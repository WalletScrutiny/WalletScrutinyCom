var Lj = Object.defineProperty;
var Mj = (lr, ar, cr) => ar in lr ? Lj(lr, ar, { enumerable: !0, configurable: !0, writable: !0, value: cr }) : lr[ar] = cr;
var Wi = (lr, ar, cr) => (Mj(lr, typeof ar != "symbol" ? ar + "" : ar, cr), cr), Ku = (lr, ar, cr) => {
  if (!ar.has(lr))
    throw TypeError("Cannot " + cr);
};
var Ya = (lr, ar, cr) => (Ku(lr, ar, "read from private field"), cr ? cr.call(lr) : ar.get(lr)), Zo = (lr, ar, cr) => {
  if (ar.has(lr))
    throw TypeError("Cannot add the same private member more than once");
  ar instanceof WeakSet ? ar.add(lr) : ar.set(lr, cr);
}, ss = (lr, ar, cr, ur) => (Ku(lr, ar, "write to private field"), ur ? ur.call(lr, cr) : ar.set(lr, cr), cr);
var go = (lr, ar, cr) => (Ku(lr, ar, "access private method"), cr);
function noop$1() {
}
const identity = (lr) => lr;
function assign$1(lr, ar) {
  for (const cr in ar)
    lr[cr] = ar[cr];
  return (
    /** @type {T & S} */
    lr
  );
}
function run$1(lr) {
  return lr();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(lr) {
  lr.forEach(run$1);
}
function is_function(lr) {
  return typeof lr == "function";
}
function safe_not_equal(lr, ar) {
  return lr != lr ? ar == ar : lr !== ar || lr && typeof lr == "object" || typeof lr == "function";
}
let src_url_equal_anchor;
function src_url_equal(lr, ar) {
  return lr === ar ? !0 : (src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = ar, lr === src_url_equal_anchor.href);
}
function is_empty(lr) {
  return Object.keys(lr).length === 0;
}
function subscribe(lr, ...ar) {
  if (lr == null) {
    for (const ur of ar)
      ur(void 0);
    return noop$1;
  }
  const cr = lr.subscribe(...ar);
  return cr.unsubscribe ? () => cr.unsubscribe() : cr;
}
function get_store_value(lr) {
  let ar;
  return subscribe(lr, (cr) => ar = cr)(), ar;
}
function component_subscribe(lr, ar, cr) {
  lr.$$.on_destroy.push(subscribe(ar, cr));
}
function create_slot(lr, ar, cr, ur) {
  if (lr) {
    const fr = get_slot_context(lr, ar, cr, ur);
    return lr[0](fr);
  }
}
function get_slot_context(lr, ar, cr, ur) {
  return lr[1] && ur ? assign$1(cr.ctx.slice(), lr[1](ur(ar))) : cr.ctx;
}
function get_slot_changes(lr, ar, cr, ur) {
  if (lr[2] && ur) {
    const fr = lr[2](ur(cr));
    if (ar.dirty === void 0)
      return fr;
    if (typeof fr == "object") {
      const dr = [], hr = Math.max(ar.dirty.length, fr.length);
      for (let gr = 0; gr < hr; gr += 1)
        dr[gr] = ar.dirty[gr] | fr[gr];
      return dr;
    }
    return ar.dirty | fr;
  }
  return ar.dirty;
}
function update_slot_base(lr, ar, cr, ur, fr, dr) {
  if (fr) {
    const hr = get_slot_context(ar, cr, ur, dr);
    lr.p(hr, fr);
  }
}
function get_all_dirty_from_scope(lr) {
  if (lr.ctx.length > 32) {
    const ar = [], cr = lr.ctx.length / 32;
    for (let ur = 0; ur < cr; ur++)
      ar[ur] = -1;
    return ar;
  }
  return -1;
}
function exclude_internal_props(lr) {
  const ar = {};
  for (const cr in lr)
    cr[0] !== "$" && (ar[cr] = lr[cr]);
  return ar;
}
function compute_rest_props(lr, ar) {
  const cr = {};
  ar = new Set(ar);
  for (const ur in lr)
    !ar.has(ur) && ur[0] !== "$" && (cr[ur] = lr[ur]);
  return cr;
}
function compute_slots(lr) {
  const ar = {};
  for (const cr in lr)
    ar[cr] = !0;
  return ar;
}
function set_store_value(lr, ar, cr) {
  return lr.set(cr), ar;
}
function action_destroyer(lr) {
  return lr && is_function(lr.destroy) ? lr.destroy : noop$1;
}
function split_css_unit(lr) {
  const ar = typeof lr == "string" && lr.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return ar ? [parseFloat(ar[1]), ar[2] || "px"] : [
    /** @type {number} */
    lr,
    "px"
  ];
}
const is_client = typeof window != "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (lr) => requestAnimationFrame(lr) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(lr) {
  tasks.forEach((ar) => {
    ar.c(lr) || (tasks.delete(ar), ar.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(lr) {
  let ar;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((cr) => {
      tasks.add(ar = { c: lr, f: cr });
    }),
    abort() {
      tasks.delete(ar);
    }
  };
}
const globals = typeof window != "undefined" ? window : typeof globalThis != "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function append(lr, ar) {
  lr.appendChild(ar);
}
function append_styles(lr, ar, cr) {
  const ur = get_root_for_style(lr);
  if (!ur.getElementById(ar)) {
    const fr = element("style");
    fr.id = ar, fr.textContent = cr, append_stylesheet(ur, fr);
  }
}
function get_root_for_style(lr) {
  if (!lr)
    return document;
  const ar = lr.getRootNode ? lr.getRootNode() : lr.ownerDocument;
  return ar && /** @type {ShadowRoot} */
  ar.host ? (
    /** @type {ShadowRoot} */
    ar
  ) : lr.ownerDocument;
}
function append_empty_stylesheet(lr) {
  const ar = element("style");
  return ar.textContent = "/* empty */", append_stylesheet(get_root_for_style(lr), ar), ar.sheet;
}
function append_stylesheet(lr, ar) {
  return append(
    /** @type {Document} */
    lr.head || lr,
    ar
  ), ar.sheet;
}
function insert(lr, ar, cr) {
  lr.insertBefore(ar, cr || null);
}
function detach(lr) {
  lr.parentNode && lr.parentNode.removeChild(lr);
}
function destroy_each(lr, ar) {
  for (let cr = 0; cr < lr.length; cr += 1)
    lr[cr] && lr[cr].d(ar);
}
function element(lr) {
  return document.createElement(lr);
}
function svg_element(lr) {
  return document.createElementNS("http://www.w3.org/2000/svg", lr);
}
function text$3(lr) {
  return document.createTextNode(lr);
}
function space() {
  return text$3(" ");
}
function empty$1() {
  return text$3("");
}
function listen(lr, ar, cr, ur) {
  return lr.addEventListener(ar, cr, ur), () => lr.removeEventListener(ar, cr, ur);
}
function prevent_default(lr) {
  return function(ar) {
    return ar.preventDefault(), lr.call(this, ar);
  };
}
function attr(lr, ar, cr) {
  cr == null ? lr.removeAttribute(ar) : lr.getAttribute(ar) !== cr && lr.setAttribute(ar, cr);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(lr, ar) {
  const cr = Object.getOwnPropertyDescriptors(lr.__proto__);
  for (const ur in ar)
    ar[ur] == null ? lr.removeAttribute(ur) : ur === "style" ? lr.style.cssText = ar[ur] : ur === "__value" ? lr.value = lr[ur] = ar[ur] : cr[ur] && cr[ur].set && always_set_through_set_attribute.indexOf(ur) === -1 ? lr[ur] = ar[ur] : attr(lr, ur, ar[ur]);
}
function init_binding_group(lr) {
  let ar;
  return {
    /* push */
    p(...cr) {
      ar = cr, ar.forEach((ur) => lr.push(ur));
    },
    /* remove */
    r() {
      ar.forEach((cr) => lr.splice(lr.indexOf(cr), 1));
    }
  };
}
function to_number(lr) {
  return lr === "" ? null : +lr;
}
function children(lr) {
  return Array.from(lr.childNodes);
}
function set_data(lr, ar) {
  ar = "" + ar, lr.data !== ar && (lr.data = /** @type {string} */
  ar);
}
function set_input_value(lr, ar) {
  lr.value = ar == null ? "" : ar;
}
function set_style(lr, ar, cr, ur) {
  cr == null ? lr.style.removeProperty(ar) : lr.style.setProperty(ar, cr, ur ? "important" : "");
}
function select_option(lr, ar, cr) {
  for (let ur = 0; ur < lr.options.length; ur += 1) {
    const fr = lr.options[ur];
    if (fr.__value === ar) {
      fr.selected = !0;
      return;
    }
  }
  (!cr || ar !== void 0) && (lr.selectedIndex = -1);
}
function select_options(lr, ar) {
  for (let cr = 0; cr < lr.options.length; cr += 1) {
    const ur = lr.options[cr];
    ur.selected = ~ar.indexOf(ur.__value);
  }
}
function select_value(lr) {
  const ar = lr.querySelector(":checked");
  return ar && ar.__value;
}
function select_multiple_value(lr) {
  return [].map.call(lr.querySelectorAll(":checked"), (ar) => ar.__value);
}
function toggle_class(lr, ar, cr) {
  lr.classList.toggle(ar, !!cr);
}
function custom_event(lr, ar, { bubbles: cr = !1, cancelable: ur = !1 } = {}) {
  return new CustomEvent(lr, { detail: ar, bubbles: cr, cancelable: ur });
}
class HtmlTag {
  constructor(ar = !1) {
    /**
     * @private
     * @default false
     */
    Wi(this, "is_svg", !1);
    /** parent for creating node */
    Wi(this, "e");
    /** html tag nodes */
    Wi(this, "n");
    /** target */
    Wi(this, "t");
    /** anchor */
    Wi(this, "a");
    this.is_svg = ar, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(ar) {
    this.h(ar);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(ar, cr, ur = null) {
    this.e || (this.is_svg ? this.e = svg_element(
      /** @type {keyof SVGElementTagNameMap} */
      cr.nodeName
    ) : this.e = element(
      /** @type {keyof HTMLElementTagNameMap} */
      cr.nodeType === 11 ? "TEMPLATE" : cr.nodeName
    ), this.t = cr.tagName !== "TEMPLATE" ? cr : (
      /** @type {HTMLTemplateElement} */
      cr.content
    ), this.c(ar)), this.i(ur);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(ar) {
    this.e.innerHTML = ar, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(ar) {
    for (let cr = 0; cr < this.n.length; cr += 1)
      insert(this.t, this.n[cr], ar);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(ar) {
    this.d(), this.h(ar), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function get_custom_elements_slots(lr) {
  const ar = {};
  return lr.childNodes.forEach(
    /** @param {Element} node */
    (cr) => {
      ar[cr.slot || "default"] = !0;
    }
  ), ar;
}
function construct_svelte_component(lr, ar) {
  return new lr(ar);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash$7(lr) {
  let ar = 5381, cr = lr.length;
  for (; cr--; )
    ar = (ar << 5) - ar ^ lr.charCodeAt(cr);
  return ar >>> 0;
}
function create_style_information(lr, ar) {
  const cr = { stylesheet: append_empty_stylesheet(ar), rules: {} };
  return managed_styles.set(lr, cr), cr;
}
function create_rule(lr, ar, cr, ur, fr, dr, hr, gr = 0) {
  const vr = 16.666 / ur;
  let mr = `{
`;
  for (let xr = 0; xr <= 1; xr += vr) {
    const Cr = ar + (cr - ar) * dr(xr);
    mr += xr * 100 + `%{${hr(Cr, 1 - Cr)}}
`;
  }
  const br = mr + `100% {${hr(cr, 1 - cr)}}
}`, yr = `__svelte_${hash$7(br)}_${gr}`, kr = get_root_for_style(lr), { stylesheet: Tr, rules: _r } = managed_styles.get(kr) || create_style_information(kr, lr);
  _r[yr] || (_r[yr] = !0, Tr.insertRule(`@keyframes ${yr} ${br}`, Tr.cssRules.length));
  const Er = lr.style.animation || "";
  return lr.style.animation = `${Er ? `${Er}, ` : ""}${yr} ${ur}ms linear ${fr}ms 1 both`, active += 1, yr;
}
function delete_rule(lr, ar) {
  const cr = (lr.style.animation || "").split(", "), ur = cr.filter(
    ar ? (dr) => dr.indexOf(ar) < 0 : (dr) => dr.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), fr = cr.length - ur.length;
  fr && (lr.style.animation = ur.join(", "), active -= fr, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((lr) => {
      const { ownerNode: ar } = lr.stylesheet;
      ar && detach(ar);
    }), managed_styles.clear());
  });
}
function create_animation(lr, ar, cr, ur) {
  if (!ar)
    return noop$1;
  const fr = lr.getBoundingClientRect();
  if (ar.left === fr.left && ar.right === fr.right && ar.top === fr.top && ar.bottom === fr.bottom)
    return noop$1;
  const {
    delay: dr = 0,
    duration: hr = 300,
    easing: gr = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: vr = now() + dr,
    // @ts-ignore todo:
    end: mr = vr + hr,
    tick: br = noop$1,
    css: yr
  } = cr(lr, { from: ar, to: fr }, ur);
  let kr = !0, Tr = !1, _r;
  function Er() {
    yr && (_r = create_rule(lr, 0, 1, hr, dr, gr, yr)), dr || (Tr = !0);
  }
  function xr() {
    yr && delete_rule(lr, _r), kr = !1;
  }
  return loop((Cr) => {
    if (!Tr && Cr >= vr && (Tr = !0), Tr && Cr >= mr && (br(1, 0), xr()), !kr)
      return !1;
    if (Tr) {
      const Ar = Cr - vr, Lr = 0 + 1 * gr(Ar / hr);
      br(Lr, 1 - Lr);
    }
    return !0;
  }), Er(), br(0, 1), xr;
}
function fix_position(lr) {
  const ar = getComputedStyle(lr);
  if (ar.position !== "absolute" && ar.position !== "fixed") {
    const { width: cr, height: ur } = ar, fr = lr.getBoundingClientRect();
    lr.style.position = "absolute", lr.style.width = cr, lr.style.height = ur, add_transform(lr, fr);
  }
}
function add_transform(lr, ar) {
  const cr = lr.getBoundingClientRect();
  if (ar.left !== cr.left || ar.top !== cr.top) {
    const ur = getComputedStyle(lr), fr = ur.transform === "none" ? "" : ur.transform;
    lr.style.transform = `${fr} translate(${ar.left - cr.left}px, ${ar.top - cr.top}px)`;
  }
}
let current_component;
function set_current_component(lr) {
  current_component = lr;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(lr) {
  get_current_component().$$.on_mount.push(lr);
}
function afterUpdate(lr) {
  get_current_component().$$.after_update.push(lr);
}
function onDestroy(lr) {
  get_current_component().$$.on_destroy.push(lr);
}
function createEventDispatcher() {
  const lr = get_current_component();
  return (ar, cr, { cancelable: ur = !1 } = {}) => {
    const fr = lr.$$.callbacks[ar];
    if (fr) {
      const dr = custom_event(
        /** @type {string} */
        ar,
        cr,
        { cancelable: ur }
      );
      return fr.slice().forEach((hr) => {
        hr.call(lr, dr);
      }), !dr.defaultPrevented;
    }
    return !0;
  };
}
function setContext(lr, ar) {
  return get_current_component().$$.context.set(lr, ar), ar;
}
function getContext(lr) {
  return get_current_component().$$.context.get(lr);
}
function bubble(lr, ar) {
  const cr = lr.$$.callbacks[ar.type];
  cr && cr.slice().forEach((ur) => ur.call(this, ar));
}
const dirty_components = [], binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [], resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(lr) {
  render_callbacks.push(lr);
}
function add_flush_callback(lr) {
  flush_callbacks.push(lr);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const lr = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const ar = dirty_components[flushidx];
        flushidx++, set_current_component(ar), update(ar.$$);
      }
    } catch (ar) {
      throw dirty_components.length = 0, flushidx = 0, ar;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let ar = 0; ar < render_callbacks.length; ar += 1) {
      const cr = render_callbacks[ar];
      seen_callbacks.has(cr) || (seen_callbacks.add(cr), cr());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(lr);
}
function update(lr) {
  if (lr.fragment !== null) {
    lr.update(), run_all(lr.before_update);
    const ar = lr.dirty;
    lr.dirty = [-1], lr.fragment && lr.fragment.p(lr.ctx, ar), lr.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(lr) {
  const ar = [], cr = [];
  render_callbacks.forEach((ur) => lr.indexOf(ur) === -1 ? ar.push(ur) : cr.push(ur)), cr.forEach((ur) => ur()), render_callbacks = ar;
}
let promise;
function wait() {
  return promise || (promise = Promise.resolve(), promise.then(() => {
    promise = null;
  })), promise;
}
function dispatch(lr, ar, cr) {
  lr.dispatchEvent(custom_event(`${ar ? "intro" : "outro"}${cr}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(lr, ar) {
  lr && lr.i && (outroing.delete(lr), lr.i(ar));
}
function transition_out(lr, ar, cr, ur) {
  if (lr && lr.o) {
    if (outroing.has(lr))
      return;
    outroing.add(lr), outros.c.push(() => {
      outroing.delete(lr), ur && (cr && lr.d(1), ur());
    }), lr.o(ar);
  } else
    ur && ur();
}
const null_transition = { duration: 0 };
function create_in_transition(lr, ar, cr) {
  const ur = { direction: "in" };
  let fr = ar(lr, cr, ur), dr = !1, hr, gr, vr = 0;
  function mr() {
    hr && delete_rule(lr, hr);
  }
  function br() {
    const {
      delay: kr = 0,
      duration: Tr = 300,
      easing: _r = identity,
      tick: Er = noop$1,
      css: xr
    } = fr || null_transition;
    xr && (hr = create_rule(lr, 0, 1, Tr, kr, _r, xr, vr++)), Er(0, 1);
    const Cr = now() + kr, Ar = Cr + Tr;
    gr && gr.abort(), dr = !0, add_render_callback(() => dispatch(lr, !0, "start")), gr = loop((Lr) => {
      if (dr) {
        if (Lr >= Ar)
          return Er(1, 0), dispatch(lr, !0, "end"), mr(), dr = !1;
        if (Lr >= Cr) {
          const Dr = _r((Lr - Cr) / Tr);
          Er(Dr, 1 - Dr);
        }
      }
      return dr;
    });
  }
  let yr = !1;
  return {
    start() {
      yr || (yr = !0, delete_rule(lr), is_function(fr) ? (fr = fr(ur), wait().then(br)) : br());
    },
    invalidate() {
      yr = !1;
    },
    end() {
      dr && (mr(), dr = !1);
    }
  };
}
function create_out_transition(lr, ar, cr) {
  const ur = { direction: "out" };
  let fr = ar(lr, cr, ur), dr = !0, hr;
  const gr = outros;
  gr.r += 1;
  let vr;
  function mr() {
    const {
      delay: br = 0,
      duration: yr = 300,
      easing: kr = identity,
      tick: Tr = noop$1,
      css: _r
    } = fr || null_transition;
    _r && (hr = create_rule(lr, 1, 0, yr, br, kr, _r));
    const Er = now() + br, xr = Er + yr;
    add_render_callback(() => dispatch(lr, !1, "start")), "inert" in lr && (vr = /** @type {HTMLElement} */
    lr.inert, lr.inert = !0), loop((Cr) => {
      if (dr) {
        if (Cr >= xr)
          return Tr(0, 1), dispatch(lr, !1, "end"), --gr.r || run_all(gr.c), !1;
        if (Cr >= Er) {
          const Ar = kr((Cr - Er) / yr);
          Tr(1 - Ar, Ar);
        }
      }
      return dr;
    });
  }
  return is_function(fr) ? wait().then(() => {
    fr = fr(ur), mr();
  }) : mr(), {
    end(br) {
      br && "inert" in lr && (lr.inert = vr), br && fr.tick && fr.tick(1, 0), dr && (hr && delete_rule(lr, hr), dr = !1);
    }
  };
}
function create_bidirectional_transition(lr, ar, cr, ur) {
  let dr = ar(lr, cr, { direction: "both" }), hr = ur ? 0 : 1, gr = null, vr = null, mr = null, br;
  function yr() {
    mr && delete_rule(lr, mr);
  }
  function kr(_r, Er) {
    const xr = (
      /** @type {Program['d']} */
      _r.b - hr
    );
    return Er *= Math.abs(xr), {
      a: hr,
      b: _r.b,
      d: xr,
      duration: Er,
      start: _r.start,
      end: _r.start + Er,
      group: _r.group
    };
  }
  function Tr(_r) {
    const {
      delay: Er = 0,
      duration: xr = 300,
      easing: Cr = identity,
      tick: Ar = noop$1,
      css: Lr
    } = dr || null_transition, Dr = {
      start: now() + Er,
      b: _r
    };
    _r || (Dr.group = outros, outros.r += 1), "inert" in lr && (_r ? br !== void 0 && (lr.inert = br) : (br = /** @type {HTMLElement} */
    lr.inert, lr.inert = !0)), gr || vr ? vr = Dr : (Lr && (yr(), mr = create_rule(lr, hr, _r, xr, Er, Cr, Lr)), _r && Ar(0, 1), gr = kr(Dr, xr), add_render_callback(() => dispatch(lr, _r, "start")), loop((Nr) => {
      if (vr && Nr > vr.start && (gr = kr(vr, xr), vr = null, dispatch(lr, gr.b, "start"), Lr && (yr(), mr = create_rule(
        lr,
        hr,
        gr.b,
        gr.duration,
        0,
        Cr,
        dr.css
      ))), gr) {
        if (Nr >= gr.end)
          Ar(hr = gr.b, 1 - hr), dispatch(lr, gr.b, "end"), vr || (gr.b ? yr() : --gr.group.r || run_all(gr.group.c)), gr = null;
        else if (Nr >= gr.start) {
          const Hr = Nr - gr.start;
          hr = gr.a + gr.d * Cr(Hr / gr.duration), Ar(hr, 1 - hr);
        }
      }
      return !!(gr || vr);
    }));
  }
  return {
    run(_r) {
      is_function(dr) ? wait().then(() => {
        dr = dr({ direction: _r ? "in" : "out" }), Tr(_r);
      }) : Tr(_r);
    },
    end() {
      yr(), gr = vr = null;
    }
  };
}
function ensure_array_like(lr) {
  return (lr == null ? void 0 : lr.length) !== void 0 ? lr : Array.from(lr);
}
function outro_and_destroy_block(lr, ar) {
  transition_out(lr, 1, 1, () => {
    ar.delete(lr.key);
  });
}
function fix_and_outro_and_destroy_block(lr, ar) {
  lr.f(), outro_and_destroy_block(lr, ar);
}
function update_keyed_each(lr, ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr) {
  let kr = lr.length, Tr = dr.length, _r = kr;
  const Er = {};
  for (; _r--; )
    Er[lr[_r].key] = _r;
  const xr = [], Cr = /* @__PURE__ */ new Map(), Ar = /* @__PURE__ */ new Map(), Lr = [];
  for (_r = Tr; _r--; ) {
    const $r = yr(fr, dr, _r), Wr = cr($r);
    let Zr = hr.get(Wr);
    Zr ? ur && Lr.push(() => Zr.p($r, ar)) : (Zr = mr(Wr, $r), Zr.c()), Cr.set(Wr, xr[_r] = Zr), Wr in Er && Ar.set(Wr, Math.abs(_r - Er[Wr]));
  }
  const Dr = /* @__PURE__ */ new Set(), Nr = /* @__PURE__ */ new Set();
  function Hr($r) {
    transition_in($r, 1), $r.m(gr, br), hr.set($r.key, $r), br = $r.first, Tr--;
  }
  for (; kr && Tr; ) {
    const $r = xr[Tr - 1], Wr = lr[kr - 1], Zr = $r.key, oi = Wr.key;
    $r === Wr ? (br = $r.first, kr--, Tr--) : Cr.has(oi) ? !hr.has(Zr) || Dr.has(Zr) ? Hr($r) : Nr.has(oi) ? kr-- : Ar.get(Zr) > Ar.get(oi) ? (Nr.add(Zr), Hr($r)) : (Dr.add(oi), kr--) : (vr(Wr, hr), kr--);
  }
  for (; kr--; ) {
    const $r = lr[kr];
    Cr.has($r.key) || vr($r, hr);
  }
  for (; Tr; )
    Hr(xr[Tr - 1]);
  return run_all(Lr), xr;
}
function get_spread_update(lr, ar) {
  const cr = {}, ur = {}, fr = { $$scope: 1 };
  let dr = lr.length;
  for (; dr--; ) {
    const hr = lr[dr], gr = ar[dr];
    if (gr) {
      for (const vr in hr)
        vr in gr || (ur[vr] = 1);
      for (const vr in gr)
        fr[vr] || (cr[vr] = gr[vr], fr[vr] = 1);
      lr[dr] = gr;
    } else
      for (const vr in hr)
        fr[vr] = 1;
  }
  for (const hr in ur)
    hr in cr || (cr[hr] = void 0);
  return cr;
}
function get_spread_object(lr) {
  return typeof lr == "object" && lr !== null ? lr : {};
}
function bind(lr, ar, cr) {
  const ur = lr.$$.props[ar];
  ur !== void 0 && (lr.$$.bound[ur] = cr, cr(lr.$$.ctx[ur]));
}
function create_component(lr) {
  lr && lr.c();
}
function mount_component(lr, ar, cr) {
  const { fragment: ur, after_update: fr } = lr.$$;
  ur && ur.m(ar, cr), add_render_callback(() => {
    const dr = lr.$$.on_mount.map(run$1).filter(is_function);
    lr.$$.on_destroy ? lr.$$.on_destroy.push(...dr) : run_all(dr), lr.$$.on_mount = [];
  }), fr.forEach(add_render_callback);
}
function destroy_component(lr, ar) {
  const cr = lr.$$;
  cr.fragment !== null && (flush_render_callbacks(cr.after_update), run_all(cr.on_destroy), cr.fragment && cr.fragment.d(ar), cr.on_destroy = cr.fragment = null, cr.ctx = []);
}
function make_dirty(lr, ar) {
  lr.$$.dirty[0] === -1 && (dirty_components.push(lr), schedule_update(), lr.$$.dirty.fill(0)), lr.$$.dirty[ar / 31 | 0] |= 1 << ar % 31;
}
function init(lr, ar, cr, ur, fr, dr, hr = null, gr = [-1]) {
  const vr = current_component;
  set_current_component(lr);
  const mr = lr.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: dr,
    update: noop$1,
    not_equal: fr,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(ar.context || (vr ? vr.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: gr,
    skip_bound: !1,
    root: ar.target || vr.$$.root
  };
  hr && hr(mr.root);
  let br = !1;
  if (mr.ctx = cr ? cr(lr, ar.props || {}, (yr, kr, ...Tr) => {
    const _r = Tr.length ? Tr[0] : kr;
    return mr.ctx && fr(mr.ctx[yr], mr.ctx[yr] = _r) && (!mr.skip_bound && mr.bound[yr] && mr.bound[yr](_r), br && make_dirty(lr, yr)), kr;
  }) : [], mr.update(), br = !0, run_all(mr.before_update), mr.fragment = ur ? ur(mr.ctx) : !1, ar.target) {
    if (ar.hydrate) {
      const yr = children(ar.target);
      mr.fragment && mr.fragment.l(yr), yr.forEach(detach);
    } else
      mr.fragment && mr.fragment.c();
    ar.intro && transition_in(lr.$$.fragment), mount_component(lr, ar.target, ar.anchor), flush();
  }
  set_current_component(vr);
}
let SvelteElement;
typeof HTMLElement == "function" && (SvelteElement = class extends HTMLElement {
  constructor(ar, cr, ur) {
    super();
    /** The Svelte component constructor */
    Wi(this, "$$ctor");
    /** Slots */
    Wi(this, "$$s");
    /** The Svelte component instance */
    Wi(this, "$$c");
    /** Whether or not the custom element is connected */
    Wi(this, "$$cn", !1);
    /** Component props data */
    Wi(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    Wi(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    Wi(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    Wi(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    Wi(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = ar, this.$$s = cr, ur && this.attachShadow({ mode: "open" });
  }
  addEventListener(ar, cr, ur) {
    if (this.$$l[ar] = this.$$l[ar] || [], this.$$l[ar].push(cr), this.$$c) {
      const fr = this.$$c.$on(ar, cr);
      this.$$l_u.set(cr, fr);
    }
    super.addEventListener(ar, cr, ur);
  }
  removeEventListener(ar, cr, ur) {
    if (super.removeEventListener(ar, cr, ur), this.$$c) {
      const fr = this.$$l_u.get(cr);
      fr && (fr(), this.$$l_u.delete(cr));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let ar = function(dr) {
        return () => {
          let hr;
          return {
            c: function() {
              hr = element("slot"), dr !== "default" && attr(hr, "name", dr);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(mr, br) {
              insert(mr, hr, br);
            },
            d: function(mr) {
              mr && detach(hr);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn)
        return;
      const cr = {}, ur = get_custom_elements_slots(this);
      for (const dr of this.$$s)
        dr in ur && (cr[dr] = [ar(dr)]);
      for (const dr of this.attributes) {
        const hr = this.$$g_p(dr.name);
        hr in this.$$d || (this.$$d[hr] = get_custom_element_value(hr, dr.value, this.$$p_d, "toProp"));
      }
      for (const dr in this.$$p_d)
        !(dr in this.$$d) && this[dr] !== void 0 && (this.$$d[dr] = this[dr], delete this[dr]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: cr,
          $$scope: {
            ctx: []
          }
        }
      });
      const fr = () => {
        this.$$r = !0;
        for (const dr in this.$$p_d)
          if (this.$$d[dr] = this.$$c.$$.ctx[this.$$c.$$.props[dr]], this.$$p_d[dr].reflect) {
            const hr = get_custom_element_value(
              dr,
              this.$$d[dr],
              this.$$p_d,
              "toAttribute"
            );
            hr == null ? this.removeAttribute(this.$$p_d[dr].attribute || dr) : this.setAttribute(this.$$p_d[dr].attribute || dr, hr);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(fr), fr();
      for (const dr in this.$$l)
        for (const hr of this.$$l[dr]) {
          const gr = this.$$c.$on(dr, hr);
          this.$$l_u.set(hr, gr);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(ar, cr, ur) {
    var fr;
    this.$$r || (ar = this.$$g_p(ar), this.$$d[ar] = get_custom_element_value(ar, ur, this.$$p_d, "toProp"), (fr = this.$$c) == null || fr.$set({ [ar]: this.$$d[ar] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(ar) {
    return Object.keys(this.$$p_d).find(
      (cr) => this.$$p_d[cr].attribute === ar || !this.$$p_d[cr].attribute && cr.toLowerCase() === ar
    ) || ar;
  }
});
function get_custom_element_value(lr, ar, cr, ur) {
  var dr;
  const fr = (dr = cr[lr]) == null ? void 0 : dr.type;
  if (ar = fr === "Boolean" && typeof ar != "boolean" ? ar != null : ar, !ur || !cr[lr])
    return ar;
  if (ur === "toAttribute")
    switch (fr) {
      case "Object":
      case "Array":
        return ar == null ? null : JSON.stringify(ar);
      case "Boolean":
        return ar ? "" : null;
      case "Number":
        return ar == null ? null : ar;
      default:
        return ar;
    }
  else
    switch (fr) {
      case "Object":
      case "Array":
        return ar && JSON.parse(ar);
      case "Boolean":
        return ar;
      case "Number":
        return ar != null ? +ar : ar;
      default:
        return ar;
    }
}
function create_custom_element(lr, ar, cr, ur, fr, dr) {
  let hr = class extends SvelteElement {
    constructor() {
      super(lr, cr, fr), this.$$p_d = ar;
    }
    static get observedAttributes() {
      return Object.keys(ar).map(
        (gr) => (ar[gr].attribute || gr).toLowerCase()
      );
    }
  };
  return Object.keys(ar).forEach((gr) => {
    Object.defineProperty(hr.prototype, gr, {
      get() {
        return this.$$c && gr in this.$$c ? this.$$c[gr] : this.$$d[gr];
      },
      set(vr) {
        var mr;
        vr = get_custom_element_value(gr, vr, ar), this.$$d[gr] = vr, (mr = this.$$c) == null || mr.$set({ [gr]: vr });
      }
    });
  }), ur.forEach((gr) => {
    Object.defineProperty(hr.prototype, gr, {
      get() {
        var vr;
        return (vr = this.$$c) == null ? void 0 : vr[gr];
      }
    });
  }), dr && (hr = dr(hr)), lr.element = /** @type {any} */
  hr, hr;
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Wi(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Wi(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(ar, cr) {
    if (!is_function(cr))
      return noop$1;
    const ur = this.$$.callbacks[ar] || (this.$$.callbacks[ar] = []);
    return ur.push(cr), () => {
      const fr = ur.indexOf(cr);
      fr !== -1 && ur.splice(fr, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(ar) {
    this.$$set && !is_empty(ar) && (this.$$.skip_bound = !0, this.$$set(ar), this.$$.skip_bound = !1);
  }
}
const PUBLIC_VERSION = "4";
typeof window != "undefined" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function readable(lr, ar) {
  return {
    subscribe: writable(lr, ar).subscribe
  };
}
function writable(lr, ar = noop$1) {
  let cr;
  const ur = /* @__PURE__ */ new Set();
  function fr(gr) {
    if (safe_not_equal(lr, gr) && (lr = gr, cr)) {
      const vr = !subscriber_queue.length;
      for (const mr of ur)
        mr[1](), subscriber_queue.push(mr, lr);
      if (vr) {
        for (let mr = 0; mr < subscriber_queue.length; mr += 2)
          subscriber_queue[mr][0](subscriber_queue[mr + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function dr(gr) {
    fr(gr(lr));
  }
  function hr(gr, vr = noop$1) {
    const mr = [gr, vr];
    return ur.add(mr), ur.size === 1 && (cr = ar(fr, dr) || noop$1), gr(lr), () => {
      ur.delete(mr), ur.size === 0 && cr && (cr(), cr = null);
    };
  }
  return { set: fr, update: dr, subscribe: hr };
}
const storeHighlightJs = writable(void 0), tocStore = writable([]), tocActiveId = writable(void 0), DRAWER_STORE_KEY = "drawerStore";
function getDrawerStore() {
  const lr = getContext(DRAWER_STORE_KEY);
  if (!lr)
    throw new Error("drawerStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const MODAL_STORE_KEY = "modalStore";
function getModalStore() {
  const lr = getContext(MODAL_STORE_KEY);
  if (!lr)
    throw new Error("modalStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const TOAST_STORE_KEY = "toastStore";
function getToastStore() {
  const lr = getContext(TOAST_STORE_KEY);
  if (!lr)
    throw new Error("toastStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const stores = {};
function getStorage(lr) {
  return lr === "local" ? localStorage : sessionStorage;
}
function localStorageStore(lr, ar, cr) {
  var hr, gr;
  const ur = (hr = cr == null ? void 0 : cr.serializer) != null ? hr : JSON, fr = (gr = cr == null ? void 0 : cr.storage) != null ? gr : "local";
  function dr(vr, mr) {
    getStorage(fr).setItem(vr, ur.stringify(mr));
  }
  if (!stores[lr]) {
    const vr = writable(ar, (yr) => {
      const kr = getStorage(fr).getItem(lr);
      kr && yr(ur.parse(kr));
      {
        const Tr = (_r) => {
          _r.key === lr && yr(_r.newValue ? ur.parse(_r.newValue) : null);
        };
        return window.addEventListener("storage", Tr), () => window.removeEventListener("storage", Tr);
      }
    }), { subscribe: mr, set: br } = vr;
    stores[lr] = {
      set(yr) {
        dr(lr, yr), br(yr);
      },
      update(yr) {
        const kr = yr(get_store_value(vr));
        dr(lr, kr), br(kr);
      },
      subscribe: mr
    };
  }
  return stores[lr];
}
const modeOsPrefers = localStorageStore("modeOsPrefers", !1), modeUserPrefers = localStorageStore("modeUserPrefers", void 0), modeCurrent = localStorageStore("modeCurrent", !1);
function getModeOsPrefers() {
  const lr = window.matchMedia("(prefers-color-scheme: light)").matches;
  return modeOsPrefers.set(lr), lr;
}
function setModeUserPrefers(lr) {
  modeUserPrefers.set(lr);
}
function setModeCurrent(lr) {
  const ar = document.documentElement.classList, cr = "dark";
  lr === !0 ? ar.remove(cr) : ar.add(cr), modeCurrent.set(lr);
}
function setInitialClassState() {
  const lr = document.documentElement.classList, ar = localStorage.getItem("modeUserPrefers") === "false", cr = !("modeUserPrefers" in localStorage), ur = window.matchMedia("(prefers-color-scheme: dark)").matches;
  ar || cr && ur ? lr.add("dark") : lr.remove("dark");
}
const reducedMotionQuery = "(prefers-reduced-motion: reduce)";
function prefersReducedMotion() {
  return window.matchMedia(reducedMotionQuery).matches;
}
const prefersReducedMotionStore = readable(prefersReducedMotion(), (lr) => {
  {
    const ar = (ur) => {
      lr(ur.matches);
    }, cr = window.matchMedia(reducedMotionQuery);
    return cr.addEventListener("change", ar), () => {
      cr.removeEventListener("change", ar);
    };
  }
});
function clipboard(lr, ar) {
  if (!window.isSecureContext) {
    console.error("Clipboard action failed: app not running in secure context, see: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard");
    return;
  }
  const cr = () => {
    lr.dispatchEvent(new CustomEvent("copyComplete"));
  }, ur = () => {
    if (typeof ar == "object") {
      if ("element" in ar) {
        const fr = document.querySelector(`[data-clipboard="${ar.element}"]`);
        if (!fr)
          throw new Error(`Missing HTMLElement with an attribute of [data-clipboard="${ar.element}"]`);
        copyToClipboard(fr.innerHTML, "text/html").then(cr);
        return;
      }
      if ("input" in ar) {
        const fr = document.querySelector(`[data-clipboard="${ar.input}"]`);
        if (!fr)
          throw new Error(`Missing HTMLInputElement with an attribute of [data-clipboard="${ar.input}"]`);
        copyToClipboard(fr.value).then(cr);
        return;
      }
    }
    copyToClipboard(ar).then(cr);
  };
  return lr.addEventListener("click", ur), {
    update(fr) {
      ar = fr;
    },
    destroy() {
      lr.removeEventListener("click", ur);
    }
  };
}
async function copyToClipboard(lr, ar = "text/plain") {
  navigator.clipboard.write ? await navigator.clipboard.write([
    new ClipboardItem({
      [ar]: new Blob([lr], {
        type: ar
      }),
      "text/plain": new Blob([lr], {
        type: "text/plain"
      })
    })
  ]) : await new Promise((cr) => {
    cr(navigator.clipboard.writeText(String(lr)));
  });
}
function focusTrap(lr, ar) {
  const cr = 'a[href]:not([tabindex="-1"]), button:not([tabindex="-1"]), input:not([tabindex="-1"]), textarea:not([tabindex="-1"]), select:not([tabindex="-1"]), details:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])';
  let ur, fr;
  function dr(yr) {
    yr.shiftKey && yr.code === "Tab" && (yr.preventDefault(), fr.focus());
  }
  function hr(yr) {
    !yr.shiftKey && yr.code === "Tab" && (yr.preventDefault(), ur.focus());
  }
  const gr = (yr) => {
    if (ar === !1)
      return;
    const kr = Array.from(lr.querySelectorAll(cr));
    kr.length && (ur = kr[0], fr = kr[kr.length - 1], yr || ur.focus(), ur.addEventListener("keydown", dr), fr.addEventListener("keydown", hr));
  };
  gr(!1);
  function vr() {
    ur && ur.removeEventListener("keydown", dr), fr && fr.removeEventListener("keydown", hr);
  }
  const mr = (yr, kr) => (yr.length && (vr(), gr(!0)), kr), br = new MutationObserver(mr);
  return br.observe(lr, { childList: !0, subtree: !0 }), {
    update(yr) {
      ar = yr, yr ? gr(!1) : vr();
    },
    destroy() {
      vr(), br.disconnect();
    }
  };
}
function cubicIn(lr) {
  return lr * lr * lr;
}
function cubicOut(lr) {
  const ar = lr - 1;
  return ar * ar * ar + 1;
}
function fade(lr, { delay: ar = 0, duration: cr = 400, easing: ur = identity } = {}) {
  const fr = +getComputedStyle(lr).opacity;
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (dr) => `opacity: ${dr * fr}`
  };
}
function fly(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, x: fr = 0, y: dr = 0, opacity: hr = 0 } = {}) {
  const gr = getComputedStyle(lr), vr = +gr.opacity, mr = gr.transform === "none" ? "" : gr.transform, br = vr * (1 - hr), [yr, kr] = split_css_unit(fr), [Tr, _r] = split_css_unit(dr);
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (Er, xr) => `
			transform: ${mr} translate(${(1 - Er) * yr}${kr}, ${(1 - Er) * Tr}${_r});
			opacity: ${vr - br * xr}`
  };
}
function slide(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, axis: fr = "y" } = {}) {
  const dr = getComputedStyle(lr), hr = +dr.opacity, gr = fr === "y" ? "height" : "width", vr = parseFloat(dr[gr]), mr = fr === "y" ? ["top", "bottom"] : ["left", "right"], br = mr.map(
    (Cr) => `${Cr[0].toUpperCase()}${Cr.slice(1)}`
  ), yr = parseFloat(dr[`padding${br[0]}`]), kr = parseFloat(dr[`padding${br[1]}`]), Tr = parseFloat(dr[`margin${br[0]}`]), _r = parseFloat(dr[`margin${br[1]}`]), Er = parseFloat(
    dr[`border${br[0]}Width`]
  ), xr = parseFloat(
    dr[`border${br[1]}Width`]
  );
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (Cr) => `overflow: hidden;opacity: ${Math.min(Cr * 20, 1) * hr};${gr}: ${Cr * vr}px;padding-${mr[0]}: ${Cr * yr}px;padding-${mr[1]}: ${Cr * kr}px;margin-${mr[0]}: ${Cr * Tr}px;margin-${mr[1]}: ${Cr * _r}px;border-${mr[0]}-width: ${Cr * Er}px;border-${mr[1]}-width: ${Cr * xr}px;`
  };
}
function scale(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, start: fr = 0, opacity: dr = 0 } = {}) {
  const hr = getComputedStyle(lr), gr = +hr.opacity, vr = hr.transform === "none" ? "" : hr.transform, mr = 1 - fr, br = gr * (1 - dr);
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (yr, kr) => `
			transform: ${vr} scale(${1 - mr * kr});
			opacity: ${gr - br * kr}
		`
  };
}
function create_fragment$17(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "accordion " + /*classesBase*/
      lr[0]), attr(ar, "data-testid", "accordion");
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, [gr]) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[18],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[18]
        ),
        null
      ), (!ur || gr & /*classesBase*/
      1 && cr !== (cr = "accordion " + /*classesBase*/
      hr[0])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function instance$O(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, prefersReducedMotionStore, (Zr) => cr(20, fr = Zr));
  let { $$slots: dr = {}, $$scope: hr } = ar, { autocollapse: gr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: mr = "space-y-1" } = ar, { disabled: br = !1 } = ar, { padding: yr = "py-2 px-4" } = ar, { hover: kr = "hover:bg-primary-hover-token" } = ar, { rounded: Tr = "rounded-container-token" } = ar, { caretOpen: _r = "rotate-180" } = ar, { caretClosed: Er = "" } = ar, { regionControl: xr = "" } = ar, { regionPanel: Cr = "space-y-4" } = ar, { regionCaret: Ar = "" } = ar, { transitions: Lr = !fr } = ar, { transitionIn: Dr = slide } = ar, { transitionInParams: Nr = { duration: 200 } } = ar, { transitionOut: Hr = slide } = ar, { transitionOutParams: $r = { duration: 200 } } = ar;
  const Wr = writable(null);
  return setContext("active", Wr), setContext("autocollapse", gr), setContext("disabled", br), setContext("padding", yr), setContext("hover", kr), setContext("rounded", Tr), setContext("caretOpen", _r), setContext("caretClosed", Er), setContext("regionControl", xr), setContext("regionPanel", Cr), setContext("regionCaret", Ar), setContext("transitions", Lr), setContext("transitionIn", Dr), setContext("transitionInParams", Nr), setContext("transitionOut", Hr), setContext("transitionOutParams", $r), lr.$$set = (Zr) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Zr))), "autocollapse" in Zr && cr(1, gr = Zr.autocollapse), "width" in Zr && cr(2, vr = Zr.width), "spacing" in Zr && cr(3, mr = Zr.spacing), "disabled" in Zr && cr(4, br = Zr.disabled), "padding" in Zr && cr(5, yr = Zr.padding), "hover" in Zr && cr(6, kr = Zr.hover), "rounded" in Zr && cr(7, Tr = Zr.rounded), "caretOpen" in Zr && cr(8, _r = Zr.caretOpen), "caretClosed" in Zr && cr(9, Er = Zr.caretClosed), "regionControl" in Zr && cr(10, xr = Zr.regionControl), "regionPanel" in Zr && cr(11, Cr = Zr.regionPanel), "regionCaret" in Zr && cr(12, Ar = Zr.regionCaret), "transitions" in Zr && cr(13, Lr = Zr.transitions), "transitionIn" in Zr && cr(14, Dr = Zr.transitionIn), "transitionInParams" in Zr && cr(15, Nr = Zr.transitionInParams), "transitionOut" in Zr && cr(16, Hr = Zr.transitionOut), "transitionOutParams" in Zr && cr(17, $r = Zr.transitionOutParams), "$$scope" in Zr && cr(18, hr = Zr.$$scope);
  }, lr.$$.update = () => {
    var Zr;
    cr(0, ur = `${vr} ${mr} ${(Zr = ar.class) != null ? Zr : ""}`);
  }, ar = exclude_internal_props(ar), [
    ur,
    gr,
    vr,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    hr,
    dr
  ];
}
class Accordion extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$O, create_fragment$17, safe_not_equal, {
      autocollapse: 1,
      width: 2,
      spacing: 3,
      disabled: 4,
      padding: 5,
      hover: 6,
      rounded: 7,
      caretOpen: 8,
      caretClosed: 9,
      regionControl: 10,
      regionPanel: 11,
      regionCaret: 12,
      transitions: 13,
      transitionIn: 14,
      transitionInParams: 15,
      transitionOut: 16,
      transitionOutParams: 17
    });
  }
  get autocollapse() {
    return this.$$.ctx[1];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get width() {
    return this.$$.ctx[2];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[4];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[5];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[7];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[8];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[9];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[10];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[11];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[12];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[13];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[14];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[15];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[16];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[17];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Accordion, { autocollapse: { type: "Boolean" }, width: {}, spacing: {}, disabled: { type: "Boolean" }, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
function dynamicTransition(lr, ar) {
  const { transition: cr, params: ur, enabled: fr } = ar;
  return fr ? cr(lr, ur) : "duration" in ur ? cr(lr, { duration: 0 }) : { duration: 0 };
}
const get_content_slot_changes = (lr) => ({}), get_content_slot_context = (lr) => ({}), get_summary_slot_changes = (lr) => ({}), get_summary_slot_context = (lr) => ({}), get_lead_slot_changes$9 = (lr) => ({}), get_lead_slot_context$9 = (lr) => ({});
function create_if_block_1$h(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[28].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[27],
    get_lead_slot_context$9
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "accordion-lead");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr[0] & /*$$scope*/
      134217728) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[27],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[27],
          hr,
          get_lead_slot_changes$9
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[27]
        ),
        get_lead_slot_context$9
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function fallback_block_1$2(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(summary)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block$y(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  const mr = (
    /*#slots*/
    lr[28].content
  ), br = create_slot(
    mr,
    lr,
    /*$$scope*/
    lr[27],
    get_content_slot_context
  ), yr = br || fallback_block$5();
  return {
    c() {
      ar = element("div"), yr && yr.c(), attr(ar, "class", cr = "accordion-panel " + /*classesPanel*/
      lr[9]), attr(ar, "id", ur = "accordion-panel-" + /*id*/
      lr[0]), attr(ar, "role", "region"), attr(ar, "aria-hidden", fr = !/*openState*/
      lr[8]), attr(ar, "aria-labelledby", dr = "accordion-control-" + /*id*/
      lr[0]);
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), yr && yr.m(ar, null), vr = !0;
    },
    p(kr, Tr) {
      lr = kr, br && br.p && (!vr || Tr[0] & /*$$scope*/
      134217728) && update_slot_base(
        br,
        mr,
        lr,
        /*$$scope*/
        lr[27],
        vr ? get_slot_changes(
          mr,
          /*$$scope*/
          lr[27],
          Tr,
          get_content_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          lr[27]
        ),
        get_content_slot_context
      ), (!vr || Tr[0] & /*classesPanel*/
      512 && cr !== (cr = "accordion-panel " + /*classesPanel*/
      lr[9])) && attr(ar, "class", cr), (!vr || Tr[0] & /*id*/
      1 && ur !== (ur = "accordion-panel-" + /*id*/
      lr[0])) && attr(ar, "id", ur), (!vr || Tr[0] & /*openState*/
      256 && fr !== (fr = !/*openState*/
      lr[8])) && attr(ar, "aria-hidden", fr), (!vr || Tr[0] & /*id*/
      1 && dr !== (dr = "accordion-control-" + /*id*/
      lr[0])) && attr(ar, "aria-labelledby", dr);
    },
    i(kr) {
      vr || (transition_in(yr, kr), kr && add_render_callback(() => {
        vr && (gr && gr.end(1), hr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[4]
          ),
          params: (
            /*transitionInParams*/
            lr[5]
          ),
          enabled: (
            /*transitions*/
            lr[3]
          )
        }), hr.start());
      }), vr = !0);
    },
    o(kr) {
      transition_out(yr, kr), hr && hr.invalidate(), kr && (gr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[6]
        ),
        params: (
          /*transitionOutParams*/
          lr[7]
        ),
        enabled: (
          /*transitions*/
          lr[3]
        )
      })), vr = !1;
    },
    d(kr) {
      kr && detach(ar), yr && yr.d(kr), kr && gr && gr.end();
    }
  };
}
function fallback_block$5(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(content)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_fragment$16(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar = (
    /*$$slots*/
    lr[14].lead && create_if_block_1$h(lr)
  );
  const Lr = (
    /*#slots*/
    lr[28].summary
  ), Dr = create_slot(
    Lr,
    lr,
    /*$$scope*/
    lr[27],
    get_summary_slot_context
  ), Nr = Dr || fallback_block_1$2();
  let Hr = (
    /*openState*/
    lr[8] && create_if_block$y(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("button"), Ar && Ar.c(), ur = space(), fr = element("div"), Nr && Nr.c(), dr = space(), hr = element("div"), gr = svg_element("svg"), vr = svg_element("path"), Tr = space(), Hr && Hr.c(), attr(fr, "class", "accordion-summary flex-1"), attr(vr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(gr, "xmlns", "http://www.w3.org/2000/svg"), attr(gr, "viewBox", "0 0 448 512"), attr(hr, "class", mr = "accordion-summary-caret " + /*classesControlCaret*/
      lr[10]), attr(cr, "type", "button"), attr(cr, "class", br = "accordion-control " + /*classesControl*/
      lr[11]), attr(cr, "id", yr = "accordion-control-" + /*id*/
      lr[0]), attr(
        cr,
        "aria-expanded",
        /*openState*/
        lr[8]
      ), attr(cr, "aria-controls", kr = "accordion-panel-" + /*id*/
      lr[0]), cr.disabled = /*disabled*/
      lr[2], attr(ar, "class", _r = "accordion-item " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "accordion-item");
    },
    m($r, Wr) {
      insert($r, ar, Wr), append(ar, cr), Ar && Ar.m(cr, null), append(cr, ur), append(cr, fr), Nr && Nr.m(fr, null), append(cr, dr), append(cr, hr), append(hr, gr), append(gr, vr), append(ar, Tr), Hr && Hr.m(ar, null), Er = !0, xr || (Cr = [
        listen(
          cr,
          "click",
          /*setActive*/
          lr[13]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[29]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[30]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[31]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[32]
        )
      ], xr = !0);
    },
    p($r, Wr) {
      /*$$slots*/
      $r[14].lead ? Ar ? (Ar.p($r, Wr), Wr[0] & /*$$slots*/
      16384 && transition_in(Ar, 1)) : (Ar = create_if_block_1$h($r), Ar.c(), transition_in(Ar, 1), Ar.m(cr, ur)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), Dr && Dr.p && (!Er || Wr[0] & /*$$scope*/
      134217728) && update_slot_base(
        Dr,
        Lr,
        $r,
        /*$$scope*/
        $r[27],
        Er ? get_slot_changes(
          Lr,
          /*$$scope*/
          $r[27],
          Wr,
          get_summary_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          $r[27]
        ),
        get_summary_slot_context
      ), (!Er || Wr[0] & /*classesControlCaret*/
      1024 && mr !== (mr = "accordion-summary-caret " + /*classesControlCaret*/
      $r[10])) && attr(hr, "class", mr), (!Er || Wr[0] & /*classesControl*/
      2048 && br !== (br = "accordion-control " + /*classesControl*/
      $r[11])) && attr(cr, "class", br), (!Er || Wr[0] & /*id*/
      1 && yr !== (yr = "accordion-control-" + /*id*/
      $r[0])) && attr(cr, "id", yr), (!Er || Wr[0] & /*openState*/
      256) && attr(
        cr,
        "aria-expanded",
        /*openState*/
        $r[8]
      ), (!Er || Wr[0] & /*id*/
      1 && kr !== (kr = "accordion-panel-" + /*id*/
      $r[0])) && attr(cr, "aria-controls", kr), (!Er || Wr[0] & /*disabled*/
      4) && (cr.disabled = /*disabled*/
      $r[2]), /*openState*/
      $r[8] ? Hr ? (Hr.p($r, Wr), Wr[0] & /*openState*/
      256 && transition_in(Hr, 1)) : (Hr = create_if_block$y($r), Hr.c(), transition_in(Hr, 1), Hr.m(ar, null)) : Hr && (group_outros(), transition_out(Hr, 1, 1, () => {
        Hr = null;
      }), check_outros()), (!Er || Wr[0] & /*classesBase*/
      4096 && _r !== (_r = "accordion-item " + /*classesBase*/
      $r[12])) && attr(ar, "class", _r);
    },
    i($r) {
      Er || (transition_in(Ar), transition_in(Nr, $r), transition_in(Hr), Er = !0);
    },
    o($r) {
      transition_out(Ar), transition_out(Nr, $r), transition_out(Hr), Er = !1;
    },
    d($r) {
      $r && detach(ar), Ar && Ar.d(), Nr && Nr.d($r), Hr && Hr.d(), xr = !1, run_all(Cr);
    }
  };
}
const cBase$p = "", cControl = "text-start w-full flex items-center space-x-4", cControlCaret = "fill-current w-3 transition-transform duration-[200ms]", cPanel$1 = "";
function instance$N(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br = noop$1, yr = () => (br(), br = subscribe(Lr, (yi) => cr(26, mr = yi)), Lr);
  lr.$$.on_destroy.push(() => br());
  let { $$slots: kr = {}, $$scope: Tr } = ar;
  const _r = compute_slots(kr), Er = createEventDispatcher();
  let { open: xr = !1 } = ar, { id: Cr = String(Math.random()) } = ar, { autocollapse: Ar = getContext("autocollapse") } = ar, { active: Lr = getContext("active") } = ar;
  yr();
  let { disabled: Dr = getContext("disabled") } = ar, { padding: Nr = getContext("padding") } = ar, { hover: Hr = getContext("hover") } = ar, { rounded: $r = getContext("rounded") } = ar, { caretOpen: Wr = getContext("caretOpen") } = ar, { caretClosed: Zr = getContext("caretClosed") } = ar, { regionControl: oi = getContext("regionControl") } = ar, { regionPanel: Jr = getContext("regionPanel") } = ar, { regionCaret: Yr = getContext("regionCaret") } = ar, { transitions: li = getContext("transitions") } = ar, { transitionIn: Si = getContext("transitionIn") } = ar, { transitionInParams: ci = getContext("transitionInParams") } = ar, { transitionOut: hi = getContext("transitionOut") } = ar, { transitionOutParams: Ei = getContext("transitionOutParams") } = ar;
  function di(yi) {
    Ar === !0 ? Lr.set(Cr) : cr(15, xr = !xr), gi(yi);
  }
  function gi(yi) {
    const Vi = Ar ? mr === Cr : xr;
    Er("toggle", {
      event: yi,
      id: `accordion-control-${Cr}`,
      open: Vi,
      autocollapse: Ar
    });
  }
  Ar && xr && di();
  function Li(yi) {
    bubble.call(this, lr, yi);
  }
  function ui(yi) {
    bubble.call(this, lr, yi);
  }
  function wi(yi) {
    bubble.call(this, lr, yi);
  }
  function Ui(yi) {
    bubble.call(this, lr, yi);
  }
  return lr.$$set = (yi) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(yi))), "open" in yi && cr(15, xr = yi.open), "id" in yi && cr(0, Cr = yi.id), "autocollapse" in yi && cr(16, Ar = yi.autocollapse), "active" in yi && yr(cr(1, Lr = yi.active)), "disabled" in yi && cr(2, Dr = yi.disabled), "padding" in yi && cr(17, Nr = yi.padding), "hover" in yi && cr(18, Hr = yi.hover), "rounded" in yi && cr(19, $r = yi.rounded), "caretOpen" in yi && cr(20, Wr = yi.caretOpen), "caretClosed" in yi && cr(21, Zr = yi.caretClosed), "regionControl" in yi && cr(22, oi = yi.regionControl), "regionPanel" in yi && cr(23, Jr = yi.regionPanel), "regionCaret" in yi && cr(24, Yr = yi.regionCaret), "transitions" in yi && cr(3, li = yi.transitions), "transitionIn" in yi && cr(4, Si = yi.transitionIn), "transitionInParams" in yi && cr(5, ci = yi.transitionInParams), "transitionOut" in yi && cr(6, hi = yi.transitionOut), "transitionOutParams" in yi && cr(7, Ei = yi.transitionOutParams), "$$scope" in yi && cr(27, Tr = yi.$$scope);
  }, lr.$$.update = () => {
    var yi;
    lr.$$.dirty[0] & /*open, autocollapse*/
    98304 && xr && Ar && di(), lr.$$.dirty[0] & /*autocollapse, $active, id, open*/
    67207169 && cr(8, ur = Ar ? mr === Cr : xr), cr(12, fr = `${cBase$p} ${(yi = ar.class) != null ? yi : ""}`), lr.$$.dirty[0] & /*padding, hover, rounded, regionControl*/
    5111808 && cr(11, dr = `${cControl} ${Nr} ${Hr} ${$r} ${oi}`), lr.$$.dirty[0] & /*openState, caretOpen, caretClosed*/
    3145984 && cr(25, hr = ur ? Wr : Zr), lr.$$.dirty[0] & /*regionCaret, classesCaretState*/
    50331648 && cr(10, gr = `${cControlCaret} ${Yr} ${hr}`), lr.$$.dirty[0] & /*padding, rounded, regionPanel*/
    9043968 && cr(9, vr = `${cPanel$1} ${Nr} ${$r} ${Jr}`);
  }, ar = exclude_internal_props(ar), [
    Cr,
    Lr,
    Dr,
    li,
    Si,
    ci,
    hi,
    Ei,
    ur,
    vr,
    gr,
    dr,
    fr,
    di,
    _r,
    xr,
    Ar,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    hr,
    mr,
    Tr,
    kr,
    Li,
    ui,
    wi,
    Ui
  ];
}
class AccordionItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$N,
      create_fragment$16,
      safe_not_equal,
      {
        open: 15,
        id: 0,
        autocollapse: 16,
        active: 1,
        disabled: 2,
        padding: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        regionControl: 22,
        regionPanel: 23,
        regionCaret: 24,
        transitions: 3,
        transitionIn: 4,
        transitionInParams: 5,
        transitionOut: 6,
        transitionOutParams: 7
      },
      null,
      [-1, -1]
    );
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get autocollapse() {
    return this.$$.ctx[16];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[2];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[22];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[23];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[24];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[3];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[4];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[5];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[6];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[7];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(AccordionItem, { open: { type: "Boolean" }, id: {}, autocollapse: {}, active: {}, disabled: {}, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["lead", "summary", "content"], [], !0);
const get_headline_slot_changes = (lr) => ({}), get_headline_slot_context = (lr) => ({}), get_trail_slot_changes$3 = (lr) => ({}), get_trail_slot_context$3 = (lr) => ({}), get_lead_slot_changes$8 = (lr) => ({}), get_lead_slot_context$8 = (lr) => ({});
function create_if_block_2$d(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_lead_slot_context$8
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-slot-lead " + /*classesSlotLead*/
      lr[4]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[21],
          gr,
          get_lead_slot_changes$8
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[21]
        ),
        get_lead_slot_context$8
      ), (!ur || gr & /*classesSlotLead*/
      16 && cr !== (cr = "app-bar-slot-lead " + /*classesSlotLead*/
      hr[4])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_if_block_1$g(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].trail
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_trail_slot_context$3
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-slot-trail " + /*classesSlotTrail*/
      lr[2]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[21],
          gr,
          get_trail_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[21]
        ),
        get_trail_slot_context$3
      ), (!ur || gr & /*classesSlotTrail*/
      4 && cr !== (cr = "app-bar-slot-trail " + /*classesSlotTrail*/
      hr[2])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_if_block$x(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].headline
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_headline_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-row-headline " + /*classesRowHeadline*/
      lr[5]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[21],
          gr,
          get_headline_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[21]
        ),
        get_headline_slot_context
      ), (!ur || gr & /*classesRowHeadline*/
      32 && cr !== (cr = "app-bar-row-headline " + /*classesRowHeadline*/
      hr[5])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$15(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr = (
    /*$$slots*/
    lr[8].lead && create_if_block_2$d(lr)
  );
  const kr = (
    /*#slots*/
    lr[22].default
  ), Tr = create_slot(
    kr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  let _r = (
    /*$$slots*/
    lr[8].trail && create_if_block_1$g(lr)
  ), Er = (
    /*$$slots*/
    lr[8].headline && create_if_block$x(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), yr && yr.c(), ur = space(), fr = element("div"), Tr && Tr.c(), hr = space(), _r && _r.c(), vr = space(), Er && Er.c(), attr(fr, "class", dr = "app-bar-slot-default " + /*classesSlotDefault*/
      lr[3]), attr(cr, "class", gr = "app-bar-row-main " + /*classesRowMain*/
      lr[6]), attr(ar, "class", mr = "app-bar " + /*classesBase*/
      lr[7]), attr(ar, "data-testid", "app-bar"), attr(ar, "role", "toolbar"), attr(
        ar,
        "aria-label",
        /*label*/
        lr[0]
      ), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[1]
      );
    },
    m(xr, Cr) {
      insert(xr, ar, Cr), append(ar, cr), yr && yr.m(cr, null), append(cr, ur), append(cr, fr), Tr && Tr.m(fr, null), append(cr, hr), _r && _r.m(cr, null), append(ar, vr), Er && Er.m(ar, null), br = !0;
    },
    p(xr, [Cr]) {
      /*$$slots*/
      xr[8].lead ? yr ? (yr.p(xr, Cr), Cr & /*$$slots*/
      256 && transition_in(yr, 1)) : (yr = create_if_block_2$d(xr), yr.c(), transition_in(yr, 1), yr.m(cr, ur)) : yr && (group_outros(), transition_out(yr, 1, 1, () => {
        yr = null;
      }), check_outros()), Tr && Tr.p && (!br || Cr & /*$$scope*/
      2097152) && update_slot_base(
        Tr,
        kr,
        xr,
        /*$$scope*/
        xr[21],
        br ? get_slot_changes(
          kr,
          /*$$scope*/
          xr[21],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          xr[21]
        ),
        null
      ), (!br || Cr & /*classesSlotDefault*/
      8 && dr !== (dr = "app-bar-slot-default " + /*classesSlotDefault*/
      xr[3])) && attr(fr, "class", dr), /*$$slots*/
      xr[8].trail ? _r ? (_r.p(xr, Cr), Cr & /*$$slots*/
      256 && transition_in(_r, 1)) : (_r = create_if_block_1$g(xr), _r.c(), transition_in(_r, 1), _r.m(cr, null)) : _r && (group_outros(), transition_out(_r, 1, 1, () => {
        _r = null;
      }), check_outros()), (!br || Cr & /*classesRowMain*/
      64 && gr !== (gr = "app-bar-row-main " + /*classesRowMain*/
      xr[6])) && attr(cr, "class", gr), /*$$slots*/
      xr[8].headline ? Er ? (Er.p(xr, Cr), Cr & /*$$slots*/
      256 && transition_in(Er, 1)) : (Er = create_if_block$x(xr), Er.c(), transition_in(Er, 1), Er.m(ar, null)) : Er && (group_outros(), transition_out(Er, 1, 1, () => {
        Er = null;
      }), check_outros()), (!br || Cr & /*classesBase*/
      128 && mr !== (mr = "app-bar " + /*classesBase*/
      xr[7])) && attr(ar, "class", mr), (!br || Cr & /*label*/
      1) && attr(
        ar,
        "aria-label",
        /*label*/
        xr[0]
      ), (!br || Cr & /*labelledby*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        xr[1]
      );
    },
    i(xr) {
      br || (transition_in(yr), transition_in(Tr, xr), transition_in(_r), transition_in(Er), br = !0);
    },
    o(xr) {
      transition_out(yr), transition_out(Tr, xr), transition_out(_r), transition_out(Er), br = !1;
    },
    d(xr) {
      xr && detach(ar), yr && yr.d(), Tr && Tr.d(xr), _r && _r.d(), Er && Er.d();
    }
  };
}
const cBase$o = "flex flex-col", cRowMain = "grid items-center", cRowHeadline = "", cSlotLead = "flex-none flex justify-between items-center", cSlotDefault = "flex-auto", cSlotTrail = "flex-none flex items-center space-x-4";
function instance$M(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, { $$slots: mr = {}, $$scope: br } = ar;
  const yr = compute_slots(mr);
  let { background: kr = "bg-surface-100-800-token" } = ar, { border: Tr = "" } = ar, { padding: _r = "p-4" } = ar, { shadow: Er = "" } = ar, { spacing: xr = "space-y-4" } = ar, { gridColumns: Cr = "grid-cols-[auto_1fr_auto]" } = ar, { gap: Ar = "gap-4" } = ar, { regionRowMain: Lr = "" } = ar, { regionRowHeadline: Dr = "" } = ar, { slotLead: Nr = "" } = ar, { slotDefault: Hr = "" } = ar, { slotTrail: $r = "" } = ar, { label: Wr = "" } = ar, { labelledby: Zr = "" } = ar;
  return lr.$$set = (oi) => {
    cr(23, ar = assign$1(assign$1({}, ar), exclude_internal_props(oi))), "background" in oi && cr(9, kr = oi.background), "border" in oi && cr(10, Tr = oi.border), "padding" in oi && cr(11, _r = oi.padding), "shadow" in oi && cr(12, Er = oi.shadow), "spacing" in oi && cr(13, xr = oi.spacing), "gridColumns" in oi && cr(14, Cr = oi.gridColumns), "gap" in oi && cr(15, Ar = oi.gap), "regionRowMain" in oi && cr(16, Lr = oi.regionRowMain), "regionRowHeadline" in oi && cr(17, Dr = oi.regionRowHeadline), "slotLead" in oi && cr(18, Nr = oi.slotLead), "slotDefault" in oi && cr(19, Hr = oi.slotDefault), "slotTrail" in oi && cr(20, $r = oi.slotTrail), "label" in oi && cr(0, Wr = oi.label), "labelledby" in oi && cr(1, Zr = oi.labelledby), "$$scope" in oi && cr(21, br = oi.$$scope);
  }, lr.$$.update = () => {
    var oi;
    cr(7, ur = `${cBase$o} ${kr} ${Tr} ${xr} ${_r} ${Er} ${(oi = ar.class) != null ? oi : ""}`), lr.$$.dirty & /*gridColumns, gap, regionRowMain*/
    114688 && cr(6, fr = `${cRowMain} ${Cr} ${Ar} ${Lr}`), lr.$$.dirty & /*regionRowHeadline*/
    131072 && cr(5, dr = `${cRowHeadline} ${Dr}`), lr.$$.dirty & /*slotLead*/
    262144 && cr(4, hr = `${cSlotLead} ${Nr}`), lr.$$.dirty & /*slotDefault*/
    524288 && cr(3, gr = `${cSlotDefault} ${Hr}`), lr.$$.dirty & /*slotTrail*/
    1048576 && cr(2, vr = `${cSlotTrail} ${$r}`);
  }, ar = exclude_internal_props(ar), [
    Wr,
    Zr,
    vr,
    gr,
    hr,
    dr,
    fr,
    ur,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    br,
    mr
  ];
}
class AppBar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$M, create_fragment$15, safe_not_equal, {
      background: 9,
      border: 10,
      padding: 11,
      shadow: 12,
      spacing: 13,
      gridColumns: 14,
      gap: 15,
      regionRowMain: 16,
      regionRowHeadline: 17,
      slotLead: 18,
      slotDefault: 19,
      slotTrail: 20,
      label: 0,
      labelledby: 1
    });
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[10];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[12];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get gridColumns() {
    return this.$$.ctx[14];
  }
  set gridColumns(ar) {
    this.$$set({ gridColumns: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[15];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionRowMain() {
    return this.$$.ctx[16];
  }
  set regionRowMain(ar) {
    this.$$set({ regionRowMain: ar }), flush();
  }
  get regionRowHeadline() {
    return this.$$.ctx[17];
  }
  set regionRowHeadline(ar) {
    this.$$set({ regionRowHeadline: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[18];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotDefault() {
    return this.$$.ctx[19];
  }
  set slotDefault(ar) {
    this.$$set({ slotDefault: ar }), flush();
  }
  get slotTrail() {
    return this.$$.ctx[20];
  }
  set slotTrail(ar) {
    this.$$set({ slotTrail: ar }), flush();
  }
  get label() {
    return this.$$.ctx[0];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[1];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(AppBar, { background: {}, border: {}, padding: {}, shadow: {}, spacing: {}, gridColumns: {}, gap: {}, regionRowMain: {}, regionRowHeadline: {}, slotLead: {}, slotDefault: {}, slotTrail: {}, label: {}, labelledby: {} }, ["lead", "default", "trail", "headline"], [], !0);
const get_trail_slot_changes$2 = (lr) => ({}), get_trail_slot_context$2 = (lr) => ({}), get_lead_slot_changes$7 = (lr) => ({}), get_lead_slot_context$7 = (lr) => ({});
function create_fragment$14(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr;
  const kr = (
    /*#slots*/
    lr[17].lead
  ), Tr = create_slot(
    kr,
    lr,
    /*$$scope*/
    lr[16],
    get_lead_slot_context$7
  ), _r = (
    /*#slots*/
    lr[17].default
  ), Er = create_slot(
    _r,
    lr,
    /*$$scope*/
    lr[16],
    null
  ), xr = (
    /*#slots*/
    lr[17].trail
  ), Cr = create_slot(
    xr,
    lr,
    /*$$scope*/
    lr[16],
    get_trail_slot_context$2
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), Tr && Tr.c(), fr = space(), dr = element("div"), Er && Er.c(), gr = space(), vr = element("div"), Cr && Cr.c(), attr(cr, "class", ur = "app-bar-lead " + /*classesRegionLead*/
      lr[2]), attr(dr, "class", hr = "app-bar-default " + /*classesRegionDefault*/
      lr[1]), attr(vr, "class", mr = "app-bar-trail " + /*classesRegionTrail*/
      lr[0]), attr(ar, "class", br = "app-rail " + /*classesBase*/
      lr[3]), attr(ar, "data-testid", "app-rail");
    },
    m(Ar, Lr) {
      insert(Ar, ar, Lr), append(ar, cr), Tr && Tr.m(cr, null), append(ar, fr), append(ar, dr), Er && Er.m(dr, null), append(ar, gr), append(ar, vr), Cr && Cr.m(vr, null), yr = !0;
    },
    p(Ar, [Lr]) {
      Tr && Tr.p && (!yr || Lr & /*$$scope*/
      65536) && update_slot_base(
        Tr,
        kr,
        Ar,
        /*$$scope*/
        Ar[16],
        yr ? get_slot_changes(
          kr,
          /*$$scope*/
          Ar[16],
          Lr,
          get_lead_slot_changes$7
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[16]
        ),
        get_lead_slot_context$7
      ), (!yr || Lr & /*classesRegionLead*/
      4 && ur !== (ur = "app-bar-lead " + /*classesRegionLead*/
      Ar[2])) && attr(cr, "class", ur), Er && Er.p && (!yr || Lr & /*$$scope*/
      65536) && update_slot_base(
        Er,
        _r,
        Ar,
        /*$$scope*/
        Ar[16],
        yr ? get_slot_changes(
          _r,
          /*$$scope*/
          Ar[16],
          Lr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[16]
        ),
        null
      ), (!yr || Lr & /*classesRegionDefault*/
      2 && hr !== (hr = "app-bar-default " + /*classesRegionDefault*/
      Ar[1])) && attr(dr, "class", hr), Cr && Cr.p && (!yr || Lr & /*$$scope*/
      65536) && update_slot_base(
        Cr,
        xr,
        Ar,
        /*$$scope*/
        Ar[16],
        yr ? get_slot_changes(
          xr,
          /*$$scope*/
          Ar[16],
          Lr,
          get_trail_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[16]
        ),
        get_trail_slot_context$2
      ), (!yr || Lr & /*classesRegionTrail*/
      1 && mr !== (mr = "app-bar-trail " + /*classesRegionTrail*/
      Ar[0])) && attr(vr, "class", mr), (!yr || Lr & /*classesBase*/
      8 && br !== (br = "app-rail " + /*classesBase*/
      Ar[3])) && attr(ar, "class", br);
    },
    i(Ar) {
      yr || (transition_in(Tr, Ar), transition_in(Er, Ar), transition_in(Cr, Ar), yr = !0);
    },
    o(Ar) {
      transition_out(Tr, Ar), transition_out(Er, Ar), transition_out(Cr, Ar), yr = !1;
    },
    d(Ar) {
      Ar && detach(ar), Tr && Tr.d(Ar), Er && Er.d(Ar), Cr && Cr.d(Ar);
    }
  };
}
const cBase$n = "grid grid-rows-[auto_1fr_auto] overflow-y-auto", cRegionLead$1 = "box-border", cRegionDefault$1 = "box-border", cRegionTrail$1 = "box-border";
function instance$L(lr, ar, cr) {
  let ur, fr, dr, hr, { $$slots: gr = {}, $$scope: vr } = ar, { background: mr = "bg-surface-100-800-token" } = ar, { border: br = "" } = ar, { width: yr = "w-20" } = ar, { height: kr = "h-full" } = ar, { gap: Tr = "gap-0" } = ar, { regionLead: _r = "" } = ar, { regionDefault: Er = "" } = ar, { regionTrail: xr = "" } = ar, { hover: Cr = "bg-primary-hover-token" } = ar, { active: Ar = "bg-primary-active-token" } = ar, { spacing: Lr = "space-y-1" } = ar, { aspectRatio: Dr = "aspect-square" } = ar;
  return setContext("active", Ar), setContext("hover", Cr), setContext("spacing", Lr), setContext("aspectRatio", Dr), lr.$$set = (Nr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Nr))), "background" in Nr && cr(4, mr = Nr.background), "border" in Nr && cr(5, br = Nr.border), "width" in Nr && cr(6, yr = Nr.width), "height" in Nr && cr(7, kr = Nr.height), "gap" in Nr && cr(8, Tr = Nr.gap), "regionLead" in Nr && cr(9, _r = Nr.regionLead), "regionDefault" in Nr && cr(10, Er = Nr.regionDefault), "regionTrail" in Nr && cr(11, xr = Nr.regionTrail), "hover" in Nr && cr(12, Cr = Nr.hover), "active" in Nr && cr(13, Ar = Nr.active), "spacing" in Nr && cr(14, Lr = Nr.spacing), "aspectRatio" in Nr && cr(15, Dr = Nr.aspectRatio), "$$scope" in Nr && cr(16, vr = Nr.$$scope);
  }, lr.$$.update = () => {
    cr(3, ur = `${cBase$n} ${mr} ${br} ${yr} ${kr} ${Tr} ${ar.class || ""}`), lr.$$.dirty & /*regionLead*/
    512 && cr(2, fr = `${cRegionLead$1} ${_r}`), lr.$$.dirty & /*regionDefault*/
    1024 && cr(1, dr = `${cRegionDefault$1} ${Er}`), lr.$$.dirty & /*regionTrail*/
    2048 && cr(0, hr = `${cRegionTrail$1} ${xr}`);
  }, ar = exclude_internal_props(ar), [
    hr,
    dr,
    fr,
    ur,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    vr,
    gr
  ];
}
class AppRail extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$L, create_fragment$14, safe_not_equal, {
      background: 4,
      border: 5,
      width: 6,
      height: 7,
      gap: 8,
      regionLead: 9,
      regionDefault: 10,
      regionTrail: 11,
      hover: 12,
      active: 13,
      spacing: 14,
      aspectRatio: 15
    });
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[7];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[8];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[9];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[10];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[11];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[12];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[15];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRail, { background: {}, border: {}, width: {}, height: {}, gap: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default", "trail"], [], !0);
const get_lead_slot_changes$6 = (lr) => ({}), get_lead_slot_context$6 = (lr) => ({});
function create_if_block$w(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_lead_slot_context$6
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-rail-lead " + /*classesLead*/
      lr[6]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[22],
          gr,
          get_lead_slot_changes$6
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[22]
        ),
        get_lead_slot_context$6
      ), (!ur || gr[0] & /*classesLead*/
      64 && cr !== (cr = "app-rail-lead " + /*classesLead*/
      hr[6])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$13(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[12](),
    { tabindex: "-1" }
  ], Ar = {};
  for (let Hr = 0; Hr < Cr.length; Hr += 1)
    Ar = assign$1(Ar, Cr[Hr]);
  let Lr = (
    /*$$slots*/
    lr[13].lead && create_if_block$w(lr)
  );
  const Dr = (
    /*#slots*/
    lr[23].default
  ), Nr = create_slot(
    Dr,
    lr,
    /*$$scope*/
    lr[22],
    null
  );
  return _r = init_binding_group(
    /*$$binding_groups*/
    lr[34][0]
  ), {
    c() {
      ar = element("label"), cr = element("button"), ur = element("div"), fr = element("input"), dr = space(), hr = element("div"), Lr && Lr.c(), gr = space(), vr = element("div"), Nr && Nr.c(), set_attributes(fr, Ar), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", mr = "app-rail-label " + /*classesLabel*/
      lr[5]), attr(hr, "class", br = "app-rail-interface " + /*classesInterface*/
      lr[7]), attr(cr, "class", yr = "app-rail-wrapper " + /*classesWrapper*/
      lr[8]), attr(cr, "tabindex", "0"), attr(ar, "class", kr = "app-rail-tile " + /*classesBase*/
      lr[9]), attr(ar, "data-testid", "app-rail-tile"), attr(
        ar,
        "title",
        /*title*/
        lr[3]
      ), _r.p(fr);
    },
    m(Hr, $r) {
      insert(Hr, ar, $r), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[32](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), append(cr, hr), Lr && Lr.m(hr, null), append(hr, gr), append(hr, vr), Nr && Nr.m(vr, null), Tr = !0, Er || (xr = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[33]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[30]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[31]
        ),
        listen(
          cr,
          "click",
          /*selectElemInput*/
          lr[11]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[28]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[29]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[24]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[25]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[26]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[27]
        )
      ], Er = !0);
    },
    p(Hr, $r) {
      set_attributes(fr, Ar = get_spread_update(Cr, [
        { type: "radio" },
        (!Tr || $r[0] & /*name*/
        2) && { name: (
          /*name*/
          Hr[1]
        ) },
        (!Tr || $r[0] & /*value*/
        4) && { __value: (
          /*value*/
          Hr[2]
        ) },
        /*prunedRestProps*/
        Hr[12](),
        { tabindex: "-1" }
      ])), $r[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      Hr[0]), /*$$slots*/
      Hr[13].lead ? Lr ? (Lr.p(Hr, $r), $r[0] & /*$$slots*/
      8192 && transition_in(Lr, 1)) : (Lr = create_if_block$w(Hr), Lr.c(), transition_in(Lr, 1), Lr.m(hr, gr)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!Tr || $r[0] & /*$$scope*/
      4194304) && update_slot_base(
        Nr,
        Dr,
        Hr,
        /*$$scope*/
        Hr[22],
        Tr ? get_slot_changes(
          Dr,
          /*$$scope*/
          Hr[22],
          $r,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Hr[22]
        ),
        null
      ), (!Tr || $r[0] & /*classesLabel*/
      32 && mr !== (mr = "app-rail-label " + /*classesLabel*/
      Hr[5])) && attr(vr, "class", mr), (!Tr || $r[0] & /*classesInterface*/
      128 && br !== (br = "app-rail-interface " + /*classesInterface*/
      Hr[7])) && attr(hr, "class", br), (!Tr || $r[0] & /*classesWrapper*/
      256 && yr !== (yr = "app-rail-wrapper " + /*classesWrapper*/
      Hr[8])) && attr(cr, "class", yr), (!Tr || $r[0] & /*classesBase*/
      512 && kr !== (kr = "app-rail-tile " + /*classesBase*/
      Hr[9])) && attr(ar, "class", kr), (!Tr || $r[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        Hr[3]
      );
    },
    i(Hr) {
      Tr || (transition_in(Lr), transition_in(Nr, Hr), Tr = !0);
    },
    o(Hr) {
      transition_out(Lr), transition_out(Nr, Hr), Tr = !1;
    },
    d(Hr) {
      Hr && detach(ar), lr[32](null), Lr && Lr.d(), Nr && Nr.d(Hr), _r.r(), Er = !1, run_all(xr);
    }
  };
}
const cBase$m = "cursor-pointer", cWrapper$3 = "flex flex-col justify-center items-stretch w-full", cInterface$3 = "text-center", cLabel$4 = "font-bold text-xs";
function instance$K(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr;
  const mr = [
    "group",
    "name",
    "value",
    "title",
    "regionLead",
    "regionLabel",
    "hover",
    "active",
    "spacing",
    "width",
    "aspectRatio"
  ];
  let br = compute_rest_props(ar, mr), { $$slots: yr = {}, $$scope: kr } = ar;
  const Tr = compute_slots(yr);
  let { group: _r } = ar, { name: Er } = ar, { value: xr } = ar, { title: Cr = "" } = ar, { regionLead: Ar = "" } = ar, { regionLabel: Lr = "" } = ar, { hover: Dr = getContext("hover") } = ar, { active: Nr = getContext("active") } = ar, { spacing: Hr = getContext("spacing") } = ar, { width: $r = getContext("width") } = ar, { aspectRatio: Wr = getContext("aspectRatio") } = ar, Zr;
  function oi(yi) {
    ["Enter", "Space"].includes(yi.code) && (yi.preventDefault(), Jr());
  }
  function Jr() {
    Zr.click();
  }
  function Yr() {
    return delete br.class, br;
  }
  const li = [[]];
  function Si(yi) {
    bubble.call(this, lr, yi);
  }
  function ci(yi) {
    bubble.call(this, lr, yi);
  }
  function hi(yi) {
    bubble.call(this, lr, yi);
  }
  function Ei(yi) {
    bubble.call(this, lr, yi);
  }
  function di(yi) {
    bubble.call(this, lr, yi);
  }
  function gi(yi) {
    bubble.call(this, lr, yi);
  }
  function Li(yi) {
    bubble.call(this, lr, yi);
  }
  function ui(yi) {
    bubble.call(this, lr, yi);
  }
  function wi(yi) {
    binding_callbacks[yi ? "unshift" : "push"](() => {
      Zr = yi, cr(4, Zr);
    });
  }
  function Ui() {
    _r = this.__value, cr(0, _r);
  }
  return lr.$$set = (yi) => {
    cr(36, ar = assign$1(assign$1({}, ar), exclude_internal_props(yi))), cr(35, br = compute_rest_props(ar, mr)), "group" in yi && cr(0, _r = yi.group), "name" in yi && cr(1, Er = yi.name), "value" in yi && cr(2, xr = yi.value), "title" in yi && cr(3, Cr = yi.title), "regionLead" in yi && cr(14, Ar = yi.regionLead), "regionLabel" in yi && cr(15, Lr = yi.regionLabel), "hover" in yi && cr(16, Dr = yi.hover), "active" in yi && cr(17, Nr = yi.active), "spacing" in yi && cr(18, Hr = yi.spacing), "width" in yi && cr(19, $r = yi.width), "aspectRatio" in yi && cr(20, Wr = yi.aspectRatio), "$$scope" in yi && cr(22, kr = yi.$$scope);
  }, lr.$$.update = () => {
    lr.$$.dirty[0] & /*group, value, active*/
    131077 && cr(21, ur = _r === xr ? Nr : ""), cr(9, fr = `${cBase$m} ${ar.class || ""}`), lr.$$.dirty[0] & /*aspectRatio, width, hover, classActive*/
    3735552 && cr(8, dr = `${cWrapper$3} ${Wr} ${$r} ${Dr} ${ur}`), lr.$$.dirty[0] & /*spacing*/
    262144 && cr(7, hr = `${cInterface$3} ${Hr}`), lr.$$.dirty[0] & /*regionLead*/
    16384 && cr(6, gr = `${Ar}`), lr.$$.dirty[0] & /*regionLabel*/
    32768 && cr(5, vr = `${cLabel$4} ${Lr}`);
  }, ar = exclude_internal_props(ar), [
    _r,
    Er,
    xr,
    Cr,
    Zr,
    vr,
    gr,
    hr,
    dr,
    fr,
    oi,
    Jr,
    Yr,
    Tr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    ur,
    kr,
    yr,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    Li,
    ui,
    wi,
    Ui,
    li
  ];
}
class AppRailTile extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$K,
      create_fragment$13,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        regionLead: 14,
        regionLabel: 15,
        hover: 16,
        active: 17,
        spacing: 18,
        width: 19,
        aspectRatio: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[14];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[15];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[17];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[18];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[20];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailTile, { group: {}, name: {}, value: {}, title: {}, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, width: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$5 = (lr) => ({}), get_lead_slot_context$5 = (lr) => ({});
function create_if_block$v(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[16].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[15],
    get_lead_slot_context$5
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-rail-lead " + /*classesLead*/
      lr[1]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      32768) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[15],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[15],
          gr,
          get_lead_slot_changes$5
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[15]
        ),
        get_lead_slot_context$5
      ), (!ur || gr & /*classesLead*/
      2 && cr !== (cr = "app-rail-lead " + /*classesLead*/
      hr[1])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$12(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr = (
    /*$$slots*/
    lr[6].lead && create_if_block$v(lr)
  );
  const Tr = (
    /*#slots*/
    lr[16].default
  ), _r = create_slot(
    Tr,
    lr,
    /*$$scope*/
    lr[15],
    null
  );
  let Er = [
    {
      class: gr = "app-rail-anchor " + /*classesBase*/
      lr[3]
    },
    {
      href: vr = /*$$props*/
      lr[5].href
    },
    /*prunedRestProps*/
    lr[4](),
    { "data-testid": "app-rail-anchor" }
  ], xr = {};
  for (let Cr = 0; Cr < Er.length; Cr += 1)
    xr = assign$1(xr, Er[Cr]);
  return {
    c() {
      ar = element("a"), cr = element("div"), kr && kr.c(), ur = space(), fr = element("div"), _r && _r.c(), attr(fr, "class", dr = "app-rail-label " + /*classesLabel*/
      lr[0]), attr(cr, "class", hr = "app-rail-wrapper " + /*classesWrapper*/
      lr[2]), set_attributes(ar, xr);
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), kr && kr.m(cr, null), append(cr, ur), append(cr, fr), _r && _r.m(fr, null), mr = !0, br || (yr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[20]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[21]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[22]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[23]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[24]
        )
      ], br = !0);
    },
    p(Cr, [Ar]) {
      /*$$slots*/
      Cr[6].lead ? kr ? (kr.p(Cr, Ar), Ar & /*$$slots*/
      64 && transition_in(kr, 1)) : (kr = create_if_block$v(Cr), kr.c(), transition_in(kr, 1), kr.m(cr, ur)) : kr && (group_outros(), transition_out(kr, 1, 1, () => {
        kr = null;
      }), check_outros()), _r && _r.p && (!mr || Ar & /*$$scope*/
      32768) && update_slot_base(
        _r,
        Tr,
        Cr,
        /*$$scope*/
        Cr[15],
        mr ? get_slot_changes(
          Tr,
          /*$$scope*/
          Cr[15],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Cr[15]
        ),
        null
      ), (!mr || Ar & /*classesLabel*/
      1 && dr !== (dr = "app-rail-label " + /*classesLabel*/
      Cr[0])) && attr(fr, "class", dr), (!mr || Ar & /*classesWrapper*/
      4 && hr !== (hr = "app-rail-wrapper " + /*classesWrapper*/
      Cr[2])) && attr(cr, "class", hr), set_attributes(ar, xr = get_spread_update(Er, [
        (!mr || Ar & /*classesBase*/
        8 && gr !== (gr = "app-rail-anchor " + /*classesBase*/
        Cr[3])) && { class: gr },
        (!mr || Ar & /*$$props*/
        32 && vr !== (vr = /*$$props*/
        Cr[5].href)) && { href: vr },
        /*prunedRestProps*/
        Cr[4](),
        { "data-testid": "app-rail-anchor" }
      ]));
    },
    i(Cr) {
      mr || (transition_in(kr), transition_in(_r, Cr), mr = !0);
    },
    o(Cr) {
      transition_out(kr), transition_out(_r, Cr), mr = !1;
    },
    d(Cr) {
      Cr && detach(ar), kr && kr.d(), _r && _r.d(Cr), br = !1, run_all(yr);
    }
  };
}
const cBase$l = "unstyled", cWrapper$2 = "w-full flex flex-col justify-center items-stretch text-center space-y-1", cLabel$3 = "font-bold text-xs";
function instance$J(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  const vr = ["selected", "regionLead", "regionLabel", "hover", "active", "spacing", "aspectRatio"];
  let mr = compute_rest_props(ar, vr), { $$slots: br = {}, $$scope: yr } = ar;
  const kr = compute_slots(br);
  let { selected: Tr = !1 } = ar, { regionLead: _r = "flex justify-center items-center" } = ar, { regionLabel: Er = "" } = ar, { hover: xr = getContext("hover") } = ar, { active: Cr = getContext("active") } = ar, { spacing: Ar = getContext("spacing") } = ar, { aspectRatio: Lr = getContext("aspectRatio") } = ar;
  function Dr() {
    return delete mr.class, mr;
  }
  function Nr(li) {
    bubble.call(this, lr, li);
  }
  function Hr(li) {
    bubble.call(this, lr, li);
  }
  function $r(li) {
    bubble.call(this, lr, li);
  }
  function Wr(li) {
    bubble.call(this, lr, li);
  }
  function Zr(li) {
    bubble.call(this, lr, li);
  }
  function oi(li) {
    bubble.call(this, lr, li);
  }
  function Jr(li) {
    bubble.call(this, lr, li);
  }
  function Yr(li) {
    bubble.call(this, lr, li);
  }
  return lr.$$set = (li) => {
    cr(5, ar = assign$1(assign$1({}, ar), exclude_internal_props(li))), cr(25, mr = compute_rest_props(ar, vr)), "selected" in li && cr(7, Tr = li.selected), "regionLead" in li && cr(8, _r = li.regionLead), "regionLabel" in li && cr(9, Er = li.regionLabel), "hover" in li && cr(10, xr = li.hover), "active" in li && cr(11, Cr = li.active), "spacing" in li && cr(12, Ar = li.spacing), "aspectRatio" in li && cr(13, Lr = li.aspectRatio), "$$scope" in li && cr(15, yr = li.$$scope);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*selected, active*/
    2176 && cr(14, ur = Tr ? Cr : ""), cr(3, fr = `${cBase$l} ${ar.class || ""}`), lr.$$.dirty & /*aspectRatio, hover, spacing, classActive*/
    29696 && cr(2, dr = `${cWrapper$2} ${Lr} ${xr} ${Ar} ${ur}`), lr.$$.dirty & /*regionLead*/
    256 && cr(1, hr = `${_r}`), lr.$$.dirty & /*regionLabel*/
    512 && cr(0, gr = `${cLabel$3} ${Er}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    hr,
    dr,
    fr,
    Dr,
    ar,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    ur,
    yr,
    br,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr
  ];
}
class AppRailAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$J, create_fragment$12, safe_not_equal, {
      selected: 7,
      regionLead: 8,
      regionLabel: 9,
      hover: 10,
      active: 11,
      spacing: 12,
      aspectRatio: 13
    });
  }
  get selected() {
    return this.$$.ctx[7];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[9];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[10];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[11];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[13];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailAnchor, { selected: { type: "Boolean" }, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_footer_slot_changes = (lr) => ({}), get_footer_slot_context = (lr) => ({}), get_sidebarRight_slot_changes = (lr) => ({}), get_sidebarRight_slot_context = (lr) => ({}), get_pageFooter_slot_changes = (lr) => ({}), get_pageFooter_slot_context = (lr) => ({}), get_pageHeader_slot_changes = (lr) => ({}), get_pageHeader_slot_context = (lr) => ({}), get_sidebarLeft_slot_changes = (lr) => ({}), get_sidebarLeft_slot_context = (lr) => ({}), get_header_slot_changes$1 = (lr) => ({}), get_header_slot_context$1 = (lr) => ({});
function create_if_block_5$4(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].header
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_header_slot_context$1
  );
  return {
    c() {
      ar = element("header"), dr && dr.c(), attr(ar, "id", "shell-header"), attr(ar, "class", cr = "flex-none " + /*classesHeader*/
      lr[8]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[18],
          gr,
          get_header_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[18]
        ),
        get_header_slot_context$1
      ), (!ur || gr & /*classesHeader*/
      256 && cr !== (cr = "flex-none " + /*classesHeader*/
      hr[8])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_if_block_4$6(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[19].sidebarLeft
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[18],
    get_sidebarLeft_slot_context
  );
  return {
    c() {
      ar = element("aside"), fr && fr.c(), attr(ar, "id", "sidebar-left"), attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        lr[7]
      );
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[18],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[18],
          hr,
          get_sidebarLeft_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[18]
        ),
        get_sidebarLeft_slot_context
      ), (!cr || hr & /*classesSidebarLeft*/
      128) && attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        dr[7]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block_3$8(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].pageHeader
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_pageHeader_slot_context
  ), hr = dr || fallback_block_1$1();
  return {
    c() {
      ar = element("header"), hr && hr.c(), attr(ar, "id", "page-header"), attr(ar, "class", cr = "flex-none " + /*classesPageHeader*/
      lr[5]);
    },
    m(gr, vr) {
      insert(gr, ar, vr), hr && hr.m(ar, null), ur = !0;
    },
    p(gr, vr) {
      dr && dr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[18],
          vr,
          get_pageHeader_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_pageHeader_slot_context
      ), (!ur || vr & /*classesPageHeader*/
      32 && cr !== (cr = "flex-none " + /*classesPageHeader*/
      gr[5])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(hr, gr), ur = !0);
    },
    o(gr) {
      transition_out(hr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), hr && hr.d(gr);
    }
  };
}
function fallback_block_1$1(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:header)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_2$c(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].pageFooter
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_pageFooter_slot_context
  ), hr = dr || fallback_block$4();
  return {
    c() {
      ar = element("footer"), hr && hr.c(), attr(ar, "id", "page-footer"), attr(ar, "class", cr = "flex-none " + /*classesPageFooter*/
      lr[3]);
    },
    m(gr, vr) {
      insert(gr, ar, vr), hr && hr.m(ar, null), ur = !0;
    },
    p(gr, vr) {
      dr && dr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[18],
          vr,
          get_pageFooter_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_pageFooter_slot_context
      ), (!ur || vr & /*classesPageFooter*/
      8 && cr !== (cr = "flex-none " + /*classesPageFooter*/
      gr[3])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(hr, gr), ur = !0);
    },
    o(gr) {
      transition_out(hr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), hr && hr.d(gr);
    }
  };
}
function fallback_block$4(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:footer)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_1$f(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[19].sidebarRight
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[18],
    get_sidebarRight_slot_context
  );
  return {
    c() {
      ar = element("aside"), fr && fr.c(), attr(ar, "id", "sidebar-right"), attr(
        ar,
        "class",
        /*classesSidebarRight*/
        lr[6]
      );
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[18],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[18],
          hr,
          get_sidebarRight_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[18]
        ),
        get_sidebarRight_slot_context
      ), (!cr || hr & /*classesSidebarRight*/
      64) && attr(
        ar,
        "class",
        /*classesSidebarRight*/
        dr[6]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block$u(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].footer
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_footer_slot_context
  );
  return {
    c() {
      ar = element("footer"), dr && dr.c(), attr(ar, "id", "shell-footer"), attr(ar, "class", cr = "flex-none " + /*classesFooter*/
      lr[2]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[18],
          gr,
          get_footer_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[18]
        ),
        get_footer_slot_context
      ), (!ur || gr & /*classesFooter*/
      4 && cr !== (cr = "flex-none " + /*classesFooter*/
      hr[2])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$11(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr = (
    /*$$slots*/
    lr[10].header && create_if_block_5$4(lr)
  ), Cr = (
    /*$$slots*/
    lr[10].sidebarLeft && create_if_block_4$6(lr)
  ), Ar = (
    /*$$slots*/
    lr[10].pageHeader && create_if_block_3$8(lr)
  );
  const Lr = (
    /*#slots*/
    lr[19].default
  ), Dr = create_slot(
    Lr,
    lr,
    /*$$scope*/
    lr[18],
    null
  );
  let Nr = (
    /*$$slots*/
    lr[10].pageFooter && create_if_block_2$c(lr)
  ), Hr = (
    /*$$slots*/
    lr[10].sidebarRight && create_if_block_1$f(lr)
  ), $r = (
    /*$$slots*/
    lr[10].footer && create_if_block$u(lr)
  );
  return {
    c() {
      ar = element("div"), xr && xr.c(), cr = space(), ur = element("div"), Cr && Cr.c(), fr = space(), dr = element("div"), Ar && Ar.c(), hr = space(), gr = element("main"), Dr && Dr.c(), mr = space(), Nr && Nr.c(), yr = space(), Hr && Hr.c(), kr = space(), $r && $r.c(), attr(gr, "id", "page-content"), attr(gr, "class", vr = "flex-auto " + /*classesPageContent*/
      lr[4]), attr(dr, "id", "page"), attr(dr, "class", br = /*regionPage*/
      lr[1] + " " + cPage), set_style(
        dr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        lr[0]
      ), attr(ur, "class", "flex-auto " + cContentArea), attr(ar, "id", "appShell"), attr(
        ar,
        "class",
        /*classesBase*/
        lr[9]
      ), attr(ar, "data-testid", "app-shell");
    },
    m(Wr, Zr) {
      insert(Wr, ar, Zr), xr && xr.m(ar, null), append(ar, cr), append(ar, ur), Cr && Cr.m(ur, null), append(ur, fr), append(ur, dr), Ar && Ar.m(dr, null), append(dr, hr), append(dr, gr), Dr && Dr.m(gr, null), append(dr, mr), Nr && Nr.m(dr, null), append(ur, yr), Hr && Hr.m(ur, null), append(ar, kr), $r && $r.m(ar, null), Tr = !0, _r || (Er = listen(
        dr,
        "scroll",
        /*scroll_handler*/
        lr[20]
      ), _r = !0);
    },
    p(Wr, [Zr]) {
      /*$$slots*/
      Wr[10].header ? xr ? (xr.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in(xr, 1)) : (xr = create_if_block_5$4(Wr), xr.c(), transition_in(xr, 1), xr.m(ar, cr)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), /*$$slots*/
      Wr[10].sidebarLeft ? Cr ? (Cr.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in(Cr, 1)) : (Cr = create_if_block_4$6(Wr), Cr.c(), transition_in(Cr, 1), Cr.m(ur, fr)) : Cr && (group_outros(), transition_out(Cr, 1, 1, () => {
        Cr = null;
      }), check_outros()), /*$$slots*/
      Wr[10].pageHeader ? Ar ? (Ar.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in(Ar, 1)) : (Ar = create_if_block_3$8(Wr), Ar.c(), transition_in(Ar, 1), Ar.m(dr, hr)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), Dr && Dr.p && (!Tr || Zr & /*$$scope*/
      262144) && update_slot_base(
        Dr,
        Lr,
        Wr,
        /*$$scope*/
        Wr[18],
        Tr ? get_slot_changes(
          Lr,
          /*$$scope*/
          Wr[18],
          Zr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Wr[18]
        ),
        null
      ), (!Tr || Zr & /*classesPageContent*/
      16 && vr !== (vr = "flex-auto " + /*classesPageContent*/
      Wr[4])) && attr(gr, "class", vr), /*$$slots*/
      Wr[10].pageFooter ? Nr ? (Nr.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in(Nr, 1)) : (Nr = create_if_block_2$c(Wr), Nr.c(), transition_in(Nr, 1), Nr.m(dr, null)) : Nr && (group_outros(), transition_out(Nr, 1, 1, () => {
        Nr = null;
      }), check_outros()), (!Tr || Zr & /*regionPage*/
      2 && br !== (br = /*regionPage*/
      Wr[1] + " " + cPage)) && attr(dr, "class", br), Zr & /*scrollbarGutter*/
      1 && set_style(
        dr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        Wr[0]
      ), /*$$slots*/
      Wr[10].sidebarRight ? Hr ? (Hr.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in(Hr, 1)) : (Hr = create_if_block_1$f(Wr), Hr.c(), transition_in(Hr, 1), Hr.m(ur, null)) : Hr && (group_outros(), transition_out(Hr, 1, 1, () => {
        Hr = null;
      }), check_outros()), /*$$slots*/
      Wr[10].footer ? $r ? ($r.p(Wr, Zr), Zr & /*$$slots*/
      1024 && transition_in($r, 1)) : ($r = create_if_block$u(Wr), $r.c(), transition_in($r, 1), $r.m(ar, null)) : $r && (group_outros(), transition_out($r, 1, 1, () => {
        $r = null;
      }), check_outros()), (!Tr || Zr & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Wr[9]
      );
    },
    i(Wr) {
      Tr || (transition_in(xr), transition_in(Cr), transition_in(Ar), transition_in(Dr, Wr), transition_in(Nr), transition_in(Hr), transition_in($r), Tr = !0);
    },
    o(Wr) {
      transition_out(xr), transition_out(Cr), transition_out(Ar), transition_out(Dr, Wr), transition_out(Nr), transition_out(Hr), transition_out($r), Tr = !1;
    },
    d(Wr) {
      Wr && detach(ar), xr && xr.d(), Cr && Cr.d(), Ar && Ar.d(), Dr && Dr.d(Wr), Nr && Nr.d(), Hr && Hr.d(), $r && $r.d(), _r = !1, Er();
    }
  };
}
const cBaseAppShell = "w-full h-full flex flex-col overflow-hidden", cContentArea = "w-full h-full flex overflow-hidden", cPage = "flex-1 overflow-x-hidden flex flex-col", cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto", cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance$I(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br, { $$slots: yr = {}, $$scope: kr } = ar;
  const Tr = compute_slots(yr);
  let { scrollbarGutter: _r = "auto" } = ar, { regionPage: Er = "" } = ar, { slotHeader: xr = "z-10" } = ar, { slotSidebarLeft: Cr = "w-auto" } = ar, { slotSidebarRight: Ar = "w-auto" } = ar, { slotPageHeader: Lr = "" } = ar, { slotPageContent: Dr = "" } = ar, { slotPageFooter: Nr = "" } = ar, { slotFooter: Hr = "" } = ar;
  function $r(Wr) {
    bubble.call(this, lr, Wr);
  }
  return lr.$$set = (Wr) => {
    cr(21, ar = assign$1(assign$1({}, ar), exclude_internal_props(Wr))), "scrollbarGutter" in Wr && cr(0, _r = Wr.scrollbarGutter), "regionPage" in Wr && cr(1, Er = Wr.regionPage), "slotHeader" in Wr && cr(11, xr = Wr.slotHeader), "slotSidebarLeft" in Wr && cr(12, Cr = Wr.slotSidebarLeft), "slotSidebarRight" in Wr && cr(13, Ar = Wr.slotSidebarRight), "slotPageHeader" in Wr && cr(14, Lr = Wr.slotPageHeader), "slotPageContent" in Wr && cr(15, Dr = Wr.slotPageContent), "slotPageFooter" in Wr && cr(16, Nr = Wr.slotPageFooter), "slotFooter" in Wr && cr(17, Hr = Wr.slotFooter), "$$scope" in Wr && cr(18, kr = Wr.$$scope);
  }, lr.$$.update = () => {
    var Wr;
    cr(9, ur = `${cBaseAppShell} ${(Wr = ar.class) != null ? Wr : ""}`), lr.$$.dirty & /*slotHeader*/
    2048 && cr(8, fr = `${xr}`), lr.$$.dirty & /*slotSidebarLeft*/
    4096 && cr(7, dr = `${cSidebarLeft} ${Cr}`), lr.$$.dirty & /*slotSidebarRight*/
    8192 && cr(6, hr = `${cSidebarRight} ${Ar}`), lr.$$.dirty & /*slotPageHeader*/
    16384 && cr(5, gr = `${Lr}`), lr.$$.dirty & /*slotPageContent*/
    32768 && cr(4, vr = `${Dr}`), lr.$$.dirty & /*slotPageFooter*/
    65536 && cr(3, mr = `${Nr}`), lr.$$.dirty & /*slotFooter*/
    131072 && cr(2, br = `${Hr}`);
  }, ar = exclude_internal_props(ar), [
    _r,
    Er,
    br,
    mr,
    vr,
    gr,
    hr,
    dr,
    fr,
    ur,
    Tr,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    kr,
    yr,
    $r
  ];
}
class AppShell extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$I, create_fragment$11, safe_not_equal, {
      scrollbarGutter: 0,
      regionPage: 1,
      slotHeader: 11,
      slotSidebarLeft: 12,
      slotSidebarRight: 13,
      slotPageHeader: 14,
      slotPageContent: 15,
      slotPageFooter: 16,
      slotFooter: 17
    });
  }
  get scrollbarGutter() {
    return this.$$.ctx[0];
  }
  set scrollbarGutter(ar) {
    this.$$set({ scrollbarGutter: ar }), flush();
  }
  get regionPage() {
    return this.$$.ctx[1];
  }
  set regionPage(ar) {
    this.$$set({ regionPage: ar }), flush();
  }
  get slotHeader() {
    return this.$$.ctx[11];
  }
  set slotHeader(ar) {
    this.$$set({ slotHeader: ar }), flush();
  }
  get slotSidebarLeft() {
    return this.$$.ctx[12];
  }
  set slotSidebarLeft(ar) {
    this.$$set({ slotSidebarLeft: ar }), flush();
  }
  get slotSidebarRight() {
    return this.$$.ctx[13];
  }
  set slotSidebarRight(ar) {
    this.$$set({ slotSidebarRight: ar }), flush();
  }
  get slotPageHeader() {
    return this.$$.ctx[14];
  }
  set slotPageHeader(ar) {
    this.$$set({ slotPageHeader: ar }), flush();
  }
  get slotPageContent() {
    return this.$$.ctx[15];
  }
  set slotPageContent(ar) {
    this.$$set({ slotPageContent: ar }), flush();
  }
  get slotPageFooter() {
    return this.$$.ctx[16];
  }
  set slotPageFooter(ar) {
    this.$$set({ slotPageFooter: ar }), flush();
  }
  get slotFooter() {
    return this.$$.ctx[17];
  }
  set slotFooter(ar) {
    this.$$set({ slotFooter: ar }), flush();
  }
}
create_custom_element(
  AppShell,
  { scrollbarGutter: {}, regionPage: {}, slotHeader: {}, slotSidebarLeft: {}, slotSidebarRight: {}, slotPageHeader: {}, slotPageContent: {}, slotPageFooter: {}, slotFooter: {} },
  [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ],
  [],
  !0
);
function get_each_context$c(lr, ar, cr) {
  const ur = lr.slice();
  return ur[35] = ar[cr], ur;
}
function create_else_block$d(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("div"), cr = text$3(
        /*emptyState*/
        lr[0]
      ), attr(ar, "class", ur = "autocomplete-empty " + /*classesEmpty*/
      lr[7]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr);
    },
    p(fr, dr) {
      dr[0] & /*emptyState*/
      1 && set_data(
        cr,
        /*emptyState*/
        fr[0]
      ), dr[0] & /*classesEmpty*/
      128 && ur !== (ur = "autocomplete-empty " + /*classesEmpty*/
      fr[7]) && attr(ar, "class", ur);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block$t(lr) {
  let ar, cr, ur = [], fr = /* @__PURE__ */ new Map(), dr, hr, gr, vr = ensure_array_like(
    /*optionsFiltered*/
    lr[6].slice(
      0,
      /*sliceLimit*/
      lr[13]
    )
  );
  const mr = (br) => (
    /*option*/
    br[35]
  );
  for (let br = 0; br < vr.length; br += 1) {
    let yr = get_each_context$c(lr, vr, br), kr = mr(yr);
    fr.set(kr, ur[br] = create_each_block$c(kr, yr));
  }
  return {
    c() {
      ar = element("nav"), cr = element("ul");
      for (let br = 0; br < ur.length; br += 1)
        ur[br].c();
      attr(cr, "class", dr = "autocomplete-list " + /*classesList*/
      lr[10]), attr(ar, "class", hr = "autocomplete-nav " + /*classesNav*/
      lr[11]);
    },
    m(br, yr) {
      insert(br, ar, yr), append(ar, cr);
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr] && ur[kr].m(cr, null);
      gr = !0;
    },
    p(br, yr) {
      yr[0] & /*classesItem, transitionOut, transitionOutParams, transitions, classesButton, onSelection, optionsFiltered, sliceLimit*/
      25458 && (vr = ensure_array_like(
        /*optionsFiltered*/
        br[6].slice(
          0,
          /*sliceLimit*/
          br[13]
        )
      ), group_outros(), ur = update_keyed_each(ur, yr, mr, 1, br, vr, fr, cr, outro_and_destroy_block, create_each_block$c, null, get_each_context$c), check_outros()), (!gr || yr[0] & /*classesList*/
      1024 && dr !== (dr = "autocomplete-list " + /*classesList*/
      br[10])) && attr(cr, "class", dr), (!gr || yr[0] & /*classesNav*/
      2048 && hr !== (hr = "autocomplete-nav " + /*classesNav*/
      br[11])) && attr(ar, "class", hr);
    },
    i(br) {
      if (!gr) {
        for (let yr = 0; yr < vr.length; yr += 1)
          transition_in(ur[yr]);
        gr = !0;
      }
    },
    o(br) {
      for (let yr = 0; yr < ur.length; yr += 1)
        transition_out(ur[yr]);
      gr = !1;
    },
    d(br) {
      br && detach(ar);
      for (let yr = 0; yr < ur.length; yr += 1)
        ur[yr].d();
    }
  };
}
function create_each_block$c(lr, ar) {
  let cr, ur, fr = (
    /*option*/
    ar[35].label + ""
  ), dr, hr, gr, vr, mr, br, yr, kr;
  function Tr() {
    return (
      /*click_handler_1*/
      ar[29](
        /*option*/
        ar[35]
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      cr = element("li"), ur = element("button"), hr = space(), attr(ur, "class", dr = "autocomplete-button " + /*classesButton*/
      ar[8]), attr(ur, "type", "button"), attr(cr, "class", gr = "autocomplete-item " + /*classesItem*/
      ar[9]), this.first = cr;
    },
    m(_r, Er) {
      insert(_r, cr, Er), append(cr, ur), ur.innerHTML = fr, append(cr, hr), br = !0, yr || (kr = [
        listen(ur, "click", Tr),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[27]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[28]
        )
      ], yr = !0);
    },
    p(_r, Er) {
      ar = _r, (!br || Er[0] & /*optionsFiltered, sliceLimit*/
      8256) && fr !== (fr = /*option*/
      ar[35].label + "") && (ur.innerHTML = fr), (!br || Er[0] & /*classesButton*/
      256 && dr !== (dr = "autocomplete-button " + /*classesButton*/
      ar[8])) && attr(ur, "class", dr), (!br || Er[0] & /*classesItem*/
      512 && gr !== (gr = "autocomplete-item " + /*classesItem*/
      ar[9])) && attr(cr, "class", gr);
    },
    i(_r) {
      br || (_r && add_render_callback(() => {
        br && (mr && mr.end(1), vr = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[2]
          ),
          params: (
            /*transitionInParams*/
            ar[3]
          ),
          enabled: (
            /*transitions*/
            ar[1]
          )
        }), vr.start());
      }), br = !0);
    },
    o(_r) {
      vr && vr.invalidate(), _r && (mr = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[4]
        ),
        params: (
          /*transitionOutParams*/
          ar[5]
        ),
        enabled: (
          /*transitions*/
          ar[1]
        )
      })), br = !1;
    },
    d(_r) {
      _r && detach(cr), _r && mr && mr.end(), yr = !1, run_all(kr);
    }
  };
}
function create_fragment$10(lr) {
  let ar, cr, ur, fr, dr;
  const hr = [create_if_block$t, create_else_block$d], gr = [];
  function vr(mr, br) {
    return (
      /*optionsFiltered*/
      mr[6].length > 0 ? 0 : 1
    );
  }
  return cr = vr(lr), ur = gr[cr] = hr[cr](lr), {
    c() {
      ar = element("div"), ur.c(), attr(ar, "class", fr = "autocomplete " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "autocomplete");
    },
    m(mr, br) {
      insert(mr, ar, br), gr[cr].m(ar, null), dr = !0;
    },
    p(mr, br) {
      let yr = cr;
      cr = vr(mr), cr === yr ? gr[cr].p(mr, br) : (group_outros(), transition_out(gr[yr], 1, 1, () => {
        gr[yr] = null;
      }), check_outros(), ur = gr[cr], ur ? ur.p(mr, br) : (ur = gr[cr] = hr[cr](mr), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!dr || br[0] & /*classesBase*/
      4096 && fr !== (fr = "autocomplete " + /*classesBase*/
      mr[12])) && attr(ar, "class", fr);
    },
    i(mr) {
      dr || (transition_in(ur), dr = !0);
    },
    o(mr) {
      transition_out(ur), dr = !1;
    },
    d(mr) {
      mr && detach(ar), gr[cr].d();
    }
  };
}
function instance$H(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br, yr, kr;
  component_subscribe(lr, prefersReducedMotionStore, (ui) => cr(30, kr = ui));
  const Tr = createEventDispatcher();
  let { input: _r = void 0 } = ar, { options: Er = [] } = ar, { limit: xr = void 0 } = ar, { allowlist: Cr = [] } = ar, { denylist: Ar = [] } = ar, { emptyState: Lr = "No Results Found." } = ar, { regionNav: Dr = "" } = ar, { regionList: Nr = "list-nav" } = ar, { regionItem: Hr = "" } = ar, { regionButton: $r = "w-full" } = ar, { regionEmpty: Wr = "text-center" } = ar, { filter: Zr = hi } = ar, { transitions: oi = !kr } = ar, { transitionIn: Jr = slide } = ar, { transitionInParams: Yr = { duration: 200 } } = ar, { transitionOut: li = slide } = ar, { transitionOutParams: Si = { duration: 200 } } = ar;
  function ci(ui, wi) {
    let Ui = [...Er];
    ui.length && (Ui = Ui.filter((yi) => ui.includes(yi.value))), wi.length && (Ui = Ui.filter((yi) => !wi.includes(yi.value))), !ui.length && !wi.length && (Ui = Er), cr(26, ur = Ui);
  }
  function hi() {
    let ui = [...ur];
    return ui = ui.filter((wi) => {
      const Ui = String(_r).toLowerCase().trim();
      if (JSON.stringify([wi.label, wi.value, wi.keywords]).toLowerCase().includes(Ui))
        return wi;
    }), ui;
  }
  function Ei(ui) {
    Tr("selection", ui);
  }
  function di(ui) {
    bubble.call(this, lr, ui);
  }
  function gi(ui) {
    bubble.call(this, lr, ui);
  }
  const Li = (ui) => Ei(ui);
  return lr.$$set = (ui) => {
    cr(34, ar = assign$1(assign$1({}, ar), exclude_internal_props(ui))), "input" in ui && cr(15, _r = ui.input), "options" in ui && cr(16, Er = ui.options), "limit" in ui && cr(17, xr = ui.limit), "allowlist" in ui && cr(18, Cr = ui.allowlist), "denylist" in ui && cr(19, Ar = ui.denylist), "emptyState" in ui && cr(0, Lr = ui.emptyState), "regionNav" in ui && cr(20, Dr = ui.regionNav), "regionList" in ui && cr(21, Nr = ui.regionList), "regionItem" in ui && cr(22, Hr = ui.regionItem), "regionButton" in ui && cr(23, $r = ui.regionButton), "regionEmpty" in ui && cr(24, Wr = ui.regionEmpty), "filter" in ui && cr(25, Zr = ui.filter), "transitions" in ui && cr(1, oi = ui.transitions), "transitionIn" in ui && cr(2, Jr = ui.transitionIn), "transitionInParams" in ui && cr(3, Yr = ui.transitionInParams), "transitionOut" in ui && cr(4, li = ui.transitionOut), "transitionOutParams" in ui && cr(5, Si = ui.transitionOutParams);
  }, lr.$$.update = () => {
    var ui;
    lr.$$.dirty[0] & /*options*/
    65536 && cr(26, ur = Er), lr.$$.dirty[0] & /*allowlist, denylist*/
    786432 && ci(Cr, Ar), lr.$$.dirty[0] & /*input, filter, listedOptions*/
    100696064 && cr(6, fr = _r ? Zr() : ur), lr.$$.dirty[0] & /*limit, optionsFiltered*/
    131136 && cr(13, dr = xr != null ? xr : fr.length), cr(12, hr = `${(ui = ar.class) != null ? ui : ""}`), lr.$$.dirty[0] & /*regionNav*/
    1048576 && cr(11, gr = `${Dr}`), lr.$$.dirty[0] & /*regionList*/
    2097152 && cr(10, vr = `${Nr}`), lr.$$.dirty[0] & /*regionItem*/
    4194304 && cr(9, mr = `${Hr}`), lr.$$.dirty[0] & /*regionButton*/
    8388608 && cr(8, br = `${$r}`), lr.$$.dirty[0] & /*regionEmpty*/
    16777216 && cr(7, yr = `${Wr}`);
  }, ar = exclude_internal_props(ar), [
    Lr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    fr,
    yr,
    br,
    mr,
    vr,
    gr,
    hr,
    dr,
    Ei,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    ur,
    di,
    gi,
    Li
  ];
}
class Autocomplete extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$H,
      create_fragment$10,
      safe_not_equal,
      {
        input: 15,
        options: 16,
        limit: 17,
        allowlist: 18,
        denylist: 19,
        emptyState: 0,
        regionNav: 20,
        regionList: 21,
        regionItem: 22,
        regionButton: 23,
        regionEmpty: 24,
        filter: 25,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get input() {
    return this.$$.ctx[15];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get options() {
    return this.$$.ctx[16];
  }
  set options(ar) {
    this.$$set({ options: ar }), flush();
  }
  get limit() {
    return this.$$.ctx[17];
  }
  set limit(ar) {
    this.$$set({ limit: ar }), flush();
  }
  get allowlist() {
    return this.$$.ctx[18];
  }
  set allowlist(ar) {
    this.$$set({ allowlist: ar }), flush();
  }
  get denylist() {
    return this.$$.ctx[19];
  }
  set denylist(ar) {
    this.$$set({ denylist: ar }), flush();
  }
  get emptyState() {
    return this.$$.ctx[0];
  }
  set emptyState(ar) {
    this.$$set({ emptyState: ar }), flush();
  }
  get regionNav() {
    return this.$$.ctx[20];
  }
  set regionNav(ar) {
    this.$$set({ regionNav: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[21];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionItem() {
    return this.$$.ctx[22];
  }
  set regionItem(ar) {
    this.$$set({ regionItem: ar }), flush();
  }
  get regionButton() {
    return this.$$.ctx[23];
  }
  set regionButton(ar) {
    this.$$set({ regionButton: ar }), flush();
  }
  get regionEmpty() {
    return this.$$.ctx[24];
  }
  set regionEmpty(ar) {
    this.$$set({ regionEmpty: ar }), flush();
  }
  get filter() {
    return this.$$.ctx[25];
  }
  set filter(ar) {
    this.$$set({ filter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Autocomplete, { input: {}, options: {}, limit: {}, allowlist: {}, denylist: {}, emptyState: {}, regionNav: {}, regionList: {}, regionItem: {}, regionButton: {}, regionEmpty: {}, filter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function create_else_block$c(lr) {
  let ar, cr, ur = String(
    /*initials*/
    lr[1]
  ).substring(0, 2).toUpperCase() + "", fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("text"), fr = text$3(ur), attr(cr, "x", "50%"), attr(cr, "y", "50%"), attr(cr, "dominant-baseline", "central"), attr(cr, "text-anchor", "middle"), attr(cr, "font-weight", "bold"), attr(cr, "font-size", 150), attr(cr, "class", dr = "avatar-text " + /*fill*/
      lr[2]), attr(ar, "class", "avatar-initials w-full h-full"), attr(ar, "viewBox", "0 0 512 512");
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, cr), append(cr, fr);
    },
    p(hr, gr) {
      gr & /*initials*/
      2 && ur !== (ur = String(
        /*initials*/
        hr[1]
      ).substring(0, 2).toUpperCase() + "") && set_data(fr, ur), gr & /*fill*/
      4 && dr !== (dr = "avatar-text " + /*fill*/
      hr[2]) && attr(cr, "class", dr);
    },
    d(hr) {
      hr && detach(ar);
    }
  };
}
function create_if_block$s(lr) {
  var yr;
  let ar, cr, ur, fr, dr, hr, gr, vr, mr = [
    {
      class: cr = "avatar-image " + cImage
    },
    {
      style: ur = /*$$props*/
      (yr = lr[8].style) != null ? yr : ""
    },
    { src: fr = /*src*/
    lr[0] },
    {
      alt: dr = /*$$props*/
      lr[8].alt || ""
    },
    /*prunedRestProps*/
    lr[7]()
  ], br = {};
  for (let kr = 0; kr < mr.length; kr += 1)
    br = assign$1(br, mr[kr]);
  return {
    c() {
      ar = element("img"), set_attributes(ar, br);
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), gr || (vr = [
        action_destroyer(hr = /*action*/
        lr[4].call(
          null,
          ar,
          /*actionParams*/
          lr[5]
        )),
        listen(
          ar,
          "error",
          /*error_handler*/
          lr[19]
        )
      ], gr = !0);
    },
    p(kr, Tr) {
      var _r;
      set_attributes(ar, br = get_spread_update(mr, [
        { class: cr },
        Tr & /*$$props*/
        256 && ur !== (ur = /*$$props*/
        (_r = kr[8].style) != null ? _r : "") && { style: ur },
        Tr & /*src*/
        1 && !src_url_equal(ar.src, fr = /*src*/
        kr[0]) && { src: fr },
        Tr & /*$$props*/
        256 && dr !== (dr = /*$$props*/
        kr[8].alt || "") && { alt: dr },
        /*prunedRestProps*/
        kr[7]()
      ])), hr && is_function(hr.update) && Tr & /*actionParams*/
      32 && hr.update.call(
        null,
        /*actionParams*/
        kr[5]
      );
    },
    d(kr) {
      kr && detach(ar), gr = !1, run_all(vr);
    }
  };
}
function create_fragment$$(lr) {
  let ar, cr, ur, fr;
  function dr(vr, mr) {
    return (
      /*src*/
      vr[0] ? create_if_block$s : create_else_block$c
    );
  }
  let hr = dr(lr), gr = hr(lr);
  return {
    c() {
      ar = element("figure"), gr.c(), attr(ar, "class", cr = "avatar " + /*classesBase*/
      lr[6]), attr(ar, "data-testid", "avatar");
    },
    m(vr, mr) {
      insert(vr, ar, mr), gr.m(ar, null), ur || (fr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[15]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[16]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[18]
        )
      ], ur = !0);
    },
    p(vr, [mr]) {
      hr === (hr = dr(vr)) && gr ? gr.p(vr, mr) : (gr.d(1), gr = hr(vr), gr && (gr.c(), gr.m(ar, null))), mr & /*classesBase*/
      64 && cr !== (cr = "avatar " + /*classesBase*/
      vr[6]) && attr(ar, "class", cr);
    },
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar), gr.d(), ur = !1, run_all(fr);
    }
  };
}
let cBase$k = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate", cImage = "w-full h-full object-cover";
function instance$G(lr, ar, cr) {
  let ur;
  const fr = [
    "initials",
    "fill",
    "src",
    "fallback",
    "action",
    "actionParams",
    "background",
    "width",
    "border",
    "rounded",
    "shadow",
    "cursor"
  ];
  let dr = compute_rest_props(ar, fr), { initials: hr = "AB" } = ar, { fill: gr = "fill-token" } = ar, { src: vr = "" } = ar, { fallback: mr = "" } = ar, { action: br = () => {
  } } = ar, { actionParams: yr = "" } = ar, { background: kr = "bg-surface-400-500-token" } = ar, { width: Tr = "w-16" } = ar, { border: _r = "" } = ar, { rounded: Er = "rounded-full" } = ar, { shadow: xr = "" } = ar, { cursor: Cr = "" } = ar;
  function Ar() {
    return delete dr.class, dr;
  }
  function Lr(Wr) {
    bubble.call(this, lr, Wr);
  }
  function Dr(Wr) {
    bubble.call(this, lr, Wr);
  }
  function Nr(Wr) {
    bubble.call(this, lr, Wr);
  }
  function Hr(Wr) {
    bubble.call(this, lr, Wr);
  }
  const $r = () => cr(0, vr = mr);
  return lr.$$set = (Wr) => {
    cr(8, ar = assign$1(assign$1({}, ar), exclude_internal_props(Wr))), cr(20, dr = compute_rest_props(ar, fr)), "initials" in Wr && cr(1, hr = Wr.initials), "fill" in Wr && cr(2, gr = Wr.fill), "src" in Wr && cr(0, vr = Wr.src), "fallback" in Wr && cr(3, mr = Wr.fallback), "action" in Wr && cr(4, br = Wr.action), "actionParams" in Wr && cr(5, yr = Wr.actionParams), "background" in Wr && cr(9, kr = Wr.background), "width" in Wr && cr(10, Tr = Wr.width), "border" in Wr && cr(11, _r = Wr.border), "rounded" in Wr && cr(12, Er = Wr.rounded), "shadow" in Wr && cr(13, xr = Wr.shadow), "cursor" in Wr && cr(14, Cr = Wr.cursor);
  }, lr.$$.update = () => {
    var Wr;
    cr(6, ur = `${cBase$k} ${kr} ${Tr} ${_r} ${Er} ${xr} ${Cr} ${(Wr = ar.class) != null ? Wr : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    hr,
    gr,
    mr,
    br,
    yr,
    ur,
    Ar,
    ar,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Lr,
    Dr,
    Nr,
    Hr,
    $r
  ];
}
class Avatar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$G, create_fragment$$, safe_not_equal, {
      initials: 1,
      fill: 2,
      src: 0,
      fallback: 3,
      action: 4,
      actionParams: 5,
      background: 9,
      width: 10,
      border: 11,
      rounded: 12,
      shadow: 13,
      cursor: 14
    });
  }
  get initials() {
    return this.$$.ctx[1];
  }
  set initials(ar) {
    this.$$set({ initials: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[2];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get src() {
    return this.$$.ctx[0];
  }
  set src(ar) {
    this.$$set({ src: ar }), flush();
  }
  get fallback() {
    return this.$$.ctx[3];
  }
  set fallback(ar) {
    this.$$set({ fallback: ar }), flush();
  }
  get action() {
    return this.$$.ctx[4];
  }
  set action(ar) {
    this.$$set({ action: ar }), flush();
  }
  get actionParams() {
    return this.$$.ctx[5];
  }
  set actionParams(ar) {
    this.$$set({ actionParams: ar }), flush();
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[10];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get border() {
    return this.$$.ctx[11];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[13];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get cursor() {
    return this.$$.ctx[14];
  }
  set cursor(ar) {
    this.$$set({ cursor: ar }), flush();
  }
}
create_custom_element(Avatar, { initials: {}, fill: {}, src: {}, fallback: {}, action: {}, actionParams: {}, background: {}, width: {}, border: {}, rounded: {}, shadow: {}, cursor: {} }, [], [], !0);
const tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      50: { hex: "#f8fafc", rgb: "248 250 252" },
      100: { hex: "#f1f5f9", rgb: "241 245 249" },
      200: { hex: "#e2e8f0", rgb: "226 232 240" },
      300: { hex: "#cbd5e1", rgb: "203 213 225" },
      400: { hex: "#94a3b8", rgb: "148 163 184" },
      500: { hex: "#64748b", rgb: "100 116 139" },
      600: { hex: "#475569", rgb: "71 85 105" },
      700: { hex: "#334155", rgb: "51 65 85" },
      800: { hex: "#1e293b", rgb: "30 41 59" },
      900: { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      50: { hex: "#f9fafb", rgb: "249 250 251" },
      100: { hex: "#f3f4f6", rgb: "243 244 246" },
      200: { hex: "#e5e7eb", rgb: "229 231 235" },
      300: { hex: "#d1d5db", rgb: "209 213 219" },
      400: { hex: "#9ca3af", rgb: "156 163 175" },
      500: { hex: "#6b7280", rgb: "107 114 128" },
      600: { hex: "#4b5563", rgb: "75 85 99" },
      700: { hex: "#374151", rgb: "55 65 81" },
      800: { hex: "#1f2937", rgb: "31 41 55" },
      900: { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f4f4f5", rgb: "244 244 245" },
      200: { hex: "#e4e4e7", rgb: "228 228 231" },
      300: { hex: "#d4d4d8", rgb: "212 212 216" },
      400: { hex: "#a1a1aa", rgb: "161 161 170" },
      500: { hex: "#71717a", rgb: "113 113 122" },
      600: { hex: "#52525b", rgb: "82 82 91" },
      700: { hex: "#3f3f46", rgb: "63 63 70" },
      800: { hex: "#27272a", rgb: "39 39 42" },
      900: { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f5f5f5", rgb: "245 245 245" },
      200: { hex: "#e5e5e5", rgb: "229 229 229" },
      300: { hex: "#d4d4d4", rgb: "212 212 212" },
      400: { hex: "#a3a3a3", rgb: "163 163 163" },
      500: { hex: "#737373", rgb: "115 115 115" },
      600: { hex: "#525252", rgb: "82 82 82" },
      700: { hex: "#404040", rgb: "64 64 64" },
      800: { hex: "#262626", rgb: "38 38 38" },
      900: { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      50: { hex: "#fafaf9", rgb: "250 250 249" },
      100: { hex: "#f5f5f4", rgb: "245 245 244" },
      200: { hex: "#e7e5e4", rgb: "231 229 228" },
      300: { hex: "#d6d3d1", rgb: "214 211 209" },
      400: { hex: "#a8a29e", rgb: "168 162 158" },
      500: { hex: "#78716c", rgb: "120 113 108" },
      600: { hex: "#57534e", rgb: "87 83 78" },
      700: { hex: "#44403c", rgb: "68 64 60" },
      800: { hex: "#292524", rgb: "41 37 36" },
      900: { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      50: { hex: "#fef2f2", rgb: "254 242 242" },
      100: { hex: "#fee2e2", rgb: "254 226 226" },
      200: { hex: "#fecaca", rgb: "254 202 202" },
      300: { hex: "#fca5a5", rgb: "252 165 165" },
      400: { hex: "#f87171", rgb: "248 113 113" },
      500: { hex: "#ef4444", rgb: "239 68 68" },
      600: { hex: "#dc2626", rgb: "220 38 38" },
      700: { hex: "#b91c1c", rgb: "185 28 28" },
      800: { hex: "#991b1b", rgb: "153 27 27" },
      900: { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      50: { hex: "#fff7ed", rgb: "255 247 237" },
      100: { hex: "#ffedd5", rgb: "255 237 213" },
      200: { hex: "#fed7aa", rgb: "254 215 170" },
      300: { hex: "#fdba74", rgb: "253 186 116" },
      400: { hex: "#fb923c", rgb: "251 146 60" },
      500: { hex: "#f97316", rgb: "249 115 22" },
      600: { hex: "#ea580c", rgb: "234 88 12" },
      700: { hex: "#c2410c", rgb: "194 65 12" },
      800: { hex: "#9a3412", rgb: "154 52 18" },
      900: { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      50: { hex: "#fffbeb", rgb: "255 251 235" },
      100: { hex: "#fef3c7", rgb: "254 243 199" },
      200: { hex: "#fde68a", rgb: "253 230 138" },
      300: { hex: "#fcd34d", rgb: "252 211 77" },
      400: { hex: "#fbbf24", rgb: "251 191 36" },
      500: { hex: "#f59e0b", rgb: "245 158 11" },
      600: { hex: "#d97706", rgb: "217 119 6" },
      700: { hex: "#b45309", rgb: "180 83 9" },
      800: { hex: "#92400e", rgb: "146 64 14" },
      900: { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      50: { hex: "#fefce8", rgb: "254 252 232" },
      100: { hex: "#fef9c3", rgb: "254 249 195" },
      200: { hex: "#fef08a", rgb: "254 240 138" },
      300: { hex: "#fde047", rgb: "253 224 71" },
      400: { hex: "#facc15", rgb: "250 204 21" },
      500: { hex: "#eab308", rgb: "234 179 8" },
      600: { hex: "#ca8a04", rgb: "202 138 4" },
      700: { hex: "#a16207", rgb: "161 98 7" },
      800: { hex: "#854d0e", rgb: "133 77 14" },
      900: { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      50: { hex: "#f7fee7", rgb: "247 254 231" },
      100: { hex: "#ecfccb", rgb: "236 252 203" },
      200: { hex: "#d9f99d", rgb: "217 249 157" },
      300: { hex: "#bef264", rgb: "190 242 100" },
      400: { hex: "#a3e635", rgb: "163 230 53" },
      500: { hex: "#84cc16", rgb: "132 204 22" },
      600: { hex: "#65a30d", rgb: "101 163 13" },
      700: { hex: "#4d7c0f", rgb: "77 124 15" },
      800: { hex: "#3f6212", rgb: "63 98 18" },
      900: { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      50: { hex: "#f0fdf4", rgb: "240 253 244" },
      100: { hex: "#dcfce7", rgb: "220 252 231" },
      200: { hex: "#bbf7d0", rgb: "187 247 208" },
      300: { hex: "#86efac", rgb: "134 239 172" },
      400: { hex: "#4ade80", rgb: "74 222 128" },
      500: { hex: "#22c55e", rgb: "34 197 94" },
      600: { hex: "#16a34a", rgb: "22 163 74" },
      700: { hex: "#15803d", rgb: "21 128 61" },
      800: { hex: "#166534", rgb: "22 101 52" },
      900: { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      50: { hex: "#ecfdf5", rgb: "236 253 245" },
      100: { hex: "#d1fae5", rgb: "209 250 229" },
      200: { hex: "#a7f3d0", rgb: "167 243 208" },
      300: { hex: "#6ee7b7", rgb: "110 231 183" },
      400: { hex: "#34d399", rgb: "52 211 153" },
      500: { hex: "#10b981", rgb: "16 185 129" },
      600: { hex: "#059669", rgb: "5 150 105" },
      700: { hex: "#047857", rgb: "4 120 87" },
      800: { hex: "#065f46", rgb: "6 95 70" },
      900: { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      50: { hex: "#f0fdfa", rgb: "240 253 250" },
      100: { hex: "#ccfbf1", rgb: "204 251 241" },
      200: { hex: "#99f6e4", rgb: "153 246 228" },
      300: { hex: "#5eead4", rgb: "94 234 212" },
      400: { hex: "#2dd4bf", rgb: "45 212 191" },
      500: { hex: "#14b8a6", rgb: "20 184 166" },
      600: { hex: "#0d9488", rgb: "13 148 136" },
      700: { hex: "#0f766e", rgb: "15 118 110" },
      800: { hex: "#115e59", rgb: "17 94 89" },
      900: { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      50: { hex: "#ecfeff", rgb: "236 254 255" },
      100: { hex: "#cffafe", rgb: "207 250 254" },
      200: { hex: "#a5f3fc", rgb: "165 243 252" },
      300: { hex: "#67e8f9", rgb: "103 232 249" },
      400: { hex: "#22d3ee", rgb: "34 211 238" },
      500: { hex: "#06b6d4", rgb: "6 182 212" },
      600: { hex: "#0891b2", rgb: "8 145 178" },
      700: { hex: "#0e7490", rgb: "14 116 144" },
      800: { hex: "#155e75", rgb: "21 94 117" },
      900: { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      50: { hex: "#f0f9ff", rgb: "240 249 255" },
      100: { hex: "#e0f2fe", rgb: "224 242 254" },
      200: { hex: "#bae6fd", rgb: "186 230 253" },
      300: { hex: "#7dd3fc", rgb: "125 211 252" },
      400: { hex: "#38bdf8", rgb: "56 189 248" },
      500: { hex: "#0ea5e9", rgb: "14 165 233" },
      600: { hex: "#0284c7", rgb: "2 132 199" },
      700: { hex: "#0369a1", rgb: "3 105 161" },
      800: { hex: "#075985", rgb: "7 89 133" },
      900: { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      50: { hex: "#eff6ff", rgb: "239 246 255" },
      100: { hex: "#dbeafe", rgb: "219 234 254" },
      200: { hex: "#bfdbfe", rgb: "191 219 254" },
      300: { hex: "#93c5fd", rgb: "147 197 253" },
      400: { hex: "#60a5fa", rgb: "96 165 250" },
      500: { hex: "#3b82f6", rgb: "59 130 246" },
      600: { hex: "#2563eb", rgb: "37 99 235" },
      700: { hex: "#1d4ed8", rgb: "29 78 216" },
      800: { hex: "#1e40af", rgb: "30 64 175" },
      900: { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      50: { hex: "#eef2ff", rgb: "238 242 255" },
      100: { hex: "#e0e7ff", rgb: "224 231 255" },
      200: { hex: "#c7d2fe", rgb: "199 210 254" },
      300: { hex: "#a5b4fc", rgb: "165 180 252" },
      400: { hex: "#818cf8", rgb: "129 140 248" },
      500: { hex: "#6366f1", rgb: "99 102 241" },
      600: { hex: "#4f46e5", rgb: "79 70 229" },
      700: { hex: "#4338ca", rgb: "67 56 202" },
      800: { hex: "#3730a3", rgb: "55 48 163" },
      900: { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      50: { hex: "#f5f3ff", rgb: "245 243 255" },
      100: { hex: "#ede9fe", rgb: "237 233 254" },
      200: { hex: "#ddd6fe", rgb: "221 214 254" },
      300: { hex: "#c4b5fd", rgb: "196 181 253" },
      400: { hex: "#a78bfa", rgb: "167 139 250" },
      500: { hex: "#8b5cf6", rgb: "139 92 246" },
      600: { hex: "#7c3aed", rgb: "124 58 237" },
      700: { hex: "#6d28d9", rgb: "109 40 217" },
      800: { hex: "#5b21b6", rgb: "91 33 182" },
      900: { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      50: { hex: "#faf5ff", rgb: "250 245 255" },
      100: { hex: "#f3e8ff", rgb: "243 232 255" },
      200: { hex: "#e9d5ff", rgb: "233 213 255" },
      300: { hex: "#d8b4fe", rgb: "216 180 254" },
      400: { hex: "#c084fc", rgb: "192 132 252" },
      500: { hex: "#a855f7", rgb: "168 85 247" },
      600: { hex: "#9333ea", rgb: "147 51 234" },
      700: { hex: "#7e22ce", rgb: "126 34 206" },
      800: { hex: "#6b21a8", rgb: "107 33 168" },
      900: { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      50: { hex: "#fdf4ff", rgb: "253 244 255" },
      100: { hex: "#fae8ff", rgb: "250 232 255" },
      200: { hex: "#f5d0fe", rgb: "245 208 254" },
      300: { hex: "#f0abfc", rgb: "240 171 252" },
      400: { hex: "#e879f9", rgb: "232 121 249" },
      500: { hex: "#d946ef", rgb: "217 70 239" },
      600: { hex: "#c026d3", rgb: "192 38 211" },
      700: { hex: "#a21caf", rgb: "162 28 175" },
      800: { hex: "#86198f", rgb: "134 25 143" },
      900: { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      50: { hex: "#fdf2f8", rgb: "253 242 248" },
      100: { hex: "#fce7f3", rgb: "252 231 243" },
      200: { hex: "#fbcfe8", rgb: "251 207 232" },
      300: { hex: "#f9a8d4", rgb: "249 168 212" },
      400: { hex: "#f472b6", rgb: "244 114 182" },
      500: { hex: "#ec4899", rgb: "236 72 153" },
      600: { hex: "#db2777", rgb: "219 39 119" },
      700: { hex: "#be185d", rgb: "190 24 93" },
      800: { hex: "#9d174d", rgb: "157 23 77" },
      900: { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      50: { hex: "#fff1f2", rgb: "255 241 242" },
      100: { hex: "#ffe4e6", rgb: "255 228 230" },
      200: { hex: "#fecdd3", rgb: "254 205 211" },
      300: { hex: "#fda4af", rgb: "253 164 175" },
      400: { hex: "#fb7185", rgb: "251 113 133" },
      500: { hex: "#f43f5e", rgb: "244 63 94" },
      600: { hex: "#e11d48", rgb: "225 29 72" },
      700: { hex: "#be123c", rgb: "190 18 60" },
      800: { hex: "#9f1239", rgb: "159 18 57" },
      900: { hex: "#881337", rgb: "136 19 55" }
    }
  }
];
function get_each_context$b(lr, ar, cr) {
  const ur = lr.slice();
  return ur[26] = ar[cr].color, ur[27] = ar[cr].label, ur[28] = ar[cr].value, ur;
}
function create_if_block_2$b(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[17].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[16],
    null
  );
  return {
    c() {
      ar = element("figcaption"), dr && dr.c(), attr(ar, "class", cr = "conic-caption " + /*classesCaption*/
      lr[7]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      65536) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[16],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[16],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[16]
        ),
        null
      ), (!ur || gr & /*classesCaption*/
      128 && cr !== (cr = "conic-caption " + /*classesCaption*/
      hr[7])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_if_block_1$e(lr) {
  let ar, cr;
  return {
    c() {
      ar = element("div"), attr(ar, "class", cr = "conic-cone " + /*classesCone*/
      lr[6]), toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        lr[1]
      ), set_style(
        ar,
        "background",
        /*cone*/
        lr[3]
      );
    },
    m(ur, fr) {
      insert(ur, ar, fr);
    },
    p(ur, fr) {
      fr & /*classesCone*/
      64 && cr !== (cr = "conic-cone " + /*classesCone*/
      ur[6]) && attr(ar, "class", cr), fr & /*classesCone, spin*/
      66 && toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        ur[1]
      ), fr & /*cone*/
      8 && set_style(
        ar,
        "background",
        /*cone*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block$r(lr) {
  let ar, cr, ur = ensure_array_like(
    /*generatedLegendList*/
    lr[4]
  ), fr = [];
  for (let dr = 0; dr < ur.length; dr += 1)
    fr[dr] = create_each_block$b(get_each_context$b(lr, ur, dr));
  return {
    c() {
      ar = element("ul");
      for (let dr = 0; dr < fr.length; dr += 1)
        fr[dr].c();
      attr(ar, "class", cr = "conic-list list " + /*classesLegend*/
      lr[5]);
    },
    m(dr, hr) {
      insert(dr, ar, hr);
      for (let gr = 0; gr < fr.length; gr += 1)
        fr[gr] && fr[gr].m(ar, null);
    },
    p(dr, hr) {
      if (hr & /*hover, generatedLegendList, cSwatch*/
      20) {
        ur = ensure_array_like(
          /*generatedLegendList*/
          dr[4]
        );
        let gr;
        for (gr = 0; gr < ur.length; gr += 1) {
          const vr = get_each_context$b(dr, ur, gr);
          fr[gr] ? fr[gr].p(vr, hr) : (fr[gr] = create_each_block$b(vr), fr[gr].c(), fr[gr].m(ar, null));
        }
        for (; gr < fr.length; gr += 1)
          fr[gr].d(1);
        fr.length = ur.length;
      }
      hr & /*classesLegend*/
      32 && cr !== (cr = "conic-list list " + /*classesLegend*/
      dr[5]) && attr(ar, "class", cr);
    },
    d(dr) {
      dr && detach(ar), destroy_each(fr, dr);
    }
  };
}
function create_each_block$b(lr) {
  let ar, cr, ur, fr, dr = (
    /*label*/
    lr[27] + ""
  ), hr, gr, vr, mr = (
    /*value*/
    lr[28] + ""
  ), br, yr, kr, Tr, _r, Er;
  return {
    c() {
      ar = element("li"), cr = element("span"), ur = space(), fr = element("span"), hr = text$3(dr), gr = space(), vr = element("strong"), br = text$3(mr), yr = text$3("%"), kr = space(), attr(cr, "class", "conic-swatch " + cSwatch), set_style(
        cr,
        "background",
        /*color*/
        lr[26]
      ), attr(fr, "class", "conic-label flex-auto"), attr(vr, "class", "conic-value"), attr(ar, "class", Tr = "conic-item " + /*hover*/
      lr[2]);
    },
    m(xr, Cr) {
      insert(xr, ar, Cr), append(ar, cr), append(ar, ur), append(ar, fr), append(fr, hr), append(ar, gr), append(ar, vr), append(vr, br), append(vr, yr), append(ar, kr), _r || (Er = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[20]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[21]
        )
      ], _r = !0);
    },
    p(xr, Cr) {
      Cr & /*generatedLegendList*/
      16 && set_style(
        cr,
        "background",
        /*color*/
        xr[26]
      ), Cr & /*generatedLegendList*/
      16 && dr !== (dr = /*label*/
      xr[27] + "") && set_data(hr, dr), Cr & /*generatedLegendList*/
      16 && mr !== (mr = /*value*/
      xr[28] + "") && set_data(br, mr), Cr & /*hover*/
      4 && Tr !== (Tr = "conic-item " + /*hover*/
      xr[2]) && attr(ar, "class", Tr);
    },
    d(xr) {
      xr && detach(ar), _r = !1, run_all(Er);
    }
  };
}
function create_fragment$_(lr) {
  let ar, cr, ur, fr, dr, hr = (
    /*$$slots*/
    lr[9].default && create_if_block_2$b(lr)
  ), gr = (
    /*cone*/
    lr[3] && create_if_block_1$e(lr)
  ), vr = (
    /*legend*/
    lr[0] && /*generatedLegendList*/
    lr[4] && create_if_block$r(lr)
  );
  return {
    c() {
      ar = element("figure"), hr && hr.c(), cr = space(), gr && gr.c(), ur = space(), vr && vr.c(), attr(ar, "class", fr = "conic-gradient " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "conic-gradient");
    },
    m(mr, br) {
      insert(mr, ar, br), hr && hr.m(ar, null), append(ar, cr), gr && gr.m(ar, null), append(ar, ur), vr && vr.m(ar, null), dr = !0;
    },
    p(mr, [br]) {
      /*$$slots*/
      mr[9].default ? hr ? (hr.p(mr, br), br & /*$$slots*/
      512 && transition_in(hr, 1)) : (hr = create_if_block_2$b(mr), hr.c(), transition_in(hr, 1), hr.m(ar, cr)) : hr && (group_outros(), transition_out(hr, 1, 1, () => {
        hr = null;
      }), check_outros()), /*cone*/
      mr[3] ? gr ? gr.p(mr, br) : (gr = create_if_block_1$e(mr), gr.c(), gr.m(ar, ur)) : gr && (gr.d(1), gr = null), /*legend*/
      mr[0] && /*generatedLegendList*/
      mr[4] ? vr ? vr.p(mr, br) : (vr = create_if_block$r(mr), vr.c(), vr.m(ar, null)) : vr && (vr.d(1), vr = null), (!dr || br & /*classesBase*/
      256 && fr !== (fr = "conic-gradient " + /*classesBase*/
      mr[8])) && attr(ar, "class", fr);
    },
    i(mr) {
      dr || (transition_in(hr), dr = !0);
    },
    o(mr) {
      transition_out(hr), dr = !1;
    },
    d(mr) {
      mr && detach(ar), hr && hr.d(), gr && gr.d(), vr && vr.d();
    }
  };
}
const cBase$j = "flex flex-col items-center space-y-4 w-", cCaption = "text-center", cCone = "block aspect-square rounded-full", cLegend = "text-sm w-full", cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance$F(lr, ar, cr) {
  let ur, fr, dr, hr, { $$slots: gr = {}, $$scope: vr } = ar;
  const mr = compute_slots(gr);
  let { stops: br = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = ar, { legend: yr = !1 } = ar, { spin: kr = !1 } = ar, { width: Tr = "w-24" } = ar, { hover: _r = "bg-primary-hover-token" } = ar, { digits: Er = 0 } = ar, { regionCaption: xr = "" } = ar, { regionCone: Cr = "" } = ar, { regionLegend: Ar = "" } = ar, Lr, Dr;
  function Nr(Yr) {
    if (typeof Yr == "string")
      return Yr;
    const li = tailwindDefaultColors.find((Si) => Si.label === Yr[0]);
    return li == null ? void 0 : li.shades[Yr[1]].hex;
  }
  function Hr() {
    let Yr = br.map((li) => `${Nr(li.color)} ${li.start}% ${li.end}%`);
    cr(3, Lr = `conic-gradient(${Yr.join(", ")})`);
  }
  function $r() {
    yr && cr(4, Dr = br.map((Yr) => ({
      label: Yr.label,
      color: Nr(Yr.color),
      value: (Yr.end - Yr.start).toFixed(Er)
    })));
  }
  afterUpdate(() => {
    Hr(), $r();
  });
  function Wr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Zr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function oi(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Jr(Yr) {
    bubble.call(this, lr, Yr);
  }
  return lr.$$set = (Yr) => {
    cr(25, ar = assign$1(assign$1({}, ar), exclude_internal_props(Yr))), "stops" in Yr && cr(10, br = Yr.stops), "legend" in Yr && cr(0, yr = Yr.legend), "spin" in Yr && cr(1, kr = Yr.spin), "width" in Yr && cr(11, Tr = Yr.width), "hover" in Yr && cr(2, _r = Yr.hover), "digits" in Yr && cr(12, Er = Yr.digits), "regionCaption" in Yr && cr(13, xr = Yr.regionCaption), "regionCone" in Yr && cr(14, Cr = Yr.regionCone), "regionLegend" in Yr && cr(15, Ar = Yr.regionLegend), "$$scope" in Yr && cr(16, vr = Yr.$$scope);
  }, lr.$$.update = () => {
    var Yr;
    cr(8, ur = `${cBase$j} ${(Yr = ar.class) != null ? Yr : ""}`), lr.$$.dirty & /*regionCaption*/
    8192 && cr(7, fr = `${cCaption} ${xr}`), lr.$$.dirty & /*width, regionCone*/
    18432 && cr(6, dr = `${cCone} ${Tr} ${Cr}`), lr.$$.dirty & /*regionLegend*/
    32768 && cr(5, hr = `${cLegend} ${Ar}`);
  }, ar = exclude_internal_props(ar), [
    yr,
    kr,
    _r,
    Lr,
    Dr,
    hr,
    dr,
    fr,
    ur,
    mr,
    br,
    Tr,
    Er,
    xr,
    Cr,
    Ar,
    vr,
    gr,
    Wr,
    Zr,
    oi,
    Jr
  ];
}
class ConicGradient extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$F, create_fragment$_, safe_not_equal, {
      stops: 10,
      legend: 0,
      spin: 1,
      width: 11,
      hover: 2,
      digits: 12,
      regionCaption: 13,
      regionCone: 14,
      regionLegend: 15
    });
  }
  get stops() {
    return this.$$.ctx[10];
  }
  set stops(ar) {
    this.$$set({ stops: ar }), flush();
  }
  get legend() {
    return this.$$.ctx[0];
  }
  set legend(ar) {
    this.$$set({ legend: ar }), flush();
  }
  get spin() {
    return this.$$.ctx[1];
  }
  set spin(ar) {
    this.$$set({ spin: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[2];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get digits() {
    return this.$$.ctx[12];
  }
  set digits(ar) {
    this.$$set({ digits: ar }), flush();
  }
  get regionCaption() {
    return this.$$.ctx[13];
  }
  set regionCaption(ar) {
    this.$$set({ regionCaption: ar }), flush();
  }
  get regionCone() {
    return this.$$.ctx[14];
  }
  set regionCone(ar) {
    this.$$set({ regionCone: ar }), flush();
  }
  get regionLegend() {
    return this.$$.ctx[15];
  }
  set regionLegend(ar) {
    this.$$set({ regionLegend: ar }), flush();
  }
}
create_custom_element(ConicGradient, { stops: {}, legend: { type: "Boolean" }, spin: { type: "Boolean" }, width: {}, hover: {}, digits: {}, regionCaption: {}, regionCone: {}, regionLegend: {} }, ["default"], [], !0);
function fallback_block$3(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Select a File");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_fragment$Z(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr = [
    { type: "file" },
    { name: (
      /*name*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[6]()
  ], Tr = {};
  for (let Cr = 0; Cr < kr.length; Cr += 1)
    Tr = assign$1(Tr, kr[Cr]);
  const _r = (
    /*#slots*/
    lr[11].default
  ), Er = create_slot(
    _r,
    lr,
    /*$$scope*/
    lr[10],
    null
  ), xr = Er || fallback_block$3();
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("input"), fr = space(), dr = element("button"), xr && xr.c(), set_attributes(ur, Tr), attr(cr, "class", "w-0 h-0 overflow-hidden"), attr(dr, "type", "button"), attr(dr, "class", hr = "file-button-btn " + /*classesButton*/
      lr[3]), dr.disabled = gr = /*$$restProps*/
      lr[7].disabled, attr(ar, "class", vr = "file-button " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "file-button");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), append(cr, ur), ur.autofocus && ur.focus(), lr[16](ur), append(ar, fr), append(ar, dr), xr && xr.m(dr, null), mr = !0, br || (yr = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          lr[17]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          lr[15]
        ),
        listen(
          dr,
          "click",
          /*onButtonClick*/
          lr[5]
        ),
        listen(
          dr,
          "keydown",
          /*keydown_handler*/
          lr[12]
        ),
        listen(
          dr,
          "keyup",
          /*keyup_handler*/
          lr[13]
        ),
        listen(
          dr,
          "keypress",
          /*keypress_handler*/
          lr[14]
        )
      ], br = !0);
    },
    p(Cr, [Ar]) {
      set_attributes(ur, Tr = get_spread_update(kr, [
        { type: "file" },
        (!mr || Ar & /*name*/
        4) && { name: (
          /*name*/
          Cr[2]
        ) },
        /*prunedRestProps*/
        Cr[6]()
      ])), Er && Er.p && (!mr || Ar & /*$$scope*/
      1024) && update_slot_base(
        Er,
        _r,
        Cr,
        /*$$scope*/
        Cr[10],
        mr ? get_slot_changes(
          _r,
          /*$$scope*/
          Cr[10],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Cr[10]
        ),
        null
      ), (!mr || Ar & /*classesButton*/
      8 && hr !== (hr = "file-button-btn " + /*classesButton*/
      Cr[3])) && attr(dr, "class", hr), (!mr || Ar & /*$$restProps*/
      128 && gr !== (gr = /*$$restProps*/
      Cr[7].disabled)) && (dr.disabled = gr), (!mr || Ar & /*classesBase*/
      16 && vr !== (vr = "file-button " + /*classesBase*/
      Cr[4])) && attr(ar, "class", vr);
    },
    i(Cr) {
      mr || (transition_in(xr, Cr), mr = !0);
    },
    o(Cr) {
      transition_out(xr, Cr), mr = !1;
    },
    d(Cr) {
      Cr && detach(ar), lr[16](null), xr && xr.d(Cr), br = !1, run_all(yr);
    }
  };
}
function instance$E(lr, ar, cr) {
  let ur, fr;
  const dr = ["files", "fileInput", "name", "width", "button"];
  let hr = compute_rest_props(ar, dr), { $$slots: gr = {}, $$scope: vr } = ar, { files: mr = void 0 } = ar, { fileInput: br = void 0 } = ar, { name: yr } = ar, { width: kr = "" } = ar, { button: Tr = "btn variant-filled" } = ar;
  function _r() {
    br && br.click();
  }
  function Er() {
    return delete hr.class, hr;
  }
  function xr(Hr) {
    bubble.call(this, lr, Hr);
  }
  function Cr(Hr) {
    bubble.call(this, lr, Hr);
  }
  function Ar(Hr) {
    bubble.call(this, lr, Hr);
  }
  function Lr(Hr) {
    bubble.call(this, lr, Hr);
  }
  function Dr(Hr) {
    binding_callbacks[Hr ? "unshift" : "push"](() => {
      br = Hr, cr(1, br);
    });
  }
  function Nr() {
    mr = this.files, cr(0, mr);
  }
  return lr.$$set = (Hr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Hr))), cr(7, hr = compute_rest_props(ar, dr)), "files" in Hr && cr(0, mr = Hr.files), "fileInput" in Hr && cr(1, br = Hr.fileInput), "name" in Hr && cr(2, yr = Hr.name), "width" in Hr && cr(8, kr = Hr.width), "button" in Hr && cr(9, Tr = Hr.button), "$$scope" in Hr && cr(10, vr = Hr.$$scope);
  }, lr.$$.update = () => {
    var Hr;
    cr(4, ur = `${(Hr = ar.class) != null ? Hr : ""}`), lr.$$.dirty & /*button, width*/
    768 && cr(3, fr = `${Tr} ${kr}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    br,
    yr,
    fr,
    ur,
    _r,
    Er,
    hr,
    kr,
    Tr,
    vr,
    gr,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr
  ];
}
class FileButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$E, create_fragment$Z, safe_not_equal, {
      files: 0,
      fileInput: 1,
      name: 2,
      width: 8,
      button: 9
    });
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get width() {
    return this.$$.ctx[8];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get button() {
    return this.$$.ctx[9];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
}
create_custom_element(FileButton, { files: {}, fileInput: {}, name: {}, width: {}, button: {} }, ["default"], [], !0);
const get_meta_slot_changes = (lr) => ({}), get_meta_slot_context = (lr) => ({}), get_message_slot_changes = (lr) => ({}), get_message_slot_context = (lr) => ({}), get_lead_slot_changes$4 = (lr) => ({}), get_lead_slot_context$4 = (lr) => ({});
function create_if_block_1$d(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[18].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[17],
    get_lead_slot_context$4
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "dropzone-lead " + /*slotLead*/
      lr[5]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr[0] & /*$$scope*/
      131072) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[17],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[17],
          gr,
          get_lead_slot_changes$4
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[17]
        ),
        get_lead_slot_context$4
      ), (!ur || gr[0] & /*slotLead*/
      32 && cr !== (cr = "dropzone-lead " + /*slotLead*/
      hr[5])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function fallback_block$2(lr) {
  let ar, cr;
  return {
    c() {
      ar = element("strong"), ar.textContent = "Upload a file", cr = text$3(" or drag and drop");
    },
    m(ur, fr) {
      insert(ur, ar, fr), insert(ur, cr, fr);
    },
    p: noop$1,
    d(ur) {
      ur && (detach(ar), detach(cr));
    }
  };
}
function create_if_block$q(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[18].meta
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[17],
    get_meta_slot_context
  );
  return {
    c() {
      ar = element("small"), dr && dr.c(), attr(ar, "class", cr = "dropzone-meta " + /*slotMeta*/
      lr[7]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr[0] & /*$$scope*/
      131072) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[17],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[17],
          gr,
          get_meta_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[17]
        ),
        get_meta_slot_context
      ), (!ur || gr[0] & /*slotMeta*/
      128 && cr !== (cr = "dropzone-meta " + /*slotMeta*/
      hr[7])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$Y(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr = [
    { type: "file" },
    { name: (
      /*name*/
      lr[2]
    ) },
    {
      class: ur = "dropzone-input " + /*classesInput*/
      lr[9]
    },
    /*prunedRestProps*/
    lr[11]()
  ], Ar = {};
  for (let Wr = 0; Wr < Cr.length; Wr += 1)
    Ar = assign$1(Ar, Cr[Wr]);
  let Lr = (
    /*$$slots*/
    lr[13].lead && create_if_block_1$d(lr)
  );
  const Dr = (
    /*#slots*/
    lr[18].message
  ), Nr = create_slot(
    Dr,
    lr,
    /*$$scope*/
    lr[17],
    get_message_slot_context
  ), Hr = Nr || fallback_block$2();
  let $r = (
    /*$$slots*/
    lr[13].meta && create_if_block$q(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("input"), fr = space(), dr = element("div"), hr = element("div"), Lr && Lr.c(), gr = space(), vr = element("div"), Hr && Hr.c(), br = space(), $r && $r.c(), set_attributes(cr, Ar), attr(vr, "class", mr = "dropzone-message " + /*slotMessage*/
      lr[6]), attr(hr, "class", yr = "dropzone-interface-text " + /*regionInterfaceText*/
      lr[4]), attr(dr, "class", kr = "dropzone-interface " + /*classesInterface*/
      lr[8] + " " + /*regionInterface*/
      lr[3]), attr(ar, "class", Tr = "dropzone " + /*classesBase*/
      lr[10]), attr(ar, "data-testid", "file-dropzone"), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        lr[12].disabled
      );
    },
    m(Wr, Zr) {
      insert(Wr, ar, Zr), append(ar, cr), cr.autofocus && cr.focus(), lr[32](cr), append(ar, fr), append(ar, dr), append(dr, hr), Lr && Lr.m(hr, null), append(hr, gr), append(hr, vr), Hr && Hr.m(vr, null), append(hr, br), $r && $r.m(hr, null), _r = !0, Er || (xr = [
        listen(
          cr,
          "change",
          /*input_change_handler*/
          lr[31]
        ),
        listen(
          cr,
          "change",
          /*change_handler*/
          lr[19]
        ),
        listen(
          cr,
          "dragenter",
          /*dragenter_handler*/
          lr[20]
        ),
        listen(
          cr,
          "dragover",
          /*dragover_handler*/
          lr[21]
        ),
        listen(
          cr,
          "dragleave",
          /*dragleave_handler*/
          lr[22]
        ),
        listen(
          cr,
          "drop",
          /*drop_handler*/
          lr[23]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[25]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[26]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[27]
        ),
        listen(
          cr,
          "focus",
          /*focus_handler*/
          lr[28]
        ),
        listen(
          cr,
          "focusin",
          /*focusin_handler*/
          lr[29]
        ),
        listen(
          cr,
          "focusout",
          /*focusout_handler*/
          lr[30]
        )
      ], Er = !0);
    },
    p(Wr, Zr) {
      set_attributes(cr, Ar = get_spread_update(Cr, [
        { type: "file" },
        (!_r || Zr[0] & /*name*/
        4) && { name: (
          /*name*/
          Wr[2]
        ) },
        (!_r || Zr[0] & /*classesInput*/
        512 && ur !== (ur = "dropzone-input " + /*classesInput*/
        Wr[9])) && { class: ur },
        /*prunedRestProps*/
        Wr[11]()
      ])), /*$$slots*/
      Wr[13].lead ? Lr ? (Lr.p(Wr, Zr), Zr[0] & /*$$slots*/
      8192 && transition_in(Lr, 1)) : (Lr = create_if_block_1$d(Wr), Lr.c(), transition_in(Lr, 1), Lr.m(hr, gr)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!_r || Zr[0] & /*$$scope*/
      131072) && update_slot_base(
        Nr,
        Dr,
        Wr,
        /*$$scope*/
        Wr[17],
        _r ? get_slot_changes(
          Dr,
          /*$$scope*/
          Wr[17],
          Zr,
          get_message_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Wr[17]
        ),
        get_message_slot_context
      ), (!_r || Zr[0] & /*slotMessage*/
      64 && mr !== (mr = "dropzone-message " + /*slotMessage*/
      Wr[6])) && attr(vr, "class", mr), /*$$slots*/
      Wr[13].meta ? $r ? ($r.p(Wr, Zr), Zr[0] & /*$$slots*/
      8192 && transition_in($r, 1)) : ($r = create_if_block$q(Wr), $r.c(), transition_in($r, 1), $r.m(hr, null)) : $r && (group_outros(), transition_out($r, 1, 1, () => {
        $r = null;
      }), check_outros()), (!_r || Zr[0] & /*regionInterfaceText*/
      16 && yr !== (yr = "dropzone-interface-text " + /*regionInterfaceText*/
      Wr[4])) && attr(hr, "class", yr), (!_r || Zr[0] & /*classesInterface, regionInterface*/
      264 && kr !== (kr = "dropzone-interface " + /*classesInterface*/
      Wr[8] + " " + /*regionInterface*/
      Wr[3])) && attr(dr, "class", kr), (!_r || Zr[0] & /*classesBase*/
      1024 && Tr !== (Tr = "dropzone " + /*classesBase*/
      Wr[10])) && attr(ar, "class", Tr), (!_r || Zr[0] & /*classesBase, $$restProps*/
      5120) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Wr[12].disabled
      );
    },
    i(Wr) {
      _r || (transition_in(Lr), transition_in(Hr, Wr), transition_in($r), _r = !0);
    },
    o(Wr) {
      transition_out(Lr), transition_out(Hr, Wr), transition_out($r), _r = !1;
    },
    d(Wr) {
      Wr && detach(ar), lr[32](null), Lr && Lr.d(), Hr && Hr.d(Wr), $r && $r.d(), Er = !1, run_all(xr);
    }
  };
}
const cBase$i = "textarea relative flex justify-center items-center", cInput = "w-full absolute top-0 left-0 right-0 bottom-0 z-[1] opacity-0 disabled:!opacity-0 cursor-pointer", cInterface$2 = "flex justify-center items-center text-center";
function instance$D(lr, ar, cr) {
  let ur, fr, dr;
  const hr = [
    "files",
    "fileInput",
    "name",
    "border",
    "padding",
    "rounded",
    "regionInterface",
    "regionInterfaceText",
    "slotLead",
    "slotMessage",
    "slotMeta"
  ];
  let gr = compute_rest_props(ar, hr), { $$slots: vr = {}, $$scope: mr } = ar;
  const br = compute_slots(vr);
  let { files: yr = void 0 } = ar, { fileInput: kr = void 0 } = ar, { name: Tr } = ar, { border: _r = "border-2 border-dashed" } = ar, { padding: Er = "p-4 py-8" } = ar, { rounded: xr = "rounded-container-token" } = ar, { regionInterface: Cr = "" } = ar, { regionInterfaceText: Ar = "" } = ar, { slotLead: Lr = "mb-4" } = ar, { slotMessage: Dr = "" } = ar, { slotMeta: Nr = "opacity-75" } = ar;
  function Hr() {
    return delete gr.class, gr;
  }
  function $r(ui) {
    bubble.call(this, lr, ui);
  }
  function Wr(ui) {
    bubble.call(this, lr, ui);
  }
  function Zr(ui) {
    bubble.call(this, lr, ui);
  }
  function oi(ui) {
    bubble.call(this, lr, ui);
  }
  function Jr(ui) {
    bubble.call(this, lr, ui);
  }
  function Yr(ui) {
    bubble.call(this, lr, ui);
  }
  function li(ui) {
    bubble.call(this, lr, ui);
  }
  function Si(ui) {
    bubble.call(this, lr, ui);
  }
  function ci(ui) {
    bubble.call(this, lr, ui);
  }
  function hi(ui) {
    bubble.call(this, lr, ui);
  }
  function Ei(ui) {
    bubble.call(this, lr, ui);
  }
  function di(ui) {
    bubble.call(this, lr, ui);
  }
  function gi() {
    yr = this.files, cr(0, yr);
  }
  function Li(ui) {
    binding_callbacks[ui ? "unshift" : "push"](() => {
      kr = ui, cr(1, kr);
    });
  }
  return lr.$$set = (ui) => {
    cr(33, ar = assign$1(assign$1({}, ar), exclude_internal_props(ui))), cr(12, gr = compute_rest_props(ar, hr)), "files" in ui && cr(0, yr = ui.files), "fileInput" in ui && cr(1, kr = ui.fileInput), "name" in ui && cr(2, Tr = ui.name), "border" in ui && cr(14, _r = ui.border), "padding" in ui && cr(15, Er = ui.padding), "rounded" in ui && cr(16, xr = ui.rounded), "regionInterface" in ui && cr(3, Cr = ui.regionInterface), "regionInterfaceText" in ui && cr(4, Ar = ui.regionInterfaceText), "slotLead" in ui && cr(5, Lr = ui.slotLead), "slotMessage" in ui && cr(6, Dr = ui.slotMessage), "slotMeta" in ui && cr(7, Nr = ui.slotMeta), "$$scope" in ui && cr(17, mr = ui.$$scope);
  }, lr.$$.update = () => {
    var ui;
    cr(10, ur = `${cBase$i} ${_r} ${Er} ${xr} ${(ui = ar.class) != null ? ui : ""}`);
  }, cr(9, fr = `${cInput}`), cr(8, dr = `${cInterface$2}`), ar = exclude_internal_props(ar), [
    yr,
    kr,
    Tr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    dr,
    fr,
    ur,
    Hr,
    gr,
    br,
    _r,
    Er,
    xr,
    mr,
    vr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    Li
  ];
}
class FileDropzone extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$D,
      create_fragment$Y,
      safe_not_equal,
      {
        files: 0,
        fileInput: 1,
        name: 2,
        border: 14,
        padding: 15,
        rounded: 16,
        regionInterface: 3,
        regionInterfaceText: 4,
        slotLead: 5,
        slotMessage: 6,
        slotMeta: 7
      },
      null,
      [-1, -1]
    );
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[15];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[16];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionInterface() {
    return this.$$.ctx[3];
  }
  set regionInterface(ar) {
    this.$$set({ regionInterface: ar }), flush();
  }
  get regionInterfaceText() {
    return this.$$.ctx[4];
  }
  set regionInterfaceText(ar) {
    this.$$set({ regionInterfaceText: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[5];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotMessage() {
    return this.$$.ctx[6];
  }
  set slotMessage(ar) {
    this.$$set({ slotMessage: ar }), flush();
  }
  get slotMeta() {
    return this.$$.ctx[7];
  }
  set slotMeta(ar) {
    this.$$set({ slotMeta: ar }), flush();
  }
}
create_custom_element(FileDropzone, { files: {}, fileInput: {}, name: {}, border: {}, padding: {}, rounded: {}, regionInterface: {}, regionInterfaceText: {}, slotLead: {}, slotMessage: {}, slotMeta: {} }, ["lead", "message", "meta"], [], !0);
function flip(lr, { from: ar, to: cr }, ur = {}) {
  const fr = getComputedStyle(lr), dr = fr.transform === "none" ? "" : fr.transform, [hr, gr] = fr.transformOrigin.split(" ").map(parseFloat), vr = ar.left + ar.width * hr / cr.width - (cr.left + hr), mr = ar.top + ar.height * gr / cr.height - (cr.top + gr), { delay: br = 0, duration: yr = (Tr) => Math.sqrt(Tr) * 120, easing: kr = cubicOut } = ur;
  return {
    delay: br,
    duration: is_function(yr) ? yr(Math.sqrt(vr * vr + mr * mr)) : yr,
    easing: kr,
    css: (Tr, _r) => {
      const Er = _r * vr, xr = _r * mr, Cr = Tr + _r * ar.width / cr.width, Ar = Tr + _r * ar.height / cr.height;
      return `transform: ${dr} translate(${Er}px, ${xr}px) scale(${Cr}, ${Ar});`;
    }
  };
}
function get_each_context$a(lr, ar, cr) {
  const ur = lr.slice();
  return ur[56] = ar[cr].id, ur[57] = ar[cr].val, ur[59] = cr, ur;
}
function get_each_context_1$4(lr, ar, cr) {
  const ur = lr.slice();
  return ur[60] = ar[cr], ur;
}
function create_each_block_1$4(lr) {
  let ar, cr = (
    /*option*/
    lr[60] + ""
  ), ur, fr;
  return {
    c() {
      ar = element("option"), ur = text$3(cr), ar.__value = fr = /*option*/
      lr[60], set_input_value(ar, ar.__value);
    },
    m(dr, hr) {
      insert(dr, ar, hr), append(ar, ur);
    },
    p(dr, hr) {
      hr[0] & /*value*/
      1 && cr !== (cr = /*option*/
      dr[60] + "") && set_data(ur, cr), hr[0] & /*value*/
      1 && fr !== (fr = /*option*/
      dr[60]) && (ar.__value = fr, set_input_value(ar, ar.__value));
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block$p(lr) {
  let ar, cr = [], ur = /* @__PURE__ */ new Map(), fr, dr, hr, gr, vr = ensure_array_like(
    /*chipValues*/
    lr[15]
  );
  const mr = (br) => (
    /*id*/
    br[56]
  );
  for (let br = 0; br < vr.length; br += 1) {
    let yr = get_each_context$a(lr, vr, br), kr = mr(yr);
    ur.set(kr, cr[br] = create_each_block$a(kr, yr));
  }
  return {
    c() {
      ar = element("div");
      for (let br = 0; br < cr.length; br += 1)
        cr[br].c();
      attr(ar, "class", fr = "input-chip-list " + /*classesChipList*/
      lr[18]);
    },
    m(br, yr) {
      insert(br, ar, yr);
      for (let kr = 0; kr < cr.length; kr += 1)
        cr[kr] && cr[kr].m(ar, null);
      gr = !0;
    },
    p(br, yr) {
      if (lr = br, yr[0] & /*chips, chipTransitionOut, chipTransitionOutParams, transitions, removeChip, chipValues*/
      8446048) {
        vr = ensure_array_like(
          /*chipValues*/
          lr[15]
        ), group_outros();
        for (let kr = 0; kr < cr.length; kr += 1)
          cr[kr].r();
        cr = update_keyed_each(cr, yr, mr, 1, lr, vr, ur, ar, fix_and_outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
        for (let kr = 0; kr < cr.length; kr += 1)
          cr[kr].a();
        check_outros();
      }
      (!gr || yr[0] & /*classesChipList*/
      262144 && fr !== (fr = "input-chip-list " + /*classesChipList*/
      lr[18])) && attr(ar, "class", fr);
    },
    i(br) {
      if (!gr) {
        for (let yr = 0; yr < vr.length; yr += 1)
          transition_in(cr[yr]);
        br && add_render_callback(() => {
          gr && (hr && hr.end(1), dr = create_in_transition(ar, dynamicTransition, {
            transition: (
              /*listTransitionIn*/
              lr[7]
            ),
            params: (
              /*listTransitionInParams*/
              lr[8]
            ),
            enabled: (
              /*transitions*/
              lr[6]
            )
          }), dr.start());
        }), gr = !0;
      }
    },
    o(br) {
      for (let yr = 0; yr < cr.length; yr += 1)
        transition_out(cr[yr]);
      dr && dr.invalidate(), br && (hr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*listTransitionOut*/
          lr[9]
        ),
        params: (
          /*listTransitionOutParams*/
          lr[10]
        ),
        enabled: (
          /*transitions*/
          lr[6]
        )
      })), gr = !1;
    },
    d(br) {
      br && detach(ar);
      for (let yr = 0; yr < cr.length; yr += 1)
        cr[yr].d();
      br && hr && hr.end();
    }
  };
}
function create_each_block$a(lr, ar) {
  let cr, ur, fr, dr = (
    /*val*/
    ar[57] + ""
  ), hr, gr, vr, mr, br, yr, kr, Tr, _r = noop$1, Er, xr, Cr;
  function Ar(...Lr) {
    return (
      /*click_handler_1*/
      ar[50](
        /*i*/
        ar[59],
        /*val*/
        ar[57],
        ...Lr
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      cr = element("div"), ur = element("button"), fr = element("span"), hr = text$3(dr), gr = space(), vr = element("span"), vr.textContent = "✕", kr = space(), attr(ur, "type", "button"), attr(ur, "class", mr = "chip " + /*chips*/
      ar[5]), this.first = cr;
    },
    m(Lr, Dr) {
      insert(Lr, cr, Dr), append(cr, ur), append(ur, fr), append(fr, hr), append(ur, gr), append(ur, vr), append(cr, kr), Er = !0, xr || (Cr = [
        listen(ur, "click", Ar),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[40]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[41]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          ar[42]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          ar[43]
        )
      ], xr = !0);
    },
    p(Lr, Dr) {
      ar = Lr, (!Er || Dr[0] & /*chipValues*/
      32768) && dr !== (dr = /*val*/
      ar[57] + "") && set_data(hr, dr), (!Er || Dr[0] & /*chips*/
      32 && mr !== (mr = "chip " + /*chips*/
      ar[5])) && attr(ur, "class", mr);
    },
    r() {
      Tr = cr.getBoundingClientRect();
    },
    f() {
      fix_position(cr), _r();
    },
    a() {
      _r(), _r = create_animation(cr, Tr, flip, { duration: (
        /*duration*/
        ar[3]
      ) });
    },
    i(Lr) {
      Er || (Lr && add_render_callback(() => {
        Er && (yr && yr.end(1), br = create_in_transition(ur, dynamicTransition, {
          transition: (
            /*chipTransitionIn*/
            ar[11]
          ),
          params: (
            /*chipTransitionInParams*/
            ar[12]
          ),
          enabled: (
            /*transitions*/
            ar[6]
          )
        }), br.start());
      }), Er = !0);
    },
    o(Lr) {
      br && br.invalidate(), Lr && (yr = create_out_transition(ur, dynamicTransition, {
        transition: (
          /*chipTransitionOut*/
          ar[13]
        ),
        params: (
          /*chipTransitionOutParams*/
          ar[14]
        ),
        enabled: (
          /*transitions*/
          ar[6]
        )
      })), Er = !1;
    },
    d(Lr) {
      Lr && detach(cr), Lr && yr && yr.end(), xr = !1, run_all(Cr);
    }
  };
}
function create_fragment$X(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr = ensure_array_like(
    /*value*/
    lr[0]
  ), Ar = [];
  for (let Dr = 0; Dr < Cr.length; Dr += 1)
    Ar[Dr] = create_each_block_1$4(get_each_context_1$4(lr, Cr, Dr));
  let Lr = (
    /*chipValues*/
    lr[15].length && create_if_block$p(lr)
  );
  return {
    c() {
      var Dr;
      ar = element("div"), cr = element("div"), ur = element("select");
      for (let Nr = 0; Nr < Ar.length; Nr += 1)
        Ar[Nr].c();
      fr = space(), dr = element("div"), hr = element("form"), gr = element("input"), yr = space(), Lr && Lr.c(), attr(
        ur,
        "name",
        /*name*/
        lr[2]
      ), ur.multiple = !0, ur.required = /*required*/
      lr[4], attr(ur, "tabindex", "-1"), /*value*/
      lr[0] === void 0 && add_render_callback(() => (
        /*select_change_handler*/
        lr[48].call(ur)
      )), attr(cr, "class", "h-0 overflow-hidden"), attr(gr, "type", "text"), attr(gr, "placeholder", vr = /*$$restProps*/
      (Dr = lr[24].placeholder) != null ? Dr : "Enter values..."), attr(gr, "class", mr = "input-chip-field " + /*classesInput*/
      lr[17]), gr.disabled = br = /*$$restProps*/
      lr[24].disabled, attr(dr, "class", kr = "input-chip-wrapper " + /*classesChipWrapper*/
      lr[19]), attr(ar, "class", Tr = "input-chip " + /*classesBase*/
      lr[20]), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        lr[24].disabled
      );
    },
    m(Dr, Nr) {
      insert(Dr, ar, Nr), append(ar, cr), append(cr, ur);
      for (let Hr = 0; Hr < Ar.length; Hr += 1)
        Ar[Hr] && Ar[Hr].m(ur, null);
      lr[47](ur), select_options(
        ur,
        /*value*/
        lr[0]
      ), append(ar, fr), append(ar, dr), append(dr, hr), append(hr, gr), set_input_value(
        gr,
        /*input*/
        lr[1]
      ), append(dr, yr), Lr && Lr.m(dr, null), _r = !0, Er || (xr = [
        listen(
          ur,
          "change",
          /*select_change_handler*/
          lr[48]
        ),
        listen(
          gr,
          "input",
          /*input_1_input_handler*/
          lr[49]
        ),
        listen(
          gr,
          "input",
          /*onInputHandler*/
          lr[21]
        ),
        listen(
          gr,
          "input",
          /*input_handler*/
          lr[44]
        ),
        listen(
          gr,
          "focus",
          /*focus_handler*/
          lr[45]
        ),
        listen(
          gr,
          "blur",
          /*blur_handler*/
          lr[46]
        ),
        listen(
          hr,
          "submit",
          /*addChip*/
          lr[22]
        )
      ], Er = !0);
    },
    p(Dr, Nr) {
      var Hr;
      if (Nr[0] & /*value*/
      1) {
        Cr = ensure_array_like(
          /*value*/
          Dr[0]
        );
        let $r;
        for ($r = 0; $r < Cr.length; $r += 1) {
          const Wr = get_each_context_1$4(Dr, Cr, $r);
          Ar[$r] ? Ar[$r].p(Wr, Nr) : (Ar[$r] = create_each_block_1$4(Wr), Ar[$r].c(), Ar[$r].m(ur, null));
        }
        for (; $r < Ar.length; $r += 1)
          Ar[$r].d(1);
        Ar.length = Cr.length;
      }
      (!_r || Nr[0] & /*name*/
      4) && attr(
        ur,
        "name",
        /*name*/
        Dr[2]
      ), (!_r || Nr[0] & /*required*/
      16) && (ur.required = /*required*/
      Dr[4]), Nr[0] & /*value*/
      1 && select_options(
        ur,
        /*value*/
        Dr[0]
      ), (!_r || Nr[0] & /*$$restProps*/
      16777216 && vr !== (vr = /*$$restProps*/
      (Hr = Dr[24].placeholder) != null ? Hr : "Enter values...")) && attr(gr, "placeholder", vr), (!_r || Nr[0] & /*classesInput*/
      131072 && mr !== (mr = "input-chip-field " + /*classesInput*/
      Dr[17])) && attr(gr, "class", mr), (!_r || Nr[0] & /*$$restProps*/
      16777216 && br !== (br = /*$$restProps*/
      Dr[24].disabled)) && (gr.disabled = br), Nr[0] & /*input*/
      2 && gr.value !== /*input*/
      Dr[1] && set_input_value(
        gr,
        /*input*/
        Dr[1]
      ), /*chipValues*/
      Dr[15].length ? Lr ? (Lr.p(Dr, Nr), Nr[0] & /*chipValues*/
      32768 && transition_in(Lr, 1)) : (Lr = create_if_block$p(Dr), Lr.c(), transition_in(Lr, 1), Lr.m(dr, null)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), (!_r || Nr[0] & /*classesChipWrapper*/
      524288 && kr !== (kr = "input-chip-wrapper " + /*classesChipWrapper*/
      Dr[19])) && attr(dr, "class", kr), (!_r || Nr[0] & /*classesBase*/
      1048576 && Tr !== (Tr = "input-chip " + /*classesBase*/
      Dr[20])) && attr(ar, "class", Tr), (!_r || Nr[0] & /*classesBase, $$restProps*/
      17825792) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Dr[24].disabled
      );
    },
    i(Dr) {
      _r || (transition_in(Lr), _r = !0);
    },
    o(Dr) {
      transition_out(Lr), _r = !1;
    },
    d(Dr) {
      Dr && detach(ar), destroy_each(Ar, Dr), lr[47](null), Lr && Lr.d(), Er = !1, run_all(xr);
    }
  };
}
const cBase$h = "textarea cursor-pointer", cChipWrapper = "space-y-4", cChipList = "flex flex-wrap gap-2", cInputField = "unstyled bg-transparent border-0 !ring-0 p-0 w-full";
function instance$C(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  const vr = [
    "input",
    "name",
    "value",
    "whitelist",
    "max",
    "minlength",
    "maxlength",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "duration",
    "required",
    "chips",
    "invalid",
    "padding",
    "rounded",
    "regionChipWrapper",
    "regionChipList",
    "regionInput",
    "transitions",
    "listTransitionIn",
    "listTransitionInParams",
    "listTransitionOut",
    "listTransitionOutParams",
    "chipTransitionIn",
    "chipTransitionInParams",
    "chipTransitionOut",
    "chipTransitionOutParams"
  ];
  let mr = compute_rest_props(ar, vr), br;
  component_subscribe(lr, prefersReducedMotionStore, (Gi) => cr(51, br = Gi));
  const yr = createEventDispatcher();
  let { input: kr = "" } = ar, { name: Tr } = ar, { value: _r = [] } = ar, { whitelist: Er = [] } = ar, { max: xr = -1 } = ar, { minlength: Cr = -1 } = ar, { maxlength: Ar = -1 } = ar, { allowUpperCase: Lr = !1 } = ar, { allowDuplicates: Dr = !1 } = ar, { validation: Nr = () => !0 } = ar, { duration: Hr = 150 } = ar, { required: $r = !1 } = ar, { chips: Wr = "variant-filled" } = ar, { invalid: Zr = "input-error" } = ar, { padding: oi = "p-2" } = ar, { rounded: Jr = "rounded-container-token" } = ar, { regionChipWrapper: Yr = "" } = ar, { regionChipList: li = "" } = ar, { regionInput: Si = "" } = ar, { transitions: ci = !br } = ar, { listTransitionIn: hi = fly } = ar, { listTransitionInParams: Ei = { duration: 150, opacity: 0, y: -20 } } = ar, { listTransitionOut: di = fly } = ar, { listTransitionOutParams: gi = { duration: 150, opacity: 0, y: -20 } } = ar, { chipTransitionIn: Li = scale } = ar, { chipTransitionInParams: ui = { duration: 150, opacity: 0 } } = ar, { chipTransitionOut: wi = scale } = ar, { chipTransitionOutParams: Ui = { duration: 150, opacity: 0 } } = ar, yi = !0, Vi = (_r == null ? void 0 : _r.map((Gi) => ({ val: Gi, id: Math.random() }))) || [];
  function Oi() {
    cr(0, _r = []);
  }
  let Mi;
  onMount(() => {
    if (!Mi.form)
      return;
    const Gi = Mi.form;
    return Gi.addEventListener("reset", Oi), () => {
      Gi.removeEventListener("reset", Oi);
    };
  });
  function Ii() {
    cr(38, yi = !0);
  }
  function mi() {
    return !(!kr || (cr(1, kr = kr.trim()), Nr !== void 0 && !Nr(kr)) || xr !== -1 && _r.length >= xr || Cr !== -1 && kr.length < Cr || Ar !== -1 && kr.length > Ar || Er.length > 0 && !Er.includes(kr) || Dr === !1 && _r.includes(kr));
  }
  function _i(Gi) {
    if (Gi.preventDefault(), cr(38, yi = mi()), yi === !1) {
      yr("invalid", { event: Gi, input: kr });
      return;
    }
    cr(1, kr = Lr ? kr : kr.toLowerCase()), _r.push(kr), cr(0, _r), Vi.push({ val: kr, id: Math.random() }), cr(15, Vi), cr(0, _r), yr("add", {
      event: Gi,
      chipIndex: _r.length - 1,
      chipValue: kr
    }), cr(1, kr = "");
  }
  function Ci(Gi, ha, Ua) {
    mr.disabled || (_r.splice(ha, 1), cr(0, _r), Vi.splice(ha, 1), cr(15, Vi), cr(0, _r), yr("remove", { event: Gi, chipIndex: ha, chipValue: Ua }));
  }
  function Ki(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Ni(Gi) {
    bubble.call(this, lr, Gi);
  }
  function ia(Gi) {
    bubble.call(this, lr, Gi);
  }
  function ea(Gi) {
    bubble.call(this, lr, Gi);
  }
  function la(Gi) {
    bubble.call(this, lr, Gi);
  }
  function ma(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Ba(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Fa(Gi) {
    binding_callbacks[Gi ? "unshift" : "push"](() => {
      Mi = Gi, cr(16, Mi);
    });
  }
  function Ia() {
    _r = select_multiple_value(this), cr(0, _r);
  }
  function Hi() {
    kr = this.value, cr(1, kr);
  }
  const oa = (Gi, ha, Ua) => {
    Ci(Ua, Gi, ha);
  };
  return lr.$$set = (Gi) => {
    cr(55, ar = assign$1(assign$1({}, ar), exclude_internal_props(Gi))), cr(24, mr = compute_rest_props(ar, vr)), "input" in Gi && cr(1, kr = Gi.input), "name" in Gi && cr(2, Tr = Gi.name), "value" in Gi && cr(0, _r = Gi.value), "whitelist" in Gi && cr(25, Er = Gi.whitelist), "max" in Gi && cr(26, xr = Gi.max), "minlength" in Gi && cr(27, Cr = Gi.minlength), "maxlength" in Gi && cr(28, Ar = Gi.maxlength), "allowUpperCase" in Gi && cr(29, Lr = Gi.allowUpperCase), "allowDuplicates" in Gi && cr(30, Dr = Gi.allowDuplicates), "validation" in Gi && cr(31, Nr = Gi.validation), "duration" in Gi && cr(3, Hr = Gi.duration), "required" in Gi && cr(4, $r = Gi.required), "chips" in Gi && cr(5, Wr = Gi.chips), "invalid" in Gi && cr(32, Zr = Gi.invalid), "padding" in Gi && cr(33, oi = Gi.padding), "rounded" in Gi && cr(34, Jr = Gi.rounded), "regionChipWrapper" in Gi && cr(35, Yr = Gi.regionChipWrapper), "regionChipList" in Gi && cr(36, li = Gi.regionChipList), "regionInput" in Gi && cr(37, Si = Gi.regionInput), "transitions" in Gi && cr(6, ci = Gi.transitions), "listTransitionIn" in Gi && cr(7, hi = Gi.listTransitionIn), "listTransitionInParams" in Gi && cr(8, Ei = Gi.listTransitionInParams), "listTransitionOut" in Gi && cr(9, di = Gi.listTransitionOut), "listTransitionOutParams" in Gi && cr(10, gi = Gi.listTransitionOutParams), "chipTransitionIn" in Gi && cr(11, Li = Gi.chipTransitionIn), "chipTransitionInParams" in Gi && cr(12, ui = Gi.chipTransitionInParams), "chipTransitionOut" in Gi && cr(13, wi = Gi.chipTransitionOut), "chipTransitionOutParams" in Gi && cr(14, Ui = Gi.chipTransitionOutParams);
  }, lr.$$.update = () => {
    var Gi;
    lr.$$.dirty[1] & /*inputValid, invalid*/
    130 && cr(39, ur = yi === !1 ? Zr : ""), cr(20, fr = `${cBase$h} ${oi} ${Jr} ${(Gi = ar.class) != null ? Gi : ""} ${ur}`), lr.$$.dirty[1] & /*regionChipWrapper*/
    16 && cr(19, dr = `${cChipWrapper} ${Yr}`), lr.$$.dirty[1] & /*regionChipList*/
    32 && cr(18, hr = `${cChipList} ${li}`), lr.$$.dirty[1] & /*regionInput*/
    64 && cr(17, gr = `${cInputField} ${Si}`), lr.$$.dirty[0] & /*value, chipValues*/
    32769 && cr(15, Vi = (_r == null ? void 0 : _r.map((ha, Ua) => {
      var eo;
      return ((eo = Vi[Ua]) == null ? void 0 : eo.val) === ha ? Vi[Ua] : { id: Math.random(), val: ha };
    })) || []);
  }, ar = exclude_internal_props(ar), [
    _r,
    kr,
    Tr,
    Hr,
    $r,
    Wr,
    ci,
    hi,
    Ei,
    di,
    gi,
    Li,
    ui,
    wi,
    Ui,
    Vi,
    Mi,
    gr,
    hr,
    dr,
    fr,
    Ii,
    _i,
    Ci,
    mr,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    yi,
    ur,
    Ki,
    Ni,
    ia,
    ea,
    la,
    ma,
    Ba,
    Fa,
    Ia,
    Hi,
    oa
  ];
}
class InputChip extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$C,
      create_fragment$X,
      safe_not_equal,
      {
        input: 1,
        name: 2,
        value: 0,
        whitelist: 25,
        max: 26,
        minlength: 27,
        maxlength: 28,
        allowUpperCase: 29,
        allowDuplicates: 30,
        validation: 31,
        duration: 3,
        required: 4,
        chips: 5,
        invalid: 32,
        padding: 33,
        rounded: 34,
        regionChipWrapper: 35,
        regionChipList: 36,
        regionInput: 37,
        transitions: 6,
        listTransitionIn: 7,
        listTransitionInParams: 8,
        listTransitionOut: 9,
        listTransitionOutParams: 10,
        chipTransitionIn: 11,
        chipTransitionInParams: 12,
        chipTransitionOut: 13,
        chipTransitionOutParams: 14
      },
      null,
      [-1, -1, -1]
    );
  }
  get input() {
    return this.$$.ctx[1];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get whitelist() {
    return this.$$.ctx[25];
  }
  set whitelist(ar) {
    this.$$set({ whitelist: ar }), flush();
  }
  get max() {
    return this.$$.ctx[26];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get minlength() {
    return this.$$.ctx[27];
  }
  set minlength(ar) {
    this.$$set({ minlength: ar }), flush();
  }
  get maxlength() {
    return this.$$.ctx[28];
  }
  set maxlength(ar) {
    this.$$set({ maxlength: ar }), flush();
  }
  get allowUpperCase() {
    return this.$$.ctx[29];
  }
  set allowUpperCase(ar) {
    this.$$set({ allowUpperCase: ar }), flush();
  }
  get allowDuplicates() {
    return this.$$.ctx[30];
  }
  set allowDuplicates(ar) {
    this.$$set({ allowDuplicates: ar }), flush();
  }
  get validation() {
    return this.$$.ctx[31];
  }
  set validation(ar) {
    this.$$set({ validation: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[3];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get required() {
    return this.$$.ctx[4];
  }
  set required(ar) {
    this.$$set({ required: ar }), flush();
  }
  get chips() {
    return this.$$.ctx[5];
  }
  set chips(ar) {
    this.$$set({ chips: ar }), flush();
  }
  get invalid() {
    return this.$$.ctx[32];
  }
  set invalid(ar) {
    this.$$set({ invalid: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[33];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionChipWrapper() {
    return this.$$.ctx[35];
  }
  set regionChipWrapper(ar) {
    this.$$set({ regionChipWrapper: ar }), flush();
  }
  get regionChipList() {
    return this.$$.ctx[36];
  }
  set regionChipList(ar) {
    this.$$set({ regionChipList: ar }), flush();
  }
  get regionInput() {
    return this.$$.ctx[37];
  }
  set regionInput(ar) {
    this.$$set({ regionInput: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[6];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get listTransitionIn() {
    return this.$$.ctx[7];
  }
  set listTransitionIn(ar) {
    this.$$set({ listTransitionIn: ar }), flush();
  }
  get listTransitionInParams() {
    return this.$$.ctx[8];
  }
  set listTransitionInParams(ar) {
    this.$$set({ listTransitionInParams: ar }), flush();
  }
  get listTransitionOut() {
    return this.$$.ctx[9];
  }
  set listTransitionOut(ar) {
    this.$$set({ listTransitionOut: ar }), flush();
  }
  get listTransitionOutParams() {
    return this.$$.ctx[10];
  }
  set listTransitionOutParams(ar) {
    this.$$set({ listTransitionOutParams: ar }), flush();
  }
  get chipTransitionIn() {
    return this.$$.ctx[11];
  }
  set chipTransitionIn(ar) {
    this.$$set({ chipTransitionIn: ar }), flush();
  }
  get chipTransitionInParams() {
    return this.$$.ctx[12];
  }
  set chipTransitionInParams(ar) {
    this.$$set({ chipTransitionInParams: ar }), flush();
  }
  get chipTransitionOut() {
    return this.$$.ctx[13];
  }
  set chipTransitionOut(ar) {
    this.$$set({ chipTransitionOut: ar }), flush();
  }
  get chipTransitionOutParams() {
    return this.$$.ctx[14];
  }
  set chipTransitionOutParams(ar) {
    this.$$set({ chipTransitionOutParams: ar }), flush();
  }
}
create_custom_element(InputChip, { input: {}, name: {}, value: {}, whitelist: {}, max: {}, minlength: {}, maxlength: {}, allowUpperCase: { type: "Boolean" }, allowDuplicates: { type: "Boolean" }, validation: {}, duration: {}, required: { type: "Boolean" }, chips: {}, invalid: {}, padding: {}, rounded: {}, regionChipWrapper: {}, regionChipList: {}, regionInput: {}, transitions: {}, listTransitionIn: {}, listTransitionInParams: {}, listTransitionOut: {}, listTransitionOutParams: {}, chipTransitionIn: {}, chipTransitionInParams: {}, chipTransitionOut: {}, chipTransitionOutParams: {} }, [], [], !0);
function create_fragment$W(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[12].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[11],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox " + /*classesBase*/
      lr[1]), attr(ar, "role", "listbox"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(ar, "data-testid", "listbox");
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, [gr]) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      2048) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[11],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[11],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[11]
        ),
        null
      ), (!ur || gr & /*classesBase*/
      2 && cr !== (cr = "listbox " + /*classesBase*/
      hr[1])) && attr(ar, "class", cr), (!ur || gr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        hr[0]
      );
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
const cBase$g = "";
function instance$B(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { multiple: hr = !1 } = ar, { spacing: gr = "space-y-1" } = ar, { rounded: vr = "rounded-token" } = ar, { active: mr = "variant-filled" } = ar, { hover: br = "hover:variant-soft" } = ar, { padding: yr = "px-4 py-2" } = ar, { regionLead: kr = "" } = ar, { regionDefault: Tr = "" } = ar, { regionTrail: _r = "" } = ar, { labelledby: Er = "" } = ar;
  return setContext("multiple", hr), setContext("rounded", vr), setContext("active", mr), setContext("hover", br), setContext("padding", yr), setContext("regionLead", kr), setContext("regionDefault", Tr), setContext("regionTrail", _r), lr.$$set = (xr) => {
    cr(13, ar = assign$1(assign$1({}, ar), exclude_internal_props(xr))), "multiple" in xr && cr(2, hr = xr.multiple), "spacing" in xr && cr(3, gr = xr.spacing), "rounded" in xr && cr(4, vr = xr.rounded), "active" in xr && cr(5, mr = xr.active), "hover" in xr && cr(6, br = xr.hover), "padding" in xr && cr(7, yr = xr.padding), "regionLead" in xr && cr(8, kr = xr.regionLead), "regionDefault" in xr && cr(9, Tr = xr.regionDefault), "regionTrail" in xr && cr(10, _r = xr.regionTrail), "labelledby" in xr && cr(0, Er = xr.labelledby), "$$scope" in xr && cr(11, dr = xr.$$scope);
  }, lr.$$.update = () => {
    var xr;
    cr(1, ur = `${cBase$g} ${gr} ${vr} ${(xr = ar.class) != null ? xr : ""}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    ur,
    hr,
    gr,
    vr,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    dr,
    fr
  ];
}
class ListBox extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$B, create_fragment$W, safe_not_equal, {
      multiple: 2,
      spacing: 3,
      rounded: 4,
      active: 5,
      hover: 6,
      padding: 7,
      regionLead: 8,
      regionDefault: 9,
      regionTrail: 10,
      labelledby: 0
    });
  }
  get multiple() {
    return this.$$.ctx[2];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[4];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[5];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[9];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[10];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ListBox, { multiple: { type: "Boolean" }, spacing: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, labelledby: {} }, ["default"], [], !0);
const get_trail_slot_changes$1 = (lr) => ({}), get_trail_slot_context$1 = (lr) => ({}), get_lead_slot_changes$3 = (lr) => ({}), get_lead_slot_context$3 = (lr) => ({});
function create_else_block$b(lr) {
  let ar, cr = !1, ur, fr, dr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    lr[35][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        lr[1]
      ), ar.__value = /*value*/
      lr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1"), ur.p(ar);
    },
    m(hr, gr) {
      insert(hr, ar, gr), lr[33](ar), ar.checked = ar.__value === /*group*/
      lr[0], fr || (dr = [
        listen(
          ar,
          "change",
          /*input_change_handler_1*/
          lr[34]
        ),
        listen(
          ar,
          "click",
          /*click_handler_1*/
          lr[29]
        ),
        listen(
          ar,
          "change",
          /*change_handler_1*/
          lr[30]
        )
      ], fr = !0);
    },
    p(hr, gr) {
      gr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        hr[1]
      ), gr[0] & /*value*/
      4 && (ar.__value = /*value*/
      hr[2], set_input_value(ar, ar.__value), cr = !0), (cr || gr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      hr[0]);
    },
    d(hr) {
      hr && detach(ar), lr[33](null), ur.r(), fr = !1, run_all(dr);
    }
  };
}
function create_if_block_2$a(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        lr[1]
      ), ar.__value = /*value*/
      lr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1");
    },
    m(fr, dr) {
      insert(fr, ar, dr), lr[31](ar), ar.checked = /*checked*/
      lr[4], cr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          lr[32]
        ),
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[27]
        ),
        listen(
          ar,
          "change",
          /*change_handler*/
          lr[28]
        )
      ], cr = !0);
    },
    p(fr, dr) {
      dr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        fr[1]
      ), dr[0] & /*value*/
      4 && (ar.__value = /*value*/
      fr[2], set_input_value(ar, ar.__value)), dr[0] & /*checked*/
      16 && (ar.checked = /*checked*/
      fr[4]);
    },
    d(fr) {
      fr && detach(ar), lr[31](null), cr = !1, run_all(ur);
    }
  };
}
function create_if_block_1$c(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_lead_slot_context$3
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox-label-lead " + /*classesRegionLead*/
      lr[9]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[22],
          gr,
          get_lead_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[22]
        ),
        get_lead_slot_context$3
      ), (!ur || gr[0] & /*classesRegionLead*/
      512 && cr !== (cr = "listbox-label-lead " + /*classesRegionLead*/
      hr[9])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_if_block$o(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].trail
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_trail_slot_context$1
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox-label-trail " + /*classesRegionTrail*/
      lr[7]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[22],
          gr,
          get_trail_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[22]
        ),
        get_trail_slot_context$1
      ), (!ur || gr[0] & /*classesRegionTrail*/
      128 && cr !== (cr = "listbox-label-trail " + /*classesRegionTrail*/
      hr[7])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$V(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r;
  function Er(Hr, $r) {
    return (
      /*multiple*/
      Hr[3] ? create_if_block_2$a : create_else_block$b
    );
  }
  let xr = Er(lr), Cr = xr(lr), Ar = (
    /*$$slots*/
    lr[13].lead && create_if_block_1$c(lr)
  );
  const Lr = (
    /*#slots*/
    lr[23].default
  ), Dr = create_slot(
    Lr,
    lr,
    /*$$scope*/
    lr[22],
    null
  );
  let Nr = (
    /*$$slots*/
    lr[13].trail && create_if_block$o(lr)
  );
  return {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), Cr.c(), fr = space(), dr = element("div"), Ar && Ar.c(), hr = space(), gr = element("div"), Dr && Dr.c(), mr = space(), Nr && Nr.c(), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(gr, "class", vr = "listbox-label-content " + /*classesRegionDefault*/
      lr[8]), attr(dr, "class", br = "listbox-label " + /*classesLabel*/
      lr[10]), attr(cr, "class", yr = "listbox-item " + /*classesBase*/
      lr[11]), attr(cr, "data-testid", "listbox-item"), attr(cr, "role", "option"), attr(
        cr,
        "aria-selected",
        /*selected*/
        lr[5]
      ), attr(cr, "tabindex", "0");
    },
    m(Hr, $r) {
      insert(Hr, ar, $r), append(ar, cr), append(cr, ur), Cr.m(ur, null), append(cr, fr), append(cr, dr), Ar && Ar.m(dr, null), append(dr, hr), append(dr, gr), Dr && Dr.m(gr, null), append(dr, mr), Nr && Nr.m(dr, null), kr = !0, Tr || (_r = [
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[12]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[25]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[26]
        )
      ], Tr = !0);
    },
    p(Hr, $r) {
      xr === (xr = Er(Hr)) && Cr ? Cr.p(Hr, $r) : (Cr.d(1), Cr = xr(Hr), Cr && (Cr.c(), Cr.m(ur, null))), /*$$slots*/
      Hr[13].lead ? Ar ? (Ar.p(Hr, $r), $r[0] & /*$$slots*/
      8192 && transition_in(Ar, 1)) : (Ar = create_if_block_1$c(Hr), Ar.c(), transition_in(Ar, 1), Ar.m(dr, hr)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), Dr && Dr.p && (!kr || $r[0] & /*$$scope*/
      4194304) && update_slot_base(
        Dr,
        Lr,
        Hr,
        /*$$scope*/
        Hr[22],
        kr ? get_slot_changes(
          Lr,
          /*$$scope*/
          Hr[22],
          $r,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Hr[22]
        ),
        null
      ), (!kr || $r[0] & /*classesRegionDefault*/
      256 && vr !== (vr = "listbox-label-content " + /*classesRegionDefault*/
      Hr[8])) && attr(gr, "class", vr), /*$$slots*/
      Hr[13].trail ? Nr ? (Nr.p(Hr, $r), $r[0] & /*$$slots*/
      8192 && transition_in(Nr, 1)) : (Nr = create_if_block$o(Hr), Nr.c(), transition_in(Nr, 1), Nr.m(dr, null)) : Nr && (group_outros(), transition_out(Nr, 1, 1, () => {
        Nr = null;
      }), check_outros()), (!kr || $r[0] & /*classesLabel*/
      1024 && br !== (br = "listbox-label " + /*classesLabel*/
      Hr[10])) && attr(dr, "class", br), (!kr || $r[0] & /*classesBase*/
      2048 && yr !== (yr = "listbox-item " + /*classesBase*/
      Hr[11])) && attr(cr, "class", yr), (!kr || $r[0] & /*selected*/
      32) && attr(
        cr,
        "aria-selected",
        /*selected*/
        Hr[5]
      );
    },
    i(Hr) {
      kr || (transition_in(Ar), transition_in(Dr, Hr), transition_in(Nr), kr = !0);
    },
    o(Hr) {
      transition_out(Ar), transition_out(Dr, Hr), transition_out(Nr), kr = !1;
    },
    d(Hr) {
      Hr && detach(ar), Cr.d(), Ar && Ar.d(), Dr && Dr.d(Hr), Nr && Nr.d(), Tr = !1, run_all(_r);
    }
  };
}
const cBase$f = "cursor-pointer -outline-offset-[3px]", cLabel$2 = "flex items-center space-x-4", cRegionLead = "", cRegionDefault = "flex-1", cRegionTrail = "";
function areDeeplyEqual(lr, ar) {
  if (lr === ar)
    return !0;
  if (!(lr instanceof Object) || !(ar instanceof Object))
    return !1;
  const cr = Object.keys(lr), ur = Object.keys(ar);
  if (cr.length !== ur.length)
    return !1;
  for (const fr of cr) {
    const dr = lr[fr], hr = ar[fr];
    if (!areDeeplyEqual(dr, hr))
      return !1;
  }
  return !0;
}
function instance$A(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, { $$slots: br = {}, $$scope: yr } = ar;
  const kr = compute_slots(br);
  let { group: Tr } = ar, { name: _r } = ar, { value: Er } = ar, { multiple: xr = getContext("multiple") } = ar, { rounded: Cr = getContext("rounded") } = ar, { active: Ar = getContext("active") } = ar, { hover: Lr = getContext("hover") } = ar, { padding: Dr = getContext("padding") } = ar, { regionLead: Nr = getContext("regionLead") } = ar, { regionDefault: Hr = getContext("regionDefault") } = ar, { regionTrail: $r = getContext("regionTrail") } = ar, Wr, Zr;
  function oi(Vi) {
    cr(4, Wr = Vi.indexOf(Er) >= 0);
  }
  function Jr(Vi) {
    const Oi = Tr.indexOf(Er);
    Vi ? Oi < 0 && (Tr.push(Er), cr(0, Tr)) : Oi >= 0 && (Tr.splice(Oi, 1), cr(0, Tr));
  }
  function Yr(Vi) {
    ["Enter", "Space"].includes(Vi.code) && (Vi.preventDefault(), Zr.click());
  }
  const li = [[]];
  function Si(Vi) {
    bubble.call(this, lr, Vi);
  }
  function ci(Vi) {
    bubble.call(this, lr, Vi);
  }
  function hi(Vi) {
    bubble.call(this, lr, Vi);
  }
  function Ei(Vi) {
    bubble.call(this, lr, Vi);
  }
  function di(Vi) {
    bubble.call(this, lr, Vi);
  }
  function gi(Vi) {
    bubble.call(this, lr, Vi);
  }
  function Li(Vi) {
    bubble.call(this, lr, Vi);
  }
  function ui(Vi) {
    binding_callbacks[Vi ? "unshift" : "push"](() => {
      Zr = Vi, cr(6, Zr);
    });
  }
  function wi() {
    Wr = this.checked, cr(4, Wr);
  }
  function Ui(Vi) {
    binding_callbacks[Vi ? "unshift" : "push"](() => {
      Zr = Vi, cr(6, Zr);
    });
  }
  function yi() {
    Tr = this.__value, cr(0, Tr);
  }
  return lr.$$set = (Vi) => {
    cr(38, ar = assign$1(assign$1({}, ar), exclude_internal_props(Vi))), "group" in Vi && cr(0, Tr = Vi.group), "name" in Vi && cr(1, _r = Vi.name), "value" in Vi && cr(2, Er = Vi.value), "multiple" in Vi && cr(3, xr = Vi.multiple), "rounded" in Vi && cr(14, Cr = Vi.rounded), "active" in Vi && cr(15, Ar = Vi.active), "hover" in Vi && cr(16, Lr = Vi.hover), "padding" in Vi && cr(17, Dr = Vi.padding), "regionLead" in Vi && cr(18, Nr = Vi.regionLead), "regionDefault" in Vi && cr(19, Hr = Vi.regionDefault), "regionTrail" in Vi && cr(20, $r = Vi.regionTrail), "$$scope" in Vi && cr(22, yr = Vi.$$scope);
  }, lr.$$.update = () => {
    var Vi;
    lr.$$.dirty[0] & /*multiple, group*/
    9 && xr && oi(Tr), lr.$$.dirty[0] & /*multiple, checked*/
    24 && xr && Jr(Wr), lr.$$.dirty[0] & /*multiple, group, value*/
    13 && cr(5, ur = xr ? Tr.some((Oi) => areDeeplyEqual(Er, Oi)) : areDeeplyEqual(Tr, Er)), lr.$$.dirty[0] & /*selected, active, hover*/
    98336 && cr(21, fr = ur ? Ar : Lr), cr(11, dr = `${cBase$f} ${Cr} ${Dr} ${fr} ${(Vi = ar.class) != null ? Vi : ""}`), lr.$$.dirty[0] & /*regionLead*/
    262144 && cr(9, gr = `${cRegionLead} ${Nr}`), lr.$$.dirty[0] & /*regionDefault*/
    524288 && cr(8, vr = `${cRegionDefault} ${Hr}`), lr.$$.dirty[0] & /*regionTrail*/
    1048576 && cr(7, mr = `${cRegionTrail} ${$r}`);
  }, cr(10, hr = `${cLabel$2}`), ar = exclude_internal_props(ar), [
    Tr,
    _r,
    Er,
    xr,
    Wr,
    ur,
    Zr,
    mr,
    vr,
    gr,
    hr,
    dr,
    Yr,
    kr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    fr,
    yr,
    br,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    Li,
    ui,
    wi,
    Ui,
    yi,
    li
  ];
}
class ListBoxItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$A,
      create_fragment$V,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        multiple: 3,
        rounded: 14,
        active: 15,
        hover: 16,
        padding: 17,
        regionLead: 18,
        regionDefault: 19,
        regionTrail: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[3];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[15];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[18];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[19];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[20];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
}
create_custom_element(ListBoxItem, { group: {}, name: {}, value: {}, multiple: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {} }, ["lead", "default", "trail"], [], !0);
const leftArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>', rightArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"/></svg>', leftAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/></svg>', rightAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>';
function get_each_context$9(lr, ar, cr) {
  const ur = lr.slice();
  return ur[43] = ar[cr], ur;
}
function get_each_context_1$3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[46] = ar[cr], ur;
}
function create_if_block_5$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr = ensure_array_like(
    /*settings*/
    lr[0].amounts
  ), vr = [];
  for (let mr = 0; mr < gr.length; mr += 1)
    vr[mr] = create_each_block_1$3(get_each_context_1$3(lr, gr, mr));
  return {
    c() {
      ar = element("label"), cr = element("select");
      for (let mr = 0; mr < vr.length; mr += 1)
        vr[mr].c();
      attr(cr, "class", ur = "paginator-select " + /*classesSelect*/
      lr[19]), cr.disabled = /*disabled*/
      lr[1], attr(cr, "aria-label", "Select Amount"), /*settings*/
      lr[0].limit === void 0 && add_render_callback(() => (
        /*select_1_change_handler*/
        lr[32].call(cr)
      )), attr(ar, "class", fr = "paginator-label " + /*classesLabel*/
      lr[20]);
    },
    m(mr, br) {
      insert(mr, ar, br), append(ar, cr);
      for (let yr = 0; yr < vr.length; yr += 1)
        vr[yr] && vr[yr].m(cr, null);
      select_option(
        cr,
        /*settings*/
        lr[0].limit,
        !0
      ), dr || (hr = [
        listen(
          cr,
          "change",
          /*select_1_change_handler*/
          lr[32]
        ),
        listen(
          cr,
          "change",
          /*onChangeLength*/
          lr[23]
        )
      ], dr = !0);
    },
    p(mr, br) {
      if (br[0] & /*settings, amountText*/
      33) {
        gr = ensure_array_like(
          /*settings*/
          mr[0].amounts
        );
        let yr;
        for (yr = 0; yr < gr.length; yr += 1) {
          const kr = get_each_context_1$3(mr, gr, yr);
          vr[yr] ? vr[yr].p(kr, br) : (vr[yr] = create_each_block_1$3(kr), vr[yr].c(), vr[yr].m(cr, null));
        }
        for (; yr < vr.length; yr += 1)
          vr[yr].d(1);
        vr.length = gr.length;
      }
      br[0] & /*classesSelect*/
      524288 && ur !== (ur = "paginator-select " + /*classesSelect*/
      mr[19]) && attr(cr, "class", ur), br[0] & /*disabled*/
      2 && (cr.disabled = /*disabled*/
      mr[1]), br[0] & /*settings*/
      1 && select_option(
        cr,
        /*settings*/
        mr[0].limit
      ), br[0] & /*classesLabel*/
      1048576 && fr !== (fr = "paginator-label " + /*classesLabel*/
      mr[20]) && attr(ar, "class", fr);
    },
    d(mr) {
      mr && detach(ar), destroy_each(vr, mr), dr = !1, run_all(hr);
    }
  };
}
function create_each_block_1$3(lr) {
  let ar, cr = (
    /*amount*/
    lr[46] + ""
  ), ur, fr, dr, hr;
  return {
    c() {
      ar = element("option"), ur = text$3(cr), fr = space(), dr = text$3(
        /*amountText*/
        lr[5]
      ), ar.__value = hr = /*amount*/
      lr[46], set_input_value(ar, ar.__value);
    },
    m(gr, vr) {
      insert(gr, ar, vr), append(ar, ur), append(ar, fr), append(ar, dr);
    },
    p(gr, vr) {
      vr[0] & /*settings*/
      1 && cr !== (cr = /*amount*/
      gr[46] + "") && set_data(ur, cr), vr[0] & /*amountText*/
      32 && set_data(
        dr,
        /*amountText*/
        gr[5]
      ), vr[0] & /*settings*/
      1 && hr !== (hr = /*amount*/
      gr[46]) && (ar.__value = hr, set_input_value(ar, ar.__value));
    },
    d(gr) {
      gr && detach(ar);
    }
  };
}
function create_if_block_4$5(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelFirst*/
        lr[12]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      lr[0].page === 0;
    },
    m(dr, hr) {
      insert(dr, ar, hr), ar.innerHTML = /*buttonTextFirst*/
      lr[9], ur || (fr = listen(
        ar,
        "click",
        /*click_handler*/
        lr[33]
      ), ur = !0);
    },
    p(dr, hr) {
      hr[0] & /*buttonTextFirst*/
      512 && (ar.innerHTML = /*buttonTextFirst*/
      dr[9]), hr[0] & /*labelFirst*/
      4096 && attr(
        ar,
        "aria-label",
        /*labelFirst*/
        dr[12]
      ), hr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), hr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      dr[0].page === 0) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_3$7(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        lr[13]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      lr[0].page === 0;
    },
    m(dr, hr) {
      insert(dr, ar, hr), ar.innerHTML = /*buttonTextPrevious*/
      lr[7], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_1*/
        lr[34]
      ), ur = !0);
    },
    p(dr, hr) {
      hr[0] & /*buttonTextPrevious*/
      128 && (ar.innerHTML = /*buttonTextPrevious*/
      dr[7]), hr[0] & /*labelPrevious*/
      8192 && attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        dr[13]
      ), hr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), hr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      dr[0].page === 0) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_else_block$a(lr) {
  let ar, cr = ensure_array_like(
    /*controlPages*/
    lr[17]
  ), ur = [];
  for (let fr = 0; fr < cr.length; fr += 1)
    ur[fr] = create_each_block$9(get_each_context$9(lr, cr, fr));
  return {
    c() {
      for (let fr = 0; fr < ur.length; fr += 1)
        ur[fr].c();
      ar = empty$1();
    },
    m(fr, dr) {
      for (let hr = 0; hr < ur.length; hr += 1)
        ur[hr] && ur[hr].m(fr, dr);
      insert(fr, ar, dr);
    },
    p(fr, dr) {
      if (dr[0] & /*buttonClasses, classesButtonActive, controlPages, gotoPage*/
      21102656) {
        cr = ensure_array_like(
          /*controlPages*/
          fr[17]
        );
        let hr;
        for (hr = 0; hr < cr.length; hr += 1) {
          const gr = get_each_context$9(fr, cr, hr);
          ur[hr] ? ur[hr].p(gr, dr) : (ur[hr] = create_each_block$9(gr), ur[hr].c(), ur[hr].m(ar.parentNode, ar));
        }
        for (; hr < ur.length; hr += 1)
          ur[hr].d(1);
        ur.length = cr.length;
      }
    },
    d(fr) {
      fr && detach(ar), destroy_each(ur, fr);
    }
  };
}
function create_if_block_2$9(lr) {
  let ar, cr = (
    /*settings*/
    lr[0].page * /*settings*/
    lr[0].limit + 1 + ""
  ), ur, fr, dr = Math.min(
    /*settings*/
    lr[0].page * /*settings*/
    lr[0].limit + /*settings*/
    lr[0].limit,
    /*settings*/
    lr[0].size
  ) + "", hr, gr, vr, mr, br, yr = (
    /*settings*/
    lr[0].size + ""
  ), kr, Tr;
  return {
    c() {
      ar = element("button"), ur = text$3(cr), fr = text$3("-"), hr = text$3(dr), gr = text$3(" "), vr = element("span"), mr = text$3(
        /*separatorText*/
        lr[11]
      ), br = space(), kr = text$3(yr), attr(vr, "class", "opacity-50"), attr(ar, "type", "button"), attr(ar, "class", Tr = /*buttonClasses*/
      lr[6] + " pointer-events-none !text-sm");
    },
    m(_r, Er) {
      insert(_r, ar, Er), append(ar, ur), append(ar, fr), append(ar, hr), append(ar, gr), append(ar, vr), append(vr, mr), append(vr, br), append(vr, kr);
    },
    p(_r, Er) {
      Er[0] & /*settings*/
      1 && cr !== (cr = /*settings*/
      _r[0].page * /*settings*/
      _r[0].limit + 1 + "") && set_data(ur, cr), Er[0] & /*settings*/
      1 && dr !== (dr = Math.min(
        /*settings*/
        _r[0].page * /*settings*/
        _r[0].limit + /*settings*/
        _r[0].limit,
        /*settings*/
        _r[0].size
      ) + "") && set_data(hr, dr), Er[0] & /*separatorText*/
      2048 && set_data(
        mr,
        /*separatorText*/
        _r[11]
      ), Er[0] & /*settings*/
      1 && yr !== (yr = /*settings*/
      _r[0].size + "") && set_data(kr, yr), Er[0] & /*buttonClasses*/
      64 && Tr !== (Tr = /*buttonClasses*/
      _r[6] + " pointer-events-none !text-sm") && attr(ar, "class", Tr);
    },
    d(_r) {
      _r && detach(ar);
    }
  };
}
function create_each_block$9(lr) {
  let ar, cr = (
    /*page*/
    (lr[43] >= 0 ? (
      /*page*/
      lr[43] + 1
    ) : "...") + ""
  ), ur, fr, dr, hr, gr;
  function vr() {
    return (
      /*click_handler_2*/
      lr[35](
        /*page*/
        lr[43]
      )
    );
  }
  return {
    c() {
      ar = element("button"), ur = text$3(cr), fr = space(), attr(ar, "type", "button"), attr(ar, "class", dr = /*buttonClasses*/
      lr[6] + " " + /*classesButtonActive*/
      lr[22](
        /*page*/
        lr[43]
      ));
    },
    m(mr, br) {
      insert(mr, ar, br), append(ar, ur), append(ar, fr), hr || (gr = listen(ar, "click", vr), hr = !0);
    },
    p(mr, br) {
      lr = mr, br[0] & /*controlPages*/
      131072 && cr !== (cr = /*page*/
      (lr[43] >= 0 ? (
        /*page*/
        lr[43] + 1
      ) : "...") + "") && set_data(ur, cr), br[0] & /*buttonClasses, classesButtonActive, controlPages*/
      4325440 && dr !== (dr = /*buttonClasses*/
      lr[6] + " " + /*classesButtonActive*/
      lr[22](
        /*page*/
        lr[43]
      )) && attr(ar, "class", dr);
    },
    d(mr) {
      mr && detach(ar), hr = !1, gr();
    }
  };
}
function create_if_block_1$b(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelNext*/
        lr[14]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      (lr[0].page + 1) * /*settings*/
      lr[0].limit >= /*settings*/
      lr[0].size;
    },
    m(dr, hr) {
      insert(dr, ar, hr), ar.innerHTML = /*buttonTextNext*/
      lr[8], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_3*/
        lr[36]
      ), ur = !0);
    },
    p(dr, hr) {
      hr[0] & /*buttonTextNext*/
      256 && (ar.innerHTML = /*buttonTextNext*/
      dr[8]), hr[0] & /*labelNext*/
      16384 && attr(
        ar,
        "aria-label",
        /*labelNext*/
        dr[14]
      ), hr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), hr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      (dr[0].page + 1) * /*settings*/
      dr[0].limit >= /*settings*/
      dr[0].size) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block$n(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelLast*/
        lr[15]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      (lr[0].page + 1) * /*settings*/
      lr[0].limit >= /*settings*/
      lr[0].size;
    },
    m(dr, hr) {
      insert(dr, ar, hr), ar.innerHTML = /*buttonTextLast*/
      lr[10], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_4*/
        lr[37]
      ), ur = !0);
    },
    p(dr, hr) {
      hr[0] & /*buttonTextLast*/
      1024 && (ar.innerHTML = /*buttonTextLast*/
      dr[10]), hr[0] & /*labelLast*/
      32768 && attr(
        ar,
        "aria-label",
        /*labelLast*/
        dr[15]
      ), hr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), hr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      (dr[0].page + 1) * /*settings*/
      dr[0].limit >= /*settings*/
      dr[0].size) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_fragment$U(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br = (
    /*settings*/
    lr[0].amounts.length && create_if_block_5$3(lr)
  ), yr = (
    /*showFirstLastButtons*/
    lr[3] && create_if_block_4$5(lr)
  ), kr = (
    /*showPreviousNextButtons*/
    lr[2] && create_if_block_3$7(lr)
  );
  function Tr(Ar, Lr) {
    return (
      /*showNumerals*/
      Ar[4] === !1 ? create_if_block_2$9 : create_else_block$a
    );
  }
  let _r = Tr(lr), Er = _r(lr), xr = (
    /*showPreviousNextButtons*/
    lr[2] && create_if_block_1$b(lr)
  ), Cr = (
    /*showFirstLastButtons*/
    lr[3] && create_if_block$n(lr)
  );
  return {
    c() {
      ar = element("div"), br && br.c(), cr = space(), ur = element("div"), yr && yr.c(), fr = space(), kr && kr.c(), dr = space(), Er.c(), hr = space(), xr && xr.c(), gr = space(), Cr && Cr.c(), attr(ur, "class", vr = "paginator-controls " + /*classesControls*/
      lr[18]), attr(ar, "class", mr = "paginator " + /*classesBase*/
      lr[21]), attr(ar, "data-testid", "paginator");
    },
    m(Ar, Lr) {
      insert(Ar, ar, Lr), br && br.m(ar, null), append(ar, cr), append(ar, ur), yr && yr.m(ur, null), append(ur, fr), kr && kr.m(ur, null), append(ur, dr), Er.m(ur, null), append(ur, hr), xr && xr.m(ur, null), append(ur, gr), Cr && Cr.m(ur, null);
    },
    p(Ar, Lr) {
      /*settings*/
      Ar[0].amounts.length ? br ? br.p(Ar, Lr) : (br = create_if_block_5$3(Ar), br.c(), br.m(ar, cr)) : br && (br.d(1), br = null), /*showFirstLastButtons*/
      Ar[3] ? yr ? yr.p(Ar, Lr) : (yr = create_if_block_4$5(Ar), yr.c(), yr.m(ur, fr)) : yr && (yr.d(1), yr = null), /*showPreviousNextButtons*/
      Ar[2] ? kr ? kr.p(Ar, Lr) : (kr = create_if_block_3$7(Ar), kr.c(), kr.m(ur, dr)) : kr && (kr.d(1), kr = null), _r === (_r = Tr(Ar)) && Er ? Er.p(Ar, Lr) : (Er.d(1), Er = _r(Ar), Er && (Er.c(), Er.m(ur, hr))), /*showPreviousNextButtons*/
      Ar[2] ? xr ? xr.p(Ar, Lr) : (xr = create_if_block_1$b(Ar), xr.c(), xr.m(ur, gr)) : xr && (xr.d(1), xr = null), /*showFirstLastButtons*/
      Ar[3] ? Cr ? Cr.p(Ar, Lr) : (Cr = create_if_block$n(Ar), Cr.c(), Cr.m(ur, null)) : Cr && (Cr.d(1), Cr = null), Lr[0] & /*classesControls*/
      262144 && vr !== (vr = "paginator-controls " + /*classesControls*/
      Ar[18]) && attr(ur, "class", vr), Lr[0] & /*classesBase*/
      2097152 && mr !== (mr = "paginator " + /*classesBase*/
      Ar[21]) && attr(ar, "class", mr);
    },
    i: noop$1,
    o: noop$1,
    d(Ar) {
      Ar && detach(ar), br && br.d(), yr && yr.d(), kr && kr.d(), Er.d(), xr && xr.d(), Cr && Cr.d();
    }
  };
}
const cBase$e = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4", cLabel$1 = "w-full md:w-auto";
function instance$z(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  const vr = createEventDispatcher();
  let { settings: mr = {
    page: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = ar, { disabled: br = !1 } = ar, { showPreviousNextButtons: yr = !0 } = ar, { showFirstLastButtons: kr = !1 } = ar, { showNumerals: Tr = !1 } = ar, { maxNumerals: _r = 1 } = ar, { justify: Er = "justify-between" } = ar, { select: xr = "select min-w-[150px]" } = ar, { amountText: Cr = "Items" } = ar, { regionControl: Ar = "btn-group" } = ar, { controlVariant: Lr = "variant-filled" } = ar, { controlSeparator: Dr = "" } = ar, { active: Nr = "variant-filled-primary" } = ar, { buttonClasses: Hr = "!px-3 !py-1.5 fill-current" } = ar, { buttonTextPrevious: $r = leftArrow } = ar, { buttonTextNext: Wr = rightArrow } = ar, { buttonTextFirst: Zr = leftAngles } = ar, { buttonTextLast: oi = rightAngles } = ar, { separatorText: Jr = "of" } = ar, { labelFirst: Yr = "First page" } = ar, { labelPrevious: li = "Previous page" } = ar, { labelNext: Si = "Next page" } = ar, { labelLast: ci = "Last page" } = ar, hi = Math.max(0, Math.ceil(mr.size / mr.limit - 1)), Ei = ui();
  function di() {
    vr("amount", mr.limit), cr(16, hi = Math.max(0, Math.ceil(mr.size / mr.limit - 1))), mr.page > hi && cr(0, mr.page = hi, mr), cr(17, Ei = ui());
  }
  function gi(mi) {
    mi < 0 || (cr(0, mr.page = mi, mr), vr("page", mr.page), cr(17, Ei = ui()));
  }
  function Li() {
    const mi = [];
    for (let _i = 0; _i <= hi; _i++)
      mi.push(_i);
    return mi;
  }
  function ui() {
    const mi = [], _i = mr.page < _r + 2, Ci = mr.page > hi - (_r + 2);
    if (hi <= _r * 2 + 1)
      return Li();
    if (mi.push(0), _i || mi.push(-1), _i || Ci) {
      const Ki = _i ? 1 : hi - (_r + 2), Ni = Ci ? hi - 1 : _r + 2;
      for (let ia = Ki; ia <= Ni; ia++)
        mi.push(ia);
    } else
      for (let Ki = mr.page - _r; Ki <= mr.page + _r; Ki++)
        mi.push(Ki);
    return Ci || mi.push(-1), mi.push(hi), mi;
  }
  function wi(mi) {
    cr(16, hi = Math.max(0, Math.ceil(mi / mr.limit - 1))), cr(17, Ei = ui());
  }
  function Ui() {
    mr.limit = select_value(this), cr(0, mr);
  }
  const yi = () => {
    gi(0);
  }, Vi = () => {
    gi(mr.page - 1);
  }, Oi = (mi) => gi(mi), Mi = () => {
    gi(mr.page + 1);
  }, Ii = () => {
    gi(hi);
  };
  return lr.$$set = (mi) => {
    cr(42, ar = assign$1(assign$1({}, ar), exclude_internal_props(mi))), "settings" in mi && cr(0, mr = mi.settings), "disabled" in mi && cr(1, br = mi.disabled), "showPreviousNextButtons" in mi && cr(2, yr = mi.showPreviousNextButtons), "showFirstLastButtons" in mi && cr(3, kr = mi.showFirstLastButtons), "showNumerals" in mi && cr(4, Tr = mi.showNumerals), "maxNumerals" in mi && cr(25, _r = mi.maxNumerals), "justify" in mi && cr(26, Er = mi.justify), "select" in mi && cr(27, xr = mi.select), "amountText" in mi && cr(5, Cr = mi.amountText), "regionControl" in mi && cr(28, Ar = mi.regionControl), "controlVariant" in mi && cr(29, Lr = mi.controlVariant), "controlSeparator" in mi && cr(30, Dr = mi.controlSeparator), "active" in mi && cr(31, Nr = mi.active), "buttonClasses" in mi && cr(6, Hr = mi.buttonClasses), "buttonTextPrevious" in mi && cr(7, $r = mi.buttonTextPrevious), "buttonTextNext" in mi && cr(8, Wr = mi.buttonTextNext), "buttonTextFirst" in mi && cr(9, Zr = mi.buttonTextFirst), "buttonTextLast" in mi && cr(10, oi = mi.buttonTextLast), "separatorText" in mi && cr(11, Jr = mi.separatorText), "labelFirst" in mi && cr(12, Yr = mi.labelFirst), "labelPrevious" in mi && cr(13, li = mi.labelPrevious), "labelNext" in mi && cr(14, Si = mi.labelNext), "labelLast" in mi && cr(15, ci = mi.labelLast);
  }, lr.$$.update = () => {
    var mi;
    lr.$$.dirty[0] & /*settings*/
    1 | lr.$$.dirty[1] & /*active*/
    1 && cr(22, ur = (_i) => _i === mr.page ? `${Nr} pointer-events-none` : ""), lr.$$.dirty[0] & /*maxNumerals*/
    33554432 && di(), lr.$$.dirty[0] & /*settings*/
    1 && wi(mr.size), cr(21, fr = `${cBase$e} ${Er} ${(mi = ar.class) != null ? mi : ""}`), lr.$$.dirty[0] & /*select*/
    134217728 && cr(19, hr = `${xr}`), lr.$$.dirty[0] & /*regionControl, controlVariant, controlSeparator*/
    1879048192 && cr(18, gr = `${Ar} ${Lr} ${Dr}`);
  }, cr(20, dr = `${cLabel$1}`), ar = exclude_internal_props(ar), [
    mr,
    br,
    yr,
    kr,
    Tr,
    Cr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    gr,
    hr,
    dr,
    fr,
    ur,
    di,
    gi,
    _r,
    Er,
    xr,
    Ar,
    Lr,
    Dr,
    Nr,
    Ui,
    yi,
    Vi,
    Oi,
    Mi,
    Ii
  ];
}
class Paginator extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$z,
      create_fragment$U,
      safe_not_equal,
      {
        settings: 0,
        disabled: 1,
        showPreviousNextButtons: 2,
        showFirstLastButtons: 3,
        showNumerals: 4,
        maxNumerals: 25,
        justify: 26,
        select: 27,
        amountText: 5,
        regionControl: 28,
        controlVariant: 29,
        controlSeparator: 30,
        active: 31,
        buttonClasses: 6,
        buttonTextPrevious: 7,
        buttonTextNext: 8,
        buttonTextFirst: 9,
        buttonTextLast: 10,
        separatorText: 11,
        labelFirst: 12,
        labelPrevious: 13,
        labelNext: 14,
        labelLast: 15
      },
      null,
      [-1, -1]
    );
  }
  get settings() {
    return this.$$.ctx[0];
  }
  set settings(ar) {
    this.$$set({ settings: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get showPreviousNextButtons() {
    return this.$$.ctx[2];
  }
  set showPreviousNextButtons(ar) {
    this.$$set({ showPreviousNextButtons: ar }), flush();
  }
  get showFirstLastButtons() {
    return this.$$.ctx[3];
  }
  set showFirstLastButtons(ar) {
    this.$$set({ showFirstLastButtons: ar }), flush();
  }
  get showNumerals() {
    return this.$$.ctx[4];
  }
  set showNumerals(ar) {
    this.$$set({ showNumerals: ar }), flush();
  }
  get maxNumerals() {
    return this.$$.ctx[25];
  }
  set maxNumerals(ar) {
    this.$$set({ maxNumerals: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[26];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get select() {
    return this.$$.ctx[27];
  }
  set select(ar) {
    this.$$set({ select: ar }), flush();
  }
  get amountText() {
    return this.$$.ctx[5];
  }
  set amountText(ar) {
    this.$$set({ amountText: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[28];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get controlVariant() {
    return this.$$.ctx[29];
  }
  set controlVariant(ar) {
    this.$$set({ controlVariant: ar }), flush();
  }
  get controlSeparator() {
    return this.$$.ctx[30];
  }
  set controlSeparator(ar) {
    this.$$set({ controlSeparator: ar }), flush();
  }
  get active() {
    return this.$$.ctx[31];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get buttonClasses() {
    return this.$$.ctx[6];
  }
  set buttonClasses(ar) {
    this.$$set({ buttonClasses: ar }), flush();
  }
  get buttonTextPrevious() {
    return this.$$.ctx[7];
  }
  set buttonTextPrevious(ar) {
    this.$$set({ buttonTextPrevious: ar }), flush();
  }
  get buttonTextNext() {
    return this.$$.ctx[8];
  }
  set buttonTextNext(ar) {
    this.$$set({ buttonTextNext: ar }), flush();
  }
  get buttonTextFirst() {
    return this.$$.ctx[9];
  }
  set buttonTextFirst(ar) {
    this.$$set({ buttonTextFirst: ar }), flush();
  }
  get buttonTextLast() {
    return this.$$.ctx[10];
  }
  set buttonTextLast(ar) {
    this.$$set({ buttonTextLast: ar }), flush();
  }
  get separatorText() {
    return this.$$.ctx[11];
  }
  set separatorText(ar) {
    this.$$set({ separatorText: ar }), flush();
  }
  get labelFirst() {
    return this.$$.ctx[12];
  }
  set labelFirst(ar) {
    this.$$set({ labelFirst: ar }), flush();
  }
  get labelPrevious() {
    return this.$$.ctx[13];
  }
  set labelPrevious(ar) {
    this.$$set({ labelPrevious: ar }), flush();
  }
  get labelNext() {
    return this.$$.ctx[14];
  }
  set labelNext(ar) {
    this.$$set({ labelNext: ar }), flush();
  }
  get labelLast() {
    return this.$$.ctx[15];
  }
  set labelLast(ar) {
    this.$$set({ labelLast: ar }), flush();
  }
}
create_custom_element(Paginator, { settings: {}, disabled: { type: "Boolean" }, showPreviousNextButtons: { type: "Boolean" }, showFirstLastButtons: { type: "Boolean" }, showNumerals: { type: "Boolean" }, maxNumerals: {}, justify: {}, select: {}, amountText: {}, regionControl: {}, controlVariant: {}, controlSeparator: {}, active: {}, buttonClasses: {}, buttonTextPrevious: {}, buttonTextNext: {}, buttonTextFirst: {}, buttonTextLast: {}, separatorText: {}, labelFirst: {}, labelPrevious: {}, labelNext: {}, labelLast: {} }, [], [], !0);
function add_css$b(lr) {
  append_styles(lr, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}");
}
function create_fragment$T(lr) {
  let ar, cr, ur, fr = `${/*indeterminate*/
  lr[4] ? 100 : (
    /*fillPercent*/
    lr[7]
  )}%`, dr, hr;
  return {
    c() {
      ar = element("div"), cr = element("div"), attr(cr, "class", ur = "progress-bar-meter " + /*classesMeter*/
      lr[5] + " " + /*classesMeter*/
      lr[5] + " svelte-meqa4r"), set_style(cr, "width", fr), attr(ar, "class", dr = "progress-bar " + /*classesTrack*/
      lr[6] + " svelte-meqa4r"), attr(ar, "data-testid", "progress-bar"), attr(ar, "role", "progressbar"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[3]
      ), attr(
        ar,
        "aria-valuenow",
        /*value*/
        lr[0]
      ), attr(
        ar,
        "aria-valuemin",
        /*min*/
        lr[1]
      ), attr(ar, "aria-valuemax", hr = /*max*/
      lr[2] - /*min*/
      lr[1]);
    },
    m(gr, vr) {
      insert(gr, ar, vr), append(ar, cr);
    },
    p(gr, [vr]) {
      vr & /*classesMeter*/
      32 && ur !== (ur = "progress-bar-meter " + /*classesMeter*/
      gr[5] + " " + /*classesMeter*/
      gr[5] + " svelte-meqa4r") && attr(cr, "class", ur), vr & /*indeterminate, fillPercent*/
      144 && fr !== (fr = `${/*indeterminate*/
      gr[4] ? 100 : (
        /*fillPercent*/
        gr[7]
      )}%`) && set_style(cr, "width", fr), vr & /*classesTrack*/
      64 && dr !== (dr = "progress-bar " + /*classesTrack*/
      gr[6] + " svelte-meqa4r") && attr(ar, "class", dr), vr & /*labelledby*/
      8 && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        gr[3]
      ), vr & /*value*/
      1 && attr(
        ar,
        "aria-valuenow",
        /*value*/
        gr[0]
      ), vr & /*min*/
      2 && attr(
        ar,
        "aria-valuemin",
        /*min*/
        gr[1]
      ), vr & /*max, min*/
      6 && hr !== (hr = /*max*/
      gr[2] - /*min*/
      gr[1]) && attr(ar, "aria-valuemax", hr);
    },
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar);
    }
  };
}
const cTrack$2 = "w-full overflow-hidden", cMeter = "h-full";
function instance$y(lr, ar, cr) {
  let ur, fr, dr, hr, gr, { value: vr = void 0 } = ar, { min: mr = 0 } = ar, { max: br = 100 } = ar, { height: yr = "h-2" } = ar, { rounded: kr = "rounded-token" } = ar, { transition: Tr = "transition-[width]" } = ar, { meter: _r = "bg-surface-900-50-token" } = ar, { track: Er = "bg-surface-200-700-token" } = ar, { labelledby: xr = "" } = ar;
  return lr.$$set = (Cr) => {
    cr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Cr))), "value" in Cr && cr(0, vr = Cr.value), "min" in Cr && cr(1, mr = Cr.min), "max" in Cr && cr(2, br = Cr.max), "height" in Cr && cr(8, yr = Cr.height), "rounded" in Cr && cr(9, kr = Cr.rounded), "transition" in Cr && cr(10, Tr = Cr.transition), "meter" in Cr && cr(11, _r = Cr.meter), "track" in Cr && cr(12, Er = Cr.track), "labelledby" in Cr && cr(3, xr = Cr.labelledby);
  }, lr.$$.update = () => {
    var Cr;
    lr.$$.dirty & /*value, min, max*/
    7 && cr(7, ur = vr ? 100 * (vr - mr) / (br - mr) : 0), lr.$$.dirty & /*value*/
    1 && cr(4, fr = vr === void 0 || vr < 0), lr.$$.dirty & /*indeterminate*/
    16 && cr(13, dr = fr ? "animIndeterminate" : ""), cr(6, hr = `${cTrack$2} ${Er} ${yr} ${kr} ${(Cr = ar.class) != null ? Cr : ""}`), lr.$$.dirty & /*meter, rounded, classesIndeterminate, transition*/
    11776 && cr(5, gr = `${cMeter} ${_r} ${kr} ${dr} ${Tr}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    mr,
    br,
    xr,
    fr,
    gr,
    hr,
    ur,
    yr,
    kr,
    Tr,
    _r,
    Er,
    dr
  ];
}
class ProgressBar extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$y,
      create_fragment$T,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        height: 8,
        rounded: 9,
        transition: 10,
        meter: 11,
        track: 12,
        labelledby: 3
      },
      add_css$b
    );
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[1];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[2];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get height() {
    return this.$$.ctx[8];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[9];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[10];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[11];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[12];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[3];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressBar, { value: {}, min: {}, max: {}, height: {}, rounded: {}, transition: {}, meter: {}, track: {}, labelledby: {} }, [], [], !0);
function create_if_block$m(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[16].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[15],
    null
  );
  return {
    c() {
      ar = svg_element("text"), dr && dr.c(), attr(ar, "x", "50%"), attr(ar, "y", "50%"), attr(ar, "text-anchor", "middle"), attr(ar, "dominant-baseline", "middle"), attr(ar, "font-weight", "bold"), attr(
        ar,
        "font-size",
        /*font*/
        lr[2]
      ), attr(ar, "class", cr = "progress-radial-text " + /*fill*/
      lr[7]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      32768) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[15],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[15],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[15]
        ),
        null
      ), (!ur || gr & /*font*/
      4) && attr(
        ar,
        "font-size",
        /*font*/
        hr[2]
      ), (!ur || gr & /*fill*/
      128 && cr !== (cr = "progress-radial-text " + /*fill*/
      hr[7])) && attr(ar, "class", cr);
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$S(lr) {
  let ar, cr, ur, fr, dr, hr, gr = `${/*circumference*/
  lr[9]}
			${/*circumference*/
  lr[9]}`, vr, mr, br, yr, kr = (
    /*value*/
    lr[0] != null && /*value*/
    lr[0] >= 0 && /*$$slots*/
    lr[13].default && create_if_block$m(lr)
  );
  return {
    c() {
      ar = element("figure"), cr = svg_element("svg"), ur = svg_element("circle"), dr = svg_element("circle"), kr && kr.c(), attr(ur, "class", fr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      lr[6]), attr(
        ur,
        "stroke-width",
        /*stroke*/
        lr[1]
      ), attr(
        ur,
        "r",
        /*radius*/
        lr[12]
      ), attr(ur, "cx", "50%"), attr(ur, "cy", "50%"), attr(dr, "class", hr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      lr[5] + " " + /*transition*/
      lr[4]), attr(
        dr,
        "stroke-width",
        /*stroke*/
        lr[1]
      ), attr(
        dr,
        "r",
        /*radius*/
        lr[12]
      ), attr(dr, "cx", "50%"), attr(dr, "cy", "50%"), attr(
        dr,
        "stroke-linecap",
        /*strokeLinecap*/
        lr[3]
      ), set_style(dr, "stroke-dasharray", gr), set_style(
        dr,
        "stroke-dashoffset",
        /*dashoffset*/
        lr[10]
      ), attr(cr, "viewBox", "0 0 " + baseSize + " " + baseSize), attr(cr, "class", "rounded-full"), toggle_class(
        cr,
        "animate-spin",
        /*value*/
        lr[0] === void 0
      ), attr(ar, "class", vr = "progress-radial " + /*classesBase*/
      lr[11]), attr(ar, "data-testid", "progress-radial"), attr(ar, "role", "meter"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[8]
      ), attr(ar, "aria-valuenow", mr = /*value*/
      lr[0] || 0), attr(ar, "aria-valuetext", br = /*value*/
      lr[0] ? `${/*value*/
      lr[0]}%` : "Indeterminate Spinner"), attr(ar, "aria-valuemin", 0), attr(ar, "aria-valuemax", 100);
    },
    m(Tr, _r) {
      insert(Tr, ar, _r), append(ar, cr), append(cr, ur), append(cr, dr), kr && kr.m(cr, null), yr = !0;
    },
    p(Tr, [_r]) {
      (!yr || _r & /*track*/
      64 && fr !== (fr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      Tr[6])) && attr(ur, "class", fr), (!yr || _r & /*stroke*/
      2) && attr(
        ur,
        "stroke-width",
        /*stroke*/
        Tr[1]
      ), (!yr || _r & /*meter, transition*/
      48 && hr !== (hr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      Tr[5] + " " + /*transition*/
      Tr[4])) && attr(dr, "class", hr), (!yr || _r & /*stroke*/
      2) && attr(
        dr,
        "stroke-width",
        /*stroke*/
        Tr[1]
      ), (!yr || _r & /*strokeLinecap*/
      8) && attr(
        dr,
        "stroke-linecap",
        /*strokeLinecap*/
        Tr[3]
      ), _r & /*circumference*/
      512 && gr !== (gr = `${/*circumference*/
      Tr[9]}
			${/*circumference*/
      Tr[9]}`) && set_style(dr, "stroke-dasharray", gr), _r & /*dashoffset*/
      1024 && set_style(
        dr,
        "stroke-dashoffset",
        /*dashoffset*/
        Tr[10]
      ), /*value*/
      Tr[0] != null && /*value*/
      Tr[0] >= 0 && /*$$slots*/
      Tr[13].default ? kr ? (kr.p(Tr, _r), _r & /*value, $$slots*/
      8193 && transition_in(kr, 1)) : (kr = create_if_block$m(Tr), kr.c(), transition_in(kr, 1), kr.m(cr, null)) : kr && (group_outros(), transition_out(kr, 1, 1, () => {
        kr = null;
      }), check_outros()), (!yr || _r & /*value, undefined*/
      1) && toggle_class(
        cr,
        "animate-spin",
        /*value*/
        Tr[0] === void 0
      ), (!yr || _r & /*classesBase*/
      2048 && vr !== (vr = "progress-radial " + /*classesBase*/
      Tr[11])) && attr(ar, "class", vr), (!yr || _r & /*labelledby*/
      256) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        Tr[8]
      ), (!yr || _r & /*value*/
      1 && mr !== (mr = /*value*/
      Tr[0] || 0)) && attr(ar, "aria-valuenow", mr), (!yr || _r & /*value*/
      1 && br !== (br = /*value*/
      Tr[0] ? `${/*value*/
      Tr[0]}%` : "Indeterminate Spinner")) && attr(ar, "aria-valuetext", br);
    },
    i(Tr) {
      yr || (transition_in(kr), yr = !0);
    },
    o(Tr) {
      transition_out(kr), yr = !1;
    },
    d(Tr) {
      Tr && detach(ar), kr && kr.d();
    }
  };
}
const cBase$d = "progress-radial relative overflow-hidden", cBaseTrack = "fill-transparent", cBaseMeter = "fill-transparent -rotate-90 origin-[50%_50%]", baseSize = 512;
function instance$x(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar;
  const hr = compute_slots(fr);
  let { value: gr = void 0 } = ar, { stroke: vr = 40 } = ar, { font: mr = 56 } = ar, { strokeLinecap: br = "butt" } = ar, { transition: yr = "transition-[stroke-dashoffset]" } = ar, { width: kr = "w-36" } = ar, { meter: Tr = "stroke-surface-900 dark:stroke-surface-50" } = ar, { track: _r = "stroke-surface-500/30" } = ar, { fill: Er = "fill-token" } = ar, { labelledby: xr = "" } = ar;
  const Cr = baseSize / 2 - vr / 2;
  let Ar = Cr, Lr;
  function Dr(Nr) {
    cr(9, Ar = Cr * 2 * Math.PI), cr(10, Lr = Ar - Nr / 100 * Ar);
  }
  return Dr(0), afterUpdate(() => {
    Dr(gr === void 0 ? 25 : gr);
  }), lr.$$set = (Nr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Nr))), "value" in Nr && cr(0, gr = Nr.value), "stroke" in Nr && cr(1, vr = Nr.stroke), "font" in Nr && cr(2, mr = Nr.font), "strokeLinecap" in Nr && cr(3, br = Nr.strokeLinecap), "transition" in Nr && cr(4, yr = Nr.transition), "width" in Nr && cr(14, kr = Nr.width), "meter" in Nr && cr(5, Tr = Nr.meter), "track" in Nr && cr(6, _r = Nr.track), "fill" in Nr && cr(7, Er = Nr.fill), "labelledby" in Nr && cr(8, xr = Nr.labelledby), "$$scope" in Nr && cr(15, dr = Nr.$$scope);
  }, lr.$$.update = () => {
    var Nr;
    cr(11, ur = `${cBase$d} ${kr} ${(Nr = ar.class) != null ? Nr : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    vr,
    mr,
    br,
    yr,
    Tr,
    _r,
    Er,
    xr,
    Ar,
    Lr,
    ur,
    Cr,
    hr,
    kr,
    dr,
    fr
  ];
}
class ProgressRadial extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$x, create_fragment$S, safe_not_equal, {
      value: 0,
      stroke: 1,
      font: 2,
      strokeLinecap: 3,
      transition: 4,
      width: 14,
      meter: 5,
      track: 6,
      fill: 7,
      labelledby: 8
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get stroke() {
    return this.$$.ctx[1];
  }
  set stroke(ar) {
    this.$$set({ stroke: ar }), flush();
  }
  get font() {
    return this.$$.ctx[2];
  }
  set font(ar) {
    this.$$set({ font: ar }), flush();
  }
  get strokeLinecap() {
    return this.$$.ctx[3];
  }
  set strokeLinecap(ar) {
    this.$$set({ strokeLinecap: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[4];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get width() {
    return this.$$.ctx[14];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[5];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[6];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[8];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressRadial, { value: {}, stroke: {}, font: {}, strokeLinecap: {}, transition: {}, width: {}, meter: {}, track: {}, fill: {}, labelledby: {} }, ["default"], [], !0);
function get_each_context$8(lr, ar, cr) {
  const ur = lr.slice();
  return ur[15] = ar[cr], ur[17] = cr, ur;
}
const get_empty_slot_changes_1 = (lr) => ({}), get_empty_slot_context_1 = (lr) => ({}), get_half_slot_changes_1 = (lr) => ({}), get_half_slot_context_1 = (lr) => ({}), get_full_slot_changes_1 = (lr) => ({}), get_full_slot_context_1 = (lr) => ({}), get_empty_slot_changes = (lr) => ({}), get_empty_slot_context = (lr) => ({}), get_half_slot_changes = (lr) => ({}), get_half_slot_context = (lr) => ({}), get_full_slot_changes = (lr) => ({}), get_full_slot_context = (lr) => ({});
function create_else_block_1$6(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  const mr = [create_if_block_3$6, create_if_block_4$4, create_else_block_2$1], br = [];
  function yr(kr, Tr) {
    return Tr & /*value*/
    1 && (cr = null), Tr & /*value*/
    1 && (ur = null), cr == null && (cr = !!isFull(
      /*value*/
      kr[0],
      /*i*/
      kr[17]
    )), cr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      kr[0],
      /*i*/
      kr[17]
    )), ur ? 1 : 2);
  }
  return fr = yr(lr, -1), dr = br[fr] = mr[fr](lr), {
    c() {
      ar = element("span"), dr.c(), hr = space(), attr(ar, "class", gr = "rating-icon " + /*regionIcon*/
      lr[3]);
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), br[fr].m(ar, null), append(ar, hr), vr = !0;
    },
    p(kr, Tr) {
      let _r = fr;
      fr = yr(kr, Tr), fr === _r ? br[fr].p(kr, Tr) : (group_outros(), transition_out(br[_r], 1, 1, () => {
        br[_r] = null;
      }), check_outros(), dr = br[fr], dr ? dr.p(kr, Tr) : (dr = br[fr] = mr[fr](kr), dr.c()), transition_in(dr, 1), dr.m(ar, hr)), (!vr || Tr & /*regionIcon*/
      8 && gr !== (gr = "rating-icon " + /*regionIcon*/
      kr[3])) && attr(ar, "class", gr);
    },
    i(kr) {
      vr || (transition_in(dr), vr = !0);
    },
    o(kr) {
      transition_out(dr), vr = !1;
    },
    d(kr) {
      kr && detach(ar), br[fr].d();
    }
  };
}
function create_if_block$l(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br;
  const yr = [create_if_block_1$a, create_if_block_2$8, create_else_block$9], kr = [];
  function Tr(Er, xr) {
    return xr & /*value*/
    1 && (cr = null), xr & /*value*/
    1 && (ur = null), cr == null && (cr = !!isFull(
      /*value*/
      Er[0],
      /*i*/
      Er[17]
    )), cr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      Er[0],
      /*i*/
      Er[17]
    )), ur ? 1 : 2);
  }
  fr = Tr(lr, -1), dr = kr[fr] = yr[fr](lr);
  function _r() {
    return (
      /*click_handler*/
      lr[12](
        /*i*/
        lr[17]
      )
    );
  }
  return {
    c() {
      ar = element("button"), dr.c(), hr = space(), attr(ar, "class", gr = "rating-icon " + /*regionIcon*/
      lr[3]), attr(ar, "type", "button");
    },
    m(Er, xr) {
      insert(Er, ar, xr), kr[fr].m(ar, null), append(ar, hr), vr = !0, mr || (br = listen(ar, "click", _r), mr = !0);
    },
    p(Er, xr) {
      lr = Er;
      let Cr = fr;
      fr = Tr(lr, xr), fr === Cr ? kr[fr].p(lr, xr) : (group_outros(), transition_out(kr[Cr], 1, 1, () => {
        kr[Cr] = null;
      }), check_outros(), dr = kr[fr], dr ? dr.p(lr, xr) : (dr = kr[fr] = yr[fr](lr), dr.c()), transition_in(dr, 1), dr.m(ar, hr)), (!vr || xr & /*regionIcon*/
      8 && gr !== (gr = "rating-icon " + /*regionIcon*/
      lr[3])) && attr(ar, "class", gr);
    },
    i(Er) {
      vr || (transition_in(dr), vr = !0);
    },
    o(Er) {
      transition_out(dr), vr = !1;
    },
    d(Er) {
      Er && detach(ar), kr[fr].d(), mr = !1, br();
    }
  };
}
function create_else_block_2$1(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].empty
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_empty_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_empty_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_empty_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_4$4(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].half
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_half_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_half_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_half_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_3$6(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].full
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_full_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_full_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_full_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_else_block$9(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].empty
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_empty_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_empty_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_empty_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_2$8(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].half
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_half_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_half_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_half_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_1$a(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].full
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_full_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_full_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_full_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_each_block$8(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block$l, create_else_block_1$6], hr = [];
  function gr(vr, mr) {
    return (
      /*interactive*/
      vr[2] ? 0 : 1
    );
  }
  return ar = gr(lr), cr = hr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = empty$1();
    },
    m(vr, mr) {
      hr[ar].m(vr, mr), insert(vr, ur, mr), fr = !0;
    },
    p(vr, mr) {
      let br = ar;
      ar = gr(vr), ar === br ? hr[ar].p(vr, mr) : (group_outros(), transition_out(hr[br], 1, 1, () => {
        hr[br] = null;
      }), check_outros(), cr = hr[ar], cr ? cr.p(vr, mr) : (cr = hr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), hr[ar].d(vr);
    }
  };
}
function create_fragment$R(lr) {
  let ar, cr, ur, fr = ensure_array_like({ length: (
    /*max*/
    lr[1]
  ) }), dr = [];
  for (let gr = 0; gr < fr.length; gr += 1)
    dr[gr] = create_each_block$8(get_each_context$8(lr, fr, gr));
  const hr = (gr) => transition_out(dr[gr], 1, 1, () => {
    dr[gr] = null;
  });
  return {
    c() {
      ar = element("div");
      for (let gr = 0; gr < dr.length; gr += 1)
        dr[gr].c();
      attr(ar, "class", cr = "ratings " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "rating-bar");
    },
    m(gr, vr) {
      insert(gr, ar, vr);
      for (let mr = 0; mr < dr.length; mr += 1)
        dr[mr] && dr[mr].m(ar, null);
      ur = !0;
    },
    p(gr, [vr]) {
      if (vr & /*regionIcon, iconClick, $$scope, isFull, value, isHalf, interactive, max*/
      1071) {
        fr = ensure_array_like({ length: (
          /*max*/
          gr[1]
        ) });
        let mr;
        for (mr = 0; mr < fr.length; mr += 1) {
          const br = get_each_context$8(gr, fr, mr);
          dr[mr] ? (dr[mr].p(br, vr), transition_in(dr[mr], 1)) : (dr[mr] = create_each_block$8(br), dr[mr].c(), transition_in(dr[mr], 1), dr[mr].m(ar, null));
        }
        for (group_outros(), mr = fr.length; mr < dr.length; mr += 1)
          hr(mr);
        check_outros();
      }
      (!ur || vr & /*classesBase*/
      16 && cr !== (cr = "ratings " + /*classesBase*/
      gr[4])) && attr(ar, "class", cr);
    },
    i(gr) {
      if (!ur) {
        for (let vr = 0; vr < fr.length; vr += 1)
          transition_in(dr[vr]);
        ur = !0;
      }
    },
    o(gr) {
      dr = dr.filter(Boolean);
      for (let vr = 0; vr < dr.length; vr += 1)
        transition_out(dr[vr]);
      ur = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_each(dr, gr);
    }
  };
}
const cBase$c = "w-full flex";
function isFull(lr, ar) {
  return Math.floor(lr) >= ar + 1;
}
function isHalf(lr, ar) {
  return lr === ar + 0.5;
}
function instance$w(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { value: hr = 0 } = ar, { max: gr = 5 } = ar, { interactive: vr = !1 } = ar, { text: mr = "text-token" } = ar, { fill: br = "fill-token" } = ar, { justify: yr = "justify-center" } = ar, { spacing: kr = "space-x-2" } = ar, { regionIcon: Tr = "" } = ar;
  const _r = createEventDispatcher();
  function Er(Cr) {
    _r("icon", { index: Cr + 1 });
  }
  const xr = (Cr) => Er(Cr);
  return lr.$$set = (Cr) => {
    cr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Cr))), "value" in Cr && cr(0, hr = Cr.value), "max" in Cr && cr(1, gr = Cr.max), "interactive" in Cr && cr(2, vr = Cr.interactive), "text" in Cr && cr(6, mr = Cr.text), "fill" in Cr && cr(7, br = Cr.fill), "justify" in Cr && cr(8, yr = Cr.justify), "spacing" in Cr && cr(9, kr = Cr.spacing), "regionIcon" in Cr && cr(3, Tr = Cr.regionIcon), "$$scope" in Cr && cr(10, dr = Cr.$$scope);
  }, lr.$$.update = () => {
    var Cr;
    cr(4, ur = `${cBase$c} ${mr} ${br} ${yr} ${kr} ${(Cr = ar.class) != null ? Cr : ""}`);
  }, ar = exclude_internal_props(ar), [
    hr,
    gr,
    vr,
    Tr,
    ur,
    Er,
    mr,
    br,
    yr,
    kr,
    dr,
    fr,
    xr
  ];
}
class Ratings extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$w, create_fragment$R, safe_not_equal, {
      value: 0,
      max: 1,
      interactive: 2,
      text: 6,
      fill: 7,
      justify: 8,
      spacing: 9,
      regionIcon: 3
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get max() {
    return this.$$.ctx[1];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[2];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get text() {
    return this.$$.ctx[6];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[8];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[9];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionIcon() {
    return this.$$.ctx[3];
  }
  set regionIcon(ar) {
    this.$$set({ regionIcon: ar }), flush();
  }
}
create_custom_element(Ratings, { value: {}, max: {}, interactive: { type: "Boolean" }, text: {}, fill: {}, justify: {}, spacing: {}, regionIcon: {} }, ["full", "half", "empty"], [], !0);
function create_fragment$Q(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[14].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[13],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "radio-group " + /*classesBase*/
      lr[1]), attr(ar, "data-testid", "radio-group"), attr(ar, "role", "radiogroup"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      );
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, [gr]) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      8192) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[13],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[13],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[13]
        ),
        null
      ), (!ur || gr & /*classesBase*/
      2 && cr !== (cr = "radio-group " + /*classesBase*/
      hr[1])) && attr(ar, "class", cr), (!ur || gr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        hr[0]
      );
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
const cBase$b = "p-1";
function instance$v(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { display: hr = "inline-flex" } = ar, { background: gr = "bg-surface-200-700-token" } = ar, { border: vr = "border-token border-surface-400-500-token" } = ar, { spacing: mr = "" } = ar, { rounded: br = "rounded-token" } = ar, { padding: yr = "px-4 py-1" } = ar, { active: kr = "variant-filled" } = ar, { hover: Tr = "hover:variant-soft" } = ar, { color: _r = "" } = ar, { fill: Er = "" } = ar, { regionLabel: xr = "" } = ar, { labelledby: Cr = "" } = ar;
  return setContext("rounded", br), setContext("padding", yr), setContext("active", kr), setContext("hover", Tr), setContext("color", _r), setContext("fill", Er), setContext("regionLabel", xr), lr.$$set = (Ar) => {
    cr(15, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ar))), "display" in Ar && cr(3, hr = Ar.display), "background" in Ar && cr(4, gr = Ar.background), "border" in Ar && cr(5, vr = Ar.border), "spacing" in Ar && cr(2, mr = Ar.spacing), "rounded" in Ar && cr(6, br = Ar.rounded), "padding" in Ar && cr(7, yr = Ar.padding), "active" in Ar && cr(8, kr = Ar.active), "hover" in Ar && cr(9, Tr = Ar.hover), "color" in Ar && cr(10, _r = Ar.color), "fill" in Ar && cr(11, Er = Ar.fill), "regionLabel" in Ar && cr(12, xr = Ar.regionLabel), "labelledby" in Ar && cr(0, Cr = Ar.labelledby), "$$scope" in Ar && cr(13, dr = Ar.$$scope);
  }, lr.$$.update = () => {
    var Ar;
    lr.$$.dirty & /*display*/
    8 && cr(2, mr = `${hr.includes("flex-col") ? "" : "space-x-1"}`), cr(1, ur = `${cBase$b} ${hr} ${gr} ${vr} ${mr} ${br} ${(Ar = ar.class) != null ? Ar : ""}`);
  }, ar = exclude_internal_props(ar), [
    Cr,
    ur,
    mr,
    hr,
    gr,
    vr,
    br,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    dr,
    fr
  ];
}
class RadioGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$v, create_fragment$Q, safe_not_equal, {
      display: 3,
      background: 4,
      border: 5,
      spacing: 2,
      rounded: 6,
      padding: 7,
      active: 8,
      hover: 9,
      color: 10,
      fill: 11,
      regionLabel: 12,
      labelledby: 0
    });
  }
  get display() {
    return this.$$.ctx[3];
  }
  set display(ar) {
    this.$$set({ display: ar }), flush();
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[2];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[6];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[10];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[11];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[12];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RadioGroup, { display: {}, background: {}, border: {}, spacing: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {}, labelledby: {} }, ["default"], [], !0);
function create_fragment$P(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[11](),
    { tabindex: "-1" }
  ], Tr = {};
  for (let xr = 0; xr < kr.length; xr += 1)
    Tr = assign$1(Tr, kr[xr]);
  const _r = (
    /*#slots*/
    lr[21].default
  ), Er = create_slot(
    _r,
    lr,
    /*$$scope*/
    lr[20],
    null
  );
  return mr = init_binding_group(
    /*$$binding_groups*/
    lr[29][0]
  ), {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), fr = element("input"), dr = space(), Er && Er.c(), set_attributes(fr, Tr), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(cr, "class", hr = "radio-item " + /*classesWrapper*/
      lr[8]), attr(cr, "data-testid", "radio-item"), attr(cr, "role", "radio"), attr(
        cr,
        "aria-checked",
        /*checked*/
        lr[6]
      ), attr(
        cr,
        "aria-label",
        /*label*/
        lr[4]
      ), attr(cr, "tabindex", "0"), attr(
        cr,
        "title",
        /*title*/
        lr[3]
      ), attr(ar, "class", gr = "radio-label " + /*classsBase*/
      lr[9] + " " + /*regionLabel*/
      lr[5]), mr.p(fr);
    },
    m(xr, Cr) {
      insert(xr, ar, Cr), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[27](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), Er && Er.m(cr, null), vr = !0, br || (yr = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[28]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[25]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[26]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[22]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[23]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[24]
        )
      ], br = !0);
    },
    p(xr, Cr) {
      set_attributes(fr, Tr = get_spread_update(kr, [
        { type: "radio" },
        (!vr || Cr[0] & /*name*/
        2) && { name: (
          /*name*/
          xr[1]
        ) },
        (!vr || Cr[0] & /*value*/
        4) && { __value: (
          /*value*/
          xr[2]
        ) },
        /*prunedRestProps*/
        xr[11](),
        { tabindex: "-1" }
      ])), Cr[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      xr[0]), Er && Er.p && (!vr || Cr[0] & /*$$scope*/
      1048576) && update_slot_base(
        Er,
        _r,
        xr,
        /*$$scope*/
        xr[20],
        vr ? get_slot_changes(
          _r,
          /*$$scope*/
          xr[20],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          xr[20]
        ),
        null
      ), (!vr || Cr[0] & /*classesWrapper*/
      256 && hr !== (hr = "radio-item " + /*classesWrapper*/
      xr[8])) && attr(cr, "class", hr), (!vr || Cr[0] & /*checked*/
      64) && attr(
        cr,
        "aria-checked",
        /*checked*/
        xr[6]
      ), (!vr || Cr[0] & /*label*/
      16) && attr(
        cr,
        "aria-label",
        /*label*/
        xr[4]
      ), (!vr || Cr[0] & /*title*/
      8) && attr(
        cr,
        "title",
        /*title*/
        xr[3]
      ), (!vr || Cr[0] & /*classsBase, regionLabel*/
      544 && gr !== (gr = "radio-label " + /*classsBase*/
      xr[9] + " " + /*regionLabel*/
      xr[5])) && attr(ar, "class", gr);
    },
    i(xr) {
      vr || (transition_in(Er, xr), vr = !0);
    },
    o(xr) {
      transition_out(Er, xr), vr = !1;
    },
    d(xr) {
      xr && detach(ar), lr[27](null), Er && Er.d(xr), mr.r(), br = !1, run_all(yr);
    }
  };
}
const cBase$a = "flex-auto", cWrapper$1 = "text-base text-center cursor-pointer", cDisabled$1 = "opacity-50 cursor-not-allowed";
function instance$u(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "label",
    "rounded",
    "padding",
    "active",
    "hover",
    "color",
    "fill",
    "regionLabel"
  ];
  let mr = compute_rest_props(ar, vr), { $$slots: br = {}, $$scope: yr } = ar, { group: kr } = ar, { name: Tr } = ar, { value: _r } = ar, { title: Er = "" } = ar, { label: xr = "" } = ar, { rounded: Cr = getContext("rounded") } = ar, { padding: Ar = getContext("padding") } = ar, { active: Lr = getContext("active") } = ar, { hover: Dr = getContext("hover") } = ar, { color: Nr = getContext("color") } = ar, { fill: Hr = getContext("fill") } = ar, { regionLabel: $r = getContext("regionLabel") } = ar, Wr;
  function Zr(gi) {
    ["Enter", "Space"].includes(gi.code) && (gi.preventDefault(), Wr.click());
  }
  function oi() {
    return delete mr.class, mr;
  }
  const Jr = [[]];
  function Yr(gi) {
    bubble.call(this, lr, gi);
  }
  function li(gi) {
    bubble.call(this, lr, gi);
  }
  function Si(gi) {
    bubble.call(this, lr, gi);
  }
  function ci(gi) {
    bubble.call(this, lr, gi);
  }
  function hi(gi) {
    bubble.call(this, lr, gi);
  }
  function Ei(gi) {
    binding_callbacks[gi ? "unshift" : "push"](() => {
      Wr = gi, cr(7, Wr);
    });
  }
  function di() {
    kr = this.__value, cr(0, kr);
  }
  return lr.$$set = (gi) => {
    cr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(gi))), cr(30, mr = compute_rest_props(ar, vr)), "group" in gi && cr(0, kr = gi.group), "name" in gi && cr(1, Tr = gi.name), "value" in gi && cr(2, _r = gi.value), "title" in gi && cr(3, Er = gi.title), "label" in gi && cr(4, xr = gi.label), "rounded" in gi && cr(12, Cr = gi.rounded), "padding" in gi && cr(13, Ar = gi.padding), "active" in gi && cr(14, Lr = gi.active), "hover" in gi && cr(15, Dr = gi.hover), "color" in gi && cr(16, Nr = gi.color), "fill" in gi && cr(17, Hr = gi.fill), "regionLabel" in gi && cr(5, $r = gi.regionLabel), "$$scope" in gi && cr(20, yr = gi.$$scope);
  }, lr.$$.update = () => {
    var gi;
    lr.$$.dirty[0] & /*value, group*/
    5 && cr(6, ur = _r === kr), lr.$$.dirty[0] & /*checked, active, color, fill, hover*/
    245824 && cr(19, fr = ur ? `${Lr} ${Nr} ${Hr}` : Dr), cr(18, dr = ar.disabled ? cDisabled$1 : ""), cr(8, gr = `${cWrapper$1} ${Ar} ${Cr} ${fr} ${dr} ${(gi = ar.class) != null ? gi : ""}`);
  }, cr(9, hr = `${cBase$a}`), ar = exclude_internal_props(ar), [
    kr,
    Tr,
    _r,
    Er,
    xr,
    $r,
    ur,
    Wr,
    gr,
    hr,
    Zr,
    oi,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    dr,
    fr,
    yr,
    br,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    Jr
  ];
}
class RadioItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$u,
      create_fragment$P,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        label: 4,
        rounded: 12,
        padding: 13,
        active: 14,
        hover: 15,
        color: 16,
        fill: 17,
        regionLabel: 5
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get label() {
    return this.$$.ctx[4];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[13];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[16];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[17];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[5];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
}
create_custom_element(RadioItem, { group: {}, name: {}, value: {}, title: {}, label: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {} }, ["default"], [], !0);
const get_trail_slot_changes = (lr) => ({}), get_trail_slot_context = (lr) => ({});
function get_each_context$7(lr, ar, cr) {
  const ur = lr.slice();
  return ur[23] = ar[cr], ur;
}
function create_if_block_2$7(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].default
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    null
  );
  return {
    c() {
      ar = element("label"), fr && fr.c(), attr(ar, "class", "range-slider-label " + cBaseLabel), attr(
        ar,
        "for",
        /*id*/
        lr[2]
      );
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          hr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        null
      ), (!cr || hr & /*id*/
      4) && attr(
        ar,
        "for",
        /*id*/
        dr[2]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block_1$9(lr) {
  let ar, cr, ur = ensure_array_like(
    /*tickmarks*/
    lr[8]
  ), fr = [];
  for (let dr = 0; dr < ur.length; dr += 1)
    fr[dr] = create_each_block$7(get_each_context$7(lr, ur, dr));
  return {
    c() {
      ar = element("datalist");
      for (let dr = 0; dr < fr.length; dr += 1)
        fr[dr].c();
      attr(ar, "id", cr = "tickmarks-" + /*id*/
      lr[2]), attr(ar, "class", "range-slider-ticks");
    },
    m(dr, hr) {
      insert(dr, ar, hr);
      for (let gr = 0; gr < fr.length; gr += 1)
        fr[gr] && fr[gr].m(ar, null);
    },
    p(dr, hr) {
      if (hr & /*tickmarks*/
      256) {
        ur = ensure_array_like(
          /*tickmarks*/
          dr[8]
        );
        let gr;
        for (gr = 0; gr < ur.length; gr += 1) {
          const vr = get_each_context$7(dr, ur, gr);
          fr[gr] ? fr[gr].p(vr, hr) : (fr[gr] = create_each_block$7(vr), fr[gr].c(), fr[gr].m(ar, null));
        }
        for (; gr < fr.length; gr += 1)
          fr[gr].d(1);
        fr.length = ur.length;
      }
      hr & /*id*/
      4 && cr !== (cr = "tickmarks-" + /*id*/
      dr[2]) && attr(ar, "id", cr);
    },
    d(dr) {
      dr && detach(ar), destroy_each(fr, dr);
    }
  };
}
function create_each_block$7(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("option"), ar.__value = cr = /*tm*/
      lr[23], set_input_value(ar, ar.__value), attr(ar, "label", ur = /*tm*/
      lr[23]);
    },
    m(fr, dr) {
      insert(fr, ar, dr);
    },
    p(fr, dr) {
      dr & /*tickmarks*/
      256 && cr !== (cr = /*tm*/
      fr[23]) && (ar.__value = cr, set_input_value(ar, ar.__value)), dr & /*tickmarks*/
      256 && ur !== (ur = /*tm*/
      fr[23]) && attr(ar, "label", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block$k(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].trail
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    get_trail_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "range-slider-trail");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          hr,
          get_trail_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        get_trail_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$O(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr = (
    /*$$slots*/
    lr[12].default && create_if_block_2$7(lr)
  ), _r = [
    { type: "range" },
    { id: (
      /*id*/
      lr[2]
    ) },
    { name: (
      /*name*/
      lr[1]
    ) },
    {
      class: dr = "range-slider-input " + /*classesInput*/
      lr[9]
    },
    {
      list: hr = "tickmarks-" + /*id*/
      lr[2]
    },
    { "aria-label": (
      /*label*/
      lr[7]
    ) },
    { min: (
      /*min*/
      lr[3]
    ) },
    { max: (
      /*max*/
      lr[4]
    ) },
    { step: (
      /*step*/
      lr[5]
    ) },
    /*prunedRestProps*/
    lr[11]()
  ], Er = {};
  for (let Ar = 0; Ar < _r.length; Ar += 1)
    Er = assign$1(Er, _r[Ar]);
  let xr = (
    /*ticked*/
    lr[6] && /*tickmarks*/
    lr[8] && /*tickmarks*/
    lr[8].length && create_if_block_1$9(lr)
  ), Cr = (
    /*$$slots*/
    lr[12].trail && create_if_block$k(lr)
  );
  return {
    c() {
      ar = element("div"), Tr && Tr.c(), cr = space(), ur = element("div"), fr = element("input"), gr = space(), xr && xr.c(), vr = space(), Cr && Cr.c(), set_attributes(fr, Er), attr(ur, "class", "range-content " + cBaseContent), attr(ar, "class", mr = "range-slider " + /*classesBase*/
      lr[10]), attr(ar, "data-testid", "range-slider");
    },
    m(Ar, Lr) {
      insert(Ar, ar, Lr), Tr && Tr.m(ar, null), append(ar, cr), append(ar, ur), append(ur, fr), fr.autofocus && fr.focus(), set_input_value(
        fr,
        /*value*/
        lr[0]
      ), append(ur, gr), xr && xr.m(ur, null), append(ar, vr), Cr && Cr.m(ar, null), br = !0, yr || (kr = [
        listen(
          fr,
          "change",
          /*input_change_input_handler*/
          lr[19]
        ),
        listen(
          fr,
          "input",
          /*input_change_input_handler*/
          lr[19]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[16]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[17]
        ),
        listen(
          fr,
          "blur",
          /*blur_handler*/
          lr[18]
        )
      ], yr = !0);
    },
    p(Ar, [Lr]) {
      /*$$slots*/
      Ar[12].default ? Tr ? (Tr.p(Ar, Lr), Lr & /*$$slots*/
      4096 && transition_in(Tr, 1)) : (Tr = create_if_block_2$7(Ar), Tr.c(), transition_in(Tr, 1), Tr.m(ar, cr)) : Tr && (group_outros(), transition_out(Tr, 1, 1, () => {
        Tr = null;
      }), check_outros()), set_attributes(fr, Er = get_spread_update(_r, [
        { type: "range" },
        (!br || Lr & /*id*/
        4) && { id: (
          /*id*/
          Ar[2]
        ) },
        (!br || Lr & /*name*/
        2) && { name: (
          /*name*/
          Ar[1]
        ) },
        (!br || Lr & /*classesInput*/
        512 && dr !== (dr = "range-slider-input " + /*classesInput*/
        Ar[9])) && { class: dr },
        (!br || Lr & /*id*/
        4 && hr !== (hr = "tickmarks-" + /*id*/
        Ar[2])) && { list: hr },
        (!br || Lr & /*label*/
        128) && { "aria-label": (
          /*label*/
          Ar[7]
        ) },
        (!br || Lr & /*min*/
        8) && { min: (
          /*min*/
          Ar[3]
        ) },
        (!br || Lr & /*max*/
        16) && { max: (
          /*max*/
          Ar[4]
        ) },
        (!br || Lr & /*step*/
        32) && { step: (
          /*step*/
          Ar[5]
        ) },
        /*prunedRestProps*/
        Ar[11]()
      ])), Lr & /*value*/
      1 && set_input_value(
        fr,
        /*value*/
        Ar[0]
      ), /*ticked*/
      Ar[6] && /*tickmarks*/
      Ar[8] && /*tickmarks*/
      Ar[8].length ? xr ? xr.p(Ar, Lr) : (xr = create_if_block_1$9(Ar), xr.c(), xr.m(ur, null)) : xr && (xr.d(1), xr = null), /*$$slots*/
      Ar[12].trail ? Cr ? (Cr.p(Ar, Lr), Lr & /*$$slots*/
      4096 && transition_in(Cr, 1)) : (Cr = create_if_block$k(Ar), Cr.c(), transition_in(Cr, 1), Cr.m(ar, null)) : Cr && (group_outros(), transition_out(Cr, 1, 1, () => {
        Cr = null;
      }), check_outros()), (!br || Lr & /*classesBase*/
      1024 && mr !== (mr = "range-slider " + /*classesBase*/
      Ar[10])) && attr(ar, "class", mr);
    },
    i(Ar) {
      br || (transition_in(Tr), transition_in(Cr), br = !0);
    },
    o(Ar) {
      transition_out(Tr), transition_out(Cr), br = !1;
    },
    d(Ar) {
      Ar && detach(ar), Tr && Tr.d(), xr && xr.d(), Cr && Cr.d(), yr = !1, run_all(kr);
    }
  };
}
const cBase$9 = "space-y-2", cBaseLabel = "", cBaseContent = "flex justify-center py-2", cBaseInput = "w-full h-2";
function instance$t(lr, ar, cr) {
  let ur, fr;
  const dr = ["name", "id", "value", "min", "max", "step", "ticked", "accent", "label"];
  let hr = compute_rest_props(ar, dr), { $$slots: gr = {}, $$scope: vr } = ar;
  const mr = compute_slots(gr);
  let { name: br } = ar, { id: yr = String(Math.random()) } = ar, { value: kr = 0 } = ar, { min: Tr = 0 } = ar, { max: _r = 100 } = ar, { step: Er = 1 } = ar, { ticked: xr = !1 } = ar, { accent: Cr = "accent-surface-900 dark:accent-surface-50" } = ar, { label: Ar = "" } = ar, Lr;
  function Dr() {
    xr != !1 && cr(8, Lr = Array.from({ length: _r - Tr + 1 }, (oi, Jr) => Jr + Tr));
  }
  xr && Dr(), afterUpdate(() => {
    Dr();
  });
  function Nr() {
    return delete hr.class, hr;
  }
  function Hr(oi) {
    bubble.call(this, lr, oi);
  }
  function $r(oi) {
    bubble.call(this, lr, oi);
  }
  function Wr(oi) {
    bubble.call(this, lr, oi);
  }
  function Zr() {
    kr = to_number(this.value), cr(0, kr);
  }
  return lr.$$set = (oi) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(oi))), cr(21, hr = compute_rest_props(ar, dr)), "name" in oi && cr(1, br = oi.name), "id" in oi && cr(2, yr = oi.id), "value" in oi && cr(0, kr = oi.value), "min" in oi && cr(3, Tr = oi.min), "max" in oi && cr(4, _r = oi.max), "step" in oi && cr(5, Er = oi.step), "ticked" in oi && cr(6, xr = oi.ticked), "accent" in oi && cr(13, Cr = oi.accent), "label" in oi && cr(7, Ar = oi.label), "$$scope" in oi && cr(14, vr = oi.$$scope);
  }, lr.$$.update = () => {
    var oi;
    cr(10, ur = `${cBase$9} ${(oi = ar.class) != null ? oi : ""}`), lr.$$.dirty & /*accent*/
    8192 && cr(9, fr = `${cBaseInput} ${Cr}`);
  }, ar = exclude_internal_props(ar), [
    kr,
    br,
    yr,
    Tr,
    _r,
    Er,
    xr,
    Ar,
    Lr,
    fr,
    ur,
    Nr,
    mr,
    Cr,
    vr,
    gr,
    Hr,
    $r,
    Wr,
    Zr
  ];
}
class RangeSlider extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$t, create_fragment$O, safe_not_equal, {
      name: 1,
      id: 2,
      value: 0,
      min: 3,
      max: 4,
      step: 5,
      ticked: 6,
      accent: 13,
      label: 7
    });
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get id() {
    return this.$$.ctx[2];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[3];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[4];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get step() {
    return this.$$.ctx[5];
  }
  set step(ar) {
    this.$$set({ step: ar }), flush();
  }
  get ticked() {
    return this.$$.ctx[6];
  }
  set ticked(ar) {
    this.$$set({ ticked: ar }), flush();
  }
  get accent() {
    return this.$$.ctx[13];
  }
  set accent(ar) {
    this.$$set({ accent: ar }), flush();
  }
  get label() {
    return this.$$.ctx[7];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(RangeSlider, { name: {}, id: {}, value: {}, min: {}, max: {}, step: {}, ticked: { type: "Boolean" }, accent: {}, label: {} }, ["default", "trail"], [], !0);
function create_if_block$j(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[22].default
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "slide-toggle-text ml-3");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr[0] & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[21],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[21],
          hr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[21]
        ),
        null
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$N(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    { name: (
      /*name*/
      lr[1]
    ) },
    /*prunedRestProps*/
    lr[8](),
    {
      disabled: fr = /*$$props*/
      lr[9].disabled
    }
  ], Cr = {};
  for (let Lr = 0; Lr < xr.length; Lr += 1)
    Cr = assign$1(Cr, xr[Lr]);
  let Ar = (
    /*$$slots*/
    lr[10].default && create_if_block$j(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("label"), ur = element("input"), dr = space(), hr = element("div"), gr = element("div"), br = space(), Ar && Ar.c(), set_attributes(ur, Cr), attr(gr, "class", vr = "slide-toggle-thumb " + /*classesThumb*/
      lr[3]), toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        lr[9].disabled
      ), attr(hr, "class", mr = "slide-toggle-track " + /*classesTrack*/
      lr[4]), toggle_class(
        hr,
        "cursor-not-allowed",
        /*$$props*/
        lr[9].disabled
      ), attr(cr, "class", yr = "slide-toggle-label " + /*classesLabel*/
      lr[5]), attr(
        ar,
        "id",
        /*label*/
        lr[2]
      ), attr(ar, "class", kr = "slide-toggle " + /*classesBase*/
      lr[6]), attr(ar, "data-testid", "slide-toggle"), attr(ar, "role", "switch"), attr(
        ar,
        "aria-label",
        /*label*/
        lr[2]
      ), attr(
        ar,
        "aria-checked",
        /*checked*/
        lr[0]
      ), attr(ar, "tabindex", "0");
    },
    m(Lr, Dr) {
      insert(Lr, ar, Dr), append(ar, cr), append(cr, ur), ur.autofocus && ur.focus(), ur.checked = /*checked*/
      lr[0], append(cr, dr), append(cr, hr), append(hr, gr), append(cr, br), Ar && Ar.m(cr, null), Tr = !0, _r || (Er = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          lr[31]
        ),
        listen(
          ur,
          "click",
          /*click_handler*/
          lr[23]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          lr[24]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          lr[25]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          lr[26]
        ),
        listen(
          ur,
          "mouseover",
          /*mouseover_handler*/
          lr[27]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          lr[28]
        ),
        listen(
          ur,
          "focus",
          /*focus_handler*/
          lr[29]
        ),
        listen(
          ur,
          "blur",
          /*blur_handler*/
          lr[30]
        ),
        listen(
          ar,
          "keydown",
          /*onKeyDown*/
          lr[7]
        )
      ], _r = !0);
    },
    p(Lr, Dr) {
      set_attributes(ur, Cr = get_spread_update(xr, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        (!Tr || Dr[0] & /*name*/
        2) && { name: (
          /*name*/
          Lr[1]
        ) },
        /*prunedRestProps*/
        Lr[8](),
        (!Tr || Dr[0] & /*$$props*/
        512 && fr !== (fr = /*$$props*/
        Lr[9].disabled)) && { disabled: fr }
      ])), Dr[0] & /*checked*/
      1 && (ur.checked = /*checked*/
      Lr[0]), (!Tr || Dr[0] & /*classesThumb*/
      8 && vr !== (vr = "slide-toggle-thumb " + /*classesThumb*/
      Lr[3])) && attr(gr, "class", vr), (!Tr || Dr[0] & /*classesThumb, $$props*/
      520) && toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        Lr[9].disabled
      ), (!Tr || Dr[0] & /*classesTrack*/
      16 && mr !== (mr = "slide-toggle-track " + /*classesTrack*/
      Lr[4])) && attr(hr, "class", mr), (!Tr || Dr[0] & /*classesTrack, $$props*/
      528) && toggle_class(
        hr,
        "cursor-not-allowed",
        /*$$props*/
        Lr[9].disabled
      ), /*$$slots*/
      Lr[10].default ? Ar ? (Ar.p(Lr, Dr), Dr[0] & /*$$slots*/
      1024 && transition_in(Ar, 1)) : (Ar = create_if_block$j(Lr), Ar.c(), transition_in(Ar, 1), Ar.m(cr, null)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), (!Tr || Dr[0] & /*classesLabel*/
      32 && yr !== (yr = "slide-toggle-label " + /*classesLabel*/
      Lr[5])) && attr(cr, "class", yr), (!Tr || Dr[0] & /*label*/
      4) && attr(
        ar,
        "id",
        /*label*/
        Lr[2]
      ), (!Tr || Dr[0] & /*classesBase*/
      64 && kr !== (kr = "slide-toggle " + /*classesBase*/
      Lr[6])) && attr(ar, "class", kr), (!Tr || Dr[0] & /*label*/
      4) && attr(
        ar,
        "aria-label",
        /*label*/
        Lr[2]
      ), (!Tr || Dr[0] & /*checked*/
      1) && attr(
        ar,
        "aria-checked",
        /*checked*/
        Lr[0]
      );
    },
    i(Lr) {
      Tr || (transition_in(Ar), Tr = !0);
    },
    o(Lr) {
      transition_out(Ar), Tr = !1;
    },
    d(Lr) {
      Lr && detach(ar), Ar && Ar.d(), _r = !1, run_all(Er);
    }
  };
}
const cBase$8 = "inline-block", cLabel = "unstyled flex items-center", cTrack$1 = "flex transition-all duration-[200ms] cursor-pointer", cThumb$1 = "w-[50%] h-full scale-[0.8] transition-all duration-[200ms] shadow";
function instance$s(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br;
  const yr = ["name", "checked", "size", "background", "active", "border", "rounded", "label"];
  let kr = compute_rest_props(ar, yr), { $$slots: Tr = {}, $$scope: _r } = ar;
  const Er = compute_slots(Tr), xr = createEventDispatcher();
  let { name: Cr } = ar, { checked: Ar = !1 } = ar, { size: Lr = "md" } = ar, { background: Dr = "bg-surface-400 dark:bg-surface-700" } = ar, { active: Nr = "bg-surface-900 dark:bg-surface-300" } = ar, { border: Hr = "" } = ar, { rounded: $r = "rounded-full" } = ar, { label: Wr = "" } = ar, Zr;
  switch (Lr) {
    case "sm":
      Zr = "w-12 h-6";
      break;
    case "lg":
      Zr = "w-20 h-10";
      break;
    default:
      Zr = "w-16 h-8";
  }
  function oi(ui) {
    ["Enter", "Space"].includes(ui.code) && (ui.preventDefault(), xr("keyup", ui), ui.currentTarget.firstChild.click());
  }
  function Jr() {
    return delete kr.class, kr;
  }
  function Yr(ui) {
    bubble.call(this, lr, ui);
  }
  function li(ui) {
    bubble.call(this, lr, ui);
  }
  function Si(ui) {
    bubble.call(this, lr, ui);
  }
  function ci(ui) {
    bubble.call(this, lr, ui);
  }
  function hi(ui) {
    bubble.call(this, lr, ui);
  }
  function Ei(ui) {
    bubble.call(this, lr, ui);
  }
  function di(ui) {
    bubble.call(this, lr, ui);
  }
  function gi(ui) {
    bubble.call(this, lr, ui);
  }
  function Li() {
    Ar = this.checked, cr(0, Ar);
  }
  return lr.$$set = (ui) => {
    cr(9, ar = assign$1(assign$1({}, ar), exclude_internal_props(ui))), cr(33, kr = compute_rest_props(ar, yr)), "name" in ui && cr(1, Cr = ui.name), "checked" in ui && cr(0, Ar = ui.checked), "size" in ui && cr(11, Lr = ui.size), "background" in ui && cr(12, Dr = ui.background), "active" in ui && cr(13, Nr = ui.active), "border" in ui && cr(14, Hr = ui.border), "rounded" in ui && cr(15, $r = ui.rounded), "label" in ui && cr(2, Wr = ui.label), "$$scope" in ui && cr(21, _r = ui.$$scope);
  }, lr.$$.update = () => {
    var ui;
    lr.$$.dirty[0] & /*checked, active, background*/
    12289 && cr(19, ur = Ar ? Nr : `${Dr} cursor-pointer`), lr.$$.dirty[0] & /*checked*/
    1 && cr(18, fr = Ar ? "bg-white/75" : "bg-white"), lr.$$.dirty[0] & /*checked*/
    1 && cr(17, dr = Ar ? "translate-x-full" : ""), cr(20, hr = ar.disabled === !0 ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer"), cr(6, gr = `${cBase$8} ${$r} ${hr} ${(ui = ar.class) != null ? ui : ""}`), lr.$$.dirty[0] & /*border, rounded, trackSize, cTrackActive*/
    638976 && cr(4, mr = `${cTrack$1} ${Hr} ${$r} ${Zr} ${ur}`), lr.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    425984 && cr(3, br = `${cThumb$1} ${$r} ${fr} ${dr}`);
  }, cr(5, vr = `${cLabel}`), ar = exclude_internal_props(ar), [
    Ar,
    Cr,
    Wr,
    br,
    mr,
    vr,
    gr,
    oi,
    Jr,
    ar,
    Er,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Zr,
    dr,
    fr,
    ur,
    hr,
    _r,
    Tr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    Li
  ];
}
class SlideToggle extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$s,
      create_fragment$N,
      safe_not_equal,
      {
        name: 1,
        checked: 0,
        size: 11,
        background: 12,
        active: 13,
        border: 14,
        rounded: 15,
        label: 2
      },
      null,
      [-1, -1]
    );
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[0];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get size() {
    return this.$$.ctx[11];
  }
  set size(ar) {
    this.$$set({ size: ar }), flush();
  }
  get background() {
    return this.$$.ctx[12];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get label() {
    return this.$$.ctx[2];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(SlideToggle, { name: {}, checked: { type: "Boolean" }, size: {}, background: {}, active: {}, border: {}, rounded: {}, label: {} }, ["default"], [], !0);
function get_each_context$6(lr, ar, cr) {
  const ur = lr.slice();
  return ur[36] = ar[cr], ur;
}
function create_if_block$i(lr) {
  let ar, cr, ur, fr, dr, hr = ensure_array_like(Array.from(Array(
    /*$state*/
    lr[7].total
  ).keys())), gr = [];
  for (let vr = 0; vr < hr.length; vr += 1)
    gr[vr] = create_each_block$6(get_each_context$6(lr, hr, vr));
  return {
    c() {
      ar = element("header");
      for (let vr = 0; vr < gr.length; vr += 1)
        gr[vr].c();
      attr(ar, "class", cr = "stepper-header " + /*classesHeader*/
      lr[11]);
    },
    m(vr, mr) {
      insert(vr, ar, mr);
      for (let br = 0; br < gr.length; br += 1)
        gr[br] && gr[br].m(ar, null);
      dr = !0;
    },
    p(vr, mr) {
      if (lr = vr, mr[0] & /*classesHeaderStep, isActive, $state, classesBadge, stepTerm*/
      1729) {
        hr = ensure_array_like(Array.from(Array(
          /*$state*/
          lr[7].total
        ).keys()));
        let br;
        for (br = 0; br < hr.length; br += 1) {
          const yr = get_each_context$6(lr, hr, br);
          gr[br] ? gr[br].p(yr, mr) : (gr[br] = create_each_block$6(yr), gr[br].c(), gr[br].m(ar, null));
        }
        for (; br < gr.length; br += 1)
          gr[br].d(1);
        gr.length = hr.length;
      }
      (!dr || mr[0] & /*classesHeader*/
      2048 && cr !== (cr = "stepper-header " + /*classesHeader*/
      lr[11])) && attr(ar, "class", cr);
    },
    i(vr) {
      dr || (vr && add_render_callback(() => {
        dr && (fr && fr.end(1), ur = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[2]
          ),
          params: (
            /*transitionInParams*/
            lr[3]
          ),
          enabled: (
            /*transitions*/
            lr[1]
          )
        }), ur.start());
      }), dr = !0);
    },
    o(vr) {
      ur && ur.invalidate(), vr && (fr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[4]
        ),
        params: (
          /*transitionOutParams*/
          lr[5]
        ),
        enabled: (
          /*transitions*/
          lr[1]
        )
      })), dr = !1;
    },
    d(vr) {
      vr && detach(ar), destroy_each(gr, vr), vr && fr && fr.end();
    }
  };
}
function create_each_block$6(lr) {
  let ar, cr, ur = (
    /*isActive*/
    (lr[6](
      /*step*/
      lr[36]
    ) ? `${/*stepTerm*/
    lr[0]} ${/*step*/
    lr[36] + 1}` : (
      /*step*/
      lr[36] + 1
    )) + ""
  ), fr, dr, hr, gr;
  return {
    c() {
      ar = element("div"), cr = element("span"), fr = text$3(ur), hr = space(), attr(cr, "class", dr = "badge " + /*classesBadge*/
      lr[9](
        /*step*/
        lr[36]
      )), attr(ar, "class", gr = "stepper-header-step " + /*classesHeaderStep*/
      lr[10]), toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        lr[6](
          /*step*/
          lr[36]
        )
      );
    },
    m(vr, mr) {
      insert(vr, ar, mr), append(ar, cr), append(cr, fr), append(ar, hr);
    },
    p(vr, mr) {
      mr[0] & /*isActive, $state, stepTerm*/
      193 && ur !== (ur = /*isActive*/
      (vr[6](
        /*step*/
        vr[36]
      ) ? `${/*stepTerm*/
      vr[0]} ${/*step*/
      vr[36] + 1}` : (
        /*step*/
        vr[36] + 1
      )) + "") && set_data(fr, ur), mr[0] & /*classesBadge, $state*/
      640 && dr !== (dr = "badge " + /*classesBadge*/
      vr[9](
        /*step*/
        vr[36]
      )) && attr(cr, "class", dr), mr[0] & /*classesHeaderStep*/
      1024 && gr !== (gr = "stepper-header-step " + /*classesHeaderStep*/
      vr[10]) && attr(ar, "class", gr), mr[0] & /*classesHeaderStep, isActive, $state*/
      1216 && toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        vr[6](
          /*step*/
          vr[36]
        )
      );
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_fragment$M(lr) {
  let ar, cr, ur, fr, dr, hr, gr = (
    /*$state*/
    lr[7].total && create_if_block$i(lr)
  );
  const vr = (
    /*#slots*/
    lr[32].default
  ), mr = create_slot(
    vr,
    lr,
    /*$$scope*/
    lr[31],
    null
  );
  return {
    c() {
      ar = element("div"), gr && gr.c(), cr = space(), ur = element("div"), mr && mr.c(), attr(ur, "class", fr = "stepper-content " + /*classesContent*/
      lr[8]), attr(ar, "class", dr = "stepper " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "stepper");
    },
    m(br, yr) {
      insert(br, ar, yr), gr && gr.m(ar, null), append(ar, cr), append(ar, ur), mr && mr.m(ur, null), hr = !0;
    },
    p(br, yr) {
      /*$state*/
      br[7].total ? gr ? (gr.p(br, yr), yr[0] & /*$state*/
      128 && transition_in(gr, 1)) : (gr = create_if_block$i(br), gr.c(), transition_in(gr, 1), gr.m(ar, cr)) : gr && (group_outros(), transition_out(gr, 1, 1, () => {
        gr = null;
      }), check_outros()), mr && mr.p && (!hr || yr[1] & /*$$scope*/
      1) && update_slot_base(
        mr,
        vr,
        br,
        /*$$scope*/
        br[31],
        hr ? get_slot_changes(
          vr,
          /*$$scope*/
          br[31],
          yr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          br[31]
        ),
        null
      ), (!hr || yr[0] & /*classesContent*/
      256 && fr !== (fr = "stepper-content " + /*classesContent*/
      br[8])) && attr(ur, "class", fr), (!hr || yr[0] & /*classesBase*/
      4096 && dr !== (dr = "stepper " + /*classesBase*/
      br[12])) && attr(ar, "class", dr);
    },
    i(br) {
      hr || (transition_in(gr), transition_in(mr, br), hr = !0);
    },
    o(br) {
      transition_out(gr), transition_out(mr, br), hr = !1;
    },
    d(br) {
      br && detach(ar), gr && gr.d(), mr && mr.d(br);
    }
  };
}
const cBase$7 = "space-y-4", cHeader$2 = "flex items-center border-t mt-[15px]", cHeaderStep = "-mt-[15px] transition-all duration-300", cContent$1 = "";
function instance$r(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br;
  component_subscribe(lr, prefersReducedMotionStore, (wi) => cr(33, br = wi));
  let { $$slots: yr = {}, $$scope: kr } = ar;
  const Tr = createEventDispatcher();
  let { gap: _r = "gap-4" } = ar, { stepTerm: Er = "Step" } = ar, { badge: xr = "variant-filled-surface" } = ar, { active: Cr = "variant-filled" } = ar, { border: Ar = "border-surface-400-500-token" } = ar, { start: Lr = 0 } = ar, { justify: Dr = "justify-between" } = ar, { buttonBack: Nr = "variant-ghost" } = ar, { buttonBackType: Hr = "button" } = ar, { buttonBackLabel: $r = "&larr; Back" } = ar, { buttonNext: Wr = "variant-filled" } = ar, { buttonNextType: Zr = "button" } = ar, { buttonNextLabel: oi = "Next &rarr;" } = ar, { buttonComplete: Jr = "variant-filled-primary" } = ar, { buttonCompleteType: Yr = "button" } = ar, { buttonCompleteLabel: li = "Complete" } = ar, { regionHeader: Si = "" } = ar, { regionContent: ci = "" } = ar, { transitions: hi = !br } = ar, { transitionIn: Ei = fade } = ar, { transitionInParams: di = { duration: 100 } } = ar, { transitionOut: gi = fade } = ar, { transitionOutParams: Li = { duration: 100 } } = ar, ui = writable({ current: Lr, total: 0 });
  return component_subscribe(lr, ui, (wi) => cr(7, mr = wi)), setContext("state", ui), setContext("dispatchParent", Tr), setContext("stepTerm", Er), setContext("gap", _r), setContext("justify", Dr), setContext("buttonBack", Nr), setContext("buttonBackType", Hr), setContext("buttonBackLabel", $r), setContext("buttonNext", Wr), setContext("buttonNextType", Zr), setContext("buttonNextLabel", oi), setContext("buttonComplete", Jr), setContext("buttonCompleteType", Yr), setContext("buttonCompleteLabel", li), setContext("transitions", hi), setContext("transitionIn", Ei), setContext("transitionInParams", di), setContext("transitionOut", gi), setContext("transitionOutParams", Li), lr.$$set = (wi) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(wi))), "gap" in wi && cr(14, _r = wi.gap), "stepTerm" in wi && cr(0, Er = wi.stepTerm), "badge" in wi && cr(15, xr = wi.badge), "active" in wi && cr(16, Cr = wi.active), "border" in wi && cr(17, Ar = wi.border), "start" in wi && cr(18, Lr = wi.start), "justify" in wi && cr(19, Dr = wi.justify), "buttonBack" in wi && cr(20, Nr = wi.buttonBack), "buttonBackType" in wi && cr(21, Hr = wi.buttonBackType), "buttonBackLabel" in wi && cr(22, $r = wi.buttonBackLabel), "buttonNext" in wi && cr(23, Wr = wi.buttonNext), "buttonNextType" in wi && cr(24, Zr = wi.buttonNextType), "buttonNextLabel" in wi && cr(25, oi = wi.buttonNextLabel), "buttonComplete" in wi && cr(26, Jr = wi.buttonComplete), "buttonCompleteType" in wi && cr(27, Yr = wi.buttonCompleteType), "buttonCompleteLabel" in wi && cr(28, li = wi.buttonCompleteLabel), "regionHeader" in wi && cr(29, Si = wi.regionHeader), "regionContent" in wi && cr(30, ci = wi.regionContent), "transitions" in wi && cr(1, hi = wi.transitions), "transitionIn" in wi && cr(2, Ei = wi.transitionIn), "transitionInParams" in wi && cr(3, di = wi.transitionInParams), "transitionOut" in wi && cr(4, gi = wi.transitionOut), "transitionOutParams" in wi && cr(5, Li = wi.transitionOutParams), "$$scope" in wi && cr(31, kr = wi.$$scope);
  }, lr.$$.update = () => {
    var wi;
    lr.$$.dirty[0] & /*$state*/
    128 && cr(6, ur = (Ui) => Ui === mr.current), cr(12, fr = `${cBase$7} ${(wi = ar.class) != null ? wi : ""}`), lr.$$.dirty[0] & /*border, gap, regionHeader*/
    537018368 && cr(11, dr = `${cHeader$2} ${Ar} ${_r} ${Si}`), lr.$$.dirty[0] & /*isActive, active, badge*/
    98368 && cr(9, gr = (Ui) => ur(Ui) ? Cr : xr), lr.$$.dirty[0] & /*regionContent*/
    1073741824 && cr(8, vr = `${cContent$1} ${ci}`);
  }, cr(10, hr = `${cHeaderStep}`), ar = exclude_internal_props(ar), [
    Er,
    hi,
    Ei,
    di,
    gi,
    Li,
    ur,
    mr,
    vr,
    gr,
    hr,
    dr,
    fr,
    ui,
    _r,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    kr,
    yr
  ];
}
class Stepper extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$r,
      create_fragment$M,
      safe_not_equal,
      {
        gap: 14,
        stepTerm: 0,
        badge: 15,
        active: 16,
        border: 17,
        start: 18,
        justify: 19,
        buttonBack: 20,
        buttonBackType: 21,
        buttonBackLabel: 22,
        buttonNext: 23,
        buttonNextType: 24,
        buttonNextLabel: 25,
        buttonComplete: 26,
        buttonCompleteType: 27,
        buttonCompleteLabel: 28,
        regionHeader: 29,
        regionContent: 30,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get gap() {
    return this.$$.ctx[14];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[0];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get badge() {
    return this.$$.ctx[15];
  }
  set badge(ar) {
    this.$$set({ badge: ar }), flush();
  }
  get active() {
    return this.$$.ctx[16];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[17];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get start() {
    return this.$$.ctx[18];
  }
  set start(ar) {
    this.$$set({ start: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[19];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[20];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[21];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[22];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[23];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[24];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[25];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[26];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[27];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[28];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[29];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[30];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Stepper, { gap: {}, stepTerm: {}, badge: {}, active: {}, border: {}, start: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, regionHeader: {}, regionContent: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
const get_navigation_slot_changes = (lr) => ({}), get_navigation_slot_context = (lr) => ({}), get_header_slot_changes = (lr) => ({}), get_header_slot_context = (lr) => ({});
function create_if_block$h(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr;
  const br = (
    /*#slots*/
    lr[34].header
  ), yr = create_slot(
    br,
    lr,
    /*$$scope*/
    lr[33],
    get_header_slot_context
  ), kr = yr || fallback_block_1(lr), Tr = (
    /*#slots*/
    lr[34].default
  ), _r = create_slot(
    Tr,
    lr,
    /*$$scope*/
    lr[33],
    null
  ), Er = _r || fallback_block$1(lr);
  let xr = (
    /*$state*/
    lr[21].total > 1 && create_if_block_1$8(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("header"), kr && kr.c(), fr = space(), dr = element("div"), Er && Er.c(), gr = space(), xr && xr.c(), attr(cr, "class", ur = "step-header " + /*classesHeader*/
      lr[19]), attr(dr, "class", hr = "step-content " + /*classesContent*/
      lr[18]), attr(ar, "class", vr = "step " + /*classesBase*/
      lr[20]), attr(ar, "data-testid", "step");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), kr && kr.m(cr, null), append(ar, fr), append(ar, dr), Er && Er.m(dr, null), append(ar, gr), xr && xr.m(ar, null), mr = !0;
    },
    p(Cr, Ar) {
      yr ? yr.p && (!mr || Ar[1] & /*$$scope*/
      4) && update_slot_base(
        yr,
        br,
        Cr,
        /*$$scope*/
        Cr[33],
        mr ? get_slot_changes(
          br,
          /*$$scope*/
          Cr[33],
          Ar,
          get_header_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Cr[33]
        ),
        get_header_slot_context
      ) : kr && kr.p && (!mr || Ar[0] & /*stepTerm*/
      4) && kr.p(Cr, mr ? Ar : [-1, -1]), (!mr || Ar[0] & /*classesHeader*/
      524288 && ur !== (ur = "step-header " + /*classesHeader*/
      Cr[19])) && attr(cr, "class", ur), _r ? _r.p && (!mr || Ar[1] & /*$$scope*/
      4) && update_slot_base(
        _r,
        Tr,
        Cr,
        /*$$scope*/
        Cr[33],
        mr ? get_slot_changes(
          Tr,
          /*$$scope*/
          Cr[33],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Cr[33]
        ),
        null
      ) : Er && Er.p && (!mr || Ar[0] & /*stepTerm*/
      4) && Er.p(Cr, mr ? Ar : [-1, -1]), (!mr || Ar[0] & /*classesContent*/
      262144 && hr !== (hr = "step-content " + /*classesContent*/
      Cr[18])) && attr(dr, "class", hr), /*$state*/
      Cr[21].total > 1 ? xr ? (xr.p(Cr, Ar), Ar[0] & /*$state*/
      2097152 && transition_in(xr, 1)) : (xr = create_if_block_1$8(Cr), xr.c(), transition_in(xr, 1), xr.m(ar, null)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), (!mr || Ar[0] & /*classesBase*/
      1048576 && vr !== (vr = "step " + /*classesBase*/
      Cr[20])) && attr(ar, "class", vr);
    },
    i(Cr) {
      mr || (transition_in(kr, Cr), transition_in(Er, Cr), transition_in(xr), mr = !0);
    },
    o(Cr) {
      transition_out(kr, Cr), transition_out(Er, Cr), transition_out(xr), mr = !1;
    },
    d(Cr) {
      Cr && detach(ar), kr && kr.d(Cr), Er && Er.d(Cr), xr && xr.d();
    }
  };
}
function fallback_block_1(lr) {
  let ar, cr, ur = (
    /*stepIndex*/
    lr[22] + 1 + ""
  ), fr;
  return {
    c() {
      ar = text$3(
        /*stepTerm*/
        lr[2]
      ), cr = space(), fr = text$3(ur);
    },
    m(dr, hr) {
      insert(dr, ar, hr), insert(dr, cr, hr), insert(dr, fr, hr);
    },
    p(dr, hr) {
      hr[0] & /*stepTerm*/
      4 && set_data(
        ar,
        /*stepTerm*/
        dr[2]
      );
    },
    d(dr) {
      dr && (detach(ar), detach(cr), detach(fr));
    }
  };
}
function fallback_block$1(lr) {
  let ar, cr, ur, fr = (
    /*stepIndex*/
    lr[22] + 1 + ""
  ), dr, hr;
  return {
    c() {
      ar = text$3("("), cr = text$3(
        /*stepTerm*/
        lr[2]
      ), ur = space(), dr = text$3(fr), hr = text$3(" Content)");
    },
    m(gr, vr) {
      insert(gr, ar, vr), insert(gr, cr, vr), insert(gr, ur, vr), insert(gr, dr, vr), insert(gr, hr, vr);
    },
    p(gr, vr) {
      vr[0] & /*stepTerm*/
      4 && set_data(
        cr,
        /*stepTerm*/
        gr[2]
      );
    },
    d(gr) {
      gr && (detach(ar), detach(cr), detach(ur), detach(dr), detach(hr));
    }
  };
}
function create_if_block_1$8(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  const mr = [create_if_block_4$3, create_else_block_1$5], br = [];
  function yr(Er, xr) {
    return (
      /*stepIndex*/
      Er[22] === 0 && /*$$slots*/
      Er[26].navigation ? 0 : 1
    );
  }
  cr = yr(lr), ur = br[cr] = mr[cr](lr);
  function kr(Er, xr) {
    return (
      /*stepIndex*/
      Er[22] < /*$state*/
      Er[21].total - 1 ? create_if_block_2$6 : create_else_block$8
    );
  }
  let Tr = kr(lr), _r = Tr(lr);
  return {
    c() {
      ar = element("div"), ur.c(), fr = space(), _r.c(), attr(ar, "class", dr = "step-navigation " + /*classesNavigation*/
      lr[17]);
    },
    m(Er, xr) {
      insert(Er, ar, xr), br[cr].m(ar, null), append(ar, fr), _r.m(ar, null), vr = !0;
    },
    p(Er, xr) {
      lr = Er;
      let Cr = cr;
      cr = yr(lr), cr === Cr ? br[cr].p(lr, xr) : (group_outros(), transition_out(br[Cr], 1, 1, () => {
        br[Cr] = null;
      }), check_outros(), ur = br[cr], ur ? ur.p(lr, xr) : (ur = br[cr] = mr[cr](lr), ur.c()), transition_in(ur, 1), ur.m(ar, fr)), Tr === (Tr = kr(lr)) && _r ? _r.p(lr, xr) : (_r.d(1), _r = Tr(lr), _r && (_r.c(), _r.m(ar, null))), (!vr || xr[0] & /*classesNavigation*/
      131072 && dr !== (dr = "step-navigation " + /*classesNavigation*/
      lr[17])) && attr(ar, "class", dr);
    },
    i(Er) {
      vr || (transition_in(ur), Er && add_render_callback(() => {
        vr && (gr && gr.end(1), hr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[13]
          ),
          params: (
            /*transitionInParams*/
            lr[14]
          ),
          enabled: (
            /*transitions*/
            lr[12]
          )
        }), hr.start());
      }), vr = !0);
    },
    o(Er) {
      transition_out(ur), hr && hr.invalidate(), Er && (gr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[15]
        ),
        params: (
          /*transitionOutParams*/
          lr[16]
        ),
        enabled: (
          /*transitions*/
          lr[12]
        )
      })), vr = !1;
    },
    d(Er) {
      Er && detach(ar), br[cr].d(), _r.d(), Er && gr && gr.end();
    }
  };
}
function create_else_block_1$5(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonBackType*/
        lr[4]
      ), attr(ar, "class", cr = "btn " + /*buttonBack*/
      lr[3]), ar.disabled = ur = /*$state*/
      lr[21].current === 0;
    },
    m(hr, gr) {
      insert(hr, ar, gr), ar.innerHTML = /*buttonBackLabel*/
      lr[5], fr || (dr = listen(
        ar,
        "click",
        /*onBack*/
        lr[24]
      ), fr = !0);
    },
    p(hr, gr) {
      gr[0] & /*buttonBackLabel*/
      32 && (ar.innerHTML = /*buttonBackLabel*/
      hr[5]), gr[0] & /*buttonBackType*/
      16 && attr(
        ar,
        "type",
        /*buttonBackType*/
        hr[4]
      ), gr[0] & /*buttonBack*/
      8 && cr !== (cr = "btn " + /*buttonBack*/
      hr[3]) && attr(ar, "class", cr), gr[0] & /*$state*/
      2097152 && ur !== (ur = /*$state*/
      hr[21].current === 0) && (ar.disabled = ur);
    },
    i: noop$1,
    o: noop$1,
    d(hr) {
      hr && detach(ar), fr = !1, dr();
    }
  };
}
function create_if_block_4$3(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[34].navigation
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[33],
    get_navigation_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "step-navigation-slot");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr[1] & /*$$scope*/
      4) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[33],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[33],
          hr,
          get_navigation_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[33]
        ),
        get_navigation_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_else_block$8(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonCompleteType*/
        lr[10]
      ), attr(ar, "class", cr = "btn " + /*buttonComplete*/
      lr[9]), ar.disabled = /*locked*/
      lr[0];
    },
    m(dr, hr) {
      insert(dr, ar, hr), ar.innerHTML = /*buttonCompleteLabel*/
      lr[11], ur || (fr = listen(
        ar,
        "click",
        /*onComplete*/
        lr[25]
      ), ur = !0);
    },
    p(dr, hr) {
      hr[0] & /*buttonCompleteLabel*/
      2048 && (ar.innerHTML = /*buttonCompleteLabel*/
      dr[11]), hr[0] & /*buttonCompleteType*/
      1024 && attr(
        ar,
        "type",
        /*buttonCompleteType*/
        dr[10]
      ), hr[0] & /*buttonComplete*/
      512 && cr !== (cr = "btn " + /*buttonComplete*/
      dr[9]) && attr(ar, "class", cr), hr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      dr[0]);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_2$6(lr) {
  let ar, cr, ur, fr, dr, hr, gr = (
    /*locked*/
    lr[0] && create_if_block_3$5()
  );
  return {
    c() {
      ar = element("button"), gr && gr.c(), cr = space(), ur = element("span"), attr(
        ar,
        "type",
        /*buttonNextType*/
        lr[7]
      ), attr(ar, "class", fr = "btn " + /*buttonNext*/
      lr[6]), ar.disabled = /*locked*/
      lr[0];
    },
    m(vr, mr) {
      insert(vr, ar, mr), gr && gr.m(ar, null), append(ar, cr), append(ar, ur), ur.innerHTML = /*buttonNextLabel*/
      lr[8], dr || (hr = listen(
        ar,
        "click",
        /*onNext*/
        lr[23]
      ), dr = !0);
    },
    p(vr, mr) {
      /*locked*/
      vr[0] ? gr || (gr = create_if_block_3$5(), gr.c(), gr.m(ar, cr)) : gr && (gr.d(1), gr = null), mr[0] & /*buttonNextLabel*/
      256 && (ur.innerHTML = /*buttonNextLabel*/
      vr[8]), mr[0] & /*buttonNextType*/
      128 && attr(
        ar,
        "type",
        /*buttonNextType*/
        vr[7]
      ), mr[0] & /*buttonNext*/
      64 && fr !== (fr = "btn " + /*buttonNext*/
      vr[6]) && attr(ar, "class", fr), mr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      vr[0]);
    },
    d(vr) {
      vr && detach(ar), gr && gr.d(), dr = !1, hr();
    }
  };
}
function create_if_block_3$5(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z"), attr(ar, "class", "w-3 aspect-square fill-current"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$L(lr) {
  let ar, cr, ur = (
    /*stepIndex*/
    lr[22] === /*$state*/
    lr[21].current && create_if_block$h(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*stepIndex*/
      fr[22] === /*$state*/
      fr[21].current ? ur ? (ur.p(fr, dr), dr[0] & /*$state*/
      2097152 && transition_in(ur, 1)) : (ur = create_if_block$h(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cBase$6 = "space-y-4", cHeader$1 = "text-2xl font-bold", cContent = "space-y-4", cNavigation = "flex";
function instance$q(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr = noop$1, mr = () => (vr(), vr = subscribe(Cr, (yi) => cr(21, gr = yi)), Cr);
  lr.$$.on_destroy.push(() => vr());
  let { $$slots: br = {}, $$scope: yr } = ar;
  const kr = compute_slots(br);
  let { locked: Tr = !1 } = ar, { regionHeader: _r = "" } = ar, { regionContent: Er = "" } = ar, { regionNavigation: xr = "" } = ar, { state: Cr = getContext("state") } = ar;
  mr();
  let { dispatchParent: Ar = getContext("dispatchParent") } = ar, { stepTerm: Lr = getContext("stepTerm") } = ar, { gap: Dr = getContext("gap") } = ar, { justify: Nr = getContext("justify") } = ar, { buttonBack: Hr = getContext("buttonBack") } = ar, { buttonBackType: $r = getContext("buttonBackType") } = ar, { buttonBackLabel: Wr = getContext("buttonBackLabel") } = ar, { buttonNext: Zr = getContext("buttonNext") } = ar, { buttonNextType: oi = getContext("buttonNextType") } = ar, { buttonNextLabel: Jr = getContext("buttonNextLabel") } = ar, { buttonComplete: Yr = getContext("buttonComplete") } = ar, { buttonCompleteType: li = getContext("buttonCompleteType") } = ar, { buttonCompleteLabel: Si = getContext("buttonCompleteLabel") } = ar, { transitions: ci = getContext("transitions") } = ar, { transitionIn: hi = getContext("transitionIn") } = ar, { transitionInParams: Ei = getContext("transitionInParams") } = ar, { transitionOut: di = getContext("transitionOut") } = ar, { transitionOutParams: gi = getContext("transitionOutParams") } = ar;
  const Li = gr.total;
  set_store_value(Cr, gr.total++, gr);
  async function ui() {
    await new Promise((yi) => setTimeout(yi)), !Tr && (set_store_value(Cr, gr.current++, gr), Ar("next", { step: Li, state: gr }), Ar("step", { step: Li, state: gr }));
  }
  function wi() {
    set_store_value(Cr, gr.current--, gr), Ar("back", { step: Li, state: gr }), Ar("step", { step: Li, state: gr });
  }
  function Ui() {
    Ar("complete", { step: Li, state: gr });
  }
  return onDestroy(() => {
    set_store_value(Cr, gr.total--, gr);
  }), lr.$$set = (yi) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(yi))), "locked" in yi && cr(0, Tr = yi.locked), "regionHeader" in yi && cr(27, _r = yi.regionHeader), "regionContent" in yi && cr(28, Er = yi.regionContent), "regionNavigation" in yi && cr(29, xr = yi.regionNavigation), "state" in yi && mr(cr(1, Cr = yi.state)), "dispatchParent" in yi && cr(30, Ar = yi.dispatchParent), "stepTerm" in yi && cr(2, Lr = yi.stepTerm), "gap" in yi && cr(31, Dr = yi.gap), "justify" in yi && cr(32, Nr = yi.justify), "buttonBack" in yi && cr(3, Hr = yi.buttonBack), "buttonBackType" in yi && cr(4, $r = yi.buttonBackType), "buttonBackLabel" in yi && cr(5, Wr = yi.buttonBackLabel), "buttonNext" in yi && cr(6, Zr = yi.buttonNext), "buttonNextType" in yi && cr(7, oi = yi.buttonNextType), "buttonNextLabel" in yi && cr(8, Jr = yi.buttonNextLabel), "buttonComplete" in yi && cr(9, Yr = yi.buttonComplete), "buttonCompleteType" in yi && cr(10, li = yi.buttonCompleteType), "buttonCompleteLabel" in yi && cr(11, Si = yi.buttonCompleteLabel), "transitions" in yi && cr(12, ci = yi.transitions), "transitionIn" in yi && cr(13, hi = yi.transitionIn), "transitionInParams" in yi && cr(14, Ei = yi.transitionInParams), "transitionOut" in yi && cr(15, di = yi.transitionOut), "transitionOutParams" in yi && cr(16, gi = yi.transitionOutParams), "$$scope" in yi && cr(33, yr = yi.$$scope);
  }, lr.$$.update = () => {
    var yi;
    cr(20, ur = `${cBase$6} ${(yi = ar.class) != null ? yi : ""}`), lr.$$.dirty[0] & /*regionHeader*/
    134217728 && cr(19, fr = `${cHeader$1} ${_r}`), lr.$$.dirty[0] & /*regionContent*/
    268435456 && cr(18, dr = `${cContent} ${Er}`), lr.$$.dirty[0] & /*regionNavigation*/
    536870912 | lr.$$.dirty[1] & /*justify, gap*/
    3 && cr(17, hr = `${cNavigation} ${Nr} ${Dr} ${xr}`);
  }, ar = exclude_internal_props(ar), [
    Tr,
    Cr,
    Lr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    hr,
    dr,
    fr,
    ur,
    gr,
    Li,
    ui,
    wi,
    Ui,
    kr,
    _r,
    Er,
    xr,
    Ar,
    Dr,
    Nr,
    yr,
    br
  ];
}
let Step$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$q,
      create_fragment$L,
      safe_not_equal,
      {
        locked: 0,
        regionHeader: 27,
        regionContent: 28,
        regionNavigation: 29,
        state: 1,
        dispatchParent: 30,
        stepTerm: 2,
        gap: 31,
        justify: 32,
        buttonBack: 3,
        buttonBackType: 4,
        buttonBackLabel: 5,
        buttonNext: 6,
        buttonNextType: 7,
        buttonNextLabel: 8,
        buttonComplete: 9,
        buttonCompleteType: 10,
        buttonCompleteLabel: 11,
        transitions: 12,
        transitionIn: 13,
        transitionInParams: 14,
        transitionOut: 15,
        transitionOutParams: 16
      },
      null,
      [-1, -1]
    );
  }
  get locked() {
    return this.$$.ctx[0];
  }
  set locked(ar) {
    this.$$set({ locked: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[27];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[28];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get regionNavigation() {
    return this.$$.ctx[29];
  }
  set regionNavigation(ar) {
    this.$$set({ regionNavigation: ar }), flush();
  }
  get state() {
    return this.$$.ctx[1];
  }
  set state(ar) {
    this.$$set({ state: ar }), flush();
  }
  get dispatchParent() {
    return this.$$.ctx[30];
  }
  set dispatchParent(ar) {
    this.$$set({ dispatchParent: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[2];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[31];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[32];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[3];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[4];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[5];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[6];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[7];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[8];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[9];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[10];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[11];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[12];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[13];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[14];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[15];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[16];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
};
create_custom_element(Step$1, { locked: { type: "Boolean" }, regionHeader: {}, regionContent: {}, regionNavigation: {}, state: {}, dispatchParent: {}, stepTerm: {}, gap: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["header", "default", "navigation"], [], !0);
function tableA11y(lr) {
  const ar = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"], cr = (ur) => {
    if (ar.includes(ur.code))
      switch (ur.preventDefault(), ur.code) {
        case "ArrowUp":
          a11ySetActiveCell(lr, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(lr, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(lr, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(lr, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(lr, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(lr, "last");
          break;
      }
  };
  return lr.addEventListener("keydown", cr), {
    destroy() {
      lr.removeEventListener("keydown", cr);
    }
  };
}
function a11ySetActiveCell(lr, ar, cr) {
  const ur = document.activeElement;
  if (!ur || !ur.parentElement || !ur.parentElement.ariaRowIndex || !ur.ariaColIndex)
    return;
  const fr = parseInt(ur.parentElement.ariaRowIndex), dr = parseInt(ur.ariaColIndex), hr = lr.querySelector(`[aria-rowindex="${fr + cr}"]`);
  if (hr !== null) {
    const gr = hr.querySelector(`[aria-colindex="${dr + ar}"]`);
    gr !== null && gr.focus();
  }
}
function a11yGetTargetElem(lr) {
  const ar = document.activeElement;
  if (!ar || !ar.parentElement || !ar.parentElement.ariaRowIndex)
    return null;
  const cr = parseInt(ar.parentElement.ariaRowIndex);
  return lr.querySelector(`[aria-rowindex="${cr}"]`);
}
function a11yJumpToOuterColumn(lr, ar = "first") {
  const cr = a11yGetTargetElem(lr);
  if (cr === null)
    return;
  const ur = cr.children.length, fr = ar === "first" ? 1 : ur, dr = cr.querySelector(`[aria-colindex="${fr}"]`);
  dr !== null && dr.focus();
}
function get_each_context$5(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur;
}
function get_each_context_1$2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[22] = ar[cr], ur[24] = cr, ur;
}
function get_each_context_2$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur[26] = cr, ur;
}
function get_each_context_3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[27] = ar[cr], ur;
}
function create_each_block_3(lr) {
  let ar, cr = (
    /*heading*/
    lr[27] + ""
  );
  return {
    c() {
      ar = element("th"), attr(
        ar,
        "class",
        /*regionHeadCell*/
        lr[3]
      ), attr(ar, "role", "columnheader");
    },
    m(ur, fr) {
      insert(ur, ar, fr), ar.innerHTML = cr;
    },
    p(ur, fr) {
      fr & /*source*/
      1 && cr !== (cr = /*heading*/
      ur[27] + "") && (ar.innerHTML = cr), fr & /*regionHeadCell*/
      8 && attr(
        ar,
        "class",
        /*regionHeadCell*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_each_block_2$1(lr) {
  let ar, cr = (Number(
    /*cell*/
    lr[19]
  ) === 0 || /*cell*/
  lr[19] ? (
    /*cell*/
    lr[19]
  ) : "-") + "", ur;
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionCell*/
        lr[5]
      ), attr(ar, "role", "gridcell"), attr(
        ar,
        "aria-colindex",
        /*cellIndex*/
        lr[26] + 1
      ), attr(ar, "tabindex", ur = /*cellIndex*/
      lr[26] === 0 && /*interactive*/
      lr[1] ? 0 : -1);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr & /*source*/
      1 && cr !== (cr = (Number(
        /*cell*/
        fr[19]
      ) === 0 || /*cell*/
      fr[19] ? (
        /*cell*/
        fr[19]
      ) : "-") + "") && (ar.innerHTML = cr), dr & /*regionCell*/
      32 && attr(
        ar,
        "class",
        /*regionCell*/
        fr[5]
      ), dr & /*interactive*/
      2 && ur !== (ur = /*cellIndex*/
      fr[26] === 0 && /*interactive*/
      fr[1] ? 0 : -1) && attr(ar, "tabindex", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_each_block_1$2(lr) {
  let ar, cr, ur, fr, dr = ensure_array_like(
    /*row*/
    lr[22]
  ), hr = [];
  for (let mr = 0; mr < dr.length; mr += 1)
    hr[mr] = create_each_block_2$1(get_each_context_2$1(lr, dr, mr));
  function gr(...mr) {
    return (
      /*click_handler*/
      lr[15](
        /*rowIndex*/
        lr[24],
        ...mr
      )
    );
  }
  function vr(...mr) {
    return (
      /*keydown_handler*/
      lr[16](
        /*rowIndex*/
        lr[24],
        ...mr
      )
    );
  }
  return {
    c() {
      ar = element("tr");
      for (let mr = 0; mr < hr.length; mr += 1)
        hr[mr].c();
      cr = space(), attr(
        ar,
        "aria-rowindex",
        /*rowIndex*/
        lr[24] + 1
      );
    },
    m(mr, br) {
      insert(mr, ar, br);
      for (let yr = 0; yr < hr.length; yr += 1)
        hr[yr] && hr[yr].m(ar, null);
      append(ar, cr), ur || (fr = [
        listen(ar, "click", gr),
        listen(ar, "keydown", vr)
      ], ur = !0);
    },
    p(mr, br) {
      if (lr = mr, br & /*regionCell, interactive, Number, source*/
      35) {
        dr = ensure_array_like(
          /*row*/
          lr[22]
        );
        let yr;
        for (yr = 0; yr < dr.length; yr += 1) {
          const kr = get_each_context_2$1(lr, dr, yr);
          hr[yr] ? hr[yr].p(kr, br) : (hr[yr] = create_each_block_2$1(kr), hr[yr].c(), hr[yr].m(ar, cr));
        }
        for (; yr < hr.length; yr += 1)
          hr[yr].d(1);
        hr.length = dr.length;
      }
    },
    d(mr) {
      mr && detach(ar), destroy_each(hr, mr), ur = !1, run_all(fr);
    }
  };
}
function create_if_block$g(lr) {
  let ar, cr, ur, fr = ensure_array_like(
    /*source*/
    lr[0].foot
  ), dr = [];
  for (let hr = 0; hr < fr.length; hr += 1)
    dr[hr] = create_each_block$5(get_each_context$5(lr, fr, hr));
  return {
    c() {
      ar = element("tfoot"), cr = element("tr");
      for (let hr = 0; hr < dr.length; hr += 1)
        dr[hr].c();
      attr(ar, "class", ur = "table-foot " + /*regionFoot*/
      lr[6]);
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, cr);
      for (let vr = 0; vr < dr.length; vr += 1)
        dr[vr] && dr[vr].m(cr, null);
    },
    p(hr, gr) {
      if (gr & /*regionFootCell, source*/
      129) {
        fr = ensure_array_like(
          /*source*/
          hr[0].foot
        );
        let vr;
        for (vr = 0; vr < fr.length; vr += 1) {
          const mr = get_each_context$5(hr, fr, vr);
          dr[vr] ? dr[vr].p(mr, gr) : (dr[vr] = create_each_block$5(mr), dr[vr].c(), dr[vr].m(cr, null));
        }
        for (; vr < dr.length; vr += 1)
          dr[vr].d(1);
        dr.length = fr.length;
      }
      gr & /*regionFoot*/
      64 && ur !== (ur = "table-foot " + /*regionFoot*/
      hr[6]) && attr(ar, "class", ur);
    },
    d(hr) {
      hr && detach(ar), destroy_each(dr, hr);
    }
  };
}
function create_each_block$5(lr) {
  let ar, cr = (
    /*cell*/
    lr[19] + ""
  );
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionFootCell*/
        lr[7]
      );
    },
    m(ur, fr) {
      insert(ur, ar, fr), ar.innerHTML = cr;
    },
    p(ur, fr) {
      fr & /*source*/
      1 && cr !== (cr = /*cell*/
      ur[19] + "") && (ar.innerHTML = cr), fr & /*regionFootCell*/
      128 && attr(
        ar,
        "class",
        /*regionFootCell*/
        ur[7]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$K(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r = ensure_array_like(
    /*source*/
    lr[0].head
  ), Er = [];
  for (let Lr = 0; Lr < _r.length; Lr += 1)
    Er[Lr] = create_each_block_3(get_each_context_3(lr, _r, Lr));
  let xr = ensure_array_like(
    /*source*/
    lr[0].body
  ), Cr = [];
  for (let Lr = 0; Lr < xr.length; Lr += 1)
    Cr[Lr] = create_each_block_1$2(get_each_context_1$2(lr, xr, Lr));
  let Ar = (
    /*source*/
    lr[0].foot && create_if_block$g(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("table"), ur = element("thead"), fr = element("tr");
      for (let Lr = 0; Lr < Er.length; Lr += 1)
        Er[Lr].c();
      hr = space(), gr = element("tbody");
      for (let Lr = 0; Lr < Cr.length; Lr += 1)
        Cr[Lr].c();
      mr = space(), Ar && Ar.c(), attr(ur, "class", dr = "table-head " + /*regionHead*/
      lr[2]), attr(gr, "class", vr = "table-body " + /*regionBody*/
      lr[4]), attr(
        cr,
        "class",
        /*classesTable*/
        lr[8]
      ), attr(cr, "role", br = /*interactive*/
      lr[1] ? "grid" : "table"), toggle_class(
        cr,
        "table-interactive",
        /*interactive*/
        lr[1]
      ), attr(ar, "class", yr = "table-container " + /*classesBase*/
      lr[9]);
    },
    m(Lr, Dr) {
      insert(Lr, ar, Dr), append(ar, cr), append(cr, ur), append(ur, fr);
      for (let Nr = 0; Nr < Er.length; Nr += 1)
        Er[Nr] && Er[Nr].m(fr, null);
      append(cr, hr), append(cr, gr);
      for (let Nr = 0; Nr < Cr.length; Nr += 1)
        Cr[Nr] && Cr[Nr].m(gr, null);
      append(cr, mr), Ar && Ar.m(cr, null), kr || (Tr = action_destroyer(tableA11y.call(null, cr)), kr = !0);
    },
    p(Lr, [Dr]) {
      if (Dr & /*regionHeadCell, source*/
      9) {
        _r = ensure_array_like(
          /*source*/
          Lr[0].head
        );
        let Nr;
        for (Nr = 0; Nr < _r.length; Nr += 1) {
          const Hr = get_each_context_3(Lr, _r, Nr);
          Er[Nr] ? Er[Nr].p(Hr, Dr) : (Er[Nr] = create_each_block_3(Hr), Er[Nr].c(), Er[Nr].m(fr, null));
        }
        for (; Nr < Er.length; Nr += 1)
          Er[Nr].d(1);
        Er.length = _r.length;
      }
      if (Dr & /*regionHead*/
      4 && dr !== (dr = "table-head " + /*regionHead*/
      Lr[2]) && attr(ur, "class", dr), Dr & /*onRowClick, onRowKeydown, source, regionCell, interactive, Number*/
      3107) {
        xr = ensure_array_like(
          /*source*/
          Lr[0].body
        );
        let Nr;
        for (Nr = 0; Nr < xr.length; Nr += 1) {
          const Hr = get_each_context_1$2(Lr, xr, Nr);
          Cr[Nr] ? Cr[Nr].p(Hr, Dr) : (Cr[Nr] = create_each_block_1$2(Hr), Cr[Nr].c(), Cr[Nr].m(gr, null));
        }
        for (; Nr < Cr.length; Nr += 1)
          Cr[Nr].d(1);
        Cr.length = xr.length;
      }
      Dr & /*regionBody*/
      16 && vr !== (vr = "table-body " + /*regionBody*/
      Lr[4]) && attr(gr, "class", vr), /*source*/
      Lr[0].foot ? Ar ? Ar.p(Lr, Dr) : (Ar = create_if_block$g(Lr), Ar.c(), Ar.m(cr, null)) : Ar && (Ar.d(1), Ar = null), Dr & /*classesTable*/
      256 && attr(
        cr,
        "class",
        /*classesTable*/
        Lr[8]
      ), Dr & /*interactive*/
      2 && br !== (br = /*interactive*/
      Lr[1] ? "grid" : "table") && attr(cr, "role", br), Dr & /*classesTable, interactive*/
      258 && toggle_class(
        cr,
        "table-interactive",
        /*interactive*/
        Lr[1]
      ), Dr & /*classesBase*/
      512 && yr !== (yr = "table-container " + /*classesBase*/
      Lr[9]) && attr(ar, "class", yr);
    },
    i: noop$1,
    o: noop$1,
    d(Lr) {
      Lr && detach(ar), destroy_each(Er, Lr), destroy_each(Cr, Lr), Ar && Ar.d(), kr = !1, Tr();
    }
  };
}
function instance$p(lr, ar, cr) {
  let ur, fr;
  const dr = createEventDispatcher();
  let { source: hr } = ar, { interactive: gr = !1 } = ar, { element: vr = "table" } = ar, { text: mr = "" } = ar, { color: br = "" } = ar, { regionHead: yr = "" } = ar, { regionHeadCell: kr = "" } = ar, { regionBody: Tr = "" } = ar, { regionCell: _r = "" } = ar, { regionFoot: Er = "" } = ar, { regionFootCell: xr = "" } = ar;
  function Cr(Nr, Hr) {
    if (!gr)
      return;
    Nr.preventDefault(), Nr.stopPropagation();
    const $r = hr.meta ? hr.meta[Hr] : hr.body[Hr];
    dr("selected", $r);
  }
  function Ar(Nr, Hr) {
    ["Enter", "Space"].includes(Nr.code) && Cr(Nr, Hr);
  }
  const Lr = (Nr, Hr) => {
    Cr(Hr, Nr);
  }, Dr = (Nr, Hr) => {
    Ar(Hr, Nr);
  };
  return lr.$$set = (Nr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Nr))), "source" in Nr && cr(0, hr = Nr.source), "interactive" in Nr && cr(1, gr = Nr.interactive), "element" in Nr && cr(12, vr = Nr.element), "text" in Nr && cr(13, mr = Nr.text), "color" in Nr && cr(14, br = Nr.color), "regionHead" in Nr && cr(2, yr = Nr.regionHead), "regionHeadCell" in Nr && cr(3, kr = Nr.regionHeadCell), "regionBody" in Nr && cr(4, Tr = Nr.regionBody), "regionCell" in Nr && cr(5, _r = Nr.regionCell), "regionFoot" in Nr && cr(6, Er = Nr.regionFoot), "regionFootCell" in Nr && cr(7, xr = Nr.regionFootCell);
  }, lr.$$.update = () => {
    cr(9, ur = `${ar.class || ""}`), lr.$$.dirty & /*element, text, color*/
    28672 && cr(8, fr = `${vr} ${mr} ${br}`);
  }, ar = exclude_internal_props(ar), [
    hr,
    gr,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    fr,
    ur,
    Cr,
    Ar,
    vr,
    mr,
    br,
    Lr,
    Dr
  ];
}
let Table$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$p, create_fragment$K, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 12,
      text: 13,
      color: 14,
      regionHead: 2,
      regionHeadCell: 3,
      regionBody: 4,
      regionCell: 5,
      regionFoot: 6,
      regionFootCell: 7
    });
  }
  get source() {
    return this.$$.ctx[0];
  }
  set source(ar) {
    this.$$set({ source: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[1];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get element() {
    return this.$$.ctx[12];
  }
  set element(ar) {
    this.$$set({ element: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get regionHead() {
    return this.$$.ctx[2];
  }
  set regionHead(ar) {
    this.$$set({ regionHead: ar }), flush();
  }
  get regionHeadCell() {
    return this.$$.ctx[3];
  }
  set regionHeadCell(ar) {
    this.$$set({ regionHeadCell: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[4];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionCell() {
    return this.$$.ctx[5];
  }
  set regionCell(ar) {
    this.$$set({ regionCell: ar }), flush();
  }
  get regionFoot() {
    return this.$$.ctx[6];
  }
  set regionFoot(ar) {
    this.$$set({ regionFoot: ar }), flush();
  }
  get regionFootCell() {
    return this.$$.ctx[7];
  }
  set regionFootCell(ar) {
    this.$$set({ regionFootCell: ar }), flush();
  }
};
create_custom_element(Table$2, { source: {}, interactive: { type: "Boolean" }, element: {}, text: {}, color: {}, regionHead: {}, regionHeadCell: {}, regionBody: {}, regionCell: {}, regionFoot: {}, regionFootCell: {} }, [], [], !0);
const get_panel_slot_changes = (lr) => ({}), get_panel_slot_context = (lr) => ({});
function create_if_block$f(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[17].panel
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[16],
    get_panel_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "tab-panel " + /*classesPanel*/
      lr[2]), attr(ar, "role", "tabpanel"), attr(
        ar,
        "aria-labelledby",
        /*panel*/
        lr[1]
      ), attr(ar, "tabindex", "0");
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(hr, gr) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      65536) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[16],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[16],
          gr,
          get_panel_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[16]
        ),
        get_panel_slot_context
      ), (!ur || gr & /*classesPanel*/
      4 && cr !== (cr = "tab-panel " + /*classesPanel*/
      hr[2])) && attr(ar, "class", cr), (!ur || gr & /*panel*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*panel*/
        hr[1]
      );
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr);
    }
  };
}
function create_fragment$J(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  const mr = (
    /*#slots*/
    lr[17].default
  ), br = create_slot(
    mr,
    lr,
    /*$$scope*/
    lr[16],
    null
  );
  let yr = (
    /*$$slots*/
    lr[5].panel && create_if_block$f(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), br && br.c(), fr = space(), yr && yr.c(), attr(cr, "class", ur = "tab-list " + /*classesList*/
      lr[3]), attr(cr, "role", "tablist"), attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(ar, "class", dr = "tab-group " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "tab-group");
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), append(ar, cr), br && br.m(cr, null), append(ar, fr), yr && yr.m(ar, null), hr = !0, gr || (vr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[20]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[21]
        )
      ], gr = !0);
    },
    p(kr, [Tr]) {
      br && br.p && (!hr || Tr & /*$$scope*/
      65536) && update_slot_base(
        br,
        mr,
        kr,
        /*$$scope*/
        kr[16],
        hr ? get_slot_changes(
          mr,
          /*$$scope*/
          kr[16],
          Tr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          kr[16]
        ),
        null
      ), (!hr || Tr & /*classesList*/
      8 && ur !== (ur = "tab-list " + /*classesList*/
      kr[3])) && attr(cr, "class", ur), (!hr || Tr & /*labelledby*/
      1) && attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        kr[0]
      ), /*$$slots*/
      kr[5].panel ? yr ? (yr.p(kr, Tr), Tr & /*$$slots*/
      32 && transition_in(yr, 1)) : (yr = create_if_block$f(kr), yr.c(), transition_in(yr, 1), yr.m(ar, null)) : yr && (group_outros(), transition_out(yr, 1, 1, () => {
        yr = null;
      }), check_outros()), (!hr || Tr & /*classesBase*/
      16 && dr !== (dr = "tab-group " + /*classesBase*/
      kr[4])) && attr(ar, "class", dr);
    },
    i(kr) {
      hr || (transition_in(br, kr), transition_in(yr), hr = !0);
    },
    o(kr) {
      transition_out(br, kr), transition_out(yr), hr = !1;
    },
    d(kr) {
      kr && detach(ar), br && br.d(kr), yr && yr.d(), gr = !1, run_all(vr);
    }
  };
}
const cBase$5 = "space-y-4", cList$1 = "flex overflow-x-auto hide-scrollbar", cPanel = "";
function instance$o(lr, ar, cr) {
  let ur, fr, dr, { $$slots: hr = {}, $$scope: gr } = ar;
  const vr = compute_slots(hr);
  let { justify: mr = "justify-start" } = ar, { border: br = "border-b border-surface-400-500-token" } = ar, { active: yr = "border-b-2 border-surface-900-50-token" } = ar, { hover: kr = "hover:variant-soft" } = ar, { flex: Tr = "flex-none" } = ar, { padding: _r = "px-4 py-2" } = ar, { rounded: Er = "rounded-tl-container-token rounded-tr-container-token" } = ar, { spacing: xr = "space-y-1" } = ar, { regionList: Cr = "" } = ar, { regionPanel: Ar = "" } = ar, { labelledby: Lr = "" } = ar, { panel: Dr = "" } = ar;
  setContext("active", yr), setContext("hover", kr), setContext("flex", Tr), setContext("padding", _r), setContext("rounded", Er), setContext("spacing", xr);
  function Nr(Zr) {
    bubble.call(this, lr, Zr);
  }
  function Hr(Zr) {
    bubble.call(this, lr, Zr);
  }
  function $r(Zr) {
    bubble.call(this, lr, Zr);
  }
  function Wr(Zr) {
    bubble.call(this, lr, Zr);
  }
  return lr.$$set = (Zr) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Zr))), "justify" in Zr && cr(6, mr = Zr.justify), "border" in Zr && cr(7, br = Zr.border), "active" in Zr && cr(8, yr = Zr.active), "hover" in Zr && cr(9, kr = Zr.hover), "flex" in Zr && cr(10, Tr = Zr.flex), "padding" in Zr && cr(11, _r = Zr.padding), "rounded" in Zr && cr(12, Er = Zr.rounded), "spacing" in Zr && cr(13, xr = Zr.spacing), "regionList" in Zr && cr(14, Cr = Zr.regionList), "regionPanel" in Zr && cr(15, Ar = Zr.regionPanel), "labelledby" in Zr && cr(0, Lr = Zr.labelledby), "panel" in Zr && cr(1, Dr = Zr.panel), "$$scope" in Zr && cr(16, gr = Zr.$$scope);
  }, lr.$$.update = () => {
    var Zr;
    cr(4, ur = `${cBase$5} ${(Zr = ar.class) != null ? Zr : ""}`), lr.$$.dirty & /*justify, border, regionList*/
    16576 && cr(3, fr = `${cList$1} ${mr} ${br} ${Cr}`), lr.$$.dirty & /*regionPanel*/
    32768 && cr(2, dr = `${cPanel} ${Ar}`);
  }, ar = exclude_internal_props(ar), [
    Lr,
    Dr,
    dr,
    fr,
    ur,
    vr,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    gr,
    hr,
    Nr,
    Hr,
    $r,
    Wr
  ];
}
class TabGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$o, create_fragment$J, safe_not_equal, {
      justify: 6,
      border: 7,
      active: 8,
      hover: 9,
      flex: 10,
      padding: 11,
      rounded: 12,
      spacing: 13,
      regionList: 14,
      regionPanel: 15,
      labelledby: 0,
      panel: 1
    });
  }
  get justify() {
    return this.$$.ctx[6];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get border() {
    return this.$$.ctx[7];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[10];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[14];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[15];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get panel() {
    return this.$$.ctx[1];
  }
  set panel(ar) {
    this.$$set({ panel: ar }), flush();
  }
}
create_custom_element(TabGroup, { justify: {}, border: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {}, regionList: {}, regionPanel: {}, labelledby: {}, panel: {} }, ["default", "panel"], [], !0);
const get_lead_slot_changes$2 = (lr) => ({}), get_lead_slot_context$2 = (lr) => ({});
function create_if_block$e(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[22].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[21],
    get_lead_slot_context$2
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tab-lead");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr[0] & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[21],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[21],
          hr,
          get_lead_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[21]
        ),
        get_lead_slot_context$2
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$I(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[11](),
    { tabindex: "-1" }
  ], Cr = {};
  for (let Nr = 0; Nr < xr.length; Nr += 1)
    Cr = assign$1(Cr, xr[Nr]);
  let Ar = (
    /*$$slots*/
    lr[12].lead && create_if_block$e(lr)
  );
  const Lr = (
    /*#slots*/
    lr[22].default
  ), Dr = create_slot(
    Lr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return Tr = init_binding_group(
    /*$$binding_groups*/
    lr[30][0]
  ), {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), fr = element("input"), dr = space(), hr = element("div"), Ar && Ar.c(), gr = space(), vr = element("div"), Dr && Dr.c(), set_attributes(fr, Cr), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", "tab-label"), attr(hr, "class", mr = "tab-interface " + /*classesInterface*/
      lr[8]), attr(cr, "class", br = "tab " + /*classesTab*/
      lr[7]), attr(cr, "data-testid", "tab"), attr(cr, "role", "tab"), attr(
        cr,
        "aria-controls",
        /*controls*/
        lr[4]
      ), attr(
        cr,
        "aria-selected",
        /*selected*/
        lr[5]
      ), attr(cr, "tabindex", yr = /*selected*/
      lr[5] ? 0 : -1), attr(
        ar,
        "class",
        /*classesBase*/
        lr[9]
      ), attr(
        ar,
        "title",
        /*title*/
        lr[3]
      ), Tr.p(fr);
    },
    m(Nr, Hr) {
      insert(Nr, ar, Hr), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[28](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), append(cr, hr), Ar && Ar.m(hr, null), append(hr, gr), append(hr, vr), Dr && Dr.m(vr, null), kr = !0, _r || (Er = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[29]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[26]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[27]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[23]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[25]
        )
      ], _r = !0);
    },
    p(Nr, Hr) {
      set_attributes(fr, Cr = get_spread_update(xr, [
        { type: "radio" },
        (!kr || Hr[0] & /*name*/
        2) && { name: (
          /*name*/
          Nr[1]
        ) },
        (!kr || Hr[0] & /*value*/
        4) && { __value: (
          /*value*/
          Nr[2]
        ) },
        /*prunedRestProps*/
        Nr[11](),
        { tabindex: "-1" }
      ])), Hr[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      Nr[0]), /*$$slots*/
      Nr[12].lead ? Ar ? (Ar.p(Nr, Hr), Hr[0] & /*$$slots*/
      4096 && transition_in(Ar, 1)) : (Ar = create_if_block$e(Nr), Ar.c(), transition_in(Ar, 1), Ar.m(hr, gr)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), Dr && Dr.p && (!kr || Hr[0] & /*$$scope*/
      2097152) && update_slot_base(
        Dr,
        Lr,
        Nr,
        /*$$scope*/
        Nr[21],
        kr ? get_slot_changes(
          Lr,
          /*$$scope*/
          Nr[21],
          Hr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Nr[21]
        ),
        null
      ), (!kr || Hr[0] & /*classesInterface*/
      256 && mr !== (mr = "tab-interface " + /*classesInterface*/
      Nr[8])) && attr(hr, "class", mr), (!kr || Hr[0] & /*classesTab*/
      128 && br !== (br = "tab " + /*classesTab*/
      Nr[7])) && attr(cr, "class", br), (!kr || Hr[0] & /*controls*/
      16) && attr(
        cr,
        "aria-controls",
        /*controls*/
        Nr[4]
      ), (!kr || Hr[0] & /*selected*/
      32) && attr(
        cr,
        "aria-selected",
        /*selected*/
        Nr[5]
      ), (!kr || Hr[0] & /*selected*/
      32 && yr !== (yr = /*selected*/
      Nr[5] ? 0 : -1)) && attr(cr, "tabindex", yr), (!kr || Hr[0] & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Nr[9]
      ), (!kr || Hr[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        Nr[3]
      );
    },
    i(Nr) {
      kr || (transition_in(Ar), transition_in(Dr, Nr), kr = !0);
    },
    o(Nr) {
      transition_out(Ar), transition_out(Dr, Nr), kr = !1;
    },
    d(Nr) {
      Nr && detach(ar), lr[28](null), Ar && Ar.d(), Dr && Dr.d(Nr), Tr.r(), _r = !1, run_all(Er);
    }
  };
}
const cBase$4 = "text-center cursor-pointer transition-colors duration-100", cInterface$1 = "";
function instance$n(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "controls",
    "regionTab",
    "active",
    "hover",
    "flex",
    "padding",
    "rounded",
    "spacing"
  ];
  let mr = compute_rest_props(ar, vr), { $$slots: br = {}, $$scope: yr } = ar;
  const kr = compute_slots(br);
  let { group: Tr } = ar, { name: _r } = ar, { value: Er } = ar, { title: xr = "" } = ar, { controls: Cr = "" } = ar, { regionTab: Ar = "" } = ar, { active: Lr = getContext("active") } = ar, { hover: Dr = getContext("hover") } = ar, { flex: Nr = getContext("flex") } = ar, { padding: Hr = getContext("padding") } = ar, { rounded: $r = getContext("rounded") } = ar, { spacing: Wr = getContext("spacing") } = ar, Zr;
  function oi(Li) {
    if (["Enter", "Space"].includes(Li.code))
      Li.preventDefault(), Zr.click();
    else if (Li.code === "ArrowRight") {
      const ui = Zr.closest(".tab-list");
      if (!ui)
        return;
      const wi = Array.from(ui.querySelectorAll(".tab")), Ui = Zr.closest(".tab");
      if (!Ui)
        return;
      const yi = wi.indexOf(Ui), Vi = yi + 1 >= wi.length ? 0 : yi + 1, Oi = wi[Vi], Mi = Oi == null ? void 0 : Oi.querySelector("input");
      Oi && Mi && (Mi.click(), Oi.focus());
    } else if (Li.code === "ArrowLeft") {
      const ui = Zr.closest(".tab-list");
      if (!ui)
        return;
      const wi = Array.from(ui.querySelectorAll(".tab")), Ui = Zr.closest(".tab");
      if (!Ui)
        return;
      const yi = wi.indexOf(Ui), Vi = yi - 1 < 0 ? wi.length - 1 : yi - 1, Oi = wi[Vi], Mi = Oi == null ? void 0 : Oi.querySelector("input");
      Oi && Mi && (Mi.click(), Oi.focus());
    }
  }
  function Jr() {
    return delete mr.class, mr;
  }
  const Yr = [[]];
  function li(Li) {
    bubble.call(this, lr, Li);
  }
  function Si(Li) {
    bubble.call(this, lr, Li);
  }
  function ci(Li) {
    bubble.call(this, lr, Li);
  }
  function hi(Li) {
    bubble.call(this, lr, Li);
  }
  function Ei(Li) {
    bubble.call(this, lr, Li);
  }
  function di(Li) {
    binding_callbacks[Li ? "unshift" : "push"](() => {
      Zr = Li, cr(6, Zr);
    });
  }
  function gi() {
    Tr = this.__value, cr(0, Tr);
  }
  return lr.$$set = (Li) => {
    cr(32, ar = assign$1(assign$1({}, ar), exclude_internal_props(Li))), cr(31, mr = compute_rest_props(ar, vr)), "group" in Li && cr(0, Tr = Li.group), "name" in Li && cr(1, _r = Li.name), "value" in Li && cr(2, Er = Li.value), "title" in Li && cr(3, xr = Li.title), "controls" in Li && cr(4, Cr = Li.controls), "regionTab" in Li && cr(13, Ar = Li.regionTab), "active" in Li && cr(14, Lr = Li.active), "hover" in Li && cr(15, Dr = Li.hover), "flex" in Li && cr(16, Nr = Li.flex), "padding" in Li && cr(17, Hr = Li.padding), "rounded" in Li && cr(18, $r = Li.rounded), "spacing" in Li && cr(19, Wr = Li.spacing), "$$scope" in Li && cr(21, yr = Li.$$scope);
  }, lr.$$.update = () => {
    var Li;
    lr.$$.dirty[0] & /*value, group*/
    5 && cr(5, ur = Er === Tr), lr.$$.dirty[0] & /*selected, active, hover*/
    49184 && cr(20, fr = ur ? Lr : Dr), cr(9, dr = `${cBase$4} ${Nr} ${Hr} ${$r} ${fr} ${(Li = ar.class) != null ? Li : ""}`), lr.$$.dirty[0] & /*spacing*/
    524288 && cr(8, hr = `${cInterface$1} ${Wr}`), lr.$$.dirty[0] & /*regionTab*/
    8192 && cr(7, gr = `${Ar}`);
  }, ar = exclude_internal_props(ar), [
    Tr,
    _r,
    Er,
    xr,
    Cr,
    ur,
    Zr,
    gr,
    hr,
    dr,
    oi,
    Jr,
    kr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    fr,
    yr,
    br,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    gi,
    Yr
  ];
}
let Tab$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$n,
      create_fragment$I,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        controls: 4,
        regionTab: 13,
        active: 14,
        hover: 15,
        flex: 16,
        padding: 17,
        rounded: 18,
        spacing: 19
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[4];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get regionTab() {
    return this.$$.ctx[13];
  }
  set regionTab(ar) {
    this.$$set({ regionTab: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[16];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[18];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[19];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
};
create_custom_element(Tab$1, { group: {}, name: {}, value: {}, title: {}, controls: {}, regionTab: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$1 = (lr) => ({}), get_lead_slot_context$1 = (lr) => ({});
function create_if_block$d(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    get_lead_slot_context$1
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tab-lead");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          hr,
          get_lead_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        get_lead_slot_context$1
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$H(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr = (
    /*$$slots*/
    lr[5].lead && create_if_block$d(lr)
  );
  const kr = (
    /*#slots*/
    lr[15].default
  ), Tr = create_slot(
    kr,
    lr,
    /*$$scope*/
    lr[14],
    null
  );
  let _r = [
    {
      class: hr = "tab-anchor " + /*classesBase*/
      lr[2]
    },
    {
      href: gr = /*$$props*/
      lr[4].href
    },
    /*prunedRestProps*/
    lr[3](),
    { "aria-controls": (
      /*controls*/
      lr[0]
    ) },
    { "data-testid": "tab-anchor" }
  ], Er = {};
  for (let xr = 0; xr < _r.length; xr += 1)
    Er = assign$1(Er, _r[xr]);
  return {
    c() {
      ar = element("a"), cr = element("div"), yr && yr.c(), ur = space(), fr = element("div"), Tr && Tr.c(), attr(fr, "class", "tab-label"), attr(cr, "class", dr = "tab-interface " + /*classesInterface*/
      lr[1]), set_attributes(ar, Er);
    },
    m(xr, Cr) {
      insert(xr, ar, Cr), append(ar, cr), yr && yr.m(cr, null), append(cr, ur), append(cr, fr), Tr && Tr.m(fr, null), vr = !0, mr || (br = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[16]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[19]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[20]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[21]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[22]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[23]
        )
      ], mr = !0);
    },
    p(xr, [Cr]) {
      /*$$slots*/
      xr[5].lead ? yr ? (yr.p(xr, Cr), Cr & /*$$slots*/
      32 && transition_in(yr, 1)) : (yr = create_if_block$d(xr), yr.c(), transition_in(yr, 1), yr.m(cr, ur)) : yr && (group_outros(), transition_out(yr, 1, 1, () => {
        yr = null;
      }), check_outros()), Tr && Tr.p && (!vr || Cr & /*$$scope*/
      16384) && update_slot_base(
        Tr,
        kr,
        xr,
        /*$$scope*/
        xr[14],
        vr ? get_slot_changes(
          kr,
          /*$$scope*/
          xr[14],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          xr[14]
        ),
        null
      ), (!vr || Cr & /*classesInterface*/
      2 && dr !== (dr = "tab-interface " + /*classesInterface*/
      xr[1])) && attr(cr, "class", dr), set_attributes(ar, Er = get_spread_update(_r, [
        (!vr || Cr & /*classesBase*/
        4 && hr !== (hr = "tab-anchor " + /*classesBase*/
        xr[2])) && { class: hr },
        (!vr || Cr & /*$$props*/
        16 && gr !== (gr = /*$$props*/
        xr[4].href)) && { href: gr },
        /*prunedRestProps*/
        xr[3](),
        (!vr || Cr & /*controls*/
        1) && { "aria-controls": (
          /*controls*/
          xr[0]
        ) },
        { "data-testid": "tab-anchor" }
      ]));
    },
    i(xr) {
      vr || (transition_in(yr), transition_in(Tr, xr), vr = !0);
    },
    o(xr) {
      transition_out(yr), transition_out(Tr, xr), vr = !1;
    },
    d(xr) {
      xr && detach(ar), yr && yr.d(), Tr && Tr.d(xr), mr = !1, run_all(br);
    }
  };
}
const cBase$3 = "text-center cursor-pointer transition-colors duration-100", cInterface = "";
function instance$m(lr, ar, cr) {
  let ur, fr, dr;
  const hr = ["selected", "controls", "active", "hover", "flex", "padding", "rounded", "spacing"];
  let gr = compute_rest_props(ar, hr), { $$slots: vr = {}, $$scope: mr } = ar;
  const br = compute_slots(vr);
  let { selected: yr = !1 } = ar, { controls: kr = "" } = ar, { active: Tr = getContext("active") } = ar, { hover: _r = getContext("hover") } = ar, { flex: Er = getContext("flex") } = ar, { padding: xr = getContext("padding") } = ar, { rounded: Cr = getContext("rounded") } = ar, { spacing: Ar = getContext("spacing") } = ar;
  function Lr() {
    return delete gr.class, gr;
  }
  function Dr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Nr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Hr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function $r(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Wr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Zr(Yr) {
    bubble.call(this, lr, Yr);
  }
  function oi(Yr) {
    bubble.call(this, lr, Yr);
  }
  function Jr(Yr) {
    bubble.call(this, lr, Yr);
  }
  return lr.$$set = (Yr) => {
    cr(4, ar = assign$1(assign$1({}, ar), exclude_internal_props(Yr))), cr(24, gr = compute_rest_props(ar, hr)), "selected" in Yr && cr(6, yr = Yr.selected), "controls" in Yr && cr(0, kr = Yr.controls), "active" in Yr && cr(7, Tr = Yr.active), "hover" in Yr && cr(8, _r = Yr.hover), "flex" in Yr && cr(9, Er = Yr.flex), "padding" in Yr && cr(10, xr = Yr.padding), "rounded" in Yr && cr(11, Cr = Yr.rounded), "spacing" in Yr && cr(12, Ar = Yr.spacing), "$$scope" in Yr && cr(14, mr = Yr.$$scope);
  }, lr.$$.update = () => {
    var Yr;
    lr.$$.dirty & /*selected, active, hover*/
    448 && cr(13, ur = yr ? Tr : _r), cr(2, fr = `${cBase$3} ${Er} ${xr} ${Cr} ${ur} ${(Yr = ar.class) != null ? Yr : ""}`), lr.$$.dirty & /*spacing*/
    4096 && cr(1, dr = `${cInterface} ${Ar}`);
  }, ar = exclude_internal_props(ar), [
    kr,
    dr,
    fr,
    Lr,
    ar,
    br,
    yr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    ur,
    mr,
    vr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr
  ];
}
class TabAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$m, create_fragment$H, safe_not_equal, {
      selected: 6,
      controls: 0,
      active: 7,
      hover: 8,
      flex: 9,
      padding: 10,
      rounded: 11,
      spacing: 12
    });
  }
  get selected() {
    return this.$$.ctx[6];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[0];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get active() {
    return this.$$.ctx[7];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[8];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[9];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[10];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[11];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
}
create_custom_element(TabAnchor, { selected: { type: "Boolean" }, controls: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
function create_fragment$G(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "tree " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        lr[0]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        lr[2]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[1]
      );
    },
    m(hr, gr) {
      insert(hr, ar, gr), dr && dr.m(ar, null), lr[23](ar), ur = !0;
    },
    p(hr, [gr]) {
      dr && dr.p && (!ur || gr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        hr,
        /*$$scope*/
        hr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          hr[21],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          hr[21]
        ),
        null
      ), (!ur || gr & /*classesBase*/
      16 && cr !== (cr = "tree " + /*classesBase*/
      hr[4])) && attr(ar, "class", cr), (!ur || gr & /*multiple*/
      1) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        hr[0]
      ), (!ur || gr & /*labelledby*/
      4) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        hr[2]
      ), (!ur || gr & /*disabled*/
      2) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        hr[1]
      );
    },
    i(hr) {
      ur || (transition_in(dr, hr), ur = !0);
    },
    o(hr) {
      transition_out(dr, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr), lr[23](null);
    }
  };
}
function instance$l(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { selection: hr = !1 } = ar, { multiple: gr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: mr = "space-y-1" } = ar, { open: br = !1 } = ar, { disabled: yr = !1 } = ar, { padding: kr = "py-4 px-4" } = ar, { indent: Tr = "ml-4" } = ar, { hover: _r = "hover:variant-soft" } = ar, { rounded: Er = "rounded-container-token" } = ar, { caretOpen: xr = "rotate-180" } = ar, { caretClosed: Cr = "" } = ar, { hyphenOpacity: Ar = "opacity-10" } = ar, { regionSummary: Lr = "" } = ar, { regionSymbol: Dr = "" } = ar, { regionChildren: Nr = "" } = ar, { labelledby: Hr = "" } = ar;
  function $r() {
    Zr.querySelectorAll("details.tree-item").forEach((Yr) => {
      if (!Yr.open) {
        const li = Yr.querySelector("summary.tree-item-summary");
        li && li.click();
      }
    });
  }
  function Wr() {
    Zr.querySelectorAll("details.tree-item").forEach((Yr) => {
      if (Yr.open) {
        const li = Yr.querySelector("summary.tree-item-summary");
        li && li.click();
      }
    });
  }
  setContext("open", br), setContext("selection", hr), setContext("multiple", gr), setContext("disabled", yr), setContext("padding", kr), setContext("indent", Tr), setContext("hover", _r), setContext("rounded", Er), setContext("caretOpen", xr), setContext("caretClosed", Cr), setContext("hyphenOpacity", Ar), setContext("regionSummary", Lr), setContext("regionSymbol", Dr), setContext("regionChildren", Nr);
  let Zr;
  function oi(Jr) {
    binding_callbacks[Jr ? "unshift" : "push"](() => {
      Zr = Jr, cr(3, Zr);
    });
  }
  return lr.$$set = (Jr) => {
    cr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(Jr))), "selection" in Jr && cr(5, hr = Jr.selection), "multiple" in Jr && cr(0, gr = Jr.multiple), "width" in Jr && cr(6, vr = Jr.width), "spacing" in Jr && cr(7, mr = Jr.spacing), "open" in Jr && cr(8, br = Jr.open), "disabled" in Jr && cr(1, yr = Jr.disabled), "padding" in Jr && cr(9, kr = Jr.padding), "indent" in Jr && cr(10, Tr = Jr.indent), "hover" in Jr && cr(11, _r = Jr.hover), "rounded" in Jr && cr(12, Er = Jr.rounded), "caretOpen" in Jr && cr(13, xr = Jr.caretOpen), "caretClosed" in Jr && cr(14, Cr = Jr.caretClosed), "hyphenOpacity" in Jr && cr(15, Ar = Jr.hyphenOpacity), "regionSummary" in Jr && cr(16, Lr = Jr.regionSummary), "regionSymbol" in Jr && cr(17, Dr = Jr.regionSymbol), "regionChildren" in Jr && cr(18, Nr = Jr.regionChildren), "labelledby" in Jr && cr(2, Hr = Jr.labelledby), "$$scope" in Jr && cr(21, dr = Jr.$$scope);
  }, lr.$$.update = () => {
    var Jr;
    cr(4, ur = `${vr} ${mr} ${(Jr = ar.class) != null ? Jr : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    yr,
    Hr,
    Zr,
    ur,
    hr,
    vr,
    mr,
    br,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    $r,
    Wr,
    dr,
    fr,
    oi
  ];
}
class TreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$l, create_fragment$G, safe_not_equal, {
      selection: 5,
      multiple: 0,
      width: 6,
      spacing: 7,
      open: 8,
      disabled: 1,
      padding: 9,
      indent: 10,
      hover: 11,
      rounded: 12,
      caretOpen: 13,
      caretClosed: 14,
      hyphenOpacity: 15,
      regionSummary: 16,
      regionSymbol: 17,
      regionChildren: 18,
      labelledby: 2,
      expandAll: 19,
      collapseAll: 20
    });
  }
  get selection() {
    return this.$$.ctx[5];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[0];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[7];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[8];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[9];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[10];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[11];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[13];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[14];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[15];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[16];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[17];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[18];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[2];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get expandAll() {
    return this.$$.ctx[19];
  }
  get collapseAll() {
    return this.$$.ctx[20];
  }
}
create_custom_element(TreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, ["default"], ["expandAll", "collapseAll"], !0);
const get_children_slot_changes = (lr) => ({}), get_children_slot_context = (lr) => ({}), get_lead_slot_changes = (lr) => ({}), get_lead_slot_context = (lr) => ({});
function create_else_block_1$4(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512"), attr(ar, "class", ur = "w-3 " + /*classesHyphen*/
      lr[15]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr);
    },
    p(fr, dr) {
      dr[0] & /*classesHyphen*/
      32768 && ur !== (ur = "w-3 " + /*classesHyphen*/
      fr[15]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_3$4(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_1$7(lr) {
  let ar;
  function cr(dr, hr) {
    return (
      /*multiple*/
      dr[7] ? create_if_block_2$5 : create_else_block$7
    );
  }
  let ur = cr(lr), fr = ur(lr);
  return {
    c() {
      fr.c(), ar = empty$1();
    },
    m(dr, hr) {
      fr.m(dr, hr), insert(dr, ar, hr);
    },
    p(dr, hr) {
      ur === (ur = cr(dr)) && fr ? fr.p(dr, hr) : (fr.d(1), fr = ur(dr), fr && (fr.c(), fr.m(ar.parentNode, ar)));
    },
    d(dr) {
      dr && detach(ar), fr.d(dr);
    }
  };
}
function create_else_block$7(lr) {
  let ar, cr = !1, ur, fr, dr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    lr[44][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "class", "radio tree-item-radio"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        lr[4]
      ), ar.__value = /*value*/
      lr[5], set_input_value(ar, ar.__value), ur.p(ar);
    },
    m(hr, gr) {
      insert(hr, ar, gr), ar.checked = ar.__value === /*group*/
      lr[0], fr || (dr = listen(
        ar,
        "change",
        /*input_change_handler_1*/
        lr[43]
      ), fr = !0);
    },
    p(hr, gr) {
      gr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        hr[4]
      ), gr[0] & /*value*/
      32 && (ar.__value = /*value*/
      hr[5], set_input_value(ar, ar.__value), cr = !0), (cr || gr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      hr[0]);
    },
    d(hr) {
      hr && detach(ar), ur.r(), fr = !1, dr();
    }
  };
}
function create_if_block_2$5(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "class", "checkbox tree-item-checkbox"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        lr[4]
      ), ar.__value = /*value*/
      lr[5], set_input_value(ar, ar.__value), /*checked*/
      (lr[1] === void 0 || /*indeterminate*/
      lr[3] === void 0) && add_render_callback(() => (
        /*input_change_handler*/
        lr[42].call(ar)
      ));
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.checked = /*checked*/
      lr[1], ar.indeterminate = /*indeterminate*/
      lr[3], cr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          lr[42]
        ),
        listen(
          ar,
          "change",
          /*onParentChange*/
          lr[11]
        )
      ], cr = !0);
    },
    p(fr, dr) {
      dr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        fr[4]
      ), dr[0] & /*value*/
      32 && (ar.__value = /*value*/
      fr[5], set_input_value(ar, ar.__value)), dr[0] & /*checked*/
      2 && (ar.checked = /*checked*/
      fr[1]), dr[0] & /*indeterminate*/
      8 && (ar.indeterminate = /*indeterminate*/
      fr[3]);
    },
    d(fr) {
      fr && detach(ar), cr = !1, run_all(ur);
    }
  };
}
function create_if_block$c(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[38].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[37],
    get_lead_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tree-item-lead");
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, hr) {
      fr && fr.p && (!cr || hr[1] & /*$$scope*/
      64) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[37],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[37],
          hr,
          get_lead_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[37]
        ),
        get_lead_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$F(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar;
  function Lr(Yr, li) {
    return (
      /*$$slots*/
      Yr[21].children && !/*hideChildren*/
      Yr[10] ? create_if_block_3$4 : create_else_block_1$4
    );
  }
  let Dr = Lr(lr), Nr = Dr(lr), Hr = (
    /*selection*/
    lr[6] && /*name*/
    lr[4] && /*group*/
    lr[0] !== void 0 && create_if_block_1$7(lr)
  ), $r = (
    /*$$slots*/
    lr[21].lead && !/*hideLead*/
    lr[9] && create_if_block$c(lr)
  );
  const Wr = (
    /*#slots*/
    lr[38].default
  ), Zr = create_slot(
    Wr,
    lr,
    /*$$scope*/
    lr[37],
    null
  ), oi = (
    /*#slots*/
    lr[38].children
  ), Jr = create_slot(
    oi,
    lr,
    /*$$scope*/
    lr[37],
    get_children_slot_context
  );
  return {
    c() {
      ar = element("details"), cr = element("summary"), ur = element("div"), Nr.c(), dr = space(), Hr && Hr.c(), hr = space(), $r && $r.c(), gr = space(), vr = element("div"), Zr && Zr.c(), kr = space(), Tr = element("div"), Jr && Jr.c(), attr(ur, "class", fr = "tree-summary-symbol " + /*classesSymbol*/
      lr[16]), attr(vr, "class", "tree-item-content"), attr(cr, "class", mr = "tree-item-summary " + /*classesSummary*/
      lr[17]), attr(cr, "role", "treeitem"), attr(cr, "aria-selected", br = /*selection*/
      lr[6] ? (
        /*checked*/
        lr[1]
      ) : void 0), attr(cr, "aria-expanded", yr = /*$$slots*/
      lr[21].children ? (
        /*open*/
        lr[2]
      ) : void 0), attr(Tr, "class", _r = "tree-item-children " + /*classesChildren*/
      lr[14]), attr(Tr, "role", "group"), attr(ar, "class", Er = "tree-item " + /*classesBase*/
      lr[18]), attr(ar, "data-testid", "tree-item"), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[8]
      );
    },
    m(Yr, li) {
      insert(Yr, ar, li), append(ar, cr), append(cr, ur), Nr.m(ur, null), append(cr, dr), Hr && Hr.m(cr, null), append(cr, hr), $r && $r.m(cr, null), append(cr, gr), append(cr, vr), Zr && Zr.m(vr, null), append(ar, kr), append(ar, Tr), Jr && Jr.m(Tr, null), lr[45](Tr), lr[46](ar), ar.open = /*open*/
      lr[2], xr = !0, Cr || (Ar = [
        listen(
          cr,
          "click",
          /*onSummaryClick*/
          lr[19]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[39]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[20]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[40]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[41]
        ),
        listen(
          ar,
          "toggle",
          /*details_toggle_handler*/
          lr[47]
        )
      ], Cr = !0);
    },
    p(Yr, li) {
      Dr === (Dr = Lr(Yr)) && Nr ? Nr.p(Yr, li) : (Nr.d(1), Nr = Dr(Yr), Nr && (Nr.c(), Nr.m(ur, null))), (!xr || li[0] & /*classesSymbol*/
      65536 && fr !== (fr = "tree-summary-symbol " + /*classesSymbol*/
      Yr[16])) && attr(ur, "class", fr), /*selection*/
      Yr[6] && /*name*/
      Yr[4] && /*group*/
      Yr[0] !== void 0 ? Hr ? Hr.p(Yr, li) : (Hr = create_if_block_1$7(Yr), Hr.c(), Hr.m(cr, hr)) : Hr && (Hr.d(1), Hr = null), /*$$slots*/
      Yr[21].lead && !/*hideLead*/
      Yr[9] ? $r ? ($r.p(Yr, li), li[0] & /*$$slots, hideLead*/
      2097664 && transition_in($r, 1)) : ($r = create_if_block$c(Yr), $r.c(), transition_in($r, 1), $r.m(cr, gr)) : $r && (group_outros(), transition_out($r, 1, 1, () => {
        $r = null;
      }), check_outros()), Zr && Zr.p && (!xr || li[1] & /*$$scope*/
      64) && update_slot_base(
        Zr,
        Wr,
        Yr,
        /*$$scope*/
        Yr[37],
        xr ? get_slot_changes(
          Wr,
          /*$$scope*/
          Yr[37],
          li,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Yr[37]
        ),
        null
      ), (!xr || li[0] & /*classesSummary*/
      131072 && mr !== (mr = "tree-item-summary " + /*classesSummary*/
      Yr[17])) && attr(cr, "class", mr), (!xr || li[0] & /*selection, checked*/
      66 && br !== (br = /*selection*/
      Yr[6] ? (
        /*checked*/
        Yr[1]
      ) : void 0)) && attr(cr, "aria-selected", br), (!xr || li[0] & /*$$slots, open*/
      2097156 && yr !== (yr = /*$$slots*/
      Yr[21].children ? (
        /*open*/
        Yr[2]
      ) : void 0)) && attr(cr, "aria-expanded", yr), Jr && Jr.p && (!xr || li[1] & /*$$scope*/
      64) && update_slot_base(
        Jr,
        oi,
        Yr,
        /*$$scope*/
        Yr[37],
        xr ? get_slot_changes(
          oi,
          /*$$scope*/
          Yr[37],
          li,
          get_children_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Yr[37]
        ),
        get_children_slot_context
      ), (!xr || li[0] & /*classesChildren*/
      16384 && _r !== (_r = "tree-item-children " + /*classesChildren*/
      Yr[14])) && attr(Tr, "class", _r), (!xr || li[0] & /*classesBase*/
      262144 && Er !== (Er = "tree-item " + /*classesBase*/
      Yr[18])) && attr(ar, "class", Er), (!xr || li[0] & /*disabled*/
      256) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        Yr[8]
      ), li[0] & /*open*/
      4 && (ar.open = /*open*/
      Yr[2]);
    },
    i(Yr) {
      xr || (transition_in($r), transition_in(Zr, Yr), transition_in(Jr, Yr), xr = !0);
    },
    o(Yr) {
      transition_out($r), transition_out(Zr, Yr), transition_out(Jr, Yr), xr = !1;
    },
    d(Yr) {
      Yr && detach(ar), Nr.d(), Hr && Hr.d(), $r && $r.d(), Zr && Zr.d(Yr), Jr && Jr.d(Yr), lr[45](null), lr[46](null), Cr = !1, run_all(Ar);
    }
  };
}
const cBase$2 = "", cSummary = "list-none [&::-webkit-details-marker]:hidden flex items-center cursor-pointer", cSymbol = "fill-current w-3 text-center transition-transform duration-[200ms]", cChildren = "", cDisabled = "opacity-50 !cursor-not-allowed";
function instance$k(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br, { $$slots: yr = {}, $$scope: kr } = ar;
  const Tr = compute_slots(yr);
  let { group: _r = void 0 } = ar, { name: Er = void 0 } = ar, { value: xr = void 0 } = ar, { checked: Cr = !1 } = ar, { children: Ar = [] } = ar, { spacing: Lr = "space-x-4" } = ar, { open: Dr = getContext("open") } = ar, { selection: Nr = getContext("selection") } = ar, { multiple: Hr = getContext("multiple") } = ar, { disabled: $r = getContext("disabled") } = ar, { indeterminate: Wr = !1 } = ar, { padding: Zr = getContext("padding") } = ar, { indent: oi = getContext("indent") } = ar, { hover: Jr = getContext("hover") } = ar, { rounded: Yr = getContext("rounded") } = ar, { caretOpen: li = getContext("caretOpen") } = ar, { caretClosed: Si = getContext("caretClosed") } = ar, { hyphenOpacity: ci = getContext("hyphenOpacity") } = ar, { regionSummary: hi = getContext("regionSummary") } = ar, { regionSymbol: Ei = getContext("regionSymbol") } = ar, { regionChildren: di = getContext("regionChildren") } = ar, { hideLead: gi = !1 } = ar, { hideChildren: Li = !1 } = ar, ui, wi;
  function Ui(Hi) {
    $r && Hi.preventDefault();
  }
  function yi(Hi, oa) {
    Array.isArray(Hi) && (cr(1, Cr = Hi.indexOf(xr) >= 0), _i("groupChange", { checked: Cr, indeterminate: oa }), _i("childChange"));
  }
  function Vi(Hi, oa) {
    if (!Array.isArray(_r))
      return;
    const Gi = _r.indexOf(xr);
    Hi ? Gi < 0 && (_r.push(xr), cr(0, _r)) : Gi >= 0 && (_r.splice(Gi, 1), cr(0, _r)), oa || mi();
  }
  function Oi(Hi) {
    cr(1, Cr = Hi === xr), _i("groupChange", { checked: Cr, indeterminate: !1 }), Hi && _i("childChange");
  }
  function Mi(Hi) {
    Hi && _r !== xr ? cr(0, _r = xr) : !Hi && _r === xr && cr(0, _r = "");
  }
  function Ii() {
    if (Hr) {
      if (!Array.isArray(_r))
        return;
      const Hi = Ar.map((ha) => ha.value), oa = Ar[0].group, Gi = _r.indexOf(xr);
      Ar.some((ha) => ha.indeterminate) ? (cr(3, Wr = !0), Gi >= 0 && (_r.splice(Gi, 1), cr(0, _r))) : Hi.every((ha) => Array.isArray(oa) && oa.includes(ha)) ? (cr(3, Wr = !1), Gi < 0 && (_r.push(xr), cr(0, _r))) : Hi.some((ha) => Array.isArray(oa) && oa.includes(ha)) ? (cr(3, Wr = !0), Gi >= 0 && (_r.splice(Gi, 1), cr(0, _r))) : (cr(3, Wr = !1), Gi >= 0 && (_r.splice(Gi, 1), cr(0, _r)));
    } else
      _r !== xr && Ar.some((Hi) => Hi.checked) ? cr(0, _r = xr) : _r === xr && !Ar.some((Hi) => Hi.checked) && cr(0, _r = "");
    _i("childChange");
  }
  function mi() {
    if (!Hr || !Ar || Ar.length === 0 || !Array.isArray(_r))
      return;
    const Hi = _r.indexOf(xr), oa = (ha) => {
      !ha || !Array.isArray(ha.group) || (ha.indeterminate = !1, ha.group.indexOf(ha.value) < 0 && (ha.group.push(ha.value), ha.group = ha.group));
    }, Gi = (ha) => {
      if (!ha || !Array.isArray(ha.group))
        return;
      ha.indeterminate = !1;
      const Ua = ha.group.indexOf(ha.value);
      Ua >= 0 && (ha.group.splice(Ua, 1), ha.group = ha.group);
    };
    Ar.forEach((ha) => {
      ha && (Hi >= 0 ? oa(ha) : Gi(ha), ha.onParentChange());
    });
  }
  const _i = createEventDispatcher();
  function Ci(Hi) {
    var Ua, eo, ua, va, Ta, Aa, Oa, Xa, Ka;
    function oa() {
      let Pa = ui;
      for (; Pa !== null; ) {
        if (Pa.classList.contains("tree"))
          return Pa;
        Pa = Pa.parentElement;
      }
    }
    let Gi, ha = null;
    switch (Hi.code) {
      case "ArrowRight":
        if (!Dr)
          cr(2, Dr = !0);
        else if (Tr.children && !Li) {
          const Pa = wi.querySelector("details>summary");
          Pa && Pa.focus();
        }
        break;
      case "ArrowLeft":
        if (Dr)
          cr(2, Dr = !1);
        else {
          const Pa = (Ua = ui.parentElement) == null ? void 0 : Ua.parentElement;
          Pa && Pa.tagName === "DETAILS" && ((eo = Pa.querySelector("summary")) == null || eo.focus());
        }
        break;
      case "Home":
        Hi.preventDefault(), Gi = oa(), Gi && ((ua = Gi == null ? void 0 : Gi.querySelector("summary")) == null || ua.focus());
        break;
      case "End":
        if (Hi.preventDefault(), Gi = oa(), Gi) {
          const Pa = Gi == null ? void 0 : Gi.querySelectorAll("details");
          if (!Pa)
            return;
          for (let Da = Pa.length - 1; Da >= 0; Da--) {
            const Ha = Pa[Da];
            if ((Ta = (va = Ha.parentElement) == null ? void 0 : va.classList) != null && Ta.contains("tree") || ((Oa = (Aa = Ha.parentElement) == null ? void 0 : Aa.parentElement) == null ? void 0 : Oa.getAttribute("open")) !== null) {
              ha = Ha;
              break;
            } else if (((Ka = (Xa = Ha.parentElement) == null ? void 0 : Xa.parentElement) == null ? void 0 : Ka.tagName) !== "details") {
              ha = Ha.parentElement.parentElement;
              break;
            }
          }
          if (ha) {
            const Da = ha.querySelector("summary");
            Da && Da.focus();
          }
        }
        break;
    }
  }
  const Ki = [[]];
  function Ni(Hi) {
    bubble.call(this, lr, Hi);
  }
  function ia(Hi) {
    bubble.call(this, lr, Hi);
  }
  function ea(Hi) {
    bubble.call(this, lr, Hi);
  }
  function la() {
    Cr = this.checked, Wr = this.indeterminate, cr(1, Cr), cr(3, Wr);
  }
  function ma() {
    _r = this.__value, cr(0, _r);
  }
  function Ba(Hi) {
    binding_callbacks[Hi ? "unshift" : "push"](() => {
      wi = Hi, cr(13, wi);
    });
  }
  function Fa(Hi) {
    binding_callbacks[Hi ? "unshift" : "push"](() => {
      ui = Hi, cr(12, ui);
    });
  }
  function Ia() {
    Dr = this.open, cr(2, Dr);
  }
  return lr.$$set = (Hi) => {
    cr(54, ar = assign$1(assign$1({}, ar), exclude_internal_props(Hi))), "group" in Hi && cr(0, _r = Hi.group), "name" in Hi && cr(4, Er = Hi.name), "value" in Hi && cr(5, xr = Hi.value), "checked" in Hi && cr(1, Cr = Hi.checked), "children" in Hi && cr(22, Ar = Hi.children), "spacing" in Hi && cr(23, Lr = Hi.spacing), "open" in Hi && cr(2, Dr = Hi.open), "selection" in Hi && cr(6, Nr = Hi.selection), "multiple" in Hi && cr(7, Hr = Hi.multiple), "disabled" in Hi && cr(8, $r = Hi.disabled), "indeterminate" in Hi && cr(3, Wr = Hi.indeterminate), "padding" in Hi && cr(24, Zr = Hi.padding), "indent" in Hi && cr(25, oi = Hi.indent), "hover" in Hi && cr(26, Jr = Hi.hover), "rounded" in Hi && cr(27, Yr = Hi.rounded), "caretOpen" in Hi && cr(28, li = Hi.caretOpen), "caretClosed" in Hi && cr(29, Si = Hi.caretClosed), "hyphenOpacity" in Hi && cr(30, ci = Hi.hyphenOpacity), "regionSummary" in Hi && cr(31, hi = Hi.regionSummary), "regionSymbol" in Hi && cr(32, Ei = Hi.regionSymbol), "regionChildren" in Hi && cr(33, di = Hi.regionChildren), "hideLead" in Hi && cr(9, gi = Hi.hideLead), "hideChildren" in Hi && cr(10, Li = Hi.hideChildren), "$$scope" in Hi && cr(37, kr = Hi.$$scope);
  }, lr.$$.update = () => {
    var Hi;
    lr.$$.dirty[0] & /*multiple, group, indeterminate*/
    137 && Hr && yi(_r, Wr), lr.$$.dirty[0] & /*multiple, checked, indeterminate*/
    138 && Hr && Vi(Cr, Wr), lr.$$.dirty[0] & /*multiple, group*/
    129 && (Hr || Oi(_r)), lr.$$.dirty[0] & /*multiple, checked*/
    130 && (Hr || Mi(Cr)), lr.$$.dirty[0] & /*multiple, group, value, children*/
    4194465 && !Hr && _r !== void 0 && _r !== xr && Ar.forEach((oa) => {
      oa && (oa.group = "");
    }), lr.$$.dirty[0] & /*open*/
    4 && _i("toggle", { open: Dr }), lr.$$.dirty[0] & /*children*/
    4194304 && Ar.forEach((oa) => {
      oa && oa.$on("childChange", Ii);
    }), lr.$$.dirty[0] & /*open, hideChildren, caretOpen, caretClosed*/
    805307396 && cr(34, ur = Dr && Tr.children && !Li ? li : Si), lr.$$.dirty[0] & /*disabled*/
    256 && cr(36, fr = $r ? cDisabled : ""), cr(18, dr = `${cBase$2} ${(Hi = ar.class) != null ? Hi : ""}`), lr.$$.dirty[0] & /*spacing, rounded, padding, hover*/
    226492416 | lr.$$.dirty[1] & /*classesDisabled, regionSummary*/
    33 && cr(17, hr = `${cSummary} ${fr} ${Lr} ${Yr} ${Zr} ${Jr} ${hi}`), lr.$$.dirty[1] & /*classesCaretState*/
    8 && cr(35, vr = `${ur}`), lr.$$.dirty[1] & /*classesCaret, regionSymbol*/
    18 && cr(16, gr = `${cSymbol} ${vr} ${Ei}`), lr.$$.dirty[0] & /*hyphenOpacity*/
    1073741824 && cr(15, mr = `${ci}`), lr.$$.dirty[0] & /*indent*/
    33554432 | lr.$$.dirty[1] & /*regionChildren*/
    4 && cr(14, br = `${cChildren} ${oi} ${di}`);
  }, ar = exclude_internal_props(ar), [
    _r,
    Cr,
    Dr,
    Wr,
    Er,
    xr,
    Nr,
    Hr,
    $r,
    gi,
    Li,
    mi,
    ui,
    wi,
    br,
    mr,
    gr,
    hr,
    dr,
    Ui,
    Ci,
    Tr,
    Ar,
    Lr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    ur,
    vr,
    fr,
    kr,
    yr,
    Ni,
    ia,
    ea,
    la,
    ma,
    Ki,
    Ba,
    Fa,
    Ia
  ];
}
class TreeViewItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$k,
      create_fragment$F,
      safe_not_equal,
      {
        group: 0,
        name: 4,
        value: 5,
        checked: 1,
        children: 22,
        spacing: 23,
        open: 2,
        selection: 6,
        multiple: 7,
        disabled: 8,
        indeterminate: 3,
        padding: 24,
        indent: 25,
        hover: 26,
        rounded: 27,
        caretOpen: 28,
        caretClosed: 29,
        hyphenOpacity: 30,
        regionSummary: 31,
        regionSymbol: 32,
        regionChildren: 33,
        hideLead: 9,
        hideChildren: 10,
        onParentChange: 11
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[4];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[5];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[1];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get children() {
    return this.$$.ctx[22];
  }
  set children(ar) {
    this.$$set({ children: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[23];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[2];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get selection() {
    return this.$$.ctx[6];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[7];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[8];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get indeterminate() {
    return this.$$.ctx[3];
  }
  set indeterminate(ar) {
    this.$$set({ indeterminate: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[24];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[25];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[26];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[27];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[28];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[29];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[30];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[31];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[32];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[33];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get hideLead() {
    return this.$$.ctx[9];
  }
  set hideLead(ar) {
    this.$$set({ hideLead: ar }), flush();
  }
  get hideChildren() {
    return this.$$.ctx[10];
  }
  set hideChildren(ar) {
    this.$$set({ hideChildren: ar }), flush();
  }
  get onParentChange() {
    return this.$$.ctx[11];
  }
}
create_custom_element(TreeViewItem, { group: {}, name: {}, value: {}, checked: { type: "Boolean" }, children: {}, spacing: {}, open: {}, selection: {}, multiple: {}, disabled: {}, indeterminate: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, hideLead: { type: "Boolean" }, hideChildren: { type: "Boolean" } }, ["lead", "default", "children"], ["onParentChange"], !0);
function get_each_context$4(lr, ar, cr) {
  const ur = lr.slice();
  return ur[31] = ar[cr], ur[32] = ar, ur[33] = cr, ur;
}
function create_if_block$b(lr) {
  let ar, cr, ur = ensure_array_like(
    /*nodes*/
    lr[0]
  ), fr = [];
  for (let hr = 0; hr < ur.length; hr += 1)
    fr[hr] = create_each_block$4(get_each_context$4(lr, ur, hr));
  const dr = (hr) => transition_out(fr[hr], 1, 1, () => {
    fr[hr] = null;
  });
  return {
    c() {
      for (let hr = 0; hr < fr.length; hr += 1)
        fr[hr].c();
      ar = empty$1();
    },
    m(hr, gr) {
      for (let vr = 0; vr < fr.length; vr += 1)
        fr[vr] && fr[vr].m(hr, gr);
      insert(hr, ar, gr), cr = !0;
    },
    p(hr, gr) {
      if (gr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, treeItems, children, group, name, toggleNode, checkNode, dispatch*/
      4095) {
        ur = ensure_array_like(
          /*nodes*/
          hr[0]
        );
        let vr;
        for (vr = 0; vr < ur.length; vr += 1) {
          const mr = get_each_context$4(hr, ur, vr);
          fr[vr] ? (fr[vr].p(mr, gr), transition_in(fr[vr], 1)) : (fr[vr] = create_each_block$4(mr), fr[vr].c(), transition_in(fr[vr], 1), fr[vr].m(ar.parentNode, ar));
        }
        for (group_outros(), vr = ur.length; vr < fr.length; vr += 1)
          dr(vr);
        check_outros();
      }
    },
    i(hr) {
      if (!cr) {
        for (let gr = 0; gr < ur.length; gr += 1)
          transition_in(fr[gr]);
        cr = !0;
      }
    },
    o(hr) {
      fr = fr.filter(Boolean);
      for (let gr = 0; gr < fr.length; gr += 1)
        transition_out(fr[gr]);
      cr = !1;
    },
    d(hr) {
      hr && detach(ar), destroy_each(fr, hr);
    }
  };
}
function create_else_block_1$3(lr) {
  let ar, cr, ur;
  const fr = [
    /*node*/
    lr[31].contentProps
  ];
  var dr = (
    /*node*/
    lr[31].content
  );
  function hr(gr, vr) {
    let mr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      mr = get_spread_update(fr, [get_spread_object(
        /*node*/
        gr[31].contentProps
      )]);
    else
      for (let br = 0; br < fr.length; br += 1)
        mr = assign$1(mr, fr[br]);
    return { props: mr };
  }
  return dr && (ar = construct_svelte_component(dr, hr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(gr, vr) {
      ar && mount_component(ar, gr, vr), insert(gr, cr, vr), ur = !0;
    },
    p(gr, vr) {
      if (vr[0] & /*nodes*/
      1 && dr !== (dr = /*node*/
      gr[31].content)) {
        if (ar) {
          group_outros();
          const mr = ar;
          transition_out(mr.$$.fragment, 1, 0, () => {
            destroy_component(mr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, hr(gr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const mr = vr[0] & /*nodes*/
        1 ? get_spread_update(fr, [get_spread_object(
          /*node*/
          gr[31].contentProps
        )]) : {};
        ar.$set(mr);
      }
    },
    i(gr) {
      ur || (ar && transition_in(ar.$$.fragment, gr), ur = !0);
    },
    o(gr) {
      ar && transition_out(ar.$$.fragment, gr), ur = !1;
    },
    d(gr) {
      gr && detach(cr), ar && destroy_component(ar, gr);
    }
  };
}
function create_if_block_2$4(lr) {
  let ar, cr = (
    /*node*/
    lr[31].content + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(fr, dr) {
      ar.m(cr, fr, dr), insert(fr, ur, dr);
    },
    p(fr, dr) {
      dr[0] & /*nodes*/
      1 && cr !== (cr = /*node*/
      fr[31].content + "") && ar.p(cr);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && (detach(ur), ar.d());
    }
  };
}
function create_default_slot$2(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_2$4, create_else_block_1$3], hr = [];
  function gr(vr, mr) {
    return typeof /*node*/
    vr[31].content == "string" ? 0 : 1;
  }
  return ar = gr(lr), cr = hr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = space();
    },
    m(vr, mr) {
      hr[ar].m(vr, mr), insert(vr, ur, mr), fr = !0;
    },
    p(vr, mr) {
      let br = ar;
      ar = gr(vr), ar === br ? hr[ar].p(vr, mr) : (group_outros(), transition_out(hr[br], 1, 1, () => {
        hr[br] = null;
      }), check_outros(), cr = hr[ar], cr ? cr.p(vr, mr) : (cr = hr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), hr[ar].d(vr);
    }
  };
}
function create_else_block$6(lr) {
  let ar, cr, ur;
  const fr = [
    /*node*/
    lr[31].leadProps
  ];
  var dr = (
    /*node*/
    lr[31].lead
  );
  function hr(gr, vr) {
    let mr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      mr = get_spread_update(fr, [get_spread_object(
        /*node*/
        gr[31].leadProps
      )]);
    else
      for (let br = 0; br < fr.length; br += 1)
        mr = assign$1(mr, fr[br]);
    return { props: mr };
  }
  return dr && (ar = construct_svelte_component(dr, hr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(gr, vr) {
      ar && mount_component(ar, gr, vr), insert(gr, cr, vr), ur = !0;
    },
    p(gr, vr) {
      if (vr[0] & /*nodes*/
      1 && dr !== (dr = /*node*/
      gr[31].lead)) {
        if (ar) {
          group_outros();
          const mr = ar;
          transition_out(mr.$$.fragment, 1, 0, () => {
            destroy_component(mr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, hr(gr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const mr = vr[0] & /*nodes*/
        1 ? get_spread_update(fr, [get_spread_object(
          /*node*/
          gr[31].leadProps
        )]) : {};
        ar.$set(mr);
      }
    },
    i(gr) {
      ur || (ar && transition_in(ar.$$.fragment, gr), ur = !0);
    },
    o(gr) {
      ar && transition_out(ar.$$.fragment, gr), ur = !1;
    },
    d(gr) {
      gr && detach(cr), ar && destroy_component(ar, gr);
    }
  };
}
function create_if_block_1$6(lr) {
  let ar, cr = (
    /*node*/
    lr[31].lead + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(fr, dr) {
      ar.m(cr, fr, dr), insert(fr, ur, dr);
    },
    p(fr, dr) {
      dr[0] & /*nodes*/
      1 && cr !== (cr = /*node*/
      fr[31].lead + "") && ar.p(cr);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && (detach(ur), ar.d());
    }
  };
}
function create_lead_slot(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_1$6, create_else_block$6], hr = [];
  function gr(vr, mr) {
    return typeof /*node*/
    vr[31].lead == "string" ? 0 : 1;
  }
  return ar = gr(lr), cr = hr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = space();
    },
    m(vr, mr) {
      hr[ar].m(vr, mr), insert(vr, ur, mr), fr = !0;
    },
    p(vr, mr) {
      let br = ar;
      ar = gr(vr), ar === br ? hr[ar].p(vr, mr) : (group_outros(), transition_out(hr[br], 1, 1, () => {
        hr[br] = null;
      }), check_outros(), cr = hr[ar], cr ? cr.p(vr, mr) : (cr = hr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), hr[ar].d(vr);
    }
  };
}
function create_children_slot(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  function mr(Er) {
    lr[12](Er);
  }
  function br(Er) {
    lr[13](Er);
  }
  function yr(Er) {
    lr[14](Er);
  }
  function kr(Er) {
    lr[15](Er);
  }
  function Tr(Er) {
    lr[16](
      Er,
      /*i*/
      lr[33]
    );
  }
  let _r = { nodes: (
    /*node*/
    lr[31].children
  ) };
  return (
    /*expandedNodes*/
    lr[1] !== void 0 && (_r.expandedNodes = /*expandedNodes*/
    lr[1]), /*disabledNodes*/
    lr[2] !== void 0 && (_r.disabledNodes = /*disabledNodes*/
    lr[2]), /*checkedNodes*/
    lr[3] !== void 0 && (_r.checkedNodes = /*checkedNodes*/
    lr[3]), /*indeterminateNodes*/
    lr[4] !== void 0 && (_r.indeterminateNodes = /*indeterminateNodes*/
    lr[4]), /*children*/
    lr[8][
      /*i*/
      lr[33]
    ] !== void 0 && (_r.treeItems = /*children*/
    lr[8][
      /*i*/
      lr[33]
    ]), ar = new RecursiveTreeViewItem_1({ props: _r }), binding_callbacks.push(() => bind(ar, "expandedNodes", mr)), binding_callbacks.push(() => bind(ar, "disabledNodes", br)), binding_callbacks.push(() => bind(ar, "checkedNodes", yr)), binding_callbacks.push(() => bind(ar, "indeterminateNodes", kr)), binding_callbacks.push(() => bind(ar, "treeItems", Tr)), ar.$on(
      "click",
      /*click_handler*/
      lr[17]
    ), ar.$on(
      "toggle",
      /*toggle_handler*/
      lr[18]
    ), {
      c() {
        create_component(ar.$$.fragment), gr = space();
      },
      m(Er, xr) {
        mount_component(ar, Er, xr), insert(Er, gr, xr), vr = !0;
      },
      p(Er, xr) {
        lr = Er;
        const Cr = {};
        xr[0] & /*nodes*/
        1 && (Cr.nodes = /*node*/
        lr[31].children), !cr && xr[0] & /*expandedNodes*/
        2 && (cr = !0, Cr.expandedNodes = /*expandedNodes*/
        lr[1], add_flush_callback(() => cr = !1)), !ur && xr[0] & /*disabledNodes*/
        4 && (ur = !0, Cr.disabledNodes = /*disabledNodes*/
        lr[2], add_flush_callback(() => ur = !1)), !fr && xr[0] & /*checkedNodes*/
        8 && (fr = !0, Cr.checkedNodes = /*checkedNodes*/
        lr[3], add_flush_callback(() => fr = !1)), !dr && xr[0] & /*indeterminateNodes*/
        16 && (dr = !0, Cr.indeterminateNodes = /*indeterminateNodes*/
        lr[4], add_flush_callback(() => dr = !1)), !hr && xr[0] & /*children*/
        256 && (hr = !0, Cr.treeItems = /*children*/
        lr[8][
          /*i*/
          lr[33]
        ], add_flush_callback(() => hr = !1)), ar.$set(Cr);
      },
      i(Er) {
        vr || (transition_in(ar.$$.fragment, Er), vr = !0);
      },
      o(Er) {
        transition_out(ar.$$.fragment, Er), vr = !1;
      },
      d(Er) {
        Er && detach(gr), destroy_component(ar, Er);
      }
    }
  );
}
function create_each_block$4(lr) {
  let ar, cr = (
    /*i*/
    lr[33]
  ), ur, fr, dr, hr, gr;
  const vr = () => (
    /*treeviewitem_binding*/
    lr[19](ar, cr)
  ), mr = () => (
    /*treeviewitem_binding*/
    lr[19](null, cr)
  );
  function br(Lr) {
    lr[20](
      Lr,
      /*i*/
      lr[33]
    );
  }
  function yr(Lr) {
    lr[21](Lr);
  }
  function kr(Lr) {
    lr[22](Lr);
  }
  function Tr(Lr) {
    lr[23](
      Lr,
      /*node*/
      lr[31]
    );
  }
  function _r(...Lr) {
    return (
      /*toggle_handler_1*/
      lr[24](
        /*node*/
        lr[31],
        ...Lr
      )
    );
  }
  function Er(...Lr) {
    return (
      /*groupChange_handler*/
      lr[25](
        /*node*/
        lr[31],
        ...Lr
      )
    );
  }
  function xr() {
    return (
      /*click_handler_1*/
      lr[26](
        /*node*/
        lr[31]
      )
    );
  }
  function Cr() {
    return (
      /*toggle_handler_2*/
      lr[27](
        /*node*/
        lr[31]
      )
    );
  }
  let Ar = {
    hideLead: !/*node*/
    lr[31].lead,
    hideChildren: !/*node*/
    lr[31].children || /*node*/
    lr[31].children.length === 0,
    open: (
      /*expandedNodes*/
      lr[1].includes(
        /*node*/
        lr[31].id
      )
    ),
    disabled: (
      /*disabledNodes*/
      lr[2].includes(
        /*node*/
        lr[31].id
      )
    ),
    checked: (
      /*checkedNodes*/
      lr[3].includes(
        /*node*/
        lr[31].id
      )
    ),
    indeterminate: (
      /*indeterminateNodes*/
      lr[4].includes(
        /*node*/
        lr[31].id
      )
    ),
    $$slots: {
      children: [create_children_slot],
      lead: [create_lead_slot],
      default: [create_default_slot$2]
    },
    $$scope: { ctx: lr }
  };
  return (
    /*children*/
    lr[8][
      /*i*/
      lr[33]
    ] !== void 0 && (Ar.children = /*children*/
    lr[8][
      /*i*/
      lr[33]
    ]), /*group*/
    lr[6] !== void 0 && (Ar.group = /*group*/
    lr[6]), /*name*/
    lr[7] !== void 0 && (Ar.name = /*name*/
    lr[7]), /*node*/
    lr[31].id !== void 0 && (Ar.value = /*node*/
    lr[31].id), ar = new TreeViewItem({ props: Ar }), vr(), binding_callbacks.push(() => bind(ar, "children", br)), binding_callbacks.push(() => bind(ar, "group", yr)), binding_callbacks.push(() => bind(ar, "name", kr)), binding_callbacks.push(() => bind(ar, "value", Tr)), ar.$on("toggle", _r), ar.$on("groupChange", Er), ar.$on("click", xr), ar.$on("toggle", Cr), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(Lr, Dr) {
        mount_component(ar, Lr, Dr), gr = !0;
      },
      p(Lr, Dr) {
        lr = Lr, cr !== /*i*/
        lr[33] && (mr(), cr = /*i*/
        lr[33], vr());
        const Nr = {};
        Dr[0] & /*nodes*/
        1 && (Nr.hideLead = !/*node*/
        lr[31].lead), Dr[0] & /*nodes*/
        1 && (Nr.hideChildren = !/*node*/
        lr[31].children || /*node*/
        lr[31].children.length === 0), Dr[0] & /*expandedNodes, nodes*/
        3 && (Nr.open = /*expandedNodes*/
        lr[1].includes(
          /*node*/
          lr[31].id
        )), Dr[0] & /*disabledNodes, nodes*/
        5 && (Nr.disabled = /*disabledNodes*/
        lr[2].includes(
          /*node*/
          lr[31].id
        )), Dr[0] & /*checkedNodes, nodes*/
        9 && (Nr.checked = /*checkedNodes*/
        lr[3].includes(
          /*node*/
          lr[31].id
        )), Dr[0] & /*indeterminateNodes, nodes*/
        17 && (Nr.indeterminate = /*indeterminateNodes*/
        lr[4].includes(
          /*node*/
          lr[31].id
        )), Dr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, children*/
        287 | Dr[1] & /*$$scope*/
        8 && (Nr.$$scope = { dirty: Dr, ctx: lr }), !ur && Dr[0] & /*children*/
        256 && (ur = !0, Nr.children = /*children*/
        lr[8][
          /*i*/
          lr[33]
        ], add_flush_callback(() => ur = !1)), !fr && Dr[0] & /*group*/
        64 && (fr = !0, Nr.group = /*group*/
        lr[6], add_flush_callback(() => fr = !1)), !dr && Dr[0] & /*name*/
        128 && (dr = !0, Nr.name = /*name*/
        lr[7], add_flush_callback(() => dr = !1)), !hr && Dr[0] & /*nodes*/
        1 && (hr = !0, Nr.value = /*node*/
        lr[31].id, add_flush_callback(() => hr = !1)), ar.$set(Nr);
      },
      i(Lr) {
        gr || (transition_in(ar.$$.fragment, Lr), gr = !0);
      },
      o(Lr) {
        transition_out(ar.$$.fragment, Lr), gr = !1;
      },
      d(Lr) {
        mr(), destroy_component(ar, Lr);
      }
    }
  );
}
function create_fragment$E(lr) {
  let ar, cr, ur = (
    /*nodes*/
    lr[0] && /*nodes*/
    lr[0].length > 0 && create_if_block$b(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*nodes*/
      fr[0] && /*nodes*/
      fr[0].length > 0 ? ur ? (ur.p(fr, dr), dr[0] & /*nodes*/
      1 && transition_in(ur, 1)) : (ur = create_if_block$b(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
function instance$j(lr, ar, cr) {
  let { nodes: ur = [] } = ar, { expandedNodes: fr = [] } = ar, { disabledNodes: dr = [] } = ar, { checkedNodes: hr = [] } = ar, { indeterminateNodes: gr = [] } = ar, vr = getContext("selection"), mr = getContext("multiple"), br = getContext("relational"), yr = mr ? [] : "", kr = "";
  const Tr = createEventDispatcher();
  function _r(di, gi) {
    var Li;
    (Li = di.children) != null && Li.length && (gi ? fr.includes(di.id) || (fr.push(di.id), cr(1, fr)) : fr.includes(di.id) && (fr.splice(fr.indexOf(di.id), 1), cr(1, fr)));
  }
  function Er(di, gi, Li) {
    gi ? (hr.includes(di.id) || (hr.push(di.id), cr(3, hr)), !Li && gr.includes(di.id) && (gr.splice(gr.indexOf(di.id), 1), cr(4, gr))) : (hr.includes(di.id) && (hr.splice(hr.indexOf(di.id), 1), cr(3, hr)), Li && !gr.includes(di.id) ? (gr.push(di.id), cr(4, gr)) : !Li && gr.includes(di.id) && (gr.splice(gr.indexOf(di.id), 1), cr(4, gr)));
  }
  vr && (mr ? (ur.forEach((di) => {
    Array.isArray(yr) && hr.includes(di.id) && !yr.includes(di.id) && yr.push(di.id);
  }), yr = yr) : ur.forEach((di) => {
    hr.includes(di.id) && yr !== di.id && cr(6, yr = di.id);
  })), onMount(async () => {
    vr && (cr(7, kr = String(Math.random())), br || cr(5, xr = []));
  });
  let { treeItems: xr = [] } = ar, Cr = [];
  function Ar(di) {
    fr = di, cr(1, fr);
  }
  function Lr(di) {
    dr = di, cr(2, dr);
  }
  function Dr(di) {
    hr = di, cr(3, hr);
  }
  function Nr(di) {
    gr = di, cr(4, gr);
  }
  function Hr(di, gi) {
    lr.$$.not_equal(Cr[gi], di) && (Cr[gi] = di, cr(8, Cr));
  }
  const $r = (di) => Tr("click", { id: di.detail.id }), Wr = (di) => Tr("toggle", { id: di.detail.id });
  function Zr(di, gi) {
    binding_callbacks[di ? "unshift" : "push"](() => {
      xr[gi] = di, cr(5, xr);
    });
  }
  function oi(di, gi) {
    lr.$$.not_equal(Cr[gi], di) && (Cr[gi] = di, cr(8, Cr));
  }
  function Jr(di) {
    yr = di, cr(6, yr);
  }
  function Yr(di) {
    kr = di, cr(7, kr);
  }
  function li(di, gi) {
    lr.$$.not_equal(gi.id, di) && (gi.id = di, cr(0, ur));
  }
  const Si = (di, gi) => _r(di, gi.detail.open), ci = (di, gi) => Er(di, gi.detail.checked, gi.detail.indeterminate), hi = (di) => Tr("click", { id: di.id }), Ei = (di) => {
    Tr("toggle", { id: di.id });
  };
  return lr.$$set = (di) => {
    "nodes" in di && cr(0, ur = di.nodes), "expandedNodes" in di && cr(1, fr = di.expandedNodes), "disabledNodes" in di && cr(2, dr = di.disabledNodes), "checkedNodes" in di && cr(3, hr = di.checkedNodes), "indeterminateNodes" in di && cr(4, gr = di.indeterminateNodes), "treeItems" in di && cr(5, xr = di.treeItems);
  }, [
    ur,
    fr,
    dr,
    hr,
    gr,
    xr,
    yr,
    kr,
    Cr,
    Tr,
    _r,
    Er,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei
  ];
}
class RecursiveTreeViewItem_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$j,
      create_fragment$E,
      safe_not_equal,
      {
        nodes: 0,
        expandedNodes: 1,
        disabledNodes: 2,
        checkedNodes: 3,
        indeterminateNodes: 4,
        treeItems: 5
      },
      null,
      [-1, -1]
    );
  }
  get nodes() {
    return this.$$.ctx[0];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[1];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[2];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[3];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[4];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get treeItems() {
    return this.$$.ctx[5];
  }
  set treeItems(ar) {
    this.$$set({ treeItems: ar }), flush();
  }
}
create_custom_element(RecursiveTreeViewItem_1, { nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, treeItems: {} }, [], [], !0);
function create_if_block$a(lr) {
  let ar, cr, ur, fr, dr, hr;
  function gr(kr) {
    lr[26](kr);
  }
  function vr(kr) {
    lr[27](kr);
  }
  function mr(kr) {
    lr[28](kr);
  }
  function br(kr) {
    lr[29](kr);
  }
  let yr = { nodes: (
    /*nodes*/
    lr[5]
  ) };
  return (
    /*expandedNodes*/
    lr[0] !== void 0 && (yr.expandedNodes = /*expandedNodes*/
    lr[0]), /*disabledNodes*/
    lr[1] !== void 0 && (yr.disabledNodes = /*disabledNodes*/
    lr[1]), /*checkedNodes*/
    lr[2] !== void 0 && (yr.checkedNodes = /*checkedNodes*/
    lr[2]), /*indeterminateNodes*/
    lr[3] !== void 0 && (yr.indeterminateNodes = /*indeterminateNodes*/
    lr[3]), ar = new RecursiveTreeViewItem_1({ props: yr }), binding_callbacks.push(() => bind(ar, "expandedNodes", gr)), binding_callbacks.push(() => bind(ar, "disabledNodes", vr)), binding_callbacks.push(() => bind(ar, "checkedNodes", mr)), binding_callbacks.push(() => bind(ar, "indeterminateNodes", br)), ar.$on(
      "click",
      /*onClick*/
      lr[9]
    ), ar.$on(
      "toggle",
      /*onToggle*/
      lr[10]
    ), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(kr, Tr) {
        mount_component(ar, kr, Tr), hr = !0;
      },
      p(kr, Tr) {
        const _r = {};
        Tr[0] & /*nodes*/
        32 && (_r.nodes = /*nodes*/
        kr[5]), !cr && Tr[0] & /*expandedNodes*/
        1 && (cr = !0, _r.expandedNodes = /*expandedNodes*/
        kr[0], add_flush_callback(() => cr = !1)), !ur && Tr[0] & /*disabledNodes*/
        2 && (ur = !0, _r.disabledNodes = /*disabledNodes*/
        kr[1], add_flush_callback(() => ur = !1)), !fr && Tr[0] & /*checkedNodes*/
        4 && (fr = !0, _r.checkedNodes = /*checkedNodes*/
        kr[2], add_flush_callback(() => fr = !1)), !dr && Tr[0] & /*indeterminateNodes*/
        8 && (dr = !0, _r.indeterminateNodes = /*indeterminateNodes*/
        kr[3], add_flush_callback(() => dr = !1)), ar.$set(_r);
      },
      i(kr) {
        hr || (transition_in(ar.$$.fragment, kr), hr = !0);
      },
      o(kr) {
        transition_out(ar.$$.fragment, kr), hr = !1;
      },
      d(kr) {
        destroy_component(ar, kr);
      }
    }
  );
}
function create_fragment$D(lr) {
  let ar, cr, ur, fr = (
    /*nodes*/
    lr[5] && /*nodes*/
    lr[5].length > 0 && create_if_block$a(lr)
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", cr = "tree " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        lr[4]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        lr[7]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[6]
      );
    },
    m(dr, hr) {
      insert(dr, ar, hr), fr && fr.m(ar, null), ur = !0;
    },
    p(dr, hr) {
      /*nodes*/
      dr[5] && /*nodes*/
      dr[5].length > 0 ? fr ? (fr.p(dr, hr), hr[0] & /*nodes*/
      32 && transition_in(fr, 1)) : (fr = create_if_block$a(dr), fr.c(), transition_in(fr, 1), fr.m(ar, null)) : fr && (group_outros(), transition_out(fr, 1, 1, () => {
        fr = null;
      }), check_outros()), (!ur || hr[0] & /*classesBase*/
      256 && cr !== (cr = "tree " + /*classesBase*/
      dr[8])) && attr(ar, "class", cr), (!ur || hr[0] & /*multiple*/
      16) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        dr[4]
      ), (!ur || hr[0] & /*labelledby*/
      128) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        dr[7]
      ), (!ur || hr[0] & /*disabled*/
      64) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        dr[6]
      );
    },
    i(dr) {
      ur || (transition_in(fr), ur = !0);
    },
    o(dr) {
      transition_out(fr), ur = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d();
    }
  };
}
function instance$i(lr, ar, cr) {
  let ur, { selection: fr = !1 } = ar, { multiple: dr = !1 } = ar, { relational: hr = !1 } = ar, { nodes: gr = [] } = ar, { expandedNodes: vr = [] } = ar, { disabledNodes: mr = [] } = ar, { checkedNodes: br = [] } = ar, { indeterminateNodes: yr = [] } = ar, { width: kr = "w-full" } = ar, { spacing: Tr = "space-y-1" } = ar, { open: _r = !1 } = ar, { disabled: Er = !1 } = ar, { padding: xr = "py-4 px-4" } = ar, { indent: Cr = "ml-4" } = ar, { hover: Ar = "hover:variant-soft" } = ar, { rounded: Lr = "rounded-container-token" } = ar, { caretOpen: Dr = "rotate-180" } = ar, { caretClosed: Nr = "" } = ar, { hyphenOpacity: Hr = "opacity-10" } = ar, { regionSummary: $r = "" } = ar, { regionSymbol: Wr = "" } = ar, { regionChildren: Zr = "" } = ar, { labelledby: oi = "" } = ar;
  setContext("open", _r), setContext("selection", fr), setContext("multiple", dr), setContext("relational", hr), setContext("disabled", Er), setContext("padding", xr), setContext("indent", Cr), setContext("hover", Ar), setContext("rounded", Lr), setContext("caretOpen", Dr), setContext("caretClosed", Nr), setContext("hyphenOpacity", Hr), setContext("regionSummary", $r), setContext("regionSymbol", Wr), setContext("regionChildren", Zr);
  const Jr = createEventDispatcher();
  function Yr(di) {
    Jr("click", { id: di.detail.id });
  }
  function li(di) {
    Jr("toggle", { id: di.detail.id });
  }
  function Si(di) {
    vr = di, cr(0, vr);
  }
  function ci(di) {
    mr = di, cr(1, mr);
  }
  function hi(di) {
    br = di, cr(2, br);
  }
  function Ei(di) {
    yr = di, cr(3, yr);
  }
  return lr.$$set = (di) => {
    cr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(di))), "selection" in di && cr(11, fr = di.selection), "multiple" in di && cr(4, dr = di.multiple), "relational" in di && cr(12, hr = di.relational), "nodes" in di && cr(5, gr = di.nodes), "expandedNodes" in di && cr(0, vr = di.expandedNodes), "disabledNodes" in di && cr(1, mr = di.disabledNodes), "checkedNodes" in di && cr(2, br = di.checkedNodes), "indeterminateNodes" in di && cr(3, yr = di.indeterminateNodes), "width" in di && cr(13, kr = di.width), "spacing" in di && cr(14, Tr = di.spacing), "open" in di && cr(15, _r = di.open), "disabled" in di && cr(6, Er = di.disabled), "padding" in di && cr(16, xr = di.padding), "indent" in di && cr(17, Cr = di.indent), "hover" in di && cr(18, Ar = di.hover), "rounded" in di && cr(19, Lr = di.rounded), "caretOpen" in di && cr(20, Dr = di.caretOpen), "caretClosed" in di && cr(21, Nr = di.caretClosed), "hyphenOpacity" in di && cr(22, Hr = di.hyphenOpacity), "regionSummary" in di && cr(23, $r = di.regionSummary), "regionSymbol" in di && cr(24, Wr = di.regionSymbol), "regionChildren" in di && cr(25, Zr = di.regionChildren), "labelledby" in di && cr(7, oi = di.labelledby);
  }, lr.$$.update = () => {
    var di;
    cr(8, ur = `${kr} ${Tr} ${(di = ar.class) != null ? di : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    mr,
    br,
    yr,
    dr,
    gr,
    Er,
    oi,
    ur,
    Yr,
    li,
    fr,
    hr,
    kr,
    Tr,
    _r,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    Si,
    ci,
    hi,
    Ei
  ];
}
class RecursiveTreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$i,
      create_fragment$D,
      safe_not_equal,
      {
        selection: 11,
        multiple: 4,
        relational: 12,
        nodes: 5,
        expandedNodes: 0,
        disabledNodes: 1,
        checkedNodes: 2,
        indeterminateNodes: 3,
        width: 13,
        spacing: 14,
        open: 15,
        disabled: 6,
        padding: 16,
        indent: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        hyphenOpacity: 22,
        regionSummary: 23,
        regionSymbol: 24,
        regionChildren: 25,
        labelledby: 7
      },
      null,
      [-1, -1]
    );
  }
  get selection() {
    return this.$$.ctx[11];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[4];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get relational() {
    return this.$$.ctx[12];
  }
  set relational(ar) {
    this.$$set({ relational: ar }), flush();
  }
  get nodes() {
    return this.$$.ctx[5];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[0];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[1];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[2];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[3];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get width() {
    return this.$$.ctx[13];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[6];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[16];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[17];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[22];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[23];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[24];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[25];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[7];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RecursiveTreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, relational: { type: "Boolean" }, nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, [], [], !0);
function create_if_block$9(lr) {
  let ar, cr, ur, fr = languageFormatter(
    /*language*/
    lr[0]
  ) + "", dr, hr, gr, vr = (/*copyState*/
  lr[7] ? (
    /*buttonCopied*/
    lr[4]
  ) : (
    /*buttonLabel*/
    lr[3]
  )) + "", mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar;
  function Lr(Hr, $r) {
    return (
      /*formatted*/
      Hr[6] ? create_if_block_1$5 : create_else_block$5
    );
  }
  let Dr = Lr(lr), Nr = Dr(lr);
  return {
    c() {
      ar = element("div"), cr = element("header"), ur = element("span"), dr = text$3(fr), hr = space(), gr = element("button"), mr = text$3(vr), kr = space(), Tr = element("pre"), _r = element("code"), Nr.c(), attr(ur, "class", "codeblock-language"), attr(gr, "class", br = "codeblock-btn " + /*button*/
      lr[2]), attr(cr, "class", "codeblock-header " + cHeader), attr(_r, "class", Er = "codeblock-code language-" + /*language*/
      lr[0] + " lineNumbers"), attr(Tr, "class", "codeblock-pre " + cPre), attr(ar, "class", xr = "codeblock " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "codeblock");
    },
    m(Hr, $r) {
      insert(Hr, ar, $r), append(ar, cr), append(cr, ur), append(ur, dr), append(cr, hr), append(cr, gr), append(gr, mr), append(ar, kr), append(ar, Tr), append(Tr, _r), Nr.m(_r, null), Cr || (Ar = [
        listen(
          gr,
          "click",
          /*onCopyClick*/
          lr[9]
        ),
        action_destroyer(yr = clipboard.call(
          null,
          gr,
          /*code*/
          lr[1]
        ))
      ], Cr = !0);
    },
    p(Hr, $r) {
      $r & /*language*/
      1 && fr !== (fr = languageFormatter(
        /*language*/
        Hr[0]
      ) + "") && set_data(dr, fr), $r & /*copyState, buttonLabel, buttonCopied*/
      152 && vr !== (vr = (/*copyState*/
      Hr[7] ? (
        /*buttonCopied*/
        Hr[4]
      ) : (
        /*buttonLabel*/
        Hr[3]
      )) + "") && set_data(mr, vr), $r & /*button*/
      4 && br !== (br = "codeblock-btn " + /*button*/
      Hr[2]) && attr(gr, "class", br), yr && is_function(yr.update) && $r & /*code*/
      2 && yr.update.call(
        null,
        /*code*/
        Hr[1]
      ), Dr === (Dr = Lr(Hr)) && Nr ? Nr.p(Hr, $r) : (Nr.d(1), Nr = Dr(Hr), Nr && (Nr.c(), Nr.m(_r, null))), $r & /*language*/
      1 && Er !== (Er = "codeblock-code language-" + /*language*/
      Hr[0] + " lineNumbers") && attr(_r, "class", Er), $r & /*classesBase*/
      256 && xr !== (xr = "codeblock " + /*classesBase*/
      Hr[8]) && attr(ar, "class", xr);
    },
    d(Hr) {
      Hr && detach(ar), Nr.d(), Cr = !1, run_all(Ar);
    }
  };
}
function create_else_block$5(lr) {
  let ar = (
    /*code*/
    lr[1].trim() + ""
  ), cr;
  return {
    c() {
      cr = text$3(ar);
    },
    m(ur, fr) {
      insert(ur, cr, fr);
    },
    p(ur, fr) {
      fr & /*code*/
      2 && ar !== (ar = /*code*/
      ur[1].trim() + "") && set_data(cr, ar);
    },
    d(ur) {
      ur && detach(cr);
    }
  };
}
function create_if_block_1$5(lr) {
  let ar, cr;
  return {
    c() {
      ar = new HtmlTag(!1), cr = empty$1(), ar.a = cr;
    },
    m(ur, fr) {
      ar.m(
        /*displayCode*/
        lr[5],
        ur,
        fr
      ), insert(ur, cr, fr);
    },
    p(ur, fr) {
      fr & /*displayCode*/
      32 && ar.p(
        /*displayCode*/
        ur[5]
      );
    },
    d(ur) {
      ur && (detach(cr), ar.d());
    }
  };
}
function create_fragment$C(lr) {
  let ar, cr = (
    /*language*/
    lr[0] && /*code*/
    lr[1] && create_if_block$9(lr)
  );
  return {
    c() {
      cr && cr.c(), ar = empty$1();
    },
    m(ur, fr) {
      cr && cr.m(ur, fr), insert(ur, ar, fr);
    },
    p(ur, [fr]) {
      /*language*/
      ur[0] && /*code*/
      ur[1] ? cr ? cr.p(ur, fr) : (cr = create_if_block$9(ur), cr.c(), cr.m(ar.parentNode, ar)) : cr && (cr.d(1), cr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), cr && cr.d(ur);
    }
  };
}
const cBase$1 = "overflow-hidden shadow", cHeader = "text-xs text-white/50 uppercase flex justify-between items-center p-2 pl-4", cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lr) {
  return lr === "js" ? "javascript" : lr === "ts" ? "typescript" : lr === "shell" ? "terminal" : lr;
}
function instance$h(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, storeHighlightJs, (Hr) => cr(17, fr = Hr));
  const dr = createEventDispatcher();
  let { language: hr = "plaintext" } = ar, { code: gr = "" } = ar, { lineNumbers: vr = !1 } = ar, { background: mr = "bg-neutral-900/90" } = ar, { blur: br = "" } = ar, { text: yr = "text-sm" } = ar, { color: kr = "text-white" } = ar, { rounded: Tr = "rounded-container-token" } = ar, { shadow: _r = "shadow" } = ar, { button: Er = "btn btn-sm variant-soft !text-white" } = ar, { buttonLabel: xr = "Copy" } = ar, { buttonCopied: Cr = "👍" } = ar, Ar = !1, Lr = gr, Dr = !1;
  function Nr() {
    cr(7, Dr = !0), setTimeout(
      () => {
        cr(7, Dr = !1);
      },
      2e3
    ), dr("copy");
  }
  return lr.$$set = (Hr) => {
    cr(19, ar = assign$1(assign$1({}, ar), exclude_internal_props(Hr))), "language" in Hr && cr(0, hr = Hr.language), "code" in Hr && cr(1, gr = Hr.code), "lineNumbers" in Hr && cr(10, vr = Hr.lineNumbers), "background" in Hr && cr(11, mr = Hr.background), "blur" in Hr && cr(12, br = Hr.blur), "text" in Hr && cr(13, yr = Hr.text), "color" in Hr && cr(14, kr = Hr.color), "rounded" in Hr && cr(15, Tr = Hr.rounded), "shadow" in Hr && cr(16, _r = Hr.shadow), "button" in Hr && cr(2, Er = Hr.button), "buttonLabel" in Hr && cr(3, xr = Hr.buttonLabel), "buttonCopied" in Hr && cr(4, Cr = Hr.buttonCopied);
  }, lr.$$.update = () => {
    var Hr;
    lr.$$.dirty & /*$storeHighlightJs, code, language*/
    131075 && fr !== void 0 && (cr(5, Lr = fr.highlight(gr, { language: hr }).value.trim()), cr(6, Ar = !0)), lr.$$.dirty & /*lineNumbers, displayCode*/
    1056 && vr && (cr(5, Lr = Lr.replace(/^/gm, () => '<span class="line"></span>	')), cr(6, Ar = !0)), cr(8, ur = `${cBase$1} ${mr} ${br} ${yr} ${kr} ${Tr} ${_r} ${(Hr = ar.class) != null ? Hr : ""}`);
  }, ar = exclude_internal_props(ar), [
    hr,
    gr,
    Er,
    xr,
    Cr,
    Lr,
    Ar,
    Dr,
    ur,
    Nr,
    vr,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    fr
  ];
}
let CodeBlock$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$h, create_fragment$C, safe_not_equal, {
      language: 0,
      code: 1,
      lineNumbers: 10,
      background: 11,
      blur: 12,
      text: 13,
      color: 14,
      rounded: 15,
      shadow: 16,
      button: 2,
      buttonLabel: 3,
      buttonCopied: 4
    });
  }
  get language() {
    return this.$$.ctx[0];
  }
  set language(ar) {
    this.$$set({ language: ar }), flush();
  }
  get code() {
    return this.$$.ctx[1];
  }
  set code(ar) {
    this.$$set({ code: ar }), flush();
  }
  get lineNumbers() {
    return this.$$.ctx[10];
  }
  set lineNumbers(ar) {
    this.$$set({ lineNumbers: ar }), flush();
  }
  get background() {
    return this.$$.ctx[11];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[12];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[16];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get button() {
    return this.$$.ctx[2];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
  get buttonLabel() {
    return this.$$.ctx[3];
  }
  set buttonLabel(ar) {
    this.$$set({ buttonLabel: ar }), flush();
  }
  get buttonCopied() {
    return this.$$.ctx[4];
  }
  set buttonCopied(ar) {
    this.$$set({ buttonCopied: ar }), flush();
  }
};
create_custom_element(CodeBlock$2, { language: {}, code: {}, lineNumbers: { type: "Boolean" }, background: {}, blur: {}, text: {}, color: {}, rounded: {}, shadow: {}, button: {}, buttonLabel: {}, buttonCopied: {} }, [], [], !0);
function create_if_block$8(lr) {
  let ar = (
    /*$modalStore*/
    lr[13]
  ), cr, ur, fr = create_key_block(lr);
  return {
    c() {
      fr.c(), cr = empty$1();
    },
    m(dr, hr) {
      fr.m(dr, hr), insert(dr, cr, hr), ur = !0;
    },
    p(dr, hr) {
      hr[0] & /*$modalStore*/
      8192 && safe_not_equal(ar, ar = /*$modalStore*/
      dr[13]) ? (group_outros(), transition_out(fr, 1, 1, noop$1), check_outros(), fr = create_key_block(dr), fr.c(), transition_in(fr, 1), fr.m(cr.parentNode, cr)) : fr.p(dr, hr);
    },
    i(dr) {
      ur || (transition_in(fr), ur = !0);
    },
    o(dr) {
      transition_out(fr), ur = !1;
    },
    d(dr) {
      dr && detach(cr), fr.d(dr);
    }
  };
}
function create_else_block$4(lr) {
  let ar, cr, ur, fr, dr, hr;
  const gr = [create_if_block_8$1, create_else_block_1$2], vr = [];
  function mr(br, yr) {
    var kr;
    return (
      /*currentComponent*/
      (kr = br[15]) != null && kr.slot ? 0 : 1
    );
  }
  return cr = mr(lr), ur = vr[cr] = gr[cr](lr), {
    c() {
      var br, yr, kr;
      ar = element("div"), ur.c(), attr(ar, "class", fr = "modal contents " + /*$modalStore*/
      ((yr = (br = lr[13][0]) == null ? void 0 : br.modalClasses) != null ? yr : "")), attr(ar, "data-testid", "modal-component"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", dr = /*$modalStore*/
      (kr = lr[13][0].title) != null ? kr : "");
    },
    m(br, yr) {
      insert(br, ar, yr), vr[cr].m(ar, null), hr = !0;
    },
    p(br, yr) {
      var Tr, _r, Er;
      let kr = cr;
      cr = mr(br), cr === kr ? vr[cr].p(br, yr) : (group_outros(), transition_out(vr[kr], 1, 1, () => {
        vr[kr] = null;
      }), check_outros(), ur = vr[cr], ur ? ur.p(br, yr) : (ur = vr[cr] = gr[cr](br), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!hr || yr[0] & /*$modalStore*/
      8192 && fr !== (fr = "modal contents " + /*$modalStore*/
      ((_r = (Tr = br[13][0]) == null ? void 0 : Tr.modalClasses) != null ? _r : ""))) && attr(ar, "class", fr), (!hr || yr[0] & /*$modalStore*/
      8192 && dr !== (dr = /*$modalStore*/
      (Er = br[13][0].title) != null ? Er : "")) && attr(ar, "aria-label", dr);
    },
    i(br) {
      hr || (transition_in(ur), hr = !0);
    },
    o(br) {
      transition_out(ur), hr = !1;
    },
    d(br) {
      br && detach(ar), vr[cr].d();
    }
  };
}
function create_if_block_1$4(lr) {
  var Tr, _r, Er, xr;
  let ar, cr, ur, fr, dr, hr, gr = (
    /*$modalStore*/
    ((Tr = lr[13][0]) == null ? void 0 : Tr.title) && create_if_block_7$2(lr)
  ), vr = (
    /*$modalStore*/
    ((_r = lr[13][0]) == null ? void 0 : _r.body) && create_if_block_6$2(lr)
  ), mr = (
    /*$modalStore*/
    ((Er = lr[13][0]) == null ? void 0 : Er.image) && typeof /*$modalStore*/
    ((xr = lr[13][0]) == null ? void 0 : xr.image) == "string" && create_if_block_5$2(lr)
  );
  function br(Cr, Ar) {
    if (
      /*$modalStore*/
      Cr[13][0].type === "alert"
    )
      return create_if_block_2$3;
    if (
      /*$modalStore*/
      Cr[13][0].type === "confirm"
    )
      return create_if_block_3$3;
    if (
      /*$modalStore*/
      Cr[13][0].type === "prompt"
    )
      return create_if_block_4$2;
  }
  let yr = br(lr), kr = yr && yr(lr);
  return {
    c() {
      var Cr;
      ar = element("div"), gr && gr.c(), cr = space(), vr && vr.c(), ur = space(), mr && mr.c(), fr = space(), kr && kr.c(), attr(ar, "class", dr = "modal " + /*classesModal*/
      lr[17]), attr(ar, "data-testid", "modal"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", hr = /*$modalStore*/
      (Cr = lr[13][0].title) != null ? Cr : "");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), gr && gr.m(ar, null), append(ar, cr), vr && vr.m(ar, null), append(ar, ur), mr && mr.m(ar, null), append(ar, fr), kr && kr.m(ar, null);
    },
    p(Cr, Ar) {
      var Lr, Dr, Nr, Hr, $r;
      /*$modalStore*/
      (Lr = Cr[13][0]) != null && Lr.title ? gr ? gr.p(Cr, Ar) : (gr = create_if_block_7$2(Cr), gr.c(), gr.m(ar, cr)) : gr && (gr.d(1), gr = null), /*$modalStore*/
      (Dr = Cr[13][0]) != null && Dr.body ? vr ? vr.p(Cr, Ar) : (vr = create_if_block_6$2(Cr), vr.c(), vr.m(ar, ur)) : vr && (vr.d(1), vr = null), /*$modalStore*/
      (Nr = Cr[13][0]) != null && Nr.image && typeof /*$modalStore*/
      ((Hr = Cr[13][0]) == null ? void 0 : Hr.image) == "string" ? mr ? mr.p(Cr, Ar) : (mr = create_if_block_5$2(Cr), mr.c(), mr.m(ar, fr)) : mr && (mr.d(1), mr = null), yr === (yr = br(Cr)) && kr ? kr.p(Cr, Ar) : (kr && kr.d(1), kr = yr && yr(Cr), kr && (kr.c(), kr.m(ar, null))), Ar[0] & /*classesModal*/
      131072 && dr !== (dr = "modal " + /*classesModal*/
      Cr[17]) && attr(ar, "class", dr), Ar[0] & /*$modalStore*/
      8192 && hr !== (hr = /*$modalStore*/
      ($r = Cr[13][0].title) != null ? $r : "") && attr(ar, "aria-label", hr);
    },
    i: noop$1,
    o: noop$1,
    d(Cr) {
      Cr && detach(ar), gr && gr.d(), vr && vr.d(), mr && mr.d(), kr && kr.d();
    }
  };
}
function create_else_block_1$2(lr) {
  var gr, vr;
  let ar, cr, ur;
  const fr = [
    /*currentComponent*/
    (gr = lr[15]) == null ? void 0 : gr.props,
    { parent: (
      /*parent*/
      lr[16]
    ) }
  ];
  var dr = (
    /*currentComponent*/
    (vr = lr[15]) == null ? void 0 : vr.ref
  );
  function hr(mr, br) {
    var kr;
    let yr = {};
    if (br !== void 0 && br[0] & /*currentComponent, parent*/
    98304)
      yr = get_spread_update(fr, [
        br[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (kr = mr[15]) == null ? void 0 : kr.props
        ),
        br[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          mr[16]
        ) }
      ]);
    else
      for (let Tr = 0; Tr < fr.length; Tr += 1)
        yr = assign$1(yr, fr[Tr]);
    return { props: yr };
  }
  return dr && (ar = construct_svelte_component(dr, hr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(mr, br) {
      ar && mount_component(ar, mr, br), insert(mr, cr, br), ur = !0;
    },
    p(mr, br) {
      var yr, kr;
      if (br[0] & /*currentComponent*/
      32768 && dr !== (dr = /*currentComponent*/
      (yr = mr[15]) == null ? void 0 : yr.ref)) {
        if (ar) {
          group_outros();
          const Tr = ar;
          transition_out(Tr.$$.fragment, 1, 0, () => {
            destroy_component(Tr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, hr(mr, br)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const Tr = br[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(fr, [
          br[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (kr = mr[15]) == null ? void 0 : kr.props
          ),
          br[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            mr[16]
          ) }
        ]) : {};
        ar.$set(Tr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(cr), ar && destroy_component(ar, mr);
    }
  };
}
function create_if_block_8$1(lr) {
  var gr, vr;
  let ar, cr, ur;
  const fr = [
    /*currentComponent*/
    (gr = lr[15]) == null ? void 0 : gr.props,
    { parent: (
      /*parent*/
      lr[16]
    ) }
  ];
  var dr = (
    /*currentComponent*/
    (vr = lr[15]) == null ? void 0 : vr.ref
  );
  function hr(mr, br) {
    var kr;
    let yr = {
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx: mr }
    };
    if (br !== void 0 && br[0] & /*currentComponent, parent*/
    98304)
      yr = get_spread_update(fr, [
        br[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (kr = mr[15]) == null ? void 0 : kr.props
        ),
        br[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          mr[16]
        ) }
      ]);
    else
      for (let Tr = 0; Tr < fr.length; Tr += 1)
        yr = assign$1(yr, fr[Tr]);
    return { props: yr };
  }
  return dr && (ar = construct_svelte_component(dr, hr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(mr, br) {
      ar && mount_component(ar, mr, br), insert(mr, cr, br), ur = !0;
    },
    p(mr, br) {
      var yr, kr;
      if (br[0] & /*currentComponent*/
      32768 && dr !== (dr = /*currentComponent*/
      (yr = mr[15]) == null ? void 0 : yr.ref)) {
        if (ar) {
          group_outros();
          const Tr = ar;
          transition_out(Tr.$$.fragment, 1, 0, () => {
            destroy_component(Tr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, hr(mr, br)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const Tr = br[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(fr, [
          br[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (kr = mr[15]) == null ? void 0 : kr.props
          ),
          br[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            mr[16]
          ) }
        ]) : {};
        br[0] & /*currentComponent*/
        32768 | br[1] & /*$$scope*/
        65536 && (Tr.$$scope = { dirty: br, ctx: mr }), ar.$set(Tr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(cr), ar && destroy_component(ar, mr);
    }
  };
}
function create_default_slot$1(lr) {
  var fr;
  let ar, cr = (
    /*currentComponent*/
    ((fr = lr[15]) == null ? void 0 : fr.slot) + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(dr, hr) {
      ar.m(cr, dr, hr), insert(dr, ur, hr);
    },
    p(dr, hr) {
      var gr;
      hr[0] & /*currentComponent*/
      32768 && cr !== (cr = /*currentComponent*/
      ((gr = dr[15]) == null ? void 0 : gr.slot) + "") && ar.p(cr);
    },
    d(dr) {
      dr && (detach(ur), ar.d());
    }
  };
}
function create_if_block_7$2(lr) {
  let ar, cr = (
    /*$modalStore*/
    lr[13][0].title + ""
  ), ur;
  return {
    c() {
      ar = element("header"), attr(ar, "class", ur = "modal-header " + /*regionHeader*/
      lr[5]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr[0] & /*$modalStore*/
      8192 && cr !== (cr = /*$modalStore*/
      fr[13][0].title + "") && (ar.innerHTML = cr), dr[0] & /*regionHeader*/
      32 && ur !== (ur = "modal-header " + /*regionHeader*/
      fr[5]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_6$2(lr) {
  let ar, cr = (
    /*$modalStore*/
    lr[13][0].body + ""
  ), ur;
  return {
    c() {
      ar = element("article"), attr(ar, "class", ur = "modal-body " + /*regionBody*/
      lr[6]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr[0] & /*$modalStore*/
      8192 && cr !== (cr = /*$modalStore*/
      fr[13][0].body + "") && (ar.innerHTML = cr), dr[0] & /*regionBody*/
      64 && ur !== (ur = "modal-body " + /*regionBody*/
      fr[6]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_5$2(lr) {
  let ar, cr;
  return {
    c() {
      var ur;
      ar = element("img"), attr(ar, "class", "modal-image " + cModalImage), src_url_equal(ar.src, cr = /*$modalStore*/
      (ur = lr[13][0]) == null ? void 0 : ur.image) || attr(ar, "src", cr), attr(ar, "alt", "Modal");
    },
    m(ur, fr) {
      insert(ur, ar, fr);
    },
    p(ur, fr) {
      var dr;
      fr[0] & /*$modalStore*/
      8192 && !src_url_equal(ar.src, cr = /*$modalStore*/
      (dr = ur[13][0]) == null ? void 0 : dr.image) && attr(ar, "src", cr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_4$2(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er = [
    { class: "modal-prompt-input input" },
    { name: "prompt" },
    { type: "text" },
    /*$modalStore*/
    lr[13][0].valueAttr
  ], xr = {};
  for (let Cr = 0; Cr < Er.length; Cr += 1)
    xr = assign$1(xr, Er[Cr]);
  return {
    c() {
      ar = element("form"), cr = element("input"), ur = space(), fr = element("footer"), dr = element("button"), hr = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), vr = space(), mr = element("button"), br = text$3(
        /*buttonTextSubmit*/
        lr[2]
      ), set_attributes(cr, xr), attr(dr, "type", "button"), attr(dr, "class", gr = "btn " + /*buttonNeutral*/
      lr[3]), attr(mr, "type", "submit"), attr(mr, "class", yr = "btn " + /*buttonPositive*/
      lr[4]), attr(fr, "class", kr = "modal-footer " + /*regionFooter*/
      lr[7]), attr(ar, "class", "space-y-4");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), cr.autofocus && cr.focus(), set_input_value(
        cr,
        /*promptValue*/
        lr[14]
      ), append(ar, ur), append(ar, fr), append(fr, dr), append(dr, hr), append(fr, vr), append(fr, mr), append(mr, br), Tr || (_r = [
        listen(
          cr,
          "input",
          /*input_input_handler*/
          lr[41]
        ),
        listen(
          dr,
          "click",
          /*onClose*/
          lr[23]
        ),
        listen(
          ar,
          "submit",
          /*onPromptSubmit*/
          lr[25]
        )
      ], Tr = !0);
    },
    p(Cr, Ar) {
      set_attributes(cr, xr = get_spread_update(Er, [
        { class: "modal-prompt-input input" },
        { name: "prompt" },
        { type: "text" },
        Ar[0] & /*$modalStore*/
        8192 && /*$modalStore*/
        Cr[13][0].valueAttr
      ])), Ar[0] & /*promptValue*/
      16384 && cr.value !== /*promptValue*/
      Cr[14] && set_input_value(
        cr,
        /*promptValue*/
        Cr[14]
      ), Ar[0] & /*buttonTextCancel*/
      1 && set_data(
        hr,
        /*buttonTextCancel*/
        Cr[0]
      ), Ar[0] & /*buttonNeutral*/
      8 && gr !== (gr = "btn " + /*buttonNeutral*/
      Cr[3]) && attr(dr, "class", gr), Ar[0] & /*buttonTextSubmit*/
      4 && set_data(
        br,
        /*buttonTextSubmit*/
        Cr[2]
      ), Ar[0] & /*buttonPositive*/
      16 && yr !== (yr = "btn " + /*buttonPositive*/
      Cr[4]) && attr(mr, "class", yr), Ar[0] & /*regionFooter*/
      128 && kr !== (kr = "modal-footer " + /*regionFooter*/
      Cr[7]) && attr(fr, "class", kr);
    },
    d(Cr) {
      Cr && detach(ar), Tr = !1, run_all(_r);
    }
  };
}
function create_if_block_3$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr;
  return {
    c() {
      ar = element("footer"), cr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), dr = space(), hr = element("button"), gr = text$3(
        /*buttonTextConfirm*/
        lr[1]
      ), attr(cr, "type", "button"), attr(cr, "class", fr = "btn " + /*buttonNeutral*/
      lr[3]), attr(hr, "type", "button"), attr(hr, "class", vr = "btn " + /*buttonPositive*/
      lr[4]), attr(ar, "class", mr = "modal-footer " + /*regionFooter*/
      lr[7]);
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), append(ar, cr), append(cr, ur), append(ar, dr), append(ar, hr), append(hr, gr), br || (yr = [
        listen(
          cr,
          "click",
          /*onClose*/
          lr[23]
        ),
        listen(
          hr,
          "click",
          /*onConfirm*/
          lr[24]
        )
      ], br = !0);
    },
    p(kr, Tr) {
      Tr[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        kr[0]
      ), Tr[0] & /*buttonNeutral*/
      8 && fr !== (fr = "btn " + /*buttonNeutral*/
      kr[3]) && attr(cr, "class", fr), Tr[0] & /*buttonTextConfirm*/
      2 && set_data(
        gr,
        /*buttonTextConfirm*/
        kr[1]
      ), Tr[0] & /*buttonPositive*/
      16 && vr !== (vr = "btn " + /*buttonPositive*/
      kr[4]) && attr(hr, "class", vr), Tr[0] & /*regionFooter*/
      128 && mr !== (mr = "modal-footer " + /*regionFooter*/
      kr[7]) && attr(ar, "class", mr);
    },
    d(kr) {
      kr && detach(ar), br = !1, run_all(yr);
    }
  };
}
function create_if_block_2$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr;
  return {
    c() {
      ar = element("footer"), cr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), attr(cr, "type", "button"), attr(cr, "class", fr = "btn " + /*buttonNeutral*/
      lr[3]), attr(ar, "class", dr = "modal-footer " + /*regionFooter*/
      lr[7]);
    },
    m(vr, mr) {
      insert(vr, ar, mr), append(ar, cr), append(cr, ur), hr || (gr = listen(
        cr,
        "click",
        /*onClose*/
        lr[23]
      ), hr = !0);
    },
    p(vr, mr) {
      mr[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        vr[0]
      ), mr[0] & /*buttonNeutral*/
      8 && fr !== (fr = "btn " + /*buttonNeutral*/
      vr[3]) && attr(cr, "class", fr), mr[0] & /*regionFooter*/
      128 && dr !== (dr = "modal-footer " + /*regionFooter*/
      vr[7]) && attr(ar, "class", dr);
    },
    d(vr) {
      vr && detach(ar), hr = !1, gr();
    }
  };
}
function create_key_block(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr;
  const Tr = [create_if_block_1$4, create_else_block$4], _r = [];
  function Er(xr, Cr) {
    return (
      /*$modalStore*/
      xr[13][0].type !== "component" ? 0 : 1
    );
  }
  return ur = Er(lr), fr = _r[ur] = Tr[ur](lr), {
    c() {
      ar = element("div"), cr = element("div"), fr.c(), attr(cr, "class", dr = "modal-transition " + /*classesTransitionLayer*/
      lr[18]), attr(ar, "class", vr = "modal-backdrop " + /*classesBackdrop*/
      lr[19]), attr(ar, "data-testid", "modal-backdrop");
    },
    m(xr, Cr) {
      insert(xr, ar, Cr), append(ar, cr), _r[ur].m(cr, null), br = !0, yr || (kr = [
        listen(
          ar,
          "mousedown",
          /*onBackdropInteractionBegin*/
          lr[21]
        ),
        listen(
          ar,
          "mouseup",
          /*onBackdropInteractionEnd*/
          lr[22]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          lr[39],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          lr[40],
          { passive: !0 }
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], yr = !0);
    },
    p(xr, Cr) {
      lr = xr;
      let Ar = ur;
      ur = Er(lr), ur === Ar ? _r[ur].p(lr, Cr) : (group_outros(), transition_out(_r[Ar], 1, 1, () => {
        _r[Ar] = null;
      }), check_outros(), fr = _r[ur], fr ? fr.p(lr, Cr) : (fr = _r[ur] = Tr[ur](lr), fr.c()), transition_in(fr, 1), fr.m(cr, null)), (!br || Cr[0] & /*classesTransitionLayer*/
      262144 && dr !== (dr = "modal-transition " + /*classesTransitionLayer*/
      lr[18])) && attr(cr, "class", dr), (!br || Cr[0] & /*classesBackdrop*/
      524288 && vr !== (vr = "modal-backdrop " + /*classesBackdrop*/
      lr[19])) && attr(ar, "class", vr);
    },
    i(xr) {
      br || (transition_in(fr), add_render_callback(() => {
        br && (gr && gr.end(1), hr = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[9]
          ),
          params: (
            /*transitionInParams*/
            lr[10]
          ),
          enabled: (
            /*transitions*/
            lr[8]
          )
        }), hr.start());
      }), add_render_callback(() => {
        br && (mr || (mr = create_bidirectional_transition(
          ar,
          dynamicTransition,
          {
            transition: fade,
            params: { duration: 150 },
            enabled: (
              /*transitions*/
              lr[8]
            )
          },
          !0
        )), mr.run(1));
      }), br = !0);
    },
    o(xr) {
      transition_out(fr), hr && hr.invalidate(), gr = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[11]
        ),
        params: (
          /*transitionOutParams*/
          lr[12]
        ),
        enabled: (
          /*transitions*/
          lr[8]
        )
      }), mr || (mr = create_bidirectional_transition(
        ar,
        dynamicTransition,
        {
          transition: fade,
          params: { duration: 150 },
          enabled: (
            /*transitions*/
            lr[8]
          )
        },
        !1
      )), mr.run(0), br = !1;
    },
    d(xr) {
      xr && detach(ar), _r[ur].d(), xr && gr && gr.end(), xr && mr && mr.end(), yr = !1, run_all(kr);
    }
  };
}
function create_fragment$B(lr) {
  let ar, cr, ur, fr, dr = (
    /*$modalStore*/
    lr[13].length > 0 && create_if_block$8(lr)
  );
  return {
    c() {
      dr && dr.c(), ar = empty$1();
    },
    m(hr, gr) {
      dr && dr.m(hr, gr), insert(hr, ar, gr), cr = !0, ur || (fr = listen(
        window,
        "keydown",
        /*onKeyDown*/
        lr[26]
      ), ur = !0);
    },
    p(hr, gr) {
      /*$modalStore*/
      hr[13].length > 0 ? dr ? (dr.p(hr, gr), gr[0] & /*$modalStore*/
      8192 && transition_in(dr, 1)) : (dr = create_if_block$8(hr), dr.c(), transition_in(dr, 1), dr.m(ar.parentNode, ar)) : dr && (group_outros(), transition_out(dr, 1, 1, () => {
        dr = null;
      }), check_outros());
    },
    i(hr) {
      cr || (transition_in(dr), cr = !0);
    },
    o(hr) {
      transition_out(dr), cr = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr), ur = !1, fr();
    }
  };
}
const cBackdrop$1 = "fixed top-0 left-0 right-0 bottom-0 overflow-y-auto", cTransitionLayer = "w-full h-fit min-h-full p-4 overflow-y-auto flex justify-center", cModal = "block overflow-y-auto", cModalImage = "w-full h-auto";
function instance$g(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr;
  component_subscribe(lr, prefersReducedMotionStore, (Ni) => cr(43, mr = Ni));
  const br = createEventDispatcher();
  let { position: yr = "items-center" } = ar, { components: kr = {} } = ar, { background: Tr = "bg-surface-100-800-token" } = ar, { width: _r = "w-modal" } = ar, { height: Er = "h-auto" } = ar, { padding: xr = "p-4" } = ar, { spacing: Cr = "space-y-4" } = ar, { rounded: Ar = "rounded-container-token" } = ar, { shadow: Lr = "shadow-xl" } = ar, { zIndex: Dr = "z-[999]" } = ar, { buttonNeutral: Nr = "variant-ghost-surface" } = ar, { buttonPositive: Hr = "variant-filled" } = ar, { buttonTextCancel: $r = "Cancel" } = ar, { buttonTextConfirm: Wr = "Confirm" } = ar, { buttonTextSubmit: Zr = "Submit" } = ar, { regionBackdrop: oi = "bg-surface-backdrop-token" } = ar, { regionHeader: Jr = "text-2xl font-bold" } = ar, { regionBody: Yr = "max-h-[200px] overflow-hidden" } = ar, { regionFooter: li = "flex justify-end space-x-2" } = ar, { transitions: Si = !mr } = ar, { transitionIn: ci = fly } = ar, { transitionInParams: hi = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, { transitionOut: Ei = fly } = ar, { transitionOutParams: di = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, gi;
  const Li = {
    buttonTextCancel: $r,
    buttonTextConfirm: Wr,
    buttonTextSubmit: Zr
  };
  let ui, wi = !1;
  const Ui = getModalStore();
  component_subscribe(lr, Ui, (Ni) => cr(13, vr = Ni)), Ui.subscribe((Ni) => {
    Ni.length && (Ni[0].type === "prompt" && cr(14, gi = Ni[0].value), cr(0, $r = Ni[0].buttonTextCancel || Li.buttonTextCancel), cr(1, Wr = Ni[0].buttonTextConfirm || Li.buttonTextConfirm), cr(2, Zr = Ni[0].buttonTextSubmit || Li.buttonTextSubmit), cr(15, ui = typeof Ni[0].component == "string" ? kr[Ni[0].component] : Ni[0].component));
  });
  function yi(Ni) {
    if (!(Ni.target instanceof Element))
      return;
    const ia = Ni.target.classList;
    (ia.contains("modal-backdrop") || ia.contains("modal-transition")) && (wi = !0);
  }
  function Vi(Ni) {
    if (!(Ni.target instanceof Element))
      return;
    const ia = Ni.target.classList;
    (ia.contains("modal-backdrop") || ia.contains("modal-transition")) && wi && (vr[0].response && vr[0].response(void 0), Ui.close(), br("backdrop", Ni)), wi = !1;
  }
  function Oi() {
    vr[0].response && vr[0].response(!1), Ui.close();
  }
  function Mi() {
    vr[0].response && vr[0].response(!0), Ui.close();
  }
  function Ii(Ni) {
    Ni.preventDefault(), vr[0].response && vr[0].response(gi), Ui.close();
  }
  function mi(Ni) {
    vr.length && Ni.code === "Escape" && Oi();
  }
  function _i(Ni) {
    bubble.call(this, lr, Ni);
  }
  function Ci(Ni) {
    bubble.call(this, lr, Ni);
  }
  function Ki() {
    gi = this.value, cr(14, gi);
  }
  return lr.$$set = (Ni) => {
    cr(46, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ni))), "position" in Ni && cr(27, yr = Ni.position), "components" in Ni && cr(28, kr = Ni.components), "background" in Ni && cr(29, Tr = Ni.background), "width" in Ni && cr(30, _r = Ni.width), "height" in Ni && cr(31, Er = Ni.height), "padding" in Ni && cr(32, xr = Ni.padding), "spacing" in Ni && cr(33, Cr = Ni.spacing), "rounded" in Ni && cr(34, Ar = Ni.rounded), "shadow" in Ni && cr(35, Lr = Ni.shadow), "zIndex" in Ni && cr(36, Dr = Ni.zIndex), "buttonNeutral" in Ni && cr(3, Nr = Ni.buttonNeutral), "buttonPositive" in Ni && cr(4, Hr = Ni.buttonPositive), "buttonTextCancel" in Ni && cr(0, $r = Ni.buttonTextCancel), "buttonTextConfirm" in Ni && cr(1, Wr = Ni.buttonTextConfirm), "buttonTextSubmit" in Ni && cr(2, Zr = Ni.buttonTextSubmit), "regionBackdrop" in Ni && cr(37, oi = Ni.regionBackdrop), "regionHeader" in Ni && cr(5, Jr = Ni.regionHeader), "regionBody" in Ni && cr(6, Yr = Ni.regionBody), "regionFooter" in Ni && cr(7, li = Ni.regionFooter), "transitions" in Ni && cr(8, Si = Ni.transitions), "transitionIn" in Ni && cr(9, ci = Ni.transitionIn), "transitionInParams" in Ni && cr(10, hi = Ni.transitionInParams), "transitionOut" in Ni && cr(11, Ei = Ni.transitionOut), "transitionOutParams" in Ni && cr(12, di = Ni.transitionOutParams);
  }, lr.$$.update = () => {
    var Ni, ia, ea, la, ma, Ba, Fa;
    lr.$$.dirty[0] & /*$modalStore, position*/
    134225920 && cr(38, ur = (ia = (Ni = vr[0]) == null ? void 0 : Ni.position) != null ? ia : yr), cr(19, fr = `${cBackdrop$1} ${oi} ${Dr} ${(ea = ar.class) != null ? ea : ""} ${(ma = (la = vr[0]) == null ? void 0 : la.backdropClasses) != null ? ma : ""}`), lr.$$.dirty[1] & /*cPosition*/
    128 && cr(18, dr = `${cTransitionLayer} ${ur != null ? ur : ""}`), lr.$$.dirty[0] & /*background, width, $modalStore*/
    1610620928 | lr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow*/
    31 && cr(17, hr = `${cModal} ${Tr} ${_r} ${Er} ${xr} ${Cr} ${Ar} ${Lr} ${(Fa = (Ba = vr[0]) == null ? void 0 : Ba.modalClasses) != null ? Fa : ""}`), lr.$$.dirty[0] & /*position, background, width, buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionHeader, regionBody, regionFooter*/
    1744830719 | lr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow, regionBackdrop*/
    95 && cr(16, gr = {
      position: yr,
      // ---
      background: Tr,
      width: _r,
      height: Er,
      padding: xr,
      spacing: Cr,
      rounded: Ar,
      shadow: Lr,
      // ---
      buttonNeutral: Nr,
      buttonPositive: Hr,
      buttonTextCancel: $r,
      buttonTextConfirm: Wr,
      buttonTextSubmit: Zr,
      // ---
      regionBackdrop: oi,
      regionHeader: Jr,
      regionBody: Yr,
      regionFooter: li,
      // ---
      onClose: Oi
    });
  }, ar = exclude_internal_props(ar), [
    $r,
    Wr,
    Zr,
    Nr,
    Hr,
    Jr,
    Yr,
    li,
    Si,
    ci,
    hi,
    Ei,
    di,
    vr,
    gi,
    ui,
    gr,
    hr,
    dr,
    fr,
    Ui,
    yi,
    Vi,
    Oi,
    Mi,
    Ii,
    mi,
    yr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    oi,
    ur,
    _i,
    Ci,
    Ki
  ];
}
class Modal extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$g,
      create_fragment$B,
      safe_not_equal,
      {
        position: 27,
        components: 28,
        background: 29,
        width: 30,
        height: 31,
        padding: 32,
        spacing: 33,
        rounded: 34,
        shadow: 35,
        zIndex: 36,
        buttonNeutral: 3,
        buttonPositive: 4,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 37,
        regionHeader: 5,
        regionBody: 6,
        regionFooter: 7,
        transitions: 8,
        transitionIn: 9,
        transitionInParams: 10,
        transitionOut: 11,
        transitionOutParams: 12
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[27];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get components() {
    return this.$$.ctx[28];
  }
  set components(ar) {
    this.$$set({ components: ar }), flush();
  }
  get background() {
    return this.$$.ctx[29];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[30];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[31];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[32];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[33];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[35];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[36];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonNeutral() {
    return this.$$.ctx[3];
  }
  set buttonNeutral(ar) {
    this.$$set({ buttonNeutral: ar }), flush();
  }
  get buttonPositive() {
    return this.$$.ctx[4];
  }
  set buttonPositive(ar) {
    this.$$set({ buttonPositive: ar }), flush();
  }
  get buttonTextCancel() {
    return this.$$.ctx[0];
  }
  set buttonTextCancel(ar) {
    this.$$set({ buttonTextCancel: ar }), flush();
  }
  get buttonTextConfirm() {
    return this.$$.ctx[1];
  }
  set buttonTextConfirm(ar) {
    this.$$set({ buttonTextConfirm: ar }), flush();
  }
  get buttonTextSubmit() {
    return this.$$.ctx[2];
  }
  set buttonTextSubmit(ar) {
    this.$$set({ buttonTextSubmit: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[37];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[5];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[6];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionFooter() {
    return this.$$.ctx[7];
  }
  set regionFooter(ar) {
    this.$$set({ regionFooter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[8];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[9];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[10];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[11];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[12];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Modal, { position: {}, components: {}, background: {}, width: {}, height: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonNeutral: {}, buttonPositive: {}, buttonTextCancel: {}, buttonTextConfirm: {}, buttonTextSubmit: {}, regionBackdrop: {}, regionHeader: {}, regionBody: {}, regionFooter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
const { window: window_1 } = globals;
function create_if_block$7(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr;
  const kr = (
    /*#slots*/
    lr[32].default
  ), Tr = create_slot(
    kr,
    lr,
    /*$$scope*/
    lr[31],
    null
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), Tr && Tr.c(), attr(cr, "class", ur = "drawer " + /*classesDrawer*/
      lr[8]), attr(cr, "data-testid", "drawer"), attr(cr, "role", "dialog"), attr(cr, "aria-modal", "true"), attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(
        cr,
        "aria-describedby",
        /*describedby*/
        lr[1]
      ), attr(ar, "class", hr = "drawer-backdrop " + /*classesBackdrop*/
      lr[9]), attr(ar, "data-testid", "drawer-backdrop");
    },
    m(_r, Er) {
      insert(_r, ar, Er), append(ar, cr), Tr && Tr.m(cr, null), lr[36](cr), lr[37](ar), mr = !0, br || (yr = [
        listen(
          ar,
          "mousedown",
          /*onDrawerInteraction*/
          lr[12]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          lr[33],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          lr[34],
          { passive: !0 }
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[35]
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], br = !0);
    },
    p(_r, Er) {
      lr = _r, Tr && Tr.p && (!mr || Er[1] & /*$$scope*/
      1) && update_slot_base(
        Tr,
        kr,
        lr,
        /*$$scope*/
        lr[31],
        mr ? get_slot_changes(
          kr,
          /*$$scope*/
          lr[31],
          Er,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          lr[31]
        ),
        null
      ), (!mr || Er[0] & /*classesDrawer*/
      256 && ur !== (ur = "drawer " + /*classesDrawer*/
      lr[8])) && attr(cr, "class", ur), (!mr || Er[0] & /*labelledby*/
      1) && attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), (!mr || Er[0] & /*describedby*/
      2) && attr(
        cr,
        "aria-describedby",
        /*describedby*/
        lr[1]
      ), (!mr || Er[0] & /*classesBackdrop*/
      512 && hr !== (hr = "drawer-backdrop " + /*classesBackdrop*/
      lr[9])) && attr(ar, "class", hr);
    },
    i(_r) {
      mr || (transition_in(Tr, _r), _r && add_render_callback(() => {
        mr && (dr && dr.end(1), fr = create_in_transition(cr, dynamicTransition, {
          transition: fly,
          params: {
            x: (
              /*anim*/
              lr[7].x
            ),
            y: (
              /*anim*/
              lr[7].y
            ),
            duration: (
              /*duration*/
              lr[2]
            ),
            opacity: (
              /*opacityTransition*/
              lr[3] ? void 0 : 1
            )
          },
          enabled: (
            /*transitions*/
            lr[4]
          )
        }), fr.start());
      }), _r && add_render_callback(() => {
        mr && (vr && vr.end(1), gr = create_in_transition(ar, dynamicTransition, {
          transition: fade,
          params: { duration: (
            /*duration*/
            lr[2]
          ) },
          enabled: (
            /*transitions*/
            lr[4] && /*opacityTransition*/
            lr[3]
          )
        }), gr.start());
      }), mr = !0);
    },
    o(_r) {
      transition_out(Tr, _r), fr && fr.invalidate(), _r && (dr = create_out_transition(cr, dynamicTransition, {
        transition: fly,
        params: {
          x: (
            /*anim*/
            lr[7].x
          ),
          y: (
            /*anim*/
            lr[7].y
          ),
          duration: (
            /*duration*/
            lr[2]
          ),
          opacity: (
            /*opacityTransition*/
            lr[3] ? void 0 : 1
          ),
          easing: cubicIn
        },
        enabled: (
          /*transitions*/
          lr[4]
        )
      })), gr && gr.invalidate(), _r && (vr = create_out_transition(ar, dynamicTransition, {
        transition: fade,
        params: { duration: (
          /*duration*/
          lr[2]
        ) },
        enabled: (
          /*transitions*/
          lr[4] && /*opacityTransition*/
          lr[3]
        )
      })), mr = !1;
    },
    d(_r) {
      _r && detach(ar), Tr && Tr.d(_r), lr[36](null), _r && dr && dr.end(), lr[37](null), _r && vr && vr.end(), br = !1, run_all(yr);
    }
  };
}
function create_fragment$A(lr) {
  let ar, cr, ur, fr, dr = (
    /*$drawerStore*/
    lr[10].open === !0 && create_if_block$7(lr)
  );
  return {
    c() {
      dr && dr.c(), ar = empty$1();
    },
    m(hr, gr) {
      dr && dr.m(hr, gr), insert(hr, ar, gr), cr = !0, ur || (fr = listen(
        window_1,
        "keydown",
        /*onKeydownWindow*/
        lr[13]
      ), ur = !0);
    },
    p(hr, gr) {
      /*$drawerStore*/
      hr[10].open === !0 ? dr ? (dr.p(hr, gr), gr[0] & /*$drawerStore*/
      1024 && transition_in(dr, 1)) : (dr = create_if_block$7(hr), dr.c(), transition_in(dr, 1), dr.m(ar.parentNode, ar)) : dr && (group_outros(), transition_out(dr, 1, 1, () => {
        dr = null;
      }), check_outros());
    },
    i(hr) {
      cr || (transition_in(dr), cr = !0);
    },
    o(hr) {
      transition_out(dr), cr = !1;
    },
    d(hr) {
      hr && detach(ar), dr && dr.d(hr), ur = !1, fr();
    }
  };
}
const cBackdrop = "fixed top-0 left-0 right-0 bottom-0 flex", cDrawer = "overflow-y-auto transition-transform";
function instance$f(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br;
  component_subscribe(lr, prefersReducedMotionStore, (Ci) => cr(38, br = Ci));
  let { $$slots: yr = {}, $$scope: kr } = ar;
  const Tr = createEventDispatcher();
  let { position: _r = "left" } = ar, { bgDrawer: Er = "bg-surface-100-800-token" } = ar, { border: xr = "" } = ar, { rounded: Cr = "" } = ar, { shadow: Ar = "shadow-xl" } = ar, { width: Lr = "" } = ar, { height: Dr = "" } = ar, { bgBackdrop: Nr = "bg-surface-backdrop-token" } = ar, { blur: Hr = "" } = ar, { padding: $r = "" } = ar, { zIndex: Wr = "z-40" } = ar, { regionBackdrop: Zr = "" } = ar, { regionDrawer: oi = "" } = ar, { labelledby: Jr = "" } = ar, { describedby: Yr = "" } = ar, { duration: li = 200 } = ar, { transitions: Si = !br } = ar, { opacityTransition: ci = !0 } = ar;
  const hi = {
    top: {
      alignment: "items-start",
      width: "w-full",
      height: "h-[50%]",
      rounded: "rounded-bl-container-token rounded-br-container-token"
    },
    bottom: {
      alignment: "items-end",
      width: "w-full",
      height: " h-[50%]",
      rounded: "rounded-tl-container-token rounded-tr-container-token"
    },
    left: {
      alignment: "justify-start",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tr-container-token rounded-br-container-token"
    },
    right: {
      alignment: "justify-end",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tl-container-token rounded-bl-container-token"
    }
  };
  let Ei, di, gi = { x: 0, y: 0 };
  const Li = getDrawerStore();
  component_subscribe(lr, Li, (Ci) => cr(10, mr = Ci));
  const ui = {
    position: _r,
    bgBackdrop: Nr,
    blur: Hr,
    padding: $r,
    bgDrawer: Er,
    border: xr,
    rounded: Cr,
    shadow: Ar,
    width: Lr,
    height: Dr,
    opacityTransition: ci,
    regionBackdrop: Zr,
    regionDrawer: oi,
    labelledby: Jr,
    describedby: Yr,
    duration: li
  };
  function wi(Ci) {
    cr(14, _r = Ci.position || ui.position), cr(21, Nr = Ci.bgBackdrop || ui.bgBackdrop), cr(22, Hr = Ci.blur || ui.blur), cr(23, $r = Ci.padding || ui.padding), cr(15, Er = Ci.bgDrawer || ui.bgDrawer), cr(16, xr = Ci.border || ui.border), cr(17, Cr = Ci.rounded || ui.rounded), cr(18, Ar = Ci.shadow || ui.shadow), cr(19, Lr = Ci.width || ui.width), cr(20, Dr = Ci.height || ui.height), cr(24, Zr = Ci.regionBackdrop || ui.regionBackdrop), cr(25, oi = Ci.regionDrawer || ui.regionDrawer), cr(0, Jr = Ci.labelledby || ui.labelledby), cr(1, Yr = Ci.describedby || ui.describedby), cr(3, ci = Ci.opacityTransition || ui.opacityTransition), cr(2, li = Ci.duration || ui.duration);
  }
  function Ui() {
    switch (_r) {
      case "top":
        cr(7, gi = { x: 0, y: -window.innerWidth });
        break;
      case "bottom":
        cr(7, gi = { x: 0, y: window.innerWidth });
        break;
      case "left":
        cr(7, gi = { x: -window.innerHeight, y: 0 });
        break;
      case "right":
        cr(7, gi = { x: window.innerHeight, y: 0 });
        break;
      default:
        console.error("Error: unknown position property value.");
        break;
    }
  }
  function yi(Ci) {
    Ci.target === Ei ? (Li.close(), Tr("backdrop", Ci)) : Tr("drawer", Ci);
  }
  function Vi(Ci) {
    mr && Ci.code === "Escape" && Li.close();
  }
  Li.subscribe((Ci) => {
    Ci.open === !0 && (wi(Ci), Ui());
  });
  function Oi(Ci) {
    bubble.call(this, lr, Ci);
  }
  function Mi(Ci) {
    bubble.call(this, lr, Ci);
  }
  function Ii(Ci) {
    bubble.call(this, lr, Ci);
  }
  function mi(Ci) {
    binding_callbacks[Ci ? "unshift" : "push"](() => {
      di = Ci, cr(6, di);
    });
  }
  function _i(Ci) {
    binding_callbacks[Ci ? "unshift" : "push"](() => {
      Ei = Ci, cr(5, Ei);
    });
  }
  return lr.$$set = (Ci) => {
    cr(44, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ci))), "position" in Ci && cr(14, _r = Ci.position), "bgDrawer" in Ci && cr(15, Er = Ci.bgDrawer), "border" in Ci && cr(16, xr = Ci.border), "rounded" in Ci && cr(17, Cr = Ci.rounded), "shadow" in Ci && cr(18, Ar = Ci.shadow), "width" in Ci && cr(19, Lr = Ci.width), "height" in Ci && cr(20, Dr = Ci.height), "bgBackdrop" in Ci && cr(21, Nr = Ci.bgBackdrop), "blur" in Ci && cr(22, Hr = Ci.blur), "padding" in Ci && cr(23, $r = Ci.padding), "zIndex" in Ci && cr(26, Wr = Ci.zIndex), "regionBackdrop" in Ci && cr(24, Zr = Ci.regionBackdrop), "regionDrawer" in Ci && cr(25, oi = Ci.regionDrawer), "labelledby" in Ci && cr(0, Jr = Ci.labelledby), "describedby" in Ci && cr(1, Yr = Ci.describedby), "duration" in Ci && cr(2, li = Ci.duration), "transitions" in Ci && cr(4, Si = Ci.transitions), "opacityTransition" in Ci && cr(3, ci = Ci.opacityTransition), "$$scope" in Ci && cr(31, kr = Ci.$$scope);
  }, lr.$$.update = () => {
    var Ci;
    lr.$$.dirty[0] & /*position*/
    16384 && cr(30, ur = hi[_r].alignment), lr.$$.dirty[0] & /*width, position*/
    540672 && cr(29, fr = Lr || hi[_r].width), lr.$$.dirty[0] & /*height, position*/
    1064960 && cr(28, dr = Dr || hi[_r].height), lr.$$.dirty[0] & /*rounded, position*/
    147456 && cr(27, hr = Cr || hi[_r].rounded), cr(9, gr = `${cBackdrop} ${Nr} ${$r} ${Hr} ${ur} ${Zr} ${Wr} ${(Ci = ar.class) != null ? Ci : ""}`), lr.$$.dirty[0] & /*bgDrawer, border, rounded, shadow, classesWidth, classesHeight, classesRounded, regionDrawer*/
    973570048 && cr(8, vr = `${cDrawer} ${Er} ${xr} ${Cr} ${Ar} ${fr} ${dr} ${hr} ${oi}`);
  }, ar = exclude_internal_props(ar), [
    Jr,
    Yr,
    li,
    ci,
    Si,
    Ei,
    di,
    gi,
    vr,
    gr,
    mr,
    Li,
    yi,
    Vi,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Dr,
    Nr,
    Hr,
    $r,
    Zr,
    oi,
    Wr,
    hr,
    dr,
    fr,
    ur,
    kr,
    yr,
    Oi,
    Mi,
    Ii,
    mi,
    _i
  ];
}
class Drawer extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$f,
      create_fragment$A,
      safe_not_equal,
      {
        position: 14,
        bgDrawer: 15,
        border: 16,
        rounded: 17,
        shadow: 18,
        width: 19,
        height: 20,
        bgBackdrop: 21,
        blur: 22,
        padding: 23,
        zIndex: 26,
        regionBackdrop: 24,
        regionDrawer: 25,
        labelledby: 0,
        describedby: 1,
        duration: 2,
        transitions: 4,
        opacityTransition: 3
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[14];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get bgDrawer() {
    return this.$$.ctx[15];
  }
  set bgDrawer(ar) {
    this.$$set({ bgDrawer: ar }), flush();
  }
  get border() {
    return this.$$.ctx[16];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[17];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[18];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[20];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get bgBackdrop() {
    return this.$$.ctx[21];
  }
  set bgBackdrop(ar) {
    this.$$set({ bgBackdrop: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[22];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[26];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[24];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionDrawer() {
    return this.$$.ctx[25];
  }
  set regionDrawer(ar) {
    this.$$set({ regionDrawer: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get describedby() {
    return this.$$.ctx[1];
  }
  set describedby(ar) {
    this.$$set({ describedby: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[2];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get opacityTransition() {
    return this.$$.ctx[3];
  }
  set opacityTransition(ar) {
    this.$$set({ opacityTransition: ar }), flush();
  }
}
create_custom_element(Drawer, { position: {}, bgDrawer: {}, border: {}, rounded: {}, shadow: {}, width: {}, height: {}, bgBackdrop: {}, blur: {}, padding: {}, zIndex: {}, regionBackdrop: {}, regionDrawer: {}, labelledby: {}, describedby: {}, duration: {}, transitions: {}, opacityTransition: { type: "Boolean" } }, ["default"], [], !0);
function create_fragment$z(lr) {
  let ar, cr = `<script nonce="%sveltekit.nonce%">(${setInitialClassState.toString()})();<\/script>`, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), fr = space(), dr = element("div"), hr = element("div"), gr = svg_element("svg"), vr = svg_element("path"), ar.a = ur, attr(vr, "d", mr = /*$modeCurrent*/
      lr[1] ? (
        /*svgPath*/
        lr[5].sun
      ) : (
        /*svgPath*/
        lr[5].moon
      )), attr(gr, "class", br = "lightswitch-icon " + /*classesIcon*/
      lr[2]), attr(gr, "xmlns", "http://www.w3.org/2000/svg"), attr(gr, "viewBox", "0 0 512 512"), attr(hr, "class", yr = "lightswitch-thumb " + /*classesThumb*/
      lr[3]), attr(dr, "class", kr = "lightswitch-track " + /*classesTrack*/
      lr[4]), attr(dr, "role", "switch"), attr(dr, "aria-label", "Light Switch"), attr(
        dr,
        "aria-checked",
        /*$modeCurrent*/
        lr[1]
      ), attr(
        dr,
        "title",
        /*title*/
        lr[0]
      ), attr(dr, "tabindex", "0");
    },
    m(Er, xr) {
      ar.m(cr, document.head), append(document.head, ur), insert(Er, fr, xr), insert(Er, dr, xr), append(dr, hr), append(hr, gr), append(gr, vr), Tr || (_r = [
        listen(
          dr,
          "click",
          /*onToggleHandler*/
          lr[6]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          lr[19]
        ),
        listen(dr, "keydown", onKeyDown),
        listen(
          dr,
          "keydown",
          /*keydown_handler*/
          lr[20]
        ),
        listen(
          dr,
          "keyup",
          /*keyup_handler*/
          lr[21]
        ),
        listen(
          dr,
          "keypress",
          /*keypress_handler*/
          lr[22]
        )
      ], Tr = !0);
    },
    p(Er, [xr]) {
      xr & /*$modeCurrent*/
      2 && mr !== (mr = /*$modeCurrent*/
      Er[1] ? (
        /*svgPath*/
        Er[5].sun
      ) : (
        /*svgPath*/
        Er[5].moon
      )) && attr(vr, "d", mr), xr & /*classesIcon*/
      4 && br !== (br = "lightswitch-icon " + /*classesIcon*/
      Er[2]) && attr(gr, "class", br), xr & /*classesThumb*/
      8 && yr !== (yr = "lightswitch-thumb " + /*classesThumb*/
      Er[3]) && attr(hr, "class", yr), xr & /*classesTrack*/
      16 && kr !== (kr = "lightswitch-track " + /*classesTrack*/
      Er[4]) && attr(dr, "class", kr), xr & /*$modeCurrent*/
      2 && attr(
        dr,
        "aria-checked",
        /*$modeCurrent*/
        Er[1]
      ), xr & /*title*/
      1 && attr(
        dr,
        "title",
        /*title*/
        Er[0]
      );
    },
    i: noop$1,
    o: noop$1,
    d(Er) {
      Er && (ar.d(), detach(fr), detach(dr)), detach(ur), Tr = !1, run_all(_r);
    }
  };
}
const cTrack = "cursor-pointer", cThumb = "aspect-square scale-[0.8] flex justify-center items-center", cIcon = "w-[70%] aspect-square";
function onKeyDown(lr) {
  ["Enter", "Space"].includes(lr.code) && (lr.preventDefault(), lr.currentTarget.click());
}
function instance$e(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr, br;
  component_subscribe(lr, modeCurrent, (Jr) => cr(1, br = Jr));
  let { title: yr = "Toggle light or dark mode." } = ar, { bgLight: kr = "bg-surface-50" } = ar, { bgDark: Tr = "bg-surface-900" } = ar, { fillLight: _r = "fill-surface-50" } = ar, { fillDark: Er = "fill-surface-900" } = ar, { width: xr = "w-12" } = ar, { height: Cr = "h-6" } = ar, { ring: Ar = "ring-[1px] ring-surface-500/30" } = ar, { rounded: Lr = "rounded-token" } = ar;
  const Dr = "transition-all duration-[200ms]", Nr = {
    sun: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z",
    moon: "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
  };
  function Hr() {
    set_store_value(modeCurrent, br = !br, br), setModeUserPrefers(br), setModeCurrent(br);
  }
  onMount(() => {
    "modeCurrent" in localStorage || setModeCurrent(getModeOsPrefers());
  });
  function $r(Jr) {
    bubble.call(this, lr, Jr);
  }
  function Wr(Jr) {
    bubble.call(this, lr, Jr);
  }
  function Zr(Jr) {
    bubble.call(this, lr, Jr);
  }
  function oi(Jr) {
    bubble.call(this, lr, Jr);
  }
  return lr.$$set = (Jr) => {
    cr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(Jr))), "title" in Jr && cr(0, yr = Jr.title), "bgLight" in Jr && cr(7, kr = Jr.bgLight), "bgDark" in Jr && cr(8, Tr = Jr.bgDark), "fillLight" in Jr && cr(9, _r = Jr.fillLight), "fillDark" in Jr && cr(10, Er = Jr.fillDark), "width" in Jr && cr(11, xr = Jr.width), "height" in Jr && cr(12, Cr = Jr.height), "ring" in Jr && cr(13, Ar = Jr.ring), "rounded" in Jr && cr(14, Lr = Jr.rounded);
  }, lr.$$.update = () => {
    var Jr;
    lr.$$.dirty & /*$modeCurrent, bgLight, bgDark*/
    386 && cr(18, ur = br === !0 ? kr : Tr), lr.$$.dirty & /*$modeCurrent, bgDark, bgLight*/
    386 && cr(17, fr = br === !0 ? Tr : kr), lr.$$.dirty & /*$modeCurrent*/
    2 && cr(16, dr = br === !0 ? "translate-x-[100%]" : ""), lr.$$.dirty & /*$modeCurrent, fillLight, fillDark*/
    1538 && cr(15, hr = br === !0 ? _r : Er), cr(4, gr = `${cTrack} ${Dr} ${xr} ${Cr} ${Ar} ${Lr} ${ur} ${(Jr = ar.class) != null ? Jr : ""}`), lr.$$.dirty & /*height, rounded, thumbBg, thumbPosition*/
    217088 && cr(3, vr = `${cThumb} ${Dr} ${Cr} ${Lr} ${fr} ${dr}`), lr.$$.dirty & /*iconFill*/
    32768 && cr(2, mr = `${cIcon} ${hr}`);
  }, ar = exclude_internal_props(ar), [
    yr,
    br,
    mr,
    vr,
    gr,
    Nr,
    Hr,
    kr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    hr,
    dr,
    fr,
    ur,
    $r,
    Wr,
    Zr,
    oi
  ];
}
class LightSwitch extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$e, create_fragment$z, safe_not_equal, {
      title: 0,
      bgLight: 7,
      bgDark: 8,
      fillLight: 9,
      fillDark: 10,
      width: 11,
      height: 12,
      ring: 13,
      rounded: 14
    });
  }
  get title() {
    return this.$$.ctx[0];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get bgLight() {
    return this.$$.ctx[7];
  }
  set bgLight(ar) {
    this.$$set({ bgLight: ar }), flush();
  }
  get bgDark() {
    return this.$$.ctx[8];
  }
  set bgDark(ar) {
    this.$$set({ bgDark: ar }), flush();
  }
  get fillLight() {
    return this.$$.ctx[9];
  }
  set fillLight(ar) {
    this.$$set({ fillLight: ar }), flush();
  }
  get fillDark() {
    return this.$$.ctx[10];
  }
  set fillDark(ar) {
    this.$$set({ fillDark: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[12];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get ring() {
    return this.$$.ctx[13];
  }
  set ring(ar) {
    this.$$set({ ring: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
}
create_custom_element(LightSwitch, { title: {}, bgLight: {}, bgDark: {}, fillLight: {}, fillDark: {}, width: {}, height: {}, ring: {}, rounded: {} }, [], [], !0);
function get_each_context$3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[36] = ar[cr], ur[38] = cr, ur;
}
function create_if_block$6(lr) {
  let ar, cr, ur = [], fr = /* @__PURE__ */ new Map(), dr, hr, gr, vr = ensure_array_like(
    /*filteredToasts*/
    lr[11]
  );
  const mr = (br) => (
    /*t*/
    br[36]
  );
  for (let br = 0; br < vr.length; br += 1) {
    let yr = get_each_context$3(lr, vr, br), kr = mr(yr);
    fr.set(kr, ur[br] = create_each_block$3(kr, yr));
  }
  return {
    c() {
      ar = element("div"), cr = element("div");
      for (let br = 0; br < ur.length; br += 1)
        ur[br].c();
      attr(cr, "class", dr = "snackbar " + /*classesSnackbar*/
      lr[13]), attr(ar, "class", hr = "snackbar-wrapper " + /*classesWrapper*/
      lr[14]), attr(ar, "data-testid", "snackbar-wrapper");
    },
    m(br, yr) {
      insert(br, ar, yr), append(ar, cr);
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr] && ur[kr].m(cr, null);
      gr = !0;
    },
    p(br, yr) {
      if (yr[0] & /*filteredToasts, transitionOut, animAxis, transitionOutParams, transitions, onMouseEnter, onMouseLeave, classesToast, background, buttonDismiss, toastStore, buttonDismissLabel, buttonAction, onAction*/
      499103) {
        vr = ensure_array_like(
          /*filteredToasts*/
          br[11]
        ), group_outros();
        for (let kr = 0; kr < ur.length; kr += 1)
          ur[kr].r();
        ur = update_keyed_each(ur, yr, mr, 1, br, vr, fr, cr, fix_and_outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        for (let kr = 0; kr < ur.length; kr += 1)
          ur[kr].a();
        check_outros();
      }
      (!gr || yr[0] & /*classesSnackbar*/
      8192 && dr !== (dr = "snackbar " + /*classesSnackbar*/
      br[13])) && attr(cr, "class", dr), (!gr || yr[0] & /*classesWrapper*/
      16384 && hr !== (hr = "snackbar-wrapper " + /*classesWrapper*/
      br[14])) && attr(ar, "class", hr);
    },
    i(br) {
      if (!gr) {
        for (let yr = 0; yr < vr.length; yr += 1)
          transition_in(ur[yr]);
        gr = !0;
      }
    },
    o(br) {
      for (let yr = 0; yr < ur.length; yr += 1)
        transition_out(ur[yr]);
      gr = !1;
    },
    d(br) {
      br && detach(ar);
      for (let yr = 0; yr < ur.length; yr += 1)
        ur[yr].d();
    }
  };
}
function create_if_block_1$3(lr) {
  let ar, cr, ur = (
    /*t*/
    lr[36].action && create_if_block_3$2(lr)
  ), fr = !/*t*/
  lr[36].hideDismiss && create_if_block_2$2(lr);
  return {
    c() {
      ar = element("div"), ur && ur.c(), cr = space(), fr && fr.c(), attr(ar, "class", "toast-actions " + cToastActions);
    },
    m(dr, hr) {
      insert(dr, ar, hr), ur && ur.m(ar, null), append(ar, cr), fr && fr.m(ar, null);
    },
    p(dr, hr) {
      /*t*/
      dr[36].action ? ur ? ur.p(dr, hr) : (ur = create_if_block_3$2(dr), ur.c(), ur.m(ar, cr)) : ur && (ur.d(1), ur = null), /*t*/
      dr[36].hideDismiss ? fr && (fr.d(1), fr = null) : fr ? fr.p(dr, hr) : (fr = create_if_block_2$2(dr), fr.c(), fr.m(ar, null));
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(), fr && fr.d();
    }
  };
}
function create_if_block_3$2(lr) {
  let ar, cr = (
    /*t*/
    lr[36].action.label + ""
  ), ur, fr;
  function dr() {
    return (
      /*click_handler*/
      lr[30](
        /*i*/
        lr[38]
      )
    );
  }
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "class",
        /*buttonAction*/
        lr[1]
      );
    },
    m(hr, gr) {
      insert(hr, ar, gr), ar.innerHTML = cr, ur || (fr = listen(ar, "click", dr), ur = !0);
    },
    p(hr, gr) {
      lr = hr, gr[0] & /*filteredToasts*/
      2048 && cr !== (cr = /*t*/
      lr[36].action.label + "") && (ar.innerHTML = cr), gr[0] & /*buttonAction*/
      2 && attr(
        ar,
        "class",
        /*buttonAction*/
        lr[1]
      );
    },
    d(hr) {
      hr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_2$2(lr) {
  let ar, cr, ur, fr;
  function dr() {
    return (
      /*click_handler_1*/
      lr[31](
        /*t*/
        lr[36]
      )
    );
  }
  return {
    c() {
      ar = element("button"), cr = text$3(
        /*buttonDismissLabel*/
        lr[3]
      ), attr(
        ar,
        "class",
        /*buttonDismiss*/
        lr[2]
      ), attr(ar, "aria-label", "Dismiss toast");
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, cr), ur || (fr = listen(ar, "click", dr), ur = !0);
    },
    p(hr, gr) {
      lr = hr, gr[0] & /*buttonDismissLabel*/
      8 && set_data(
        cr,
        /*buttonDismissLabel*/
        lr[3]
      ), gr[0] & /*buttonDismiss*/
      4 && attr(
        ar,
        "class",
        /*buttonDismiss*/
        lr[2]
      );
    },
    d(hr) {
      hr && detach(ar), ur = !1, fr();
    }
  };
}
function create_each_block$3(lr, ar) {
  let cr, ur, fr, dr = (
    /*t*/
    ar[36].message + ""
  ), hr, gr, vr, mr, br, yr, kr, Tr = noop$1, _r, Er, xr, Cr = (
    /*t*/
    (ar[36].action || !/*t*/
    ar[36].hideDismiss) && create_if_block_1$3(ar)
  );
  function Ar() {
    return (
      /*mouseenter_handler*/
      ar[32](
        /*i*/
        ar[38]
      )
    );
  }
  function Lr() {
    return (
      /*mouseleave_handler*/
      ar[33](
        /*i*/
        ar[38]
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      var Dr, Nr;
      cr = element("div"), ur = element("div"), fr = element("div"), hr = space(), Cr && Cr.c(), vr = space(), attr(fr, "class", "text-base"), attr(ur, "class", gr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((Dr = ar[36].background) != null ? Dr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      ((Nr = ar[36].classes) != null ? Nr : "")), attr(ur, "data-testid", "toast"), attr(cr, "role", mr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog"), attr(cr, "aria-live", "polite"), this.first = cr;
    },
    m(Dr, Nr) {
      insert(Dr, cr, Nr), append(cr, ur), append(ur, fr), fr.innerHTML = dr, append(ur, hr), Cr && Cr.m(ur, null), append(cr, vr), _r = !0, Er || (xr = [
        listen(cr, "mouseenter", Ar),
        listen(cr, "mouseleave", Lr)
      ], Er = !0);
    },
    p(Dr, Nr) {
      var Hr, $r;
      ar = Dr, (!_r || Nr[0] & /*filteredToasts*/
      2048) && dr !== (dr = /*t*/
      ar[36].message + "") && (fr.innerHTML = dr), /*t*/
      ar[36].action || !/*t*/
      ar[36].hideDismiss ? Cr ? Cr.p(ar, Nr) : (Cr = create_if_block_1$3(ar), Cr.c(), Cr.m(ur, null)) : Cr && (Cr.d(1), Cr = null), (!_r || Nr[0] & /*classesToast, filteredToasts, background*/
      6145 && gr !== (gr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((Hr = ar[36].background) != null ? Hr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      (($r = ar[36].classes) != null ? $r : ""))) && attr(ur, "class", gr), (!_r || Nr[0] & /*filteredToasts*/
      2048 && mr !== (mr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog")) && attr(cr, "role", mr);
    },
    r() {
      kr = cr.getBoundingClientRect();
    },
    f() {
      fix_position(cr), Tr(), add_transform(cr, kr);
    },
    a() {
      Tr(), Tr = create_animation(cr, kr, flip, {
        duration: (
          /*transitions*/
          ar[4] ? 250 : 0
        )
      });
    },
    i(Dr) {
      _r || (add_render_callback(() => {
        _r && (yr && yr.end(1), br = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[5]
          ),
          params: {
            x: (
              /*animAxis*/
              ar[10].x
            ),
            y: (
              /*animAxis*/
              ar[10].y
            ),
            .../*transitionInParams*/
            ar[6]
          },
          enabled: (
            /*transitions*/
            ar[4]
          )
        }), br.start());
      }), _r = !0);
    },
    o(Dr) {
      br && br.invalidate(), yr = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[7]
        ),
        params: {
          x: (
            /*animAxis*/
            ar[10].x
          ),
          y: (
            /*animAxis*/
            ar[10].y
          ),
          .../*transitionOutParams*/
          ar[8]
        },
        enabled: (
          /*transitions*/
          ar[4]
        )
      }), _r = !1;
    },
    d(Dr) {
      Dr && detach(cr), Cr && Cr.d(), Dr && yr && yr.end(), Er = !1, run_all(xr);
    }
  };
}
function create_fragment$y(lr) {
  let ar, cr, ur = (
    /*$toastStore*/
    lr[9].length && create_if_block$6(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*$toastStore*/
      fr[9].length ? ur ? (ur.p(fr, dr), dr[0] & /*$toastStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$6(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cWrapper = "flex fixed top-0 left-0 right-0 bottom-0 pointer-events-none", cSnackbar = "flex flex-col gap-y-2", cToast = "flex justify-between items-center pointer-events-auto", cToastActions = "flex items-center space-x-2";
function instance$d(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr;
  component_subscribe(lr, prefersReducedMotionStore, (wi) => cr(34, vr = wi));
  const mr = getToastStore();
  component_subscribe(lr, mr, (wi) => cr(9, gr = wi));
  let { position: br = "b" } = ar, { max: yr = 3 } = ar, { background: kr = "variant-filled-secondary" } = ar, { width: Tr = "max-w-[640px]" } = ar, { color: _r = "" } = ar, { padding: Er = "p-4" } = ar, { spacing: xr = "space-x-4" } = ar, { rounded: Cr = "rounded-container-token" } = ar, { shadow: Ar = "shadow-lg" } = ar, { zIndex: Lr = "z-[888]" } = ar, { buttonAction: Dr = "btn variant-filled" } = ar, { buttonDismiss: Nr = "btn-icon btn-icon-sm variant-filled" } = ar, { buttonDismissLabel: Hr = "✕" } = ar, { transitions: $r = !vr } = ar, { transitionIn: Wr = fly } = ar, { transitionInParams: Zr = { duration: 250 } } = ar, { transitionOut: oi = fly } = ar, { transitionOutParams: Jr = { duration: 250 } } = ar, Yr, li, Si = { x: 0, y: 0 };
  switch (br) {
    case "t":
      Yr = "justify-center items-start", li = "items-center", Si = { x: 0, y: -100 };
      break;
    case "b":
      Yr = "justify-center items-end", li = "items-center", Si = { x: 0, y: 100 };
      break;
    case "l":
      Yr = "justify-start items-center", li = "items-start", Si = { x: -100, y: 0 };
      break;
    case "r":
      Yr = "justify-end items-center", li = "items-end", Si = { x: 100, y: 0 };
      break;
    case "tl":
      Yr = "justify-start items-start", li = "items-start", Si = { x: -100, y: 0 };
      break;
    case "tr":
      Yr = "justify-end items-start", li = "items-end", Si = { x: 100, y: 0 };
      break;
    case "bl":
      Yr = "justify-start items-end", li = "items-start", Si = { x: -100, y: 0 };
      break;
    case "br":
      Yr = "justify-end items-end", li = "items-end", Si = { x: 100, y: 0 };
      break;
  }
  function ci(wi) {
    var Ui, yi;
    (yi = (Ui = gr[wi]) == null ? void 0 : Ui.action) == null || yi.response(), mr.close(gr[wi].id);
  }
  function hi(wi) {
    var Ui;
    (Ui = gr[wi]) != null && Ui.hoverable && (mr.freeze(wi), cr(13, fr += " scale-[105%]"));
  }
  function Ei(wi) {
    var Ui;
    (Ui = gr[wi]) != null && Ui.hoverable && (mr.unfreeze(wi), cr(13, fr = fr.replace(" scale-[105%]", "")));
  }
  const di = (wi) => ci(wi), gi = (wi) => mr.close(wi.id), Li = (wi) => hi(wi), ui = (wi) => Ei(wi);
  return lr.$$set = (wi) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(wi))), "position" in wi && cr(19, br = wi.position), "max" in wi && cr(20, yr = wi.max), "background" in wi && cr(0, kr = wi.background), "width" in wi && cr(21, Tr = wi.width), "color" in wi && cr(22, _r = wi.color), "padding" in wi && cr(23, Er = wi.padding), "spacing" in wi && cr(24, xr = wi.spacing), "rounded" in wi && cr(25, Cr = wi.rounded), "shadow" in wi && cr(26, Ar = wi.shadow), "zIndex" in wi && cr(27, Lr = wi.zIndex), "buttonAction" in wi && cr(1, Dr = wi.buttonAction), "buttonDismiss" in wi && cr(2, Nr = wi.buttonDismiss), "buttonDismissLabel" in wi && cr(3, Hr = wi.buttonDismissLabel), "transitions" in wi && cr(4, $r = wi.transitions), "transitionIn" in wi && cr(5, Wr = wi.transitionIn), "transitionInParams" in wi && cr(6, Zr = wi.transitionInParams), "transitionOut" in wi && cr(7, oi = wi.transitionOut), "transitionOutParams" in wi && cr(8, Jr = wi.transitionOutParams);
  }, lr.$$.update = () => {
    cr(14, ur = `${cWrapper} ${Yr} ${Lr} ${ar.class || ""}`), lr.$$.dirty[0] & /*cAlign, padding*/
    545259520 && cr(13, fr = `${cSnackbar} ${li} ${Er}`), lr.$$.dirty[0] & /*width, color, padding, spacing, rounded, shadow*/
    132120576 && cr(12, dr = `${cToast} ${Tr} ${_r} ${Er} ${xr} ${Cr} ${Ar}`), lr.$$.dirty[0] & /*$toastStore, max*/
    1049088 && cr(11, hr = Array.from(gr).slice(0, yr));
  }, ar = exclude_internal_props(ar), [
    kr,
    Dr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    gr,
    Si,
    hr,
    dr,
    fr,
    ur,
    mr,
    ci,
    hi,
    Ei,
    br,
    yr,
    Tr,
    _r,
    Er,
    xr,
    Cr,
    Ar,
    Lr,
    Yr,
    li,
    di,
    gi,
    Li,
    ui
  ];
}
class Toast extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$d,
      create_fragment$y,
      safe_not_equal,
      {
        position: 19,
        max: 20,
        background: 0,
        width: 21,
        color: 22,
        padding: 23,
        spacing: 24,
        rounded: 25,
        shadow: 26,
        zIndex: 27,
        buttonAction: 1,
        buttonDismiss: 2,
        buttonDismissLabel: 3,
        transitions: 4,
        transitionIn: 5,
        transitionInParams: 6,
        transitionOut: 7,
        transitionOutParams: 8
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[19];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get max() {
    return this.$$.ctx[20];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get background() {
    return this.$$.ctx[0];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[21];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get color() {
    return this.$$.ctx[22];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[24];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[25];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[26];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[27];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonAction() {
    return this.$$.ctx[1];
  }
  set buttonAction(ar) {
    this.$$set({ buttonAction: ar }), flush();
  }
  get buttonDismiss() {
    return this.$$.ctx[2];
  }
  set buttonDismiss(ar) {
    this.$$set({ buttonDismiss: ar }), flush();
  }
  get buttonDismissLabel() {
    return this.$$.ctx[3];
  }
  set buttonDismissLabel(ar) {
    this.$$set({ buttonDismissLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[5];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[6];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[7];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[8];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Toast, { position: {}, max: {}, background: {}, width: {}, color: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonAction: {}, buttonDismiss: {}, buttonDismissLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function get_each_context$2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur;
}
function create_if_block$5(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  const mr = (
    /*#slots*/
    lr[16].default
  ), br = create_slot(
    mr,
    lr,
    /*$$scope*/
    lr[15],
    null
  ), yr = br || fallback_block();
  let kr = ensure_array_like(
    /*$tocStore*/
    lr[9]
  ), Tr = [];
  for (let _r = 0; _r < kr.length; _r += 1)
    Tr[_r] = create_each_block$2(get_each_context$2(lr, kr, _r));
  return {
    c() {
      ar = element("nav"), cr = element("div"), yr && yr.c(), ur = space(), fr = element("ul");
      for (let _r = 0; _r < Tr.length; _r += 1)
        Tr[_r].c();
      attr(
        cr,
        "class",
        /*regionLead*/
        lr[3]
      ), attr(fr, "class", dr = "toc-list " + /*classesList*/
      lr[6]), attr(ar, "class", hr = "toc " + /*classesBase*/
      lr[7]), attr(ar, "data-testid", "toc");
    },
    m(_r, Er) {
      insert(_r, ar, Er), append(ar, cr), yr && yr.m(cr, null), append(ar, ur), append(ar, fr);
      for (let xr = 0; xr < Tr.length; xr += 1)
        Tr[xr] && Tr[xr].m(fr, null);
      vr = !0;
    },
    p(_r, Er) {
      if (br && br.p && (!vr || Er & /*$$scope*/
      32768) && update_slot_base(
        br,
        mr,
        _r,
        /*$$scope*/
        _r[15],
        vr ? get_slot_changes(
          mr,
          /*$$scope*/
          _r[15],
          Er,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          _r[15]
        ),
        null
      ), (!vr || Er & /*regionLead*/
      8) && attr(
        cr,
        "class",
        /*regionLead*/
        _r[3]
      ), Er & /*classesListItem, indentStyles, $tocStore, classesAnchor, reactiveActiveId, active, inactive*/
      823) {
        kr = ensure_array_like(
          /*$tocStore*/
          _r[9]
        );
        let xr;
        for (xr = 0; xr < kr.length; xr += 1) {
          const Cr = get_each_context$2(_r, kr, xr);
          Tr[xr] ? Tr[xr].p(Cr, Er) : (Tr[xr] = create_each_block$2(Cr), Tr[xr].c(), Tr[xr].m(fr, null));
        }
        for (; xr < Tr.length; xr += 1)
          Tr[xr].d(1);
        Tr.length = kr.length;
      }
      (!vr || Er & /*classesList*/
      64 && dr !== (dr = "toc-list " + /*classesList*/
      _r[6])) && attr(fr, "class", dr), (!vr || Er & /*classesBase*/
      128 && hr !== (hr = "toc " + /*classesBase*/
      _r[7])) && attr(ar, "class", hr);
    },
    i(_r) {
      vr || (transition_in(yr, _r), _r && add_render_callback(() => {
        vr && (gr || (gr = create_bidirectional_transition(ar, fade, { duration: 100 }, !0)), gr.run(1));
      }), vr = !0);
    },
    o(_r) {
      transition_out(yr, _r), _r && (gr || (gr = create_bidirectional_transition(ar, fade, { duration: 100 }, !1)), gr.run(0)), vr = !1;
    },
    d(_r) {
      _r && detach(ar), yr && yr.d(_r), destroy_each(Tr, _r), _r && gr && gr.end();
    }
  };
}
function fallback_block(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Table of Contents");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_each_block$2(lr) {
  let ar, cr, ur = (
    /*tocHeading*/
    lr[19].text + ""
  ), fr, dr, hr, gr, vr, mr, br;
  function yr() {
    return (
      /*click_handler*/
      lr[17](
        /*tocHeading*/
        lr[19]
      )
    );
  }
  return {
    c() {
      ar = element("li"), cr = element("a"), fr = text$3(ur), gr = space(), attr(cr, "href", dr = "#" + /*tocHeading*/
      lr[19].id), attr(cr, "class", hr = "toc-anchor " + /*classesAnchor*/
      lr[4] + " " + /*tocHeading*/
      (lr[19].id === /*reactiveActiveId*/
      lr[8] ? (
        /*active*/
        lr[1]
      ) : (
        /*inactive*/
        lr[0]
      ))), attr(ar, "class", vr = "toc-list-item " + /*classesListItem*/
      lr[5] + " " + /*indentStyles*/
      lr[2][
        /*tocHeading*/
        lr[19].element
      ]);
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), append(ar, cr), append(cr, fr), append(ar, gr), mr || (br = listen(cr, "click", yr), mr = !0);
    },
    p(kr, Tr) {
      lr = kr, Tr & /*$tocStore*/
      512 && ur !== (ur = /*tocHeading*/
      lr[19].text + "") && set_data(fr, ur), Tr & /*$tocStore*/
      512 && dr !== (dr = "#" + /*tocHeading*/
      lr[19].id) && attr(cr, "href", dr), Tr & /*classesAnchor, $tocStore, reactiveActiveId, active, inactive*/
      787 && hr !== (hr = "toc-anchor " + /*classesAnchor*/
      lr[4] + " " + /*tocHeading*/
      (lr[19].id === /*reactiveActiveId*/
      lr[8] ? (
        /*active*/
        lr[1]
      ) : (
        /*inactive*/
        lr[0]
      ))) && attr(cr, "class", hr), Tr & /*classesListItem, indentStyles, $tocStore*/
      548 && vr !== (vr = "toc-list-item " + /*classesListItem*/
      lr[5] + " " + /*indentStyles*/
      lr[2][
        /*tocHeading*/
        lr[19].element
      ]) && attr(ar, "class", vr);
    },
    d(kr) {
      kr && detach(ar), mr = !1, br();
    }
  };
}
function create_fragment$x(lr) {
  let ar, cr, ur = (
    /*$tocStore*/
    lr[9].length && create_if_block$5(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, [dr]) {
      /*$tocStore*/
      fr[9].length ? ur ? (ur.p(fr, dr), dr & /*$tocStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$5(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cBase = "space-y-4", cList = "space-y-2", cListItem = "block", cAnchor = "";
function instance$c(lr, ar, cr) {
  let ur, fr, dr, hr, gr, vr, mr;
  component_subscribe(lr, tocActiveId, (Nr) => cr(14, vr = Nr)), component_subscribe(lr, tocStore, (Nr) => cr(9, mr = Nr));
  let { $$slots: br = {}, $$scope: yr } = ar, { inactive: kr = "opacity-60 hover:opacity-100" } = ar, { active: Tr = "text-primary-500" } = ar, { activeId: _r = "" } = ar, { indentStyles: Er = {
    h2: "",
    h3: "ml-4",
    h4: "ml-8",
    h5: "ml-12",
    h6: "ml-16"
  } } = ar, { regionLead: xr = "font-bold" } = ar, { regionList: Cr = "" } = ar, { regionListItem: Ar = "" } = ar, { regionAnchor: Lr = "" } = ar;
  const Dr = (Nr) => {
    cr(8, ur = Nr.id);
  };
  return lr.$$set = (Nr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Nr))), "inactive" in Nr && cr(0, kr = Nr.inactive), "active" in Nr && cr(1, Tr = Nr.active), "activeId" in Nr && cr(10, _r = Nr.activeId), "indentStyles" in Nr && cr(2, Er = Nr.indentStyles), "regionLead" in Nr && cr(3, xr = Nr.regionLead), "regionList" in Nr && cr(11, Cr = Nr.regionList), "regionListItem" in Nr && cr(12, Ar = Nr.regionListItem), "regionAnchor" in Nr && cr(13, Lr = Nr.regionAnchor), "$$scope" in Nr && cr(15, yr = Nr.$$scope);
  }, lr.$$.update = () => {
    var Nr;
    lr.$$.dirty & /*$tocActiveId, activeId*/
    17408 && cr(8, ur = vr || _r.replace("#", "")), cr(7, fr = `${cBase} ${(Nr = ar.class) != null ? Nr : ""}`), lr.$$.dirty & /*regionList*/
    2048 && cr(6, dr = `${cList} ${Cr}`), lr.$$.dirty & /*regionListItem*/
    4096 && cr(5, hr = `${cListItem} ${Ar}`), lr.$$.dirty & /*regionAnchor*/
    8192 && cr(4, gr = `${cAnchor} ${Lr}`);
  }, ar = exclude_internal_props(ar), [
    kr,
    Tr,
    Er,
    xr,
    gr,
    hr,
    dr,
    fr,
    ur,
    mr,
    _r,
    Cr,
    Ar,
    Lr,
    vr,
    yr,
    br,
    Dr
  ];
}
class TableOfContents extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$c, create_fragment$x, safe_not_equal, {
      inactive: 0,
      active: 1,
      activeId: 10,
      indentStyles: 2,
      regionLead: 3,
      regionList: 11,
      regionListItem: 12,
      regionAnchor: 13
    });
  }
  get inactive() {
    return this.$$.ctx[0];
  }
  set inactive(ar) {
    this.$$set({ inactive: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get activeId() {
    return this.$$.ctx[10];
  }
  set activeId(ar) {
    this.$$set({ activeId: ar }), flush();
  }
  get indentStyles() {
    return this.$$.ctx[2];
  }
  set indentStyles(ar) {
    this.$$set({ indentStyles: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[3];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[11];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionListItem() {
    return this.$$.ctx[12];
  }
  set regionListItem(ar) {
    this.$$set({ regionListItem: ar }), flush();
  }
  get regionAnchor() {
    return this.$$.ctx[13];
  }
  set regionAnchor(ar) {
    this.$$set({ regionAnchor: ar }), flush();
  }
}
create_custom_element(TableOfContents, { inactive: {}, active: {}, activeId: {}, indentStyles: {}, regionLead: {}, regionList: {}, regionListItem: {}, regionAnchor: {} }, ["default"], [], !0);
function create_fragment$w(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "values", `0.8 0.6 -0.4 0.1 0,
					0 1.2 0.05 0 0,
					0 -1 3 0.02 0,
					0 0 0 50 0`), attr(ur, "result", "final"), attr(ur, "in", "SourceGraphic"), attr(cr, "id", "Apollo"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-apollo"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Apollo extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$w, safe_not_equal, {});
  }
}
create_custom_element(Apollo, {}, [], [], !0);
function create_fragment$v(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.000 0.000 0.000 0.000 0.000 
                    0.000 1.000 0.000 0.000 0.05 
                    0.000 0.000 1.000 0.000 0.400 
                    0.000 0.000 0.000 1.000 0.000`), attr(cr, "id", "BlueNight"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-bluenight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class BlueNight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$v, safe_not_equal, {});
  }
}
create_custom_element(BlueNight, {}, [], [], !0);
function create_fragment$u(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feComponentTransfer"), dr = svg_element("feFuncR"), hr = svg_element("feFuncG"), gr = svg_element("feFuncB"), vr = svg_element("feFuncA"), mr = svg_element("feBlend"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            0 0 0 0.33 0`), attr(dr, "type", "table"), attr(dr, "tableValues", "0.03 0.9"), attr(hr, "type", "table"), attr(hr, "tableValues", "0.57 1"), attr(gr, "type", "table"), attr(gr, "tableValues", "0.49 0.53"), attr(vr, "type", "table"), attr(vr, "tableValues", "0 1"), attr(fr, "in", "colormatrix"), attr(fr, "result", "componentTransfer"), attr(mr, "mode", "normal"), attr(mr, "in", "componentTransfer"), attr(mr, "in2", "SourceGraphic"), attr(mr, "result", "blend"), attr(cr, "id", "Emerald"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-emerald"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(br, yr) {
      insert(br, ar, yr), append(ar, cr), append(cr, ur), append(cr, fr), append(fr, dr), append(fr, hr), append(fr, gr), append(fr, vr), append(cr, mr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(br) {
      br && detach(ar);
    }
  };
}
class Emerald extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$u, safe_not_equal, {});
  }
}
create_custom_element(Emerald, {}, [], [], !0);
function create_fragment$t(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `0.5 -0.4 0.3332 0 0
					0 0.4 0.3 0 0
					0 0 0.5 0 0
					0 0 0 500 -20`), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(cr, "id", "GreenFall"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-greenfall"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class GreenFall extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$t, safe_not_equal, {});
  }
}
create_custom_element(GreenFall, {}, [], [], !0);
function create_fragment$s(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feBlend"), dr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix1"), attr(fr, "mode", "lighten"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "colormatrix1"), attr(fr, "in2", "colormatrix1"), attr(fr, "result", "blend"), attr(dr, "mode", "multiply"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "colormatrix1"), attr(dr, "in2", "diffuseLighting"), attr(dr, "result", "blend1"), attr(cr, "id", "Noir"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noir"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(hr) {
      hr && detach(ar);
    }
  };
}
class Noir extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$s, safe_not_equal, {});
  }
}
create_custom_element(Noir, {}, [], [], !0);
function create_fragment$r(lr) {
  let ar, cr, ur, fr, dr, hr, gr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feBlend"), dr = svg_element("feBlend"), hr = svg_element("feColorMatrix"), gr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix2"), attr(fr, "mode", "saturation"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "SourceGraphic"), attr(fr, "in2", "colormatrix2"), attr(fr, "result", "blend2"), attr(dr, "mode", "screen"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "colormatrix2"), attr(dr, "in2", "blend2"), attr(dr, "result", "blend3"), attr(hr, "type", "luminanceToAlpha"), attr(hr, "x", "0%"), attr(hr, "y", "0%"), attr(hr, "width", "100%"), attr(hr, "height", "100%"), attr(hr, "in", "blend3"), attr(hr, "result", "colormatrix3"), attr(gr, "mode", "exclusion"), attr(gr, "x", "0%"), attr(gr, "y", "0%"), attr(gr, "width", "100%"), attr(gr, "height", "100%"), attr(gr, "in", "blend3"), attr(gr, "in2", "colormatrix3"), attr(gr, "result", "blend5"), attr(cr, "id", "NoirLight"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noirlight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(vr, mr) {
      insert(vr, ar, mr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, hr), append(cr, gr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar);
    }
  };
}
class NoirLight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$r, safe_not_equal, {});
  }
}
create_custom_element(NoirLight, {}, [], [], !0);
function create_fragment$q(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 
					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 
					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  
					0 0 0 1 0`), attr(cr, "id", "Rustic"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-rustic"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Rustic extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$q, safe_not_equal, {});
  }
}
create_custom_element(Rustic, {}, [], [], !0);
function create_fragment$p(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.300 0.200 0.000 0.000 0.000 
					0.300 0.600 0.200 0.000 0.000 
					0.200 1.000 0.200 0.000 0.000 
					0.000 0.000 0.000 1.000 0.000`), attr(cr, "id", "Summer84"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-summer84"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Summer84 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$p, safe_not_equal, {});
  }
}
create_custom_element(Summer84, {}, [], [], !0);
function create_fragment$o(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.70 -0.20 0.00 0.00 0.00 
                    0.10 0.800 0.30 0.00 0.00 
                    0.20 0.300 0.50 0.00 0.00 
                    0.00 0.00 0.00 1.00 0.00`), attr(cr, "id", "XPro"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-xpro"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class XPro extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$o, safe_not_equal, {});
  }
}
create_custom_element(XPro, {}, [], [], !0);
const ndkUser = writable(null), isNip05Valid = writable({
  isNip05Valid: null,
  Nip05address: void 0,
  UserNpub: void 0,
  Vanity: void 0,
  UserIdentifier: void 0
}), activeProfile = writable(null);
activeProfile.subscribe((lr) => {
  lr && activeProfile.set(lr);
});
const localStore = localStorageStore("localStore", {
  lastUserLogged: void 0,
  pk: void 0
}), themeModeLocalStorageObject = writable("colour-scheme"), theme = writable("light");
function create_fragment$n(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#4DA84D"), attr(ur, "d", "M12 16.2553L14.8661 19L19 12"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Positive extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$n, safe_not_equal, {});
  }
}
create_custom_element(Positive, {}, [], [], !0);
function create_fragment$m(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#42BDD8"), attr(ur, "d", "M12.8661 17H18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(fr, "d", "M12.8661 13H18.5"), attr(fr, "stroke", "white"), attr(fr, "stroke-width", "1.5"), attr(fr, "stroke-linecap", "round"), attr(fr, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, hr) {
      insert(dr, ar, hr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Neutral extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$m, safe_not_equal, {});
  }
}
create_custom_element(Neutral, {}, [], [], !0);
function create_fragment$l(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#ED1B24"), attr(ur, "d", "M12 11.5L19 18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.3125"), attr(ur, "stroke-linecap", "round"), attr(fr, "d", "M19 11.5L12 18.5"), attr(fr, "stroke", "white"), attr(fr, "stroke-width", "1.3125"), attr(fr, "stroke-linecap", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, hr) {
      insert(dr, ar, hr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Negative extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$l, safe_not_equal, {});
  }
}
create_custom_element(Negative, {}, [], [], !0);
function number$6(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$5(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$6(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$6(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$6(lr.outputLen), number$6(lr.blockLen);
}
function exists$6(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$6(lr, ar) {
  bytes$6(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$6 = {
  number: number$6,
  bool: bool$5,
  bytes: bytes$6,
  hash: hash$6,
  exists: exists$6,
  output: output$6
}, crypto$6 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$8 = (lr) => lr instanceof Uint8Array, createView$5 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$5 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$6)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function utf8ToBytes$8(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$6(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$8(lr)), !u8a$8(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$7(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$8(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$5 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$5(lr) {
  const ar = (ur) => lr().update(toBytes$6(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$5(lr = 32) {
  if (crypto$6 && typeof crypto$6.getRandomValues == "function")
    return crypto$6.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$5(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
let SHA2$5 = class extends Hash$5 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$5(this.buffer);
  }
  update(ar) {
    assert$6.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$6(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView$5(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64$5(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView$5(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$6 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$5 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$5 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$5 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$5 = new Uint32Array(64);
let SHA256$5 = class extends SHA2$5 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$5[0] | 0, this.B = IV$5[1] | 0, this.C = IV$5[2] | 0, this.D = IV$5[3] | 0, this.E = IV$5[4] | 0, this.F = IV$5[5] | 0, this.G = IV$5[6] | 0, this.H = IV$5[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W$5[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W$5[yr - 15], Tr = SHA256_W$5[yr - 2], _r = rotr$5(kr, 7) ^ rotr$5(kr, 18) ^ kr >>> 3, Er = rotr$5(Tr, 17) ^ rotr$5(Tr, 19) ^ Tr >>> 10;
      SHA256_W$5[yr] = Er + SHA256_W$5[yr - 7] + _r + SHA256_W$5[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr$5(gr, 6) ^ rotr$5(gr, 11) ^ rotr$5(gr, 25), Tr = br + kr + Chi$6(gr, vr, mr) + SHA256_K$5[yr] + SHA256_W$5[yr] | 0, Er = (rotr$5(ur, 2) ^ rotr$5(ur, 13) ^ rotr$5(ur, 22)) + Maj$5(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W$5.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$3 = class extends SHA256$5 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$5 = wrapConstructor$5(() => new SHA256$5());
wrapConstructor$5(() => new SHA224$3());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$9 = BigInt(0), _1n$9 = BigInt(1), _2n$5 = BigInt(2), u8a$7 = (lr) => lr instanceof Uint8Array, hexes$5 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$5(lr) {
  if (!u8a$7(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$5[lr[cr]];
  return ar;
}
function numberToHexUnpadded$1(lr) {
  const ar = lr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber$1(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  return BigInt(lr === "" ? "0" : `0x${lr}`);
}
function hexToBytes$6(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function bytesToNumberBE$1(lr) {
  return hexToNumber$1(bytesToHex$5(lr));
}
function bytesToNumberLE$1(lr) {
  if (!u8a$7(lr))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$5(Uint8Array.from(lr).reverse()));
}
function numberToBytesBE$1(lr, ar) {
  return hexToBytes$6(lr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE$1(lr, ar) {
  return numberToBytesBE$1(lr, ar).reverse();
}
function numberToVarBytesBE$1(lr) {
  return hexToBytes$6(numberToHexUnpadded$1(lr));
}
function ensureBytes$2(lr, ar, cr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$6(ar);
    } catch (dr) {
      throw new Error(`${lr} must be valid hex string, got "${ar}". Cause: ${dr}`);
    }
  else if (u8a$7(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${lr} must be hex string or Uint8Array`);
  const fr = ur.length;
  if (typeof cr == "number" && fr !== cr)
    throw new Error(`${lr} expected ${cr} bytes, got ${fr}`);
  return ur;
}
function concatBytes$6(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$7(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
function equalBytes$2(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length; cr++)
    if (lr[cr] !== ar[cr])
      return !1;
  return !0;
}
function utf8ToBytes$7(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function bitLen$1(lr) {
  let ar;
  for (ar = 0; lr > _0n$9; lr >>= _1n$9, ar += 1)
    ;
  return ar;
}
function bitGet$1(lr, ar) {
  return lr >> BigInt(ar) & _1n$9;
}
const bitSet$1 = (lr, ar, cr) => lr | (cr ? _1n$9 : _0n$9) << BigInt(ar), bitMask$1 = (lr) => (_2n$5 << BigInt(lr - 1)) - _1n$9, u8n$1 = (lr) => new Uint8Array(lr), u8fr$1 = (lr) => Uint8Array.from(lr);
function createHmacDrbg$1(lr, ar, cr) {
  if (typeof lr != "number" || lr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof cr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n$1(lr), fr = u8n$1(lr), dr = 0;
  const hr = () => {
    ur.fill(1), fr.fill(0), dr = 0;
  }, gr = (...yr) => cr(fr, ur, ...yr), vr = (yr = u8n$1()) => {
    fr = gr(u8fr$1([0]), yr), ur = gr(), yr.length !== 0 && (fr = gr(u8fr$1([1]), yr), ur = gr());
  }, mr = () => {
    if (dr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let yr = 0;
    const kr = [];
    for (; yr < ar; ) {
      ur = gr();
      const Tr = ur.slice();
      kr.push(Tr), yr += ur.length;
    }
    return concatBytes$6(...kr);
  };
  return (yr, kr) => {
    hr(), vr(yr);
    let Tr;
    for (; !(Tr = kr(mr())); )
      vr();
    return hr(), Tr;
  };
}
const validatorFns$1 = {
  bigint: (lr) => typeof lr == "bigint",
  function: (lr) => typeof lr == "function",
  boolean: (lr) => typeof lr == "boolean",
  string: (lr) => typeof lr == "string",
  isSafeInteger: (lr) => Number.isSafeInteger(lr),
  array: (lr) => Array.isArray(lr),
  field: (lr, ar) => ar.Fp.isValid(lr),
  hash: (lr) => typeof lr == "function" && Number.isSafeInteger(lr.outputLen)
};
function validateObject$1(lr, ar, cr = {}) {
  const ur = (fr, dr, hr) => {
    const gr = validatorFns$1[dr];
    if (typeof gr != "function")
      throw new Error(`Invalid validator "${dr}", expected function`);
    const vr = lr[fr];
    if (!(hr && vr === void 0) && !gr(vr, lr))
      throw new Error(`Invalid param ${String(fr)}=${vr} (${typeof vr}), expected ${dr}`);
  };
  for (const [fr, dr] of Object.entries(ar))
    ur(fr, dr, !1);
  for (const [fr, dr] of Object.entries(cr))
    ur(fr, dr, !0);
  return lr;
}
const ut$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$5,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$6,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$2,
  equalBytes: equalBytes$2,
  hexToBytes: hexToBytes$6,
  hexToNumber: hexToNumber$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$7,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = BigInt(0), _1n$8 = BigInt(1), _2n$4 = BigInt(2), _3n$3 = BigInt(3), _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(lr, ar) {
  const cr = lr % ar;
  return cr >= _0n$8 ? cr : ar + cr;
}
function pow$1(lr, ar, cr) {
  if (cr <= _0n$8 || ar < _0n$8)
    throw new Error("Expected power/modulo > 0");
  if (cr === _1n$8)
    return _0n$8;
  let ur = _1n$8;
  for (; ar > _0n$8; )
    ar & _1n$8 && (ur = ur * lr % cr), lr = lr * lr % cr, ar >>= _1n$8;
  return ur;
}
function pow2$1(lr, ar, cr) {
  let ur = lr;
  for (; ar-- > _0n$8; )
    ur *= ur, ur %= cr;
  return ur;
}
function invert$1(lr, ar) {
  if (lr === _0n$8 || ar <= _0n$8)
    throw new Error(`invert: expected positive integers, got n=${lr} mod=${ar}`);
  let cr = mod$1(lr, ar), ur = ar, fr = _0n$8, dr = _1n$8;
  for (; cr !== _0n$8; ) {
    const gr = ur / cr, vr = ur % cr, mr = fr - dr * gr;
    ur = cr, cr = vr, fr = dr, dr = mr;
  }
  if (ur !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(fr, ar);
}
function tonelliShanks$1(lr) {
  const ar = (lr - _1n$8) / _2n$4;
  let cr, ur, fr;
  for (cr = lr - _1n$8, ur = 0; cr % _2n$4 === _0n$8; cr /= _2n$4, ur++)
    ;
  for (fr = _2n$4; fr < lr && pow$1(fr, ar, lr) !== lr - _1n$8; fr++)
    ;
  if (ur === 1) {
    const hr = (lr + _1n$8) / _4n$1;
    return function(vr, mr) {
      const br = vr.pow(mr, hr);
      if (!vr.eql(vr.sqr(br), mr))
        throw new Error("Cannot find square root");
      return br;
    };
  }
  const dr = (cr + _1n$8) / _2n$4;
  return function(gr, vr) {
    if (gr.pow(vr, ar) === gr.neg(gr.ONE))
      throw new Error("Cannot find square root");
    let mr = ur, br = gr.pow(gr.mul(gr.ONE, fr), cr), yr = gr.pow(vr, dr), kr = gr.pow(vr, cr);
    for (; !gr.eql(kr, gr.ONE); ) {
      if (gr.eql(kr, gr.ZERO))
        return gr.ZERO;
      let Tr = 1;
      for (let Er = gr.sqr(kr); Tr < mr && !gr.eql(Er, gr.ONE); Tr++)
        Er = gr.sqr(Er);
      const _r = gr.pow(br, _1n$8 << BigInt(mr - Tr - 1));
      br = gr.sqr(_r), yr = gr.mul(yr, _r), kr = gr.mul(kr, br), mr = Tr;
    }
    return yr;
  };
}
function FpSqrt$1(lr) {
  if (lr % _4n$1 === _3n$3) {
    const ar = (lr + _1n$8) / _4n$1;
    return function(ur, fr) {
      const dr = ur.pow(fr, ar);
      if (!ur.eql(ur.sqr(dr), fr))
        throw new Error("Cannot find square root");
      return dr;
    };
  }
  if (lr % _8n$1 === _5n$1) {
    const ar = (lr - _5n$1) / _8n$1;
    return function(ur, fr) {
      const dr = ur.mul(fr, _2n$4), hr = ur.pow(dr, ar), gr = ur.mul(fr, hr), vr = ur.mul(ur.mul(gr, _2n$4), hr), mr = ur.mul(gr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(mr), fr))
        throw new Error("Cannot find square root");
      return mr;
    };
  }
  return tonelliShanks$1(lr);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(lr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, cr = FIELD_FIELDS$1.reduce((ur, fr) => (ur[fr] = "function", ur), ar);
  return validateObject$1(lr, cr);
}
function FpPow$1(lr, ar, cr) {
  if (cr < _0n$8)
    throw new Error("Expected power > 0");
  if (cr === _0n$8)
    return lr.ONE;
  if (cr === _1n$8)
    return ar;
  let ur = lr.ONE, fr = ar;
  for (; cr > _0n$8; )
    cr & _1n$8 && (ur = lr.mul(ur, fr)), fr = lr.sqr(fr), cr >>= _1n$8;
  return ur;
}
function FpInvertBatch$1(lr, ar) {
  const cr = new Array(ar.length), ur = ar.reduce((dr, hr, gr) => lr.is0(hr) ? dr : (cr[gr] = dr, lr.mul(dr, hr)), lr.ONE), fr = lr.inv(ur);
  return ar.reduceRight((dr, hr, gr) => lr.is0(hr) ? dr : (cr[gr] = lr.mul(dr, cr[gr]), lr.mul(dr, hr)), fr), cr;
}
function nLength$1(lr, ar) {
  const cr = ar !== void 0 ? ar : lr.toString(2).length, ur = Math.ceil(cr / 8);
  return { nBitLength: cr, nByteLength: ur };
}
function Field$1(lr, ar, cr = !1, ur = {}) {
  if (lr <= _0n$8)
    throw new Error(`Expected Fp ORDER > 0, got ${lr}`);
  const { nBitLength: fr, nByteLength: dr } = nLength$1(lr, ar);
  if (dr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const hr = FpSqrt$1(lr), gr = Object.freeze({
    ORDER: lr,
    BITS: fr,
    BYTES: dr,
    MASK: bitMask$1(fr),
    ZERO: _0n$8,
    ONE: _1n$8,
    create: (vr) => mod$1(vr, lr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$8 <= vr && vr < lr;
    },
    is0: (vr) => vr === _0n$8,
    isOdd: (vr) => (vr & _1n$8) === _1n$8,
    neg: (vr) => mod$1(-vr, lr),
    eql: (vr, mr) => vr === mr,
    sqr: (vr) => mod$1(vr * vr, lr),
    add: (vr, mr) => mod$1(vr + mr, lr),
    sub: (vr, mr) => mod$1(vr - mr, lr),
    mul: (vr, mr) => mod$1(vr * mr, lr),
    pow: (vr, mr) => FpPow$1(gr, vr, mr),
    div: (vr, mr) => mod$1(vr * invert$1(mr, lr), lr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, mr) => vr + mr,
    subN: (vr, mr) => vr - mr,
    mulN: (vr, mr) => vr * mr,
    inv: (vr) => invert$1(vr, lr),
    sqrt: ur.sqrt || ((vr) => hr(gr, vr)),
    invertBatch: (vr) => FpInvertBatch$1(gr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, mr, br) => br ? mr : vr,
    toBytes: (vr) => cr ? numberToBytesLE$1(vr, dr) : numberToBytesBE$1(vr, dr),
    fromBytes: (vr) => {
      if (vr.length !== dr)
        throw new Error(`Fp.fromBytes: expected ${dr}, got ${vr.length}`);
      return cr ? bytesToNumberLE$1(vr) : bytesToNumberBE$1(vr);
    }
  });
  return Object.freeze(gr);
}
function hashToPrivateScalar(lr, ar, cr = !1) {
  lr = ensureBytes$2("privateHash", lr);
  const ur = lr.length, fr = nLength$1(ar).nByteLength + 8;
  if (fr < 24 || ur < fr || ur > 1024)
    throw new Error(`hashToPrivateScalar: expected ${fr}-1024 bytes of input, got ${ur}`);
  const dr = cr ? bytesToNumberLE$1(lr) : bytesToNumberBE$1(lr);
  return mod$1(dr, ar - _1n$8) + _1n$8;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$7 = BigInt(1);
function wNAF$1(lr, ar) {
  const cr = (fr, dr) => {
    const hr = dr.negate();
    return fr ? hr : dr;
  }, ur = (fr) => {
    const dr = Math.ceil(ar / fr) + 1, hr = 2 ** (fr - 1);
    return { windows: dr, windowSize: hr };
  };
  return {
    constTimeNegate: cr,
    // non-const time multiplication ladder
    unsafeLadder(fr, dr) {
      let hr = lr.ZERO, gr = fr;
      for (; dr > _0n$7; )
        dr & _1n$7 && (hr = hr.add(gr)), gr = gr.double(), dr >>= _1n$7;
      return hr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(fr, dr) {
      const { windows: hr, windowSize: gr } = ur(dr), vr = [];
      let mr = fr, br = mr;
      for (let yr = 0; yr < hr; yr++) {
        br = mr, vr.push(br);
        for (let kr = 1; kr < gr; kr++)
          br = br.add(mr), vr.push(br);
        mr = br.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(fr, dr, hr) {
      const { windows: gr, windowSize: vr } = ur(fr);
      let mr = lr.ZERO, br = lr.BASE;
      const yr = BigInt(2 ** fr - 1), kr = 2 ** fr, Tr = BigInt(fr);
      for (let _r = 0; _r < gr; _r++) {
        const Er = _r * vr;
        let xr = Number(hr & yr);
        hr >>= Tr, xr > vr && (xr -= kr, hr += _1n$7);
        const Cr = Er, Ar = Er + Math.abs(xr) - 1, Lr = _r % 2 !== 0, Dr = xr < 0;
        xr === 0 ? br = br.add(cr(Lr, dr[Cr])) : mr = mr.add(cr(Dr, dr[Ar]));
      }
      return { p: mr, f: br };
    },
    wNAFCached(fr, dr, hr, gr) {
      const vr = fr._WINDOW_SIZE || 1;
      let mr = dr.get(fr);
      return mr || (mr = this.precomputeWindow(fr, vr), vr !== 1 && dr.set(fr, gr(mr))), this.wNAF(vr, mr, hr);
    }
  };
}
function validateBasic$1(lr) {
  return validateField$1(lr.Fp), validateObject$1(lr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength$1(lr.n, lr.nBitLength),
    ...lr,
    p: lr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(lr) {
  const ar = validateBasic$1(lr);
  validateObject$1(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: cr, Fp: ur, a: fr } = ar;
  if (cr) {
    if (!ur.eql(fr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof cr != "object" || typeof cr.beta != "bigint" || typeof cr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$2, DER$1 = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(lr) {
    const { Err: ar } = DER$1;
    if (lr.length < 2 || lr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const cr = lr[1], ur = lr.subarray(2, cr + 2);
    if (!cr || ur.length !== cr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(ur), l: lr.subarray(cr + 2) };
  },
  toSig(lr) {
    const { Err: ar } = DER$1, cr = typeof lr == "string" ? h2b$1(lr) : lr;
    if (!(cr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = cr.length;
    if (ur < 2 || cr[0] != 48)
      throw new ar("Invalid signature tag");
    if (cr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: fr, l: dr } = DER$1._parseInt(cr.subarray(2)), { d: hr, l: gr } = DER$1._parseInt(dr);
    if (gr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: fr, s: hr };
  },
  hexFromSig(lr) {
    const ar = (mr) => Number.parseInt(mr[0], 16) & 8 ? "00" + mr : mr, cr = (mr) => {
      const br = mr.toString(16);
      return br.length & 1 ? `0${br}` : br;
    }, ur = ar(cr(lr.s)), fr = ar(cr(lr.r)), dr = ur.length / 2, hr = fr.length / 2, gr = cr(dr), vr = cr(hr);
    return `30${cr(hr + dr + 4)}02${vr}${fr}02${gr}${ur}`;
  }
}, _0n$6 = BigInt(0), _1n$6 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(lr) {
  const ar = validatePointOpts$1(lr), { Fp: cr } = ar, ur = ar.toBytes || ((_r, Er, xr) => {
    const Cr = Er.toAffine();
    return concatBytes$6(Uint8Array.from([4]), cr.toBytes(Cr.x), cr.toBytes(Cr.y));
  }), fr = ar.fromBytes || ((_r) => {
    const Er = _r.subarray(1), xr = cr.fromBytes(Er.subarray(0, cr.BYTES)), Cr = cr.fromBytes(Er.subarray(cr.BYTES, 2 * cr.BYTES));
    return { x: xr, y: Cr };
  });
  function dr(_r) {
    const { a: Er, b: xr } = ar, Cr = cr.sqr(_r), Ar = cr.mul(Cr, _r);
    return cr.add(cr.add(Ar, cr.mul(_r, Er)), xr);
  }
  if (!cr.eql(cr.sqr(ar.Gy), dr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function hr(_r) {
    return typeof _r == "bigint" && _0n$6 < _r && _r < ar.n;
  }
  function gr(_r) {
    if (!hr(_r))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(_r) {
    const { allowedPrivateKeyLengths: Er, nByteLength: xr, wrapPrivateKey: Cr, n: Ar } = ar;
    if (Er && typeof _r != "bigint") {
      if (_r instanceof Uint8Array && (_r = bytesToHex$5(_r)), typeof _r != "string" || !Er.includes(_r.length))
        throw new Error("Invalid key");
      _r = _r.padStart(xr * 2, "0");
    }
    let Lr;
    try {
      Lr = typeof _r == "bigint" ? _r : bytesToNumberBE$1(ensureBytes$2("private key", _r, xr));
    } catch (Dr) {
      throw new Error(`private key must be ${xr} bytes, hex or bigint, not ${typeof _r}`);
    }
    return Cr && (Lr = mod$1(Lr, Ar)), gr(Lr), Lr;
  }
  const mr = /* @__PURE__ */ new Map();
  function br(_r) {
    if (!(_r instanceof yr))
      throw new Error("ProjectivePoint expected");
  }
  class yr {
    constructor(Er, xr, Cr) {
      if (this.px = Er, this.py = xr, this.pz = Cr, Er == null || !cr.isValid(Er))
        throw new Error("x required");
      if (xr == null || !cr.isValid(xr))
        throw new Error("y required");
      if (Cr == null || !cr.isValid(Cr))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Er) {
      const { x: xr, y: Cr } = Er || {};
      if (!Er || !cr.isValid(xr) || !cr.isValid(Cr))
        throw new Error("invalid affine point");
      if (Er instanceof yr)
        throw new Error("projective point not allowed");
      const Ar = (Lr) => cr.eql(Lr, cr.ZERO);
      return Ar(xr) && Ar(Cr) ? yr.ZERO : new yr(xr, Cr, cr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Er) {
      const xr = cr.invertBatch(Er.map((Cr) => Cr.pz));
      return Er.map((Cr, Ar) => Cr.toAffine(xr[Ar])).map(yr.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Er) {
      const xr = yr.fromAffine(fr(ensureBytes$2("pointHex", Er)));
      return xr.assertValidity(), xr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Er) {
      return yr.BASE.multiply(vr(Er));
    }
    // "Private method", don't use it directly
    _setWindowSize(Er) {
      this._WINDOW_SIZE = Er, mr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Er, y: xr } = this.toAffine();
      if (!cr.isValid(Er) || !cr.isValid(xr))
        throw new Error("bad point: x or y not FE");
      const Cr = cr.sqr(xr), Ar = dr(Er);
      if (!cr.eql(Cr, Ar))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Er } = this.toAffine();
      if (cr.isOdd)
        return !cr.isOdd(Er);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Er) {
      br(Er);
      const { px: xr, py: Cr, pz: Ar } = this, { px: Lr, py: Dr, pz: Nr } = Er, Hr = cr.eql(cr.mul(xr, Nr), cr.mul(Lr, Ar)), $r = cr.eql(cr.mul(Cr, Nr), cr.mul(Dr, Ar));
      return Hr && $r;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new yr(this.px, cr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Er, b: xr } = ar, Cr = cr.mul(xr, _3n$2), { px: Ar, py: Lr, pz: Dr } = this;
      let Nr = cr.ZERO, Hr = cr.ZERO, $r = cr.ZERO, Wr = cr.mul(Ar, Ar), Zr = cr.mul(Lr, Lr), oi = cr.mul(Dr, Dr), Jr = cr.mul(Ar, Lr);
      return Jr = cr.add(Jr, Jr), $r = cr.mul(Ar, Dr), $r = cr.add($r, $r), Nr = cr.mul(Er, $r), Hr = cr.mul(Cr, oi), Hr = cr.add(Nr, Hr), Nr = cr.sub(Zr, Hr), Hr = cr.add(Zr, Hr), Hr = cr.mul(Nr, Hr), Nr = cr.mul(Jr, Nr), $r = cr.mul(Cr, $r), oi = cr.mul(Er, oi), Jr = cr.sub(Wr, oi), Jr = cr.mul(Er, Jr), Jr = cr.add(Jr, $r), $r = cr.add(Wr, Wr), Wr = cr.add($r, Wr), Wr = cr.add(Wr, oi), Wr = cr.mul(Wr, Jr), Hr = cr.add(Hr, Wr), oi = cr.mul(Lr, Dr), oi = cr.add(oi, oi), Wr = cr.mul(oi, Jr), Nr = cr.sub(Nr, Wr), $r = cr.mul(oi, Zr), $r = cr.add($r, $r), $r = cr.add($r, $r), new yr(Nr, Hr, $r);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Er) {
      br(Er);
      const { px: xr, py: Cr, pz: Ar } = this, { px: Lr, py: Dr, pz: Nr } = Er;
      let Hr = cr.ZERO, $r = cr.ZERO, Wr = cr.ZERO;
      const Zr = ar.a, oi = cr.mul(ar.b, _3n$2);
      let Jr = cr.mul(xr, Lr), Yr = cr.mul(Cr, Dr), li = cr.mul(Ar, Nr), Si = cr.add(xr, Cr), ci = cr.add(Lr, Dr);
      Si = cr.mul(Si, ci), ci = cr.add(Jr, Yr), Si = cr.sub(Si, ci), ci = cr.add(xr, Ar);
      let hi = cr.add(Lr, Nr);
      return ci = cr.mul(ci, hi), hi = cr.add(Jr, li), ci = cr.sub(ci, hi), hi = cr.add(Cr, Ar), Hr = cr.add(Dr, Nr), hi = cr.mul(hi, Hr), Hr = cr.add(Yr, li), hi = cr.sub(hi, Hr), Wr = cr.mul(Zr, ci), Hr = cr.mul(oi, li), Wr = cr.add(Hr, Wr), Hr = cr.sub(Yr, Wr), Wr = cr.add(Yr, Wr), $r = cr.mul(Hr, Wr), Yr = cr.add(Jr, Jr), Yr = cr.add(Yr, Jr), li = cr.mul(Zr, li), ci = cr.mul(oi, ci), Yr = cr.add(Yr, li), li = cr.sub(Jr, li), li = cr.mul(Zr, li), ci = cr.add(ci, li), Jr = cr.mul(Yr, ci), $r = cr.add($r, Jr), Jr = cr.mul(hi, ci), Hr = cr.mul(Si, Hr), Hr = cr.sub(Hr, Jr), Jr = cr.mul(Si, Yr), Wr = cr.mul(hi, Wr), Wr = cr.add(Wr, Jr), new yr(Hr, $r, Wr);
    }
    subtract(Er) {
      return this.add(Er.negate());
    }
    is0() {
      return this.equals(yr.ZERO);
    }
    wNAF(Er) {
      return Tr.wNAFCached(this, mr, Er, (xr) => {
        const Cr = cr.invertBatch(xr.map((Ar) => Ar.pz));
        return xr.map((Ar, Lr) => Ar.toAffine(Cr[Lr])).map(yr.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Er) {
      const xr = yr.ZERO;
      if (Er === _0n$6)
        return xr;
      if (gr(Er), Er === _1n$6)
        return this;
      const { endo: Cr } = ar;
      if (!Cr)
        return Tr.unsafeLadder(this, Er);
      let { k1neg: Ar, k1: Lr, k2neg: Dr, k2: Nr } = Cr.splitScalar(Er), Hr = xr, $r = xr, Wr = this;
      for (; Lr > _0n$6 || Nr > _0n$6; )
        Lr & _1n$6 && (Hr = Hr.add(Wr)), Nr & _1n$6 && ($r = $r.add(Wr)), Wr = Wr.double(), Lr >>= _1n$6, Nr >>= _1n$6;
      return Ar && (Hr = Hr.negate()), Dr && ($r = $r.negate()), $r = new yr(cr.mul($r.px, Cr.beta), $r.py, $r.pz), Hr.add($r);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Er) {
      gr(Er);
      let xr = Er, Cr, Ar;
      const { endo: Lr } = ar;
      if (Lr) {
        const { k1neg: Dr, k1: Nr, k2neg: Hr, k2: $r } = Lr.splitScalar(xr);
        let { p: Wr, f: Zr } = this.wNAF(Nr), { p: oi, f: Jr } = this.wNAF($r);
        Wr = Tr.constTimeNegate(Dr, Wr), oi = Tr.constTimeNegate(Hr, oi), oi = new yr(cr.mul(oi.px, Lr.beta), oi.py, oi.pz), Cr = Wr.add(oi), Ar = Zr.add(Jr);
      } else {
        const { p: Dr, f: Nr } = this.wNAF(xr);
        Cr = Dr, Ar = Nr;
      }
      return yr.normalizeZ([Cr, Ar])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Er, xr, Cr) {
      const Ar = yr.BASE, Lr = (Nr, Hr) => Hr === _0n$6 || Hr === _1n$6 || !Nr.equals(Ar) ? Nr.multiplyUnsafe(Hr) : Nr.multiply(Hr), Dr = Lr(this, xr).add(Lr(Er, Cr));
      return Dr.is0() ? void 0 : Dr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(Er) {
      const { px: xr, py: Cr, pz: Ar } = this, Lr = this.is0();
      Er == null && (Er = Lr ? cr.ONE : cr.inv(Ar));
      const Dr = cr.mul(xr, Er), Nr = cr.mul(Cr, Er), Hr = cr.mul(Ar, Er);
      if (Lr)
        return { x: cr.ZERO, y: cr.ZERO };
      if (!cr.eql(Hr, cr.ONE))
        throw new Error("invZ was invalid");
      return { x: Dr, y: Nr };
    }
    isTorsionFree() {
      const { h: Er, isTorsionFree: xr } = ar;
      if (Er === _1n$6)
        return !0;
      if (xr)
        return xr(yr, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Er, clearCofactor: xr } = ar;
      return Er === _1n$6 ? this : xr ? xr(yr, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Er = !0) {
      return this.assertValidity(), ur(yr, this, Er);
    }
    toHex(Er = !0) {
      return bytesToHex$5(this.toRawBytes(Er));
    }
  }
  yr.BASE = new yr(ar.Gx, ar.Gy, cr.ONE), yr.ZERO = new yr(cr.ZERO, cr.ONE, cr.ZERO);
  const kr = ar.nBitLength, Tr = wNAF$1(yr, ar.endo ? Math.ceil(kr / 2) : kr);
  return {
    CURVE: ar,
    ProjectivePoint: yr,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: dr,
    isWithinCurveOrder: hr
  };
}
function validateOpts$1(lr) {
  const ar = validateBasic$1(lr);
  return validateObject$1(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass$1(lr) {
  const ar = validateOpts$1(lr), { Fp: cr, n: ur } = ar, fr = cr.BYTES + 1, dr = 2 * cr.BYTES + 1;
  function hr(ci) {
    return _0n$6 < ci && ci < cr.ORDER;
  }
  function gr(ci) {
    return mod$1(ci, ur);
  }
  function vr(ci) {
    return invert$1(ci, ur);
  }
  const { ProjectivePoint: mr, normPrivateKeyToScalar: br, weierstrassEquation: yr, isWithinCurveOrder: kr } = weierstrassPoints$1({
    ...ar,
    toBytes(ci, hi, Ei) {
      const di = hi.toAffine(), gi = cr.toBytes(di.x), Li = concatBytes$6;
      return Ei ? Li(Uint8Array.from([hi.hasEvenY() ? 2 : 3]), gi) : Li(Uint8Array.from([4]), gi, cr.toBytes(di.y));
    },
    fromBytes(ci) {
      const hi = ci.length, Ei = ci[0], di = ci.subarray(1);
      if (hi === fr && (Ei === 2 || Ei === 3)) {
        const gi = bytesToNumberBE$1(di);
        if (!hr(gi))
          throw new Error("Point is not on curve");
        const Li = yr(gi);
        let ui = cr.sqrt(Li);
        const wi = (ui & _1n$6) === _1n$6;
        return (Ei & 1) === 1 !== wi && (ui = cr.neg(ui)), { x: gi, y: ui };
      } else if (hi === dr && Ei === 4) {
        const gi = cr.fromBytes(di.subarray(0, cr.BYTES)), Li = cr.fromBytes(di.subarray(cr.BYTES, 2 * cr.BYTES));
        return { x: gi, y: Li };
      } else
        throw new Error(`Point of length ${hi} was invalid. Expected ${fr} compressed bytes or ${dr} uncompressed bytes`);
    }
  }), Tr = (ci) => bytesToHex$5(numberToBytesBE$1(ci, ar.nByteLength));
  function _r(ci) {
    const hi = ur >> _1n$6;
    return ci > hi;
  }
  function Er(ci) {
    return _r(ci) ? gr(-ci) : ci;
  }
  const xr = (ci, hi, Ei) => bytesToNumberBE$1(ci.slice(hi, Ei));
  class Cr {
    constructor(hi, Ei, di) {
      this.r = hi, this.s = Ei, this.recovery = di, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hi) {
      const Ei = ar.nByteLength;
      return hi = ensureBytes$2("compactSignature", hi, Ei * 2), new Cr(xr(hi, 0, Ei), xr(hi, Ei, 2 * Ei));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hi) {
      const { r: Ei, s: di } = DER$1.toSig(ensureBytes$2("DER", hi));
      return new Cr(Ei, di);
    }
    assertValidity() {
      if (!kr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!kr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(hi) {
      return new Cr(this.r, this.s, hi);
    }
    recoverPublicKey(hi) {
      const { r: Ei, s: di, recovery: gi } = this, Li = $r(ensureBytes$2("msgHash", hi));
      if (gi == null || ![0, 1, 2, 3].includes(gi))
        throw new Error("recovery id invalid");
      const ui = gi === 2 || gi === 3 ? Ei + ar.n : Ei;
      if (ui >= cr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const wi = gi & 1 ? "03" : "02", Ui = mr.fromHex(wi + Tr(ui)), yi = vr(ui), Vi = gr(-Li * yi), Oi = gr(di * yi), Mi = mr.BASE.multiplyAndAddUnsafe(Ui, Vi, Oi);
      if (!Mi)
        throw new Error("point at infinify");
      return Mi.assertValidity(), Mi;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return _r(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Cr(this.r, gr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$6(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$6(this.toCompactHex());
    }
    toCompactHex() {
      return Tr(this.r) + Tr(this.s);
    }
  }
  const Ar = {
    isValidPrivateKey(ci) {
      try {
        return br(ci), !0;
      } catch (hi) {
        return !1;
      }
    },
    normPrivateKeyToScalar: br,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const ci = ar.randomBytes(cr.BYTES + 8), hi = hashToPrivateScalar(ci, ur);
      return numberToBytesBE$1(hi, ar.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(ci = 8, hi = mr.BASE) {
      return hi._setWindowSize(ci), hi.multiply(BigInt(3)), hi;
    }
  };
  function Lr(ci, hi = !0) {
    return mr.fromPrivateKey(ci).toRawBytes(hi);
  }
  function Dr(ci) {
    const hi = ci instanceof Uint8Array, Ei = typeof ci == "string", di = (hi || Ei) && ci.length;
    return hi ? di === fr || di === dr : Ei ? di === 2 * fr || di === 2 * dr : ci instanceof mr;
  }
  function Nr(ci, hi, Ei = !0) {
    if (Dr(ci))
      throw new Error("first arg must be private key");
    if (!Dr(hi))
      throw new Error("second arg must be public key");
    return mr.fromHex(hi).multiply(br(ci)).toRawBytes(Ei);
  }
  const Hr = ar.bits2int || function(ci) {
    const hi = bytesToNumberBE$1(ci), Ei = ci.length * 8 - ar.nBitLength;
    return Ei > 0 ? hi >> BigInt(Ei) : hi;
  }, $r = ar.bits2int_modN || function(ci) {
    return gr(Hr(ci));
  }, Wr = bitMask$1(ar.nBitLength);
  function Zr(ci) {
    if (typeof ci != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$6 <= ci && ci < Wr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE$1(ci, ar.nByteLength);
  }
  function oi(ci, hi, Ei = Jr) {
    if (["recovered", "canonical"].some((mi) => mi in Ei))
      throw new Error("sign() legacy options not supported");
    const { hash: di, randomBytes: gi } = ar;
    let { lowS: Li, prehash: ui, extraEntropy: wi } = Ei;
    Li == null && (Li = !0), ci = ensureBytes$2("msgHash", ci), ui && (ci = ensureBytes$2("prehashed msgHash", di(ci)));
    const Ui = $r(ci), yi = br(hi), Vi = [Zr(yi), Zr(Ui)];
    if (wi != null) {
      const mi = wi === !0 ? gi(cr.BYTES) : wi;
      Vi.push(ensureBytes$2("extraEntropy", mi, cr.BYTES));
    }
    const Oi = concatBytes$6(...Vi), Mi = Ui;
    function Ii(mi) {
      const _i = Hr(mi);
      if (!kr(_i))
        return;
      const Ci = vr(_i), Ki = mr.BASE.multiply(_i).toAffine(), Ni = gr(Ki.x);
      if (Ni === _0n$6)
        return;
      const ia = gr(Ci * gr(Mi + Ni * yi));
      if (ia === _0n$6)
        return;
      let ea = (Ki.x === Ni ? 0 : 2) | Number(Ki.y & _1n$6), la = ia;
      return Li && _r(ia) && (la = Er(ia), ea ^= 1), new Cr(Ni, la, ea);
    }
    return { seed: Oi, k2sig: Ii };
  }
  const Jr = { lowS: ar.lowS, prehash: !1 }, Yr = { lowS: ar.lowS, prehash: !1 };
  function li(ci, hi, Ei = Jr) {
    const { seed: di, k2sig: gi } = oi(ci, hi, Ei), Li = ar;
    return createHmacDrbg$1(Li.hash.outputLen, Li.nByteLength, Li.hmac)(di, gi);
  }
  mr.BASE._setWindowSize(8);
  function Si(ci, hi, Ei, di = Yr) {
    var Ki;
    const gi = ci;
    if (hi = ensureBytes$2("msgHash", hi), Ei = ensureBytes$2("publicKey", Ei), "strict" in di)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Li, prehash: ui } = di;
    let wi, Ui;
    try {
      if (typeof gi == "string" || gi instanceof Uint8Array)
        try {
          wi = Cr.fromDER(gi);
        } catch (Ni) {
          if (!(Ni instanceof DER$1.Err))
            throw Ni;
          wi = Cr.fromCompact(gi);
        }
      else if (typeof gi == "object" && typeof gi.r == "bigint" && typeof gi.s == "bigint") {
        const { r: Ni, s: ia } = gi;
        wi = new Cr(Ni, ia);
      } else
        throw new Error("PARSE");
      Ui = mr.fromHex(Ei);
    } catch (Ni) {
      if (Ni.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Li && wi.hasHighS())
      return !1;
    ui && (hi = ar.hash(hi));
    const { r: yi, s: Vi } = wi, Oi = $r(hi), Mi = vr(Vi), Ii = gr(Oi * Mi), mi = gr(yi * Mi), _i = (Ki = mr.BASE.multiplyAndAddUnsafe(Ui, Ii, mi)) == null ? void 0 : Ki.toAffine();
    return _i ? gr(_i.x) === yi : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Lr,
    getSharedSecret: Nr,
    sign: li,
    verify: Si,
    ProjectivePoint: mr,
    Signature: Cr,
    utils: Ar
  };
}
let HMAC$5 = class extends Hash$5 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$6.hash(ar);
    const ur = toBytes$6(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$6.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$5 = (lr, ar, cr) => new HMAC$5(lr, ar).update(cr).digest();
hmac$5.create = (lr, ar) => new HMAC$5(lr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(lr) {
  return {
    hash: lr,
    hmac: (ar, ...cr) => hmac$5(lr, ar, concatBytes$7(...cr)),
    randomBytes: randomBytes$5
  };
}
function createCurve$1(lr, ar) {
  const cr = (ur) => weierstrass$1({ ...lr, ...getHash$1(ur) });
  return Object.freeze({ ...cr(ar), create: cr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$5 = BigInt(1), _2n$3 = BigInt(2), divNearest$1 = (lr, ar) => (lr + ar / _2n$3) / ar;
function sqrtMod$1(lr) {
  const ar = secp256k1P$1, cr = BigInt(3), ur = BigInt(6), fr = BigInt(11), dr = BigInt(22), hr = BigInt(23), gr = BigInt(44), vr = BigInt(88), mr = lr * lr * lr % ar, br = mr * mr * lr % ar, yr = pow2$1(br, cr, ar) * br % ar, kr = pow2$1(yr, cr, ar) * br % ar, Tr = pow2$1(kr, _2n$3, ar) * mr % ar, _r = pow2$1(Tr, fr, ar) * Tr % ar, Er = pow2$1(_r, dr, ar) * _r % ar, xr = pow2$1(Er, gr, ar) * Er % ar, Cr = pow2$1(xr, vr, ar) * xr % ar, Ar = pow2$1(Cr, gr, ar) * Er % ar, Lr = pow2$1(Ar, cr, ar) * br % ar, Dr = pow2$1(Lr, hr, ar) * _r % ar, Nr = pow2$1(Dr, ur, ar) * mr % ar, Hr = pow2$1(Nr, _2n$3, ar);
  if (!Fp$1.eql(Fp$1.sqr(Hr), lr))
    throw new Error("Cannot find square root");
  return Hr;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 }), secp256k1$1 = createCurve$1({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (lr) => {
      const ar = secp256k1N$1, cr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n$5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), fr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), dr = cr, hr = BigInt("0x100000000000000000000000000000000"), gr = divNearest$1(dr * lr, ar), vr = divNearest$1(-ur * lr, ar);
      let mr = mod$1(lr - gr * cr - vr * fr, ar), br = mod$1(-gr * ur - vr * dr, ar);
      const yr = mr > hr, kr = br > hr;
      if (yr && (mr = ar - mr), kr && (br = ar - br), mr > hr || br > hr)
        throw new Error("splitScalar: Endomorphism failed, k=" + lr);
      return { k1neg: yr, k1: mr, k2neg: kr, k2: br };
    }
  }
}, sha256$5), _0n$5 = BigInt(0), fe$2 = (lr) => typeof lr == "bigint" && _0n$5 < lr && lr < secp256k1P$1, ge$3 = (lr) => typeof lr == "bigint" && _0n$5 < lr && lr < secp256k1N$1, TAGGED_HASH_PREFIXES$1 = {};
function taggedHash$1(lr, ...ar) {
  let cr = TAGGED_HASH_PREFIXES$1[lr];
  if (cr === void 0) {
    const ur = sha256$5(Uint8Array.from(lr, (fr) => fr.charCodeAt(0)));
    cr = concatBytes$6(ur, ur), TAGGED_HASH_PREFIXES$1[lr] = cr;
  }
  return sha256$5(concatBytes$6(cr, ...ar));
}
const pointToBytes$1 = (lr) => lr.toRawBytes(!0).slice(1), numTo32b$1 = (lr) => numberToBytesBE$1(lr, 32), modP$1 = (lr) => mod$1(lr, secp256k1P$1), modN$1 = (lr) => mod$1(lr, secp256k1N$1), Point$2 = secp256k1$1.ProjectivePoint, GmulAdd$1 = (lr, ar, cr) => Point$2.BASE.multiplyAndAddUnsafe(lr, ar, cr);
function schnorrGetExtPubKey$1(lr) {
  let ar = secp256k1$1.utils.normPrivateKeyToScalar(lr), cr = Point$2.fromPrivateKey(ar);
  return { scalar: cr.hasEvenY() ? ar : modN$1(-ar), bytes: pointToBytes$1(cr) };
}
function lift_x$1(lr) {
  if (!fe$2(lr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP$1(lr * lr), cr = modP$1(ar * lr + BigInt(7));
  let ur = sqrtMod$1(cr);
  ur % _2n$3 !== _0n$5 && (ur = modP$1(-ur));
  const fr = new Point$2(lr, ur, _1n$5);
  return fr.assertValidity(), fr;
}
function challenge$1(...lr) {
  return modN$1(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge", ...lr)));
}
function schnorrGetPublicKey$1(lr) {
  return schnorrGetExtPubKey$1(lr).bytes;
}
function schnorrSign$1(lr, ar, cr = randomBytes$5(32)) {
  const ur = ensureBytes$2("message", lr), { bytes: fr, scalar: dr } = schnorrGetExtPubKey$1(ar), hr = ensureBytes$2("auxRand", cr, 32), gr = numTo32b$1(dr ^ bytesToNumberBE$1(taggedHash$1("BIP0340/aux", hr))), vr = taggedHash$1("BIP0340/nonce", gr, fr, ur), mr = modN$1(bytesToNumberBE$1(vr));
  if (mr === _0n$5)
    throw new Error("sign failed: k is zero");
  const { bytes: br, scalar: yr } = schnorrGetExtPubKey$1(mr), kr = challenge$1(br, fr, ur), Tr = new Uint8Array(64);
  if (Tr.set(br, 0), Tr.set(numTo32b$1(modN$1(yr + kr * dr)), 32), !schnorrVerify$1(Tr, ur, fr))
    throw new Error("sign: Invalid signature produced");
  return Tr;
}
function schnorrVerify$1(lr, ar, cr) {
  const ur = ensureBytes$2("signature", lr, 64), fr = ensureBytes$2("message", ar), dr = ensureBytes$2("publicKey", cr, 32);
  try {
    const hr = lift_x$1(bytesToNumberBE$1(dr)), gr = bytesToNumberBE$1(ur.subarray(0, 32));
    if (!fe$2(gr))
      return !1;
    const vr = bytesToNumberBE$1(ur.subarray(32, 64));
    if (!ge$3(vr))
      return !1;
    const mr = challenge$1(numTo32b$1(gr), pointToBytes$1(hr), fr), br = GmulAdd$1(hr, vr, modN$1(-mr));
    return !(!br || !br.hasEvenY() || br.toAffine().x !== gr);
  } catch (hr) {
    return !1;
  }
}
const schnorr$1 = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey$1,
  sign: schnorrSign$1,
  verify: schnorrVerify$1,
  utils: {
    randomPrivateKey: secp256k1$1.utils.randomPrivateKey,
    lift_x: lift_x$1,
    pointToBytes: pointToBytes$1,
    numberToBytesBE: numberToBytesBE$1,
    bytesToNumberBE: bytesToNumberBE$1,
    taggedHash: taggedHash$1,
    mod: mod$1
  }
}))(), crypto$5 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$6 = (lr) => lr instanceof Uint8Array, createView$4 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$4 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$5)
  throw new Error("Non little-endian hardware is not supported");
const hexes$4 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$4(lr) {
  if (!u8a$6(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$4[lr[cr]];
  return ar;
}
function hexToBytes$5(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function utf8ToBytes$6(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$5(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$6(lr)), !u8a$6(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$5(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$6(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$4 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$4(lr) {
  const ar = (ur) => lr().update(toBytes$5(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$4(lr = 32) {
  if (crypto$5 && typeof crypto$5.getRandomValues == "function")
    return crypto$5.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$5(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$4(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$5(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$5(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$5(lr.outputLen), number$5(lr.blockLen);
}
function exists$5(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$5(lr, ar) {
  bytes$5(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$5 = {
  number: number$5,
  bool: bool$4,
  bytes: bytes$5,
  hash: hash$5,
  exists: exists$5,
  output: output$5
};
function setBigUint64$4(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
let SHA2$4 = class extends Hash$4 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$4(this.buffer);
  }
  update(ar) {
    assert$5.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$5(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView$4(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64$4(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView$4(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$5 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$4 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$4 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$4 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$4 = new Uint32Array(64);
let SHA256$4 = class extends SHA2$4 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$4[0] | 0, this.B = IV$4[1] | 0, this.C = IV$4[2] | 0, this.D = IV$4[3] | 0, this.E = IV$4[4] | 0, this.F = IV$4[5] | 0, this.G = IV$4[6] | 0, this.H = IV$4[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W$4[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W$4[yr - 15], Tr = SHA256_W$4[yr - 2], _r = rotr$4(kr, 7) ^ rotr$4(kr, 18) ^ kr >>> 3, Er = rotr$4(Tr, 17) ^ rotr$4(Tr, 19) ^ Tr >>> 10;
      SHA256_W$4[yr] = Er + SHA256_W$4[yr - 7] + _r + SHA256_W$4[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr$4(gr, 6) ^ rotr$4(gr, 11) ^ rotr$4(gr, 25), Tr = br + kr + Chi$5(gr, vr, mr) + SHA256_K$4[yr] + SHA256_W$4[yr] | 0, Er = (rotr$4(ur, 2) ^ rotr$4(ur, 13) ^ rotr$4(ur, 22)) + Maj$4(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W$4.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$2 = class extends SHA256$4 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$4 = wrapConstructor$4(() => new SHA256$4());
wrapConstructor$4(() => new SHA224$2());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$2(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain$3(...lr) {
  const ar = (fr, dr) => (hr) => fr(dr(hr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet$3(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber$2(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$4(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding$3(lr, ar = "=") {
  if (assertNumber$2(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize$3(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix$3(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((hr) => {
    if (assertNumber$2(hr), hr < 0 || hr >= ar)
      throw new Error(`Wrong integer: ${hr}`);
  }); ; ) {
    let hr = 0, gr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const mr = dr[vr], br = ar * hr + mr;
      if (!Number.isSafeInteger(br) || ar * hr / ar !== hr || br - mr !== ar * hr)
        throw new Error("convertRadix: carry overflow");
      if (hr = br % cr, dr[vr] = Math.floor(br / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + hr !== br)
        throw new Error("convertRadix: carry overflow");
      if (gr)
        dr[vr] ? gr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(hr), gr)
      break;
  }
  for (let hr = 0; hr < lr.length - 1 && lr[hr] === 0; hr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$3 = (lr, ar) => ar ? gcd$3(ar, lr % ar) : lr, radix2carry$3 = (lr, ar) => lr + (ar - gcd$3(lr, ar));
function convertRadix2$3(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry$3(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry$3(ar, cr)}`);
  let fr = 0, dr = 0;
  const hr = 2 ** cr - 1, gr = [];
  for (const vr of lr) {
    if (assertNumber$2(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      gr.push((fr >> dr - cr & hr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & hr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && gr.push(fr >>> 0), gr;
}
function radix$3(lr) {
  return assertNumber$2(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$3(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$3(ar, lr, 2 ** 8));
    }
  };
}
function radix2$3(lr, ar = !1) {
  if (assertNumber$2(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$3(8, lr) > 32 || radix2carry$3(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$3(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$3(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper$2(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16$2 = chain$3(radix2$3(4), alphabet$3("0123456789ABCDEF"), join$4("")), base32$2 = chain$3(radix2$3(5), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$4(""), normalize$3((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$3(6), join$4("")), base64url$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$3(6), join$4("")), genBase58$3 = (lr) => chain$3(radix$3(58), alphabet$3(lr), join$4("")), base58$3 = genBase58$3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$2 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$2 = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58$3.encode(ur).padStart(XMR_BLOCK_LEN$2[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN$2.indexOf(ur.length), dr = base58$3.decode(ur);
      for (let hr = 0; hr < dr.length - fr; hr++)
        if (dr[hr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$2 = chain$3(alphabet$3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$4("")), POLYMOD_GENERATORS$2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$2(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$2.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS$2[ur]);
  return cr;
}
function bechChecksum$2(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const hr = lr.charCodeAt(dr);
    if (hr < 33 || hr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod$2(fr) ^ hr >> 5;
  }
  fr = bech32Polymod$2(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod$2(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod$2(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod$2(fr);
  return fr ^= cr, BECH_ALPHABET$2.encode(convertRadix2$3([fr % 2 ** 30], 30, 5, !1));
}
function genBech32$2(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2$3(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper$2(ur);
  function hr(br, yr, kr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof br}`);
    if (!Array.isArray(yr) || yr.length && typeof yr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof yr}`);
    const Tr = br.length + 7 + yr.length;
    if (kr !== !1 && Tr > kr)
      throw new TypeError(`Length ${Tr} exceeds limit ${kr}`);
    return br = br.toLowerCase(), `${br}1${BECH_ALPHABET$2.encode(yr)}${bechChecksum$2(br, yr, ar)}`;
  }
  function gr(br, yr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof br}`);
    if (br.length < 8 || yr !== !1 && br.length > yr)
      throw new TypeError(`Wrong string length: ${br.length} (${br}). Expected (8..${yr})`);
    const kr = br.toLowerCase();
    if (br !== kr && br !== br.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    br = kr;
    const Tr = br.lastIndexOf("1");
    if (Tr === 0 || Tr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const _r = br.slice(0, Tr), Er = br.slice(Tr + 1);
    if (Er.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const xr = BECH_ALPHABET$2.decode(Er).slice(0, -6), Cr = bechChecksum$2(_r, xr, ar);
    if (!Er.endsWith(Cr))
      throw new Error(`Invalid checksum in ${br}: expected "${Cr}"`);
    return { prefix: _r, words: xr };
  }
  const vr = unsafeWrapper$2(gr);
  function mr(br) {
    const { prefix: yr, words: kr } = gr(br, !1);
    return { prefix: yr, words: kr, bytes: ur(kr) };
  }
  return { encode: hr, decode: gr, decodeToBytes: mr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32$3 = genBech32$2("bech32");
genBech32$2("bech32m");
const utf8$2 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex$2 = chain$3(radix2$3(4), alphabet$3("0123456789abcdef"), join$4(""), normalize$3((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS$2 = {
  utf8: utf8$2,
  hex: hex$2,
  base16: base16$2,
  base32: base32$2,
  base64: base64$2,
  base64url: base64url$2,
  base58: base58$3,
  base58xmr: base58xmr$2
};
`${Object.keys(CODERS$2).join(", ")}`;
const wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split(`
`);
function number$4(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$3(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$4(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$4(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$4(lr.outputLen), number$4(lr.blockLen);
}
function exists$4(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$4(lr, ar) {
  bytes$4(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$3 = { number: number$4, bool: bool$3, bytes: bytes$4, hash: hash$4, exists: exists$4, output: output$4 }, assert$4 = assert$3, crypto$4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$5 = (lr) => lr instanceof Uint8Array, createView$3 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$3 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$4)
  throw new Error("Non little-endian hardware is not supported");
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$3(lr) {
  if (!u8a$5(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$3[lr[cr]];
  return ar;
}
function hexToBytes$4(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function utf8ToBytes$5(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$4(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$5(lr)), !u8a$5(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$4(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$5(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts$1(lr, ar) {
  if (ar !== void 0 && toStr.call(ar) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(lr, ar);
}
function wrapConstructor$3(lr) {
  const ar = (ur) => lr().update(toBytes$4(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$3(lr = 32) {
  if (crypto$4 && typeof crypto$4.getRandomValues == "function")
    return crypto$4.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$4 = class extends Hash$3 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, hash$4(ar);
    const ur = toBytes$4(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return exists$4(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$4(this), bytes$4(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$4 = (lr, ar, cr) => new HMAC$4(lr, ar).update(cr).digest();
hmac$4.create = (lr, ar) => new HMAC$4(lr, ar);
function pbkdf2Init(lr, ar, cr, ur) {
  hash$4(lr);
  const fr = checkOpts$1({ dkLen: 32, asyncTick: 10 }, ur), { c: dr, dkLen: hr, asyncTick: gr } = fr;
  if (number$4(dr), number$4(hr), number$4(gr), dr < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const vr = toBytes$4(ar), mr = toBytes$4(cr), br = new Uint8Array(hr), yr = hmac$4.create(lr, vr), kr = yr._cloneInto().update(mr);
  return { c: dr, dkLen: hr, asyncTick: gr, DK: br, PRF: yr, PRFSalt: kr };
}
function pbkdf2Output(lr, ar, cr, ur, fr) {
  return lr.destroy(), ar.destroy(), ur && ur.destroy(), fr.fill(0), cr;
}
function pbkdf2(lr, ar, cr, ur) {
  const { c: fr, dkLen: dr, DK: hr, PRF: gr, PRFSalt: vr } = pbkdf2Init(lr, ar, cr, ur);
  let mr;
  const br = new Uint8Array(4), yr = createView$3(br), kr = new Uint8Array(gr.outputLen);
  for (let Tr = 1, _r = 0; _r < dr; Tr++, _r += gr.outputLen) {
    const Er = hr.subarray(_r, _r + gr.outputLen);
    yr.setInt32(0, Tr, !1), (mr = vr._cloneInto(mr)).update(br).digestInto(kr), Er.set(kr.subarray(0, Er.length));
    for (let xr = 1; xr < fr; xr++) {
      gr._cloneInto(mr).update(kr).digestInto(kr);
      for (let Cr = 0; Cr < Er.length; Cr++)
        Er[Cr] ^= kr[Cr];
    }
  }
  return pbkdf2Output(gr, vr, hr, mr, kr);
}
function setBigUint64$3(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
let SHA2$3 = class extends Hash$3 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$3(this.buffer);
  }
  update(ar) {
    exists$4(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$4(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView$3(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$4(this), output$4(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64$3(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView$3(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$4 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$3 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$3 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$3 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$3 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$3 = class extends SHA2$3 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$3[0] | 0, this.B = IV$3[1] | 0, this.C = IV$3[2] | 0, this.D = IV$3[3] | 0, this.E = IV$3[4] | 0, this.F = IV$3[5] | 0, this.G = IV$3[6] | 0, this.H = IV$3[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W$3[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W$3[yr - 15], Tr = SHA256_W$3[yr - 2], _r = rotr$3(kr, 7) ^ rotr$3(kr, 18) ^ kr >>> 3, Er = rotr$3(Tr, 17) ^ rotr$3(Tr, 19) ^ Tr >>> 10;
      SHA256_W$3[yr] = Er + SHA256_W$3[yr - 7] + _r + SHA256_W$3[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr$3(gr, 6) ^ rotr$3(gr, 11) ^ rotr$3(gr, 25), Tr = br + kr + Chi$4(gr, vr, mr) + SHA256_K$3[yr] + SHA256_W$3[yr] | 0, Er = (rotr$3(ur, 2) ^ rotr$3(ur, 13) ^ rotr$3(ur, 22)) + Maj$3(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W$3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$3(() => new SHA256$3()), U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(lr, ar = !1) {
  return ar ? { h: Number(lr & U32_MASK64), l: Number(lr >> _32n & U32_MASK64) } : { h: Number(lr >> _32n & U32_MASK64) | 0, l: Number(lr & U32_MASK64) | 0 };
}
function split$1(lr, ar = !1) {
  let cr = new Uint32Array(lr.length), ur = new Uint32Array(lr.length);
  for (let fr = 0; fr < lr.length; fr++) {
    const { h: dr, l: hr } = fromBig(lr[fr], ar);
    [cr[fr], ur[fr]] = [dr, hr];
  }
  return [cr, ur];
}
const toBig = (lr, ar) => BigInt(lr >>> 0) << _32n | BigInt(ar >>> 0), shrSH = (lr, ar, cr) => lr >>> cr, shrSL = (lr, ar, cr) => lr << 32 - cr | ar >>> cr, rotrSH = (lr, ar, cr) => lr >>> cr | ar << 32 - cr, rotrSL = (lr, ar, cr) => lr << 32 - cr | ar >>> cr, rotrBH = (lr, ar, cr) => lr << 64 - cr | ar >>> cr - 32, rotrBL = (lr, ar, cr) => lr >>> cr - 32 | ar << 64 - cr, rotr32H = (lr, ar) => ar, rotr32L = (lr, ar) => lr, rotlSH = (lr, ar, cr) => lr << cr | ar >>> 32 - cr, rotlSL = (lr, ar, cr) => ar << cr | lr >>> 32 - cr, rotlBH = (lr, ar, cr) => ar << cr - 32 | lr >>> 64 - cr, rotlBL = (lr, ar, cr) => lr << cr - 32 | ar >>> 64 - cr;
function add(lr, ar, cr, ur) {
  const fr = (ar >>> 0) + (ur >>> 0);
  return { h: lr + cr + (fr / 2 ** 32 | 0) | 0, l: fr | 0 };
}
const add3L = (lr, ar, cr) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0), add3H = (lr, ar, cr, ur) => ar + cr + ur + (lr / 2 ** 32 | 0) | 0, add4L = (lr, ar, cr, ur) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0) + (ur >>> 0), add4H = (lr, ar, cr, ur, fr) => ar + cr + ur + fr + (lr / 2 ** 32 | 0) | 0, add5L = (lr, ar, cr, ur, fr) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0) + (ur >>> 0) + (fr >>> 0), add5H = (lr, ar, cr, ur, fr, dr) => ar + cr + ur + fr + dr + (lr / 2 ** 32 | 0) | 0, u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, u64$1 = u64, [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((lr) => BigInt(lr))))(), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2$3 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: ar, Al: cr, Bh: ur, Bl: fr, Ch: dr, Cl: hr, Dh: gr, Dl: vr, Eh: mr, El: br, Fh: yr, Fl: kr, Gh: Tr, Gl: _r, Hh: Er, Hl: xr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr) {
    this.Ah = ar | 0, this.Al = cr | 0, this.Bh = ur | 0, this.Bl = fr | 0, this.Ch = dr | 0, this.Cl = hr | 0, this.Dh = gr | 0, this.Dl = vr | 0, this.Eh = mr | 0, this.El = br | 0, this.Fh = yr | 0, this.Fl = kr | 0, this.Gh = Tr | 0, this.Gl = _r | 0, this.Hh = Er | 0, this.Hl = xr | 0;
  }
  process(ar, cr) {
    for (let Lr = 0; Lr < 16; Lr++, cr += 4)
      SHA512_W_H[Lr] = ar.getUint32(cr), SHA512_W_L[Lr] = ar.getUint32(cr += 4);
    for (let Lr = 16; Lr < 80; Lr++) {
      const Dr = SHA512_W_H[Lr - 15] | 0, Nr = SHA512_W_L[Lr - 15] | 0, Hr = u64$1.rotrSH(Dr, Nr, 1) ^ u64$1.rotrSH(Dr, Nr, 8) ^ u64$1.shrSH(Dr, Nr, 7), $r = u64$1.rotrSL(Dr, Nr, 1) ^ u64$1.rotrSL(Dr, Nr, 8) ^ u64$1.shrSL(Dr, Nr, 7), Wr = SHA512_W_H[Lr - 2] | 0, Zr = SHA512_W_L[Lr - 2] | 0, oi = u64$1.rotrSH(Wr, Zr, 19) ^ u64$1.rotrBH(Wr, Zr, 61) ^ u64$1.shrSH(Wr, Zr, 6), Jr = u64$1.rotrSL(Wr, Zr, 19) ^ u64$1.rotrBL(Wr, Zr, 61) ^ u64$1.shrSL(Wr, Zr, 6), Yr = u64$1.add4L($r, Jr, SHA512_W_L[Lr - 7], SHA512_W_L[Lr - 16]), li = u64$1.add4H(Yr, Hr, oi, SHA512_W_H[Lr - 7], SHA512_W_H[Lr - 16]);
      SHA512_W_H[Lr] = li | 0, SHA512_W_L[Lr] = Yr | 0;
    }
    let { Ah: ur, Al: fr, Bh: dr, Bl: hr, Ch: gr, Cl: vr, Dh: mr, Dl: br, Eh: yr, El: kr, Fh: Tr, Fl: _r, Gh: Er, Gl: xr, Hh: Cr, Hl: Ar } = this;
    for (let Lr = 0; Lr < 80; Lr++) {
      const Dr = u64$1.rotrSH(yr, kr, 14) ^ u64$1.rotrSH(yr, kr, 18) ^ u64$1.rotrBH(yr, kr, 41), Nr = u64$1.rotrSL(yr, kr, 14) ^ u64$1.rotrSL(yr, kr, 18) ^ u64$1.rotrBL(yr, kr, 41), Hr = yr & Tr ^ ~yr & Er, $r = kr & _r ^ ~kr & xr, Wr = u64$1.add5L(Ar, Nr, $r, SHA512_Kl[Lr], SHA512_W_L[Lr]), Zr = u64$1.add5H(Wr, Cr, Dr, Hr, SHA512_Kh[Lr], SHA512_W_H[Lr]), oi = Wr | 0, Jr = u64$1.rotrSH(ur, fr, 28) ^ u64$1.rotrBH(ur, fr, 34) ^ u64$1.rotrBH(ur, fr, 39), Yr = u64$1.rotrSL(ur, fr, 28) ^ u64$1.rotrBL(ur, fr, 34) ^ u64$1.rotrBL(ur, fr, 39), li = ur & dr ^ ur & gr ^ dr & gr, Si = fr & hr ^ fr & vr ^ hr & vr;
      Cr = Er | 0, Ar = xr | 0, Er = Tr | 0, xr = _r | 0, Tr = yr | 0, _r = kr | 0, { h: yr, l: kr } = u64$1.add(mr | 0, br | 0, Zr | 0, oi | 0), mr = gr | 0, br = vr | 0, gr = dr | 0, vr = hr | 0, dr = ur | 0, hr = fr | 0;
      const ci = u64$1.add3L(oi, Yr, Si);
      ur = u64$1.add3H(ci, Zr, Jr, li), fr = ci | 0;
    }
    ({ h: ur, l: fr } = u64$1.add(this.Ah | 0, this.Al | 0, ur | 0, fr | 0)), { h: dr, l: hr } = u64$1.add(this.Bh | 0, this.Bl | 0, dr | 0, hr | 0), { h: gr, l: vr } = u64$1.add(this.Ch | 0, this.Cl | 0, gr | 0, vr | 0), { h: mr, l: br } = u64$1.add(this.Dh | 0, this.Dl | 0, mr | 0, br | 0), { h: yr, l: kr } = u64$1.add(this.Eh | 0, this.El | 0, yr | 0, kr | 0), { h: Tr, l: _r } = u64$1.add(this.Fh | 0, this.Fl | 0, Tr | 0, _r | 0), { h: Er, l: xr } = u64$1.add(this.Gh | 0, this.Gl | 0, Er | 0, xr | 0), { h: Cr, l: Ar } = u64$1.add(this.Hh | 0, this.Hl | 0, Cr | 0, Ar | 0), this.set(ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor$3(() => new SHA512());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function chain$2(...lr) {
  const ar = (fr, dr) => (hr) => fr(dr(hr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
// @__NO_SIDE_EFFECTS__
function alphabet$2(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join$3(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding$2(lr, ar = "=") {
  if (typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix$2(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((hr) => {
    if (hr < 0 || hr >= ar)
      throw new Error(`Wrong integer: ${hr}`);
  }); ; ) {
    let hr = 0, gr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const mr = dr[vr], br = ar * hr + mr;
      if (!Number.isSafeInteger(br) || ar * hr / ar !== hr || br - mr !== ar * hr)
        throw new Error("convertRadix: carry overflow");
      hr = br % cr;
      const yr = Math.floor(br / cr);
      if (dr[vr] = yr, !Number.isSafeInteger(yr) || yr * cr + hr !== br)
        throw new Error("convertRadix: carry overflow");
      if (gr)
        yr ? gr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(hr), gr)
      break;
  }
  for (let hr = 0; hr < lr.length - 1 && lr[hr] === 0; hr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$2 = /* @__NO_SIDE_EFFECTS__ */ (lr, ar) => ar ? /* @__PURE__ */ gcd$2(ar, lr % ar) : lr, radix2carry$2 = /* @__NO_SIDE_EFFECTS__ */ (lr, ar) => lr + (ar - /* @__PURE__ */ gcd$2(lr, ar));
// @__NO_SIDE_EFFECTS__
function convertRadix2$2(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (/* @__PURE__ */ radix2carry$2(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${/* @__PURE__ */ radix2carry$2(ar, cr)}`);
  let fr = 0, dr = 0;
  const hr = 2 ** cr - 1, gr = [];
  for (const vr of lr) {
    if (vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      gr.push((fr >> dr - cr & hr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & hr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && gr.push(fr >>> 0), gr;
}
// @__NO_SIDE_EFFECTS__
function radix$2(lr) {
  return {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix$2(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix$2(ar, lr, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function radix2$2(lr, ar = !1) {
  if (lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry$2(8, lr) > 32 || /* @__PURE__ */ radix2carry$2(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix2$2(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix2$2(cr, lr, 8, ar));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function checksum(lr, ar) {
  if (typeof ar != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(cr) {
      if (!(cr instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const ur = ar(cr).slice(0, lr), fr = new Uint8Array(cr.length + lr);
      return fr.set(cr), fr.set(ur, cr.length), fr;
    },
    decode(cr) {
      if (!(cr instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const ur = cr.slice(0, -lr), fr = ar(ur).slice(0, lr), dr = cr.slice(-lr);
      for (let hr = 0; hr < lr; hr++)
        if (fr[hr] !== dr[hr])
          throw new Error("Invalid checksum");
      return ur;
    }
  };
}
const utils$4 = { alphabet: alphabet$2, chain: chain$2, checksum, radix: radix$2, radix2: radix2$2, join: join$3, padding: padding$2 }, genBase58$2 = (lr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ radix$2(58), /* @__PURE__ */ alphabet$2(lr), /* @__PURE__ */ join$3("")), base58$2 = /* @__PURE__ */ genBase58$2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), base58check$1 = (lr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ checksum(4, (ar) => lr(lr(ar))), base58$2), isJapanese = (lr) => lr[0] === "あいこくしん";
function nfkd(lr) {
  if (typeof lr != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof lr}`);
  return lr.normalize("NFKD");
}
function normalize$2(lr) {
  const ar = nfkd(lr), cr = ar.split(" ");
  if (![12, 15, 18, 21, 24].includes(cr.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: ar, words: cr };
}
function assertEntropy(lr) {
  assert$4.bytes(lr, 16, 20, 24, 28, 32);
}
function generateMnemonic(lr, ar = 128) {
  if (assert$4.number(ar), ar % 32 !== 0 || ar > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes$3(ar / 8), lr);
}
const calcChecksum = (lr) => {
  const ar = 8 - lr.length / 4;
  return new Uint8Array([sha256$3(lr)[0] >> ar << ar]);
};
function getCoder(lr) {
  if (!Array.isArray(lr) || lr.length !== 2048 || typeof lr[0] != "string")
    throw new Error("Worlist: expected array of 2048 strings");
  return lr.forEach((ar) => {
    if (typeof ar != "string")
      throw new Error(`Wordlist: non-string element: ${ar}`);
  }), utils$4.chain(utils$4.checksum(1, calcChecksum), utils$4.radix2(11, !0), utils$4.alphabet(lr));
}
function mnemonicToEntropy(lr, ar) {
  const { words: cr } = normalize$2(lr), ur = getCoder(ar).decode(cr);
  return assertEntropy(ur), ur;
}
function entropyToMnemonic(lr, ar) {
  return assertEntropy(lr), getCoder(ar).encode(lr).join(isJapanese(ar) ? "　" : " ");
}
function validateMnemonic(lr, ar) {
  try {
    mnemonicToEntropy(lr, ar);
  } catch (cr) {
    return !1;
  }
  return !0;
}
const salt = (lr) => nfkd(`mnemonic${lr}`);
function mnemonicToSeedSync(lr, ar = "") {
  return pbkdf2(sha512, normalize$2(lr).nfkd, salt(ar), { c: 2048, dkLen: 64 });
}
const Rho$1 = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (lr, ar) => ar), Pi$1 = /* @__PURE__ */ Id.map((lr) => (9 * lr + 5) % 16);
let idxL = [Id], idxR = [Pi$1];
for (let lr = 0; lr < 4; lr++)
  for (let ar of [idxL, idxR])
    ar.push(ar[lr].map((cr) => Rho$1[cr]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((lr) => new Uint8Array(lr)), shiftsL = /* @__PURE__ */ idxL.map((lr, ar) => lr.map((cr) => shifts[ar][cr])), shiftsR = /* @__PURE__ */ idxR.map((lr, ar) => lr.map((cr) => shifts[ar][cr])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]), rotl$1 = (lr, ar) => lr << ar | lr >>> 32 - ar;
function f$1(lr, ar, cr, ur) {
  return lr === 0 ? ar ^ cr ^ ur : lr === 1 ? ar & cr | ~ar & ur : lr === 2 ? (ar | ~cr) ^ ur : lr === 3 ? ar & ur | cr & ~ur : ar ^ (cr | ~ur);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2$3 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: ar, h1: cr, h2: ur, h3: fr, h4: dr } = this;
    return [ar, cr, ur, fr, dr];
  }
  set(ar, cr, ur, fr, dr) {
    this.h0 = ar | 0, this.h1 = cr | 0, this.h2 = ur | 0, this.h3 = fr | 0, this.h4 = dr | 0;
  }
  process(ar, cr) {
    for (let Tr = 0; Tr < 16; Tr++, cr += 4)
      BUF[Tr] = ar.getUint32(cr, !0);
    let ur = this.h0 | 0, fr = ur, dr = this.h1 | 0, hr = dr, gr = this.h2 | 0, vr = gr, mr = this.h3 | 0, br = mr, yr = this.h4 | 0, kr = yr;
    for (let Tr = 0; Tr < 5; Tr++) {
      const _r = 4 - Tr, Er = Kl[Tr], xr = Kr[Tr], Cr = idxL[Tr], Ar = idxR[Tr], Lr = shiftsL[Tr], Dr = shiftsR[Tr];
      for (let Nr = 0; Nr < 16; Nr++) {
        const Hr = rotl$1(ur + f$1(Tr, dr, gr, mr) + BUF[Cr[Nr]] + Er, Lr[Nr]) + yr | 0;
        ur = yr, yr = mr, mr = rotl$1(gr, 10) | 0, gr = dr, dr = Hr;
      }
      for (let Nr = 0; Nr < 16; Nr++) {
        const Hr = rotl$1(fr + f$1(_r, hr, vr, br) + BUF[Ar[Nr]] + xr, Dr[Nr]) + kr | 0;
        fr = kr, kr = br, br = rotl$1(vr, 10) | 0, vr = hr, hr = Hr;
      }
    }
    this.set(this.h1 + gr + br | 0, this.h2 + mr + kr | 0, this.h3 + yr + fr | 0, this.h4 + ur + hr | 0, this.h0 + dr + vr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160 = /* @__PURE__ */ wrapConstructor$3(() => new RIPEMD160()), Point$1 = secp256k1$1.ProjectivePoint, base58check = base58check$1(sha256$3);
function bytesToNumber(lr) {
  return BigInt(`0x${bytesToHex$3(lr)}`);
}
function numberToBytes(lr) {
  return hexToBytes$4(lr.toString(16).padStart(64, "0"));
}
const MASTER_SECRET = utf8ToBytes$5("Bitcoin seed"), BITCOIN_VERSIONS = { private: 76066276, public: 76067358 }, HARDENED_OFFSET = 2147483648, hash160 = (lr) => ripemd160(sha256$3(lr)), fromU32 = (lr) => createView$3(lr).getUint32(0, !1), toU32 = (lr) => {
  if (!Number.isSafeInteger(lr) || lr < 0 || lr > 2 ** 32 - 1)
    throw new Error(`Invalid number=${lr}. Should be from 0 to 2 ** 32 - 1`);
  const ar = new Uint8Array(4);
  return createView$3(ar).setUint32(0, lr, !1), ar;
};
class HDKey {
  get fingerprint() {
    if (!this.pubHash)
      throw new Error("No publicKey set!");
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const ar = this.privateKey;
    if (!ar)
      throw new Error("No private key");
    return base58check.encode(this.serialize(this.versions.private, concatBytes$4(new Uint8Array([0]), ar)));
  }
  get publicExtendedKey() {
    if (!this.pubKey)
      throw new Error("No public key");
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(ar, cr = BITCOIN_VERSIONS) {
    if (bytes$4(ar), 8 * ar.length < 128 || 8 * ar.length > 512)
      throw new Error(`HDKey: wrong seed length=${ar.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const ur = hmac$4(sha512, MASTER_SECRET, ar);
    return new HDKey({
      versions: cr,
      chainCode: ur.slice(32),
      privateKey: ur.slice(0, 32)
    });
  }
  static fromExtendedKey(ar, cr = BITCOIN_VERSIONS) {
    const ur = base58check.decode(ar), fr = createView$3(ur), dr = fr.getUint32(0, !1), hr = {
      versions: cr,
      depth: ur[4],
      parentFingerprint: fr.getUint32(5, !1),
      index: fr.getUint32(9, !1),
      chainCode: ur.slice(13, 45)
    }, gr = ur.slice(45), vr = gr[0] === 0;
    if (dr !== cr[vr ? "private" : "public"])
      throw new Error("Version mismatch");
    return vr ? new HDKey({ ...hr, privateKey: gr.slice(1) }) : new HDKey({ ...hr, publicKey: gr });
  }
  static fromJSON(ar) {
    return HDKey.fromExtendedKey(ar.xpriv);
  }
  constructor(ar) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !ar || typeof ar != "object")
      throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = ar.versions || BITCOIN_VERSIONS, this.depth = ar.depth || 0, this.chainCode = ar.chainCode, this.index = ar.index || 0, this.parentFingerprint = ar.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))
      throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (ar.publicKey && ar.privateKey)
      throw new Error("HDKey: publicKey and privateKey at same time.");
    if (ar.privateKey) {
      if (!secp256k1$1.utils.isValidPrivateKey(ar.privateKey))
        throw new Error("Invalid private key");
      this.privKey = typeof ar.privateKey == "bigint" ? ar.privateKey : bytesToNumber(ar.privateKey), this.privKeyBytes = numberToBytes(this.privKey), this.pubKey = secp256k1$1.getPublicKey(ar.privateKey, !0);
    } else if (ar.publicKey)
      this.pubKey = Point$1.fromHex(ar.publicKey).toRawBytes(!0);
    else
      throw new Error("HDKey: no public or private key provided");
    this.pubHash = hash160(this.pubKey);
  }
  derive(ar) {
    if (!/^[mM]'?/.test(ar))
      throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(ar))
      return this;
    const cr = ar.replace(/^[mM]'?\//, "").split("/");
    let ur = this;
    for (const fr of cr) {
      const dr = /^(\d+)('?)$/.exec(fr);
      if (!dr || dr.length !== 3)
        throw new Error(`Invalid child index: ${fr}`);
      let hr = +dr[1];
      if (!Number.isSafeInteger(hr) || hr >= HARDENED_OFFSET)
        throw new Error("Invalid index");
      dr[2] === "'" && (hr += HARDENED_OFFSET), ur = ur.deriveChild(hr);
    }
    return ur;
  }
  deriveChild(ar) {
    if (!this.pubKey || !this.chainCode)
      throw new Error("No publicKey or chainCode set");
    let cr = toU32(ar);
    if (ar >= HARDENED_OFFSET) {
      const gr = this.privateKey;
      if (!gr)
        throw new Error("Could not derive hardened child key");
      cr = concatBytes$4(new Uint8Array([0]), gr, cr);
    } else
      cr = concatBytes$4(this.pubKey, cr);
    const ur = hmac$4(sha512, this.chainCode, cr), fr = bytesToNumber(ur.slice(0, 32)), dr = ur.slice(32);
    if (!secp256k1$1.utils.isValidPrivateKey(fr))
      throw new Error("Tweak bigger than curve order");
    const hr = {
      versions: this.versions,
      chainCode: dr,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: ar
    };
    try {
      if (this.privateKey) {
        const gr = mod$1(this.privKey + fr, secp256k1$1.CURVE.n);
        if (!secp256k1$1.utils.isValidPrivateKey(gr))
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        hr.privateKey = gr;
      } else {
        const gr = Point$1.fromHex(this.pubKey).add(Point$1.fromPrivateKey(fr));
        if (gr.equals(Point$1.ZERO))
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        hr.publicKey = gr.toRawBytes(!0);
      }
      return new HDKey(hr);
    } catch (gr) {
      return this.deriveChild(ar + 1);
    }
  }
  sign(ar) {
    if (!this.privateKey)
      throw new Error("No privateKey set!");
    return bytes$4(ar, 32), secp256k1$1.sign(ar, this.privKey).toCompactRawBytes();
  }
  verify(ar, cr) {
    if (bytes$4(ar, 32), bytes$4(cr, 64), !this.publicKey)
      throw new Error("No publicKey set!");
    let ur;
    try {
      ur = secp256k1$1.Signature.fromCompact(cr);
    } catch (fr) {
      return !1;
    }
    return secp256k1$1.verify(ur, ar, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(ar, cr) {
    if (!this.chainCode)
      throw new Error("No chainCode set");
    return bytes$4(cr, 33), concatBytes$4(toU32(ar), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, cr);
  }
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
const u8a$4 = (lr) => lr instanceof Uint8Array, u32 = (lr) => new Uint32Array(lr.buffer, lr.byteOffset, Math.floor(lr.byteLength / 4)), isLE$3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$3)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$4(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$3(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$4(lr)), !u8a$4(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
const isPlainObject = (lr) => Object.prototype.toString.call(lr) === "[object Object]" && lr.constructor === Object;
function checkOpts(lr, ar) {
  if (ar !== void 0 && (typeof ar != "object" || !isPlainObject(ar)))
    throw new Error("options must be object or undefined");
  return Object.assign(lr, ar);
}
function ensureBytes$1(lr, ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof ar == "number" && lr.length !== ar)
    throw new Error(`Uint8Array length ${ar} expected`);
}
function equalBytes$1(lr, ar) {
  if (lr.length !== ar.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let cr = !0;
  for (let ur = 0; ur < lr.length; ur++)
    cr && (cr = lr[ur] === ar[ur]);
  return cr;
}
function number$3(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$2(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$3(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$3(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("hash must be wrapped by utils.wrapConstructor");
  number$3(lr.outputLen), number$3(lr.blockLen);
}
function exists$3(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$3(lr, ar) {
  bytes$3(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$2 = { number: number$3, bool: bool$2, bytes: bytes$3, hash: hash$3, exists: exists$3, output: output$3 }, u8to16 = (lr, ar) => lr[ar++] & 255 | (lr[ar++] & 255) << 8;
class Poly1305 {
  constructor(ar) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, ar = toBytes$3(ar), ensureBytes$1(ar, 32);
    const cr = u8to16(ar, 0), ur = u8to16(ar, 2), fr = u8to16(ar, 4), dr = u8to16(ar, 6), hr = u8to16(ar, 8), gr = u8to16(ar, 10), vr = u8to16(ar, 12), mr = u8to16(ar, 14);
    this.r[0] = cr & 8191, this.r[1] = (cr >>> 13 | ur << 3) & 8191, this.r[2] = (ur >>> 10 | fr << 6) & 7939, this.r[3] = (fr >>> 7 | dr << 9) & 8191, this.r[4] = (dr >>> 4 | hr << 12) & 255, this.r[5] = hr >>> 1 & 8190, this.r[6] = (hr >>> 14 | gr << 2) & 8191, this.r[7] = (gr >>> 11 | vr << 5) & 8065, this.r[8] = (vr >>> 8 | mr << 8) & 8191, this.r[9] = mr >>> 5 & 127;
    for (let br = 0; br < 8; br++)
      this.pad[br] = u8to16(ar, 16 + 2 * br);
  }
  process(ar, cr, ur = !1) {
    const fr = ur ? 0 : 2048, { h: dr, r: hr } = this, gr = hr[0], vr = hr[1], mr = hr[2], br = hr[3], yr = hr[4], kr = hr[5], Tr = hr[6], _r = hr[7], Er = hr[8], xr = hr[9], Cr = u8to16(ar, cr + 0), Ar = u8to16(ar, cr + 2), Lr = u8to16(ar, cr + 4), Dr = u8to16(ar, cr + 6), Nr = u8to16(ar, cr + 8), Hr = u8to16(ar, cr + 10), $r = u8to16(ar, cr + 12), Wr = u8to16(ar, cr + 14);
    let Zr = dr[0] + (Cr & 8191), oi = dr[1] + ((Cr >>> 13 | Ar << 3) & 8191), Jr = dr[2] + ((Ar >>> 10 | Lr << 6) & 8191), Yr = dr[3] + ((Lr >>> 7 | Dr << 9) & 8191), li = dr[4] + ((Dr >>> 4 | Nr << 12) & 8191), Si = dr[5] + (Nr >>> 1 & 8191), ci = dr[6] + ((Nr >>> 14 | Hr << 2) & 8191), hi = dr[7] + ((Hr >>> 11 | $r << 5) & 8191), Ei = dr[8] + (($r >>> 8 | Wr << 8) & 8191), di = dr[9] + (Wr >>> 5 | fr), gi = 0, Li = gi + Zr * gr + oi * (5 * xr) + Jr * (5 * Er) + Yr * (5 * _r) + li * (5 * Tr);
    gi = Li >>> 13, Li &= 8191, Li += Si * (5 * kr) + ci * (5 * yr) + hi * (5 * br) + Ei * (5 * mr) + di * (5 * vr), gi += Li >>> 13, Li &= 8191;
    let ui = gi + Zr * vr + oi * gr + Jr * (5 * xr) + Yr * (5 * Er) + li * (5 * _r);
    gi = ui >>> 13, ui &= 8191, ui += Si * (5 * Tr) + ci * (5 * kr) + hi * (5 * yr) + Ei * (5 * br) + di * (5 * mr), gi += ui >>> 13, ui &= 8191;
    let wi = gi + Zr * mr + oi * vr + Jr * gr + Yr * (5 * xr) + li * (5 * Er);
    gi = wi >>> 13, wi &= 8191, wi += Si * (5 * _r) + ci * (5 * Tr) + hi * (5 * kr) + Ei * (5 * yr) + di * (5 * br), gi += wi >>> 13, wi &= 8191;
    let Ui = gi + Zr * br + oi * mr + Jr * vr + Yr * gr + li * (5 * xr);
    gi = Ui >>> 13, Ui &= 8191, Ui += Si * (5 * Er) + ci * (5 * _r) + hi * (5 * Tr) + Ei * (5 * kr) + di * (5 * yr), gi += Ui >>> 13, Ui &= 8191;
    let yi = gi + Zr * yr + oi * br + Jr * mr + Yr * vr + li * gr;
    gi = yi >>> 13, yi &= 8191, yi += Si * (5 * xr) + ci * (5 * Er) + hi * (5 * _r) + Ei * (5 * Tr) + di * (5 * kr), gi += yi >>> 13, yi &= 8191;
    let Vi = gi + Zr * kr + oi * yr + Jr * br + Yr * mr + li * vr;
    gi = Vi >>> 13, Vi &= 8191, Vi += Si * gr + ci * (5 * xr) + hi * (5 * Er) + Ei * (5 * _r) + di * (5 * Tr), gi += Vi >>> 13, Vi &= 8191;
    let Oi = gi + Zr * Tr + oi * kr + Jr * yr + Yr * br + li * mr;
    gi = Oi >>> 13, Oi &= 8191, Oi += Si * vr + ci * gr + hi * (5 * xr) + Ei * (5 * Er) + di * (5 * _r), gi += Oi >>> 13, Oi &= 8191;
    let Mi = gi + Zr * _r + oi * Tr + Jr * kr + Yr * yr + li * br;
    gi = Mi >>> 13, Mi &= 8191, Mi += Si * mr + ci * vr + hi * gr + Ei * (5 * xr) + di * (5 * Er), gi += Mi >>> 13, Mi &= 8191;
    let Ii = gi + Zr * Er + oi * _r + Jr * Tr + Yr * kr + li * yr;
    gi = Ii >>> 13, Ii &= 8191, Ii += Si * br + ci * mr + hi * vr + Ei * gr + di * (5 * xr), gi += Ii >>> 13, Ii &= 8191;
    let mi = gi + Zr * xr + oi * Er + Jr * _r + Yr * Tr + li * kr;
    gi = mi >>> 13, mi &= 8191, mi += Si * yr + ci * br + hi * mr + Ei * vr + di * gr, gi += mi >>> 13, mi &= 8191, gi = (gi << 2) + gi | 0, gi = gi + Li | 0, Li = gi & 8191, gi = gi >>> 13, ui += gi, dr[0] = Li, dr[1] = ui, dr[2] = wi, dr[3] = Ui, dr[4] = yi, dr[5] = Vi, dr[6] = Oi, dr[7] = Mi, dr[8] = Ii, dr[9] = mi;
  }
  finalize() {
    const { h: ar, pad: cr } = this, ur = new Uint16Array(10);
    let fr = ar[1] >>> 13;
    ar[1] &= 8191;
    for (let gr = 2; gr < 10; gr++)
      ar[gr] += fr, fr = ar[gr] >>> 13, ar[gr] &= 8191;
    ar[0] += fr * 5, fr = ar[0] >>> 13, ar[0] &= 8191, ar[1] += fr, fr = ar[1] >>> 13, ar[1] &= 8191, ar[2] += fr, ur[0] = ar[0] + 5, fr = ur[0] >>> 13, ur[0] &= 8191;
    for (let gr = 1; gr < 10; gr++)
      ur[gr] = ar[gr] + fr, fr = ur[gr] >>> 13, ur[gr] &= 8191;
    ur[9] -= 8192;
    let dr = (fr ^ 1) - 1;
    for (let gr = 0; gr < 10; gr++)
      ur[gr] &= dr;
    dr = ~dr;
    for (let gr = 0; gr < 10; gr++)
      ar[gr] = ar[gr] & dr | ur[gr];
    ar[0] = (ar[0] | ar[1] << 13) & 65535, ar[1] = (ar[1] >>> 3 | ar[2] << 10) & 65535, ar[2] = (ar[2] >>> 6 | ar[3] << 7) & 65535, ar[3] = (ar[3] >>> 9 | ar[4] << 4) & 65535, ar[4] = (ar[4] >>> 12 | ar[5] << 1 | ar[6] << 14) & 65535, ar[5] = (ar[6] >>> 2 | ar[7] << 11) & 65535, ar[6] = (ar[7] >>> 5 | ar[8] << 8) & 65535, ar[7] = (ar[8] >>> 8 | ar[9] << 5) & 65535;
    let hr = ar[0] + cr[0];
    ar[0] = hr & 65535;
    for (let gr = 1; gr < 8; gr++)
      hr = (ar[gr] + cr[gr] | 0) + (hr >>> 16) | 0, ar[gr] = hr & 65535;
  }
  update(ar) {
    assert$2.exists(this);
    const { buffer: cr, blockLen: ur } = this;
    ar = toBytes$3(ar);
    const fr = ar.length;
    for (let dr = 0; dr < fr; ) {
      const hr = Math.min(ur - this.pos, fr - dr);
      if (hr === ur) {
        for (; ur <= fr - dr; dr += ur)
          this.process(ar, dr);
        continue;
      }
      cr.set(ar.subarray(dr, dr + hr), this.pos), this.pos += hr, dr += hr, this.pos === ur && (this.process(cr, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    this.h.fill(0), this.r.fill(0), this.buffer.fill(0), this.pad.fill(0);
  }
  digestInto(ar) {
    assert$2.exists(this), assert$2.output(ar, this), this.finished = !0;
    const { buffer: cr, h: ur } = this;
    let { pos: fr } = this;
    if (fr) {
      for (cr[fr++] = 1; fr < 16; fr++)
        cr[fr] = 0;
      this.process(cr, 0, !0);
    }
    this.finalize();
    let dr = 0;
    for (let hr = 0; hr < 8; hr++)
      ar[dr++] = ur[hr] >>> 0, ar[dr++] = ur[hr] >>> 8;
    return ar;
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
}
function wrapConstructorWithKey(lr) {
  const ar = (ur, fr) => lr(fr).update(toBytes$3(ur)).digest(), cr = lr(new Uint8Array(32));
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = (ur) => lr(ur), ar;
}
wrapConstructorWithKey((lr) => new Poly1305(lr));
const sigma16 = utf8ToBytes$4("expand 16-byte k"), sigma32 = utf8ToBytes$4("expand 32-byte k"), sigma16_32 = u32(sigma16), sigma32_32 = u32(sigma32), isAligned32 = (lr) => !(lr.byteOffset % 4), salsaBasic = (lr) => {
  const { core: ar, rounds: cr, counterRight: ur, counterLen: fr, allow128bitKeys: dr, extendNonceFn: hr, blockLen: gr } = checkOpts({ rounds: 20, counterRight: !1, counterLen: 8, allow128bitKeys: !0, blockLen: 64 }, lr);
  assert$2.number(fr), assert$2.number(cr), assert$2.number(gr), assert$2.bool(ur), assert$2.bool(dr);
  const vr = gr / 4;
  if (gr % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen must be aligned to 4 bytes");
  return (mr, br, yr, kr, Tr = 0) => {
    if (assert$2.bytes(mr), assert$2.bytes(br), assert$2.bytes(yr), kr || (kr = new Uint8Array(yr.length)), assert$2.bytes(kr), assert$2.number(Tr), Tr < 0 || Tr >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (kr.length < yr.length)
      throw new Error(`Salsa/ChaCha: output (${kr.length}) is shorter than data (${yr.length})`);
    const _r = [];
    let Er, xr;
    if (mr.length === 32)
      Er = mr, xr = sigma32_32;
    else if (mr.length === 16 && dr)
      Er = new Uint8Array(32), Er.set(mr), Er.set(mr, 16), xr = sigma16_32, _r.push(Er);
    else
      throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${mr.length}`);
    if (hr) {
      if (br.length <= 16)
        throw new Error("Salsa/ChaCha: extended nonce must be bigger than 16 bytes");
      Er = hr(xr, Er, br.subarray(0, 16), new Uint8Array(32)), _r.push(Er), br = br.subarray(16);
    }
    const Cr = 16 - fr;
    if (br.length !== Cr)
      throw new Error(`Salsa/ChaCha: nonce must be ${Cr} or 16 bytes`);
    if (Cr !== 12) {
      const Zr = new Uint8Array(12);
      Zr.set(br, ur ? 0 : 12 - br.length), _r.push(br = Zr);
    }
    const Ar = new Uint8Array(gr), Lr = u32(Ar), Dr = u32(Er), Nr = u32(br), Hr = isAligned32(yr) && u32(yr), $r = isAligned32(kr) && u32(kr);
    _r.push(Lr);
    const Wr = yr.length;
    for (let Zr = 0, oi = Tr; Zr < Wr; oi++) {
      if (ar(xr, Dr, Nr, Lr, oi, cr), oi >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const Jr = Math.min(gr, Wr - Zr);
      if (Jr === gr && $r && Hr) {
        const Yr = Zr / 4;
        if (Zr % 4 !== 0)
          throw new Error("Salsa/ChaCha: invalid block position");
        for (let li = 0; li < vr; li++)
          $r[Yr + li] = Hr[Yr + li] ^ Lr[li];
        Zr += gr;
        continue;
      }
      for (let Yr = 0; Yr < Jr; Yr++)
        kr[Zr + Yr] = yr[Zr + Yr] ^ Ar[Yr];
      Zr += Jr;
    }
    for (let Zr = 0; Zr < _r.length; Zr++)
      _r[Zr].fill(0);
    return kr;
  };
}, rotl = (lr, ar) => lr << ar | lr >>> 32 - ar;
function chachaCore(lr, ar, cr, ur, fr, dr = 20) {
  let hr = lr[0], gr = lr[1], vr = lr[2], mr = lr[3], br = ar[0], yr = ar[1], kr = ar[2], Tr = ar[3], _r = ar[4], Er = ar[5], xr = ar[6], Cr = ar[7], Ar = fr, Lr = cr[0], Dr = cr[1], Nr = cr[2], Hr = hr, $r = gr, Wr = vr, Zr = mr, oi = br, Jr = yr, Yr = kr, li = Tr, Si = _r, ci = Er, hi = xr, Ei = Cr, di = Ar, gi = Lr, Li = Dr, ui = Nr;
  for (let Ui = 0; Ui < dr; Ui += 2)
    Hr = Hr + oi | 0, di = rotl(di ^ Hr, 16), Si = Si + di | 0, oi = rotl(oi ^ Si, 12), Hr = Hr + oi | 0, di = rotl(di ^ Hr, 8), Si = Si + di | 0, oi = rotl(oi ^ Si, 7), $r = $r + Jr | 0, gi = rotl(gi ^ $r, 16), ci = ci + gi | 0, Jr = rotl(Jr ^ ci, 12), $r = $r + Jr | 0, gi = rotl(gi ^ $r, 8), ci = ci + gi | 0, Jr = rotl(Jr ^ ci, 7), Wr = Wr + Yr | 0, Li = rotl(Li ^ Wr, 16), hi = hi + Li | 0, Yr = rotl(Yr ^ hi, 12), Wr = Wr + Yr | 0, Li = rotl(Li ^ Wr, 8), hi = hi + Li | 0, Yr = rotl(Yr ^ hi, 7), Zr = Zr + li | 0, ui = rotl(ui ^ Zr, 16), Ei = Ei + ui | 0, li = rotl(li ^ Ei, 12), Zr = Zr + li | 0, ui = rotl(ui ^ Zr, 8), Ei = Ei + ui | 0, li = rotl(li ^ Ei, 7), Hr = Hr + Jr | 0, ui = rotl(ui ^ Hr, 16), hi = hi + ui | 0, Jr = rotl(Jr ^ hi, 12), Hr = Hr + Jr | 0, ui = rotl(ui ^ Hr, 8), hi = hi + ui | 0, Jr = rotl(Jr ^ hi, 7), $r = $r + Yr | 0, di = rotl(di ^ $r, 16), Ei = Ei + di | 0, Yr = rotl(Yr ^ Ei, 12), $r = $r + Yr | 0, di = rotl(di ^ $r, 8), Ei = Ei + di | 0, Yr = rotl(Yr ^ Ei, 7), Wr = Wr + li | 0, gi = rotl(gi ^ Wr, 16), Si = Si + gi | 0, li = rotl(li ^ Si, 12), Wr = Wr + li | 0, gi = rotl(gi ^ Wr, 8), Si = Si + gi | 0, li = rotl(li ^ Si, 7), Zr = Zr + oi | 0, Li = rotl(Li ^ Zr, 16), ci = ci + Li | 0, oi = rotl(oi ^ ci, 12), Zr = Zr + oi | 0, Li = rotl(Li ^ Zr, 8), ci = ci + Li | 0, oi = rotl(oi ^ ci, 7);
  let wi = 0;
  ur[wi++] = hr + Hr | 0, ur[wi++] = gr + $r | 0, ur[wi++] = vr + Wr | 0, ur[wi++] = mr + Zr | 0, ur[wi++] = br + oi | 0, ur[wi++] = yr + Jr | 0, ur[wi++] = kr + Yr | 0, ur[wi++] = Tr + li | 0, ur[wi++] = _r + Si | 0, ur[wi++] = Er + ci | 0, ur[wi++] = xr + hi | 0, ur[wi++] = Cr + Ei | 0, ur[wi++] = Ar + di | 0, ur[wi++] = Lr + gi | 0, ur[wi++] = Dr + Li | 0, ur[wi++] = Nr + ui | 0;
}
const chacha20 = /* @__PURE__ */ salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  allow128bitKeys: !1
});
let HMAC$3 = class extends Hash$4 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$5.hash(ar);
    const ur = toBytes$5(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$5.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$3 = (lr, ar, cr) => new HMAC$3(lr, ar).update(cr).digest();
hmac$3.create = (lr, ar) => new HMAC$3(lr, ar);
function extract$2(lr, ar, cr) {
  return assert$5.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac$3(lr, toBytes$5(cr), toBytes$5(ar));
}
const HKDF_COUNTER$2 = new Uint8Array([0]), EMPTY_BUFFER$2 = new Uint8Array();
function expand$2(lr, ar, cr, ur = 32) {
  if (assert$5.hash(lr), assert$5.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER$2);
  const dr = new Uint8Array(fr * lr.outputLen), hr = hmac$3.create(lr, ar), gr = hr._cloneInto(), vr = new Uint8Array(hr.outputLen);
  for (let mr = 0; mr < fr; mr++)
    HKDF_COUNTER$2[0] = mr + 1, gr.update(mr === 0 ? EMPTY_BUFFER$2 : vr).update(cr).update(HKDF_COUNTER$2).digestInto(vr), dr.set(vr, lr.outputLen * mr), hr._cloneInto(gr);
  return hr.destroy(), gr.destroy(), vr.fill(0), HKDF_COUNTER$2.fill(0), dr.slice(0, ur);
}
const hkdf$1 = (lr, ar, cr, ur, fr) => expand$2(lr, extract$2(lr, ar, cr), ur, fr);
var __defProp$2 = Object.defineProperty, __export$2 = (lr, ar) => {
  for (var cr in ar)
    __defProp$2(lr, cr, { get: ar[cr], enumerable: !0 });
};
function generatePrivateKey() {
  return bytesToHex$4(schnorr$1.utils.randomPrivateKey());
}
function getPublicKey$1(lr) {
  return bytesToHex$4(schnorr$1.getPublicKey(lr));
}
var utils_exports$2 = {};
__export$2(utils_exports$2, {
  MessageNode: () => MessageNode$1,
  MessageQueue: () => MessageQueue$1,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$2,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$2,
  normalizeURL: () => normalizeURL$2,
  utf8Decoder: () => utf8Decoder$2,
  utf8Encoder: () => utf8Encoder$2
});
var utf8Decoder$2 = new TextDecoder("utf-8"), utf8Encoder$2 = new TextEncoder();
function normalizeURL$2(lr) {
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$2(lr, ar) {
  var hr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at < lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at >= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at > ar.created_at)
        cr = fr;
      else if (lr[fr].created_at < ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((hr = lr[dr]) == null ? void 0 : hr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
function insertEventIntoAscendingList$2(lr, ar) {
  var hr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at > lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at <= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at < ar.created_at)
        cr = fr;
      else if (lr[fr].created_at > ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((hr = lr[dr]) == null ? void 0 : hr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
var MessageNode$1 = class {
  constructor(ar) {
    Wi(this, "_value");
    Wi(this, "_next");
    this._value = ar, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(ar) {
    this._value = ar;
  }
  get next() {
    return this._next;
  }
  set next(ar) {
    this._next = ar;
  }
}, MessageQueue$1 = class {
  constructor() {
    Wi(this, "_first");
    Wi(this, "_last");
    Wi(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(ar) {
    this._first = ar;
  }
  get last() {
    return this._last;
  }
  set last(ar) {
    this._last = ar;
  }
  get size() {
    return this._size;
  }
  set size(ar) {
    this._size = ar;
  }
  enqueue(ar) {
    const cr = new MessageNode$1(ar);
    return this._size === 0 || !this._last ? (this._first = cr, this._last = cr) : (this._last.next = cr, this._last = cr), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let ar = this._first;
    return this._first = ar.next, ar.next = null, this._size--, ar.value;
  }
}, verifiedSymbol$2 = Symbol("verified");
function getBlankEvent$1(lr = 255) {
  return {
    kind: lr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent$1(lr, ar) {
  const cr = lr;
  return cr.pubkey = getPublicKey$1(ar), cr.id = getEventHash$2(cr), cr.sig = getSignature$1(cr, ar), cr[verifiedSymbol$2] = !0, cr;
}
function serializeEvent$2(lr) {
  if (!validateEvent$2(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash$2(lr) {
  let ar = sha256$4(utf8Encoder$2.encode(serializeEvent$2(lr)));
  return bytesToHex$4(ar);
}
var isRecord$2 = (lr) => lr instanceof Object;
function validateEvent$2(lr) {
  if (!isRecord$2(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature$1(lr) {
  if (typeof lr[verifiedSymbol$2] == "boolean")
    return lr[verifiedSymbol$2];
  const ar = getEventHash$2(lr);
  if (ar !== lr.id)
    return lr[verifiedSymbol$2] = !1;
  try {
    return lr[verifiedSymbol$2] = schnorr$1.verify(lr.sig, ar, lr.pubkey);
  } catch (cr) {
    return lr[verifiedSymbol$2] = !1;
  }
}
function getSignature$1(lr, ar) {
  return bytesToHex$4(schnorr$1.sign(getEventHash$2(lr), ar));
}
function matchFilter$1(lr, ar) {
  if (lr.ids && lr.ids.indexOf(ar.id) === -1 && !lr.ids.some((cr) => ar.id.startsWith(cr)) || lr.kinds && lr.kinds.indexOf(ar.kind) === -1 || lr.authors && lr.authors.indexOf(ar.pubkey) === -1 && !lr.authors.some((cr) => ar.pubkey.startsWith(cr)))
    return !1;
  for (let cr in lr)
    if (cr[0] === "#") {
      let ur = cr.slice(1), fr = lr[`#${ur}`];
      if (fr && !ar.tags.find(([dr, hr]) => dr === cr.slice(1) && fr.indexOf(hr) !== -1))
        return !1;
    }
  return !(lr.since && ar.created_at < lr.since || lr.until && ar.created_at > lr.until);
}
function matchFilters(lr, ar) {
  for (let cr = 0; cr < lr.length; cr++)
    if (matchFilter$1(lr[cr], ar))
      return !0;
  return !1;
}
var fakejson_exports$2 = {};
__export$2(fakejson_exports$2, {
  getHex64: () => getHex64$2,
  getInt: () => getInt$2,
  getSubscriptionId: () => getSubscriptionId$2,
  matchEventId: () => matchEventId$2,
  matchEventKind: () => matchEventKind$2,
  matchEventPubkey: () => matchEventPubkey$2
});
function getHex64$2(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt$2(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId$2(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId$2(lr, ar) {
  return ar === getHex64$2(lr, "id");
}
function matchEventPubkey$2(lr, ar) {
  return ar === getHex64$2(lr, "pubkey");
}
function matchEventKind$2(lr, ar) {
  return ar === getInt$2(lr, "kind");
}
var newListeners = () => ({
  connect: [],
  disconnect: [],
  error: [],
  notice: [],
  auth: []
});
function relayInit(lr, ar = {}) {
  let { listTimeout: cr = 3e3, getTimeout: ur = 3e3, countTimeout: fr = 3e3 } = ar;
  var dr, hr = {}, gr = newListeners(), vr = {}, mr = {}, br;
  async function yr() {
    return br || (br = new Promise((Cr, Ar) => {
      try {
        dr = new WebSocket(lr);
      } catch (Hr) {
        Ar(Hr);
      }
      dr.onopen = () => {
        gr.connect.forEach((Hr) => Hr()), Cr();
      }, dr.onerror = () => {
        br = void 0, gr.error.forEach((Hr) => Hr()), Ar();
      }, dr.onclose = async () => {
        br = void 0, gr.disconnect.forEach((Hr) => Hr());
      };
      let Lr = new MessageQueue$1(), Dr;
      dr.onmessage = (Hr) => {
        Lr.enqueue(Hr.data), Dr || (Dr = setInterval(Nr, 0));
      };
      function Nr() {
        var Wr, Zr, oi;
        if (Lr.size === 0) {
          clearInterval(Dr), Dr = null;
          return;
        }
        var Hr = Lr.dequeue();
        if (!Hr)
          return;
        let $r = getSubscriptionId$2(Hr);
        if ($r) {
          let Jr = hr[$r];
          if (Jr && Jr.alreadyHaveEvent && Jr.alreadyHaveEvent(getHex64$2(Hr, "id"), lr))
            return;
        }
        try {
          let Jr = JSON.parse(Hr);
          switch (Jr[0]) {
            case "EVENT": {
              let ci = Jr[1], hi = Jr[2];
              validateEvent$2(hi) && hr[ci] && (hr[ci].skipVerification || verifySignature$1(hi)) && matchFilters(hr[ci].filters, hi) && (hr[ci], (((Wr = vr[ci]) == null ? void 0 : Wr.event) || []).forEach((Ei) => Ei(hi)));
              return;
            }
            case "COUNT":
              let Yr = Jr[1], li = Jr[2];
              hr[Yr] && (((Zr = vr[Yr]) == null ? void 0 : Zr.count) || []).forEach((ci) => ci(li));
              return;
            case "EOSE": {
              let ci = Jr[1];
              ci in vr && (vr[ci].eose.forEach((hi) => hi()), vr[ci].eose = []);
              return;
            }
            case "OK": {
              let ci = Jr[1], hi = Jr[2], Ei = Jr[3] || "";
              if (ci in mr) {
                let { resolve: di, reject: gi } = mr[ci];
                hi ? di(null) : gi(new Error(Ei));
              }
              return;
            }
            case "NOTICE":
              let Si = Jr[1];
              gr.notice.forEach((ci) => ci(Si));
              return;
            case "AUTH": {
              let ci = Jr[1];
              (oi = gr.auth) == null || oi.forEach((hi) => hi(ci));
              return;
            }
          }
        } catch (Jr) {
          return;
        }
      }
    }), br);
  }
  function kr() {
    return (dr == null ? void 0 : dr.readyState) === 1;
  }
  async function Tr() {
    kr() || await yr();
  }
  async function _r(Cr) {
    let Ar = JSON.stringify(Cr);
    if (!(!kr() && (await new Promise((Lr) => setTimeout(Lr, 1e3)), !kr())))
      try {
        dr.send(Ar);
      } catch (Lr) {
        console.log(Lr);
      }
  }
  const Er = (Cr, {
    verb: Ar = "REQ",
    skipVerification: Lr = !1,
    alreadyHaveEvent: Dr = null,
    id: Nr = Math.random().toString().slice(2)
  } = {}) => {
    let Hr = Nr;
    hr[Hr] = {
      id: Hr,
      filters: Cr,
      skipVerification: Lr,
      alreadyHaveEvent: Dr
    }, _r([Ar, Hr, ...Cr]);
    let $r = {
      sub: (Wr, Zr = {}) => Er(Wr || Cr, {
        skipVerification: Zr.skipVerification || Lr,
        alreadyHaveEvent: Zr.alreadyHaveEvent || Dr,
        id: Hr
      }),
      unsub: () => {
        delete hr[Hr], delete vr[Hr], _r(["CLOSE", Hr]);
      },
      on: (Wr, Zr) => {
        vr[Hr] = vr[Hr] || {
          event: [],
          count: [],
          eose: []
        }, vr[Hr][Wr].push(Zr);
      },
      off: (Wr, Zr) => {
        let oi = vr[Hr], Jr = oi[Wr].indexOf(Zr);
        Jr >= 0 && oi[Wr].splice(Jr, 1);
      },
      get events() {
        return eventsGenerator($r);
      }
    };
    return $r;
  };
  function xr(Cr, Ar) {
    return new Promise((Lr, Dr) => {
      if (!Cr.id) {
        Dr(new Error(`event ${Cr} has no id`));
        return;
      }
      let Nr = Cr.id;
      _r([Ar, Cr]), mr[Nr] = { resolve: Lr, reject: Dr };
    });
  }
  return {
    url: lr,
    sub: Er,
    on: (Cr, Ar) => {
      gr[Cr].push(Ar), Cr === "connect" && (dr == null ? void 0 : dr.readyState) === 1 && Ar();
    },
    off: (Cr, Ar) => {
      let Lr = gr[Cr].indexOf(Ar);
      Lr !== -1 && gr[Cr].splice(Lr, 1);
    },
    list: (Cr, Ar) => new Promise((Lr) => {
      let Dr = Er(Cr, Ar), Nr = [], Hr = setTimeout(() => {
        Dr.unsub(), Lr(Nr);
      }, cr);
      Dr.on("eose", () => {
        Dr.unsub(), clearTimeout(Hr), Lr(Nr);
      }), Dr.on("event", ($r) => {
        Nr.push($r);
      });
    }),
    get: (Cr, Ar) => new Promise((Lr) => {
      let Dr = Er([Cr], Ar), Nr = setTimeout(() => {
        Dr.unsub(), Lr(null);
      }, ur);
      Dr.on("event", (Hr) => {
        Dr.unsub(), clearTimeout(Nr), Lr(Hr);
      });
    }),
    count: (Cr) => new Promise((Ar) => {
      let Lr = Er(Cr, { ...Er, verb: "COUNT" }), Dr = setTimeout(() => {
        Lr.unsub(), Ar(null);
      }, fr);
      Lr.on("count", (Nr) => {
        Lr.unsub(), clearTimeout(Dr), Ar(Nr);
      });
    }),
    async publish(Cr) {
      await xr(Cr, "EVENT");
    },
    async auth(Cr) {
      await xr(Cr, "AUTH");
    },
    connect: Tr,
    close() {
      gr = newListeners(), vr = {}, mr = {}, (dr == null ? void 0 : dr.readyState) === WebSocket.OPEN && dr.close();
    },
    get status() {
      var Cr;
      return (Cr = dr == null ? void 0 : dr.readyState) != null ? Cr : 3;
    }
  };
}
async function* eventsGenerator(lr) {
  let ar;
  const cr = [], ur = (fr) => {
    ar ? (ar(fr), ar = void 0) : cr.push(fr);
  };
  lr.on("event", ur);
  try {
    for (; ; )
      cr.length > 0 ? yield cr.shift() : yield await new Promise((dr) => {
        ar = dr;
      });
  } finally {
    lr.off("event", ur);
  }
}
var nip19_exports$2 = {};
__export$2(nip19_exports$2, {
  BECH32_REGEX: () => BECH32_REGEX$2,
  decode: () => decode$3,
  naddrEncode: () => naddrEncode$2,
  neventEncode: () => neventEncode$2,
  noteEncode: () => noteEncode$2,
  nprofileEncode: () => nprofileEncode$2,
  npubEncode: () => npubEncode$2,
  nrelayEncode: () => nrelayEncode$2,
  nsecEncode: () => nsecEncode$2
});
var Bech32MaxSize$2 = 5e3, BECH32_REGEX$2 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$2(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$3(lr) {
  var fr, dr, hr, gr, vr, mr, br, yr;
  let { prefix: ar, words: cr } = bech32$3.decode(lr, Bech32MaxSize$2), ur = new Uint8Array(bech32$3.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let kr = parseTLV$2(ur);
      if (!((fr = kr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$4(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$2.decode(Tr)) : []
        }
      };
    }
    case "nevent": {
      let kr = parseTLV$2(ur);
      if (!((dr = kr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (kr[2] && kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (kr[3] && kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$4(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$2.decode(Tr)) : [],
          author: (hr = kr[2]) != null && hr[0] ? bytesToHex$4(kr[2][0]) : void 0,
          kind: (gr = kr[3]) != null && gr[0] ? parseInt(bytesToHex$4(kr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let kr = parseTLV$2(ur);
      if (!((vr = kr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((mr = kr[2]) != null && mr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((br = kr[3]) != null && br[0]))
        throw new Error("missing TLV 3 for naddr");
      if (kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$2.decode(kr[0][0]),
          pubkey: bytesToHex$4(kr[2][0]),
          kind: parseInt(bytesToHex$4(kr[3][0]), 16),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$2.decode(Tr)) : []
        }
      };
    }
    case "nrelay": {
      let kr = parseTLV$2(ur);
      if (!((yr = kr[0]) != null && yr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$2.decode(kr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$4(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$2(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1];
    if (!fr)
      throw new Error(`malformed TLV ${ur}`);
    let dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode$2(lr) {
  return encodeBytes$2("nsec", lr);
}
function npubEncode$2(lr) {
  return encodeBytes$2("npub", lr);
}
function noteEncode$2(lr) {
  return encodeBytes$2("note", lr);
}
function encodeBech32$2(lr, ar) {
  let cr = bech32$3.toWords(ar);
  return bech32$3.encode(lr, cr, Bech32MaxSize$2);
}
function encodeBytes$2(lr, ar) {
  let cr = hexToBytes$5(ar);
  return encodeBech32$2(lr, cr);
}
function nprofileEncode$2(lr) {
  let ar = encodeTLV$2({
    0: [hexToBytes$5(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder$2.encode(cr))
  });
  return encodeBech32$2("nprofile", ar);
}
function neventEncode$2(lr) {
  let ar;
  lr.kind != null && (ar = integerToUint8Array$2(lr.kind));
  let cr = encodeTLV$2({
    0: [hexToBytes$5(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: lr.author ? [hexToBytes$5(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$2("nevent", cr);
}
function naddrEncode$2(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV$2({
    0: [utf8Encoder$2.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: [hexToBytes$5(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$2("naddr", cr);
}
function nrelayEncode$2(lr) {
  let ar = encodeTLV$2({
    0: [utf8Encoder$2.encode(lr)]
  });
  return encodeBech32$2("nrelay", ar);
}
function encodeTLV$2(lr) {
  let ar = [];
  return Object.entries(lr).forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes$5(...ar);
}
var nip04_exports$2 = {};
__export$2(nip04_exports$2, {
  decrypt: () => decrypt$3,
  encrypt: () => encrypt$3
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$3(lr, ar, cr) {
  const ur = secp256k1$1.getSharedSecret(lr, "02" + ar), fr = getNormalizedX$2(ur);
  let dr = Uint8Array.from(randomBytes$4(16)), hr = utf8Encoder$2.encode(cr), gr = await crypto.subtle.importKey("raw", fr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: dr }, gr, hr), mr = base64$2.encode(new Uint8Array(vr)), br = base64$2.encode(new Uint8Array(dr.buffer));
  return `${mr}?iv=${br}`;
}
async function decrypt$3(lr, ar, cr) {
  let [ur, fr] = cr.split("?iv="), dr = secp256k1$1.getSharedSecret(lr, "02" + ar), hr = getNormalizedX$2(dr), gr = await crypto.subtle.importKey("raw", hr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$2.decode(ur), mr = base64$2.decode(fr), br = await crypto.subtle.decrypt({ name: "AES-CBC", iv: mr }, gr, vr);
  return utf8Decoder$2.decode(br);
}
function getNormalizedX$2(lr) {
  return lr.slice(1, 33);
}
var nip05_exports$2 = {};
__export$2(nip05_exports$2, {
  NIP05_REGEX: () => NIP05_REGEX$2,
  queryProfile: () => queryProfile$2,
  searchDomain: () => searchDomain$2,
  useFetchImplementation: () => useFetchImplementation$2
});
var NIP05_REGEX$2 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$2;
try {
  _fetch$2 = fetch;
} catch (lr) {
}
function useFetchImplementation$2(lr) {
  _fetch$2 = lr;
}
async function searchDomain$2(lr, ar = "") {
  try {
    return (await (await _fetch$2(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile$2(lr) {
  const ar = lr.match(NIP05_REGEX$2);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch$2(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: hr, relays: gr } = parseNIP05Result$2(await dr.json()), vr = hr[ur];
    return vr ? { pubkey: vr, relays: gr == null ? void 0 : gr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result$2(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip06_exports$1 = {};
__export$2(nip06_exports$1, {
  generateSeedWords: () => generateSeedWords$1,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords$1,
  validateWords: () => validateWords$1
});
function privateKeyFromSeedWords$1(lr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(lr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$4(ur);
}
function generateSeedWords$1() {
  return generateMnemonic(wordlist);
}
function validateWords$1(lr) {
  return validateMnemonic(lr, wordlist);
}
var nip10_exports$2 = {};
__export$2(nip10_exports$2, {
  parse: () => parse$2
});
function parse$2(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, hr, gr, vr] = fr, mr = {
      id: hr,
      relays: gr ? [gr] : []
    }, br = ur === 0, yr = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = mr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = mr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(mr);
      continue;
    }
    if (br) {
      ar.root = mr;
      continue;
    }
    if (yr) {
      ar.reply = mr;
      continue;
    }
    ar.mentions.push(mr);
  }
  return ar;
}
var nip13_exports$2 = {};
__export$2(nip13_exports$2, {
  getPow: () => getPow$2,
  minePow: () => minePow$2
});
function getPow$2(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$2(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash$2(ur), getPow$2(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$2 = {};
__export$2(nip18_exports$2, {
  finishRepostEvent: () => finishRepostEvent$2,
  getRepostedEvent: () => getRepostedEvent$2,
  getRepostedEventPointer: () => getRepostedEventPointer$2
});
function finishRepostEvent$2(lr, ar, cr, ur) {
  var fr;
  return finishEvent$1(
    {
      kind: 6,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$2(lr) {
  if (lr.kind !== 6)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent$2(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer$2(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifySignature$1(ur)))
    return ur;
}
var nip21_exports$2 = {};
__export$2(nip21_exports$2, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$2,
  parse: () => parse2$2,
  test: () => test$2
});
var NOSTR_URI_REGEX$2 = new RegExp(`nostr:(${BECH32_REGEX$2.source})`);
function test$2(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX$2.source}$`).test(lr);
}
function parse2$2(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX$2.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$3(ar[1])
  };
}
var nip25_exports$2 = {};
__export$2(nip25_exports$2, {
  finishReactionEvent: () => finishReactionEvent$2,
  getReactedEventPointer: () => getReactedEventPointer$2
});
function finishReactionEvent$2(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((hr) => hr.length >= 2 && (hr[0] === "e" || hr[0] === "p"));
  return finishEvent$1(
    {
      ...lr,
      kind: 7,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer$2(lr) {
  if (lr.kind !== 7)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip26_exports$1 = {};
__export$2(nip26_exports$1, {
  createDelegation: () => createDelegation$1,
  getDelegator: () => getDelegator$1
});
function createDelegation$1(lr, ar) {
  let cr = [];
  (ar.kind || -1) >= 0 && cr.push(`kind=${ar.kind}`), ar.until && cr.push(`created_at<${ar.until}`), ar.since && cr.push(`created_at>${ar.since}`);
  let ur = cr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let fr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), dr = bytesToHex$4(schnorr$1.sign(fr, lr));
  return {
    from: getPublicKey$1(lr),
    to: ar.pubkey,
    cond: ur,
    sig: dr
  };
}
function getDelegator$1(lr) {
  let ar = lr.tags.find((gr) => gr[0] === "delegation" && gr.length >= 4);
  if (!ar)
    return null;
  let cr = ar[1], ur = ar[2], fr = ar[3], dr = ur.split("&");
  for (let gr = 0; gr < dr.length; gr++) {
    let [vr, mr, br] = dr[gr].split(/\b/);
    if (!(vr === "kind" && mr === "=" && lr.kind === parseInt(br))) {
      if (vr === "created_at" && mr === "<" && lr.created_at < parseInt(br))
        continue;
      if (vr === "created_at" && mr === ">" && lr.created_at > parseInt(br))
        continue;
      return null;
    }
  }
  let hr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${lr.pubkey}:${ur}`));
  return schnorr$1.verify(fr, hr, cr) ? cr : null;
}
var nip27_exports$2 = {};
__export$2(nip27_exports$2, {
  matchAll: () => matchAll$2,
  regex: () => regex$2,
  replaceAll: () => replaceAll$2
});
var regex$2 = () => new RegExp(`\\b${NOSTR_URI_REGEX$2.source}\\b`, "g");
function* matchAll$2(lr) {
  const ar = lr.matchAll(regex$2());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$3(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$2(lr, ar) {
  return lr.replaceAll(regex$2(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$3(ur)
  }));
}
var nip28_exports$2 = {};
__export$2(nip28_exports$2, {
  channelCreateEvent: () => channelCreateEvent$2,
  channelHideMessageEvent: () => channelHideMessageEvent$2,
  channelMessageEvent: () => channelMessageEvent$2,
  channelMetadataEvent: () => channelMetadataEvent$2,
  channelMuteUserEvent: () => channelMuteUserEvent$2
});
var channelCreateEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 40,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 41,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent$2 = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finishEvent$1(
    {
      kind: 42,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 43,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 44,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip39_exports$2 = {};
__export$2(nip39_exports$2, {
  useFetchImplementation: () => useFetchImplementation2$2,
  validateGithub: () => validateGithub$2
});
var _fetch2$2;
try {
  _fetch2$2 = fetch;
} catch (lr) {
}
function useFetchImplementation2$2(lr) {
  _fetch2$2 = lr;
}
async function validateGithub$2(lr, ar, cr) {
  try {
    return await (await _fetch2$2(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$2 = {};
__export$2(nip42_exports$2, {
  authenticate: () => authenticate$1
});
var authenticate$1 = async ({
  challenge: lr,
  relay: ar,
  sign: cr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", lr]
    ],
    content: ""
  };
  return ar.auth(await cr(ur));
}, nip44_exports$2 = {};
__export$2(nip44_exports$2, {
  decrypt: () => decrypt2$2,
  encrypt: () => encrypt2$2,
  utils: () => utils$3
});
var utils$3 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(lr, ar) {
      return secp256k1$1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(lr, ar) {
      const cr = hkdf$1(sha256$4, lr, ar, "nip44-v2", 76);
      return {
        encryption: cr.subarray(0, 32),
        nonce: cr.subarray(32, 44),
        auth: cr.subarray(44, 76)
      };
    },
    calcPadding(lr) {
      if (!Number.isSafeInteger(lr) || lr < 0)
        throw new Error("expected positive integer");
      if (lr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
      return cr * (Math.floor((lr - 1) / cr) + 1);
    },
    pad(lr) {
      const ar = utf8Encoder$2.encode(lr), cr = ar.length;
      if (cr < 1 || cr >= utils$3.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$3.v2.calcPadding(cr), fr = new Uint8Array(ur - cr), dr = new Uint8Array(2);
      return new DataView(dr.buffer).setUint16(0, cr), concatBytes$5(dr, ar, fr);
    },
    unpad(lr) {
      const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
      if (ar === 0 || cr.length !== ar || lr.length !== 2 + utils$3.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$2.decode(cr);
    }
  }
};
function encrypt2$2(lr, ar, cr = {}) {
  var mr, br;
  const ur = (mr = cr.version) != null ? mr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const fr = (br = cr.salt) != null ? br : randomBytes$4(32);
  ensureBytes$1(fr, 32);
  const dr = utils$3.v2.getMessageKeys(lr, fr), hr = utils$3.v2.pad(ar), gr = chacha20(dr.encryption, dr.nonce, hr), vr = hmac$3(sha256$4, dr.auth, gr);
  return base64$2.encode(concatBytes$5(new Uint8Array([ur]), fr, gr, vr));
}
function decrypt2$2(lr, ar) {
  const cr = utils$3.v2;
  ensureBytes$1(lr, 32);
  const ur = ar.length;
  if (ur < cr.minCiphertextSize || ur >= cr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let fr;
  try {
    fr = base64$2.decode(ar);
  } catch (kr) {
    throw new Error("invalid base64: " + kr.message);
  }
  const dr = fr.subarray(0, 1)[0];
  if (dr !== 2)
    throw new Error("unknown encryption version " + dr);
  const hr = fr.subarray(1, 33), gr = fr.subarray(33, -32), vr = fr.subarray(-32), mr = cr.getMessageKeys(lr, hr), br = hmac$3(sha256$4, mr.auth, gr);
  if (!equalBytes$1(br, vr))
    throw new Error("invalid MAC");
  const yr = chacha20(mr.encryption, mr.nonce, gr);
  return cr.unpad(yr);
}
var nip47_exports$2 = {};
__export$2(nip47_exports$2, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$2,
  parseConnectionString: () => parseConnectionString$2
});
function parseConnectionString$2(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent$2({
  pubkey: lr,
  secret: ar,
  invoice: cr
}) {
  const fr = await encrypt$3(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finishEvent$1(dr, ar);
}
var nip57_exports$2 = {};
__export$2(nip57_exports$2, {
  getZapEndpoint: () => getZapEndpoint$2,
  makeZapReceipt: () => makeZapReceipt$2,
  makeZapRequest: () => makeZapRequest$2,
  useFetchImplementation: () => useFetchImplementation3$2,
  validateZapRequest: () => validateZapRequest$2
});
var _fetch3$2;
try {
  _fetch3$2 = fetch;
} catch (lr) {
}
function useFetchImplementation3$2(lr) {
  _fetch3$2 = lr;
}
async function getZapEndpoint$2(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: hr } = bech32$3.decode(cr, 1e3), gr = bech32$3.fromWords(hr);
      ar = utf8Decoder$2.decode(gr);
    } else if (ur) {
      let [hr, gr] = ur.split("@");
      ar = `https://${gr}/.well-known/lnurlp/${hr}`;
    } else
      return null;
    let dr = await (await _fetch3$2(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$2({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest$2(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$2(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature$1(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, hr]) => dr === "p" && hr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, hr]) => dr === "e" && hr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, hr]) => dr === "relays" && hr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$2({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let dr = JSON.parse(lr).tags.filter(([gr]) => gr === "e" || gr === "p" || gr === "a"), hr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["bolt11", cr], ["description", lr]]
  };
  return ar && hr.tags.push(["preimage", ar]), hr;
}
var nip98_exports$2 = {};
__export$2(nip98_exports$2, {
  getToken: () => getToken$2,
  unpackEventFromToken: () => unpackEventFromToken$2,
  validateEvent: () => validateEvent2$2,
  validateToken: () => validateToken$2
});
var _authorizationScheme$2 = "Nostr ";
async function getToken$2(lr, ar, cr, ur = !1) {
  if (!lr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const fr = getBlankEvent$1(
    27235
    /* HttpAuth */
  );
  fr.tags = [
    ["u", lr],
    ["method", ar]
  ], fr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const dr = await cr(fr);
  return (ur ? _authorizationScheme$2 : "") + base64$2.encode(utf8Encoder$2.encode(JSON.stringify(dr)));
}
async function validateToken$2(lr, ar, cr) {
  const ur = await unpackEventFromToken$2(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2$2(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken$2(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme$2, "");
  const ar = utf8Decoder$2.decode(base64$2.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$2(lr, ar, cr) {
  if (!lr)
    throw new Error("Invalid nostr event");
  if (!verifySignature$1(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (lr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!lr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = lr.tags.find((dr) => dr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const fr = lr.tags.find((dr) => dr[0] === "method");
  if ((fr == null ? void 0 : fr.length) !== 1 && (fr == null ? void 0 : fr[1].toLowerCase()) !== cr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
var commonjsGlobal$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function getDefaultExportFromCjs(lr) {
  return lr && lr.__esModule && Object.prototype.hasOwnProperty.call(lr, "default") ? lr.default : lr;
}
function getAugmentedNamespace(lr) {
  if (lr.__esModule)
    return lr;
  var ar = lr.default;
  if (typeof ar == "function") {
    var cr = function ur() {
      return this instanceof ur ? Reflect.construct(ar, arguments, this.constructor) : ar.apply(this, arguments);
    };
    cr.prototype = ar.prototype;
  } else
    cr = {};
  return Object.defineProperty(cr, "__esModule", { value: !0 }), Object.keys(lr).forEach(function(ur) {
    var fr = Object.getOwnPropertyDescriptor(lr, ur);
    Object.defineProperty(cr, ur, fr.get ? fr : {
      enumerable: !0,
      get: function() {
        return lr[ur];
      }
    });
  }), cr;
}
var lib$2 = {}, types = {};
Object.defineProperty(types, "__esModule", { value: !0 });
var ee$2 = {}, taskCollection$1 = {}, taskCollection = {}, bakeCollection = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.bakeCollectionVariadic = exports.bakeCollectionAwait = exports.bakeCollection = exports.BAKED_EMPTY_FUNC = void 0, exports.BAKED_EMPTY_FUNC = function() {
  };
  var FORLOOP_FALLBACK = 1500;
  function generateArgsDefCode(lr) {
    var ar = "";
    if (lr === 0)
      return ar;
    for (var cr = 0; cr < lr - 1; ++cr)
      ar += "arg" + String(cr) + ", ";
    return ar += "arg" + String(lr - 1), ar;
  }
  function generateBodyPartsCode(lr, ar) {
    for (var cr = "", ur = "", fr = 0; fr < ar; ++fr)
      cr += "var f".concat(fr, " = collection[").concat(fr, `];
`), ur += "f".concat(fr, "(").concat(lr, `)
`);
    return { funcDefCode: cr, funcCallCode: ur };
  }
  function generateBodyPartsVariadicCode(lr) {
    for (var ar = "", cr = "", ur = 0; ur < lr; ++ur)
      ar += "var f".concat(ur, " = collection[").concat(ur, `];
`), cr += "f".concat(ur, `.apply(undefined, arguments)
`);
    return { funcDefCode: ar, funcCallCode: cr };
  }
  function bakeCollection(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                `).concat(funcCallCode, `
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      collection.length % 10 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                        collection[i+4](`).concat(argsDefCode, `);
                        collection[i+5](`).concat(argsDefCode, `);
                        collection[i+6](`).concat(argsDefCode, `);
                        collection[i+7](`).concat(argsDefCode, `);
                        collection[i+8](`).concat(argsDefCode, `);
                        collection[i+9](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 4 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 3 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                    }
                });
            })`) : funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode, `);
                    }
                });
            })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollection = bakeCollection;
  function bakeCollectionAwait(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                return Promise.all([ `).concat(funcCallCode, ` ]);
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      funcFactoryCode = `(function(collection) {
            return (function(`.concat(argsDefCode, `) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode, `);
                }
                return Promise.all(promises);
            });
        })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionAwait = bakeCollectionAwait;
  function bakeCollectionVariadic(collection) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var _a = generateBodyPartsVariadicCode(collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function() {
                `).concat(funcCallCode, `
            });
        })`);
    } else
      funcFactoryCode = `(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionVariadic = bakeCollectionVariadic;
})(bakeCollection);
var __spreadArray$3 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
};
Object.defineProperty(taskCollection, "__esModule", { value: !0 });
taskCollection.TaskCollection = taskCollection._fast_remove_single = void 0;
var bake_collection_1 = bakeCollection;
function push_norebuild(lr, ar) {
  var cr = this.length;
  if (cr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(lr), this.length++;
  else if (ar) {
    if (cr === 1) {
      var fr = Array(1 + arguments.length);
      fr.push(fr), fr.push.apply(fr, arguments), this._tasks = fr;
    } else {
      var fr = Array(arguments.length);
      fr.push.apply(fr, arguments), this._tasks = fr;
    }
    this.length += arguments.length;
  } else
    cr === 1 ? this._tasks = [this._tasks, lr] : this._tasks = lr, this.length++;
}
function push_rebuild(lr, ar) {
  var cr = this.length;
  if (cr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(lr), this.length++;
  else if (ar) {
    if (cr === 1) {
      var fr = Array(1 + arguments.length);
      fr.push(fr), fr.push.apply(fr, arguments), this._tasks = fr;
    } else {
      var fr = Array(arguments.length);
      fr.push.apply(fr, arguments), this._tasks = fr;
    }
    this.length += arguments.length;
  } else
    cr === 1 ? this._tasks = [this._tasks, lr] : this._tasks = lr, this.length++;
  this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function _fast_remove_single(lr, ar) {
  ar !== -1 && (ar === 0 ? lr.shift() : ar === lr.length - 1 ? lr.length = lr.length - 1 : lr.splice(ar, 1));
}
taskCollection._fast_remove_single = _fast_remove_single;
function removeLast_norebuild(lr) {
  this.length !== 0 && (this.length === 1 ? this._tasks === lr && (this.length = 0) : (_fast_remove_single(this._tasks, this._tasks.lastIndexOf(lr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length));
}
function removeLast_rebuild(lr) {
  if (this.length !== 0) {
    if (this.length === 1)
      if (this._tasks === lr && (this.length = 0), this.firstEmitBuildStrategy) {
        this.call = bake_collection_1.BAKED_EMPTY_FUNC;
        return;
      } else {
        this.rebuild();
        return;
      }
    else
      _fast_remove_single(this._tasks, this._tasks.lastIndexOf(lr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length;
    this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
  }
}
function insert_norebuild(lr) {
  for (var ar, cr = [], ur = 1; ur < arguments.length; ur++)
    cr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = cr, this.length = 1) : this.length === 1 ? (cr.unshift(this._tasks), this._tasks = cr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([lr, 0], cr, !1)), this.length = this._tasks.length);
}
function insert_rebuild(lr) {
  for (var ar, cr = [], ur = 1; ur < arguments.length; ur++)
    cr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = cr, this.length = 1) : this.length === 1 ? (cr.unshift(this._tasks), this._tasks = cr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([lr, 0], cr, !1)), this.length = this._tasks.length), this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function rebuild_noawait() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollection)(this._tasks, this.argsNum);
}
function rebuild_await() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollectionAwait)(this._tasks, this.argsNum);
}
function rebuild_on_first_call() {
  this.rebuild(), this.call.apply(void 0, arguments);
}
var TaskCollection = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      cr === void 0 && (cr = !0), ur === void 0 && (ur = null), fr === void 0 && (fr = !1), this.awaitTasks = fr, this.call = bake_collection_1.BAKED_EMPTY_FUNC, this.argsNum = ar, this.firstEmitBuildStrategy = !0, fr ? this.rebuild = rebuild_await.bind(this) : this.rebuild = rebuild_noawait.bind(this), this.setAutoRebuild(cr), ur ? typeof ur == "function" ? (this._tasks = ur, this.length = 1) : (this._tasks = ur, this.length = ur.length) : (this._tasks = null, this.length = 0), cr && this.rebuild();
    }
    return lr;
  }()
);
taskCollection.TaskCollection = TaskCollection;
function fastClear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function clear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function growArgsNum(lr) {
  this.argsNum < lr && (this.argsNum = lr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
function setAutoRebuild(lr) {
  lr ? (this.push = push_rebuild.bind(this), this.insert = insert_rebuild.bind(this), this.removeLast = removeLast_rebuild.bind(this)) : (this.push = push_norebuild.bind(this), this.insert = insert_norebuild.bind(this), this.removeLast = removeLast_norebuild.bind(this));
}
function tasksAsArray() {
  return this.length === 0 ? [] : this.length === 1 ? [this._tasks] : this._tasks;
}
function setTasks(lr) {
  lr.length === 0 ? (this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC) : lr.length === 1 ? (this.length = 1, this.call = lr[0], this._tasks = lr[0]) : (this.length = lr.length, this._tasks = lr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
TaskCollection.prototype.fastClear = fastClear;
TaskCollection.prototype.clear = clear;
TaskCollection.prototype.growArgsNum = growArgsNum;
TaskCollection.prototype.setAutoRebuild = setAutoRebuild;
TaskCollection.prototype.tasksAsArray = tasksAsArray;
TaskCollection.prototype.setTasks = setTasks;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr);
    var gr = Object.getOwnPropertyDescriptor(fr, dr);
    (!gr || ("get" in gr ? !fr.__esModule : gr.writable || gr.configurable)) && (gr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, hr, gr);
  } : function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr), ur[hr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(taskCollection, lr);
})(taskCollection$1);
var utils$2 = {};
Object.defineProperty(utils$2, "__esModule", { value: !0 });
utils$2.nullObj = void 0;
function nullObj() {
  var lr = {};
  return lr.__proto__ = null, lr.prototype = null, lr;
}
utils$2.nullObj = nullObj;
var __spreadArray$2 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
};
Object.defineProperty(ee$2, "__esModule", { value: !0 });
ee$2.EventEmitter = void 0;
var task_collection_1 = taskCollection$1, utils_1$1 = utils$2;
function emit(lr, ar, cr, ur, fr, dr) {
  var hr = this.events[lr];
  return hr ? hr.length === 0 ? !1 : (hr.argsNum < 6 ? hr.call(ar, cr, ur, fr, dr) : hr.call.apply(void 0, arguments), !0) : !1;
}
function emitHasOnce(lr, ar, cr, ur, fr, dr) {
  var hr = this.events[lr];
  if (hr) {
    if (hr.length === 0)
      return !1;
    hr.argsNum < 6 ? hr.call(ar, cr, ur, fr, dr) : hr.call.apply(void 0, arguments);
  }
  var gr = this.onceEvents[lr];
  if (gr) {
    if (typeof gr == "function")
      this.onceEvents[lr] = void 0, arguments.length < 6 ? gr(ar, cr, ur, fr, dr) : gr.apply(void 0, arguments);
    else {
      var vr = gr;
      if (this.onceEvents[lr] = void 0, arguments.length < 6)
        for (var mr = 0; mr < vr.length; ++mr)
          vr[mr](ar, cr, ur, fr, dr);
      else
        for (var mr = 0; mr < vr.length; ++mr)
          vr[mr].apply(void 0, arguments);
    }
    return !0;
  }
  return !!hr;
}
var EventEmitter$1 = (
  /** @class */
  function() {
    function lr() {
      this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set(), this.maxListeners = 1 / 0;
    }
    return Object.defineProperty(lr.prototype, "_eventsCount", {
      get: function() {
        return this.eventNames().length;
      },
      enumerable: !1,
      configurable: !0
    }), lr;
  }()
);
ee$2.EventEmitter = EventEmitter$1;
function once(lr, ar) {
  switch (this.emit === emit && (this.emit = emitHasOnce), typeof this.onceEvents[lr]) {
    case "undefined":
      this.onceEvents[lr] = ar, typeof lr == "symbol" && this._symbolKeys.add(lr);
      break;
    case "function":
      this.onceEvents[lr] = [this.onceEvents[lr], ar];
      break;
    case "object":
      this.onceEvents[lr].push(ar);
  }
  return this;
}
function addListener(lr, ar, cr) {
  if (cr === void 0 && (cr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[lr];
  return ur ? (ur.push(ar), ur.growArgsNum(cr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(lr), '" event!'))) : (this.events[lr] = new task_collection_1.TaskCollection(cr, !0, ar, !1), typeof lr == "symbol" && this._symbolKeys.add(lr)), this;
}
function removeListener(lr, ar) {
  var cr = this.events[lr];
  cr && cr.removeLast(ar);
  var ur = this.onceEvents[lr];
  return ur && (typeof ur == "function" ? this.onceEvents[lr] = void 0 : typeof ur == "object" && (ur.length === 1 && ur[0] === ar ? this.onceEvents[lr] = void 0 : (0, task_collection_1._fast_remove_single)(ur, ur.lastIndexOf(ar)))), this;
}
function hasListeners(lr) {
  return this.events[lr] && !!this.events[lr].length;
}
function prependListener(lr, ar, cr) {
  if (cr === void 0 && (cr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[lr];
  return !ur || !(ur instanceof task_collection_1.TaskCollection) ? (ur = this.events[lr] = new task_collection_1.TaskCollection(cr, !0, ar, !1), typeof lr == "symbol" && this._symbolKeys.add(lr)) : (ur.insert(0, ar), ur.growArgsNum(cr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(lr), '" event!'))), this;
}
function prependOnceListener(lr, ar) {
  this.emit === emit && (this.emit = emitHasOnce);
  var cr = this.onceEvents[lr];
  if (!cr || typeof cr != "object")
    cr = this.onceEvents[lr] = [ar], typeof lr == "symbol" && this._symbolKeys.add(lr);
  else
    throw new Error("FIXME");
  return this;
}
function removeAllListeners(lr) {
  return lr === void 0 ? (this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set()) : (this.events[lr] = void 0, this.onceEvents[lr] = void 0, typeof lr == "symbol" && this._symbolKeys.delete(lr)), this;
}
function setMaxListeners(lr) {
  return this.maxListeners = lr, this;
}
function getMaxListeners() {
  return this.maxListeners;
}
function listeners(lr) {
  return this.emit === emit ? this.events[lr] ? this.events[lr].tasksAsArray().slice() : [] : this.events[lr] && this.onceEvents[lr] ? __spreadArray$2(__spreadArray$2([], this.events[lr].tasksAsArray(), !0), typeof this.onceEvents[lr] == "function" ? [this.onceEvents[lr]] : this.onceEvents[lr], !0) : this.events[lr] ? this.events[lr].tasksAsArray() : this.onceEvents[lr] ? typeof this.onceEvents[lr] == "function" ? [this.onceEvents[lr]] : this.onceEvents[lr] : [];
}
function eventNames() {
  var lr = this;
  if (this.emit === emit) {
    var ar = Object.keys(this.events);
    return __spreadArray$2(__spreadArray$2([], ar, !0), Array.from(this._symbolKeys), !0).filter(function(ur) {
      return ur in lr.events && lr.events[ur] && lr.events[ur].length;
    });
  } else {
    var ar = Object.keys(this.events).filter(function(fr) {
      return lr.events[fr] && lr.events[fr].length;
    }), cr = Object.keys(this.onceEvents).filter(function(fr) {
      return lr.onceEvents[fr] && lr.onceEvents[fr].length;
    });
    return __spreadArray$2(__spreadArray$2(__spreadArray$2([], ar, !0), cr, !0), Array.from(this._symbolKeys).filter(function(fr) {
      return fr in lr.events && lr.events[fr] && lr.events[fr].length || fr in lr.onceEvents && lr.onceEvents[fr] && lr.onceEvents[fr].length;
    }), !0);
  }
}
function listenerCount(lr) {
  return this.emit === emit ? this.events[lr] && this.events[lr].length || 0 : (this.events[lr] && this.events[lr].length || 0) + (this.onceEvents[lr] && this.onceEvents[lr].length || 0);
}
EventEmitter$1.prototype.emit = emit;
EventEmitter$1.prototype.on = addListener;
EventEmitter$1.prototype.once = once;
EventEmitter$1.prototype.addListener = addListener;
EventEmitter$1.prototype.removeListener = removeListener;
EventEmitter$1.prototype.hasListeners = hasListeners;
EventEmitter$1.prototype.prependListener = prependListener;
EventEmitter$1.prototype.prependOnceListener = prependOnceListener;
EventEmitter$1.prototype.off = removeListener;
EventEmitter$1.prototype.removeAllListeners = removeAllListeners;
EventEmitter$1.prototype.setMaxListeners = setMaxListeners;
EventEmitter$1.prototype.getMaxListeners = getMaxListeners;
EventEmitter$1.prototype.listeners = listeners;
EventEmitter$1.prototype.eventNames = eventNames;
EventEmitter$1.prototype.listenerCount = listenerCount;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr);
    var gr = Object.getOwnPropertyDescriptor(fr, dr);
    (!gr || ("get" in gr ? !fr.__esModule : gr.writable || gr.configurable)) && (gr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, hr, gr);
  } : function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr), ur[hr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(types, lr), cr(ee$2, lr);
})(lib$2);
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var lr = 1e3, ar = lr * 60, cr = ar * 60, ur = cr * 24, fr = ur * 7, dr = ur * 365.25;
  ms = function(br, yr) {
    yr = yr || {};
    var kr = typeof br;
    if (kr === "string" && br.length > 0)
      return hr(br);
    if (kr === "number" && isFinite(br))
      return yr.long ? vr(br) : gr(br);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(br)
    );
  };
  function hr(br) {
    if (br = String(br), !(br.length > 100)) {
      var yr = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        br
      );
      if (yr) {
        var kr = parseFloat(yr[1]), Tr = (yr[2] || "ms").toLowerCase();
        switch (Tr) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return kr * dr;
          case "weeks":
          case "week":
          case "w":
            return kr * fr;
          case "days":
          case "day":
          case "d":
            return kr * ur;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return kr * cr;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return kr * ar;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return kr * lr;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return kr;
          default:
            return;
        }
      }
    }
  }
  function gr(br) {
    var yr = Math.abs(br);
    return yr >= ur ? Math.round(br / ur) + "d" : yr >= cr ? Math.round(br / cr) + "h" : yr >= ar ? Math.round(br / ar) + "m" : yr >= lr ? Math.round(br / lr) + "s" : br + "ms";
  }
  function vr(br) {
    var yr = Math.abs(br);
    return yr >= ur ? mr(br, yr, ur, "day") : yr >= cr ? mr(br, yr, cr, "hour") : yr >= ar ? mr(br, yr, ar, "minute") : yr >= lr ? mr(br, yr, lr, "second") : br + " ms";
  }
  function mr(br, yr, kr, Tr) {
    var _r = yr >= kr * 1.5;
    return Math.round(br / kr) + " " + Tr + (_r ? "s" : "");
  }
  return ms;
}
function setup(lr) {
  cr.debug = cr, cr.default = cr, cr.coerce = vr, cr.disable = dr, cr.enable = fr, cr.enabled = hr, cr.humanize = requireMs(), cr.destroy = mr, Object.keys(lr).forEach((br) => {
    cr[br] = lr[br];
  }), cr.names = [], cr.skips = [], cr.formatters = {};
  function ar(br) {
    let yr = 0;
    for (let kr = 0; kr < br.length; kr++)
      yr = (yr << 5) - yr + br.charCodeAt(kr), yr |= 0;
    return cr.colors[Math.abs(yr) % cr.colors.length];
  }
  cr.selectColor = ar;
  function cr(br) {
    let yr, kr = null, Tr, _r;
    function Er(...xr) {
      if (!Er.enabled)
        return;
      const Cr = Er, Ar = Number(/* @__PURE__ */ new Date()), Lr = Ar - (yr || Ar);
      Cr.diff = Lr, Cr.prev = yr, Cr.curr = Ar, yr = Ar, xr[0] = cr.coerce(xr[0]), typeof xr[0] != "string" && xr.unshift("%O");
      let Dr = 0;
      xr[0] = xr[0].replace(/%([a-zA-Z%])/g, (Hr, $r) => {
        if (Hr === "%%")
          return "%";
        Dr++;
        const Wr = cr.formatters[$r];
        if (typeof Wr == "function") {
          const Zr = xr[Dr];
          Hr = Wr.call(Cr, Zr), xr.splice(Dr, 1), Dr--;
        }
        return Hr;
      }), cr.formatArgs.call(Cr, xr), (Cr.log || cr.log).apply(Cr, xr);
    }
    return Er.namespace = br, Er.useColors = cr.useColors(), Er.color = cr.selectColor(br), Er.extend = ur, Er.destroy = cr.destroy, Object.defineProperty(Er, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => kr !== null ? kr : (Tr !== cr.namespaces && (Tr = cr.namespaces, _r = cr.enabled(br)), _r),
      set: (xr) => {
        kr = xr;
      }
    }), typeof cr.init == "function" && cr.init(Er), Er;
  }
  function ur(br, yr) {
    const kr = cr(this.namespace + (typeof yr == "undefined" ? ":" : yr) + br);
    return kr.log = this.log, kr;
  }
  function fr(br) {
    cr.save(br), cr.namespaces = br, cr.names = [], cr.skips = [];
    let yr;
    const kr = (typeof br == "string" ? br : "").split(/[\s,]+/), Tr = kr.length;
    for (yr = 0; yr < Tr; yr++)
      kr[yr] && (br = kr[yr].replace(/\*/g, ".*?"), br[0] === "-" ? cr.skips.push(new RegExp("^" + br.slice(1) + "$")) : cr.names.push(new RegExp("^" + br + "$")));
  }
  function dr() {
    const br = [
      ...cr.names.map(gr),
      ...cr.skips.map(gr).map((yr) => "-" + yr)
    ].join(",");
    return cr.enable(""), br;
  }
  function hr(br) {
    if (br[br.length - 1] === "*")
      return !0;
    let yr, kr;
    for (yr = 0, kr = cr.skips.length; yr < kr; yr++)
      if (cr.skips[yr].test(br))
        return !1;
    for (yr = 0, kr = cr.names.length; yr < kr; yr++)
      if (cr.names[yr].test(br))
        return !0;
    return !1;
  }
  function gr(br) {
    return br.toString().substring(2, br.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function vr(br) {
    return br instanceof Error ? br.stack || br.message : br;
  }
  function mr() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return cr.enable(cr.load()), cr;
}
var common = setup;
(function(lr, ar) {
  ar.formatArgs = ur, ar.save = fr, ar.load = dr, ar.useColors = cr, ar.storage = hr(), ar.destroy = (() => {
    let vr = !1;
    return () => {
      vr || (vr = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), ar.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function cr() {
    return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function ur(vr) {
    if (vr[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + vr[0] + (this.useColors ? "%c " : " ") + "+" + lr.exports.humanize(this.diff), !this.useColors)
      return;
    const mr = "color: " + this.color;
    vr.splice(1, 0, mr, "color: inherit");
    let br = 0, yr = 0;
    vr[0].replace(/%[a-zA-Z%]/g, (kr) => {
      kr !== "%%" && (br++, kr === "%c" && (yr = br));
    }), vr.splice(yr, 0, mr);
  }
  ar.log = console.debug || console.log || (() => {
  });
  function fr(vr) {
    try {
      vr ? ar.storage.setItem("debug", vr) : ar.storage.removeItem("debug");
    } catch (mr) {
    }
  }
  function dr() {
    let vr;
    try {
      vr = ar.storage.getItem("debug");
    } catch (mr) {
    }
    return !vr && typeof process != "undefined" && "env" in process && (vr = process.env.DEBUG), vr;
  }
  function hr() {
    try {
      return localStorage;
    } catch (vr) {
    }
  }
  lr.exports = common(ar);
  const { formatters: gr } = lr.exports;
  gr.j = function(vr) {
    try {
      return JSON.stringify(vr);
    } catch (mr) {
      return "[UnexpectedJSONParseError]: " + mr.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const _debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var dist$9 = {}, LRUCache$1 = {}, LRUCacheNode$1 = {};
Object.defineProperty(LRUCacheNode$1, "__esModule", { value: !0 });
LRUCacheNode$1.LRUCacheNode = void 0;
class LRUCacheNode {
  constructor(ar, cr, ur) {
    const { entryExpirationTimeInMS: fr = null, next: dr = null, prev: hr = null, onEntryEvicted: gr, onEntryMarkedAsMostRecentlyUsed: vr, clone: mr, cloneFn: br } = ur != null ? ur : {};
    if (typeof fr == "number" && (fr <= 0 || Number.isNaN(fr)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.clone = mr != null ? mr : !1, this.cloneFn = br != null ? br : this.defaultClone, this.key = ar, this.internalValue = this.clone ? this.cloneFn(cr) : cr, this.created = Date.now(), this.entryExpirationTimeInMS = fr, this.next = dr, this.prev = hr, this.onEntryEvicted = gr, this.onEntryMarkedAsMostRecentlyUsed = vr;
  }
  get value() {
    return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;
  }
  get isExpired() {
    return typeof this.entryExpirationTimeInMS == "number" && Date.now() - this.created > this.entryExpirationTimeInMS;
  }
  invokeOnEvicted() {
    if (this.onEntryEvicted) {
      const { key: ar, value: cr, isExpired: ur } = this;
      this.onEntryEvicted({ key: ar, value: cr, isExpired: ur });
    }
  }
  invokeOnEntryMarkedAsMostRecentlyUsed() {
    if (this.onEntryMarkedAsMostRecentlyUsed) {
      const { key: ar, value: cr } = this;
      this.onEntryMarkedAsMostRecentlyUsed({ key: ar, value: cr });
    }
  }
  defaultClone(ar) {
    return typeof ar == "boolean" || typeof ar == "string" || typeof ar == "number" ? ar : JSON.parse(JSON.stringify(ar));
  }
}
LRUCacheNode$1.LRUCacheNode = LRUCacheNode;
Object.defineProperty(LRUCache$1, "__esModule", { value: !0 });
LRUCache$1.LRUCache = void 0;
const LRUCacheNode_1 = LRUCacheNode$1;
class LRUCache {
  /**
   * Creates a new instance of the LRUCache.
   *
   * @param options Additional configuration options for the LRUCache.
   *
   * @example
   * ```typescript
   * // No options.
   * const cache = new LRUCache();
   *
   * // With options.
   * const cache = new LRUCache({
   *  entryExpirationTimeInMS: 10000
   * });
   * ```
   */
  constructor(ar) {
    this.lookupTable = /* @__PURE__ */ new Map(), this.head = null, this.tail = null;
    const { maxSize: cr = 25, entryExpirationTimeInMS: ur = null, onEntryEvicted: fr, onEntryMarkedAsMostRecentlyUsed: dr, cloneFn: hr, clone: gr } = ar != null ? ar : {};
    if (Number.isNaN(cr) || cr <= 0)
      throw new Error("maxSize must be greater than 0.");
    if (typeof ur == "number" && (ur <= 0 || Number.isNaN(ur)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.maxSizeInternal = cr, this.entryExpirationTimeInMS = ur, this.onEntryEvicted = fr, this.onEntryMarkedAsMostRecentlyUsed = dr, this.clone = gr, this.cloneFn = hr;
  }
  /**
   * Returns the number of entries in the LRUCache object.
   * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.
   *
   * @returns The number of entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * cache.set('testKey', 'testValue');
   *
   * const size = cache.size;
   *
   * // Will log 1
   * console.log(size);
   * ```
   */
  get size() {
    return this.cleanCache(), this.lookupTable.size;
  }
  /**
   * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.
   *
   * @returns The number of entries that can still be added without evicting existing entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const remainingSize = cache.remainingSize;
   *
   * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.
   * console.log(remainingSize);
   * ```
   */
  get remainingSize() {
    return this.maxSizeInternal - this.size;
  }
  /**
   * Returns the most recently used (newest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the newest node is expired, it will be removed.
   *
   * @returns The most recently used (newest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const newest = cache.newest;
   *
   * // Will log testValue
   * console.log(newest.value);
   *
   * // Will log testKey
   * console.log(newest.key);
   * ```
   */
  get newest() {
    return this.head ? this.head.isExpired ? (this.removeNodeFromListAndLookupTable(this.head), this.newest) : this.mapNodeToEntry(this.head) : null;
  }
  /**
   * Returns the least recently used (oldest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the oldest node is expired, it will be removed.
   *
   * @returns The least recently used (oldest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const oldest = cache.oldest;
   *
   * // Will log testValue
   * console.log(oldest.value);
   *
   * // Will log testKey
   * console.log(oldest.key);
   * ```
   */
  get oldest() {
    return this.tail ? this.tail.isExpired ? (this.removeNodeFromListAndLookupTable(this.tail), this.oldest) : this.mapNodeToEntry(this.tail) : null;
  }
  /**
   * Gets or sets the maxSize of the cache.
   * This will evict the least recently used entries if needed to reach new maxSize.
   *
   * @param value The new value for maxSize. Must be greater than 0.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * // Will be 10
   * const maxSize = cache.maxSize;
   *
   * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.
   * cache.maxSize = 5;
   * ```
   */
  get maxSize() {
    return this.maxSizeInternal;
  }
  set maxSize(ar) {
    if (Number.isNaN(ar) || ar <= 0)
      throw new Error("maxSize must be greater than 0.");
    this.maxSizeInternal = ar, this.enforceSizeLimit();
  }
  /**
   * Sets the value for the key in the LRUCache object. Returns the LRUCache object.
   * This marks the newly added entry as the most recently used entry.
   * If adding the new entry makes the cache size go above maxSize,
   * this will evict the least recently used entries until size is equal to maxSize.
   *
   * @param key The key of the entry.
   * @param value The value to set for the key.
   * @param entryOptions Additional configuration options for the cache entry.
   *
   * @returns The LRUCache instance.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Set the key key2 to value value2. Pass in optional options.
   * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });
   * ```
   */
  set(ar, cr, ur) {
    const fr = this.lookupTable.get(ar);
    fr && this.removeNodeFromListAndLookupTable(fr);
    const dr = new LRUCacheNode_1.LRUCacheNode(ar, cr, {
      entryExpirationTimeInMS: this.entryExpirationTimeInMS,
      onEntryEvicted: this.onEntryEvicted,
      onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,
      clone: this.clone,
      cloneFn: this.cloneFn,
      ...ur
    });
    return this.setNodeAsHead(dr), this.lookupTable.set(ar, dr), this.enforceSizeLimit(), this;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'. Entry will now be most recently used.
   * const item1 = cache.get('testKey');
   *
   * // Will be null
   * const item2 = cache.get('keyNotInCache');
   * ```
   */
  get(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), null) : (this.setNodeAsHead(cr), cr.value) : null;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this will not mark the entry as most recently accessed.
   * Useful if a value is needed but the order of the cache should not be changed.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'
   * const item1 = cache.peek('testKey');
   *
   * // Will be null
   * const item2 = cache.peek('keyNotInCache');
   * ```
   */
  peek(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), null) : cr.value : null;
  }
  /**
   * Deletes the entry for the passed in key.
   *
   * @param key The key of the entry to delete
   *
   * @returns True if an element in the LRUCache object existed and has been removed,
   * or false if the element does not exist.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.delete('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.delete('keyNotInCache');
   * ```
   */
  delete(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? this.removeNodeFromListAndLookupTable(cr) : !1;
  }
  /**
   * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.
   * This does not mark the entry as recently used.
   * If the cache has a key but the entry is expired, it will be removed and false will be returned.
   *
   * @param key The key of the entry to check if exists
   *
   * @returns true if the cache contains the supplied key. False if not.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.has('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.has('keyNotInCache');
   * ```
   */
  has(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), !1) : !0 : !1;
  }
  /**
   * Removes all entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Clear cache.
   * cache.clear();
   * ```
   */
  clear() {
    this.head = null, this.tail = null, this.lookupTable.clear();
  }
  /**
   * Searches the cache for an entry matching the passed in condition.
   * Expired entries will be skipped (and removed).
   * If multiply entries in the cache match the condition, the most recently used entry will be returned.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param condition The condition to apply to each entry in the
   *
   * @returns The first cache entry to match the condition. Null if none match.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // item will be { key: 'testKey', value: 'testValue }
   * const item = cache.find(entry => {
   *   const { key, value } = entry;
   *
   *   if (key === 'testKey' || value === 'something') {
   *     return true;
   *   }
   *
   *   return false;
   * });
   *
   * // item2 will be null
   * const item2 = cache.find(entry => entry.key === 'notInCache');
   * ```
   */
  find(ar) {
    let cr = this.head;
    for (; cr; ) {
      if (cr.isExpired) {
        const fr = cr.next;
        this.removeNodeFromListAndLookupTable(cr), cr = fr;
        continue;
      }
      const ur = this.mapNodeToEntry(cr);
      if (ar(ur))
        return this.setNodeAsHead(cr), ur;
      cr = cr.next;
    }
    return null;
  }
  /**
   * Iterates over and applies the callback function to each entry in the cache.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as recently used.
   *
   * @param callback the callback function to apply to the entry
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * cache.forEach((key, value, index) => {
   *   // do something with key, value, and/or index
   * });
   * ```
   */
  forEach(ar) {
    let cr = this.head, ur = 0;
    for (; cr; ) {
      if (cr.isExpired) {
        const fr = cr.next;
        this.removeNodeFromListAndLookupTable(cr), cr = fr;
        continue;
      }
      ar(cr.value, cr.key, ur), cr = cr.next, ur++;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache values.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache values.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const value of cache.values()) {
   *   // do something with the value
   * }
   * ```
   */
  *values() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield ar.value, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache keys.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const key of cache.keys()) {
   *   // do something with the key
   * }
   * ```
   */
  *keys() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield ar.key, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache.entries()) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *entries() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *[Symbol.iterator]() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  enforceSizeLimit() {
    let ar = this.tail;
    for (; ar !== null && this.size > this.maxSizeInternal; ) {
      const cr = ar.prev;
      this.removeNodeFromListAndLookupTable(ar), ar = cr;
    }
  }
  mapNodeToEntry({ key: ar, value: cr }) {
    return {
      key: ar,
      value: cr
    };
  }
  setNodeAsHead(ar) {
    this.removeNodeFromList(ar), this.head ? (ar.next = this.head, this.head.prev = ar, this.head = ar) : (this.head = ar, this.tail = ar), ar.invokeOnEntryMarkedAsMostRecentlyUsed();
  }
  removeNodeFromList(ar) {
    ar.prev !== null && (ar.prev.next = ar.next), ar.next !== null && (ar.next.prev = ar.prev), this.head === ar && (this.head = ar.next), this.tail === ar && (this.tail = ar.prev), ar.next = null, ar.prev = null;
  }
  removeNodeFromListAndLookupTable(ar) {
    return ar.invokeOnEvicted(), this.removeNodeFromList(ar), this.lookupTable.delete(ar.key);
  }
  cleanCache() {
    if (!this.entryExpirationTimeInMS)
      return;
    const ar = [];
    for (const cr of this.lookupTable.values())
      cr.isExpired && ar.push(cr);
    ar.forEach((cr) => this.removeNodeFromListAndLookupTable(cr));
  }
}
LRUCache$1.LRUCache = LRUCache;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr);
    var gr = Object.getOwnPropertyDescriptor(fr, dr);
    (!gr || ("get" in gr ? !fr.__esModule : gr.writable || gr.configurable)) && (gr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, hr, gr);
  } : function(ur, fr, dr, hr) {
    hr === void 0 && (hr = dr), ur[hr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(LRUCache$1, lr);
})(dist$9);
var lib$1 = {};
(function(lr) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.bytes = lr.stringToBytes = lr.str = lr.bytesToString = lr.hex = lr.utf8 = lr.bech32m = lr.bech32 = lr.base58check = lr.base58xmr = lr.base58xrp = lr.base58flickr = lr.base58 = lr.base64url = lr.base64 = lr.base32crockford = lr.base32hex = lr.base32 = lr.base16 = lr.utils = lr.assertNumber = void 0;
  function ar(Jr) {
    if (!Number.isSafeInteger(Jr))
      throw new Error(`Wrong integer: ${Jr}`);
  }
  lr.assertNumber = ar;
  function cr(...Jr) {
    const Yr = (ci, hi) => (Ei) => ci(hi(Ei)), li = Array.from(Jr).reverse().reduce((ci, hi) => ci ? Yr(ci, hi.encode) : hi.encode, void 0), Si = Jr.reduce((ci, hi) => ci ? Yr(ci, hi.decode) : hi.decode, void 0);
    return { encode: li, decode: Si };
  }
  function ur(Jr) {
    return {
      encode: (Yr) => {
        if (!Array.isArray(Yr) || Yr.length && typeof Yr[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return Yr.map((li) => {
          if (ar(li), li < 0 || li >= Jr.length)
            throw new Error(`Digit index outside alphabet: ${li} (alphabet: ${Jr.length})`);
          return Jr[li];
        });
      },
      decode: (Yr) => {
        if (!Array.isArray(Yr) || Yr.length && typeof Yr[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return Yr.map((li) => {
          if (typeof li != "string")
            throw new Error(`alphabet.decode: not string element=${li}`);
          const Si = Jr.indexOf(li);
          if (Si === -1)
            throw new Error(`Unknown letter: "${li}". Allowed: ${Jr}`);
          return Si;
        });
      }
    };
  }
  function fr(Jr = "") {
    if (typeof Jr != "string")
      throw new Error("join separator should be string");
    return {
      encode: (Yr) => {
        if (!Array.isArray(Yr) || Yr.length && typeof Yr[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let li of Yr)
          if (typeof li != "string")
            throw new Error(`join.encode: non-string input=${li}`);
        return Yr.join(Jr);
      },
      decode: (Yr) => {
        if (typeof Yr != "string")
          throw new Error("join.decode input should be string");
        return Yr.split(Jr);
      }
    };
  }
  function dr(Jr, Yr = "=") {
    if (ar(Jr), typeof Yr != "string")
      throw new Error("padding chr should be string");
    return {
      encode(li) {
        if (!Array.isArray(li) || li.length && typeof li[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let Si of li)
          if (typeof Si != "string")
            throw new Error(`padding.encode: non-string input=${Si}`);
        for (; li.length * Jr % 8; )
          li.push(Yr);
        return li;
      },
      decode(li) {
        if (!Array.isArray(li) || li.length && typeof li[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let ci of li)
          if (typeof ci != "string")
            throw new Error(`padding.decode: non-string input=${ci}`);
        let Si = li.length;
        if (Si * Jr % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; Si > 0 && li[Si - 1] === Yr; Si--)
          if (!((Si - 1) * Jr % 8))
            throw new Error("Invalid padding: string has too much padding");
        return li.slice(0, Si);
      }
    };
  }
  function hr(Jr) {
    if (typeof Jr != "function")
      throw new Error("normalize fn should be function");
    return { encode: (Yr) => Yr, decode: (Yr) => Jr(Yr) };
  }
  function gr(Jr, Yr, li) {
    if (Yr < 2)
      throw new Error(`convertRadix: wrong from=${Yr}, base cannot be less than 2`);
    if (li < 2)
      throw new Error(`convertRadix: wrong to=${li}, base cannot be less than 2`);
    if (!Array.isArray(Jr))
      throw new Error("convertRadix: data should be array");
    if (!Jr.length)
      return [];
    let Si = 0;
    const ci = [], hi = Array.from(Jr);
    for (hi.forEach((Ei) => {
      if (ar(Ei), Ei < 0 || Ei >= Yr)
        throw new Error(`Wrong integer: ${Ei}`);
    }); ; ) {
      let Ei = 0, di = !0;
      for (let gi = Si; gi < hi.length; gi++) {
        const Li = hi[gi], ui = Yr * Ei + Li;
        if (!Number.isSafeInteger(ui) || Yr * Ei / Yr !== Ei || ui - Li !== Yr * Ei)
          throw new Error("convertRadix: carry overflow");
        if (Ei = ui % li, hi[gi] = Math.floor(ui / li), !Number.isSafeInteger(hi[gi]) || hi[gi] * li + Ei !== ui)
          throw new Error("convertRadix: carry overflow");
        if (di)
          hi[gi] ? di = !1 : Si = gi;
        else
          continue;
      }
      if (ci.push(Ei), di)
        break;
    }
    for (let Ei = 0; Ei < Jr.length - 1 && Jr[Ei] === 0; Ei++)
      ci.push(0);
    return ci.reverse();
  }
  const vr = (Jr, Yr) => Yr ? vr(Yr, Jr % Yr) : Jr, mr = (Jr, Yr) => Jr + (Yr - vr(Jr, Yr));
  function br(Jr, Yr, li, Si) {
    if (!Array.isArray(Jr))
      throw new Error("convertRadix2: data should be array");
    if (Yr <= 0 || Yr > 32)
      throw new Error(`convertRadix2: wrong from=${Yr}`);
    if (li <= 0 || li > 32)
      throw new Error(`convertRadix2: wrong to=${li}`);
    if (mr(Yr, li) > 32)
      throw new Error(`convertRadix2: carry overflow from=${Yr} to=${li} carryBits=${mr(Yr, li)}`);
    let ci = 0, hi = 0;
    const Ei = 2 ** li - 1, di = [];
    for (const gi of Jr) {
      if (ar(gi), gi >= 2 ** Yr)
        throw new Error(`convertRadix2: invalid data word=${gi} from=${Yr}`);
      if (ci = ci << Yr | gi, hi + Yr > 32)
        throw new Error(`convertRadix2: carry overflow pos=${hi} from=${Yr}`);
      for (hi += Yr; hi >= li; hi -= li)
        di.push((ci >> hi - li & Ei) >>> 0);
      ci &= 2 ** hi - 1;
    }
    if (ci = ci << li - hi & Ei, !Si && hi >= Yr)
      throw new Error("Excess padding");
    if (!Si && ci)
      throw new Error(`Non-zero padding: ${ci}`);
    return Si && hi > 0 && di.push(ci >>> 0), di;
  }
  function yr(Jr) {
    return ar(Jr), {
      encode: (Yr) => {
        if (!(Yr instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return gr(Array.from(Yr), 2 ** 8, Jr);
      },
      decode: (Yr) => {
        if (!Array.isArray(Yr) || Yr.length && typeof Yr[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(gr(Yr, Jr, 2 ** 8));
      }
    };
  }
  function kr(Jr, Yr = !1) {
    if (ar(Jr), Jr <= 0 || Jr > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (mr(8, Jr) > 32 || mr(Jr, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (li) => {
        if (!(li instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return br(Array.from(li), 8, Jr, !Yr);
      },
      decode: (li) => {
        if (!Array.isArray(li) || li.length && typeof li[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(br(li, Jr, 8, Yr));
      }
    };
  }
  function Tr(Jr) {
    if (typeof Jr != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...Yr) {
      try {
        return Jr.apply(null, Yr);
      } catch (li) {
      }
    };
  }
  function _r(Jr, Yr) {
    if (ar(Jr), typeof Yr != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(li) {
        if (!(li instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const Si = Yr(li).slice(0, Jr), ci = new Uint8Array(li.length + Jr);
        return ci.set(li), ci.set(Si, li.length), ci;
      },
      decode(li) {
        if (!(li instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const Si = li.slice(0, -Jr), ci = Yr(Si).slice(0, Jr), hi = li.slice(-Jr);
        for (let Ei = 0; Ei < Jr; Ei++)
          if (ci[Ei] !== hi[Ei])
            throw new Error("Invalid checksum");
        return Si;
      }
    };
  }
  lr.utils = { alphabet: ur, chain: cr, checksum: _r, radix: yr, radix2: kr, join: fr, padding: dr }, lr.base16 = cr(kr(4), ur("0123456789ABCDEF"), fr("")), lr.base32 = cr(kr(5), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), dr(5), fr("")), lr.base32hex = cr(kr(5), ur("0123456789ABCDEFGHIJKLMNOPQRSTUV"), dr(5), fr("")), lr.base32crockford = cr(kr(5), ur("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), fr(""), hr((Jr) => Jr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), lr.base64 = cr(kr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), dr(6), fr("")), lr.base64url = cr(kr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), dr(6), fr(""));
  const Er = (Jr) => cr(yr(58), ur(Jr), fr(""));
  lr.base58 = Er("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), lr.base58flickr = Er("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), lr.base58xrp = Er("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const xr = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  lr.base58xmr = {
    encode(Jr) {
      let Yr = "";
      for (let li = 0; li < Jr.length; li += 8) {
        const Si = Jr.subarray(li, li + 8);
        Yr += lr.base58.encode(Si).padStart(xr[Si.length], "1");
      }
      return Yr;
    },
    decode(Jr) {
      let Yr = [];
      for (let li = 0; li < Jr.length; li += 11) {
        const Si = Jr.slice(li, li + 11), ci = xr.indexOf(Si.length), hi = lr.base58.decode(Si);
        for (let Ei = 0; Ei < hi.length - ci; Ei++)
          if (hi[Ei] !== 0)
            throw new Error("base58xmr: wrong padding");
        Yr = Yr.concat(Array.from(hi.slice(hi.length - ci)));
      }
      return Uint8Array.from(Yr);
    }
  };
  const Cr = (Jr) => cr(_r(4, (Yr) => Jr(Jr(Yr))), lr.base58);
  lr.base58check = Cr;
  const Ar = cr(ur("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), fr("")), Lr = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function Dr(Jr) {
    const Yr = Jr >> 25;
    let li = (Jr & 33554431) << 5;
    for (let Si = 0; Si < Lr.length; Si++)
      (Yr >> Si & 1) === 1 && (li ^= Lr[Si]);
    return li;
  }
  function Nr(Jr, Yr, li = 1) {
    const Si = Jr.length;
    let ci = 1;
    for (let hi = 0; hi < Si; hi++) {
      const Ei = Jr.charCodeAt(hi);
      if (Ei < 33 || Ei > 126)
        throw new Error(`Invalid prefix (${Jr})`);
      ci = Dr(ci) ^ Ei >> 5;
    }
    ci = Dr(ci);
    for (let hi = 0; hi < Si; hi++)
      ci = Dr(ci) ^ Jr.charCodeAt(hi) & 31;
    for (let hi of Yr)
      ci = Dr(ci) ^ hi;
    for (let hi = 0; hi < 6; hi++)
      ci = Dr(ci);
    return ci ^= li, Ar.encode(br([ci % 2 ** 30], 30, 5, !1));
  }
  function Hr(Jr) {
    const Yr = Jr === "bech32" ? 1 : 734539939, li = kr(5), Si = li.decode, ci = li.encode, hi = Tr(Si);
    function Ei(ui, wi, Ui = 90) {
      if (typeof ui != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof ui}`);
      if (!Array.isArray(wi) || wi.length && typeof wi[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof wi}`);
      const yi = ui.length + 7 + wi.length;
      if (Ui !== !1 && yi > Ui)
        throw new TypeError(`Length ${yi} exceeds limit ${Ui}`);
      return ui = ui.toLowerCase(), `${ui}1${Ar.encode(wi)}${Nr(ui, wi, Yr)}`;
    }
    function di(ui, wi = 90) {
      if (typeof ui != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof ui}`);
      if (ui.length < 8 || wi !== !1 && ui.length > wi)
        throw new TypeError(`Wrong string length: ${ui.length} (${ui}). Expected (8..${wi})`);
      const Ui = ui.toLowerCase();
      if (ui !== Ui && ui !== ui.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      ui = Ui;
      const yi = ui.lastIndexOf("1");
      if (yi === 0 || yi === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const Vi = ui.slice(0, yi), Oi = ui.slice(yi + 1);
      if (Oi.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const Mi = Ar.decode(Oi).slice(0, -6), Ii = Nr(Vi, Mi, Yr);
      if (!Oi.endsWith(Ii))
        throw new Error(`Invalid checksum in ${ui}: expected "${Ii}"`);
      return { prefix: Vi, words: Mi };
    }
    const gi = Tr(di);
    function Li(ui) {
      const { prefix: wi, words: Ui } = di(ui, !1);
      return { prefix: wi, words: Ui, bytes: Si(Ui) };
    }
    return { encode: Ei, decode: di, decodeToBytes: Li, decodeUnsafe: gi, fromWords: Si, fromWordsUnsafe: hi, toWords: ci };
  }
  lr.bech32 = Hr("bech32"), lr.bech32m = Hr("bech32m"), lr.utf8 = {
    encode: (Jr) => new TextDecoder().decode(Jr),
    decode: (Jr) => new TextEncoder().encode(Jr)
  }, lr.hex = cr(kr(4), ur("0123456789abcdef"), fr(""), hr((Jr) => {
    if (typeof Jr != "string" || Jr.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof Jr} with length ${Jr.length}`);
    return Jr.toLowerCase();
  }));
  const $r = {
    utf8: lr.utf8,
    hex: lr.hex,
    base16: lr.base16,
    base32: lr.base32,
    base64: lr.base64,
    base64url: lr.base64url,
    base58: lr.base58,
    base58xmr: lr.base58xmr
  }, Wr = `Invalid encoding type. Available types: ${Object.keys($r).join(", ")}`, Zr = (Jr, Yr) => {
    if (typeof Jr != "string" || !$r.hasOwnProperty(Jr))
      throw new TypeError(Wr);
    if (!(Yr instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return $r[Jr].encode(Yr);
  };
  lr.bytesToString = Zr, lr.str = lr.bytesToString;
  const oi = (Jr, Yr) => {
    if (!$r.hasOwnProperty(Jr))
      throw new TypeError(Wr);
    if (typeof Yr != "string")
      throw new TypeError("stringToBytes() expects string");
    return $r[Jr].decode(Yr);
  };
  lr.stringToBytes = oi, lr.bytes = lr.stringToBytes;
})(lib$1);
BigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);
BigInt("2100000000000000000");
BigInt(1e11);
const TAGCODES = {
  payment_hash: 1,
  payment_secret: 16,
  description: 13,
  payee: 19,
  description_hash: 23,
  // commit to longer descriptions (used by lnurl-pay)
  expiry: 6,
  // default: 3600 (1 hour)
  min_final_cltv_expiry: 24,
  // default: 9
  fallback_address: 9,
  route_hint: 3,
  // for extra routing info (private etc.)
  feature_bits: 5,
  metadata: 27
};
for (let lr = 0, ar = Object.keys(TAGCODES); lr < ar.length; lr++)
  ar[lr], TAGCODES[ar[lr]].toString();
var NDKRelayConnectivity = class {
  constructor(lr) {
    Wi(this, "ndkRelay");
    Wi(this, "_status");
    Wi(this, "relay");
    Wi(this, "connectedAt");
    Wi(this, "_connectionStats", {
      attempts: 0,
      success: 0,
      durations: []
    });
    Wi(this, "debug");
    /**
     * Utility functions to update the connection stats.
     */
    Wi(this, "updateConnectionStats", {
      connected: () => {
        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();
      },
      disconnected: () => {
        this._connectionStats.connectedAt && (this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;
      },
      attempt: () => {
        this._connectionStats.attempts++;
      }
    });
    this.ndkRelay = lr, this._status = 3, this.relay = relayInit(this.ndkRelay.url), this.debug = this.ndkRelay.debug.extend("connectivity"), this.relay.on("notice", (ar) => this.handleNotice(ar));
  }
  async connect() {
    const lr = () => {
      this.updateConnectionStats.connected(), this._status = 1, this.ndkRelay.emit("connect");
    }, ar = () => {
      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.ndkRelay.emit("disconnect");
    };
    try {
      this.updateConnectionStats.attempt(), this._status = 0, this.relay.off("connect", lr), this.relay.off("disconnect", ar), this.relay.on("connect", lr), this.relay.on("disconnect", ar), await this.relay.connect();
    } catch (cr) {
      throw this.debug("Failed to connect", cr), this._status = 3, cr;
    }
  }
  disconnect() {
    this._status = 2, this.relay.close();
  }
  get status() {
    return this._status;
  }
  isAvailable() {
    return this._status === 1;
  }
  /**
   * Evaluates the connection stats to determine if the relay is flapping.
   */
  isFlapping() {
    const lr = this._connectionStats.durations;
    if (lr.length % 3 !== 0)
      return !1;
    const cr = lr.reduce((hr, gr) => hr + gr, 0) / lr.length, ur = lr.map((hr) => Math.pow(hr - cr, 2)).reduce((hr, gr) => hr + gr, 0) / lr.length;
    return Math.sqrt(ur) < 1e3;
  }
  async handleNotice(lr) {
    (lr.includes("oo many") || lr.includes("aximum")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, "Relay complaining?", lr)), this.ndkRelay.emit("notice", this, lr);
  }
  /**
   * Called when the relay is unexpectedly disconnected.
   */
  handleReconnection(lr = 0) {
    if (this.isFlapping()) {
      this.ndkRelay.emit("flapping", this, this._connectionStats), this._status = 5;
      return;
    }
    const ar = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 0;
    setTimeout(() => {
      this._status = 4, this.connect().then(() => {
        this.debug("Reconnected");
      }).catch((cr) => {
        this.debug("Reconnect failed", cr), lr < 5 ? setTimeout(() => {
          this.handleReconnection(lr + 1);
        }, 6e4) : this.debug("Reconnect failed after 5 attempts");
      });
    }, ar);
  }
  /**
   * Returns the connection stats.
   */
  get connectionStats() {
    return this._connectionStats;
  }
}, NDKRelayPublisher = class {
  constructor(lr) {
    Wi(this, "ndkRelay");
    this.ndkRelay = lr;
  }
  /**
   * Published an event to the relay; if the relay is not connected, it will
   * wait for the relay to connect before publishing the event.
   *
   * If the relay does not connect within the timeout, the publish operation
   * will fail.
   * @param event  The event to publish
   * @param timeoutMs  The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(lr, ar = 2500) {
    const cr = () => new Promise((gr, vr) => {
      try {
        this.publishEvent(lr, ar).then((mr) => gr(mr)).catch((mr) => vr(mr));
      } catch (mr) {
        vr(mr);
      }
    }), ur = new Promise((gr, vr) => {
      setTimeout(() => vr(new Error("Timeout")), ar);
    }), fr = () => {
      cr().then((gr) => dr(gr)).catch((gr) => hr(gr));
    };
    let dr, hr;
    return this.ndkRelay.status === 1 ? Promise.race([cr(), ur]) : Promise.race([
      new Promise((gr, vr) => {
        dr = gr, hr = vr, this.ndkRelay.once("connect", fr);
      }),
      ur
    ]).finally(() => {
      this.ndkRelay.removeListener("connect", fr);
    });
  }
  async publishEvent(lr, ar) {
    const cr = await lr.toNostrEvent(), ur = this.ndkRelay.connectivity.relay.publish(cr);
    let fr;
    const dr = new Promise((gr, vr) => {
      ur.then(() => {
        clearTimeout(fr), this.ndkRelay.emit("published", lr), gr(!0);
      }).catch((mr) => {
        clearTimeout(fr), this.ndkRelay.debug("Publish failed", mr, lr.id), this.ndkRelay.emit("publish:failed", lr, mr), vr(mr);
      });
    });
    if (!ar || lr.isEphemeral())
      return dr;
    const hr = new Promise((gr, vr) => {
      fr = setTimeout(() => {
        this.ndkRelay.debug("Publish timed out", lr.rawEvent()), this.ndkRelay.emit("publish:failed", lr, "Timeout"), vr(new Error("Publish operation timed out"));
      }, ar);
    });
    return Promise.race([dr, hr]);
  }
};
function calculateGroupableId(lr) {
  const ar = [];
  for (const cr of lr) {
    if (cr.since || cr.until)
      return null;
    const fr = Object.keys(cr || {}).sort().join("-");
    ar.push(fr);
  }
  return ar.join("|");
}
function mergeFilters(lr) {
  const ar = {};
  return lr.forEach((cr) => {
    Object.entries(cr).forEach(([ur, fr]) => {
      Array.isArray(fr) ? ar[ur] === void 0 ? ar[ur] = [...fr] : ar[ur] = Array.from(/* @__PURE__ */ new Set([...ar[ur], ...fr])) : ar[ur] = fr;
    });
  }), ar;
}
var MAX_SUBID_LENGTH = 20;
function queryFullyFilled(lr) {
  return !!(filterIncludesIds(lr.filter) && resultHasAllRequestedIds(lr));
}
function compareFilter(lr, ar) {
  if (Object.keys(lr).length !== Object.keys(ar).length)
    return !1;
  for (const [cr, ur] of Object.entries(lr)) {
    const fr = ar[cr];
    if (!fr)
      return !1;
    if (Array.isArray(ur) && Array.isArray(fr)) {
      const dr = ur;
      for (const hr of fr) {
        const gr = hr;
        if (!dr.includes(gr))
          return !1;
      }
    } else if (fr !== ur)
      return !1;
  }
  return !0;
}
function filterIncludesIds(lr) {
  return !!lr.ids;
}
function resultHasAllRequestedIds(lr) {
  const ar = lr.filter.ids;
  return !!ar && ar.length === lr.eventFirstSeen.size;
}
function generateSubId(lr, ar) {
  var gr;
  const cr = lr.map((vr) => vr.subId).filter(Boolean), ur = [], fr = /* @__PURE__ */ new Set(), dr = /* @__PURE__ */ new Set();
  if (cr.length > 0)
    ur.push(Array.from(new Set(cr)).join(","));
  else {
    for (const vr of ar)
      for (const mr of Object.keys(vr))
        mr === "kinds" ? (gr = vr.kinds) == null || gr.forEach((br) => dr.add(br)) : fr.add(mr);
    dr.size > 0 && ur.push("kinds:" + Array.from(dr).join(",")), fr.size > 0 && ur.push(Array.from(fr).join(","));
  }
  let hr = ur.join("-");
  return hr.length > MAX_SUBID_LENGTH && (hr = hr.substring(0, MAX_SUBID_LENGTH)), cr.length !== 1 && (hr += "-" + Math.floor(Math.random() * 999).toString()), hr;
}
function filterFromId(lr) {
  let ar;
  if (lr.match(NIP33_A_REGEX)) {
    const [cr, ur, fr] = lr.split(":"), dr = {
      authors: [ur],
      kinds: [parseInt(cr)]
    };
    return fr && (dr["#d"] = [fr]), dr;
  }
  try {
    switch (ar = nip19_exports$2.decode(lr), ar.type) {
      case "nevent":
        return { ids: [ar.data.id] };
      case "note":
        return { ids: [ar.data] };
      case "naddr":
        return {
          authors: [ar.data.pubkey],
          "#d": [ar.data.identifier],
          kinds: [ar.data.kind]
        };
    }
  } catch (cr) {
  }
  return { ids: [lr] };
}
function isNip33AValue(lr) {
  return lr.match(NIP33_A_REGEX) !== null;
}
var NIP33_A_REGEX = /^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/;
function relaysFromBech32(lr) {
  try {
    const ar = nip19_exports$2.decode(lr);
    if (["naddr", "nevent"].includes(ar == null ? void 0 : ar.type)) {
      const cr = ar.data;
      if (cr != null && cr.relays)
        return cr.relays.map((ur) => new NDKRelay(ur));
    }
  } catch (ar) {
  }
  return [];
}
var NDKGroupedSubscriptions = class extends lib$2.EventEmitter {
  constructor(ar, cr) {
    super();
    Wi(this, "subscriptions");
    Wi(this, "req");
    Wi(this, "debug");
    this.subscriptions = ar, this.debug = cr || this.subscriptions[0].subscription.debug.extend("grouped");
    for (const ur of ar)
      this.handleSubscriptionClosure(ur);
  }
  /**
   * Adds a subscription to this group.
   * @param subscription
   */
  addSubscription(ar) {
    this.subscriptions.push(ar), this.handleSubscriptionClosure(ar);
  }
  eventReceived(ar) {
    for (const cr of this.subscriptions)
      cr.eventReceived(ar);
  }
  eoseReceived(ar) {
    Array.from(this.subscriptions).forEach(async (ur) => {
      ur.subscription.eoseReceived(ar);
    });
  }
  handleSubscriptionClosure(ar) {
    ar.subscription.on("close", () => {
      const cr = this.subscriptions.findIndex(
        (ur) => ur.subscription === ar.subscription
      );
      this.subscriptions.splice(cr, 1), this.subscriptions.length <= 0 && this.emit("close");
    });
  }
  /**
   * Maps each subscription through a transformation function.
   * @param fn - The transformation function.
   * @returns A new array with each subscription transformed by fn.
   */
  map(ar) {
    return this.subscriptions.map(ar);
  }
  [Symbol.iterator]() {
    let ar = 0;
    const cr = this.subscriptions;
    return {
      next() {
        return ar < cr.length ? { value: cr[ar++], done: !1 } : { value: null, done: !0 };
      }
    };
  }
}, NDKSubscriptionFilters = class {
  constructor(lr, ar, cr) {
    Wi(this, "subscription");
    Wi(this, "filters", []);
    Wi(this, "ndkRelay");
    this.subscription = lr, this.filters = ar, this.ndkRelay = cr;
  }
  eventReceived(lr) {
    this.eventMatchesLocalFilter(lr) && this.subscription.eventReceived(lr, this.ndkRelay, !1);
  }
  eventMatchesLocalFilter(lr) {
    const ar = lr.rawEvent();
    return this.filters.some((cr) => matchFilter$1(cr, ar));
  }
};
function findMatchingActiveSubscriptions(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length && compareFilter(lr[cr], ar[cr]); cr++)
    return lr[cr];
}
var NDKRelaySubscriptions = class {
  constructor(lr) {
    Wi(this, "ndkRelay");
    Wi(this, "delayedItems", /* @__PURE__ */ new Map());
    Wi(this, "delayedTimers", /* @__PURE__ */ new Map());
    /**
     * Active subscriptions this relay is connected to
     */
    Wi(this, "activeSubscriptions", /* @__PURE__ */ new Map());
    Wi(this, "activeSubscriptionsByGroupId", /* @__PURE__ */ new Map());
    Wi(this, "debug");
    Wi(this, "groupingDebug");
    Wi(this, "conn");
    this.ndkRelay = lr, this.conn = lr.connectivity, this.debug = lr.debug.extend("subscriptions"), this.groupingDebug = lr.debug.extend("grouping");
  }
  /**
   * Creates or queues a subscription to the relay.
   */
  subscribe(lr, ar) {
    const cr = calculateGroupableId(ar), ur = new NDKSubscriptionFilters(
      lr,
      ar,
      this.ndkRelay
    );
    if (!cr || !lr.isGroupable()) {
      this.groupingDebug("No groupable ID for filters", ar), this.executeSubscriptions(
        cr,
        // hacky
        new NDKGroupedSubscriptions([ur]),
        ar
      );
      return;
    }
    const fr = this.activeSubscriptionsByGroupId.get(cr);
    if (fr && findMatchingActiveSubscriptions(
      fr.filters,
      ar
    )) {
      const vr = this.activeSubscriptions.get(fr.sub);
      vr == null || vr.addSubscription(
        new NDKSubscriptionFilters(lr, ar, this.ndkRelay)
      );
      return;
    }
    let dr = this.delayedItems.get(cr);
    dr ? dr.addSubscription(ur) : (dr = new NDKGroupedSubscriptions([ur]), this.delayedItems.set(cr, dr), dr.once("close", () => {
      this.delayedItems.get(cr) && this.delayedItems.delete(cr);
    }));
    const hr = setTimeout(() => {
      this.executeGroup(cr, lr);
    }, lr.opts.groupableDelay);
    this.delayedTimers.has(cr) ? this.delayedTimers.get(cr).push(hr) : this.delayedTimers.set(cr, [hr]);
  }
  /**
   * Executes a delayed subscription via its groupable ID.
   * @param groupableId
   */
  executeGroup(lr, ar) {
    const cr = this.delayedItems.get(lr);
    this.delayedItems.delete(lr);
    const ur = this.delayedTimers.get(lr);
    if (this.delayedTimers.delete(lr), ur)
      for (const fr of ur)
        clearTimeout(fr);
    if (cr) {
      const fr = cr.subscriptions[0].filters.length, dr = [];
      for (let hr = 0; hr < fr; hr++) {
        const gr = cr.map((vr) => vr.filters[hr]);
        dr.push(mergeFilters(gr));
      }
      this.executeSubscriptions(lr, cr, dr);
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * If the relay is not connected, subscriptions will be queued
   * until the relay connects.
   *
   * @param groupableId
   * @param subscriptionFilters
   * @param mergedFilters
   */
  executeSubscriptions(lr, ar, cr) {
    if (this.conn.isAvailable())
      this.executeSubscriptionsConnected(lr, ar, cr);
    else {
      const ur = () => {
        this.debug("new relay coming online for active subscription", {
          relay: this.ndkRelay.url,
          mergeFilters
        }), this.executeSubscriptionsConnected(
          lr,
          ar,
          cr
        );
      };
      this.ndkRelay.once("connect", ur), ar.once("close", () => {
        this.ndkRelay.removeListener("connect", ur);
      });
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * When there are more than one subscription, results
   * will be sent to the right subscription
   *
   * @param subscriptions
   * @param filters The filters as they should be sent to the relay
   */
  executeSubscriptionsConnected(lr, ar, cr) {
    const ur = [];
    for (const { subscription: hr } of ar)
      ur.push(hr);
    const fr = generateSubId(ur, cr);
    ar.req = cr;
    const dr = this.conn.relay.sub(cr, { id: fr });
    return this.activeSubscriptions.set(dr, ar), lr && this.activeSubscriptionsByGroupId.set(lr, { filters: cr, sub: dr }), dr.on("event", (hr) => {
      const gr = new NDKEvent(void 0, hr);
      gr.relay = this.ndkRelay;
      const vr = this.activeSubscriptions.get(dr);
      vr == null || vr.eventReceived(gr);
    }), dr.on("eose", () => {
      const hr = this.activeSubscriptions.get(dr);
      hr == null || hr.eoseReceived(this.ndkRelay);
    }), ar.once("close", () => {
      dr.unsub(), this.activeSubscriptions.delete(dr), lr && this.activeSubscriptionsByGroupId.delete(lr);
    }), dr;
  }
  executedFilters() {
    const lr = /* @__PURE__ */ new Map();
    for (const [, ar] of this.activeSubscriptions)
      lr.set(
        ar.req,
        ar.map((cr) => cr.subscription)
      );
    return lr;
  }
}, NDKRelay = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    Wi(this, "url");
    Wi(this, "scores");
    Wi(this, "connectivity");
    Wi(this, "subs");
    Wi(this, "publisher");
    Wi(this, "complaining", !1);
    Wi(this, "debug");
    this.url = ar, this.scores = /* @__PURE__ */ new Map(), this.debug = _debug(`ndk:relay:${ar}`), this.connectivity = new NDKRelayConnectivity(this), this.subs = new NDKRelaySubscriptions(this), this.publisher = new NDKRelayPublisher(this);
  }
  get status() {
    return this.connectivity.status;
  }
  get connectionStats() {
    return this.connectivity.connectionStats;
  }
  /**
   * Connects to the relay.
   */
  async connect() {
    return this.connectivity.connect();
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    this.connectivity.disconnect();
  }
  /**
   * Queues or executes the subscription of a specific set of filters
   * within this relay.
   *
   * @param subscription NDKSubscription this filters belong to.
   * @param filters Filters to execute
   */
  subscribe(ar, cr) {
    this.subs.subscribe(ar, cr);
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(ar, cr = 2500) {
    return this.publisher.publish(ar, cr);
  }
  /**
   * Called when this relay has responded with an event but
   * wasn't the fastest one.
   * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  scoreSlowerEvent(ar) {
  }
  /** @deprecated Use referenceTags instead. */
  tagReference(ar) {
    const cr = ["r", this.url];
    return ar && cr.push(ar), cr;
  }
  referenceTags() {
    return [["r", this.url]];
  }
  activeSubscriptions() {
    return this.subs.executedFilters();
  }
}, NDKRelaySet = class {
  constructor(lr, ar) {
    Wi(this, "relays");
    Wi(this, "debug");
    Wi(this, "ndk");
    this.relays = lr, this.ndk = ar, this.debug = ar.debug.extend("relayset");
  }
  /**
   * Adds a relay to this set.
   */
  addRelay(lr) {
    this.relays.add(lr);
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * If no connection to the relay is found in the pool it will temporarily
   * connect to it.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @returns NDKRelaySet
   */
  static fromRelayUrls(lr, ar) {
    const cr = /* @__PURE__ */ new Set();
    for (const ur of lr) {
      const fr = ar.pool.relays.get(ur);
      if (fr)
        cr.add(fr);
      else {
        const dr = new NDKRelay(ur);
        ar.pool.useTemporaryRelay(dr), cr.add(dr);
      }
    }
    return new NDKRelaySet(new Set(cr), ar);
  }
  /**
   * Publish an event to all relays in this set. Returns the number of relays that have received the event.
   * @param event
   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
   * @returns A set where the event was successfully published to
   */
  async publish(lr, ar) {
    const cr = /* @__PURE__ */ new Set(), ur = lr.isEphemeral(), fr = Array.from(this.relays).map((dr) => new Promise((hr) => {
      dr.publish(lr, ar).then(() => {
        cr.add(dr), hr();
      }).catch((gr) => {
        ur || this.debug("error publishing to relay", {
          relay: dr.url,
          err: gr
        }), hr();
      });
    }));
    if (await Promise.all(fr), cr.size === 0 && !ur)
      throw new Error("No relay was able to receive the event");
    return cr;
  }
  size() {
    return this.relays.size;
  }
};
function calculateRelaySetFromEvent(lr, ar) {
  var ur;
  const cr = /* @__PURE__ */ new Set();
  return (ur = lr.pool) == null || ur.relays.forEach((fr) => cr.add(fr)), new NDKRelaySet(cr, lr);
}
function getWriteRelaysFor(lr, ar) {
  var cr;
  if (lr.outboxTracker)
    return (cr = lr.outboxTracker.data.get(ar)) == null ? void 0 : cr.writeRelays;
}
function calculateRelaySetsFromFilter(lr, ar) {
  var fr, dr;
  const cr = /* @__PURE__ */ new Map(), ur = /* @__PURE__ */ new Set();
  if (ar.forEach((hr) => {
    hr.authors && hr.authors.forEach((gr) => ur.add(gr));
  }), ur.size > 0) {
    const hr = /* @__PURE__ */ new Map();
    for (const gr of ur) {
      const vr = getWriteRelaysFor(lr, gr);
      vr && vr.size > 0 ? (lr.debug(`Adding ${vr.size} relays for ${gr}`), vr.forEach((mr) => {
        const br = hr.get(mr) || [];
        br.push(gr), hr.set(mr, br);
      })) : (fr = lr.explicitRelayUrls) == null || fr.forEach((mr) => {
        const br = hr.get(mr) || [];
        br.push(gr), hr.set(mr, br);
      });
    }
    for (const gr of hr.keys())
      cr.set(gr, []);
    for (const gr of ar)
      if (gr.authors)
        for (const [vr, mr] of hr.entries())
          cr.set(vr, [...cr.get(vr), { ...gr, authors: mr }]);
      else
        for (const vr of hr.keys())
          cr.set(vr, [...cr.get(vr), gr]);
  } else
    (dr = lr.explicitRelayUrls) == null || dr.forEach((hr) => {
      cr.set(hr, ar);
    });
  return cr;
}
function calculateRelaySetsFromFilters(lr, ar) {
  return calculateRelaySetsFromFilter(lr, ar);
}
var DEFAULT_RELAYS = [
  "wss://nos.lol",
  "wss://relay.nostr.band",
  "wss://relay.f7z.io",
  "wss://relay.damus.io",
  "wss://nostr.mom",
  "wss://no.str.cr"
], Zap$1 = class extends lib$2.EventEmitter {
  constructor(cr) {
    var ur;
    super();
    Wi(this, "ndk");
    Wi(this, "zappedEvent");
    Wi(this, "zappedUser");
    this.ndk = cr.ndk, this.zappedEvent = cr.zappedEvent, this.zappedUser = cr.zappedUser || this.ndk.getUser({ hexpubkey: (ur = this.zappedEvent) == null ? void 0 : ur.pubkey });
  }
  async getZapEndpoint() {
    let cr, ur, fr, dr;
    if (this.zappedUser && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), cr = (this.zappedUser.profile || {}).lud06, ur = (this.zappedUser.profile || {}).lud16), ur && !ur.startsWith("LNURL")) {
      const [vr, mr] = ur.split("@");
      fr = `https://${mr}/.well-known/lnurlp/${vr}`;
    } else if (cr) {
      const { words: vr } = bech32$3.decode(cr, 1e3), mr = bech32$3.fromWords(vr);
      fr = new TextDecoder("utf-8").decode(mr);
    }
    if (!fr)
      throw new Error("No zap endpoint found");
    const gr = await (await fetch(fr)).json();
    return gr != null && gr.allowsNostr && (gr != null && gr.nostrPubkey || gr != null && gr.nostrPubKey) && (dr = gr.callback), dr;
  }
  /**
   * Generates a kind:9734 zap request and returns the payment request
   * @param amount amount to zap in millisatoshis
   * @param comment optional comment to include in the zap request
   * @param extraTags optional extra tags to include in the zap request
   * @param relays optional relays to ask zapper to publish the zap to
   * @returns the payment request
   */
  async createZapRequest(cr, ur, fr, dr, hr) {
    const gr = await this.generateZapRequest(cr, ur, fr, dr);
    if (!gr)
      return null;
    const { event: vr, zapEndpoint: mr } = gr;
    if (!vr)
      throw new Error("No zap request event found");
    return await vr.sign(hr), await this.getInvoice(vr, cr, mr);
  }
  async getInvoice(cr, ur, fr) {
    return (await (await fetch(
      `${fr}?` + new URLSearchParams({
        amount: ur.toString(),
        nostr: JSON.stringify(cr.rawEvent())
      })
    )).json()).pr;
  }
  async generateZapRequest(cr, ur, fr, dr, hr) {
    const gr = await this.getZapEndpoint();
    if (!gr)
      throw new Error("No zap endpoint found");
    if (!this.zappedEvent && !this.zappedUser)
      throw new Error("No zapped event or user found");
    const vr = nip57_exports$2.makeZapRequest({
      profile: this.zappedUser.pubkey,
      // set the event to null since nostr-tools doesn't support nip-33 zaps
      event: null,
      amount: cr,
      comment: ur || "",
      relays: dr != null ? dr : this.relays()
    });
    if (this.zappedEvent) {
      const br = this.zappedEvent.referenceTags();
      vr.tags.push(...br);
    }
    vr.tags.push(["lnurl", gr]);
    const mr = new NDKEvent(this.ndk, vr);
    return fr && (mr.tags = mr.tags.concat(fr)), { event: mr, zapEndpoint: gr };
  }
  /**
   * @returns the relays to use for the zap request
   */
  relays() {
    var ur, fr;
    let cr = [];
    return (fr = (ur = this.ndk) == null ? void 0 : ur.pool) != null && fr.relays && (cr = this.ndk.pool.urls()), cr.length || (cr = DEFAULT_RELAYS), cr;
  }
};
function mergeTags(lr, ar) {
  const cr = /* @__PURE__ */ new Map(), ur = (hr) => hr.join(","), fr = (hr, gr) => hr.every((vr, mr) => vr === gr[mr]), dr = (hr) => {
    for (let [gr, vr] of cr)
      if (fr(vr, hr) || fr(hr, vr)) {
        hr.length >= vr.length && cr.set(gr, hr);
        return;
      }
    cr.set(ur(hr), hr);
  };
  return lr.concat(ar).forEach(dr), Array.from(cr.values());
}
async function generateContentTags(lr, ar = []) {
  const cr = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g, ur = /#(\w+)/g;
  let fr = [];
  const dr = (hr) => {
    ar.find((gr) => gr[0] === hr[0] && gr[1] === hr[1]) || ar.push(hr);
  };
  return lr = lr.replace(cr, (hr) => {
    try {
      const gr = hr.split(/(@|nostr:)/)[2], { type: vr, data: mr } = nip19_exports$2.decode(gr);
      let br;
      switch (vr) {
        case "npub":
          br = ["p", mr];
          break;
        case "nprofile":
          br = ["p", mr.pubkey];
          break;
        case "note":
          fr.push(
            new Promise(async (yr) => {
              dr([
                "e",
                mr,
                await maybeGetEventRelayUrl(gr),
                "mention"
              ]), yr();
            })
          );
          break;
        case "nevent":
          fr.push(
            new Promise(async (yr) => {
              let { id: kr, relays: Tr, author: _r } = mr;
              (!Tr || Tr.length === 0) && (Tr = [await maybeGetEventRelayUrl(gr)]), dr(["e", kr, Tr[0], "mention"]), _r && dr(["p", _r]), yr();
            })
          );
          break;
        case "naddr":
          fr.push(
            new Promise(async (yr) => {
              var _r;
              const kr = [mr.kind, mr.pubkey, mr.identifier].join(":");
              let Tr = (_r = mr.relays) != null ? _r : [];
              Tr.length === 0 && (Tr = [await maybeGetEventRelayUrl(gr)]), dr(["a", kr, Tr[0], "mention"]), dr(["p", mr.pubkey]), yr();
            })
          );
          break;
        default:
          return hr;
      }
      return br && dr(br), `nostr:${gr}`;
    } catch (gr) {
      return hr;
    }
  }), await Promise.all(fr), lr = lr.replace(ur, (hr, gr) => {
    const vr = ["t", gr];
    return ar.find((mr) => mr[0] === vr[0] && mr[1] === vr[1]) || ar.push(vr), hr;
  }), { content: lr, tags: ar };
}
async function maybeGetEventRelayUrl(lr) {
  return "";
}
function isReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 1e4 && this.kind < 2e4;
}
function isEphemeral() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 2e4 && this.kind < 3e4;
}
function isParamReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}
var NDKKind = /* @__PURE__ */ ((lr) => (lr[lr.Metadata = 0] = "Metadata", lr[lr.Text = 1] = "Text", lr[lr.RecommendRelay = 2] = "RecommendRelay", lr[lr.Contacts = 3] = "Contacts", lr[lr.EncryptedDirectMessage = 4] = "EncryptedDirectMessage", lr[lr.EventDeletion = 5] = "EventDeletion", lr[lr.Repost = 6] = "Repost", lr[lr.Reaction = 7] = "Reaction", lr[lr.BadgeAward = 8] = "BadgeAward", lr[lr.GroupChat = 9] = "GroupChat", lr[lr.GroupNote = 11] = "GroupNote", lr[lr.GenericRepost = 16] = "GenericRepost", lr[lr.ChannelCreation = 40] = "ChannelCreation", lr[lr.ChannelMetadata = 41] = "ChannelMetadata", lr[lr.ChannelMessage = 42] = "ChannelMessage", lr[lr.ChannelHideMessage = 43] = "ChannelHideMessage", lr[lr.ChannelMuteUser = 44] = "ChannelMuteUser", lr[lr.Report = 1984] = "Report", lr[lr.Label = 1985] = "Label", lr[lr.DVMReqTextExtraction = 5e3] = "DVMReqTextExtraction", lr[lr.DVMReqTextSummarization = 5001] = "DVMReqTextSummarization", lr[lr.DVMReqTextTranslation = 5002] = "DVMReqTextTranslation", lr[lr.DVMReqTextGeneration = 5050] = "DVMReqTextGeneration", lr[lr.DVMReqImageGeneration = 5100] = "DVMReqImageGeneration", lr[lr.DVMReqDiscoveryNostrContent = 5300] = "DVMReqDiscoveryNostrContent", lr[lr.DVMReqDiscoveryNostrPeople = 5301] = "DVMReqDiscoveryNostrPeople", lr[lr.DVMReqTimestamping = 5900] = "DVMReqTimestamping", lr[lr.DVMJobFeedback = 7e3] = "DVMJobFeedback", lr[lr.MuteList = 1e4] = "MuteList", lr[lr.PinList = 10001] = "PinList", lr[lr.RelayList = 10002] = "RelayList", lr[lr.BookmarkList = 10003] = "BookmarkList", lr[lr.CommunityList = 10004] = "CommunityList", lr[lr.PublicChatList = 10005] = "PublicChatList", lr[lr.BlockRelayList = 10006] = "BlockRelayList", lr[lr.SearchRelayList = 10007] = "SearchRelayList", lr[lr.InterestList = 10015] = "InterestList", lr[lr.EmojiList = 10030] = "EmojiList", lr[lr.FollowSet = 3e4] = "FollowSet", lr[
  lr.CategorizedPeopleList = 3e4
  /* FollowSet */
] = "CategorizedPeopleList", lr[lr.CategorizedBookmarkList = 30001] = "CategorizedBookmarkList", lr[lr.RelaySet = 30002] = "RelaySet", lr[
  lr.CategorizedRelayList = 30002
  /* RelaySet */
] = "CategorizedRelayList", lr[lr.BookmarkSet = 30003] = "BookmarkSet", lr[lr.CurationSet = 30004] = "CurationSet", lr[lr.InterestSet = 30015] = "InterestSet", lr[
  lr.InterestsList = 30015
  /* InterestSet */
] = "InterestsList", lr[lr.EmojiSet = 30030] = "EmojiSet", lr[lr.HighlightSet = 39802] = "HighlightSet", lr[
  lr.CategorizedHighlightList = 39802
  /* HighlightSet */
] = "CategorizedHighlightList", lr[lr.ZapRequest = 9734] = "ZapRequest", lr[lr.Zap = 9735] = "Zap", lr[lr.Highlight = 9802] = "Highlight", lr[lr.ClientAuth = 22242] = "ClientAuth", lr[lr.NostrConnect = 24133] = "NostrConnect", lr[lr.ProfileBadge = 30008] = "ProfileBadge", lr[lr.BadgeDefinition = 30009] = "BadgeDefinition", lr[lr.MarketStall = 30017] = "MarketStall", lr[lr.MarketProduct = 30018] = "MarketProduct", lr[lr.Article = 30023] = "Article", lr[lr.AppSpecificData = 30078] = "AppSpecificData", lr[lr.Classified = 30402] = "Classified", lr[lr.AppRecommendation = 31989] = "AppRecommendation", lr[lr.AppHandler = 31990] = "AppHandler", lr))(NDKKind || {});
async function encrypt$2(lr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  if (ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), !lr) {
    const cr = this.getMatchingTags("p");
    if (cr.length !== 1)
      throw new Error(
        "No recipient could be determined and no explicit recipient was provided"
      );
    lr = this.ndk.getUser({ hexpubkey: cr[0][1] });
  }
  this.content = await (ar == null ? void 0 : ar.encrypt(lr, this.content));
}
async function decrypt$2(lr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), lr || (lr = this.author), this.content = await (ar == null ? void 0 : ar.decrypt(lr, this.content));
}
function encode$2() {
  return this.isParamReplaceable() ? nip19_exports$2.naddrEncode({
    kind: this.kind,
    pubkey: this.pubkey,
    identifier: this.replaceableDTag(),
    relays: this.relay ? [this.relay.url] : []
  }) : this.relay ? nip19_exports$2.neventEncode({
    id: this.tagId(),
    relays: [this.relay.url],
    author: this.pubkey
  }) : nip19_exports$2.noteEncode(this.tagId());
}
async function repost(lr = !0, ar) {
  if (!ar && lr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner(), ar = this.ndk.signer;
  }
  const cr = new NDKEvent(this.ndk, {
    kind: getKind(this),
    content: ""
  });
  return cr.tag(this), cr.kind === 16 && cr.tags.push(["k", `${this.kind}`]), ar && await cr.sign(ar), lr && await cr.publish(), cr;
}
function getKind(lr) {
  return lr.kind === 1 ? 6 : 16;
}
var NDKEvent = class extends lib$2.EventEmitter {
  constructor(ar, cr) {
    super();
    Wi(this, "ndk");
    Wi(this, "created_at");
    Wi(this, "content", "");
    Wi(this, "tags", []);
    Wi(this, "kind");
    Wi(this, "id", "");
    Wi(this, "sig");
    Wi(this, "pubkey", "");
    Wi(this, "_author");
    /**
     * The relay that this event was first received from.
     */
    Wi(this, "relay");
    Wi(this, "isReplaceable", isReplaceable.bind(this));
    Wi(this, "isEphemeral", isEphemeral.bind(this));
    Wi(this, "isParamReplaceable", isParamReplaceable.bind(this));
    /**
     * Encodes a bech32 id.
     *
     * @returns {string} - Encoded naddr, note or nevent.
     */
    Wi(this, "encode", encode$2.bind(this));
    Wi(this, "encrypt", encrypt$2.bind(this));
    Wi(this, "decrypt", decrypt$2.bind(this));
    /**
     * NIP-18 reposting event.
     *
     * @param publish Whether to publish the reposted event automatically
     * @param signer The signer to use for signing the reposted event
     * @returns The reposted event
     *
     * @function
     */
    Wi(this, "repost", repost.bind(this));
    this.ndk = ar, this.created_at = cr == null ? void 0 : cr.created_at, this.content = (cr == null ? void 0 : cr.content) || "", this.tags = (cr == null ? void 0 : cr.tags) || [], this.id = (cr == null ? void 0 : cr.id) || "", this.sig = cr == null ? void 0 : cr.sig, this.pubkey = (cr == null ? void 0 : cr.pubkey) || "", this.kind = cr == null ? void 0 : cr.kind;
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(ar) {
    this.pubkey = ar.hexpubkey, this._author = void 0;
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    if (this._author)
      return this._author;
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = this.ndk.getUser({ hexpubkey: this.pubkey });
    return this._author = ar, ar;
  }
  tag(ar, cr) {
    const ur = (ar == null ? void 0 : ar.pubkey) === this.pubkey, fr = ar.referenceTags(cr, ur);
    if (this.tags = mergeTags(this.tags, fr), ar instanceof NDKEvent)
      for (const dr of ar.getMatchingTags("p"))
        dr[1] !== this.pubkey && (this.tags.find((hr) => hr[0] === "p" && hr[1] === dr[1]) || this.tags.push(["p", dr[1]]));
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(ar) {
    var dr, hr;
    if (!ar && this.pubkey === "") {
      const gr = await ((hr = (dr = this.ndk) == null ? void 0 : dr.signer) == null ? void 0 : hr.user());
      this.pubkey = (gr == null ? void 0 : gr.hexpubkey) || "";
    }
    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));
    const cr = this.rawEvent(), { content: ur, tags: fr } = await this.generateTags();
    cr.content = ur || "", cr.tags = fr;
    try {
      this.id = getEventHash$2(cr);
    } catch (gr) {
    }
    return this.id && (cr.id = this.id), this.sig && (cr.sig = this.sig), cr;
  }
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(ar) {
    return this.tags.filter((cr) => cr[0] === ar);
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(ar) {
    const cr = this.getMatchingTags(ar);
    if (cr.length !== 0)
      return cr[0][1];
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name to search for and remove
   * @returns {void}
   */
  removeTag(ar) {
    this.tags = this.tags.filter((cr) => cr[0] !== ar);
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(ar) {
    var ur;
    ar ? this.author = await ar.user() : ((ur = this.ndk) == null || ur.assertSigner(), ar = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));
    const cr = await this.toNostrEvent();
    return this.sig = await ar.sign(cr), this.sig;
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(ar, cr) {
    if (this.sig || await this.sign(), !this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    return ar || (ar = this.ndk.devWriteRelaySet || calculateRelaySetFromEvent(this.ndk)), ar.publish(this, cr);
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  async generateTags() {
    var fr, dr, hr;
    let ar = [];
    const cr = await generateContentTags(this.content, this.tags), ur = cr.content;
    if (ar = cr.tags, this.kind && this.isParamReplaceable() && !this.getMatchingTags("d")[0]) {
      const vr = this.tagValue("title");
      let br = [...Array(vr ? 6 : 16)].map(() => Math.random().toString(36)[2]).join("");
      vr && vr.length > 0 && (br = vr.replace(/[^a-z0-9]+/gi, "-").replace(/^-|-$/g, "") + "-" + br), ar.push(["d", br]);
    }
    if (((fr = this.ndk) != null && fr.clientName || (dr = this.ndk) != null && dr.clientNip89) && !this.tagValue("client")) {
      const gr = ["client", (hr = this.ndk.clientName) != null ? hr : ""];
      this.ndk.clientNip89 && gr.push(this.ndk.clientNip89), ar.push(gr);
    }
    return { content: ur || "", tags: ar };
  }
  muted() {
    var fr, dr;
    const ar = (fr = this.ndk) == null ? void 0 : fr.mutedIds.get(this.pubkey);
    if (ar && ar === "p")
      return "author";
    const cr = this.tagReference(), ur = (dr = this.ndk) == null ? void 0 : dr.mutedIds.get(cr[1]);
    return ur && ur === cr[0] ? "event" : null;
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const ar = this.getMatchingTags("d")[0];
      return ar ? ar[1] : "";
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Provides a deduplication key for the event.
   *
   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
   * For all other kinds this will be the event id
   */
  deduplicationKey() {
    return this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4 ? `${this.kind}:${this.pubkey}` : this.tagId();
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    return this.isParamReplaceable() ? this.tagAddress() : this.id;
  }
  /**
   * Returns the "reference" value ("<kind>:<author-pubkey>:<d-tag>") for this replaceable event.
   * @returns {string} The id
   */
  tagAddress() {
    if (!this.isParamReplaceable())
      throw new Error("This must only be called on replaceable events");
    const ar = this.replaceableDTag();
    return `${this.kind}:${this.pubkey}:${ar}`;
  }
  /**
   * Get the tag that can be used to reference this event from another event.
   *
   * Consider using referenceTags() instead (unless you have a good reason to use this)
   *
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference(ar) {
    let cr;
    return this.isParamReplaceable() ? cr = ["a", this.tagAddress()] : cr = ["e", this.tagId()], this.relay ? cr.push(this.relay.url) : cr.push(""), ar && cr.push(ar), cr;
  }
  /**
   * Get the tags that can be used to reference this event from another event
   * @param marker The marker to use in the tag
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.referenceTags(); // [["e", "parent-id"]]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  referenceTags(ar, cr) {
    var fr;
    let ur = [];
    return this.isParamReplaceable() ? ur = [
      ["a", this.tagAddress()],
      ["e", this.id]
    ] : ur = [["e", this.id]], (fr = this.relay) != null && fr.url ? ur = ur.map((dr) => {
      var hr;
      return dr.push((hr = this.relay) == null ? void 0 : hr.url), dr;
    }) : ar && (ur = ur.map((dr) => (dr.push(""), dr))), ar && ur.forEach((dr) => dr.push(ar)), cr || ur.push(...this.author.referenceTags()), ur;
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    return this.isParamReplaceable() ? { "#a": [this.tagId()] } : { "#e": [this.tagId()] };
  }
  /**
   * Create a zap request for an existing event
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param recipient The zap recipient (optional for events)
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(ar, cr, ur, fr, dr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    dr || this.ndk.assertSigner();
    const hr = new Zap$1({
      ndk: this.ndk,
      zappedEvent: this,
      zappedUser: fr
    }), gr = Array.from(this.ndk.pool.relays.keys());
    return await hr.createZapRequest(
      ar,
      cr,
      ur,
      gr,
      dr
    );
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @returns The deletion event
   */
  async delete(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const cr = new NDKEvent(this.ndk, {
      kind: 5,
      content: ar || ""
    });
    return cr.tag(this), await cr.publish(), cr;
  }
  /**
   * React to an existing event
   *
   * @param content The content of the reaction
   */
  async react(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const cr = new NDKEvent(this.ndk, {
      kind: 7,
      content: ar
    });
    return cr.tag(this), await cr.publish(), cr;
  }
}, READ_MARKER = "read", WRITE_MARKER = "write", NDKRelayList = class extends NDKEvent {
  constructor(lr, ar) {
    var cr;
    super(lr, ar), (cr = this.kind) != null || (this.kind = 10002);
  }
  static from(lr) {
    return new NDKRelayList(lr.ndk, lr.rawEvent());
  }
  get readRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2] || lr[2] && lr[2] === READ_MARKER).map((lr) => lr[1]);
  }
  set readRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar, READ_MARKER]);
  }
  get writeRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2] || lr[2] && lr[2] === WRITE_MARKER).map((lr) => lr[1]);
  }
  set writeRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar, WRITE_MARKER]);
  }
  get bothRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2]).map((lr) => lr[1]);
  }
  set bothRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar]);
  }
  get relays() {
    return this.getMatchingTags("r").map((lr) => lr[1]);
  }
}, defaultOpts = {
  closeOnEose: !1,
  cacheUsage: "CACHE_FIRST",
  groupable: !0,
  groupableDelay: 100
}, NDKSubscription = class extends lib$2.EventEmitter {
  constructor(ar, cr, ur, fr, dr) {
    var hr;
    super();
    Wi(this, "subId");
    Wi(this, "filters");
    Wi(this, "opts");
    Wi(this, "pool");
    /**
     * Tracks the filters as they are executed on each relay
     */
    Wi(this, "relayFilters");
    Wi(this, "relaySet");
    Wi(this, "ndk");
    Wi(this, "debug");
    Wi(this, "eoseDebug");
    /**
     * Events that have been seen by the subscription, with the time they were first seen.
     */
    Wi(this, "eventFirstSeen", /* @__PURE__ */ new Map());
    /**
     * Relays that have sent an EOSE.
     */
    Wi(this, "eosesSeen", /* @__PURE__ */ new Set());
    /**
     * Events that have been seen by the subscription per relay.
     */
    Wi(this, "eventsPerRelay", /* @__PURE__ */ new Map());
    /**
     * The time the last event was received by the subscription.
     * This is used to calculate when EOSE should be emitted.
     */
    Wi(this, "lastEventReceivedAt");
    Wi(this, "internalId");
    // EOSE handling
    Wi(this, "eoseTimeout");
    if (this.ndk = ar, this.pool = (ur == null ? void 0 : ur.pool) || ar.pool, this.opts = { ...defaultOpts, ...ur || {} }, this.filters = cr instanceof Array ? cr : [cr], this.subId = dr || (ur == null ? void 0 : ur.subId), this.internalId = Math.random().toString(36).substring(7), this.relaySet = fr, this.debug = ar.debug.extend(`subscription[${(hr = ur == null ? void 0 : ur.subId) != null ? hr : this.internalId}]`), this.eoseDebug = this.debug.extend("eose"), this.opts.closeOnEose || this.debug(
      "Creating a permanent subscription",
      this.opts,
      JSON.stringify(this.filters)
    ), this.opts.cacheUsage === "ONLY_CACHE" && !this.opts.closeOnEose)
      throw new Error("Cannot use cache-only options with a persistent subscription");
  }
  /**
   * Provides access to the first filter of the subscription for
   * backwards compatibility.
   */
  get filter() {
    return this.filters[0];
  }
  isGroupable() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.groupable) || !1;
  }
  shouldQueryCache() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_RELAY";
  }
  shouldQueryRelays() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_CACHE";
  }
  shouldWaitForCache() {
    var ar;
    return (
      // Must want to close on EOSE; subscriptions
      // that want to receive further updates must
      // always hit the relay
      this.opts.closeOnEose && // Cache adapter must claim to be fast
      !!((ar = this.ndk.cacheAdapter) != null && ar.locking) && // If explicitly told to run in parallel, then
      // we should not wait for the cache
      this.opts.cacheUsage !== "PARALLEL"
    );
  }
  /**
   * Start the subscription. This is the main method that should be called
   * after creating a subscription.
   */
  async start() {
    let ar;
    if (this.shouldQueryCache() && (ar = this.startWithCache(), this.shouldWaitForCache() && (await ar, queryFullyFilled(this)))) {
      this.emit("eose", this);
      return;
    }
    this.shouldQueryRelays() ? this.startWithRelays() : this.emit("eose", this);
  }
  stop() {
    this.emit("close", this), this.removeAllListeners();
  }
  /**
   * @returns Whether the subscription has an authors filter.
   */
  hasAuthorsFilter() {
    return this.filters.some((ar) => {
      var cr;
      return (cr = ar.authors) == null ? void 0 : cr.length;
    });
  }
  async startWithCache() {
    var ar;
    if ((ar = this.ndk.cacheAdapter) != null && ar.query) {
      const cr = this.ndk.cacheAdapter.query(this);
      this.ndk.cacheAdapter.locking && await cr;
    }
  }
  /**
   * Send REQ to relays
   */
  startWithRelays() {
    if (!this.relaySet)
      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters);
    else {
      this.relayFilters = /* @__PURE__ */ new Map();
      for (const ar of this.relaySet.relays)
        this.relayFilters.set(ar.url, this.filters);
    }
    for (const [ar, cr] of this.relayFilters)
      this.pool.getRelay(ar).subscribe(this, cr);
  }
  // EVENT handling
  /**
   * Called when an event is received from a relay or the cache
   * @param event
   * @param relay
   * @param fromCache Whether the event was received from the cache
   */
  eventReceived(ar, cr, ur = !1) {
    if (cr && (ar.relay = cr), cr || (cr = ar.relay), !ur && cr) {
      let fr = this.eventsPerRelay.get(cr);
      if (fr || (fr = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(cr, fr)), fr.add(ar.id), this.eventFirstSeen.has(ar.id)) {
        const hr = Date.now() - (this.eventFirstSeen.get(ar.id) || 0);
        cr.scoreSlowerEvent(hr), this.emit("event:dup", ar, cr, hr, this);
        return;
      }
      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(ar, this.filters[0], cr), this.eventFirstSeen.set(ar.id, Date.now());
    } else
      this.eventFirstSeen.set(ar.id, 0);
    ar.ndk || (ar.ndk = this.ndk), this.emit("event", ar, cr, this), this.lastEventReceivedAt = Date.now();
  }
  eoseReceived(ar) {
    var dr, hr, gr;
    this.eosesSeen.add(ar), this.eoseDebug(`received from ${ar.url}`);
    let cr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;
    const ur = this.eosesSeen.size === ((dr = this.relayFilters) == null ? void 0 : dr.size);
    if (queryFullyFilled(this))
      this.emit("eose"), this.eoseDebug("Query fully filled"), (hr = this.opts) != null && hr.closeOnEose && this.stop();
    else if (ur)
      this.emit("eose"), this.eoseDebug("All EOSEs seen"), (gr = this.opts) != null && gr.closeOnEose && this.stop();
    else {
      let vr = 1e3;
      const mr = this.eosesSeen.size / this.relayFilters.size;
      if (this.eosesSeen.size >= 2 && mr >= 0.5) {
        vr = vr * (1 - mr), this.eoseTimeout && clearTimeout(this.eoseTimeout);
        const br = () => {
          var yr;
          cr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0, cr !== void 0 && cr < 20 ? this.eoseTimeout = setTimeout(br, vr) : (this.emit("eose"), (yr = this.opts) != null && yr.closeOnEose && this.stop());
        };
        this.eoseTimeout = setTimeout(br, vr);
      }
    }
  }
};
async function follows(lr, ar, cr = 3) {
  if (!this.ndk)
    throw new Error("NDK not set");
  const ur = Array.from(
    await this.ndk.fetchEvents(
      {
        kinds: [cr],
        authors: [this.pubkey]
      },
      lr || { groupable: !1 }
    )
  )[0];
  if (ur) {
    const fr = /* @__PURE__ */ new Set();
    return ur.tags.forEach((dr) => {
      var hr, gr;
      if (dr[0] === "p")
        try {
          fr.add(dr[1]), ar && ((gr = (hr = this.ndk) == null ? void 0 : hr.outboxTracker) == null || gr.trackUsers([dr[1]]));
        } catch (vr) {
        }
    }), [...fr].reduce((dr, hr) => {
      const gr = new NDKUser({ pubkey: hr });
      return gr.ndk = this.ndk, dr.add(gr), dr;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}
function profileFromEvent(lr) {
  const ar = {}, cr = JSON.parse(lr.content);
  return Object.keys(cr).forEach((ur) => {
    switch (ur) {
      case "name":
        ar.name = cr.name;
        break;
      case "display_name":
        ar.displayName = cr.display_name;
        break;
      case "image":
      case "picture":
        ar.image = cr.image || cr.picture;
        break;
      case "banner":
        ar.banner = cr.banner;
        break;
      case "bio":
        ar.bio = cr.bio;
        break;
      case "nip05":
        ar.nip05 = cr.nip05;
        break;
      case "lud06":
        ar.lud06 = cr.lud06;
        break;
      case "lud16":
        ar.lud16 = cr.lud16;
        break;
      case "about":
        ar.about = cr.about;
        break;
      case "zapService":
        ar.zapService = cr.zapService;
        break;
      case "website":
        ar.website = cr.website;
        break;
      default:
        ar[ur] = cr[ur];
        break;
    }
  }), ar;
}
function serializeProfile(lr) {
  const ar = {};
  for (const [cr, ur] of Object.entries(lr))
    switch (cr) {
      case "username":
      case "name":
        ar.name = ur;
        break;
      case "displayName":
        ar.display_name = ur;
        break;
      case "image":
      case "picture":
        ar.picture = ur;
        break;
      case "bio":
      case "about":
        ar.about = ur;
        break;
      default:
        ar[cr] = ur;
        break;
    }
  return JSON.stringify(ar);
}
var NDKList = class extends NDKEvent {
  constructor(ar, cr) {
    var ur;
    super(ar, cr);
    Wi(this, "_encryptedTags");
    /**
     * Stores the number of bytes the content was before decryption
     * to expire the cache when the content changes.
     */
    Wi(this, "encryptedTagsLength");
    (ur = this.kind) != null || (this.kind = 30001);
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ar) {
    return new NDKList(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns the title of the list. Falls back on fetching the name tag value.
   */
  get title() {
    const ar = this.tagValue("title") || this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the title of the list.
   */
  set title(ar) {
    if (this.removeTag("title"), this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Title cannot be empty");
  }
  /**
   * Returns the name of the list.
   * @deprecated Please use "title" instead.
   */
  get name() {
    const ar = this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the name of the list.
   * @deprecated Please use "title" instead. This method will use the `title` tag instead.
   */
  set name(ar) {
    if (this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Name cannot be empty");
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(ar) {
    ar ? this.tags.push(["description", ar]) : this.removeTag("description");
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(ar = !0) {
    if (ar && this.isEncryptedTagsCacheValid())
      return this._encryptedTags;
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    const cr = await this.ndk.signer.user();
    try {
      if (this.content.length > 0)
        try {
          const ur = await this.ndk.signer.decrypt(cr, this.content), fr = JSON.parse(ur);
          return fr && fr[0] ? (this.encryptedTagsLength = this.content.length, this._encryptedTags = fr) : (this.encryptedTagsLength = this.content.length, this._encryptedTags = []);
        } catch (ur) {
          console.log(`error decrypting ${this.content}`);
        }
    } catch (ur) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(ar) {
    return !0;
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((ar) => ![
      "d",
      "L",
      "l",
      "title",
      "name",
      "description",
      "summary",
      "image",
      "thumb",
      "alt",
      "expiration",
      "subject"
    ].includes(ar[0]));
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   */
  async addItem(ar, cr = void 0, ur = !1) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    let fr;
    if (ar instanceof NDKEvent)
      fr = ar.referenceTags();
    else if (ar instanceof NDKUser)
      fr = ar.referenceTags();
    else if (ar instanceof NDKRelay)
      fr = ar.referenceTags();
    else if (Array.isArray(ar))
      fr = [ar];
    else
      throw new Error("Invalid object type");
    if (cr && fr[0].push(cr), ur) {
      const dr = await this.ndk.signer.user(), hr = await this.encryptedTags();
      hr.push(...fr), this._encryptedTags = hr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(hr), await this.encrypt(dr);
    } else
      this.tags.push(...fr);
    this.created_at = Math.floor(Date.now() / 1e3), this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(ar, cr) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    if (cr) {
      const ur = await this.ndk.signer.user(), fr = await this.encryptedTags();
      fr.splice(ar, 1), this._encryptedTags = fr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(fr), await this.encrypt(ur);
    } else
      this.tags.splice(ar, 1);
    return this.created_at = Math.floor(Date.now() / 1e3), this.emit("change"), this;
  }
}, lists_default = NDKList;
async function pin(lr, ar, cr) {
  if (!this.ndk)
    throw new Error("No NDK instance found");
  if (this.ndk.assertSigner(), !ar) {
    const fr = await this.ndk.fetchEvents(
      { kinds: [10001], authors: [this.pubkey] },
      {
        cacheUsage: "ONLY_RELAY"
        /* ONLY_RELAY */
      }
    );
    fr.size > 0 ? ar = lists_default.from(Array.from(fr)[0]) : ar = new NDKEvent(this.ndk, {
      kind: 10001
    });
  }
  return ar.tag(lr), cr && await ar.publish(), ar;
}
var NDKUser = class {
  constructor(lr) {
    Wi(this, "ndk");
    Wi(this, "profile");
    Wi(this, "_npub");
    Wi(this, "_pubkey");
    Wi(this, "relayUrls", []);
    /**
     * Returns a set of users that this user follows.
     */
    Wi(this, "follows", follows.bind(this));
    /**
     * Pins a user or an event
     */
    Wi(this, "pin", pin.bind(this));
    lr.npub && (this._npub = lr.npub), lr.hexpubkey && (this._pubkey = lr.hexpubkey), lr.pubkey && (this._pubkey = lr.pubkey), lr.relayUrls && (this.relayUrls = lr.relayUrls);
  }
  get npub() {
    if (!this._npub) {
      if (!this._pubkey)
        throw new Error("hexpubkey not set");
      this._npub = nip19_exports$2.npubEncode(this.pubkey);
    }
    return this._npub;
  }
  set npub(lr) {
    this._npub = lr;
  }
  /**
   * Get the user's hexpubkey
   * @returns {Hexpubkey} The user's hexpubkey
   *
   * @deprecated Use `pubkey` instead
   */
  get hexpubkey() {
    return this.pubkey;
  }
  /**
   * Set the user's hexpubkey
   * @param pubkey {Hexpubkey} The user's hexpubkey
   * @deprecated Use `pubkey` instead
   */
  set hexpubkey(lr) {
    this._pubkey = lr;
  }
  /**
   * Get the user's pubkey
   * @returns {string} The user's pubkey
   */
  get pubkey() {
    if (!this._pubkey) {
      if (!this._npub)
        throw new Error("npub not set");
      this._pubkey = nip19_exports$2.decode(this.npub).data;
    }
    return this._pubkey;
  }
  /**
   * Set the user's pubkey
   * @param pubkey {string} The user's pubkey
   */
  set pubkey(lr) {
    this._pubkey = lr;
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(lr) {
    const ar = await nip05_exports$2.queryProfile(lr);
    if (ar)
      return new NDKUser({
        pubkey: ar.pubkey,
        relayUrls: ar.relays
      });
  }
  /**
   * Fetch a user's profile
   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
   * @returns User Profile
   */
  async fetchProfile(lr) {
    if (!this.ndk)
      throw new Error("NDK not set");
    this.profile || (this.profile = {});
    let ar = null;
    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && (lr == null ? void 0 : lr.cacheUsage) !== "ONLY_RELAY") {
      const ur = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);
      if (ur)
        return this.profile = ur, ur;
    }
    !lr && // if no options have been set
    this.ndk.cacheAdapter && // and we have a cache
    this.ndk.cacheAdapter.locking && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      {
        cacheUsage: "ONLY_CACHE",
        closeOnEose: !0,
        groupable: !1
      }
    ), lr = {
      cacheUsage: "ONLY_RELAY",
      closeOnEose: !0,
      groupable: !0,
      groupableDelay: 250
    }), (!ar || ar.size === 0) && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      lr
    ));
    const cr = Array.from(ar).sort(
      (ur, fr) => ur.created_at - fr.created_at
    );
    return cr.length === 0 ? null : (this.profile = profileFromEvent(cr[0]), this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile && this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile), this.profile);
  }
  /**
   * Returns a set of relay list events for a user.
   * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.
   */
  async relayList() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const lr = this.ndk.outboxPool || this.ndk.pool, ar = /* @__PURE__ */ new Set();
    for (const fr of lr.relays.values())
      ar.add(fr);
    const cr = new NDKRelaySet(ar, this.ndk), ur = await this.ndk.fetchEvent(
      {
        kinds: [10002],
        authors: [this.pubkey]
      },
      {
        closeOnEose: !0,
        pool: lr,
        groupable: !0,
        subId: `relay-list-${this.pubkey.slice(0, 6)}`
      },
      cr
    );
    return ur ? NDKRelayList.from(ur) : await this.relayListFromKind3();
  }
  async relayListFromKind3() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const lr = await this.ndk.fetchEvent({
      kinds: [3],
      authors: [this.pubkey]
    });
    if (lr)
      try {
        const ar = JSON.parse(lr.content), cr = new NDKRelayList(this.ndk), ur = /* @__PURE__ */ new Set(), fr = /* @__PURE__ */ new Set();
        for (const [dr, hr] of Object.entries(ar))
          if (!hr)
            ur.add(dr), fr.add(dr);
          else {
            const gr = hr;
            gr.write && fr.add(dr), gr.read && ur.add(dr);
          }
        return cr.readRelayUrls = Array.from(ur), cr.writeRelayUrls = Array.from(fr), cr;
      } catch (ar) {
      }
  }
  /** @deprecated Use referenceTags instead. */
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.pubkey];
  }
  /**
   * Get the tags that can be used to reference this user in an event
   * @returns {NDKTag[]} an array of NDKTag
   */
  referenceTags(lr) {
    const ar = [["p", this.pubkey]];
    return lr && ar[0].push("", lr), ar;
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (!this.profile)
      throw new Error("No profile available");
    this.ndk.assertSigner(), await new NDKEvent(this.ndk, {
      kind: 0,
      content: serializeProfile(this.profile)
    }).publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(lr, ar, cr = 3) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (this.ndk.assertSigner(), ar || (ar = await this.follows(void 0, void 0, cr)), ar.has(lr))
      return !1;
    ar.add(lr);
    const ur = new NDKEvent(this.ndk, { kind: cr });
    for (const fr of ar)
      ur.tag(fr);
    return await ur.publish(), !0;
  }
  /**
   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
   *
   * @param nip05Id The NIP-05 string to validate
   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
   * False if the NIP-05 is found but doesn't match this user's pubkey,
   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
   */
  async validateNip05(lr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = await nip05_exports$2.queryProfile(lr);
    return ar === null ? null : ar.pubkey === this.pubkey;
  }
  /**
   * Zap a user
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(lr, ar, cr, ur) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    ur || this.ndk.assertSigner();
    const fr = new Zap$1({
      ndk: this.ndk,
      zappedUser: this
    }), dr = Array.from(this.ndk.pool.relays.keys());
    return await fr.createZapRequest(
      lr,
      ar,
      cr,
      dr,
      ur
    );
  }
}, NDKRepost = class extends NDKEvent {
  constructor(ar, cr) {
    super(ar, cr);
    Wi(this, "_repostedEvents");
  }
  static from(ar) {
    return new NDKRepost(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns all reposted events by the current event.
   *
   * @param klass Optional class to convert the events to.
   * @returns
   */
  async repostedEvents(ar, cr) {
    const ur = [];
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (this._repostedEvents !== void 0)
      return this._repostedEvents;
    for (const fr of this.repostedEventIds()) {
      const dr = filterForId(fr), hr = await this.ndk.fetchEvent(dr, cr);
      hr && ur.push(ar ? ar.from(hr) : hr);
    }
    return ur;
  }
  /**
   * Returns the reposted event IDs.
   */
  repostedEventIds() {
    return this.tags.filter((ar) => ar[0] === "e" || ar[0] === "a").map((ar) => ar[1]);
  }
};
function filterForId(lr) {
  if (lr.match(/:/)) {
    const [ar, cr, ur] = lr.split(":");
    return {
      kinds: [parseInt(ar)],
      authors: [cr],
      "#d": [ur]
    };
  } else
    return { ids: [lr] };
}
var NDKNip07Signer = class {
  /**
   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available
   */
  constructor(lr = 1e3) {
    Wi(this, "_userPromise");
    Wi(this, "nip04Queue", []);
    Wi(this, "nip04Processing", !1);
    Wi(this, "debug");
    Wi(this, "waitTimeout");
    this.debug = _debug("ndk:nip07"), this.waitTimeout = lr;
  }
  async blockUntilReady() {
    await this.waitForExtension();
    const lr = await window.nostr.getPublicKey();
    if (!lr)
      throw new Error("User rejected access");
    return new NDKUser({ hexpubkey: lr });
  }
  /**
   * Getter for the user property.
   * @returns The NDKUser instance.
   */
  async user() {
    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;
  }
  /**
   * Signs the given Nostr event.
   * @param event - The Nostr event to be signed.
   * @returns The signature of the signed event.
   * @throws Error if the NIP-07 is not available on the window object.
   */
  async sign(lr) {
    return await this.waitForExtension(), (await window.nostr.signEvent(lr)).sig;
  }
  async relays() {
    var cr, ur;
    await this.waitForExtension();
    const lr = await ((ur = (cr = window.nostr).getRelays) == null ? void 0 : ur.call(cr)) || {}, ar = [];
    for (const fr of Object.keys(lr))
      lr[fr].read && lr[fr].write && ar.push(fr);
    return ar.map((fr) => new NDKRelay(fr));
  }
  async encrypt(lr, ar) {
    await this.waitForExtension();
    const cr = lr.hexpubkey;
    return this.queueNip04("encrypt", cr, ar);
  }
  async decrypt(lr, ar) {
    await this.waitForExtension();
    const cr = lr.hexpubkey;
    return this.queueNip04("decrypt", cr, ar);
  }
  async queueNip04(lr, ar, cr) {
    return new Promise((ur, fr) => {
      this.nip04Queue.push({
        type: lr,
        counterpartyHexpubkey: ar,
        value: cr,
        resolve: ur,
        reject: fr
      }), this.nip04Processing || this.processNip04Queue();
    });
  }
  async processNip04Queue(lr, ar = 0) {
    if (!lr && this.nip04Queue.length === 0) {
      this.nip04Processing = !1;
      return;
    }
    this.nip04Processing = !0;
    const { type: cr, counterpartyHexpubkey: ur, value: fr, resolve: dr, reject: hr } = lr || this.nip04Queue.shift();
    this.debug("Processing encryption queue item", {
      type: cr,
      counterpartyHexpubkey: ur,
      value: fr
    });
    try {
      let gr;
      cr === "encrypt" ? gr = await window.nostr.nip04.encrypt(ur, fr) : gr = await window.nostr.nip04.decrypt(ur, fr), dr(gr);
    } catch (gr) {
      if (gr.message && gr.message.includes("call already executing") && ar < 5) {
        this.debug("Retrying encryption queue item", {
          type: cr,
          counterpartyHexpubkey: ur,
          value: fr,
          retries: ar
        }), setTimeout(() => {
          this.processNip04Queue(lr, ar + 1);
        }, 50 * ar);
        return;
      }
      hr(gr);
    }
    this.processNip04Queue();
  }
  waitForExtension() {
    return new Promise((lr, ar) => {
      if (window.nostr) {
        lr();
        return;
      }
      let cr;
      const ur = setInterval(() => {
        window.nostr && (clearTimeout(cr), clearInterval(ur), lr());
      }, 100);
      cr = setTimeout(() => {
        clearInterval(ur), ar(new Error("NIP-07 extension not available"));
      }, this.waitTimeout);
    });
  }
}, NDKPrivateKeySigner = class {
  constructor(lr) {
    Wi(this, "_user");
    Wi(this, "privateKey");
    lr && (this.privateKey = lr, this._user = new NDKUser({
      hexpubkey: getPublicKey$1(this.privateKey)
    }));
  }
  static generate() {
    const lr = generatePrivateKey();
    return new NDKPrivateKeySigner(lr);
  }
  async blockUntilReady() {
    if (!this._user)
      throw new Error("NDKUser not initialized");
    return this._user;
  }
  async user() {
    return await this.blockUntilReady(), this._user;
  }
  async sign(lr) {
    if (!this.privateKey)
      throw Error("Attempted to sign without a private key");
    return getSignature$1(lr, this.privateKey);
  }
  async encrypt(lr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to encrypt without a private key");
    const cr = lr.hexpubkey;
    return await nip04_exports$2.encrypt(this.privateKey, cr, ar);
  }
  async decrypt(lr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to decrypt without a private key");
    const cr = lr.hexpubkey;
    return await nip04_exports$2.decrypt(this.privateKey, cr, ar);
  }
};
function dedup(lr, ar) {
  return lr.created_at > ar.created_at ? lr : ar;
}
var OutboxItem = class {
  constructor(lr) {
    /**
     * Type of item
     */
    Wi(this, "type");
    /**
     * The relay URLs that are of interest to this item
     */
    Wi(this, "relayUrlScores");
    Wi(this, "readRelays");
    Wi(this, "writeRelays");
    this.type = lr, this.relayUrlScores = /* @__PURE__ */ new Map(), this.readRelays = /* @__PURE__ */ new Set(), this.writeRelays = /* @__PURE__ */ new Set();
  }
}, OutboxTracker = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    Wi(this, "data");
    Wi(this, "ndk");
    Wi(this, "debug");
    this.ndk = ar, this.debug = ar.debug.extend("outbox-tracker"), this.data = new dist$9.LRUCache({
      maxSize: 1e5,
      entryExpirationTimeInMS: 5e3
    });
  }
  trackUsers(ar) {
    for (const cr of ar) {
      const ur = getKeyFromItem(cr);
      if (this.data.has(ur))
        continue;
      const fr = this.track(cr, "user"), dr = cr instanceof NDKUser ? cr : new NDKUser({ hexpubkey: cr });
      dr.ndk = this.ndk, dr.relayList().then((hr) => {
        if (hr) {
          fr.readRelays = new Set(hr.readRelayUrls), fr.writeRelays = new Set(hr.writeRelayUrls);
          for (const gr of fr.readRelays)
            this.ndk.pool.blacklistRelayUrls.has(gr) && (this.debug(`removing blacklisted relay ${gr} from read relays`), fr.readRelays.delete(gr));
          for (const gr of fr.writeRelays)
            this.ndk.pool.blacklistRelayUrls.has(gr) && (this.debug(`removing blacklisted relay ${gr} from write relays`), fr.writeRelays.delete(gr));
          this.data.set(ur, fr), this.debug(
            `Adding ${fr.readRelays.size} read relays and ${fr.writeRelays.size} write relays for ${dr.hexpubkey}`
          );
        }
      });
    }
  }
  /**
   *
   * @param key
   * @param score
   */
  track(ar, cr) {
    const ur = getKeyFromItem(ar);
    cr != null || (cr = getTypeFromItem(ar));
    let fr = this.data.get(ur);
    return fr || (fr = new OutboxItem(cr)), this.data.set(ur, fr), fr;
  }
};
function getKeyFromItem(lr) {
  return lr instanceof NDKUser ? lr.hexpubkey : lr;
}
function getTypeFromItem(lr) {
  return lr instanceof NDKUser ? "user" : "kind";
}
var NDKPool = class extends lib$2.EventEmitter {
  constructor(ar = [], cr = [], ur, fr) {
    super();
    // TODO: This should probably be an LRU cache
    Wi(this, "relays", /* @__PURE__ */ new Map());
    Wi(this, "blacklistRelayUrls");
    Wi(this, "debug");
    Wi(this, "temporaryRelayTimers", /* @__PURE__ */ new Map());
    Wi(this, "flappingRelays", /* @__PURE__ */ new Set());
    // A map to store timeouts for each flapping relay.
    Wi(this, "backoffTimes", /* @__PURE__ */ new Map());
    this.debug = fr != null ? fr : ur.debug.extend("pool");
    for (const dr of ar) {
      const hr = new NDKRelay(dr);
      this.addRelay(hr, !1);
    }
    this.blacklistRelayUrls = new Set(cr);
  }
  /**
   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.
   * @param relay - The relay to add to the pool.
   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.
   */
  useTemporaryRelay(ar, cr = 6e5) {
    const ur = this.relays.has(ar.url);
    ur || this.addRelay(ar);
    const fr = this.temporaryRelayTimers.get(ar.url);
    if (fr && clearTimeout(fr), !ur || fr) {
      const dr = setTimeout(() => {
        this.removeRelay(ar.url);
      }, cr);
      this.temporaryRelayTimers.set(ar.url, dr);
    }
  }
  /**
   * Adds a relay to the pool.
   *
   * @param relay - The relay to add to the pool.
   * @param connect - Whether or not to connect to the relay.
   */
  addRelay(ar, cr = !0) {
    var fr;
    const ur = ar.url;
    if ((fr = this.blacklistRelayUrls) != null && fr.has(ur)) {
      this.debug(`Relay ${ur} is blacklisted`);
      return;
    }
    ar.on("notice", async (dr, hr) => this.emit("notice", dr, hr)), ar.on("connect", () => this.handleRelayConnect(ur)), ar.on("disconnect", async () => this.emit("relay:disconnect", ar)), ar.on("flapping", () => this.handleFlapping(ar)), this.relays.set(ur, ar), cr && ar.connect().catch((dr) => {
      this.debug(`Failed to connect to relay ${ur}`, dr);
    });
  }
  /**
   * Removes a relay from the pool.
   * @param relayUrl - The URL of the relay to remove.
   * @returns {boolean} True if the relay was removed, false if it was not found.
   */
  removeRelay(ar) {
    const cr = this.relays.get(ar);
    if (cr)
      return cr.disconnect(), this.relays.delete(ar), this.emit("relay:disconnect", cr), !0;
    const ur = this.temporaryRelayTimers.get(ar);
    return ur && (clearTimeout(ur), this.temporaryRelayTimers.delete(ar)), !1;
  }
  /**
   * Fetches a relay from the pool, or creates a new one if it does not exist.
   *
   * New relays will be attempted to be connected.
   */
  getRelay(ar) {
    let cr = this.relays.get(ar);
    return cr || (cr = new NDKRelay(ar), this.addRelay(cr)), cr;
  }
  handleRelayConnect(ar) {
    this.debug(`Relay ${ar} connected`), this.emit("relay:connect", this.relays.get(ar)), this.stats().connected === this.relays.size && this.emit("connect");
  }
  /**
   * Attempts to establish a connection to each relay in the pool.
   *
   * @async
   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
   * @throws {Error} If any of the connection attempts result in an error or timeout.
   */
  async connect(ar) {
    const cr = [];
    this.debug(
      `Connecting to ${this.relays.size} relays${ar ? `, timeout ${ar}...` : ""}`
    );
    for (const ur of this.relays.values())
      if (ar) {
        const fr = new Promise((dr, hr) => {
          setTimeout(() => hr(`Timed out after ${ar}ms`), ar);
        });
        cr.push(
          Promise.race([ur.connect(), fr]).catch((dr) => {
            this.debug(
              `Failed to connect to relay ${ur.url}: ${dr != null ? dr : "No reason specified"}`
            );
          })
        );
      } else
        cr.push(ur.connect());
    ar && setTimeout(() => {
      const ur = this.stats().connected === this.relays.size, fr = this.stats().connected > 0;
      !ur && fr && this.emit("connect");
    }, ar), await Promise.all(cr);
  }
  checkOnFlappingRelays() {
    const ar = this.flappingRelays.size, cr = this.relays.size;
    if (ar / cr >= 0.8)
      for (const ur of this.flappingRelays)
        this.backoffTimes.set(ur, 0);
  }
  handleFlapping(ar) {
    this.debug(`Relay ${ar.url} is flapping`);
    let cr = this.backoffTimes.get(ar.url) || 5e3;
    cr = cr * 2, this.backoffTimes.set(ar.url, cr), this.debug(`Backoff time for ${ar.url} is ${cr}ms`), setTimeout(() => {
      this.debug(`Attempting to reconnect to ${ar.url}`), ar.connect(), this.checkOnFlappingRelays();
    }, cr), ar.disconnect(), this.emit("flapping", ar);
  }
  size() {
    return this.relays.size;
  }
  /**
   * Returns the status of each relay in the pool.
   * @returns {NDKPoolStats} An object containing the number of relays in each status.
   */
  stats() {
    const ar = {
      total: 0,
      connected: 0,
      disconnected: 0,
      connecting: 0
    };
    for (const cr of this.relays.values())
      ar.total++, cr.status === 1 ? ar.connected++ : cr.status === 3 ? ar.disconnected++ : cr.status === 0 && ar.connecting++;
    return ar;
  }
  connectedRelays() {
    return Array.from(this.relays.values()).filter(
      (ar) => ar.status === 1
      /* CONNECTED */
    );
  }
  /**
   * Get a list of all relay urls in the pool.
   */
  urls() {
    return Array.from(this.relays.keys());
  }
};
function correctRelaySet(lr, ar) {
  const cr = ar.connectedRelays();
  if (!Array.from(lr.relays).some((fr) => cr.map((dr) => dr.url).includes(fr.url)))
    for (const fr of cr)
      lr.addRelay(fr);
  if (cr.length === 0)
    for (const fr of ar.relays.values())
      lr.addRelay(fr);
  return lr;
}
var DEFAULT_OUTBOX_RELAYS = ["wss://purplepag.es", "wss://relay.snort.social"], DEFAULT_BLACKLISTED_RELAYS = [
  "wss://brb.io"
  // BRB
], NDK = class extends lib$2.EventEmitter {
  constructor(ar = {}) {
    var cr, ur;
    super();
    Wi(this, "explicitRelayUrls");
    Wi(this, "pool");
    Wi(this, "outboxPool");
    Wi(this, "_signer");
    Wi(this, "_activeUser");
    Wi(this, "cacheAdapter");
    Wi(this, "debug");
    Wi(this, "devWriteRelaySet");
    Wi(this, "outboxTracker");
    Wi(this, "mutedIds");
    Wi(this, "clientName");
    Wi(this, "clientNip89");
    Wi(this, "autoConnectUserRelays", !0);
    Wi(this, "autoFetchUserMutelist", !0);
    this.debug = ar.debug || _debug("ndk"), this.explicitRelayUrls = ar.explicitRelayUrls, this.pool = new NDKPool(ar.explicitRelayUrls || [], ar.blacklistRelayUrls, this), this.debug(`Starting with explicit relays: ${JSON.stringify(this.explicitRelayUrls)}`), this.autoConnectUserRelays = (cr = ar.autoConnectUserRelays) != null ? cr : !0, this.autoFetchUserMutelist = (ur = ar.autoFetchUserMutelist) != null ? ur : !0, this.clientName = ar.clientName, this.clientNip89 = ar.clientNip89, ar.enableOutboxModel && (this.outboxPool = new NDKPool(
      ar.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,
      ar.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS,
      this,
      this.debug.extend("outbox-pool")
    ), this.outboxTracker = new OutboxTracker(this)), this.signer = ar.signer, this.cacheAdapter = ar.cacheAdapter, this.mutedIds = ar.mutedIds || /* @__PURE__ */ new Map(), ar.devWriteRelayUrls && (this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(ar.devWriteRelayUrls, this));
  }
  toJSON() {
    return { relayCount: this.pool.relays.size }.toString();
  }
  get activeUser() {
    return this._activeUser;
  }
  /**
   * Sets the active user for this NDK instance, typically this will be
   * called when assigning a signer to the NDK instance.
   *
   * This function will automatically connect to the user's relays if
   * `autoConnectUserRelays` is set to true.
   *
   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.
   */
  set activeUser(ar) {
    const cr = this._activeUser !== ar;
    if (this._activeUser = ar, ar && cr) {
      const ur = async (vr) => {
        const mr = await vr.relayList();
        if (!mr) {
          this.debug("No relay list found for user", { npub: vr.npub });
          return;
        }
        this.debug("Connecting to user relays", {
          npub: vr.npub,
          relays: mr.relays
        });
        for (const br of mr.relays) {
          let yr = this.pool.relays.get(br);
          yr || (yr = new NDKRelay(br), this.pool.addRelay(yr));
        }
      }, fr = async (vr) => {
        const mr = await this.fetchEvents([
          { kinds: [
            1e4
            /* MuteList */
          ], authors: [vr.pubkey] },
          {
            kinds: [
              3e4
              /* FollowSet */
            ],
            authors: [vr.pubkey],
            "#d": ["mute"],
            limit: 1
          }
        ]);
        if (!mr) {
          this.debug("No mute list found for user", { npub: vr.npub });
          return;
        }
        for (const br of mr) {
          const yr = lists_default.from(br);
          for (const kr of yr.items)
            this.mutedIds.set(kr[1], kr[0]);
        }
      }, dr = [];
      this.autoConnectUserRelays && dr.push(ur), this.autoFetchUserMutelist && dr.push(fr);
      const hr = async (vr) => {
        for (const mr of dr)
          await mr(vr);
      }, gr = this.outboxPool || this.pool;
      gr.connectedRelays.length > 0 ? hr(ar) : (this.debug("Waiting for connection to main relays"), gr.once("relay:connect", (vr) => {
        this.debug("New relay came online", vr), hr(ar);
      }));
    } else
      ar || (this.mutedIds = /* @__PURE__ */ new Map());
  }
  get signer() {
    return this._signer;
  }
  set signer(ar) {
    this._signer = ar, this.debug("setting signer", this.autoConnectUserRelays), ar == null || ar.user().then((cr) => {
      cr.ndk = this, this.activeUser = cr;
    });
  }
  /**
   * Connect to relays with optional timeout.
   * If the timeout is reached, the connection will be continued to be established in the background.
   */
  async connect(ar) {
    this._signer && this.autoConnectUserRelays && (this.debug("Attempting to connect to user relays specified by signer"), this._signer.relays && (await this._signer.relays()).forEach((fr) => this.pool.addRelay(fr)));
    const cr = [this.pool.connect(ar)];
    return this.outboxPool && cr.push(this.outboxPool.connect(ar)), this.debug("Connecting to relays", { timeoutMs: ar }), Promise.allSettled(cr).then(() => {
    });
  }
  /**
   * Get a NDKUser object
   *
   * @param opts
   * @returns
   */
  getUser(ar) {
    const cr = new NDKUser(ar);
    return cr.ndk = this, cr;
  }
  /**
   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)
   *
   * @param filters
   * @param opts
   * @param relaySet explicit relay set to use
   * @param autoStart automatically start the subscription
   * @returns NDKSubscription
   */
  subscribe(ar, cr, ur, fr = !0) {
    var hr;
    const dr = new NDKSubscription(this, ar, cr, ur);
    if (ur)
      for (const gr of ur.relays)
        this.pool.useTemporaryRelay(gr);
    if (this.outboxPool && dr.hasAuthorsFilter()) {
      const gr = dr.filters.filter((vr) => {
        var mr;
        return vr.authors && ((mr = vr.authors) == null ? void 0 : mr.length) > 0;
      }).map((vr) => vr.authors).flat();
      (hr = this.outboxTracker) == null || hr.trackUsers(gr);
    }
    return fr && dr.start(), dr;
  }
  /**
   * Publish an event to a relay
   * @param event event to publish
   * @param relaySet explicit relay set to use
   * @param timeoutMs timeout in milliseconds to wait for the event to be published
   * @returns The relays the event was published to
   *
   * @deprecated Use `event.publish()` instead
   */
  async publish(ar, cr, ur) {
    return this.debug("Deprecated: Use `event.publish()` instead"), ar.publish(cr, ur);
  }
  /**
   * Fetch a single event.
   *
   * @param idOrFilter event id in bech32 format or filter
   * @param opts subscription options
   * @param relaySet explicit relay set to use
   */
  async fetchEvent(ar, cr, ur) {
    let fr;
    if (!ur && typeof ar == "string" && !isNip33AValue(ar)) {
      const dr = relaysFromBech32(ar);
      dr.length > 0 && (ur = new NDKRelaySet(new Set(dr), this), ur = correctRelaySet(ur, this.pool));
    }
    if (typeof ar == "string" ? fr = filterFromId(ar) : fr = ar, !fr)
      throw new Error(`Invalid filter: ${JSON.stringify(ar)}`);
    return new Promise((dr) => {
      const hr = this.subscribe(
        fr,
        { ...cr || {}, closeOnEose: !0 },
        ur,
        !1
      );
      hr.on("event", (gr) => {
        gr.ndk = this, dr(gr);
      }), hr.on("eose", () => {
        dr(null);
      }), hr.start();
    });
  }
  /**
   * Fetch events
   */
  async fetchEvents(ar, cr, ur) {
    return new Promise((fr) => {
      const dr = /* @__PURE__ */ new Map(), hr = this.subscribe(
        ar,
        { ...cr || {}, closeOnEose: !0 },
        ur,
        !1
      ), gr = (vr) => {
        const mr = vr.deduplicationKey(), br = dr.get(mr);
        br && (vr = dedup(br, vr)), vr.ndk = this, dr.set(mr, vr);
      };
      hr.on("event", gr), hr.on("event:dup", gr), hr.on("eose", () => {
        fr(new Set(dr.values()));
      }), hr.start();
    });
  }
  /**
   * Ensures that a signer is available to sign an event.
   */
  assertSigner() {
    if (!this.signer)
      throw this.emit("signerRequired"), new Error("Signer required");
  }
}, NDKSvelte = class extends NDK {
  constructor(lr) {
    super(lr);
  }
  createEventStore(lr) {
    const ar = writable([]);
    return {
      refCount: 0,
      filters: lr,
      subscription: void 0,
      set: ar.set,
      update: ar.update,
      subscribe: ar.subscribe,
      unsubscribe: () => {
      },
      onEose: (cr) => {
      },
      startSubscription: () => {
        throw new Error("not implemented");
      },
      ref: () => {
        throw new Error("not implemented");
      },
      unref: () => {
        throw new Error("not implemented");
      },
      empty: () => {
        throw new Error("not implemented");
      },
      changeFilters: (cr) => {
        throw new Error("not implemented");
      }
    };
  }
  eventIsRepost(lr) {
    return [NDKKind.Repost, NDKKind.GenericRepost].includes(lr.kind);
  }
  eventIsLabel(lr) {
    return [NDKKind.Label].includes(lr.kind);
  }
  storeSubscribe(lr, ar, cr) {
    var yr;
    let ur = /* @__PURE__ */ new Set(), fr = [];
    const dr = this.createEventStore(
      Array.isArray(lr) ? lr : [lr]
    ), hr = (yr = ar == null ? void 0 : ar.autoStart) != null ? yr : !0, gr = ar == null ? void 0 : ar.relaySet, vr = (kr) => {
      console.log("handle event label", kr.rawEvent()), mr(kr);
    }, mr = (kr) => {
      const Tr = NDKRepost.from(kr);
      Tr.ndk = this;
      const _r = (Er) => {
        Er.repostedByEvents ? Er.repostedByEvents.push(kr) : Er.repostedByEvents = [kr], dr.set(fr);
      };
      for (const Er of Tr.repostedEventIds()) {
        const xr = fr.find((Cr) => Cr.id === Er);
        xr ? _r(xr) : Tr.repostedEvents(cr).then((Cr) => {
          for (const Ar of Cr)
            Ar instanceof NDKEvent && br(Ar);
        });
      }
    }, br = (kr) => {
      if (dr.filters && this.eventIsRepost(kr)) {
        mr(kr);
        return;
      }
      if (this.eventIsLabel(kr)) {
        vr(kr);
        return;
      }
      let Tr = kr;
      cr && (Tr = cr.from(kr), Tr.relay = kr.relay), Tr.ndk = this;
      const _r = kr.deduplicationKey();
      if (ur.has(_r)) {
        const xr = fr.find((Cr) => Cr.deduplicationKey() === _r);
        if (xr && xr.created_at < kr.created_at) {
          const Cr = fr.findIndex((Ar) => Ar.deduplicationKey() === _r);
          fr.splice(Cr, 1);
        } else
          return;
      }
      ur.add(_r);
      const Er = fr.findIndex((xr) => xr.created_at < kr.created_at);
      Er === -1 ? fr.push(Tr) : fr.splice(Er === -1 ? fr.length : Er, 0, Tr), dr.set(fr);
    };
    return dr.ref = () => (dr.refCount++, dr.refCount === 1 && dr.startSubscription(), dr.refCount), dr.unref = () => (--dr.refCount !== 0 || (ar != null && ar.unrefUnsubscribeTimeout ? setTimeout(() => {
      dr.refCount === 0 && dr.unsubscribe();
    }, ar.unrefUnsubscribeTimeout) : dr.unsubscribe()), dr.refCount), dr.empty = () => {
      dr.set([]), fr = [], ur = /* @__PURE__ */ new Set(), dr.unsubscribe();
    }, dr.changeFilters = (kr) => {
      dr.filters = kr, dr.empty(), dr.refCount > 0 && dr.startSubscription();
    }, dr.startSubscription = () => {
      if (!dr.filters)
        throw new Error("no filters");
      const kr = dr.filters;
      ar != null && ar.repostsFilters && kr.push(...ar.repostsFilters), dr.subscription = this.subscribe(kr, ar, gr), dr.subscription.on("event", (Tr, _r) => {
        br(Tr);
      }), dr.unsubscribe = () => {
        var Tr;
        (Tr = dr.subscription) == null || Tr.stop(), dr.subscription = void 0;
      }, dr.onEose = (Tr) => {
        var _r;
        (_r = dr.subscription) == null || _r.on("eose", Tr);
      };
    }, hr && dr.startSubscription(), dr;
  }
}, src_default = NDKSvelte;
const crypto$3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$3 = (lr) => lr instanceof Uint8Array, createView$2 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$2 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$2)
  throw new Error("Non little-endian hardware is not supported");
const hexes$2 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$2(lr) {
  if (!u8a$3(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$2[lr[cr]];
  return ar;
}
function hexToBytes$3(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function utf8ToBytes$3(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$2(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$3(lr)), !u8a$3(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$3(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$3(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(lr) {
  const ar = (ur) => lr().update(toBytes$2(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$2(lr = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues == "function")
    return crypto$3.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$2(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$1(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$2(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$2(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$2(lr.outputLen), number$2(lr.blockLen);
}
function exists$2(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(lr, ar) {
  bytes$2(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$1 = {
  number: number$2,
  bool: bool$1,
  bytes: bytes$2,
  hash: hash$2,
  exists: exists$2,
  output: output$2
};
function setBigUint64$2(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
let SHA2$2 = class extends Hash$2 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$2(this.buffer);
  }
  update(ar) {
    assert$1.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$2(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView$2(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64$2(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView$2(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$3 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$2 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$2 = new Uint32Array(64);
let SHA256$2 = class extends SHA2$2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$2[0] | 0, this.B = IV$2[1] | 0, this.C = IV$2[2] | 0, this.D = IV$2[3] | 0, this.E = IV$2[4] | 0, this.F = IV$2[5] | 0, this.G = IV$2[6] | 0, this.H = IV$2[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W$2[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W$2[yr - 15], Tr = SHA256_W$2[yr - 2], _r = rotr$2(kr, 7) ^ rotr$2(kr, 18) ^ kr >>> 3, Er = rotr$2(Tr, 17) ^ rotr$2(Tr, 19) ^ Tr >>> 10;
      SHA256_W$2[yr] = Er + SHA256_W$2[yr - 7] + _r + SHA256_W$2[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr$2(gr, 6) ^ rotr$2(gr, 11) ^ rotr$2(gr, 25), Tr = br + kr + Chi$3(gr, vr, mr) + SHA256_K$2[yr] + SHA256_W$2[yr] | 0, Er = (rotr$2(ur, 2) ^ rotr$2(ur, 13) ^ rotr$2(ur, 22)) + Maj$2(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$2 = wrapConstructor$2(() => new SHA256$2());
wrapConstructor$2(() => new SHA224$1());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$1(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain$1(...lr) {
  const ar = (fr, dr) => (hr) => fr(dr(hr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet$1(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber$1(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$2(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding$1(lr, ar = "=") {
  if (assertNumber$1(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize$1(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix$1(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((hr) => {
    if (assertNumber$1(hr), hr < 0 || hr >= ar)
      throw new Error(`Wrong integer: ${hr}`);
  }); ; ) {
    let hr = 0, gr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const mr = dr[vr], br = ar * hr + mr;
      if (!Number.isSafeInteger(br) || ar * hr / ar !== hr || br - mr !== ar * hr)
        throw new Error("convertRadix: carry overflow");
      if (hr = br % cr, dr[vr] = Math.floor(br / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + hr !== br)
        throw new Error("convertRadix: carry overflow");
      if (gr)
        dr[vr] ? gr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(hr), gr)
      break;
  }
  for (let hr = 0; hr < lr.length - 1 && lr[hr] === 0; hr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$1 = (lr, ar) => ar ? gcd$1(ar, lr % ar) : lr, radix2carry$1 = (lr, ar) => lr + (ar - gcd$1(lr, ar));
function convertRadix2$1(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry$1(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry$1(ar, cr)}`);
  let fr = 0, dr = 0;
  const hr = 2 ** cr - 1, gr = [];
  for (const vr of lr) {
    if (assertNumber$1(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      gr.push((fr >> dr - cr & hr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & hr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && gr.push(fr >>> 0), gr;
}
function radix$1(lr) {
  return assertNumber$1(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$1(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$1(ar, lr, 2 ** 8));
    }
  };
}
function radix2$1(lr, ar = !1) {
  if (assertNumber$1(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$1(8, lr) > 32 || radix2carry$1(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$1(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$1(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper$1(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16$1 = chain$1(radix2$1(4), alphabet$1("0123456789ABCDEF"), join$2("")), base32$1 = chain$1(radix2$1(5), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$2(""), normalize$1((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$1(6), join$2("")), base64url$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$1(6), join$2("")), genBase58$1 = (lr) => chain$1(radix$1(58), alphabet$1(lr), join$2("")), base58$1 = genBase58$1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$1("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$1("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$1 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$1 = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58$1.encode(ur).padStart(XMR_BLOCK_LEN$1[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN$1.indexOf(ur.length), dr = base58$1.decode(ur);
      for (let hr = 0; hr < dr.length - fr; hr++)
        if (dr[hr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$1 = chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$2("")), POLYMOD_GENERATORS$1 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$1(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$1.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS$1[ur]);
  return cr;
}
function bechChecksum$1(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const hr = lr.charCodeAt(dr);
    if (hr < 33 || hr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod$1(fr) ^ hr >> 5;
  }
  fr = bech32Polymod$1(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod$1(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod$1(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod$1(fr);
  return fr ^= cr, BECH_ALPHABET$1.encode(convertRadix2$1([fr % 2 ** 30], 30, 5, !1));
}
function genBech32$1(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2$1(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper$1(ur);
  function hr(br, yr, kr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof br}`);
    if (!Array.isArray(yr) || yr.length && typeof yr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof yr}`);
    const Tr = br.length + 7 + yr.length;
    if (kr !== !1 && Tr > kr)
      throw new TypeError(`Length ${Tr} exceeds limit ${kr}`);
    return br = br.toLowerCase(), `${br}1${BECH_ALPHABET$1.encode(yr)}${bechChecksum$1(br, yr, ar)}`;
  }
  function gr(br, yr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof br}`);
    if (br.length < 8 || yr !== !1 && br.length > yr)
      throw new TypeError(`Wrong string length: ${br.length} (${br}). Expected (8..${yr})`);
    const kr = br.toLowerCase();
    if (br !== kr && br !== br.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    br = kr;
    const Tr = br.lastIndexOf("1");
    if (Tr === 0 || Tr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const _r = br.slice(0, Tr), Er = br.slice(Tr + 1);
    if (Er.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const xr = BECH_ALPHABET$1.decode(Er).slice(0, -6), Cr = bechChecksum$1(_r, xr, ar);
    if (!Er.endsWith(Cr))
      throw new Error(`Invalid checksum in ${br}: expected "${Cr}"`);
    return { prefix: _r, words: xr };
  }
  const vr = unsafeWrapper$1(gr);
  function mr(br) {
    const { prefix: yr, words: kr } = gr(br, !1);
    return { prefix: yr, words: kr, bytes: ur(kr) };
  }
  return { encode: hr, decode: gr, decodeToBytes: mr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32$2 = genBech32$1("bech32");
genBech32$1("bech32m");
const utf8$1 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex$1 = chain$1(radix2$1(4), alphabet$1("0123456789abcdef"), join$2(""), normalize$1((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS$1 = {
  utf8: utf8$1,
  hex: hex$1,
  base16: base16$1,
  base32: base32$1,
  base64: base64$1,
  base64url: base64url$1,
  base58: base58$1,
  base58xmr: base58xmr$1
};
`${Object.keys(CODERS$1).join(", ")}`;
let HMAC$2 = class extends Hash$2 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$1.hash(ar);
    const ur = toBytes$2(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$1.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$2 = (lr, ar, cr) => new HMAC$2(lr, ar).update(cr).digest();
hmac$2.create = (lr, ar) => new HMAC$2(lr, ar);
function extract$1(lr, ar, cr) {
  return assert$1.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac$2(lr, toBytes$2(cr), toBytes$2(ar));
}
const HKDF_COUNTER$1 = new Uint8Array([0]), EMPTY_BUFFER$1 = new Uint8Array();
function expand$1(lr, ar, cr, ur = 32) {
  if (assert$1.hash(lr), assert$1.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER$1);
  const dr = new Uint8Array(fr * lr.outputLen), hr = hmac$2.create(lr, ar), gr = hr._cloneInto(), vr = new Uint8Array(hr.outputLen);
  for (let mr = 0; mr < fr; mr++)
    HKDF_COUNTER$1[0] = mr + 1, gr.update(mr === 0 ? EMPTY_BUFFER$1 : vr).update(cr).update(HKDF_COUNTER$1).digestInto(vr), dr.set(vr, lr.outputLen * mr), hr._cloneInto(gr);
  return hr.destroy(), gr.destroy(), vr.fill(0), HKDF_COUNTER$1.fill(0), dr.slice(0, ur);
}
const hkdf = (lr, ar, cr, ur, fr) => expand$1(lr, extract$1(lr, ar, cr), ur, fr);
var __defProp$1 = Object.defineProperty, __export$1 = (lr, ar) => {
  for (var cr in ar)
    __defProp$1(lr, cr, { get: ar[cr], enumerable: !0 });
};
function getPublicKey(lr) {
  return bytesToHex$2(schnorr$1.getPublicKey(lr));
}
var utils_exports$1 = {};
__export$1(utils_exports$1, {
  MessageNode: () => MessageNode,
  MessageQueue: () => MessageQueue,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$1,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$1,
  normalizeURL: () => normalizeURL$1,
  utf8Decoder: () => utf8Decoder$1,
  utf8Encoder: () => utf8Encoder$1
});
var utf8Decoder$1 = new TextDecoder("utf-8"), utf8Encoder$1 = new TextEncoder();
function normalizeURL$1(lr) {
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$1(lr, ar) {
  var hr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at < lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at >= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at > ar.created_at)
        cr = fr;
      else if (lr[fr].created_at < ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((hr = lr[dr]) == null ? void 0 : hr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
function insertEventIntoAscendingList$1(lr, ar) {
  var hr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at > lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at <= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at < ar.created_at)
        cr = fr;
      else if (lr[fr].created_at > ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((hr = lr[dr]) == null ? void 0 : hr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
var MessageNode = class {
  constructor(lr) {
    Wi(this, "_value");
    Wi(this, "_next");
    this._value = lr, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(lr) {
    this._value = lr;
  }
  get next() {
    return this._next;
  }
  set next(lr) {
    this._next = lr;
  }
}, MessageQueue = class {
  constructor() {
    Wi(this, "_first");
    Wi(this, "_last");
    Wi(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(lr) {
    this._first = lr;
  }
  get last() {
    return this._last;
  }
  set last(lr) {
    this._last = lr;
  }
  get size() {
    return this._size;
  }
  set size(lr) {
    this._size = lr;
  }
  enqueue(lr) {
    const ar = new MessageNode(lr);
    return this._size === 0 || !this._last ? (this._first = ar, this._last = ar) : (this._last.next = ar, this._last = ar), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let lr = this._first;
    return this._first = lr.next, lr.next = null, this._size--, lr.value;
  }
}, verifiedSymbol$1 = Symbol("verified");
function getBlankEvent(lr = 255) {
  return {
    kind: lr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent(lr, ar) {
  const cr = lr;
  return cr.pubkey = getPublicKey(ar), cr.id = getEventHash$1(cr), cr.sig = getSignature(cr, ar), cr[verifiedSymbol$1] = !0, cr;
}
function serializeEvent$1(lr) {
  if (!validateEvent$1(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash$1(lr) {
  let ar = sha256$2(utf8Encoder$1.encode(serializeEvent$1(lr)));
  return bytesToHex$2(ar);
}
var isRecord$1 = (lr) => lr instanceof Object;
function validateEvent$1(lr) {
  if (!isRecord$1(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature(lr) {
  if (typeof lr[verifiedSymbol$1] == "boolean")
    return lr[verifiedSymbol$1];
  const ar = getEventHash$1(lr);
  if (ar !== lr.id)
    return lr[verifiedSymbol$1] = !1;
  try {
    return lr[verifiedSymbol$1] = schnorr$1.verify(lr.sig, ar, lr.pubkey);
  } catch (cr) {
    return lr[verifiedSymbol$1] = !1;
  }
}
function getSignature(lr, ar) {
  return bytesToHex$2(schnorr$1.sign(getEventHash$1(lr), ar));
}
function matchFilter(lr, ar) {
  if (lr.ids && lr.ids.indexOf(ar.id) === -1 && !lr.ids.some((cr) => ar.id.startsWith(cr)) || lr.kinds && lr.kinds.indexOf(ar.kind) === -1 || lr.authors && lr.authors.indexOf(ar.pubkey) === -1 && !lr.authors.some((cr) => ar.pubkey.startsWith(cr)))
    return !1;
  for (let cr in lr)
    if (cr[0] === "#") {
      let ur = cr.slice(1), fr = lr[`#${ur}`];
      if (fr && !ar.tags.find(([dr, hr]) => dr === cr.slice(1) && fr.indexOf(hr) !== -1))
        return !1;
    }
  return !(lr.since && ar.created_at < lr.since || lr.until && ar.created_at > lr.until);
}
var fakejson_exports$1 = {};
__export$1(fakejson_exports$1, {
  getHex64: () => getHex64$1,
  getInt: () => getInt$1,
  getSubscriptionId: () => getSubscriptionId$1,
  matchEventId: () => matchEventId$1,
  matchEventKind: () => matchEventKind$1,
  matchEventPubkey: () => matchEventPubkey$1
});
function getHex64$1(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt$1(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId$1(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId$1(lr, ar) {
  return ar === getHex64$1(lr, "id");
}
function matchEventPubkey$1(lr, ar) {
  return ar === getHex64$1(lr, "pubkey");
}
function matchEventKind$1(lr, ar) {
  return ar === getInt$1(lr, "kind");
}
var nip19_exports$1 = {};
__export$1(nip19_exports$1, {
  BECH32_REGEX: () => BECH32_REGEX$1,
  decode: () => decode$2,
  naddrEncode: () => naddrEncode$1,
  neventEncode: () => neventEncode$1,
  noteEncode: () => noteEncode$1,
  nprofileEncode: () => nprofileEncode$1,
  npubEncode: () => npubEncode$1,
  nrelayEncode: () => nrelayEncode$1,
  nsecEncode: () => nsecEncode$1
});
var Bech32MaxSize$1 = 5e3, BECH32_REGEX$1 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$1(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$2(lr) {
  var fr, dr, hr, gr, vr, mr, br, yr;
  let { prefix: ar, words: cr } = bech32$2.decode(lr, Bech32MaxSize$1), ur = new Uint8Array(bech32$2.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let kr = parseTLV$1(ur);
      if (!((fr = kr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$2(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$1.decode(Tr)) : []
        }
      };
    }
    case "nevent": {
      let kr = parseTLV$1(ur);
      if (!((dr = kr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (kr[2] && kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (kr[3] && kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$2(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$1.decode(Tr)) : [],
          author: (hr = kr[2]) != null && hr[0] ? bytesToHex$2(kr[2][0]) : void 0,
          kind: (gr = kr[3]) != null && gr[0] ? parseInt(bytesToHex$2(kr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let kr = parseTLV$1(ur);
      if (!((vr = kr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((mr = kr[2]) != null && mr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((br = kr[3]) != null && br[0]))
        throw new Error("missing TLV 3 for naddr");
      if (kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$1.decode(kr[0][0]),
          pubkey: bytesToHex$2(kr[2][0]),
          kind: parseInt(bytesToHex$2(kr[3][0]), 16),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder$1.decode(Tr)) : []
        }
      };
    }
    case "nrelay": {
      let kr = parseTLV$1(ur);
      if (!((yr = kr[0]) != null && yr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$1.decode(kr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$2(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$1(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1];
    if (!fr)
      throw new Error(`malformed TLV ${ur}`);
    let dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode$1(lr) {
  return encodeBytes$1("nsec", lr);
}
function npubEncode$1(lr) {
  return encodeBytes$1("npub", lr);
}
function noteEncode$1(lr) {
  return encodeBytes$1("note", lr);
}
function encodeBech32$1(lr, ar) {
  let cr = bech32$2.toWords(ar);
  return bech32$2.encode(lr, cr, Bech32MaxSize$1);
}
function encodeBytes$1(lr, ar) {
  let cr = hexToBytes$3(ar);
  return encodeBech32$1(lr, cr);
}
function nprofileEncode$1(lr) {
  let ar = encodeTLV$1({
    0: [hexToBytes$3(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder$1.encode(cr))
  });
  return encodeBech32$1("nprofile", ar);
}
function neventEncode$1(lr) {
  let ar;
  lr.kind != null && (ar = integerToUint8Array$1(lr.kind));
  let cr = encodeTLV$1({
    0: [hexToBytes$3(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: lr.author ? [hexToBytes$3(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$1("nevent", cr);
}
function naddrEncode$1(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV$1({
    0: [utf8Encoder$1.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: [hexToBytes$3(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$1("naddr", cr);
}
function nrelayEncode$1(lr) {
  let ar = encodeTLV$1({
    0: [utf8Encoder$1.encode(lr)]
  });
  return encodeBech32$1("nrelay", ar);
}
function encodeTLV$1(lr) {
  let ar = [];
  return Object.entries(lr).forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes$3(...ar);
}
var nip04_exports$1 = {};
__export$1(nip04_exports$1, {
  decrypt: () => decrypt$1,
  encrypt: () => encrypt$1
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$1(lr, ar, cr) {
  const ur = secp256k1$1.getSharedSecret(lr, "02" + ar), fr = getNormalizedX$1(ur);
  let dr = Uint8Array.from(randomBytes$2(16)), hr = utf8Encoder$1.encode(cr), gr = await crypto.subtle.importKey("raw", fr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: dr }, gr, hr), mr = base64$1.encode(new Uint8Array(vr)), br = base64$1.encode(new Uint8Array(dr.buffer));
  return `${mr}?iv=${br}`;
}
async function decrypt$1(lr, ar, cr) {
  let [ur, fr] = cr.split("?iv="), dr = secp256k1$1.getSharedSecret(lr, "02" + ar), hr = getNormalizedX$1(dr), gr = await crypto.subtle.importKey("raw", hr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$1.decode(ur), mr = base64$1.decode(fr), br = await crypto.subtle.decrypt({ name: "AES-CBC", iv: mr }, gr, vr);
  return utf8Decoder$1.decode(br);
}
function getNormalizedX$1(lr) {
  return lr.slice(1, 33);
}
var nip05_exports$1 = {};
__export$1(nip05_exports$1, {
  NIP05_REGEX: () => NIP05_REGEX$1,
  queryProfile: () => queryProfile$1,
  searchDomain: () => searchDomain$1,
  useFetchImplementation: () => useFetchImplementation$1
});
var NIP05_REGEX$1 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$1;
try {
  _fetch$1 = fetch;
} catch (lr) {
}
function useFetchImplementation$1(lr) {
  _fetch$1 = lr;
}
async function searchDomain$1(lr, ar = "") {
  try {
    return (await (await _fetch$1(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile$1(lr) {
  const ar = lr.match(NIP05_REGEX$1);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch$1(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: hr, relays: gr } = parseNIP05Result$1(await dr.json()), vr = hr[ur];
    return vr ? { pubkey: vr, relays: gr == null ? void 0 : gr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result$1(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip06_exports = {};
__export$1(nip06_exports, {
  generateSeedWords: () => generateSeedWords,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords,
  validateWords: () => validateWords
});
function privateKeyFromSeedWords(lr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(lr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$2(ur);
}
function generateSeedWords() {
  return generateMnemonic(wordlist);
}
function validateWords(lr) {
  return validateMnemonic(lr, wordlist);
}
var nip10_exports$1 = {};
__export$1(nip10_exports$1, {
  parse: () => parse$1
});
function parse$1(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, hr, gr, vr] = fr, mr = {
      id: hr,
      relays: gr ? [gr] : []
    }, br = ur === 0, yr = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = mr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = mr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(mr);
      continue;
    }
    if (br) {
      ar.root = mr;
      continue;
    }
    if (yr) {
      ar.reply = mr;
      continue;
    }
    ar.mentions.push(mr);
  }
  return ar;
}
var nip13_exports$1 = {};
__export$1(nip13_exports$1, {
  getPow: () => getPow$1,
  minePow: () => minePow$1
});
function getPow$1(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$1(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash$1(ur), getPow$1(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$1 = {};
__export$1(nip18_exports$1, {
  finishRepostEvent: () => finishRepostEvent$1,
  getRepostedEvent: () => getRepostedEvent$1,
  getRepostedEventPointer: () => getRepostedEventPointer$1
});
function finishRepostEvent$1(lr, ar, cr, ur) {
  var fr;
  return finishEvent(
    {
      kind: 6,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$1(lr) {
  if (lr.kind !== 6)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent$1(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer$1(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifySignature(ur)))
    return ur;
}
var nip21_exports$1 = {};
__export$1(nip21_exports$1, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$1,
  parse: () => parse2$1,
  test: () => test$1
});
var NOSTR_URI_REGEX$1 = new RegExp(`nostr:(${BECH32_REGEX$1.source})`);
function test$1(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX$1.source}$`).test(lr);
}
function parse2$1(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX$1.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$2(ar[1])
  };
}
var nip25_exports$1 = {};
__export$1(nip25_exports$1, {
  finishReactionEvent: () => finishReactionEvent$1,
  getReactedEventPointer: () => getReactedEventPointer$1
});
function finishReactionEvent$1(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((hr) => hr.length >= 2 && (hr[0] === "e" || hr[0] === "p"));
  return finishEvent(
    {
      ...lr,
      kind: 7,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer$1(lr) {
  if (lr.kind !== 7)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip26_exports = {};
__export$1(nip26_exports, {
  createDelegation: () => createDelegation,
  getDelegator: () => getDelegator
});
function createDelegation(lr, ar) {
  let cr = [];
  (ar.kind || -1) >= 0 && cr.push(`kind=${ar.kind}`), ar.until && cr.push(`created_at<${ar.until}`), ar.since && cr.push(`created_at>${ar.since}`);
  let ur = cr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let fr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), dr = bytesToHex$2(schnorr$1.sign(fr, lr));
  return {
    from: getPublicKey(lr),
    to: ar.pubkey,
    cond: ur,
    sig: dr
  };
}
function getDelegator(lr) {
  let ar = lr.tags.find((gr) => gr[0] === "delegation" && gr.length >= 4);
  if (!ar)
    return null;
  let cr = ar[1], ur = ar[2], fr = ar[3], dr = ur.split("&");
  for (let gr = 0; gr < dr.length; gr++) {
    let [vr, mr, br] = dr[gr].split(/\b/);
    if (!(vr === "kind" && mr === "=" && lr.kind === parseInt(br))) {
      if (vr === "created_at" && mr === "<" && lr.created_at < parseInt(br))
        continue;
      if (vr === "created_at" && mr === ">" && lr.created_at > parseInt(br))
        continue;
      return null;
    }
  }
  let hr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${lr.pubkey}:${ur}`));
  return schnorr$1.verify(fr, hr, cr) ? cr : null;
}
var nip27_exports$1 = {};
__export$1(nip27_exports$1, {
  matchAll: () => matchAll$1,
  regex: () => regex$1,
  replaceAll: () => replaceAll$1
});
var regex$1 = () => new RegExp(`\\b${NOSTR_URI_REGEX$1.source}\\b`, "g");
function* matchAll$1(lr) {
  const ar = lr.matchAll(regex$1());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$2(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$1(lr, ar) {
  return lr.replaceAll(regex$1(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$2(ur)
  }));
}
var nip28_exports$1 = {};
__export$1(nip28_exports$1, {
  channelCreateEvent: () => channelCreateEvent$1,
  channelHideMessageEvent: () => channelHideMessageEvent$1,
  channelMessageEvent: () => channelMessageEvent$1,
  channelMetadataEvent: () => channelMetadataEvent$1,
  channelMuteUserEvent: () => channelMuteUserEvent$1
});
var channelCreateEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 40,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 41,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent$1 = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finishEvent(
    {
      kind: 42,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 43,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 44,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip39_exports$1 = {};
__export$1(nip39_exports$1, {
  useFetchImplementation: () => useFetchImplementation2$1,
  validateGithub: () => validateGithub$1
});
var _fetch2$1;
try {
  _fetch2$1 = fetch;
} catch (lr) {
}
function useFetchImplementation2$1(lr) {
  _fetch2$1 = lr;
}
async function validateGithub$1(lr, ar, cr) {
  try {
    return await (await _fetch2$1(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$1 = {};
__export$1(nip42_exports$1, {
  authenticate: () => authenticate
});
var authenticate = async ({
  challenge: lr,
  relay: ar,
  sign: cr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", lr]
    ],
    content: ""
  };
  return ar.auth(await cr(ur));
}, nip44_exports$1 = {};
__export$1(nip44_exports$1, {
  decrypt: () => decrypt2$1,
  encrypt: () => encrypt2$1,
  utils: () => utils$1
});
var utils$1 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(lr, ar) {
      return secp256k1$1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(lr, ar) {
      const cr = hkdf(sha256$2, lr, ar, "nip44-v2", 76);
      return {
        encryption: cr.subarray(0, 32),
        nonce: cr.subarray(32, 44),
        auth: cr.subarray(44, 76)
      };
    },
    calcPadding(lr) {
      if (!Number.isSafeInteger(lr) || lr < 0)
        throw new Error("expected positive integer");
      if (lr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
      return cr * (Math.floor((lr - 1) / cr) + 1);
    },
    pad(lr) {
      const ar = utf8Encoder$1.encode(lr), cr = ar.length;
      if (cr < 1 || cr >= utils$1.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$1.v2.calcPadding(cr), fr = new Uint8Array(ur - cr), dr = new Uint8Array(2);
      return new DataView(dr.buffer).setUint16(0, cr), concatBytes$3(dr, ar, fr);
    },
    unpad(lr) {
      const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
      if (ar === 0 || cr.length !== ar || lr.length !== 2 + utils$1.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$1.decode(cr);
    }
  }
};
function encrypt2$1(lr, ar, cr = {}) {
  var mr, br;
  const ur = (mr = cr.version) != null ? mr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const fr = (br = cr.salt) != null ? br : randomBytes$2(32);
  ensureBytes$1(fr, 32);
  const dr = utils$1.v2.getMessageKeys(lr, fr), hr = utils$1.v2.pad(ar), gr = chacha20(dr.encryption, dr.nonce, hr), vr = hmac$2(sha256$2, dr.auth, gr);
  return base64$1.encode(concatBytes$3(new Uint8Array([ur]), fr, gr, vr));
}
function decrypt2$1(lr, ar) {
  const cr = utils$1.v2;
  ensureBytes$1(lr, 32);
  const ur = ar.length;
  if (ur < cr.minCiphertextSize || ur >= cr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let fr;
  try {
    fr = base64$1.decode(ar);
  } catch (kr) {
    throw new Error("invalid base64: " + kr.message);
  }
  const dr = fr.subarray(0, 1)[0];
  if (dr !== 2)
    throw new Error("unknown encryption version " + dr);
  const hr = fr.subarray(1, 33), gr = fr.subarray(33, -32), vr = fr.subarray(-32), mr = cr.getMessageKeys(lr, hr), br = hmac$2(sha256$2, mr.auth, gr);
  if (!equalBytes$1(br, vr))
    throw new Error("invalid MAC");
  const yr = chacha20(mr.encryption, mr.nonce, gr);
  return cr.unpad(yr);
}
var nip47_exports$1 = {};
__export$1(nip47_exports$1, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$1,
  parseConnectionString: () => parseConnectionString$1
});
function parseConnectionString$1(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent$1({
  pubkey: lr,
  secret: ar,
  invoice: cr
}) {
  const fr = await encrypt$1(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finishEvent(dr, ar);
}
var nip57_exports$1 = {};
__export$1(nip57_exports$1, {
  getZapEndpoint: () => getZapEndpoint$1,
  makeZapReceipt: () => makeZapReceipt$1,
  makeZapRequest: () => makeZapRequest$1,
  useFetchImplementation: () => useFetchImplementation3$1,
  validateZapRequest: () => validateZapRequest$1
});
var _fetch3$1;
try {
  _fetch3$1 = fetch;
} catch (lr) {
}
function useFetchImplementation3$1(lr) {
  _fetch3$1 = lr;
}
async function getZapEndpoint$1(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: hr } = bech32$2.decode(cr, 1e3), gr = bech32$2.fromWords(hr);
      ar = utf8Decoder$1.decode(gr);
    } else if (ur) {
      let [hr, gr] = ur.split("@");
      ar = `https://${gr}/.well-known/lnurlp/${hr}`;
    } else
      return null;
    let dr = await (await _fetch3$1(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$1({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest$1(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$1(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, hr]) => dr === "p" && hr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, hr]) => dr === "e" && hr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, hr]) => dr === "relays" && hr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$1({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let dr = JSON.parse(lr).tags.filter(([gr]) => gr === "e" || gr === "p" || gr === "a"), hr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["bolt11", cr], ["description", lr]]
  };
  return ar && hr.tags.push(["preimage", ar]), hr;
}
var nip98_exports$1 = {};
__export$1(nip98_exports$1, {
  getToken: () => getToken$1,
  unpackEventFromToken: () => unpackEventFromToken$1,
  validateEvent: () => validateEvent2$1,
  validateToken: () => validateToken$1
});
var _authorizationScheme$1 = "Nostr ";
async function getToken$1(lr, ar, cr, ur = !1) {
  if (!lr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const fr = getBlankEvent(
    27235
    /* HttpAuth */
  );
  fr.tags = [
    ["u", lr],
    ["method", ar]
  ], fr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const dr = await cr(fr);
  return (ur ? _authorizationScheme$1 : "") + base64$1.encode(utf8Encoder$1.encode(JSON.stringify(dr)));
}
async function validateToken$1(lr, ar, cr) {
  const ur = await unpackEventFromToken$1(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2$1(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken$1(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme$1, "");
  const ar = utf8Decoder$1.decode(base64$1.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$1(lr, ar, cr) {
  if (!lr)
    throw new Error("Invalid nostr event");
  if (!verifySignature(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (lr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!lr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = lr.tags.find((dr) => dr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const fr = lr.tags.find((dr) => dr[0] === "method");
  if ((fr == null ? void 0 : fr.length) !== 1 && (fr == null ? void 0 : fr[1].toLowerCase()) !== cr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
const e = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : global, t = Object.keys, n = Array.isArray;
function r(lr, ar) {
  return typeof ar != "object" || t(ar).forEach(function(cr) {
    lr[cr] = ar[cr];
  }), lr;
}
typeof Promise == "undefined" || e.Promise || (e.Promise = Promise);
const s = Object.getPrototypeOf, i$1 = {}.hasOwnProperty;
function o(lr, ar) {
  return i$1.call(lr, ar);
}
function a(lr, ar) {
  typeof ar == "function" && (ar = ar(s(lr))), (typeof Reflect == "undefined" ? t : Reflect.ownKeys)(ar).forEach((cr) => {
    l(lr, cr, ar[cr]);
  });
}
const u$1 = Object.defineProperty;
function l(lr, ar, cr, ur) {
  u$1(lr, ar, r(cr && o(cr, "get") && typeof cr.get == "function" ? { get: cr.get, set: cr.set, configurable: !0 } : { value: cr, configurable: !0, writable: !0 }, ur));
}
function c(lr) {
  return { from: function(ar) {
    return lr.prototype = Object.create(ar.prototype), l(lr.prototype, "constructor", lr), { extend: a.bind(null, lr.prototype) };
  } };
}
const h$1 = Object.getOwnPropertyDescriptor;
function d(lr, ar) {
  let cr;
  return h$1(lr, ar) || (cr = s(lr)) && d(cr, ar);
}
const f = [].slice;
function p(lr, ar, cr) {
  return f.call(lr, ar, cr);
}
function y(lr, ar) {
  return ar(lr);
}
function m(lr) {
  if (!lr)
    throw new Error("Assertion Failed");
}
function v(lr) {
  e.setImmediate ? setImmediate(lr) : setTimeout(lr, 0);
}
function g(lr, ar) {
  return lr.reduce((cr, ur, fr) => {
    var dr = ar(ur, fr);
    return dr && (cr[dr[0]] = dr[1]), cr;
  }, {});
}
function b(lr, ar) {
  if (o(lr, ar))
    return lr[ar];
  if (!ar)
    return lr;
  if (typeof ar != "string") {
    for (var cr = [], ur = 0, fr = ar.length; ur < fr; ++ur) {
      var dr = b(lr, ar[ur]);
      cr.push(dr);
    }
    return cr;
  }
  var hr = ar.indexOf(".");
  if (hr !== -1) {
    var gr = lr[ar.substr(0, hr)];
    return gr === void 0 ? void 0 : b(gr, ar.substr(hr + 1));
  }
}
function _(lr, ar, cr) {
  if (lr && ar !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(lr)))
    if (typeof ar != "string" && "length" in ar) {
      m(typeof cr != "string" && "length" in cr);
      for (var ur = 0, fr = ar.length; ur < fr; ++ur)
        _(lr, ar[ur], cr[ur]);
    } else {
      var dr = ar.indexOf(".");
      if (dr !== -1) {
        var hr = ar.substr(0, dr), gr = ar.substr(dr + 1);
        if (gr === "")
          cr === void 0 ? n(lr) && !isNaN(parseInt(hr)) ? lr.splice(hr, 1) : delete lr[hr] : lr[hr] = cr;
        else {
          var vr = lr[hr];
          vr && o(lr, hr) || (vr = lr[hr] = {}), _(vr, gr, cr);
        }
      } else
        cr === void 0 ? n(lr) && !isNaN(parseInt(ar)) ? lr.splice(ar, 1) : delete lr[ar] : lr[ar] = cr;
    }
}
function w(lr) {
  var ar = {};
  for (var cr in lr)
    o(lr, cr) && (ar[cr] = lr[cr]);
  return ar;
}
const x = [].concat;
function k(lr) {
  return x.apply([], lr);
}
const E = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k([8, 16, 32, 64].map((lr) => ["Int", "Uint", "Float"].map((ar) => ar + lr + "Array")))).filter((lr) => e[lr]), P = E.map((lr) => e[lr]);
g(E, (lr) => [lr, !0]);
let K = null;
function O(lr) {
  K = typeof WeakMap != "undefined" && /* @__PURE__ */ new WeakMap();
  const ar = S(lr);
  return K = null, ar;
}
function S(lr) {
  if (!lr || typeof lr != "object")
    return lr;
  let ar = K && K.get(lr);
  if (ar)
    return ar;
  if (n(lr)) {
    ar = [], K && K.set(lr, ar);
    for (var cr = 0, ur = lr.length; cr < ur; ++cr)
      ar.push(S(lr[cr]));
  } else if (P.indexOf(lr.constructor) >= 0)
    ar = lr;
  else {
    const dr = s(lr);
    for (var fr in ar = dr === Object.prototype ? {} : Object.create(dr), K && K.set(lr, ar), lr)
      o(lr, fr) && (ar[fr] = S(lr[fr]));
  }
  return ar;
}
const { toString: A } = {};
function C(lr) {
  return A.call(lr).slice(8, -1);
}
const j = typeof Symbol != "undefined" ? Symbol.iterator : "@@iterator", D = typeof j == "symbol" ? function(lr) {
  var ar;
  return lr != null && (ar = lr[j]) && ar.apply(lr);
} : function() {
  return null;
}, I = {};
function B(lr) {
  var ar, cr, ur, fr;
  if (arguments.length === 1) {
    if (n(lr))
      return lr.slice();
    if (this === I && typeof lr == "string")
      return [lr];
    if (fr = D(lr)) {
      for (cr = []; !(ur = fr.next()).done; )
        cr.push(ur.value);
      return cr;
    }
    if (lr == null)
      return [lr];
    if (typeof (ar = lr.length) == "number") {
      for (cr = new Array(ar); ar--; )
        cr[ar] = lr[ar];
      return cr;
    }
    return [lr];
  }
  for (ar = arguments.length, cr = new Array(ar); ar--; )
    cr[ar] = arguments[ar];
  return cr;
}
const T = typeof Symbol != "undefined" ? (lr) => lr[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var R = typeof location != "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function F(lr, ar) {
  R = lr, M = ar;
}
var M = () => !0;
const N = !new Error("").stack;
function q() {
  if (N)
    try {
      throw q.arguments, new Error();
    } catch (lr) {
      return lr;
    }
  return new Error();
}
function $(lr, ar) {
  var cr = lr.stack;
  return cr ? (ar = ar || 0, cr.indexOf(lr.name) === 0 && (ar += (lr.name + lr.message).split(`
`).length), cr.split(`
`).slice(ar).filter(M).map((ur) => `
` + ur).join("")) : "";
}
var U = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], L = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(U), V = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function W(lr, ar) {
  this._e = q(), this.name = lr, this.message = ar;
}
function Y(lr, ar) {
  return lr + ". Errors: " + Object.keys(ar).map((cr) => ar[cr].toString()).filter((cr, ur, fr) => fr.indexOf(cr) === ur).join(`
`);
}
function z(lr, ar, cr, ur) {
  this._e = q(), this.failures = ar, this.failedKeys = ur, this.successCount = cr, this.message = Y(lr, ar);
}
function G(lr, ar) {
  this._e = q(), this.name = "BulkError", this.failures = Object.keys(ar).map((cr) => ar[cr]), this.failuresByPos = ar, this.message = Y(lr, ar);
}
c(W).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), c(z).from(W), c(G).from(W);
var H = L.reduce((lr, ar) => (lr[ar] = ar + "Error", lr), {});
const Q = W;
var X = L.reduce((lr, ar) => {
  var cr = ar + "Error";
  function ur(fr, dr) {
    this._e = q(), this.name = cr, fr ? typeof fr == "string" ? (this.message = `${fr}${dr ? `
 ` + dr : ""}`, this.inner = dr || null) : typeof fr == "object" && (this.message = `${fr.name} ${fr.message}`, this.inner = fr) : (this.message = V[ar] || cr, this.inner = null);
  }
  return c(ur).from(Q), lr[ar] = ur, lr;
}, {});
X.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;
var J = U.reduce((lr, ar) => (lr[ar + "Error"] = X[ar], lr), {}), Z = L.reduce((lr, ar) => (["Syntax", "Type", "Range"].indexOf(ar) === -1 && (lr[ar + "Error"] = X[ar]), lr), {});
function ee$1() {
}
function te(lr) {
  return lr;
}
function ne$1(lr, ar) {
  return lr == null || lr === te ? ar : function(cr) {
    return ar(lr(cr));
  };
}
function re(lr, ar) {
  return function() {
    lr.apply(this, arguments), ar.apply(this, arguments);
  };
}
function se(lr, ar) {
  return lr === ee$1 ? ar : function() {
    var cr = lr.apply(this, arguments);
    cr !== void 0 && (arguments[0] = cr);
    var ur = this.onsuccess, fr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var dr = ar.apply(this, arguments);
    return ur && (this.onsuccess = this.onsuccess ? re(ur, this.onsuccess) : ur), fr && (this.onerror = this.onerror ? re(fr, this.onerror) : fr), dr !== void 0 ? dr : cr;
  };
}
function ie(lr, ar) {
  return lr === ee$1 ? ar : function() {
    lr.apply(this, arguments);
    var cr = this.onsuccess, ur = this.onerror;
    this.onsuccess = this.onerror = null, ar.apply(this, arguments), cr && (this.onsuccess = this.onsuccess ? re(cr, this.onsuccess) : cr), ur && (this.onerror = this.onerror ? re(ur, this.onerror) : ur);
  };
}
function oe(lr, ar) {
  return lr === ee$1 ? ar : function(cr) {
    var ur = lr.apply(this, arguments);
    r(cr, ur);
    var fr = this.onsuccess, dr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var hr = ar.apply(this, arguments);
    return fr && (this.onsuccess = this.onsuccess ? re(fr, this.onsuccess) : fr), dr && (this.onerror = this.onerror ? re(dr, this.onerror) : dr), ur === void 0 ? hr === void 0 ? void 0 : hr : r(ur, hr);
  };
}
function ae(lr, ar) {
  return lr === ee$1 ? ar : function() {
    return ar.apply(this, arguments) !== !1 && lr.apply(this, arguments);
  };
}
function ue(lr, ar) {
  return lr === ee$1 ? ar : function() {
    var cr = lr.apply(this, arguments);
    if (cr && typeof cr.then == "function") {
      for (var ur = this, fr = arguments.length, dr = new Array(fr); fr--; )
        dr[fr] = arguments[fr];
      return cr.then(function() {
        return ar.apply(ur, dr);
      });
    }
    return ar.apply(this, arguments);
  };
}
Z.ModifyError = z, Z.DexieError = W, Z.BulkError = G;
var le$1 = {};
const ce = 100, [he, de, fe$1] = typeof Promise == "undefined" ? [] : (() => {
  let lr = Promise.resolve();
  if (typeof crypto == "undefined" || !crypto.subtle)
    return [lr, s(lr), lr];
  const ar = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [ar, s(ar), lr];
})(), pe = de && de.then, ye = he && he.constructor, me = !!fe$1;
var ve = !1, ge$2 = fe$1 ? () => {
  fe$1.then($e);
} : e.setImmediate ? setImmediate.bind(null, $e) : e.MutationObserver ? () => {
  var lr = document.createElement("div");
  new MutationObserver(() => {
    $e(), lr = null;
  }).observe(lr, { attributes: !0 }), lr.setAttribute("i", "1");
} : () => {
  setTimeout($e, 0);
}, be = function(lr, ar) {
  Se.push([lr, ar]), we && (ge$2(), we = !1);
}, _e = !0, we = !0, xe = [], ke = [], Ee = null, Pe = te, Ke = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: dt, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((lr) => {
    try {
      dt(lr[0], lr[1]);
    } catch (ar) {
    }
  });
} }, Oe = Ke, Se = [], Ae = 0, Ce = [];
function je(lr) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = ee$1, this._lib = !1;
  var ar = this._PSD = Oe;
  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), typeof lr != "function") {
    if (lr !== le$1)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Te(this, this._value));
  }
  this._state = null, this._value = null, ++ar.ref, Be(this, lr);
}
const De = { get: function() {
  var lr = Oe, ar = Xe;
  function cr(ur, fr) {
    var dr = !lr.global && (lr !== Oe || ar !== Xe);
    const hr = dr && !tt();
    var gr = new je((vr, mr) => {
      Fe(this, new Ie(lt$3(ur, lr, dr, hr), lt$3(fr, lr, dr, hr), vr, mr, lr));
    });
    return R && qe(gr, this), gr;
  }
  return cr.prototype = le$1, cr;
}, set: function(lr) {
  l(this, "then", lr && lr.prototype === le$1 ? De : { get: function() {
    return lr;
  }, set: De.set });
} };
function Ie(lr, ar, cr, ur, fr) {
  this.onFulfilled = typeof lr == "function" ? lr : null, this.onRejected = typeof ar == "function" ? ar : null, this.resolve = cr, this.reject = ur, this.psd = fr;
}
function Be(lr, ar) {
  try {
    ar((cr) => {
      if (lr._state === null) {
        if (cr === lr)
          throw new TypeError("A promise cannot be resolved with itself.");
        var ur = lr._lib && Ue();
        cr && typeof cr.then == "function" ? Be(lr, (fr, dr) => {
          cr instanceof je ? cr._then(fr, dr) : cr.then(fr, dr);
        }) : (lr._state = !0, lr._value = cr, Re$1(lr)), ur && Le();
      }
    }, Te.bind(null, lr));
  } catch (cr) {
    Te(lr, cr);
  }
}
function Te(lr, ar) {
  if (ke.push(ar), lr._state === null) {
    var cr = lr._lib && Ue();
    ar = Pe(ar), lr._state = !1, lr._value = ar, R && ar !== null && typeof ar == "object" && !ar._promise && function(ur, fr, dr) {
      try {
        ur.apply(null, dr);
      } catch (hr) {
        fr && fr(hr);
      }
    }(() => {
      var ur = d(ar, "stack");
      ar._promise = lr, l(ar, "stack", { get: () => ve ? ur && (ur.get ? ur.get.apply(ar) : ur.value) : lr.stack });
    }), function(ur) {
      xe.some((fr) => fr._value === ur._value) || xe.push(ur);
    }(lr), Re$1(lr), cr && Le();
  }
}
function Re$1(lr) {
  var ar = lr._listeners;
  lr._listeners = [];
  for (var cr = 0, ur = ar.length; cr < ur; ++cr)
    Fe(lr, ar[cr]);
  var fr = lr._PSD;
  --fr.ref || fr.finalize(), Ae === 0 && (++Ae, be(() => {
    --Ae == 0 && Ve();
  }, []));
}
function Fe(lr, ar) {
  if (lr._state !== null) {
    var cr = lr._state ? ar.onFulfilled : ar.onRejected;
    if (cr === null)
      return (lr._state ? ar.resolve : ar.reject)(lr._value);
    ++ar.psd.ref, ++Ae, be(Me, [cr, lr, ar]);
  } else
    lr._listeners.push(ar);
}
function Me(lr, ar, cr) {
  try {
    Ee = ar;
    var ur, fr = ar._value;
    ar._state ? ur = lr(fr) : (ke.length && (ke = []), ur = lr(fr), ke.indexOf(fr) === -1 && function(dr) {
      for (var hr = xe.length; hr; )
        if (xe[--hr]._value === dr._value)
          return void xe.splice(hr, 1);
    }(ar)), cr.resolve(ur);
  } catch (dr) {
    cr.reject(dr);
  } finally {
    Ee = null, --Ae == 0 && Ve(), --cr.psd.ref || cr.psd.finalize();
  }
}
function Ne(lr, ar, cr) {
  if (ar.length === cr)
    return ar;
  var ur = "";
  if (lr._state === !1) {
    var fr, dr, hr = lr._value;
    hr != null ? (fr = hr.name || "Error", dr = hr.message || hr, ur = $(hr, 0)) : (fr = hr, dr = ""), ar.push(fr + (dr ? ": " + dr : "") + ur);
  }
  return R && ((ur = $(lr._stackHolder, 2)) && ar.indexOf(ur) === -1 && ar.push(ur), lr._prev && Ne(lr._prev, ar, cr)), ar;
}
function qe(lr, ar) {
  var cr = ar ? ar._numPrev + 1 : 0;
  cr < 100 && (lr._prev = ar, lr._numPrev = cr);
}
function $e() {
  Ue() && Le();
}
function Ue() {
  var lr = _e;
  return _e = !1, we = !1, lr;
}
function Le() {
  var lr, ar, cr;
  do
    for (; Se.length > 0; )
      for (lr = Se, Se = [], cr = lr.length, ar = 0; ar < cr; ++ar) {
        var ur = lr[ar];
        ur[0].apply(null, ur[1]);
      }
  while (Se.length > 0);
  _e = !0, we = !0;
}
function Ve() {
  var lr = xe;
  xe = [], lr.forEach((ur) => {
    ur._PSD.onunhandled.call(null, ur._value, ur);
  });
  for (var ar = Ce.slice(0), cr = ar.length; cr; )
    ar[--cr]();
}
function We(lr) {
  return new je(le$1, !1, lr);
}
function Ye(lr, ar) {
  var cr = Oe;
  return function() {
    var ur = Ue(), fr = Oe;
    try {
      return it$1(cr, !0), lr.apply(this, arguments);
    } catch (dr) {
      ar && ar(dr);
    } finally {
      it$1(fr, !1), ur && Le();
    }
  };
}
a(je.prototype, { then: De, _then: function(lr, ar) {
  Fe(this, new Ie(null, null, lr, ar, Oe));
}, catch: function(lr) {
  if (arguments.length === 1)
    return this.then(null, lr);
  var ar = arguments[0], cr = arguments[1];
  return typeof ar == "function" ? this.then(null, (ur) => ur instanceof ar ? cr(ur) : We(ur)) : this.then(null, (ur) => ur && ur.name === ar ? cr(ur) : We(ur));
}, finally: function(lr) {
  return this.then((ar) => (lr(), ar), (ar) => (lr(), We(ar)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    ve = !0;
    var lr = Ne(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = lr), lr;
  } finally {
    ve = !1;
  }
} }, timeout: function(lr, ar) {
  return lr < 1 / 0 ? new je((cr, ur) => {
    var fr = setTimeout(() => ur(new X.Timeout(ar)), lr);
    this.then(cr, ur).finally(clearTimeout.bind(null, fr));
  }) : this;
} }), typeof Symbol != "undefined" && Symbol.toStringTag && l(je.prototype, Symbol.toStringTag, "Dexie.Promise"), Ke.env = ot(), a(je, { all: function() {
  var lr = B.apply(null, arguments).map(nt);
  return new je(function(ar, cr) {
    lr.length === 0 && ar([]);
    var ur = lr.length;
    lr.forEach((fr, dr) => je.resolve(fr).then((hr) => {
      lr[dr] = hr, --ur || ar(lr);
    }, cr));
  });
}, resolve: (lr) => {
  if (lr instanceof je)
    return lr;
  if (lr && typeof lr.then == "function")
    return new je((cr, ur) => {
      lr.then(cr, ur);
    });
  var ar = new je(le$1, !0, lr);
  return qe(ar, Ee), ar;
}, reject: We, race: function() {
  var lr = B.apply(null, arguments).map(nt);
  return new je((ar, cr) => {
    lr.map((ur) => je.resolve(ur).then(ar, cr));
  });
}, PSD: { get: () => Oe, set: (lr) => Oe = lr }, totalEchoes: { get: () => Xe }, newPSD: Ze, usePSD: at, scheduler: { get: () => be, set: (lr) => {
  be = lr;
} }, rejectionMapper: { get: () => Pe, set: (lr) => {
  Pe = lr;
} }, follow: (lr, ar) => new je((cr, ur) => Ze((fr, dr) => {
  var hr = Oe;
  hr.unhandleds = [], hr.onunhandled = dr, hr.finalize = re(function() {
    (function(gr) {
      function vr() {
        gr(), Ce.splice(Ce.indexOf(vr), 1);
      }
      Ce.push(vr), ++Ae, be(() => {
        --Ae == 0 && Ve();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? fr() : dr(this.unhandleds[0]);
    });
  }, hr.finalize), lr();
}, ar, cr, ur)) }), ye && (ye.allSettled && l(je, "allSettled", function() {
  const lr = B.apply(null, arguments).map(nt);
  return new je((ar) => {
    lr.length === 0 && ar([]);
    let cr = lr.length;
    const ur = new Array(cr);
    lr.forEach((fr, dr) => je.resolve(fr).then((hr) => ur[dr] = { status: "fulfilled", value: hr }, (hr) => ur[dr] = { status: "rejected", reason: hr }).then(() => --cr || ar(ur)));
  });
}), ye.any && typeof AggregateError != "undefined" && l(je, "any", function() {
  const lr = B.apply(null, arguments).map(nt);
  return new je((ar, cr) => {
    lr.length === 0 && cr(new AggregateError([]));
    let ur = lr.length;
    const fr = new Array(ur);
    lr.forEach((dr, hr) => je.resolve(dr).then((gr) => ar(gr), (gr) => {
      fr[hr] = gr, --ur || cr(new AggregateError(fr));
    }));
  });
}));
const ze = { awaits: 0, echoes: 0, id: 0 };
var Ge = 0, He = [], Qe = 0, Xe = 0, Je = 0;
function Ze(lr, ar, cr, ur) {
  var fr = Oe, dr = Object.create(fr);
  dr.parent = fr, dr.ref = 0, dr.global = !1, dr.id = ++Je;
  var hr = Ke.env;
  dr.env = me ? { Promise: je, PromiseProp: { value: je, configurable: !0, writable: !0 }, all: je.all, race: je.race, allSettled: je.allSettled, any: je.any, resolve: je.resolve, reject: je.reject, nthen: ct(hr.nthen, dr), gthen: ct(hr.gthen, dr) } : {}, ar && r(dr, ar), ++fr.ref, dr.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var gr = at(dr, lr, cr, ur);
  return dr.ref === 0 && dr.finalize(), gr;
}
function et() {
  return ze.id || (ze.id = ++Ge), ++ze.awaits, ze.echoes += ce, ze.id;
}
function tt() {
  return !!ze.awaits && (--ze.awaits == 0 && (ze.id = 0), ze.echoes = ze.awaits * ce, !0);
}
function nt(lr) {
  return ze.echoes && lr && lr.constructor === ye ? (et(), lr.then((ar) => (tt(), ar), (ar) => (tt(), ft(ar)))) : lr;
}
function rt(lr) {
  ++Xe, ze.echoes && --ze.echoes != 0 || (ze.echoes = ze.id = 0), He.push(Oe), it$1(lr, !0);
}
function st() {
  var lr = He[He.length - 1];
  He.pop(), it$1(lr, !1);
}
function it$1(lr, ar) {
  var cr = Oe;
  if ((ar ? !ze.echoes || Qe++ && lr === Oe : !Qe || --Qe && lr === Oe) || ut$1(ar ? rt.bind(null, lr) : st), lr !== Oe && (Oe = lr, cr === Ke && (Ke.env = ot()), me)) {
    var ur = Ke.env.Promise, fr = lr.env;
    de.then = fr.nthen, ur.prototype.then = fr.gthen, (cr.global || lr.global) && (Object.defineProperty(e, "Promise", fr.PromiseProp), ur.all = fr.all, ur.race = fr.race, ur.resolve = fr.resolve, ur.reject = fr.reject, fr.allSettled && (ur.allSettled = fr.allSettled), fr.any && (ur.any = fr.any));
  }
}
function ot() {
  var lr = e.Promise;
  return me ? { Promise: lr, PromiseProp: Object.getOwnPropertyDescriptor(e, "Promise"), all: lr.all, race: lr.race, allSettled: lr.allSettled, any: lr.any, resolve: lr.resolve, reject: lr.reject, nthen: de.then, gthen: lr.prototype.then } : {};
}
function at(lr, ar, cr, ur, fr) {
  var dr = Oe;
  try {
    return it$1(lr, !0), ar(cr, ur, fr);
  } finally {
    it$1(dr, !1);
  }
}
function ut$1(lr) {
  pe.call(he, lr);
}
function lt$3(lr, ar, cr, ur) {
  return typeof lr != "function" ? lr : function() {
    var fr = Oe;
    cr && et(), it$1(ar, !0);
    try {
      return lr.apply(this, arguments);
    } finally {
      it$1(fr, !1), ur && ut$1(tt);
    }
  };
}
function ct(lr, ar) {
  return function(cr, ur) {
    return lr.call(this, lt$3(cr, ar), lt$3(ur, ar));
  };
}
("" + pe).indexOf("[native code]") === -1 && (et = tt = ee$1);
const ht = "unhandledrejection";
function dt(lr, ar) {
  var cr;
  try {
    cr = ar.onuncatched(lr);
  } catch (dr) {
  }
  if (cr !== !1)
    try {
      var ur, fr = { promise: ar, reason: lr };
      if (e.document && document.createEvent ? ((ur = document.createEvent("Event")).initEvent(ht, !0, !0), r(ur, fr)) : e.CustomEvent && r(ur = new CustomEvent(ht, { detail: fr }), fr), ur && e.dispatchEvent && (dispatchEvent(ur), !e.PromiseRejectionEvent && e.onunhandledrejection))
        try {
          e.onunhandledrejection(ur);
        } catch (dr) {
        }
      R && ur && !ur.defaultPrevented && console.warn(`Unhandled rejection: ${lr.stack || lr}`);
    } catch (dr) {
    }
}
var ft = je.reject;
function pt(lr, ar, cr, ur) {
  if (lr.idbdb && (lr._state.openComplete || Oe.letThrough || lr._vip)) {
    var fr = lr._createTransaction(ar, cr, lr._dbSchema);
    try {
      fr.create(), lr._state.PR1398_maxLoop = 3;
    } catch (dr) {
      return dr.name === H.InvalidState && lr.isOpen() && --lr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), lr._close(), lr.open().then(() => pt(lr, ar, cr, ur))) : ft(dr);
    }
    return fr._promise(ar, (dr, hr) => Ze(() => (Oe.trans = fr, ur(dr, hr, fr)))).then((dr) => fr._completion.then(() => dr));
  }
  if (lr._state.openComplete)
    return ft(new X.DatabaseClosed(lr._state.dbOpenError));
  if (!lr._state.isBeingOpened) {
    if (!lr._options.autoOpen)
      return ft(new X.DatabaseClosed());
    lr.open().catch(ee$1);
  }
  return lr._state.dbReadyPromise.then(() => pt(lr, ar, cr, ur));
}
const yt = "3.2.4", mt = String.fromCharCode(65535), vt = -1 / 0, gt$3 = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", bt = "String expected.", _t = [], wt = typeof navigator != "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), xt = wt, kt = wt, Et = (lr) => !/(dexie\.js|dexie\.min\.js)/.test(lr), Pt = "__dbnames", Kt = "readonly", Ot = "readwrite";
function St(lr, ar) {
  return lr ? ar ? function() {
    return lr.apply(this, arguments) && ar.apply(this, arguments);
  } : lr : ar;
}
const At = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Ct(lr) {
  return typeof lr != "string" || /\./.test(lr) ? (ar) => ar : (ar) => (ar[lr] === void 0 && lr in ar && delete (ar = O(ar))[lr], ar);
}
class jt {
  _trans(ar, cr, ur) {
    const fr = this._tx || Oe.trans, dr = this.name;
    function hr(vr, mr, br) {
      if (!br.schema[dr])
        throw new X.NotFound("Table " + dr + " not part of transaction");
      return cr(br.idbtrans, br);
    }
    const gr = Ue();
    try {
      return fr && fr.db === this.db ? fr === Oe.trans ? fr._promise(ar, hr, ur) : Ze(() => fr._promise(ar, hr, ur), { trans: fr, transless: Oe.transless || Oe }) : pt(this.db, ar, [this.name], hr);
    } finally {
      gr && Le();
    }
  }
  get(ar, cr) {
    return ar && ar.constructor === Object ? this.where(ar).first(cr) : this._trans("readonly", (ur) => this.core.get({ trans: ur, key: ar }).then((fr) => this.hook.reading.fire(fr))).then(cr);
  }
  where(ar) {
    if (typeof ar == "string")
      return new this.db.WhereClause(this, ar);
    if (n(ar))
      return new this.db.WhereClause(this, `[${ar.join("+")}]`);
    const cr = t(ar);
    if (cr.length === 1)
      return this.where(cr[0]).equals(ar[cr[0]]);
    const ur = this.schema.indexes.concat(this.schema.primKey).filter((mr) => mr.compound && cr.every((br) => mr.keyPath.indexOf(br) >= 0) && mr.keyPath.every((br) => cr.indexOf(br) >= 0))[0];
    if (ur && this.db._maxKey !== mt)
      return this.where(ur.name).equals(ur.keyPath.map((mr) => ar[mr]));
    !ur && R && console.warn(`The query ${JSON.stringify(ar)} on ${this.name} would benefit of a compound index [${cr.join("+")}]`);
    const { idxByName: fr } = this.schema, dr = this.db._deps.indexedDB;
    function hr(mr, br) {
      try {
        return dr.cmp(mr, br) === 0;
      } catch (yr) {
        return !1;
      }
    }
    const [gr, vr] = cr.reduce(([mr, br], yr) => {
      const kr = fr[yr], Tr = ar[yr];
      return [mr || kr, mr || !kr ? St(br, kr && kr.multi ? (_r) => {
        const Er = b(_r, yr);
        return n(Er) && Er.some((xr) => hr(Tr, xr));
      } : (_r) => hr(Tr, b(_r, yr))) : br];
    }, [null, null]);
    return gr ? this.where(gr.name).equals(ar[gr.keyPath]).filter(vr) : ur ? this.filter(vr) : this.where(cr).equals("");
  }
  filter(ar) {
    return this.toCollection().and(ar);
  }
  count(ar) {
    return this.toCollection().count(ar);
  }
  offset(ar) {
    return this.toCollection().offset(ar);
  }
  limit(ar) {
    return this.toCollection().limit(ar);
  }
  each(ar) {
    return this.toCollection().each(ar);
  }
  toArray(ar) {
    return this.toCollection().toArray(ar);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(ar) {
    return new this.db.Collection(new this.db.WhereClause(this, n(ar) ? `[${ar.join("+")}]` : ar));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(ar) {
    this.schema.mappedClass = ar;
    const cr = (ur) => {
      if (!ur)
        return ur;
      const fr = Object.create(ar.prototype);
      for (var dr in ur)
        if (o(ur, dr))
          try {
            fr[dr] = ur[dr];
          } catch (hr) {
          }
      return fr;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = cr, this.hook("reading", cr), ar;
  }
  defineClass() {
    return this.mapToClass(function(ar) {
      r(this, ar);
    });
  }
  add(ar, cr) {
    const { auto: ur, keyPath: fr } = this.schema.primKey;
    let dr = ar;
    return fr && ur && (dr = Ct(fr)(ar)), this._trans("readwrite", (hr) => this.core.mutate({ trans: hr, type: "add", keys: cr != null ? [cr] : null, values: [dr] })).then((hr) => hr.numFailures ? je.reject(hr.failures[0]) : hr.lastResult).then((hr) => {
      if (fr)
        try {
          _(ar, fr, hr);
        } catch (gr) {
        }
      return hr;
    });
  }
  update(ar, cr) {
    if (typeof ar != "object" || n(ar))
      return this.where(":id").equals(ar).modify(cr);
    {
      const ur = b(ar, this.schema.primKey.keyPath);
      if (ur === void 0)
        return ft(new X.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof cr != "function" ? t(cr).forEach((fr) => {
          _(ar, fr, cr[fr]);
        }) : cr(ar, { value: ar, primKey: ur });
      } catch (fr) {
      }
      return this.where(":id").equals(ur).modify(cr);
    }
  }
  put(ar, cr) {
    const { auto: ur, keyPath: fr } = this.schema.primKey;
    let dr = ar;
    return fr && ur && (dr = Ct(fr)(ar)), this._trans("readwrite", (hr) => this.core.mutate({ trans: hr, type: "put", values: [dr], keys: cr != null ? [cr] : null })).then((hr) => hr.numFailures ? je.reject(hr.failures[0]) : hr.lastResult).then((hr) => {
      if (fr)
        try {
          _(ar, fr, hr);
        } catch (gr) {
        }
      return hr;
    });
  }
  delete(ar) {
    return this._trans("readwrite", (cr) => this.core.mutate({ trans: cr, type: "delete", keys: [ar] })).then((cr) => cr.numFailures ? je.reject(cr.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (ar) => this.core.mutate({ trans: ar, type: "deleteRange", range: At })).then((ar) => ar.numFailures ? je.reject(ar.failures[0]) : void 0);
  }
  bulkGet(ar) {
    return this._trans("readonly", (cr) => this.core.getMany({ keys: ar, trans: cr }).then((ur) => ur.map((fr) => this.hook.reading.fire(fr))));
  }
  bulkAdd(ar, cr, ur) {
    const fr = Array.isArray(cr) ? cr : void 0, dr = (ur = ur || (fr ? void 0 : cr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (hr) => {
      const { auto: gr, keyPath: vr } = this.schema.primKey;
      if (vr && fr)
        throw new X.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (fr && fr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const mr = ar.length;
      let br = vr && gr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: hr, type: "add", keys: fr, values: br, wantResults: dr }).then(({ numFailures: yr, results: kr, lastResult: Tr, failures: _r }) => {
        if (yr === 0)
          return dr ? kr : Tr;
        throw new G(`${this.name}.bulkAdd(): ${yr} of ${mr} operations failed`, _r);
      });
    });
  }
  bulkPut(ar, cr, ur) {
    const fr = Array.isArray(cr) ? cr : void 0, dr = (ur = ur || (fr ? void 0 : cr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (hr) => {
      const { auto: gr, keyPath: vr } = this.schema.primKey;
      if (vr && fr)
        throw new X.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (fr && fr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const mr = ar.length;
      let br = vr && gr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: hr, type: "put", keys: fr, values: br, wantResults: dr }).then(({ numFailures: yr, results: kr, lastResult: Tr, failures: _r }) => {
        if (yr === 0)
          return dr ? kr : Tr;
        throw new G(`${this.name}.bulkPut(): ${yr} of ${mr} operations failed`, _r);
      });
    });
  }
  bulkDelete(ar) {
    const cr = ar.length;
    return this._trans("readwrite", (ur) => this.core.mutate({ trans: ur, type: "delete", keys: ar })).then(({ numFailures: ur, lastResult: fr, failures: dr }) => {
      if (ur === 0)
        return fr;
      throw new G(`${this.name}.bulkDelete(): ${ur} of ${cr} operations failed`, dr);
    });
  }
}
function Dt(lr) {
  var ar = {}, cr = function(hr, gr) {
    if (gr) {
      for (var vr = arguments.length, mr = new Array(vr - 1); --vr; )
        mr[vr - 1] = arguments[vr];
      return ar[hr].subscribe.apply(null, mr), lr;
    }
    if (typeof hr == "string")
      return ar[hr];
  };
  cr.addEventType = dr;
  for (var ur = 1, fr = arguments.length; ur < fr; ++ur)
    dr(arguments[ur]);
  return cr;
  function dr(hr, gr, vr) {
    if (typeof hr != "object") {
      var mr;
      gr || (gr = ae), vr || (vr = ee$1);
      var br = { subscribers: [], fire: vr, subscribe: function(yr) {
        br.subscribers.indexOf(yr) === -1 && (br.subscribers.push(yr), br.fire = gr(br.fire, yr));
      }, unsubscribe: function(yr) {
        br.subscribers = br.subscribers.filter(function(kr) {
          return kr !== yr;
        }), br.fire = br.subscribers.reduce(gr, vr);
      } };
      return ar[hr] = cr[hr] = br, br;
    }
    t(mr = hr).forEach(function(yr) {
      var kr = mr[yr];
      if (n(kr))
        dr(yr, mr[yr][0], mr[yr][1]);
      else {
        if (kr !== "asap")
          throw new X.InvalidArgument("Invalid event config");
        var Tr = dr(yr, te, function() {
          for (var _r = arguments.length, Er = new Array(_r); _r--; )
            Er[_r] = arguments[_r];
          Tr.subscribers.forEach(function(xr) {
            v(function() {
              xr.apply(null, Er);
            });
          });
        });
      }
    });
  }
}
function It(lr, ar) {
  return c(ar).from({ prototype: lr }), ar;
}
function Bt(lr, ar) {
  return !(lr.filter || lr.algorithm || lr.or) && (ar ? lr.justLimit : !lr.replayFilter);
}
function Tt(lr, ar) {
  lr.filter = St(lr.filter, ar);
}
function Rt(lr, ar, cr) {
  var ur = lr.replayFilter;
  lr.replayFilter = ur ? () => St(ur(), ar()) : ar, lr.justLimit = cr && !ur;
}
function Ft(lr, ar) {
  if (lr.isPrimKey)
    return ar.primaryKey;
  const cr = ar.getIndexByKeyPath(lr.index);
  if (!cr)
    throw new X.Schema("KeyPath " + lr.index + " on object store " + ar.name + " is not indexed");
  return cr;
}
function Mt(lr, ar, cr) {
  const ur = Ft(lr, ar.schema);
  return ar.openCursor({ trans: cr, values: !lr.keysOnly, reverse: lr.dir === "prev", unique: !!lr.unique, query: { index: ur, range: lr.range } });
}
function Nt(lr, ar, cr, ur) {
  const fr = lr.replayFilter ? St(lr.filter, lr.replayFilter()) : lr.filter;
  if (lr.or) {
    const dr = {}, hr = (gr, vr, mr) => {
      if (!fr || fr(vr, mr, (kr) => vr.stop(kr), (kr) => vr.fail(kr))) {
        var br = vr.primaryKey, yr = "" + br;
        yr === "[object ArrayBuffer]" && (yr = "" + new Uint8Array(br)), o(dr, yr) || (dr[yr] = !0, ar(gr, vr, mr));
      }
    };
    return Promise.all([lr.or._iterate(hr, cr), qt(Mt(lr, ur, cr), lr.algorithm, hr, !lr.keysOnly && lr.valueMapper)]);
  }
  return qt(Mt(lr, ur, cr), St(lr.algorithm, fr), ar, !lr.keysOnly && lr.valueMapper);
}
function qt(lr, ar, cr, ur) {
  var fr = Ye(ur ? (dr, hr, gr) => cr(ur(dr), hr, gr) : cr);
  return lr.then((dr) => {
    if (dr)
      return dr.start(() => {
        var hr = () => dr.continue();
        ar && !ar(dr, (gr) => hr = gr, (gr) => {
          dr.stop(gr), hr = ee$1;
        }, (gr) => {
          dr.fail(gr), hr = ee$1;
        }) || fr(dr.value, dr, (gr) => hr = gr), hr();
      });
  });
}
function $t(lr, ar) {
  try {
    const cr = Ut(lr), ur = Ut(ar);
    if (cr !== ur)
      return cr === "Array" ? 1 : ur === "Array" ? -1 : cr === "binary" ? 1 : ur === "binary" ? -1 : cr === "string" ? 1 : ur === "string" ? -1 : cr === "Date" ? 1 : ur !== "Date" ? NaN : -1;
    switch (cr) {
      case "number":
      case "Date":
      case "string":
        return lr > ar ? 1 : lr < ar ? -1 : 0;
      case "binary":
        return function(fr, dr) {
          const hr = fr.length, gr = dr.length, vr = hr < gr ? hr : gr;
          for (let mr = 0; mr < vr; ++mr)
            if (fr[mr] !== dr[mr])
              return fr[mr] < dr[mr] ? -1 : 1;
          return hr === gr ? 0 : hr < gr ? -1 : 1;
        }(Lt$1(lr), Lt$1(ar));
      case "Array":
        return function(fr, dr) {
          const hr = fr.length, gr = dr.length, vr = hr < gr ? hr : gr;
          for (let mr = 0; mr < vr; ++mr) {
            const br = $t(fr[mr], dr[mr]);
            if (br !== 0)
              return br;
          }
          return hr === gr ? 0 : hr < gr ? -1 : 1;
        }(lr, ar);
    }
  } catch (cr) {
  }
  return NaN;
}
function Ut(lr) {
  const ar = typeof lr;
  if (ar !== "object")
    return ar;
  if (ArrayBuffer.isView(lr))
    return "binary";
  const cr = C(lr);
  return cr === "ArrayBuffer" ? "binary" : cr;
}
function Lt$1(lr) {
  return lr instanceof Uint8Array ? lr : ArrayBuffer.isView(lr) ? new Uint8Array(lr.buffer, lr.byteOffset, lr.byteLength) : new Uint8Array(lr);
}
class Vt {
  _read(ar, cr) {
    var ur = this._ctx;
    return ur.error ? ur.table._trans(null, ft.bind(null, ur.error)) : ur.table._trans("readonly", ar).then(cr);
  }
  _write(ar) {
    var cr = this._ctx;
    return cr.error ? cr.table._trans(null, ft.bind(null, cr.error)) : cr.table._trans("readwrite", ar, "locked");
  }
  _addAlgorithm(ar) {
    var cr = this._ctx;
    cr.algorithm = St(cr.algorithm, ar);
  }
  _iterate(ar, cr) {
    return Nt(this._ctx, ar, cr, this._ctx.table.core);
  }
  clone(ar) {
    var cr = Object.create(this.constructor.prototype), ur = Object.create(this._ctx);
    return ar && r(ur, ar), cr._ctx = ur, cr;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(ar) {
    var cr = this._ctx;
    return this._read((ur) => Nt(cr, ar, ur, cr.table.core));
  }
  count(ar) {
    return this._read((cr) => {
      const ur = this._ctx, fr = ur.table.core;
      if (Bt(ur, !0))
        return fr.count({ trans: cr, query: { index: Ft(ur, fr.schema), range: ur.range } }).then((hr) => Math.min(hr, ur.limit));
      var dr = 0;
      return Nt(ur, () => (++dr, !1), cr, fr).then(() => dr);
    }).then(ar);
  }
  sortBy(ar, cr) {
    const ur = ar.split(".").reverse(), fr = ur[0], dr = ur.length - 1;
    function hr(mr, br) {
      return br ? hr(mr[ur[br]], br - 1) : mr[fr];
    }
    var gr = this._ctx.dir === "next" ? 1 : -1;
    function vr(mr, br) {
      var yr = hr(mr, dr), kr = hr(br, dr);
      return yr < kr ? -gr : yr > kr ? gr : 0;
    }
    return this.toArray(function(mr) {
      return mr.sort(vr);
    }).then(cr);
  }
  toArray(ar) {
    return this._read((cr) => {
      var ur = this._ctx;
      if (ur.dir === "next" && Bt(ur, !0) && ur.limit > 0) {
        const { valueMapper: fr } = ur, dr = Ft(ur, ur.table.core.schema);
        return ur.table.core.query({ trans: cr, limit: ur.limit, values: !0, query: { index: dr, range: ur.range } }).then(({ result: hr }) => fr ? hr.map(fr) : hr);
      }
      {
        const fr = [];
        return Nt(ur, (dr) => fr.push(dr), cr, ur.table.core).then(() => fr);
      }
    }, ar);
  }
  offset(ar) {
    var cr = this._ctx;
    return ar <= 0 || (cr.offset += ar, Bt(cr) ? Rt(cr, () => {
      var ur = ar;
      return (fr, dr) => ur === 0 || (ur === 1 ? (--ur, !1) : (dr(() => {
        fr.advance(ur), ur = 0;
      }), !1));
    }) : Rt(cr, () => {
      var ur = ar;
      return () => --ur < 0;
    })), this;
  }
  limit(ar) {
    return this._ctx.limit = Math.min(this._ctx.limit, ar), Rt(this._ctx, () => {
      var cr = ar;
      return function(ur, fr, dr) {
        return --cr <= 0 && fr(dr), cr >= 0;
      };
    }, !0), this;
  }
  until(ar, cr) {
    return Tt(this._ctx, function(ur, fr, dr) {
      return !ar(ur.value) || (fr(dr), cr);
    }), this;
  }
  first(ar) {
    return this.limit(1).toArray(function(cr) {
      return cr[0];
    }).then(ar);
  }
  last(ar) {
    return this.reverse().first(ar);
  }
  filter(ar) {
    var cr, ur;
    return Tt(this._ctx, function(fr) {
      return ar(fr.value);
    }), cr = this._ctx, ur = ar, cr.isMatch = St(cr.isMatch, ur), this;
  }
  and(ar) {
    return this.filter(ar);
  }
  or(ar) {
    return new this.db.WhereClause(this._ctx.table, ar, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(ar) {
    var cr = this._ctx;
    return cr.keysOnly = !cr.isMatch, this.each(function(ur, fr) {
      ar(fr.key, fr);
    });
  }
  eachUniqueKey(ar) {
    return this._ctx.unique = "unique", this.eachKey(ar);
  }
  eachPrimaryKey(ar) {
    var cr = this._ctx;
    return cr.keysOnly = !cr.isMatch, this.each(function(ur, fr) {
      ar(fr.primaryKey, fr);
    });
  }
  keys(ar) {
    var cr = this._ctx;
    cr.keysOnly = !cr.isMatch;
    var ur = [];
    return this.each(function(fr, dr) {
      ur.push(dr.key);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  primaryKeys(ar) {
    var cr = this._ctx;
    if (cr.dir === "next" && Bt(cr, !0) && cr.limit > 0)
      return this._read((fr) => {
        var dr = Ft(cr, cr.table.core.schema);
        return cr.table.core.query({ trans: fr, values: !1, limit: cr.limit, query: { index: dr, range: cr.range } });
      }).then(({ result: fr }) => fr).then(ar);
    cr.keysOnly = !cr.isMatch;
    var ur = [];
    return this.each(function(fr, dr) {
      ur.push(dr.primaryKey);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  uniqueKeys(ar) {
    return this._ctx.unique = "unique", this.keys(ar);
  }
  firstKey(ar) {
    return this.limit(1).keys(function(cr) {
      return cr[0];
    }).then(ar);
  }
  lastKey(ar) {
    return this.reverse().firstKey(ar);
  }
  distinct() {
    var ar = this._ctx, cr = ar.index && ar.table.schema.idxByName[ar.index];
    if (!cr || !cr.multi)
      return this;
    var ur = {};
    return Tt(this._ctx, function(fr) {
      var dr = fr.primaryKey.toString(), hr = o(ur, dr);
      return ur[dr] = !0, !hr;
    }), this;
  }
  modify(ar) {
    var cr = this._ctx;
    return this._write((ur) => {
      var fr;
      if (typeof ar == "function")
        fr = ar;
      else {
        var dr = t(ar), hr = dr.length;
        fr = function(Er) {
          for (var xr = !1, Cr = 0; Cr < hr; ++Cr) {
            var Ar = dr[Cr], Lr = ar[Ar];
            b(Er, Ar) !== Lr && (_(Er, Ar, Lr), xr = !0);
          }
          return xr;
        };
      }
      const gr = cr.table.core, { outbound: vr, extractKey: mr } = gr.schema.primaryKey, br = this.db._options.modifyChunkSize || 200, yr = [];
      let kr = 0;
      const Tr = [], _r = (Er, xr) => {
        const { failures: Cr, numFailures: Ar } = xr;
        kr += Er - Ar;
        for (let Lr of t(Cr))
          yr.push(Cr[Lr]);
      };
      return this.clone().primaryKeys().then((Er) => {
        const xr = (Cr) => {
          const Ar = Math.min(br, Er.length - Cr);
          return gr.getMany({ trans: ur, keys: Er.slice(Cr, Cr + Ar), cache: "immutable" }).then((Lr) => {
            const Dr = [], Nr = [], Hr = vr ? [] : null, $r = [];
            for (let Zr = 0; Zr < Ar; ++Zr) {
              const oi = Lr[Zr], Jr = { value: O(oi), primKey: Er[Cr + Zr] };
              fr.call(Jr, Jr.value, Jr) !== !1 && (Jr.value == null ? $r.push(Er[Cr + Zr]) : vr || $t(mr(oi), mr(Jr.value)) === 0 ? (Nr.push(Jr.value), vr && Hr.push(Er[Cr + Zr])) : ($r.push(Er[Cr + Zr]), Dr.push(Jr.value)));
            }
            const Wr = Bt(cr) && cr.limit === 1 / 0 && (typeof ar != "function" || ar === Wt) && { index: cr.index, range: cr.range };
            return Promise.resolve(Dr.length > 0 && gr.mutate({ trans: ur, type: "add", values: Dr }).then((Zr) => {
              for (let oi in Zr.failures)
                $r.splice(parseInt(oi), 1);
              _r(Dr.length, Zr);
            })).then(() => (Nr.length > 0 || Wr && typeof ar == "object") && gr.mutate({ trans: ur, type: "put", keys: Hr, values: Nr, criteria: Wr, changeSpec: typeof ar != "function" && ar }).then((Zr) => _r(Nr.length, Zr))).then(() => ($r.length > 0 || Wr && ar === Wt) && gr.mutate({ trans: ur, type: "delete", keys: $r, criteria: Wr }).then((Zr) => _r($r.length, Zr))).then(() => Er.length > Cr + Ar && xr(Cr + br));
          });
        };
        return xr(0).then(() => {
          if (yr.length > 0)
            throw new z("Error modifying one or more objects", yr, kr, Tr);
          return Er.length;
        });
      });
    });
  }
  delete() {
    var ar = this._ctx, cr = ar.range;
    return Bt(ar) && (ar.isPrimKey && !kt || cr.type === 3) ? this._write((ur) => {
      const { primaryKey: fr } = ar.table.core.schema, dr = cr;
      return ar.table.core.count({ trans: ur, query: { index: fr, range: dr } }).then((hr) => ar.table.core.mutate({ trans: ur, type: "deleteRange", range: dr }).then(({ failures: gr, lastResult: vr, results: mr, numFailures: br }) => {
        if (br)
          throw new z("Could not delete some values", Object.keys(gr).map((yr) => gr[yr]), hr - br);
        return hr - br;
      }));
    }) : this.modify(Wt);
  }
}
const Wt = (lr, ar) => ar.value = null;
function Yt(lr, ar) {
  return lr < ar ? -1 : lr === ar ? 0 : 1;
}
function zt(lr, ar) {
  return lr > ar ? -1 : lr === ar ? 0 : 1;
}
function Gt$1(lr, ar, cr) {
  var ur = lr instanceof en ? new lr.Collection(lr) : lr;
  return ur._ctx.error = cr ? new cr(ar) : new TypeError(ar), ur;
}
function Ht(lr) {
  return new lr.Collection(lr, () => Zt("")).limit(0);
}
function Qt(lr, ar, cr, ur, fr, dr) {
  for (var hr = Math.min(lr.length, ur.length), gr = -1, vr = 0; vr < hr; ++vr) {
    var mr = ar[vr];
    if (mr !== ur[vr])
      return fr(lr[vr], cr[vr]) < 0 ? lr.substr(0, vr) + cr[vr] + cr.substr(vr + 1) : fr(lr[vr], ur[vr]) < 0 ? lr.substr(0, vr) + ur[vr] + cr.substr(vr + 1) : gr >= 0 ? lr.substr(0, gr) + ar[gr] + cr.substr(gr + 1) : null;
    fr(lr[vr], mr) < 0 && (gr = vr);
  }
  return hr < ur.length && dr === "next" ? lr + cr.substr(lr.length) : hr < lr.length && dr === "prev" ? lr.substr(0, cr.length) : gr < 0 ? null : lr.substr(0, gr) + ur[gr] + cr.substr(gr + 1);
}
function Xt(lr, ar, cr, ur) {
  var fr, dr, hr, gr, vr, mr, br, yr = cr.length;
  if (!cr.every((Er) => typeof Er == "string"))
    return Gt$1(lr, bt);
  function kr(Er) {
    fr = function(Cr) {
      return Cr === "next" ? (Ar) => Ar.toUpperCase() : (Ar) => Ar.toLowerCase();
    }(Er), dr = function(Cr) {
      return Cr === "next" ? (Ar) => Ar.toLowerCase() : (Ar) => Ar.toUpperCase();
    }(Er), hr = Er === "next" ? Yt : zt;
    var xr = cr.map(function(Cr) {
      return { lower: dr(Cr), upper: fr(Cr) };
    }).sort(function(Cr, Ar) {
      return hr(Cr.lower, Ar.lower);
    });
    gr = xr.map(function(Cr) {
      return Cr.upper;
    }), vr = xr.map(function(Cr) {
      return Cr.lower;
    }), mr = Er, br = Er === "next" ? "" : ur;
  }
  kr("next");
  var Tr = new lr.Collection(lr, () => Jt(gr[0], vr[yr - 1] + ur));
  Tr._ondirectionchange = function(Er) {
    kr(Er);
  };
  var _r = 0;
  return Tr._addAlgorithm(function(Er, xr, Cr) {
    var Ar = Er.key;
    if (typeof Ar != "string")
      return !1;
    var Lr = dr(Ar);
    if (ar(Lr, vr, _r))
      return !0;
    for (var Dr = null, Nr = _r; Nr < yr; ++Nr) {
      var Hr = Qt(Ar, Lr, gr[Nr], vr[Nr], hr, mr);
      Hr === null && Dr === null ? _r = Nr + 1 : (Dr === null || hr(Dr, Hr) > 0) && (Dr = Hr);
    }
    return xr(Dr !== null ? function() {
      Er.continue(Dr + br);
    } : Cr), !1;
  }), Tr;
}
function Jt(lr, ar, cr, ur) {
  return { type: 2, lower: lr, upper: ar, lowerOpen: cr, upperOpen: ur };
}
function Zt(lr) {
  return { type: 1, lower: lr, upper: lr };
}
class en {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(ar, cr, ur, fr) {
    ur = ur !== !1, fr = fr === !0;
    try {
      return this._cmp(ar, cr) > 0 || this._cmp(ar, cr) === 0 && (ur || fr) && (!ur || !fr) ? Ht(this) : new this.Collection(this, () => Jt(ar, cr, !ur, !fr));
    } catch (dr) {
      return Gt$1(this, gt$3);
    }
  }
  equals(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Zt(ar));
  }
  above(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !0));
  }
  aboveOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !1));
  }
  below(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar, !1, !0));
  }
  belowOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar));
  }
  startsWith(ar) {
    return typeof ar != "string" ? Gt$1(this, bt) : this.between(ar, ar + mt, !0, !0);
  }
  startsWithIgnoreCase(ar) {
    return ar === "" ? this.startsWith(ar) : Xt(this, (cr, ur) => cr.indexOf(ur[0]) === 0, [ar], mt);
  }
  equalsIgnoreCase(ar) {
    return Xt(this, (cr, ur) => cr === ur[0], [ar], "");
  }
  anyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (cr, ur) => ur.indexOf(cr) !== -1, ar, "");
  }
  startsWithAnyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (cr, ur) => ur.some((fr) => cr.indexOf(fr) === 0), ar, mt);
  }
  anyOf() {
    const ar = B.apply(I, arguments);
    let cr = this._cmp;
    try {
      ar.sort(cr);
    } catch (dr) {
      return Gt$1(this, gt$3);
    }
    if (ar.length === 0)
      return Ht(this);
    const ur = new this.Collection(this, () => Jt(ar[0], ar[ar.length - 1]));
    ur._ondirectionchange = (dr) => {
      cr = dr === "next" ? this._ascending : this._descending, ar.sort(cr);
    };
    let fr = 0;
    return ur._addAlgorithm((dr, hr, gr) => {
      const vr = dr.key;
      for (; cr(vr, ar[fr]) > 0; )
        if (++fr, fr === ar.length)
          return hr(gr), !1;
      return cr(vr, ar[fr]) === 0 || (hr(() => {
        dr.continue(ar[fr]);
      }), !1);
    }), ur;
  }
  notEqual(ar) {
    return this.inAnyRange([[vt, ar], [ar, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const ar = B.apply(I, arguments);
    if (ar.length === 0)
      return new this.Collection(this);
    try {
      ar.sort(this._ascending);
    } catch (ur) {
      return Gt$1(this, gt$3);
    }
    const cr = ar.reduce((ur, fr) => ur ? ur.concat([[ur[ur.length - 1][1], fr]]) : [[vt, fr]], null);
    return cr.push([ar[ar.length - 1], this.db._maxKey]), this.inAnyRange(cr, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(ar, cr) {
    const ur = this._cmp, fr = this._ascending, dr = this._descending, hr = this._min, gr = this._max;
    if (ar.length === 0)
      return Ht(this);
    if (!ar.every((Ar) => Ar[0] !== void 0 && Ar[1] !== void 0 && fr(Ar[0], Ar[1]) <= 0))
      return Gt$1(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", X.InvalidArgument);
    const vr = !cr || cr.includeLowers !== !1, mr = cr && cr.includeUppers === !0;
    let br, yr = fr;
    function kr(Ar, Lr) {
      return yr(Ar[0], Lr[0]);
    }
    try {
      br = ar.reduce(function(Ar, Lr) {
        let Dr = 0, Nr = Ar.length;
        for (; Dr < Nr; ++Dr) {
          const Hr = Ar[Dr];
          if (ur(Lr[0], Hr[1]) < 0 && ur(Lr[1], Hr[0]) > 0) {
            Hr[0] = hr(Hr[0], Lr[0]), Hr[1] = gr(Hr[1], Lr[1]);
            break;
          }
        }
        return Dr === Nr && Ar.push(Lr), Ar;
      }, []), br.sort(kr);
    } catch (Ar) {
      return Gt$1(this, gt$3);
    }
    let Tr = 0;
    const _r = mr ? (Ar) => fr(Ar, br[Tr][1]) > 0 : (Ar) => fr(Ar, br[Tr][1]) >= 0, Er = vr ? (Ar) => dr(Ar, br[Tr][0]) > 0 : (Ar) => dr(Ar, br[Tr][0]) >= 0;
    let xr = _r;
    const Cr = new this.Collection(this, () => Jt(br[0][0], br[br.length - 1][1], !vr, !mr));
    return Cr._ondirectionchange = (Ar) => {
      Ar === "next" ? (xr = _r, yr = fr) : (xr = Er, yr = dr), br.sort(kr);
    }, Cr._addAlgorithm((Ar, Lr, Dr) => {
      for (var Nr = Ar.key; xr(Nr); )
        if (++Tr, Tr === br.length)
          return Lr(Dr), !1;
      return !!function(Hr) {
        return !_r(Hr) && !Er(Hr);
      }(Nr) || (this._cmp(Nr, br[Tr][1]) === 0 || this._cmp(Nr, br[Tr][0]) === 0 || Lr(() => {
        yr === fr ? Ar.continue(br[Tr][0]) : Ar.continue(br[Tr][1]);
      }), !1);
    }), Cr;
  }
  startsWithAnyOf() {
    const ar = B.apply(I, arguments);
    return ar.every((cr) => typeof cr == "string") ? ar.length === 0 ? Ht(this) : this.inAnyRange(ar.map((cr) => [cr, cr + mt])) : Gt$1(this, "startsWithAnyOf() only works with strings");
  }
}
function tn(lr) {
  return Ye(function(ar) {
    return nn(ar), lr(ar.target.error), !1;
  });
}
function nn(lr) {
  lr.stopPropagation && lr.stopPropagation(), lr.preventDefault && lr.preventDefault();
}
const rn = "storagemutated", sn = "x-storagemutated-1", on$1 = Dt(null, rn);
class an {
  _lock() {
    return m(!Oe.global), ++this._reculock, this._reculock !== 1 || Oe.global || (Oe.lockOwnerFor = this), this;
  }
  _unlock() {
    if (m(!Oe.global), --this._reculock == 0)
      for (Oe.global || (Oe.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var ar = this._blockedFuncs.shift();
        try {
          at(ar[1], ar[0]);
        } catch (cr) {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Oe.lockOwnerFor !== this;
  }
  create(ar) {
    if (!this.mode)
      return this;
    const cr = this.db.idbdb, ur = this.db._state.dbOpenError;
    if (m(!this.idbtrans), !ar && !cr)
      switch (ur && ur.name) {
        case "DatabaseClosedError":
          throw new X.DatabaseClosed(ur);
        case "MissingAPIError":
          throw new X.MissingAPI(ur.message, ur);
        default:
          throw new X.OpenFailed(ur);
      }
    if (!this.active)
      throw new X.TransactionInactive();
    return m(this._completion._state === null), (ar = this.idbtrans = ar || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : cr.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Ye((fr) => {
      nn(fr), this._reject(ar.error);
    }), ar.onabort = Ye((fr) => {
      nn(fr), this.active && this._reject(new X.Abort(ar.error)), this.active = !1, this.on("abort").fire(fr);
    }), ar.oncomplete = Ye(() => {
      this.active = !1, this._resolve(), "mutatedParts" in ar && on$1.storagemutated.fire(ar.mutatedParts);
    }), this;
  }
  _promise(ar, cr, ur) {
    if (ar === "readwrite" && this.mode !== "readwrite")
      return ft(new X.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ft(new X.TransactionInactive());
    if (this._locked())
      return new je((dr, hr) => {
        this._blockedFuncs.push([() => {
          this._promise(ar, cr, ur).then(dr, hr);
        }, Oe]);
      });
    if (ur)
      return Ze(() => {
        var dr = new je((hr, gr) => {
          this._lock();
          const vr = cr(hr, gr, this);
          vr && vr.then && vr.then(hr, gr);
        });
        return dr.finally(() => this._unlock()), dr._lib = !0, dr;
      });
    var fr = new je((dr, hr) => {
      var gr = cr(dr, hr, this);
      gr && gr.then && gr.then(dr, hr);
    });
    return fr._lib = !0, fr;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(ar) {
    var cr = this._root();
    const ur = je.resolve(ar);
    if (cr._waitingFor)
      cr._waitingFor = cr._waitingFor.then(() => ur);
    else {
      cr._waitingFor = ur, cr._waitingQueue = [];
      var fr = cr.idbtrans.objectStore(cr.storeNames[0]);
      (function hr() {
        for (++cr._spinCount; cr._waitingQueue.length; )
          cr._waitingQueue.shift()();
        cr._waitingFor && (fr.get(-1 / 0).onsuccess = hr);
      })();
    }
    var dr = cr._waitingFor;
    return new je((hr, gr) => {
      ur.then((vr) => cr._waitingQueue.push(Ye(hr.bind(null, vr))), (vr) => cr._waitingQueue.push(Ye(gr.bind(null, vr)))).finally(() => {
        cr._waitingFor === dr && (cr._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));
  }
  table(ar) {
    const cr = this._memoizedTables || (this._memoizedTables = {});
    if (o(cr, ar))
      return cr[ar];
    const ur = this.schema[ar];
    if (!ur)
      throw new X.NotFound("Table " + ar + " not part of transaction");
    const fr = new this.db.Table(ar, ur, this);
    return fr.core = this.db.core.table(ar), cr[ar] = fr, fr;
  }
}
function un(lr, ar, cr, ur, fr, dr, hr) {
  return { name: lr, keyPath: ar, unique: cr, multi: ur, auto: fr, compound: dr, src: (cr && !hr ? "&" : "") + (ur ? "*" : "") + (fr ? "++" : "") + ln(ar) };
}
function ln(lr) {
  return typeof lr == "string" ? lr : lr ? "[" + [].join.call(lr, "+") + "]" : "";
}
function cn(lr, ar, cr) {
  return { name: lr, primKey: ar, indexes: cr, mappedClass: null, idxByName: g(cr, (ur) => [ur.name, ur]) };
}
let hn = (lr) => {
  try {
    return lr.only([[]]), hn = () => [[]], [[]];
  } catch (ar) {
    return hn = () => mt, mt;
  }
};
function dn(lr) {
  return lr == null ? () => {
  } : typeof lr == "string" ? function(ar) {
    return ar.split(".").length === 1 ? (ur) => ur[ar] : (ur) => b(ur, ar);
  }(lr) : (ar) => b(ar, lr);
}
function fn(lr) {
  return [].slice.call(lr);
}
let pn = 0;
function yn(lr) {
  return lr == null ? ":id" : typeof lr == "string" ? lr : `[${lr.join("+")}]`;
}
function mn(lr, ar, cr) {
  function ur(vr) {
    if (vr.type === 3)
      return null;
    if (vr.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: mr, upper: br, lowerOpen: yr, upperOpen: kr } = vr;
    return mr === void 0 ? br === void 0 ? null : ar.upperBound(br, !!kr) : br === void 0 ? ar.lowerBound(mr, !!yr) : ar.bound(mr, br, !!yr, !!kr);
  }
  const { schema: fr, hasGetAll: dr } = function(vr, mr) {
    const br = fn(vr.objectStoreNames);
    return { schema: { name: vr.name, tables: br.map((yr) => mr.objectStore(yr)).map((yr) => {
      const { keyPath: kr, autoIncrement: Tr } = yr, _r = n(kr), Er = kr == null, xr = {}, Cr = { name: yr.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: Er, compound: _r, keyPath: kr, autoIncrement: Tr, unique: !0, extractKey: dn(kr) }, indexes: fn(yr.indexNames).map((Ar) => yr.index(Ar)).map((Ar) => {
        const { name: Lr, unique: Dr, multiEntry: Nr, keyPath: Hr } = Ar, $r = { name: Lr, compound: n(Hr), keyPath: Hr, unique: Dr, multiEntry: Nr, extractKey: dn(Hr) };
        return xr[yn(Hr)] = $r, $r;
      }), getIndexByKeyPath: (Ar) => xr[yn(Ar)] };
      return xr[":id"] = Cr.primaryKey, kr != null && (xr[yn(kr)] = Cr.primaryKey), Cr;
    }) }, hasGetAll: br.length > 0 && "getAll" in mr.objectStore(br[0]) && !(typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(lr, cr), hr = fr.tables.map((vr) => function(mr) {
    const br = mr.name;
    return { name: br, schema: mr, mutate: function({ trans: yr, type: kr, keys: Tr, values: _r, range: Er }) {
      return new Promise((xr, Cr) => {
        xr = Ye(xr);
        const Ar = yr.objectStore(br), Lr = Ar.keyPath == null, Dr = kr === "put" || kr === "add";
        if (!Dr && kr !== "delete" && kr !== "deleteRange")
          throw new Error("Invalid operation type: " + kr);
        const { length: Nr } = Tr || _r || { length: 1 };
        if (Tr && _r && Tr.length !== _r.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (Nr === 0)
          return xr({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let Hr;
        const $r = [], Wr = [];
        let Zr = 0;
        const oi = (Yr) => {
          ++Zr, nn(Yr);
        };
        if (kr === "deleteRange") {
          if (Er.type === 4)
            return xr({ numFailures: Zr, failures: Wr, results: [], lastResult: void 0 });
          Er.type === 3 ? $r.push(Hr = Ar.clear()) : $r.push(Hr = Ar.delete(ur(Er)));
        } else {
          const [Yr, li] = Dr ? Lr ? [_r, Tr] : [_r, null] : [Tr, null];
          if (Dr)
            for (let Si = 0; Si < Nr; ++Si)
              $r.push(Hr = li && li[Si] !== void 0 ? Ar[kr](Yr[Si], li[Si]) : Ar[kr](Yr[Si])), Hr.onerror = oi;
          else
            for (let Si = 0; Si < Nr; ++Si)
              $r.push(Hr = Ar[kr](Yr[Si])), Hr.onerror = oi;
        }
        const Jr = (Yr) => {
          const li = Yr.target.result;
          $r.forEach((Si, ci) => Si.error != null && (Wr[ci] = Si.error)), xr({ numFailures: Zr, failures: Wr, results: kr === "delete" ? Tr : $r.map((Si) => Si.result), lastResult: li });
        };
        Hr.onerror = (Yr) => {
          oi(Yr), Jr(Yr);
        }, Hr.onsuccess = Jr;
      });
    }, getMany: ({ trans: yr, keys: kr }) => new Promise((Tr, _r) => {
      Tr = Ye(Tr);
      const Er = yr.objectStore(br), xr = kr.length, Cr = new Array(xr);
      let Ar, Lr = 0, Dr = 0;
      const Nr = ($r) => {
        const Wr = $r.target;
        Cr[Wr._pos] = Wr.result, ++Dr === Lr && Tr(Cr);
      }, Hr = tn(_r);
      for (let $r = 0; $r < xr; ++$r)
        kr[$r] != null && (Ar = Er.get(kr[$r]), Ar._pos = $r, Ar.onsuccess = Nr, Ar.onerror = Hr, ++Lr);
      Lr === 0 && Tr(Cr);
    }), get: ({ trans: yr, key: kr }) => new Promise((Tr, _r) => {
      Tr = Ye(Tr);
      const Er = yr.objectStore(br).get(kr);
      Er.onsuccess = (xr) => Tr(xr.target.result), Er.onerror = tn(_r);
    }), query: function(yr) {
      return (kr) => new Promise((Tr, _r) => {
        Tr = Ye(Tr);
        const { trans: Er, values: xr, limit: Cr, query: Ar } = kr, Lr = Cr === 1 / 0 ? void 0 : Cr, { index: Dr, range: Nr } = Ar, Hr = Er.objectStore(br), $r = Dr.isPrimaryKey ? Hr : Hr.index(Dr.name), Wr = ur(Nr);
        if (Cr === 0)
          return Tr({ result: [] });
        if (yr) {
          const Zr = xr ? $r.getAll(Wr, Lr) : $r.getAllKeys(Wr, Lr);
          Zr.onsuccess = (oi) => Tr({ result: oi.target.result }), Zr.onerror = tn(_r);
        } else {
          let Zr = 0;
          const oi = xr || !("openKeyCursor" in $r) ? $r.openCursor(Wr) : $r.openKeyCursor(Wr), Jr = [];
          oi.onsuccess = (Yr) => {
            const li = oi.result;
            return li ? (Jr.push(xr ? li.value : li.primaryKey), ++Zr === Cr ? Tr({ result: Jr }) : void li.continue()) : Tr({ result: Jr });
          }, oi.onerror = tn(_r);
        }
      });
    }(dr), openCursor: function({ trans: yr, values: kr, query: Tr, reverse: _r, unique: Er }) {
      return new Promise((xr, Cr) => {
        xr = Ye(xr);
        const { index: Ar, range: Lr } = Tr, Dr = yr.objectStore(br), Nr = Ar.isPrimaryKey ? Dr : Dr.index(Ar.name), Hr = _r ? Er ? "prevunique" : "prev" : Er ? "nextunique" : "next", $r = kr || !("openKeyCursor" in Nr) ? Nr.openCursor(ur(Lr), Hr) : Nr.openKeyCursor(ur(Lr), Hr);
        $r.onerror = tn(Cr), $r.onsuccess = Ye((Wr) => {
          const Zr = $r.result;
          if (!Zr)
            return void xr(null);
          Zr.___id = ++pn, Zr.done = !1;
          const oi = Zr.continue.bind(Zr);
          let Jr = Zr.continuePrimaryKey;
          Jr && (Jr = Jr.bind(Zr));
          const Yr = Zr.advance.bind(Zr), li = () => {
            throw new Error("Cursor not stopped");
          };
          Zr.trans = yr, Zr.stop = Zr.continue = Zr.continuePrimaryKey = Zr.advance = () => {
            throw new Error("Cursor not started");
          }, Zr.fail = Ye(Cr), Zr.next = function() {
            let Si = 1;
            return this.start(() => Si-- ? this.continue() : this.stop()).then(() => this);
          }, Zr.start = (Si) => {
            const ci = new Promise((Ei, di) => {
              Ei = Ye(Ei), $r.onerror = tn(di), Zr.fail = di, Zr.stop = (gi) => {
                Zr.stop = Zr.continue = Zr.continuePrimaryKey = Zr.advance = li, Ei(gi);
              };
            }), hi = () => {
              if ($r.result)
                try {
                  Si();
                } catch (Ei) {
                  Zr.fail(Ei);
                }
              else
                Zr.done = !0, Zr.start = () => {
                  throw new Error("Cursor behind last entry");
                }, Zr.stop();
            };
            return $r.onsuccess = Ye((Ei) => {
              $r.onsuccess = hi, hi();
            }), Zr.continue = oi, Zr.continuePrimaryKey = Jr, Zr.advance = Yr, hi(), ci;
          }, xr(Zr);
        }, Cr);
      });
    }, count({ query: yr, trans: kr }) {
      const { index: Tr, range: _r } = yr;
      return new Promise((Er, xr) => {
        const Cr = kr.objectStore(br), Ar = Tr.isPrimaryKey ? Cr : Cr.index(Tr.name), Lr = ur(_r), Dr = Lr ? Ar.count(Lr) : Ar.count();
        Dr.onsuccess = Ye((Nr) => Er(Nr.target.result)), Dr.onerror = tn(xr);
      });
    } };
  }(vr)), gr = {};
  return hr.forEach((vr) => gr[vr.name] = vr), { stack: "dbcore", transaction: lr.transaction.bind(lr), table(vr) {
    if (!gr[vr])
      throw new Error(`Table '${vr}' not found`);
    return gr[vr];
  }, MIN_KEY: -1 / 0, MAX_KEY: hn(ar), schema: fr };
}
function vn({ _novip: lr }, ar) {
  const cr = ar.db, ur = function(fr, dr, { IDBKeyRange: hr, indexedDB: gr }, vr) {
    return { dbcore: function(br, yr) {
      return yr.reduce((kr, { create: Tr }) => ({ ...kr, ...Tr(kr) }), br);
    }(mn(dr, hr, vr), fr.dbcore) };
  }(lr._middlewares, cr, lr._deps, ar);
  lr.core = ur.dbcore, lr.tables.forEach((fr) => {
    const dr = fr.name;
    lr.core.schema.tables.some((hr) => hr.name === dr) && (fr.core = lr.core.table(dr), lr[dr] instanceof lr.Table && (lr[dr].core = fr.core));
  });
}
function gn({ _novip: lr }, ar, cr, ur) {
  cr.forEach((fr) => {
    const dr = ur[fr];
    ar.forEach((hr) => {
      const gr = d(hr, fr);
      (!gr || "value" in gr && gr.value === void 0) && (hr === lr.Transaction.prototype || hr instanceof lr.Transaction ? l(hr, fr, { get() {
        return this.table(fr);
      }, set(vr) {
        u$1(this, fr, { value: vr, writable: !0, configurable: !0, enumerable: !0 });
      } }) : hr[fr] = new lr.Table(fr, dr));
    });
  });
}
function bn({ _novip: lr }, ar) {
  ar.forEach((cr) => {
    for (let ur in cr)
      cr[ur] instanceof lr.Table && delete cr[ur];
  });
}
function _n(lr, ar) {
  return lr._cfg.version - ar._cfg.version;
}
function wn(lr, ar, cr, ur) {
  const fr = lr._dbSchema, dr = lr._createTransaction("readwrite", lr._storeNames, fr);
  dr.create(cr), dr._completion.catch(ur);
  const hr = dr._reject.bind(dr), gr = Oe.transless || Oe;
  Ze(() => {
    Oe.trans = dr, Oe.transless = gr, ar === 0 ? (t(fr).forEach((vr) => {
      kn(cr, vr, fr[vr].primKey, fr[vr].indexes);
    }), vn(lr, cr), je.follow(() => lr.on.populate.fire(dr)).catch(hr)) : function({ _novip: vr }, mr, br, yr) {
      const kr = [], Tr = vr._versions;
      let _r = vr._dbSchema = Pn(vr, vr.idbdb, yr), Er = !1;
      const xr = Tr.filter((Ar) => Ar._cfg.version >= mr);
      function Cr() {
        return kr.length ? je.resolve(kr.shift()(br.idbtrans)).then(Cr) : je.resolve();
      }
      return xr.forEach((Ar) => {
        kr.push(() => {
          const Lr = _r, Dr = Ar._cfg.dbschema;
          Kn(vr, Lr, yr), Kn(vr, Dr, yr), _r = vr._dbSchema = Dr;
          const Nr = xn(Lr, Dr);
          Nr.add.forEach(($r) => {
            kn(yr, $r[0], $r[1].primKey, $r[1].indexes);
          }), Nr.change.forEach(($r) => {
            if ($r.recreate)
              throw new X.Upgrade("Not yet support for changing primary key");
            {
              const Wr = yr.objectStore($r.name);
              $r.add.forEach((Zr) => En(Wr, Zr)), $r.change.forEach((Zr) => {
                Wr.deleteIndex(Zr.name), En(Wr, Zr);
              }), $r.del.forEach((Zr) => Wr.deleteIndex(Zr));
            }
          });
          const Hr = Ar._cfg.contentUpgrade;
          if (Hr && Ar._cfg.version > mr) {
            vn(vr, yr), br._memoizedTables = {}, Er = !0;
            let $r = w(Dr);
            Nr.del.forEach((Jr) => {
              $r[Jr] = Lr[Jr];
            }), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], t($r), $r), br.schema = $r;
            const Wr = T(Hr);
            let Zr;
            Wr && et();
            const oi = je.follow(() => {
              if (Zr = Hr(br), Zr && Wr) {
                var Jr = tt.bind(null, null);
                Zr.then(Jr, Jr);
              }
            });
            return Zr && typeof Zr.then == "function" ? je.resolve(Zr) : oi.then(() => Zr);
          }
        }), kr.push((Lr) => {
          (!Er || !xt) && function(Dr, Nr) {
            [].slice.call(Nr.db.objectStoreNames).forEach((Hr) => Dr[Hr] == null && Nr.db.deleteObjectStore(Hr));
          }(Ar._cfg.dbschema, Lr), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], vr._storeNames, vr._dbSchema), br.schema = vr._dbSchema;
        });
      }), Cr().then(() => {
        var Ar, Lr;
        Lr = yr, t(Ar = _r).forEach((Dr) => {
          Lr.db.objectStoreNames.contains(Dr) || kn(Lr, Dr, Ar[Dr].primKey, Ar[Dr].indexes);
        });
      });
    }(lr, ar, dr, cr).catch(hr);
  });
}
function xn(lr, ar) {
  const cr = { del: [], add: [], change: [] };
  let ur;
  for (ur in lr)
    ar[ur] || cr.del.push(ur);
  for (ur in ar) {
    const fr = lr[ur], dr = ar[ur];
    if (fr) {
      const hr = { name: ur, def: dr, recreate: !1, del: [], add: [], change: [] };
      if ("" + (fr.primKey.keyPath || "") != "" + (dr.primKey.keyPath || "") || fr.primKey.auto !== dr.primKey.auto && !wt)
        hr.recreate = !0, cr.change.push(hr);
      else {
        const gr = fr.idxByName, vr = dr.idxByName;
        let mr;
        for (mr in gr)
          vr[mr] || hr.del.push(mr);
        for (mr in vr) {
          const br = gr[mr], yr = vr[mr];
          br ? br.src !== yr.src && hr.change.push(yr) : hr.add.push(yr);
        }
        (hr.del.length > 0 || hr.add.length > 0 || hr.change.length > 0) && cr.change.push(hr);
      }
    } else
      cr.add.push([ur, dr]);
  }
  return cr;
}
function kn(lr, ar, cr, ur) {
  const fr = lr.db.createObjectStore(ar, cr.keyPath ? { keyPath: cr.keyPath, autoIncrement: cr.auto } : { autoIncrement: cr.auto });
  return ur.forEach((dr) => En(fr, dr)), fr;
}
function En(lr, ar) {
  lr.createIndex(ar.name, ar.keyPath, { unique: ar.unique, multiEntry: ar.multi });
}
function Pn(lr, ar, cr) {
  const ur = {};
  return p(ar.objectStoreNames, 0).forEach((fr) => {
    const dr = cr.objectStore(fr);
    let hr = dr.keyPath;
    const gr = un(ln(hr), hr || "", !1, !1, !!dr.autoIncrement, hr && typeof hr != "string", !0), vr = [];
    for (let br = 0; br < dr.indexNames.length; ++br) {
      const yr = dr.index(dr.indexNames[br]);
      hr = yr.keyPath;
      var mr = un(yr.name, hr, !!yr.unique, !!yr.multiEntry, !1, hr && typeof hr != "string", !1);
      vr.push(mr);
    }
    ur[fr] = cn(fr, gr, vr);
  }), ur;
}
function Kn({ _novip: lr }, ar, cr) {
  const ur = cr.db.objectStoreNames;
  for (let fr = 0; fr < ur.length; ++fr) {
    const dr = ur[fr], hr = cr.objectStore(dr);
    lr._hasGetAll = "getAll" in hr;
    for (let gr = 0; gr < hr.indexNames.length; ++gr) {
      const vr = hr.indexNames[gr], mr = hr.index(vr).keyPath, br = typeof mr == "string" ? mr : "[" + p(mr).join("+") + "]";
      if (ar[dr]) {
        const yr = ar[dr].idxByName[br];
        yr && (yr.name = vr, delete ar[dr].idxByName[br], ar[dr].idxByName[vr] = yr);
      }
    }
  }
  typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (lr._hasGetAll = !1);
}
class On {
  _parseStoresSpec(ar, cr) {
    t(ar).forEach((ur) => {
      if (ar[ur] !== null) {
        var fr = ar[ur].split(",").map((hr, gr) => {
          const vr = (hr = hr.trim()).replace(/([&*]|\+\+)/g, ""), mr = /^\[/.test(vr) ? vr.match(/^\[(.*)\]$/)[1].split("+") : vr;
          return un(vr, mr || null, /\&/.test(hr), /\*/.test(hr), /\+\+/.test(hr), n(mr), gr === 0);
        }), dr = fr.shift();
        if (dr.multi)
          throw new X.Schema("Primary key cannot be multi-valued");
        fr.forEach((hr) => {
          if (hr.auto)
            throw new X.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!hr.keyPath)
            throw new X.Schema("Index must have a name and cannot be an empty string");
        }), cr[ur] = cn(ur, dr, fr);
      }
    });
  }
  stores(ar) {
    const cr = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, ar) : ar;
    const ur = cr._versions, fr = {};
    let dr = {};
    return ur.forEach((hr) => {
      r(fr, hr._cfg.storesSource), dr = hr._cfg.dbschema = {}, hr._parseStoresSpec(fr, dr);
    }), cr._dbSchema = dr, bn(cr, [cr._allTables, cr, cr.Transaction.prototype]), gn(cr, [cr._allTables, cr, cr.Transaction.prototype, this._cfg.tables], t(dr), dr), cr._storeNames = t(dr), this;
  }
  upgrade(ar) {
    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee$1, ar), this;
  }
}
function Sn(lr, ar) {
  let cr = lr._dbNamesDB;
  return cr || (cr = lr._dbNamesDB = new Xn(Pt, { addons: [], indexedDB: lr, IDBKeyRange: ar }), cr.version(1).stores({ dbnames: "name" })), cr.table("dbnames");
}
function An(lr) {
  return lr && typeof lr.databases == "function";
}
function Cn(lr) {
  return Ze(function() {
    return Oe.letThrough = !0, lr();
  });
}
function jn() {
  var lr;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ar) {
    var cr = function() {
      return indexedDB.databases().finally(ar);
    };
    lr = setInterval(cr, 100), cr();
  }).finally(function() {
    return clearInterval(lr);
  }) : Promise.resolve();
}
function Dn(lr) {
  const ar = lr._state, { indexedDB: cr } = lr._deps;
  if (ar.isBeingOpened || lr.idbdb)
    return ar.dbReadyPromise.then(() => ar.dbOpenError ? ft(ar.dbOpenError) : lr);
  R && (ar.openCanceller._stackHolder = q()), ar.isBeingOpened = !0, ar.dbOpenError = null, ar.openComplete = !1;
  const ur = ar.openCanceller;
  function fr() {
    if (ar.openCanceller !== ur)
      throw new X.DatabaseClosed("db.open() was cancelled");
  }
  let dr = ar.dbReadyResolve, hr = null, gr = !1;
  return je.race([ur, (typeof navigator == "undefined" ? je.resolve() : jn()).then(() => new je((vr, mr) => {
    if (fr(), !cr)
      throw new X.MissingAPI();
    const br = lr.name, yr = ar.autoSchema ? cr.open(br) : cr.open(br, Math.round(10 * lr.verno));
    if (!yr)
      throw new X.MissingAPI();
    yr.onerror = tn(mr), yr.onblocked = Ye(lr._fireOnBlocked), yr.onupgradeneeded = Ye((kr) => {
      if (hr = yr.transaction, ar.autoSchema && !lr._options.allowEmptyDB) {
        yr.onerror = nn, hr.abort(), yr.result.close();
        const _r = cr.deleteDatabase(br);
        _r.onsuccess = _r.onerror = Ye(() => {
          mr(new X.NoSuchDatabase(`Database ${br} doesnt exist`));
        });
      } else {
        hr.onerror = tn(mr);
        var Tr = kr.oldVersion > Math.pow(2, 62) ? 0 : kr.oldVersion;
        gr = Tr < 1, lr._novip.idbdb = yr.result, wn(lr, Tr / 10, hr, mr);
      }
    }, mr), yr.onsuccess = Ye(() => {
      hr = null;
      const kr = lr._novip.idbdb = yr.result, Tr = p(kr.objectStoreNames);
      if (Tr.length > 0)
        try {
          const Er = kr.transaction((_r = Tr).length === 1 ? _r[0] : _r, "readonly");
          ar.autoSchema ? function({ _novip: xr }, Cr, Ar) {
            xr.verno = Cr.version / 10;
            const Lr = xr._dbSchema = Pn(0, Cr, Ar);
            xr._storeNames = p(Cr.objectStoreNames, 0), gn(xr, [xr._allTables], t(Lr), Lr);
          }(lr, kr, Er) : (Kn(lr, lr._dbSchema, Er), function(xr, Cr) {
            const Ar = xn(Pn(0, xr.idbdb, Cr), xr._dbSchema);
            return !(Ar.add.length || Ar.change.some((Lr) => Lr.add.length || Lr.change.length));
          }(lr, Er) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), vn(lr, Er);
        } catch (Er) {
        }
      var _r;
      _t.push(lr), kr.onversionchange = Ye((Er) => {
        ar.vcFired = !0, lr.on("versionchange").fire(Er);
      }), kr.onclose = Ye((Er) => {
        lr.on("close").fire(Er);
      }), gr && function({ indexedDB: Er, IDBKeyRange: xr }, Cr) {
        !An(Er) && Cr !== Pt && Sn(Er, xr).put({ name: Cr }).catch(ee$1);
      }(lr._deps, br), vr();
    }, mr);
  }))]).then(() => (fr(), ar.onReadyBeingFired = [], je.resolve(Cn(() => lr.on.ready.fire(lr.vip))).then(function vr() {
    if (ar.onReadyBeingFired.length > 0) {
      let mr = ar.onReadyBeingFired.reduce(ue, ee$1);
      return ar.onReadyBeingFired = [], je.resolve(Cn(() => mr(lr.vip))).then(vr);
    }
  }))).finally(() => {
    ar.onReadyBeingFired = null, ar.isBeingOpened = !1;
  }).then(() => lr).catch((vr) => {
    ar.dbOpenError = vr;
    try {
      hr && hr.abort();
    } catch (mr) {
    }
    return ur === ar.openCanceller && lr._close(), ft(vr);
  }).finally(() => {
    ar.openComplete = !0, dr();
  });
}
function In(lr) {
  var ar = (dr) => lr.next(dr), cr = fr(ar), ur = fr((dr) => lr.throw(dr));
  function fr(dr) {
    return (hr) => {
      var gr = dr(hr), vr = gr.value;
      return gr.done ? vr : vr && typeof vr.then == "function" ? vr.then(cr, ur) : n(vr) ? Promise.all(vr).then(cr, ur) : cr(vr);
    };
  }
  return fr(ar)();
}
function Bn(lr, ar, cr) {
  var ur = arguments.length;
  if (ur < 2)
    throw new X.InvalidArgument("Too few arguments");
  for (var fr = new Array(ur - 1); --ur; )
    fr[ur - 1] = arguments[ur];
  return cr = fr.pop(), [lr, k(fr), cr];
}
function Tn(lr, ar, cr, ur, fr) {
  return je.resolve().then(() => {
    const dr = Oe.transless || Oe, hr = lr._createTransaction(ar, cr, lr._dbSchema, ur), gr = { trans: hr, transless: dr };
    if (ur)
      hr.idbtrans = ur.idbtrans;
    else
      try {
        hr.create(), lr._state.PR1398_maxLoop = 3;
      } catch (yr) {
        return yr.name === H.InvalidState && lr.isOpen() && --lr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), lr._close(), lr.open().then(() => Tn(lr, ar, cr, null, fr))) : ft(yr);
      }
    const vr = T(fr);
    let mr;
    vr && et();
    const br = je.follow(() => {
      if (mr = fr.call(hr, hr), mr)
        if (vr) {
          var yr = tt.bind(null, null);
          mr.then(yr, yr);
        } else
          typeof mr.next == "function" && typeof mr.throw == "function" && (mr = In(mr));
    }, gr);
    return (mr && typeof mr.then == "function" ? je.resolve(mr).then((yr) => hr.active ? yr : ft(new X.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : br.then(() => mr)).then((yr) => (ur && hr._resolve(), hr._completion.then(() => yr))).catch((yr) => (hr._reject(yr), ft(yr)));
  });
}
function Rn(lr, ar, cr) {
  const ur = n(lr) ? lr.slice() : [lr];
  for (let fr = 0; fr < cr; ++fr)
    ur.push(ar);
  return ur;
}
const Fn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(lr) {
  return { ...lr, table(ar) {
    const cr = lr.table(ar), { schema: ur } = cr, fr = {}, dr = [];
    function hr(br, yr, kr) {
      const Tr = yn(br), _r = fr[Tr] = fr[Tr] || [], Er = br == null ? 0 : typeof br == "string" ? 1 : br.length, xr = yr > 0, Cr = { ...kr, isVirtual: xr, keyTail: yr, keyLength: Er, extractKey: dn(br), unique: !xr && kr.unique };
      return _r.push(Cr), Cr.isPrimaryKey || dr.push(Cr), Er > 1 && hr(Er === 2 ? br[0] : br.slice(0, Er - 1), yr + 1, kr), _r.sort((Ar, Lr) => Ar.keyTail - Lr.keyTail), Cr;
    }
    const gr = hr(ur.primaryKey.keyPath, 0, ur.primaryKey);
    fr[":id"] = [gr];
    for (const br of ur.indexes)
      hr(br.keyPath, 0, br);
    function vr(br) {
      const yr = br.query.index;
      return yr.isVirtual ? { ...br, query: { index: yr, range: (kr = br.query.range, Tr = yr.keyTail, { type: kr.type === 1 ? 2 : kr.type, lower: Rn(kr.lower, kr.lowerOpen ? lr.MAX_KEY : lr.MIN_KEY, Tr), lowerOpen: !0, upper: Rn(kr.upper, kr.upperOpen ? lr.MIN_KEY : lr.MAX_KEY, Tr), upperOpen: !0 }) } } : br;
      var kr, Tr;
    }
    return { ...cr, schema: { ...ur, primaryKey: gr, indexes: dr, getIndexByKeyPath: function(br) {
      const yr = fr[yn(br)];
      return yr && yr[0];
    } }, count: (br) => cr.count(vr(br)), query: (br) => cr.query(vr(br)), openCursor(br) {
      const { keyTail: yr, isVirtual: kr, keyLength: Tr } = br.query.index;
      return kr ? cr.openCursor(vr(br)).then((_r) => _r && function(Er) {
        return Object.create(Er, { continue: { value: function(Cr) {
          Cr != null ? Er.continue(Rn(Cr, br.reverse ? lr.MAX_KEY : lr.MIN_KEY, yr)) : br.unique ? Er.continue(Er.key.slice(0, Tr).concat(br.reverse ? lr.MIN_KEY : lr.MAX_KEY, yr)) : Er.continue();
        } }, continuePrimaryKey: { value(Cr, Ar) {
          Er.continuePrimaryKey(Rn(Cr, lr.MAX_KEY, yr), Ar);
        } }, primaryKey: { get: () => Er.primaryKey }, key: { get() {
          const Cr = Er.key;
          return Tr === 1 ? Cr[0] : Cr.slice(0, Tr);
        } }, value: { get: () => Er.value } });
      }(_r)) : cr.openCursor(br);
    } };
  } };
} };
function Mn(lr, ar, cr, ur) {
  return cr = cr || {}, ur = ur || "", t(lr).forEach((fr) => {
    if (o(ar, fr)) {
      var dr = lr[fr], hr = ar[fr];
      if (typeof dr == "object" && typeof hr == "object" && dr && hr) {
        const gr = C(dr);
        gr !== C(hr) ? cr[ur + fr] = ar[fr] : gr === "Object" ? Mn(dr, hr, cr, ur + fr + ".") : dr !== hr && (cr[ur + fr] = ar[fr]);
      } else
        dr !== hr && (cr[ur + fr] = ar[fr]);
    } else
      cr[ur + fr] = void 0;
  }), t(ar).forEach((fr) => {
    o(lr, fr) || (cr[ur + fr] = ar[fr]);
  }), cr;
}
const Nn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (lr) => ({ ...lr, table(ar) {
  const cr = lr.table(ar), { primaryKey: ur } = cr.schema;
  return { ...cr, mutate(dr) {
    const hr = Oe.trans, { deleting: gr, creating: vr, updating: mr } = hr.table(ar).hook;
    switch (dr.type) {
      case "add":
        if (vr.fire === ee$1)
          break;
        return hr._promise("readwrite", () => br(dr), !0);
      case "put":
        if (vr.fire === ee$1 && mr.fire === ee$1)
          break;
        return hr._promise("readwrite", () => br(dr), !0);
      case "delete":
        if (gr.fire === ee$1)
          break;
        return hr._promise("readwrite", () => br(dr), !0);
      case "deleteRange":
        if (gr.fire === ee$1)
          break;
        return hr._promise("readwrite", () => function(kr) {
          return yr(kr.trans, kr.range, 1e4);
        }(dr), !0);
    }
    return cr.mutate(dr);
    function br(kr) {
      const Tr = Oe.trans, _r = kr.keys || function(Er, xr) {
        return xr.type === "delete" ? xr.keys : xr.keys || xr.values.map(Er.extractKey);
      }(ur, kr);
      if (!_r)
        throw new Error("Keys missing");
      return (kr = kr.type === "add" || kr.type === "put" ? { ...kr, keys: _r } : { ...kr }).type !== "delete" && (kr.values = [...kr.values]), kr.keys && (kr.keys = [...kr.keys]), function(Er, xr, Cr) {
        return xr.type === "add" ? Promise.resolve([]) : Er.getMany({ trans: xr.trans, keys: Cr, cache: "immutable" });
      }(cr, kr, _r).then((Er) => {
        const xr = _r.map((Cr, Ar) => {
          const Lr = Er[Ar], Dr = { onerror: null, onsuccess: null };
          if (kr.type === "delete")
            gr.fire.call(Dr, Cr, Lr, Tr);
          else if (kr.type === "add" || Lr === void 0) {
            const Nr = vr.fire.call(Dr, Cr, kr.values[Ar], Tr);
            Cr == null && Nr != null && (Cr = Nr, kr.keys[Ar] = Cr, ur.outbound || _(kr.values[Ar], ur.keyPath, Cr));
          } else {
            const Nr = Mn(Lr, kr.values[Ar]), Hr = mr.fire.call(Dr, Nr, Cr, Lr, Tr);
            if (Hr) {
              const $r = kr.values[Ar];
              Object.keys(Hr).forEach((Wr) => {
                o($r, Wr) ? $r[Wr] = Hr[Wr] : _($r, Wr, Hr[Wr]);
              });
            }
          }
          return Dr;
        });
        return cr.mutate(kr).then(({ failures: Cr, results: Ar, numFailures: Lr, lastResult: Dr }) => {
          for (let Nr = 0; Nr < _r.length; ++Nr) {
            const Hr = Ar ? Ar[Nr] : _r[Nr], $r = xr[Nr];
            Hr == null ? $r.onerror && $r.onerror(Cr[Nr]) : $r.onsuccess && $r.onsuccess(kr.type === "put" && Er[Nr] ? kr.values[Nr] : Hr);
          }
          return { failures: Cr, results: Ar, numFailures: Lr, lastResult: Dr };
        }).catch((Cr) => (xr.forEach((Ar) => Ar.onerror && Ar.onerror(Cr)), Promise.reject(Cr)));
      });
    }
    function yr(kr, Tr, _r) {
      return cr.query({ trans: kr, values: !1, query: { index: ur, range: Tr }, limit: _r }).then(({ result: Er }) => br({ type: "delete", keys: Er, trans: kr }).then((xr) => xr.numFailures > 0 ? Promise.reject(xr.failures[0]) : Er.length < _r ? { failures: [], numFailures: 0, lastResult: void 0 } : yr(kr, { ...Tr, lower: Er[Er.length - 1], lowerOpen: !0 }, _r)));
    }
  } };
} }) };
function qn(lr, ar, cr) {
  try {
    if (!ar || ar.keys.length < lr.length)
      return null;
    const ur = [];
    for (let fr = 0, dr = 0; fr < ar.keys.length && dr < lr.length; ++fr)
      $t(ar.keys[fr], lr[dr]) === 0 && (ur.push(cr ? O(ar.values[fr]) : ar.values[fr]), ++dr);
    return ur.length === lr.length ? ur : null;
  } catch (ur) {
    return null;
  }
}
const $n = { stack: "dbcore", level: -1, create: (lr) => ({ table: (ar) => {
  const cr = lr.table(ar);
  return { ...cr, getMany: (ur) => {
    if (!ur.cache)
      return cr.getMany(ur);
    const fr = qn(ur.keys, ur.trans._cache, ur.cache === "clone");
    return fr ? je.resolve(fr) : cr.getMany(ur).then((dr) => (ur.trans._cache = { keys: ur.keys, values: ur.cache === "clone" ? O(dr) : dr }, dr));
  }, mutate: (ur) => (ur.type !== "add" && (ur.trans._cache = null), cr.mutate(ur)) };
} }) };
function Un(lr) {
  return !("from" in lr);
}
const Ln = function(lr, ar) {
  if (!this) {
    const cr = new Ln();
    return lr && "d" in lr && r(cr, lr), cr;
  }
  r(this, arguments.length ? { d: 1, from: lr, to: arguments.length > 1 ? ar : lr } : { d: 0 });
};
function Vn(lr, ar, cr) {
  const ur = $t(ar, cr);
  if (isNaN(ur))
    return;
  if (ur > 0)
    throw RangeError();
  if (Un(lr))
    return r(lr, { from: ar, to: cr, d: 1 });
  const fr = lr.l, dr = lr.r;
  if ($t(cr, lr.from) < 0)
    return fr ? Vn(fr, ar, cr) : lr.l = { from: ar, to: cr, d: 1, l: null, r: null }, Gn(lr);
  if ($t(ar, lr.to) > 0)
    return dr ? Vn(dr, ar, cr) : lr.r = { from: ar, to: cr, d: 1, l: null, r: null }, Gn(lr);
  $t(ar, lr.from) < 0 && (lr.from = ar, lr.l = null, lr.d = dr ? dr.d + 1 : 1), $t(cr, lr.to) > 0 && (lr.to = cr, lr.r = null, lr.d = lr.l ? lr.l.d + 1 : 1);
  const hr = !lr.r;
  fr && !lr.l && Wn(lr, fr), dr && hr && Wn(lr, dr);
}
function Wn(lr, ar) {
  Un(ar) || function cr(ur, { from: fr, to: dr, l: hr, r: gr }) {
    Vn(ur, fr, dr), hr && cr(ur, hr), gr && cr(ur, gr);
  }(lr, ar);
}
function Yn(lr, ar) {
  const cr = zn(ar);
  let ur = cr.next();
  if (ur.done)
    return !1;
  let fr = ur.value;
  const dr = zn(lr);
  let hr = dr.next(fr.from), gr = hr.value;
  for (; !ur.done && !hr.done; ) {
    if ($t(gr.from, fr.to) <= 0 && $t(gr.to, fr.from) >= 0)
      return !0;
    $t(fr.from, gr.from) < 0 ? fr = (ur = cr.next(gr.from)).value : gr = (hr = dr.next(fr.from)).value;
  }
  return !1;
}
function zn(lr) {
  let ar = Un(lr) ? null : { s: 0, n: lr };
  return { next(cr) {
    const ur = arguments.length > 0;
    for (; ar; )
      switch (ar.s) {
        case 0:
          if (ar.s = 1, ur)
            for (; ar.n.l && $t(cr, ar.n.from) < 0; )
              ar = { up: ar, n: ar.n.l, s: 1 };
          else
            for (; ar.n.l; )
              ar = { up: ar, n: ar.n.l, s: 1 };
        case 1:
          if (ar.s = 2, !ur || $t(cr, ar.n.to) <= 0)
            return { value: ar.n, done: !1 };
        case 2:
          if (ar.n.r) {
            ar.s = 3, ar = { up: ar, n: ar.n.r, s: 0 };
            continue;
          }
        case 3:
          ar = ar.up;
      }
    return { done: !0 };
  } };
}
function Gn(lr) {
  var ar, cr;
  const ur = (((ar = lr.r) === null || ar === void 0 ? void 0 : ar.d) || 0) - (((cr = lr.l) === null || cr === void 0 ? void 0 : cr.d) || 0), fr = ur > 1 ? "r" : ur < -1 ? "l" : "";
  if (fr) {
    const dr = fr === "r" ? "l" : "r", hr = { ...lr }, gr = lr[fr];
    lr.from = gr.from, lr.to = gr.to, lr[fr] = gr[fr], hr[fr] = gr[dr], lr[dr] = hr, hr.d = Hn(hr);
  }
  lr.d = Hn(lr);
}
function Hn({ r: lr, l: ar }) {
  return (lr ? ar ? Math.max(lr.d, ar.d) : lr.d : ar ? ar.d : 0) + 1;
}
a(Ln.prototype, { add(lr) {
  return Wn(this, lr), this;
}, addKey(lr) {
  return Vn(this, lr, lr), this;
}, addKeys(lr) {
  return lr.forEach((ar) => Vn(this, ar, ar)), this;
}, [j]() {
  return zn(this);
} });
const Qn = { stack: "dbcore", level: 0, create: (lr) => {
  const ar = lr.schema.name, cr = new Ln(lr.MIN_KEY, lr.MAX_KEY);
  return { ...lr, table: (ur) => {
    const fr = lr.table(ur), { schema: dr } = fr, { primaryKey: hr } = dr, { extractKey: gr, outbound: vr } = hr, mr = { ...fr, mutate: (kr) => {
      const Tr = kr.trans, _r = Tr.mutatedParts || (Tr.mutatedParts = {}), Er = (Hr) => {
        const $r = `idb://${ar}/${ur}/${Hr}`;
        return _r[$r] || (_r[$r] = new Ln());
      }, xr = Er(""), Cr = Er(":dels"), { type: Ar } = kr;
      let [Lr, Dr] = kr.type === "deleteRange" ? [kr.range] : kr.type === "delete" ? [kr.keys] : kr.values.length < 50 ? [[], kr.values] : [];
      const Nr = kr.trans._cache;
      return fr.mutate(kr).then((Hr) => {
        if (n(Lr)) {
          Ar !== "delete" && (Lr = Hr.results), xr.addKeys(Lr);
          const $r = qn(Lr, Nr);
          $r || Ar === "add" || Cr.addKeys(Lr), ($r || Dr) && function(Wr, Zr, oi, Jr) {
            function Yr(li) {
              const Si = Wr(li.name || "");
              function ci(Ei) {
                return Ei != null ? li.extractKey(Ei) : null;
              }
              const hi = (Ei) => li.multiEntry && n(Ei) ? Ei.forEach((di) => Si.addKey(di)) : Si.addKey(Ei);
              (oi || Jr).forEach((Ei, di) => {
                const gi = oi && ci(oi[di]), Li = Jr && ci(Jr[di]);
                $t(gi, Li) !== 0 && (gi != null && hi(gi), Li != null && hi(Li));
              });
            }
            Zr.indexes.forEach(Yr);
          }(Er, dr, $r, Dr);
        } else if (Lr) {
          const $r = { from: Lr.lower, to: Lr.upper };
          Cr.add($r), xr.add($r);
        } else
          xr.add(cr), Cr.add(cr), dr.indexes.forEach(($r) => Er($r.name).add(cr));
        return Hr;
      });
    } }, br = ({ query: { index: kr, range: Tr } }) => {
      var _r, Er;
      return [kr, new Ln((_r = Tr.lower) !== null && _r !== void 0 ? _r : lr.MIN_KEY, (Er = Tr.upper) !== null && Er !== void 0 ? Er : lr.MAX_KEY)];
    }, yr = { get: (kr) => [hr, new Ln(kr.key)], getMany: (kr) => [hr, new Ln().addKeys(kr.keys)], count: br, query: br, openCursor: br };
    return t(yr).forEach((kr) => {
      mr[kr] = function(Tr) {
        const { subscr: _r } = Oe;
        if (_r) {
          const Er = (Dr) => {
            const Nr = `idb://${ar}/${ur}/${Dr}`;
            return _r[Nr] || (_r[Nr] = new Ln());
          }, xr = Er(""), Cr = Er(":dels"), [Ar, Lr] = yr[kr](Tr);
          if (Er(Ar.name || "").add(Lr), !Ar.isPrimaryKey) {
            if (kr !== "count") {
              const Dr = kr === "query" && vr && Tr.values && fr.query({ ...Tr, values: !1 });
              return fr[kr].apply(this, arguments).then((Nr) => {
                if (kr === "query") {
                  if (vr && Tr.values)
                    return Dr.then(({ result: $r }) => (xr.addKeys($r), Nr));
                  const Hr = Tr.values ? Nr.result.map(gr) : Nr.result;
                  Tr.values ? xr.addKeys(Hr) : Cr.addKeys(Hr);
                } else if (kr === "openCursor") {
                  const Hr = Nr, $r = Tr.values;
                  return Hr && Object.create(Hr, { key: { get: () => (Cr.addKey(Hr.primaryKey), Hr.key) }, primaryKey: { get() {
                    const Wr = Hr.primaryKey;
                    return Cr.addKey(Wr), Wr;
                  } }, value: { get: () => ($r && xr.addKey(Hr.primaryKey), Hr.value) } });
                }
                return Nr;
              });
            }
            Cr.add(cr);
          }
        }
        return fr[kr].apply(this, arguments);
      };
    }), mr;
  } };
} };
class Xn {
  constructor(ar, cr) {
    this._middlewares = {}, this.verno = 0;
    const ur = Xn.dependencies;
    this._options = cr = { addons: Xn.addons, autoOpen: !0, indexedDB: ur.indexedDB, IDBKeyRange: ur.IDBKeyRange, ...cr }, this._deps = { indexedDB: cr.indexedDB, IDBKeyRange: cr.IDBKeyRange };
    const { addons: fr } = cr;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const dr = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: ee$1, dbReadyPromise: null, cancelOpen: ee$1, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var hr;
    dr.dbReadyPromise = new je((gr) => {
      dr.dbReadyResolve = gr;
    }), dr.openCanceller = new je((gr, vr) => {
      dr.cancelOpen = vr;
    }), this._state = dr, this.name = ar, this.on = Dt(this, "populate", "blocked", "versionchange", "close", { ready: [ue, ee$1] }), this.on.ready.subscribe = y(this.on.ready.subscribe, (gr) => (vr, mr) => {
      Xn.vip(() => {
        const br = this._state;
        if (br.openComplete)
          br.dbOpenError || je.resolve().then(vr), mr && gr(vr);
        else if (br.onReadyBeingFired)
          br.onReadyBeingFired.push(vr), mr && gr(vr);
        else {
          gr(vr);
          const yr = this;
          mr || gr(function kr() {
            yr.on.ready.unsubscribe(vr), yr.on.ready.unsubscribe(kr);
          });
        }
      });
    }), this.Collection = (hr = this, It(Vt.prototype, function(gr, vr) {
      this.db = hr;
      let mr = At, br = null;
      if (vr)
        try {
          mr = vr();
        } catch (_r) {
          br = _r;
        }
      const yr = gr._ctx, kr = yr.table, Tr = kr.hook.reading.fire;
      this._ctx = { table: kr, index: yr.index, isPrimKey: !yr.index || kr.schema.primKey.keyPath && yr.index === kr.schema.primKey.name, range: mr, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: br, or: yr.or, valueMapper: Tr !== te ? Tr : null };
    })), this.Table = function(gr) {
      return It(jt.prototype, function(vr, mr, br) {
        this.db = gr, this._tx = br, this.name = vr, this.schema = mr, this.hook = gr._allTables[vr] ? gr._allTables[vr].hook : Dt(null, { creating: [se, ee$1], reading: [ne$1, te], updating: [oe, ee$1], deleting: [ie, ee$1] });
      });
    }(this), this.Transaction = function(gr) {
      return It(an.prototype, function(vr, mr, br, yr, kr) {
        this.db = gr, this.mode = vr, this.storeNames = mr, this.schema = br, this.chromeTransactionDurability = yr, this.idbtrans = null, this.on = Dt(this, "complete", "error", "abort"), this.parent = kr || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je((Tr, _r) => {
          this._resolve = Tr, this._reject = _r;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (Tr) => {
          var _r = this.active;
          return this.active = !1, this.on.error.fire(Tr), this.parent ? this.parent._reject(Tr) : _r && this.idbtrans && this.idbtrans.abort(), ft(Tr);
        });
      });
    }(this), this.Version = function(gr) {
      return It(On.prototype, function(vr) {
        this.db = gr, this._cfg = { version: vr, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(gr) {
      return It(en.prototype, function(vr, mr, br) {
        this.db = gr, this._ctx = { table: vr, index: mr === ":id" ? null : mr, or: br };
        const yr = gr._deps.indexedDB;
        if (!yr)
          throw new X.MissingAPI();
        this._cmp = this._ascending = yr.cmp.bind(yr), this._descending = (kr, Tr) => yr.cmp(Tr, kr), this._max = (kr, Tr) => yr.cmp(kr, Tr) > 0 ? kr : Tr, this._min = (kr, Tr) => yr.cmp(kr, Tr) < 0 ? kr : Tr, this._IDBKeyRange = gr._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (gr) => {
      gr.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (gr) => {
      !gr.newVersion || gr.newVersion < gr.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${gr.oldVersion / 10}`);
    }), this._maxKey = hn(cr.IDBKeyRange), this._createTransaction = (gr, vr, mr, br) => new this.Transaction(gr, vr, mr, this._options.chromeTransactionDurability, br), this._fireOnBlocked = (gr) => {
      this.on("blocked").fire(gr), _t.filter((vr) => vr.name === this.name && vr !== this && !vr._state.vcFired).map((vr) => vr.on("versionchange").fire(gr));
    }, this.use(Fn), this.use(Nn), this.use(Qn), this.use($n), this.vip = Object.create(this, { _vip: { value: !0 } }), fr.forEach((gr) => gr(this));
  }
  version(ar) {
    if (isNaN(ar) || ar < 0.1)
      throw new X.Type("Given version is not a positive number");
    if (ar = Math.round(10 * ar) / 10, this.idbdb || this._state.isBeingOpened)
      throw new X.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, ar);
    const cr = this._versions;
    var ur = cr.filter((fr) => fr._cfg.version === ar)[0];
    return ur || (ur = new this.Version(ar), cr.push(ur), cr.sort(_n), ur.stores({}), this._state.autoSchema = !1, ur);
  }
  _whenReady(ar) {
    return this.idbdb && (this._state.openComplete || Oe.letThrough || this._vip) ? ar() : new je((cr, ur) => {
      if (this._state.openComplete)
        return ur(new X.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void ur(new X.DatabaseClosed());
        this.open().catch(ee$1);
      }
      this._state.dbReadyPromise.then(cr, ur);
    }).then(ar);
  }
  use({ stack: ar, create: cr, level: ur, name: fr }) {
    fr && this.unuse({ stack: ar, name: fr });
    const dr = this._middlewares[ar] || (this._middlewares[ar] = []);
    return dr.push({ stack: ar, create: cr, level: ur == null ? 10 : ur, name: fr }), dr.sort((hr, gr) => hr.level - gr.level), this;
  }
  unuse({ stack: ar, name: cr, create: ur }) {
    return ar && this._middlewares[ar] && (this._middlewares[ar] = this._middlewares[ar].filter((fr) => ur ? fr.create !== ur : !!cr && fr.name !== cr)), this;
  }
  open() {
    return Dn(this);
  }
  _close() {
    const ar = this._state, cr = _t.indexOf(this);
    if (cr >= 0 && _t.splice(cr, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch (ur) {
      }
      this._novip.idbdb = null;
    }
    ar.dbReadyPromise = new je((ur) => {
      ar.dbReadyResolve = ur;
    }), ar.openCanceller = new je((ur, fr) => {
      ar.cancelOpen = fr;
    });
  }
  close() {
    this._close();
    const ar = this._state;
    this._options.autoOpen = !1, ar.dbOpenError = new X.DatabaseClosed(), ar.isBeingOpened && ar.cancelOpen(ar.dbOpenError);
  }
  delete() {
    const ar = arguments.length > 0, cr = this._state;
    return new je((ur, fr) => {
      const dr = () => {
        this.close();
        var hr = this._deps.indexedDB.deleteDatabase(this.name);
        hr.onsuccess = Ye(() => {
          (function({ indexedDB: gr, IDBKeyRange: vr }, mr) {
            !An(gr) && mr !== Pt && Sn(gr, vr).delete(mr).catch(ee$1);
          })(this._deps, this.name), ur();
        }), hr.onerror = tn(fr), hr.onblocked = this._fireOnBlocked;
      };
      if (ar)
        throw new X.InvalidArgument("Arguments not allowed in db.delete()");
      cr.isBeingOpened ? cr.dbReadyPromise.then(dr) : dr();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const ar = this._state.dbOpenError;
    return ar && ar.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return t(this._allTables).map((ar) => this._allTables[ar]);
  }
  transaction() {
    const ar = Bn.apply(this, arguments);
    return this._transaction.apply(this, ar);
  }
  _transaction(ar, cr, ur) {
    let fr = Oe.trans;
    fr && fr.db === this && ar.indexOf("!") === -1 || (fr = null);
    const dr = ar.indexOf("?") !== -1;
    let hr, gr;
    ar = ar.replace("!", "").replace("?", "");
    try {
      if (gr = cr.map((mr) => {
        var br = mr instanceof this.Table ? mr.name : mr;
        if (typeof br != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return br;
      }), ar == "r" || ar === Kt)
        hr = Kt;
      else {
        if (ar != "rw" && ar != Ot)
          throw new X.InvalidArgument("Invalid transaction mode: " + ar);
        hr = Ot;
      }
      if (fr) {
        if (fr.mode === Kt && hr === Ot) {
          if (!dr)
            throw new X.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          fr = null;
        }
        fr && gr.forEach((mr) => {
          if (fr && fr.storeNames.indexOf(mr) === -1) {
            if (!dr)
              throw new X.SubTransaction("Table " + mr + " not included in parent transaction.");
            fr = null;
          }
        }), dr && fr && !fr.active && (fr = null);
      }
    } catch (mr) {
      return fr ? fr._promise(null, (br, yr) => {
        yr(mr);
      }) : ft(mr);
    }
    const vr = Tn.bind(null, this, hr, gr, fr, ur);
    return fr ? fr._promise(hr, vr, "lock") : Oe.trans ? at(Oe.transless, () => this._whenReady(vr)) : this._whenReady(vr);
  }
  table(ar) {
    if (!o(this._allTables, ar))
      throw new X.InvalidTable(`Table ${ar} does not exist`);
    return this._allTables[ar];
  }
}
const Jn = typeof Symbol != "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Zn {
  constructor(ar) {
    this._subscribe = ar;
  }
  subscribe(ar, cr, ur) {
    return this._subscribe(ar && typeof ar != "function" ? ar : { next: ar, error: cr, complete: ur });
  }
  [Jn]() {
    return this;
  }
}
function er(lr, ar) {
  return t(ar).forEach((cr) => {
    Wn(lr[cr] || (lr[cr] = new Ln()), ar[cr]);
  }), lr;
}
function tr(lr) {
  let ar, cr = !1;
  const ur = new Zn((fr) => {
    const dr = T(lr);
    let hr = !1, gr = {}, vr = {};
    const mr = { get closed() {
      return hr;
    }, unsubscribe: () => {
      hr = !0, on$1.storagemutated.unsubscribe(Tr);
    } };
    fr.start && fr.start(mr);
    let br = !1, yr = !1;
    function kr() {
      return t(vr).some((Er) => gr[Er] && Yn(gr[Er], vr[Er]));
    }
    const Tr = (Er) => {
      er(gr, Er), kr() && _r();
    }, _r = () => {
      if (br || hr)
        return;
      gr = {};
      const Er = {}, xr = function(Cr) {
        dr && et();
        const Ar = () => Ze(lr, { subscr: Cr, trans: null }), Lr = Oe.trans ? at(Oe.transless, Ar) : Ar();
        return dr && Lr.then(tt, tt), Lr;
      }(Er);
      yr || (on$1(rn, Tr), yr = !0), br = !0, Promise.resolve(xr).then((Cr) => {
        cr = !0, ar = Cr, br = !1, hr || (kr() ? _r() : (gr = {}, vr = Er, fr.next && fr.next(Cr)));
      }, (Cr) => {
        br = !1, cr = !1, fr.error && fr.error(Cr), mr.unsubscribe();
      });
    };
    return _r(), mr;
  });
  return ur.hasValue = () => cr, ur.getValue = () => ar, ur;
}
let nr;
try {
  nr = { indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB, IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange };
} catch (lr) {
  nr = { indexedDB: null, IDBKeyRange: null };
}
const rr = Xn;
function sr(lr) {
  let ar = ir;
  try {
    ir = !0, on$1.storagemutated.fire(lr);
  } finally {
    ir = ar;
  }
}
a(rr, { ...Z, delete: (lr) => new rr(lr, { addons: [] }).delete(), exists: (lr) => new rr(lr, { addons: [] }).open().then((ar) => (ar.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(lr) {
  try {
    return function({ indexedDB: ar, IDBKeyRange: cr }) {
      return An(ar) ? Promise.resolve(ar.databases()).then((ur) => ur.map((fr) => fr.name).filter((fr) => fr !== Pt)) : Sn(ar, cr).toCollection().primaryKeys();
    }(rr.dependencies).then(lr);
  } catch (ar) {
    return ft(new X.MissingAPI());
  }
}, defineClass: () => function(lr) {
  r(this, lr);
}, ignoreTransaction: (lr) => Oe.trans ? at(Oe.transless, lr) : lr(), vip: Cn, async: function(lr) {
  return function() {
    try {
      var ar = In(lr.apply(this, arguments));
      return ar && typeof ar.then == "function" ? ar : je.resolve(ar);
    } catch (cr) {
      return ft(cr);
    }
  };
}, spawn: function(lr, ar, cr) {
  try {
    var ur = In(lr.apply(cr, ar || []));
    return ur && typeof ur.then == "function" ? ur : je.resolve(ur);
  } catch (fr) {
    return ft(fr);
  }
}, currentTransaction: { get: () => Oe.trans || null }, waitFor: function(lr, ar) {
  const cr = je.resolve(typeof lr == "function" ? rr.ignoreTransaction(lr) : lr).timeout(ar || 6e4);
  return Oe.trans ? Oe.trans.waitFor(cr) : cr;
}, Promise: je, debug: { get: () => R, set: (lr) => {
  F(lr, lr === "dexie" ? () => !0 : Et);
} }, derive: c, extend: r, props: a, override: y, Events: Dt, on: on$1, liveQuery: tr, extendObservabilitySet: er, getByKeyPath: b, setByKeyPath: _, delByKeyPath: function(lr, ar) {
  typeof ar == "string" ? _(lr, ar, void 0) : "length" in ar && [].map.call(ar, function(cr) {
    _(lr, cr, void 0);
  });
}, shallowClone: w, deepClone: O, getObjectDiff: Mn, cmp: $t, asap: v, minKey: vt, addons: [], connections: _t, errnames: H, dependencies: nr, semVer: yt, version: yt.split(".").map((lr) => parseInt(lr)).reduce((lr, ar, cr) => lr + ar / Math.pow(10, 2 * cr)) }), rr.maxKey = hn(rr.dependencies.IDBKeyRange), typeof dispatchEvent != "undefined" && typeof addEventListener != "undefined" && (on$1(rn, (lr) => {
  if (!ir) {
    let ar;
    wt ? (ar = document.createEvent("CustomEvent"), ar.initCustomEvent(sn, !0, !0, lr)) : ar = new CustomEvent(sn, { detail: lr }), ir = !0, dispatchEvent(ar), ir = !1;
  }
}), addEventListener(sn, ({ detail: lr }) => {
  ir || sr(lr);
}));
let ir = !1;
if (typeof BroadcastChannel != "undefined") {
  const lr = new BroadcastChannel(sn);
  typeof lr.unref == "function" && lr.unref(), on$1(rn, (ar) => {
    ir || lr.postMessage(ar);
  }), lr.onmessage = (ar) => {
    ar.data && sr(ar.data);
  };
} else if (typeof self != "undefined" && typeof navigator != "undefined") {
  on$1(rn, (ar) => {
    try {
      ir || (typeof localStorage != "undefined" && localStorage.setItem(sn, JSON.stringify({ trig: Math.random(), changedParts: ar })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((cr) => cr.postMessage({ type: sn, changedParts: ar })));
    } catch (cr) {
    }
  }), typeof addEventListener != "undefined" && addEventListener("storage", (ar) => {
    if (ar.key === sn) {
      const cr = JSON.parse(ar.newValue);
      cr && sr(cr.changedParts);
    }
  });
  const lr = self.document && navigator.serviceWorker;
  lr && lr.addEventListener("message", function({ data: ar }) {
    ar && ar.type === sn && sr(ar.changedParts);
  });
}
je.rejectionMapper = function(lr, ar) {
  if (!lr || lr instanceof W || lr instanceof TypeError || lr instanceof SyntaxError || !lr.name || !J[lr.name])
    return lr;
  var cr = new J[lr.name](ar || lr.message, lr);
  return "stack" in lr && l(cr, "stack", { get: function() {
    return this.inner.stack;
  } }), cr;
}, F(R, Et);
var Database = class extends Xn {
  constructor(ar) {
    super(ar);
    Wi(this, "users");
    Wi(this, "events");
    Wi(this, "eventTags");
    this.version(4).stores({
      users: "&pubkey, profile, createdAt",
      events: "&id, pubkey, content, kind, createdAt, relay, [kind+pubkey]",
      eventTags: "id, tagValue, tag, value, eventId"
    });
  }
}, db;
function createDatabase(lr) {
  db = new Database(lr);
}
var NDKCacheAdapterDexie = class {
  constructor(lr = {}) {
    Wi(this, "debug");
    Wi(this, "expirationTime");
    Wi(this, "locking");
    Wi(this, "profiles");
    Wi(this, "dirtyProfiles", /* @__PURE__ */ new Set());
    createDatabase(lr.dbName || "ndk"), this.debug = lr.debug || _debug("ndk:dexie-adapter"), this.locking = !0, this.expirationTime = lr.expirationTime || 3600, lr.profileCacheSize !== "disabled" && (this.profiles = new dist$9.LRUCache({
      maxSize: lr.profileCacheSize || 1e5
    }), setInterval(() => {
      this.dumpProfiles();
    }, 1e3 * 10));
  }
  async query(lr) {
    Promise.allSettled(
      lr.filters.map((ar) => this.processFilter(ar, lr))
    );
  }
  async fetchProfile(lr) {
    if (!this.profiles)
      return null;
    let ar = this.profiles.get(lr);
    if (!ar) {
      const cr = await db.users.get({ pubkey: lr });
      cr && (ar = cr.profile, this.profiles.set(lr, ar));
    }
    return ar;
  }
  saveProfile(lr, ar) {
    this.profiles && (this.profiles.set(lr, ar), this.dirtyProfiles.add(lr));
  }
  async processFilter(lr, ar) {
    const cr = { ...lr };
    delete cr.limit;
    const ur = Object.keys(cr || {}).sort();
    try {
      await this.byKindAndAuthor(ur, lr, ar) || await this.byAuthors(ur, lr, ar) || await this.byKinds(ur, lr, ar) || await this.byIdsQuery(ur, lr, ar) || await this.byNip33Query(ur, lr, ar) || await this.byTagsAndOptionallyKinds(ur, lr, ar);
    } catch (fr) {
      console.error(fr);
    }
  }
  async setEvent(lr, ar, cr) {
    if (lr.kind === 0) {
      if (!this.profiles)
        return;
      const ur = profileFromEvent(lr);
      this.profiles.set(lr.pubkey, ur);
    } else {
      let ur = !0;
      if (lr.isParamReplaceable()) {
        const fr = `${lr.kind}:${lr.pubkey}:${lr.tagId()}`, dr = await db.events.where({ id: fr }).first();
        dr && lr.created_at && dr.createdAt > lr.created_at && (ur = !1);
      }
      ur && (db.events.put({
        id: lr.tagId(),
        pubkey: lr.pubkey,
        content: lr.content,
        kind: lr.kind,
        createdAt: lr.created_at,
        relay: cr == null ? void 0 : cr.url,
        event: JSON.stringify(lr.rawEvent())
      }), lr.kind !== 3 && lr.tags.forEach((fr) => {
        fr[0].length === 1 && db.eventTags.put({
          id: `${lr.id}:${fr[0]}:${fr[1]}`,
          eventId: lr.id,
          tag: fr[0],
          value: fr[1],
          tagValue: fr[0] + fr[1]
        });
      }));
    }
  }
  /**
   * Searches by authors
   */
  async byAuthors(lr, ar, cr) {
    const ur = ["authors"], fr = lr.length === ur.length && ur.every((hr) => lr.includes(hr));
    let dr = !1;
    if (fr && ar.authors)
      for (const hr of ar.authors) {
        const gr = await db.events.where({ pubkey: hr }).toArray();
        for (const vr of gr) {
          let mr;
          try {
            mr = JSON.parse(vr.event);
          } catch (kr) {
            console.log("failed to parse event", kr);
            continue;
          }
          const br = new NDKEvent(void 0, mr), yr = vr.relay ? new NDKRelay(vr.relay) : void 0;
          cr.eventReceived(br, yr, !0), dr = !0;
        }
      }
    return dr;
  }
  /**
   * Searches by kinds
   */
  async byKinds(lr, ar, cr) {
    const ur = ["kinds"], fr = lr.length === ur.length && ur.every((hr) => lr.includes(hr));
    let dr = !1;
    if (fr && ar.kinds)
      for (const hr of ar.kinds) {
        const gr = await db.events.where({ kind: hr }).toArray();
        for (const vr of gr) {
          let mr;
          try {
            mr = JSON.parse(vr.event);
          } catch (kr) {
            console.log("failed to parse event", kr);
            continue;
          }
          const br = new NDKEvent(void 0, mr), yr = vr.relay ? new NDKRelay(vr.relay) : void 0;
          cr.eventReceived(br, yr, !0), dr = !0;
        }
      }
    return dr;
  }
  /**
   * Searches by ids
   */
  async byIdsQuery(lr, ar, cr) {
    const ur = ["ids"];
    if (lr.length === ur.length && ur.every((dr) => lr.includes(dr)) && ar.ids) {
      for (const dr of ar.ids) {
        const hr = await db.events.where({ id: dr }).first();
        if (!hr)
          continue;
        let gr;
        try {
          gr = JSON.parse(hr.event);
        } catch (br) {
          console.log("failed to parse event", br);
          continue;
        }
        const vr = new NDKEvent(void 0, gr), mr = hr.relay ? new NDKRelay(hr.relay) : void 0;
        cr.eventReceived(vr, mr, !0);
      }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by NIP-33
   */
  async byNip33Query(lr, ar, cr) {
    const ur = ["#d", "authors", "kinds"];
    if (lr.length === ur.length && ur.every((dr) => lr.includes(dr)) && ar.kinds && ar.authors) {
      for (const dr of ar.kinds)
        if (dr >= 3e4 && dr < 4e4)
          for (const gr of ar.authors)
            for (const vr of ar["#d"]) {
              const mr = `${dr}:${gr}:${vr}`, br = await db.events.where({ id: mr }).first();
              if (!br)
                continue;
              let yr;
              try {
                yr = JSON.parse(br.event);
              } catch (_r) {
                console.log("failed to parse event", _r);
                continue;
              }
              const kr = new NDKEvent(void 0, yr), Tr = br.relay ? new NDKRelay(br.relay) : void 0;
              cr.eventReceived(kr, Tr, !0);
            }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by kind & author
   */
  async byKindAndAuthor(lr, ar, cr) {
    const ur = ["authors", "kinds"], fr = lr.length === ur.length && ur.every((hr) => lr.includes(hr));
    let dr = !1;
    if (!fr)
      return !1;
    if (ar.kinds && ar.authors)
      for (const hr of ar.kinds)
        for (const gr of ar.authors) {
          const vr = await db.events.where({ kind: hr, pubkey: gr }).toArray();
          for (const mr of vr) {
            let br;
            try {
              br = JSON.parse(mr.event);
            } catch (Tr) {
              console.log("failed to parse event", Tr);
              continue;
            }
            const yr = new NDKEvent(void 0, br), kr = mr.relay ? new NDKRelay(mr.relay) : void 0;
            cr.eventReceived(yr, kr, !0), dr = !0;
          }
        }
    return dr;
  }
  /**
   * Searches by tags and optionally filters by tags
   */
  async byTagsAndOptionallyKinds(lr, ar, cr) {
    for (const dr of lr) {
      const hr = dr === "kinds", gr = dr.startsWith("#") && dr.length === 2;
      if (!hr && !gr)
        return !1;
    }
    const ur = await this.filterByTag(lr, ar), fr = ar.kinds;
    for (const dr of ur)
      fr != null && fr.includes(dr.kind) && cr.eventReceived(dr, void 0, !0);
    return !1;
  }
  async filterByTag(lr, ar) {
    const cr = [];
    for (const ur of lr) {
      if (ur.length !== 2)
        continue;
      const fr = ur.slice(1), dr = [];
      for (const [hr, gr] of Object.entries(ar))
        hr === ur && dr.push(gr);
      for (const hr of dr) {
        const gr = await db.eventTags.where({ tagValue: fr + hr }).toArray();
        if (!gr.length)
          continue;
        const vr = gr.map((br) => br.eventId), mr = await db.events.where("id").anyOf(vr).toArray();
        for (const br of mr) {
          let yr;
          try {
            if (yr = JSON.parse(br.event), !matchFilter(ar, yr))
              continue;
          } catch (_r) {
            console.log("failed to parse event", _r);
            continue;
          }
          const kr = new NDKEvent(void 0, yr), Tr = br.relay ? new NDKRelay(br.relay) : void 0;
          kr.relay = Tr, cr.push(kr);
        }
      }
    }
    return cr;
  }
  async dumpProfiles() {
    const lr = [];
    if (this.profiles) {
      for (const ar of this.dirtyProfiles) {
        const cr = this.profiles.get(ar);
        cr && lr.push({
          pubkey: ar,
          profile: cr,
          createdAt: Date.now()
        });
      }
      lr.length && await db.users.bulkPut(lr), this.dirtyProfiles.clear();
    }
  }
};
let cacheAdapter;
const defaulRelaysUrls = [
  "wss://purplepag.es",
  "wss://relay.nostr.band",
  "wss://nos.lol",
  "wss://offchain.pub/",
  "wss://nostr-pub.wellorder.net",
  "wss://nostr.mutinywallet.com "
];
window && (cacheAdapter = new NDKCacheAdapterDexie({
  dbName: "walletScrutiny",
  expirationTime: 3600 * 24 * 2
}));
const ndk = new src_default({
  explicitRelayUrls: defaulRelaysUrls,
  cacheAdapter
}), ndkStore = writable(ndk), profileImageUrl = "https://api.dicebear.com/5.x/identicon/svg?seed=", kindNotes = 1, kindOpinion = 30023, kindDelete = 5, kindReaction = 7, uploadUrl = "https://void.cat", DEFAULT_RELAY_URLS = {
  read: defaulRelaysUrls,
  write: defaulRelaysUrls
}, opinionHeaderSeparator = `
<!--HEADER END-->
`, opinionFooterSeparator = `
<!--FOOTER START-->



`, opinionHeaderRegex = new RegExp(`^[\\s\\S]*${opinionHeaderSeparator}`), opinionFooterRegex = new RegExp(`${opinionFooterSeparator}[\\s\\S]*$`);
async function fetchUserProfile(lr) {
  try {
    if (window) {
      const ar = await db.users.where({ pubkey: lr }).first();
      if (ar)
        return ar.profile;
      {
        const ur = get_store_value(ndkStore).getUser({ pubkey: lr });
        return await ur.fetchProfile({
          closeOnEose: !0,
          groupable: !1,
          groupableDelay: 200
        }), ur.profile;
      }
    } else
      return {};
  } catch (ar) {
    throw console.error(ar), ar;
  }
}
function logout() {
  ndkUser.set(null), isNip05Valid.set({
    isNip05Valid: null,
    Nip05address: void 0,
    UserNpub: void 0,
    Vanity: void 0,
    UserIdentifier: void 0
  }), activeProfile.set(null), localStore.update(() => ({
    lastUserLogged: void 0,
    pk: void 0
  }));
}
async function NDKlogin() {
  try {
    const lr = get_store_value(ndkStore), ar = new NDKNip07Signer();
    lr.signer = ar, ndkStore.set(lr);
    const cr = await ar.user(), ur = lr.getUser({
      pubkey: cr.pubkey,
      npub: cr.npub
    });
    return ndkUser.set(ur), localStore.set({ lastUserLogged: cr.npub, pk: void 0 }), ur;
  } catch (lr) {
    return;
  }
}
async function privkeyLogin(lr) {
  if (lr)
    try {
      const ar = get_store_value(ndkStore), cr = new NDKPrivateKeySigner(lr);
      ar.signer = cr, ndkStore.set(ar);
      const ur = await cr.user(), fr = ar.getUser({
        pubkey: ur.pubkey,
        npub: ur.npub
      });
      return ndkUser.set(fr), localStore.set({ lastUserLogged: ur.npub, pk: lr }), fr;
    } catch (ar) {
      return;
    }
}
function calculateRelativeTime(lr) {
  const ar = /* @__PURE__ */ new Date(), cr = new Date(lr * 1e3), ur = Math.floor((ar.valueOf() - cr.valueOf()) / 1e3);
  return ur < 60 ? `${ur} seconds ago` : ur < 3600 ? `${Math.floor(ur / 60)} minutes ago` : ur < 86400 ? `${Math.floor(ur / 3600)} hours ago` : `${Math.floor(ur / 86400)} days ago`;
}
function number$1(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bytes$1(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$1(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(lr.outputLen), number$1(lr.blockLen);
}
function exists$1(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(lr, ar) {
  bytes$1(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const crypto$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$2 = (lr) => lr instanceof Uint8Array, createView$1 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$1 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$1(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$2(lr)), !u8a$2(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$2(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$2(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$1 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(lr) {
  const ar = (ur) => lr().update(toBytes$1(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$1(lr = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues == "function")
    return crypto$2.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
let SHA2$1 = class extends Hash$1 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$1(this.buffer);
  }
  update(ar) {
    exists$1(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$1(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView$1(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$1(this), output$1(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64$1(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView$1(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$2 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$1 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class extends SHA2$1 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W$1[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W$1[yr - 15], Tr = SHA256_W$1[yr - 2], _r = rotr$1(kr, 7) ^ rotr$1(kr, 18) ^ kr >>> 3, Er = rotr$1(Tr, 17) ^ rotr$1(Tr, 19) ^ Tr >>> 10;
      SHA256_W$1[yr] = Er + SHA256_W$1[yr - 7] + _r + SHA256_W$1[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr$1(gr, 6) ^ rotr$1(gr, 11) ^ rotr$1(gr, 25), Tr = br + kr + Chi$2(gr, vr, mr) + SHA256_K$1[yr] + SHA256_W$1[yr] | 0, Er = (rotr$1(ur, 2) ^ rotr$1(ur, 13) ^ rotr$1(ur, 22)) + Maj$1(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a$1 = (lr) => lr instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$1(lr) {
  if (!u8a$1(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$1[lr[cr]];
  return ar;
}
function numberToHexUnpadded(lr) {
  const ar = lr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  return BigInt(lr === "" ? "0" : `0x${lr}`);
}
function hexToBytes$2(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function bytesToNumberBE(lr) {
  return hexToNumber(bytesToHex$1(lr));
}
function bytesToNumberLE(lr) {
  if (!u8a$1(lr))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(lr).reverse()));
}
function numberToBytesBE(lr, ar) {
  return hexToBytes$2(lr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE(lr, ar) {
  return numberToBytesBE(lr, ar).reverse();
}
function numberToVarBytesBE(lr) {
  return hexToBytes$2(numberToHexUnpadded(lr));
}
function ensureBytes(lr, ar, cr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$2(ar);
    } catch (dr) {
      throw new Error(`${lr} must be valid hex string, got "${ar}". Cause: ${dr}`);
    }
  else if (u8a$1(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${lr} must be hex string or Uint8Array`);
  const fr = ur.length;
  if (typeof cr == "number" && fr !== cr)
    throw new Error(`${lr} expected ${cr} bytes, got ${fr}`);
  return ur;
}
function concatBytes$1(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$1(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
function equalBytes(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length; cr++)
    if (lr[cr] !== ar[cr])
      return !1;
  return !0;
}
function utf8ToBytes$1(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function bitLen(lr) {
  let ar;
  for (ar = 0; lr > _0n$4; lr >>= _1n$4, ar += 1)
    ;
  return ar;
}
function bitGet(lr, ar) {
  return lr >> BigInt(ar) & _1n$4;
}
const bitSet = (lr, ar, cr) => lr | (cr ? _1n$4 : _0n$4) << BigInt(ar), bitMask = (lr) => (_2n$2 << BigInt(lr - 1)) - _1n$4, u8n = (lr) => new Uint8Array(lr), u8fr = (lr) => Uint8Array.from(lr);
function createHmacDrbg(lr, ar, cr) {
  if (typeof lr != "number" || lr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof cr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n(lr), fr = u8n(lr), dr = 0;
  const hr = () => {
    ur.fill(1), fr.fill(0), dr = 0;
  }, gr = (...yr) => cr(fr, ur, ...yr), vr = (yr = u8n()) => {
    fr = gr(u8fr([0]), yr), ur = gr(), yr.length !== 0 && (fr = gr(u8fr([1]), yr), ur = gr());
  }, mr = () => {
    if (dr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let yr = 0;
    const kr = [];
    for (; yr < ar; ) {
      ur = gr();
      const Tr = ur.slice();
      kr.push(Tr), yr += ur.length;
    }
    return concatBytes$1(...kr);
  };
  return (yr, kr) => {
    hr(), vr(yr);
    let Tr;
    for (; !(Tr = kr(mr())); )
      vr();
    return hr(), Tr;
  };
}
const validatorFns = {
  bigint: (lr) => typeof lr == "bigint",
  function: (lr) => typeof lr == "function",
  boolean: (lr) => typeof lr == "boolean",
  string: (lr) => typeof lr == "string",
  stringOrUint8Array: (lr) => typeof lr == "string" || lr instanceof Uint8Array,
  isSafeInteger: (lr) => Number.isSafeInteger(lr),
  array: (lr) => Array.isArray(lr),
  field: (lr, ar) => ar.Fp.isValid(lr),
  hash: (lr) => typeof lr == "function" && Number.isSafeInteger(lr.outputLen)
};
function validateObject(lr, ar, cr = {}) {
  const ur = (fr, dr, hr) => {
    const gr = validatorFns[dr];
    if (typeof gr != "function")
      throw new Error(`Invalid validator "${dr}", expected function`);
    const vr = lr[fr];
    if (!(hr && vr === void 0) && !gr(vr, lr))
      throw new Error(`Invalid param ${String(fr)}=${vr} (${typeof vr}), expected ${dr}`);
  };
  for (const [fr, dr] of Object.entries(ar))
    ur(fr, dr, !1);
  for (const [fr, dr] of Object.entries(cr))
    ur(fr, dr, !0);
  return lr;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes: concatBytes$1,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes: hexToBytes$2,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(lr, ar) {
  const cr = lr % ar;
  return cr >= _0n$3 ? cr : ar + cr;
}
function pow(lr, ar, cr) {
  if (cr <= _0n$3 || ar < _0n$3)
    throw new Error("Expected power/modulo > 0");
  if (cr === _1n$3)
    return _0n$3;
  let ur = _1n$3;
  for (; ar > _0n$3; )
    ar & _1n$3 && (ur = ur * lr % cr), lr = lr * lr % cr, ar >>= _1n$3;
  return ur;
}
function pow2(lr, ar, cr) {
  let ur = lr;
  for (; ar-- > _0n$3; )
    ur *= ur, ur %= cr;
  return ur;
}
function invert(lr, ar) {
  if (lr === _0n$3 || ar <= _0n$3)
    throw new Error(`invert: expected positive integers, got n=${lr} mod=${ar}`);
  let cr = mod(lr, ar), ur = ar, fr = _0n$3, dr = _1n$3;
  for (; cr !== _0n$3; ) {
    const gr = ur / cr, vr = ur % cr, mr = fr - dr * gr;
    ur = cr, cr = vr, fr = dr, dr = mr;
  }
  if (ur !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(fr, ar);
}
function tonelliShanks(lr) {
  const ar = (lr - _1n$3) / _2n$1;
  let cr, ur, fr;
  for (cr = lr - _1n$3, ur = 0; cr % _2n$1 === _0n$3; cr /= _2n$1, ur++)
    ;
  for (fr = _2n$1; fr < lr && pow(fr, ar, lr) !== lr - _1n$3; fr++)
    ;
  if (ur === 1) {
    const hr = (lr + _1n$3) / _4n;
    return function(vr, mr) {
      const br = vr.pow(mr, hr);
      if (!vr.eql(vr.sqr(br), mr))
        throw new Error("Cannot find square root");
      return br;
    };
  }
  const dr = (cr + _1n$3) / _2n$1;
  return function(gr, vr) {
    if (gr.pow(vr, ar) === gr.neg(gr.ONE))
      throw new Error("Cannot find square root");
    let mr = ur, br = gr.pow(gr.mul(gr.ONE, fr), cr), yr = gr.pow(vr, dr), kr = gr.pow(vr, cr);
    for (; !gr.eql(kr, gr.ONE); ) {
      if (gr.eql(kr, gr.ZERO))
        return gr.ZERO;
      let Tr = 1;
      for (let Er = gr.sqr(kr); Tr < mr && !gr.eql(Er, gr.ONE); Tr++)
        Er = gr.sqr(Er);
      const _r = gr.pow(br, _1n$3 << BigInt(mr - Tr - 1));
      br = gr.sqr(_r), yr = gr.mul(yr, _r), kr = gr.mul(kr, br), mr = Tr;
    }
    return yr;
  };
}
function FpSqrt(lr) {
  if (lr % _4n === _3n$1) {
    const ar = (lr + _1n$3) / _4n;
    return function(ur, fr) {
      const dr = ur.pow(fr, ar);
      if (!ur.eql(ur.sqr(dr), fr))
        throw new Error("Cannot find square root");
      return dr;
    };
  }
  if (lr % _8n === _5n) {
    const ar = (lr - _5n) / _8n;
    return function(ur, fr) {
      const dr = ur.mul(fr, _2n$1), hr = ur.pow(dr, ar), gr = ur.mul(fr, hr), vr = ur.mul(ur.mul(gr, _2n$1), hr), mr = ur.mul(gr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(mr), fr))
        throw new Error("Cannot find square root");
      return mr;
    };
  }
  return tonelliShanks(lr);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(lr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, cr = FIELD_FIELDS.reduce((ur, fr) => (ur[fr] = "function", ur), ar);
  return validateObject(lr, cr);
}
function FpPow(lr, ar, cr) {
  if (cr < _0n$3)
    throw new Error("Expected power > 0");
  if (cr === _0n$3)
    return lr.ONE;
  if (cr === _1n$3)
    return ar;
  let ur = lr.ONE, fr = ar;
  for (; cr > _0n$3; )
    cr & _1n$3 && (ur = lr.mul(ur, fr)), fr = lr.sqr(fr), cr >>= _1n$3;
  return ur;
}
function FpInvertBatch(lr, ar) {
  const cr = new Array(ar.length), ur = ar.reduce((dr, hr, gr) => lr.is0(hr) ? dr : (cr[gr] = dr, lr.mul(dr, hr)), lr.ONE), fr = lr.inv(ur);
  return ar.reduceRight((dr, hr, gr) => lr.is0(hr) ? dr : (cr[gr] = lr.mul(dr, cr[gr]), lr.mul(dr, hr)), fr), cr;
}
function nLength(lr, ar) {
  const cr = ar !== void 0 ? ar : lr.toString(2).length, ur = Math.ceil(cr / 8);
  return { nBitLength: cr, nByteLength: ur };
}
function Field(lr, ar, cr = !1, ur = {}) {
  if (lr <= _0n$3)
    throw new Error(`Expected Field ORDER > 0, got ${lr}`);
  const { nBitLength: fr, nByteLength: dr } = nLength(lr, ar);
  if (dr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const hr = FpSqrt(lr), gr = Object.freeze({
    ORDER: lr,
    BITS: fr,
    BYTES: dr,
    MASK: bitMask(fr),
    ZERO: _0n$3,
    ONE: _1n$3,
    create: (vr) => mod(vr, lr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$3 <= vr && vr < lr;
    },
    is0: (vr) => vr === _0n$3,
    isOdd: (vr) => (vr & _1n$3) === _1n$3,
    neg: (vr) => mod(-vr, lr),
    eql: (vr, mr) => vr === mr,
    sqr: (vr) => mod(vr * vr, lr),
    add: (vr, mr) => mod(vr + mr, lr),
    sub: (vr, mr) => mod(vr - mr, lr),
    mul: (vr, mr) => mod(vr * mr, lr),
    pow: (vr, mr) => FpPow(gr, vr, mr),
    div: (vr, mr) => mod(vr * invert(mr, lr), lr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, mr) => vr + mr,
    subN: (vr, mr) => vr - mr,
    mulN: (vr, mr) => vr * mr,
    inv: (vr) => invert(vr, lr),
    sqrt: ur.sqrt || ((vr) => hr(gr, vr)),
    invertBatch: (vr) => FpInvertBatch(gr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, mr, br) => br ? mr : vr,
    toBytes: (vr) => cr ? numberToBytesLE(vr, dr) : numberToBytesBE(vr, dr),
    fromBytes: (vr) => {
      if (vr.length !== dr)
        throw new Error(`Fp.fromBytes: expected ${dr}, got ${vr.length}`);
      return cr ? bytesToNumberLE(vr) : bytesToNumberBE(vr);
    }
  });
  return Object.freeze(gr);
}
function getFieldBytesLength(lr) {
  if (typeof lr != "bigint")
    throw new Error("field order must be bigint");
  const ar = lr.toString(2).length;
  return Math.ceil(ar / 8);
}
function getMinHashLength(lr) {
  const ar = getFieldBytesLength(lr);
  return ar + Math.ceil(ar / 2);
}
function mapHashToField(lr, ar, cr = !1) {
  const ur = lr.length, fr = getFieldBytesLength(ar), dr = getMinHashLength(ar);
  if (ur < 16 || ur < dr || ur > 1024)
    throw new Error(`expected ${dr}-1024 bytes of input, got ${ur}`);
  const hr = cr ? bytesToNumberBE(lr) : bytesToNumberLE(lr), gr = mod(hr, ar - _1n$3) + _1n$3;
  return cr ? numberToBytesLE(gr, fr) : numberToBytesBE(gr, fr);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(lr, ar) {
  const cr = (fr, dr) => {
    const hr = dr.negate();
    return fr ? hr : dr;
  }, ur = (fr) => {
    const dr = Math.ceil(ar / fr) + 1, hr = 2 ** (fr - 1);
    return { windows: dr, windowSize: hr };
  };
  return {
    constTimeNegate: cr,
    // non-const time multiplication ladder
    unsafeLadder(fr, dr) {
      let hr = lr.ZERO, gr = fr;
      for (; dr > _0n$2; )
        dr & _1n$2 && (hr = hr.add(gr)), gr = gr.double(), dr >>= _1n$2;
      return hr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(fr, dr) {
      const { windows: hr, windowSize: gr } = ur(dr), vr = [];
      let mr = fr, br = mr;
      for (let yr = 0; yr < hr; yr++) {
        br = mr, vr.push(br);
        for (let kr = 1; kr < gr; kr++)
          br = br.add(mr), vr.push(br);
        mr = br.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(fr, dr, hr) {
      const { windows: gr, windowSize: vr } = ur(fr);
      let mr = lr.ZERO, br = lr.BASE;
      const yr = BigInt(2 ** fr - 1), kr = 2 ** fr, Tr = BigInt(fr);
      for (let _r = 0; _r < gr; _r++) {
        const Er = _r * vr;
        let xr = Number(hr & yr);
        hr >>= Tr, xr > vr && (xr -= kr, hr += _1n$2);
        const Cr = Er, Ar = Er + Math.abs(xr) - 1, Lr = _r % 2 !== 0, Dr = xr < 0;
        xr === 0 ? br = br.add(cr(Lr, dr[Cr])) : mr = mr.add(cr(Dr, dr[Ar]));
      }
      return { p: mr, f: br };
    },
    wNAFCached(fr, dr, hr, gr) {
      const vr = fr._WINDOW_SIZE || 1;
      let mr = dr.get(fr);
      return mr || (mr = this.precomputeWindow(fr, vr), vr !== 1 && dr.set(fr, gr(mr))), this.wNAF(vr, mr, hr);
    }
  };
}
function validateBasic(lr) {
  return validateField(lr.Fp), validateObject(lr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(lr.n, lr.nBitLength),
    ...lr,
    p: lr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(lr) {
  const ar = validateBasic(lr);
  validateObject(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: cr, Fp: ur, a: fr } = ar;
  if (cr) {
    if (!ur.eql(fr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof cr != "object" || typeof cr.beta != "bigint" || typeof cr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(lr) {
    const { Err: ar } = DER;
    if (lr.length < 2 || lr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const cr = lr[1], ur = lr.subarray(2, cr + 2);
    if (!cr || ur.length !== cr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(ur), l: lr.subarray(cr + 2) };
  },
  toSig(lr) {
    const { Err: ar } = DER, cr = typeof lr == "string" ? h2b(lr) : lr;
    if (!(cr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = cr.length;
    if (ur < 2 || cr[0] != 48)
      throw new ar("Invalid signature tag");
    if (cr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: fr, l: dr } = DER._parseInt(cr.subarray(2)), { d: hr, l: gr } = DER._parseInt(dr);
    if (gr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: fr, s: hr };
  },
  hexFromSig(lr) {
    const ar = (mr) => Number.parseInt(mr[0], 16) & 8 ? "00" + mr : mr, cr = (mr) => {
      const br = mr.toString(16);
      return br.length & 1 ? `0${br}` : br;
    }, ur = ar(cr(lr.s)), fr = ar(cr(lr.r)), dr = ur.length / 2, hr = fr.length / 2, gr = cr(dr), vr = cr(hr);
    return `30${cr(hr + dr + 4)}02${vr}${fr}02${gr}${ur}`;
  }
}, _0n$1 = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(lr) {
  const ar = validatePointOpts(lr), { Fp: cr } = ar, ur = ar.toBytes || ((_r, Er, xr) => {
    const Cr = Er.toAffine();
    return concatBytes$1(Uint8Array.from([4]), cr.toBytes(Cr.x), cr.toBytes(Cr.y));
  }), fr = ar.fromBytes || ((_r) => {
    const Er = _r.subarray(1), xr = cr.fromBytes(Er.subarray(0, cr.BYTES)), Cr = cr.fromBytes(Er.subarray(cr.BYTES, 2 * cr.BYTES));
    return { x: xr, y: Cr };
  });
  function dr(_r) {
    const { a: Er, b: xr } = ar, Cr = cr.sqr(_r), Ar = cr.mul(Cr, _r);
    return cr.add(cr.add(Ar, cr.mul(_r, Er)), xr);
  }
  if (!cr.eql(cr.sqr(ar.Gy), dr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function hr(_r) {
    return typeof _r == "bigint" && _0n$1 < _r && _r < ar.n;
  }
  function gr(_r) {
    if (!hr(_r))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(_r) {
    const { allowedPrivateKeyLengths: Er, nByteLength: xr, wrapPrivateKey: Cr, n: Ar } = ar;
    if (Er && typeof _r != "bigint") {
      if (_r instanceof Uint8Array && (_r = bytesToHex$1(_r)), typeof _r != "string" || !Er.includes(_r.length))
        throw new Error("Invalid key");
      _r = _r.padStart(xr * 2, "0");
    }
    let Lr;
    try {
      Lr = typeof _r == "bigint" ? _r : bytesToNumberBE(ensureBytes("private key", _r, xr));
    } catch (Dr) {
      throw new Error(`private key must be ${xr} bytes, hex or bigint, not ${typeof _r}`);
    }
    return Cr && (Lr = mod(Lr, Ar)), gr(Lr), Lr;
  }
  const mr = /* @__PURE__ */ new Map();
  function br(_r) {
    if (!(_r instanceof yr))
      throw new Error("ProjectivePoint expected");
  }
  class yr {
    constructor(Er, xr, Cr) {
      if (this.px = Er, this.py = xr, this.pz = Cr, Er == null || !cr.isValid(Er))
        throw new Error("x required");
      if (xr == null || !cr.isValid(xr))
        throw new Error("y required");
      if (Cr == null || !cr.isValid(Cr))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Er) {
      const { x: xr, y: Cr } = Er || {};
      if (!Er || !cr.isValid(xr) || !cr.isValid(Cr))
        throw new Error("invalid affine point");
      if (Er instanceof yr)
        throw new Error("projective point not allowed");
      const Ar = (Lr) => cr.eql(Lr, cr.ZERO);
      return Ar(xr) && Ar(Cr) ? yr.ZERO : new yr(xr, Cr, cr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Er) {
      const xr = cr.invertBatch(Er.map((Cr) => Cr.pz));
      return Er.map((Cr, Ar) => Cr.toAffine(xr[Ar])).map(yr.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Er) {
      const xr = yr.fromAffine(fr(ensureBytes("pointHex", Er)));
      return xr.assertValidity(), xr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Er) {
      return yr.BASE.multiply(vr(Er));
    }
    // "Private method", don't use it directly
    _setWindowSize(Er) {
      this._WINDOW_SIZE = Er, mr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint && !cr.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Er, y: xr } = this.toAffine();
      if (!cr.isValid(Er) || !cr.isValid(xr))
        throw new Error("bad point: x or y not FE");
      const Cr = cr.sqr(xr), Ar = dr(Er);
      if (!cr.eql(Cr, Ar))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Er } = this.toAffine();
      if (cr.isOdd)
        return !cr.isOdd(Er);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Er) {
      br(Er);
      const { px: xr, py: Cr, pz: Ar } = this, { px: Lr, py: Dr, pz: Nr } = Er, Hr = cr.eql(cr.mul(xr, Nr), cr.mul(Lr, Ar)), $r = cr.eql(cr.mul(Cr, Nr), cr.mul(Dr, Ar));
      return Hr && $r;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new yr(this.px, cr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Er, b: xr } = ar, Cr = cr.mul(xr, _3n), { px: Ar, py: Lr, pz: Dr } = this;
      let Nr = cr.ZERO, Hr = cr.ZERO, $r = cr.ZERO, Wr = cr.mul(Ar, Ar), Zr = cr.mul(Lr, Lr), oi = cr.mul(Dr, Dr), Jr = cr.mul(Ar, Lr);
      return Jr = cr.add(Jr, Jr), $r = cr.mul(Ar, Dr), $r = cr.add($r, $r), Nr = cr.mul(Er, $r), Hr = cr.mul(Cr, oi), Hr = cr.add(Nr, Hr), Nr = cr.sub(Zr, Hr), Hr = cr.add(Zr, Hr), Hr = cr.mul(Nr, Hr), Nr = cr.mul(Jr, Nr), $r = cr.mul(Cr, $r), oi = cr.mul(Er, oi), Jr = cr.sub(Wr, oi), Jr = cr.mul(Er, Jr), Jr = cr.add(Jr, $r), $r = cr.add(Wr, Wr), Wr = cr.add($r, Wr), Wr = cr.add(Wr, oi), Wr = cr.mul(Wr, Jr), Hr = cr.add(Hr, Wr), oi = cr.mul(Lr, Dr), oi = cr.add(oi, oi), Wr = cr.mul(oi, Jr), Nr = cr.sub(Nr, Wr), $r = cr.mul(oi, Zr), $r = cr.add($r, $r), $r = cr.add($r, $r), new yr(Nr, Hr, $r);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Er) {
      br(Er);
      const { px: xr, py: Cr, pz: Ar } = this, { px: Lr, py: Dr, pz: Nr } = Er;
      let Hr = cr.ZERO, $r = cr.ZERO, Wr = cr.ZERO;
      const Zr = ar.a, oi = cr.mul(ar.b, _3n);
      let Jr = cr.mul(xr, Lr), Yr = cr.mul(Cr, Dr), li = cr.mul(Ar, Nr), Si = cr.add(xr, Cr), ci = cr.add(Lr, Dr);
      Si = cr.mul(Si, ci), ci = cr.add(Jr, Yr), Si = cr.sub(Si, ci), ci = cr.add(xr, Ar);
      let hi = cr.add(Lr, Nr);
      return ci = cr.mul(ci, hi), hi = cr.add(Jr, li), ci = cr.sub(ci, hi), hi = cr.add(Cr, Ar), Hr = cr.add(Dr, Nr), hi = cr.mul(hi, Hr), Hr = cr.add(Yr, li), hi = cr.sub(hi, Hr), Wr = cr.mul(Zr, ci), Hr = cr.mul(oi, li), Wr = cr.add(Hr, Wr), Hr = cr.sub(Yr, Wr), Wr = cr.add(Yr, Wr), $r = cr.mul(Hr, Wr), Yr = cr.add(Jr, Jr), Yr = cr.add(Yr, Jr), li = cr.mul(Zr, li), ci = cr.mul(oi, ci), Yr = cr.add(Yr, li), li = cr.sub(Jr, li), li = cr.mul(Zr, li), ci = cr.add(ci, li), Jr = cr.mul(Yr, ci), $r = cr.add($r, Jr), Jr = cr.mul(hi, ci), Hr = cr.mul(Si, Hr), Hr = cr.sub(Hr, Jr), Jr = cr.mul(Si, Yr), Wr = cr.mul(hi, Wr), Wr = cr.add(Wr, Jr), new yr(Hr, $r, Wr);
    }
    subtract(Er) {
      return this.add(Er.negate());
    }
    is0() {
      return this.equals(yr.ZERO);
    }
    wNAF(Er) {
      return Tr.wNAFCached(this, mr, Er, (xr) => {
        const Cr = cr.invertBatch(xr.map((Ar) => Ar.pz));
        return xr.map((Ar, Lr) => Ar.toAffine(Cr[Lr])).map(yr.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Er) {
      const xr = yr.ZERO;
      if (Er === _0n$1)
        return xr;
      if (gr(Er), Er === _1n$1)
        return this;
      const { endo: Cr } = ar;
      if (!Cr)
        return Tr.unsafeLadder(this, Er);
      let { k1neg: Ar, k1: Lr, k2neg: Dr, k2: Nr } = Cr.splitScalar(Er), Hr = xr, $r = xr, Wr = this;
      for (; Lr > _0n$1 || Nr > _0n$1; )
        Lr & _1n$1 && (Hr = Hr.add(Wr)), Nr & _1n$1 && ($r = $r.add(Wr)), Wr = Wr.double(), Lr >>= _1n$1, Nr >>= _1n$1;
      return Ar && (Hr = Hr.negate()), Dr && ($r = $r.negate()), $r = new yr(cr.mul($r.px, Cr.beta), $r.py, $r.pz), Hr.add($r);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Er) {
      gr(Er);
      let xr = Er, Cr, Ar;
      const { endo: Lr } = ar;
      if (Lr) {
        const { k1neg: Dr, k1: Nr, k2neg: Hr, k2: $r } = Lr.splitScalar(xr);
        let { p: Wr, f: Zr } = this.wNAF(Nr), { p: oi, f: Jr } = this.wNAF($r);
        Wr = Tr.constTimeNegate(Dr, Wr), oi = Tr.constTimeNegate(Hr, oi), oi = new yr(cr.mul(oi.px, Lr.beta), oi.py, oi.pz), Cr = Wr.add(oi), Ar = Zr.add(Jr);
      } else {
        const { p: Dr, f: Nr } = this.wNAF(xr);
        Cr = Dr, Ar = Nr;
      }
      return yr.normalizeZ([Cr, Ar])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Er, xr, Cr) {
      const Ar = yr.BASE, Lr = (Nr, Hr) => Hr === _0n$1 || Hr === _1n$1 || !Nr.equals(Ar) ? Nr.multiplyUnsafe(Hr) : Nr.multiply(Hr), Dr = Lr(this, xr).add(Lr(Er, Cr));
      return Dr.is0() ? void 0 : Dr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(Er) {
      const { px: xr, py: Cr, pz: Ar } = this, Lr = this.is0();
      Er == null && (Er = Lr ? cr.ONE : cr.inv(Ar));
      const Dr = cr.mul(xr, Er), Nr = cr.mul(Cr, Er), Hr = cr.mul(Ar, Er);
      if (Lr)
        return { x: cr.ZERO, y: cr.ZERO };
      if (!cr.eql(Hr, cr.ONE))
        throw new Error("invZ was invalid");
      return { x: Dr, y: Nr };
    }
    isTorsionFree() {
      const { h: Er, isTorsionFree: xr } = ar;
      if (Er === _1n$1)
        return !0;
      if (xr)
        return xr(yr, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Er, clearCofactor: xr } = ar;
      return Er === _1n$1 ? this : xr ? xr(yr, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Er = !0) {
      return this.assertValidity(), ur(yr, this, Er);
    }
    toHex(Er = !0) {
      return bytesToHex$1(this.toRawBytes(Er));
    }
  }
  yr.BASE = new yr(ar.Gx, ar.Gy, cr.ONE), yr.ZERO = new yr(cr.ZERO, cr.ONE, cr.ZERO);
  const kr = ar.nBitLength, Tr = wNAF(yr, ar.endo ? Math.ceil(kr / 2) : kr);
  return {
    CURVE: ar,
    ProjectivePoint: yr,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: dr,
    isWithinCurveOrder: hr
  };
}
function validateOpts(lr) {
  const ar = validateBasic(lr);
  return validateObject(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass(lr) {
  const ar = validateOpts(lr), { Fp: cr, n: ur } = ar, fr = cr.BYTES + 1, dr = 2 * cr.BYTES + 1;
  function hr(ci) {
    return _0n$1 < ci && ci < cr.ORDER;
  }
  function gr(ci) {
    return mod(ci, ur);
  }
  function vr(ci) {
    return invert(ci, ur);
  }
  const { ProjectivePoint: mr, normPrivateKeyToScalar: br, weierstrassEquation: yr, isWithinCurveOrder: kr } = weierstrassPoints({
    ...ar,
    toBytes(ci, hi, Ei) {
      const di = hi.toAffine(), gi = cr.toBytes(di.x), Li = concatBytes$1;
      return Ei ? Li(Uint8Array.from([hi.hasEvenY() ? 2 : 3]), gi) : Li(Uint8Array.from([4]), gi, cr.toBytes(di.y));
    },
    fromBytes(ci) {
      const hi = ci.length, Ei = ci[0], di = ci.subarray(1);
      if (hi === fr && (Ei === 2 || Ei === 3)) {
        const gi = bytesToNumberBE(di);
        if (!hr(gi))
          throw new Error("Point is not on curve");
        const Li = yr(gi);
        let ui = cr.sqrt(Li);
        const wi = (ui & _1n$1) === _1n$1;
        return (Ei & 1) === 1 !== wi && (ui = cr.neg(ui)), { x: gi, y: ui };
      } else if (hi === dr && Ei === 4) {
        const gi = cr.fromBytes(di.subarray(0, cr.BYTES)), Li = cr.fromBytes(di.subarray(cr.BYTES, 2 * cr.BYTES));
        return { x: gi, y: Li };
      } else
        throw new Error(`Point of length ${hi} was invalid. Expected ${fr} compressed bytes or ${dr} uncompressed bytes`);
    }
  }), Tr = (ci) => bytesToHex$1(numberToBytesBE(ci, ar.nByteLength));
  function _r(ci) {
    const hi = ur >> _1n$1;
    return ci > hi;
  }
  function Er(ci) {
    return _r(ci) ? gr(-ci) : ci;
  }
  const xr = (ci, hi, Ei) => bytesToNumberBE(ci.slice(hi, Ei));
  class Cr {
    constructor(hi, Ei, di) {
      this.r = hi, this.s = Ei, this.recovery = di, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hi) {
      const Ei = ar.nByteLength;
      return hi = ensureBytes("compactSignature", hi, Ei * 2), new Cr(xr(hi, 0, Ei), xr(hi, Ei, 2 * Ei));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hi) {
      const { r: Ei, s: di } = DER.toSig(ensureBytes("DER", hi));
      return new Cr(Ei, di);
    }
    assertValidity() {
      if (!kr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!kr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(hi) {
      return new Cr(this.r, this.s, hi);
    }
    recoverPublicKey(hi) {
      const { r: Ei, s: di, recovery: gi } = this, Li = $r(ensureBytes("msgHash", hi));
      if (gi == null || ![0, 1, 2, 3].includes(gi))
        throw new Error("recovery id invalid");
      const ui = gi === 2 || gi === 3 ? Ei + ar.n : Ei;
      if (ui >= cr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const wi = gi & 1 ? "03" : "02", Ui = mr.fromHex(wi + Tr(ui)), yi = vr(ui), Vi = gr(-Li * yi), Oi = gr(di * yi), Mi = mr.BASE.multiplyAndAddUnsafe(Ui, Vi, Oi);
      if (!Mi)
        throw new Error("point at infinify");
      return Mi.assertValidity(), Mi;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return _r(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Cr(this.r, gr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$2(this.toCompactHex());
    }
    toCompactHex() {
      return Tr(this.r) + Tr(this.s);
    }
  }
  const Ar = {
    isValidPrivateKey(ci) {
      try {
        return br(ci), !0;
      } catch (hi) {
        return !1;
      }
    },
    normPrivateKeyToScalar: br,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const ci = getMinHashLength(ar.n);
      return mapHashToField(ar.randomBytes(ci), ar.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(ci = 8, hi = mr.BASE) {
      return hi._setWindowSize(ci), hi.multiply(BigInt(3)), hi;
    }
  };
  function Lr(ci, hi = !0) {
    return mr.fromPrivateKey(ci).toRawBytes(hi);
  }
  function Dr(ci) {
    const hi = ci instanceof Uint8Array, Ei = typeof ci == "string", di = (hi || Ei) && ci.length;
    return hi ? di === fr || di === dr : Ei ? di === 2 * fr || di === 2 * dr : ci instanceof mr;
  }
  function Nr(ci, hi, Ei = !0) {
    if (Dr(ci))
      throw new Error("first arg must be private key");
    if (!Dr(hi))
      throw new Error("second arg must be public key");
    return mr.fromHex(hi).multiply(br(ci)).toRawBytes(Ei);
  }
  const Hr = ar.bits2int || function(ci) {
    const hi = bytesToNumberBE(ci), Ei = ci.length * 8 - ar.nBitLength;
    return Ei > 0 ? hi >> BigInt(Ei) : hi;
  }, $r = ar.bits2int_modN || function(ci) {
    return gr(Hr(ci));
  }, Wr = bitMask(ar.nBitLength);
  function Zr(ci) {
    if (typeof ci != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$1 <= ci && ci < Wr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE(ci, ar.nByteLength);
  }
  function oi(ci, hi, Ei = Jr) {
    if (["recovered", "canonical"].some((mi) => mi in Ei))
      throw new Error("sign() legacy options not supported");
    const { hash: di, randomBytes: gi } = ar;
    let { lowS: Li, prehash: ui, extraEntropy: wi } = Ei;
    Li == null && (Li = !0), ci = ensureBytes("msgHash", ci), ui && (ci = ensureBytes("prehashed msgHash", di(ci)));
    const Ui = $r(ci), yi = br(hi), Vi = [Zr(yi), Zr(Ui)];
    if (wi != null) {
      const mi = wi === !0 ? gi(cr.BYTES) : wi;
      Vi.push(ensureBytes("extraEntropy", mi));
    }
    const Oi = concatBytes$1(...Vi), Mi = Ui;
    function Ii(mi) {
      const _i = Hr(mi);
      if (!kr(_i))
        return;
      const Ci = vr(_i), Ki = mr.BASE.multiply(_i).toAffine(), Ni = gr(Ki.x);
      if (Ni === _0n$1)
        return;
      const ia = gr(Ci * gr(Mi + Ni * yi));
      if (ia === _0n$1)
        return;
      let ea = (Ki.x === Ni ? 0 : 2) | Number(Ki.y & _1n$1), la = ia;
      return Li && _r(ia) && (la = Er(ia), ea ^= 1), new Cr(Ni, la, ea);
    }
    return { seed: Oi, k2sig: Ii };
  }
  const Jr = { lowS: ar.lowS, prehash: !1 }, Yr = { lowS: ar.lowS, prehash: !1 };
  function li(ci, hi, Ei = Jr) {
    const { seed: di, k2sig: gi } = oi(ci, hi, Ei), Li = ar;
    return createHmacDrbg(Li.hash.outputLen, Li.nByteLength, Li.hmac)(di, gi);
  }
  mr.BASE._setWindowSize(8);
  function Si(ci, hi, Ei, di = Yr) {
    var Ki;
    const gi = ci;
    if (hi = ensureBytes("msgHash", hi), Ei = ensureBytes("publicKey", Ei), "strict" in di)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Li, prehash: ui } = di;
    let wi, Ui;
    try {
      if (typeof gi == "string" || gi instanceof Uint8Array)
        try {
          wi = Cr.fromDER(gi);
        } catch (Ni) {
          if (!(Ni instanceof DER.Err))
            throw Ni;
          wi = Cr.fromCompact(gi);
        }
      else if (typeof gi == "object" && typeof gi.r == "bigint" && typeof gi.s == "bigint") {
        const { r: Ni, s: ia } = gi;
        wi = new Cr(Ni, ia);
      } else
        throw new Error("PARSE");
      Ui = mr.fromHex(Ei);
    } catch (Ni) {
      if (Ni.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Li && wi.hasHighS())
      return !1;
    ui && (hi = ar.hash(hi));
    const { r: yi, s: Vi } = wi, Oi = $r(hi), Mi = vr(Vi), Ii = gr(Oi * Mi), mi = gr(yi * Mi), _i = (Ki = mr.BASE.multiplyAndAddUnsafe(Ui, Ii, mi)) == null ? void 0 : Ki.toAffine();
    return _i ? gr(_i.x) === yi : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Lr,
    getSharedSecret: Nr,
    sign: li,
    verify: Si,
    ProjectivePoint: mr,
    Signature: Cr,
    utils: Ar
  };
}
let HMAC$1 = class extends Hash$1 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(ar);
    const ur = toBytes$1(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return exists$1(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$1(this), bytes$1(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$1 = (lr, ar, cr) => new HMAC$1(lr, ar).update(cr).digest();
hmac$1.create = (lr, ar) => new HMAC$1(lr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(lr) {
  return {
    hash: lr,
    hmac: (ar, ...cr) => hmac$1(lr, ar, concatBytes$2(...cr)),
    randomBytes: randomBytes$1
  };
}
function createCurve(lr, ar) {
  const cr = (ur) => weierstrass({ ...lr, ...getHash(ur) });
  return Object.freeze({ ...cr(ar), create: cr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (lr, ar) => (lr + ar / _2n) / ar;
function sqrtMod(lr) {
  const ar = secp256k1P, cr = BigInt(3), ur = BigInt(6), fr = BigInt(11), dr = BigInt(22), hr = BigInt(23), gr = BigInt(44), vr = BigInt(88), mr = lr * lr * lr % ar, br = mr * mr * lr % ar, yr = pow2(br, cr, ar) * br % ar, kr = pow2(yr, cr, ar) * br % ar, Tr = pow2(kr, _2n, ar) * mr % ar, _r = pow2(Tr, fr, ar) * Tr % ar, Er = pow2(_r, dr, ar) * _r % ar, xr = pow2(Er, gr, ar) * Er % ar, Cr = pow2(xr, vr, ar) * xr % ar, Ar = pow2(Cr, gr, ar) * Er % ar, Lr = pow2(Ar, cr, ar) * br % ar, Dr = pow2(Lr, hr, ar) * _r % ar, Nr = pow2(Dr, ur, ar) * mr % ar, Hr = pow2(Nr, _2n, ar);
  if (!Fp.eql(Fp.sqr(Hr), lr))
    throw new Error("Cannot find square root");
  return Hr;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (lr) => {
      const ar = secp256k1N, cr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), fr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), dr = cr, hr = BigInt("0x100000000000000000000000000000000"), gr = divNearest(dr * lr, ar), vr = divNearest(-ur * lr, ar);
      let mr = mod(lr - gr * cr - vr * fr, ar), br = mod(-gr * ur - vr * dr, ar);
      const yr = mr > hr, kr = br > hr;
      if (yr && (mr = ar - mr), kr && (br = ar - br), mr > hr || br > hr)
        throw new Error("splitScalar: Endomorphism failed, k=" + lr);
      return { k1neg: yr, k1: mr, k2neg: kr, k2: br };
    }
  }
}, sha256$1), _0n = BigInt(0), fe = (lr) => typeof lr == "bigint" && _0n < lr && lr < secp256k1P, ge$1 = (lr) => typeof lr == "bigint" && _0n < lr && lr < secp256k1N, TAGGED_HASH_PREFIXES = {};
function taggedHash(lr, ...ar) {
  let cr = TAGGED_HASH_PREFIXES[lr];
  if (cr === void 0) {
    const ur = sha256$1(Uint8Array.from(lr, (fr) => fr.charCodeAt(0)));
    cr = concatBytes$1(ur, ur), TAGGED_HASH_PREFIXES[lr] = cr;
  }
  return sha256$1(concatBytes$1(cr, ...ar));
}
const pointToBytes = (lr) => lr.toRawBytes(!0).slice(1), numTo32b = (lr) => numberToBytesBE(lr, 32), modP = (lr) => mod(lr, secp256k1P), modN = (lr) => mod(lr, secp256k1N), Point = secp256k1.ProjectivePoint, GmulAdd = (lr, ar, cr) => Point.BASE.multiplyAndAddUnsafe(lr, ar, cr);
function schnorrGetExtPubKey(lr) {
  let ar = secp256k1.utils.normPrivateKeyToScalar(lr), cr = Point.fromPrivateKey(ar);
  return { scalar: cr.hasEvenY() ? ar : modN(-ar), bytes: pointToBytes(cr) };
}
function lift_x(lr) {
  if (!fe(lr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP(lr * lr), cr = modP(ar * lr + BigInt(7));
  let ur = sqrtMod(cr);
  ur % _2n !== _0n && (ur = modP(-ur));
  const fr = new Point(lr, ur, _1n);
  return fr.assertValidity(), fr;
}
function challenge(...lr) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...lr)));
}
function schnorrGetPublicKey(lr) {
  return schnorrGetExtPubKey(lr).bytes;
}
function schnorrSign(lr, ar, cr = randomBytes$1(32)) {
  const ur = ensureBytes("message", lr), { bytes: fr, scalar: dr } = schnorrGetExtPubKey(ar), hr = ensureBytes("auxRand", cr, 32), gr = numTo32b(dr ^ bytesToNumberBE(taggedHash("BIP0340/aux", hr))), vr = taggedHash("BIP0340/nonce", gr, fr, ur), mr = modN(bytesToNumberBE(vr));
  if (mr === _0n)
    throw new Error("sign failed: k is zero");
  const { bytes: br, scalar: yr } = schnorrGetExtPubKey(mr), kr = challenge(br, fr, ur), Tr = new Uint8Array(64);
  if (Tr.set(br, 0), Tr.set(numTo32b(modN(yr + kr * dr)), 32), !schnorrVerify(Tr, ur, fr))
    throw new Error("sign: Invalid signature produced");
  return Tr;
}
function schnorrVerify(lr, ar, cr) {
  const ur = ensureBytes("signature", lr, 64), fr = ensureBytes("message", ar), dr = ensureBytes("publicKey", cr, 32);
  try {
    const hr = lift_x(bytesToNumberBE(dr)), gr = bytesToNumberBE(ur.subarray(0, 32));
    if (!fe(gr))
      return !1;
    const vr = bytesToNumberBE(ur.subarray(32, 64));
    if (!ge$1(vr))
      return !1;
    const mr = challenge(numTo32b(gr), pointToBytes(hr), fr), br = GmulAdd(hr, vr, modN(-mr));
    return !(!br || !br.hasEvenY() || br.toAffine().x !== gr);
  } catch (hr) {
    return !1;
  }
}
const schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))(), crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (lr) => lr instanceof Uint8Array, createView = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const hexes = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex(lr) {
  if (!u8a(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes[lr[cr]];
  return ar;
}
function hexToBytes$1(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), hr = Number.parseInt(dr, 16);
    if (Number.isNaN(hr) || hr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = hr;
  }
  return cr;
}
function utf8ToBytes(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes(lr)), !u8a(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(lr) {
  const ar = (ur) => lr().update(toBytes(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes(lr = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(lr.outputLen), number(lr.blockLen);
}
function exists(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(lr, ar) {
  bytes(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
function setBigUint64(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), hr = Number(cr >> fr & dr), gr = Number(cr & dr), vr = ur ? 4 : 0, mr = ur ? 0 : 4;
  lr.setUint32(ar + vr, hr, ur), lr.setUint32(ar + mr, gr, ur);
}
class SHA2 extends Hash {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView(this.buffer);
  }
  update(ar) {
    assert.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes(ar);
    const dr = ar.length;
    for (let hr = 0; hr < dr; ) {
      const gr = Math.min(fr - this.pos, dr - hr);
      if (gr === fr) {
        const vr = createView(ar);
        for (; fr <= dr - hr; hr += fr)
          this.process(vr, hr);
        continue;
      }
      ur.set(ar.subarray(hr, hr + gr), this.pos), this.pos += gr, hr += gr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: hr } = this;
    cr[hr++] = 128, this.buffer.subarray(hr).fill(0), this.padOffset > fr - hr && (this.process(ur, 0), hr = 0);
    for (let yr = hr; yr < fr; yr++)
      cr[yr] = 0;
    setBigUint64(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const gr = createView(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const mr = vr / 4, br = this.get();
    if (mr > br.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let yr = 0; yr < mr; yr++)
      gr.setUint32(4 * yr, br[yr], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: hr, pos: gr } = this;
    return ar.length = fr, ar.pos = gr, ar.finished = dr, ar.destroyed = hr, fr % cr && ar.buffer.set(ur), ar;
  }
}
const Chi$1 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: hr, G: gr, H: vr } = this;
    return [ar, cr, ur, fr, dr, hr, gr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, hr, gr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = hr | 0, this.G = gr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let yr = 0; yr < 16; yr++, cr += 4)
      SHA256_W[yr] = ar.getUint32(cr, !1);
    for (let yr = 16; yr < 64; yr++) {
      const kr = SHA256_W[yr - 15], Tr = SHA256_W[yr - 2], _r = rotr(kr, 7) ^ rotr(kr, 18) ^ kr >>> 3, Er = rotr(Tr, 17) ^ rotr(Tr, 19) ^ Tr >>> 10;
      SHA256_W[yr] = Er + SHA256_W[yr - 7] + _r + SHA256_W[yr - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: hr, E: gr, F: vr, G: mr, H: br } = this;
    for (let yr = 0; yr < 64; yr++) {
      const kr = rotr(gr, 6) ^ rotr(gr, 11) ^ rotr(gr, 25), Tr = br + kr + Chi$1(gr, vr, mr) + SHA256_K[yr] + SHA256_W[yr] | 0, Er = (rotr(ur, 2) ^ rotr(ur, 13) ^ rotr(ur, 22)) + Maj(ur, fr, dr) | 0;
      br = mr, mr = vr, vr = gr, gr = hr + Tr | 0, hr = dr, dr = fr, fr = ur, ur = Tr + Er | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, hr = hr + this.D | 0, gr = gr + this.E | 0, vr = vr + this.F | 0, mr = mr + this.G | 0, br = br + this.H | 0, this.set(ur, fr, dr, hr, gr, vr, mr, br);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const sha256 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain(...lr) {
  const ar = (fr, dr) => (hr) => fr(dr(hr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$1(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding(lr, ar = "=") {
  if (assertNumber(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((hr) => {
    if (assertNumber(hr), hr < 0 || hr >= ar)
      throw new Error(`Wrong integer: ${hr}`);
  }); ; ) {
    let hr = 0, gr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const mr = dr[vr], br = ar * hr + mr;
      if (!Number.isSafeInteger(br) || ar * hr / ar !== hr || br - mr !== ar * hr)
        throw new Error("convertRadix: carry overflow");
      if (hr = br % cr, dr[vr] = Math.floor(br / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + hr !== br)
        throw new Error("convertRadix: carry overflow");
      if (gr)
        dr[vr] ? gr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(hr), gr)
      break;
  }
  for (let hr = 0; hr < lr.length - 1 && lr[hr] === 0; hr++)
    fr.push(0);
  return fr.reverse();
}
const gcd = (lr, ar) => ar ? gcd(ar, lr % ar) : lr, radix2carry = (lr, ar) => lr + (ar - gcd(lr, ar));
function convertRadix2(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry(ar, cr)}`);
  let fr = 0, dr = 0;
  const hr = 2 ** cr - 1, gr = [];
  for (const vr of lr) {
    if (assertNumber(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      gr.push((fr >> dr - cr & hr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & hr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && gr.push(fr >>> 0), gr;
}
function radix(lr) {
  return assertNumber(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(ar, lr, 2 ** 8));
    }
  };
}
function radix2(lr, ar = !1) {
  if (assertNumber(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, lr) > 32 || radix2carry(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join$1("")), base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$1(""), normalize((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join$1("")), base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join$1("")), genBase58 = (lr) => chain(radix(58), alphabet(lr), join$1("")), base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58.encode(ur).padStart(XMR_BLOCK_LEN[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN.indexOf(ur.length), dr = base58.decode(ur);
      for (let hr = 0; hr < dr.length - fr; hr++)
        if (dr[hr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$1("")), POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS[ur]);
  return cr;
}
function bechChecksum(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const hr = lr.charCodeAt(dr);
    if (hr < 33 || hr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod(fr) ^ hr >> 5;
  }
  fr = bech32Polymod(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod(fr);
  return fr ^= cr, BECH_ALPHABET.encode(convertRadix2([fr % 2 ** 30], 30, 5, !1));
}
function genBech32(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper(ur);
  function hr(br, yr, kr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof br}`);
    if (!Array.isArray(yr) || yr.length && typeof yr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof yr}`);
    const Tr = br.length + 7 + yr.length;
    if (kr !== !1 && Tr > kr)
      throw new TypeError(`Length ${Tr} exceeds limit ${kr}`);
    return br = br.toLowerCase(), `${br}1${BECH_ALPHABET.encode(yr)}${bechChecksum(br, yr, ar)}`;
  }
  function gr(br, yr = 90) {
    if (typeof br != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof br}`);
    if (br.length < 8 || yr !== !1 && br.length > yr)
      throw new TypeError(`Wrong string length: ${br.length} (${br}). Expected (8..${yr})`);
    const kr = br.toLowerCase();
    if (br !== kr && br !== br.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    br = kr;
    const Tr = br.lastIndexOf("1");
    if (Tr === 0 || Tr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const _r = br.slice(0, Tr), Er = br.slice(Tr + 1);
    if (Er.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const xr = BECH_ALPHABET.decode(Er).slice(0, -6), Cr = bechChecksum(_r, xr, ar);
    if (!Er.endsWith(Cr))
      throw new Error(`Invalid checksum in ${br}: expected "${Cr}"`);
    return { prefix: _r, words: xr };
  }
  const vr = unsafeWrapper(gr);
  function mr(br) {
    const { prefix: yr, words: kr } = gr(br, !1);
    return { prefix: yr, words: kr, bytes: ur(kr) };
  }
  return { encode: hr, decode: gr, decodeToBytes: mr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32$1 = genBech32("bech32");
genBech32("bech32m");
const utf8 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex = chain(radix2(4), alphabet("0123456789abcdef"), join$1(""), normalize((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
`${Object.keys(CODERS).join(", ")}`;
class HMAC extends Hash {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert.hash(ar);
    const ur = toBytes(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let hr = 0; hr < dr.length; hr++)
      dr[hr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: hr, outputLen: gr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = hr, ar.outputLen = gr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (lr, ar, cr) => new HMAC(lr, ar).update(cr).digest();
hmac.create = (lr, ar) => new HMAC(lr, ar);
function extract(lr, ar, cr) {
  return assert.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac(lr, toBytes(cr), toBytes(ar));
}
const HKDF_COUNTER = new Uint8Array([0]), EMPTY_BUFFER = new Uint8Array();
function expand(lr, ar, cr, ur = 32) {
  if (assert.hash(lr), assert.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER);
  const dr = new Uint8Array(fr * lr.outputLen), hr = hmac.create(lr, ar), gr = hr._cloneInto(), vr = new Uint8Array(hr.outputLen);
  for (let mr = 0; mr < fr; mr++)
    HKDF_COUNTER[0] = mr + 1, gr.update(mr === 0 ? EMPTY_BUFFER : vr).update(cr).update(HKDF_COUNTER).digestInto(vr), dr.set(vr, lr.outputLen * mr), hr._cloneInto(gr);
  return hr.destroy(), gr.destroy(), vr.fill(0), HKDF_COUNTER.fill(0), dr.slice(0, ur);
}
var __defProp = Object.defineProperty, __export = (lr, ar) => {
  for (var cr in ar)
    __defProp(lr, cr, { get: ar[cr], enumerable: !0 });
}, verifiedSymbol = Symbol("verified"), isRecord = (lr) => lr instanceof Object;
function validateEvent(lr) {
  if (!isRecord(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
var utils_exports = {};
__export(utils_exports, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8"), utf8Encoder = new TextEncoder();
function normalizeURL(lr) {
  lr.indexOf("://") === -1 && (lr = "wss://" + lr);
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList(lr, ar) {
  const [cr, ur] = binarySearch(lr, (fr) => ar.id === fr.id ? 0 : ar.created_at === fr.created_at ? -1 : fr.created_at - ar.created_at);
  return ur || lr.splice(cr, 0, ar), lr;
}
function insertEventIntoAscendingList(lr, ar) {
  const [cr, ur] = binarySearch(lr, (fr) => ar.id === fr.id ? 0 : ar.created_at === fr.created_at ? -1 : ar.created_at - fr.created_at);
  return ur || lr.splice(cr, 0, ar), lr;
}
function binarySearch(lr, ar) {
  let cr = 0, ur = lr.length - 1;
  for (; cr <= ur; ) {
    const fr = Math.floor((cr + ur) / 2), dr = ar(lr[fr]);
    if (dr === 0)
      return [fr, !0];
    dr < 0 ? ur = fr - 1 : cr = fr + 1;
  }
  return [cr, !1];
}
var QueueNode = class {
  constructor(lr) {
    Wi(this, "value");
    Wi(this, "next", null);
    Wi(this, "prev", null);
    this.value = lr;
  }
}, Queue = class {
  constructor() {
    Wi(this, "first");
    Wi(this, "last");
    this.first = null, this.last = null;
  }
  enqueue(lr) {
    const ar = new QueueNode(lr);
    return this.last ? this.last === this.first ? (this.last = ar, this.last.prev = this.first, this.first.next = ar) : (ar.prev = this.last, this.last.next = ar, this.last = ar) : (this.first = ar, this.last = ar), !0;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const ar = this.first;
      return this.first = null, this.last = null, ar.value;
    }
    const lr = this.first;
    return this.first = lr.next, lr.value;
  }
}, JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(lr) {
    return bytesToHex(schnorr.getPublicKey(lr));
  }
  finalizeEvent(lr, ar) {
    const cr = lr;
    return cr.pubkey = bytesToHex(schnorr.getPublicKey(ar)), cr.id = getEventHash(cr), cr.sig = bytesToHex(schnorr.sign(getEventHash(cr), ar)), cr[verifiedSymbol] = !0, cr;
  }
  verifyEvent(lr) {
    if (typeof lr[verifiedSymbol] == "boolean")
      return lr[verifiedSymbol];
    const ar = getEventHash(lr);
    if (ar !== lr.id)
      return lr[verifiedSymbol] = !1, !1;
    try {
      const cr = schnorr.verify(lr.sig, ar, lr.pubkey);
      return lr[verifiedSymbol] = cr, cr;
    } catch (cr) {
      return lr[verifiedSymbol] = !1, !1;
    }
  }
};
function serializeEvent(lr) {
  if (!validateEvent(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash(lr) {
  let ar = sha256(utf8Encoder.encode(serializeEvent(lr)));
  return bytesToHex(ar);
}
var i = new JS();
i.generateSecretKey;
i.getPublicKey;
var finalizeEvent = i.finalizeEvent, verifyEvent = i.verifyEvent, kinds_exports = {};
__export(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EncryptedDirectMessages: () => EncryptedDirectMessages,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isEphemeralKind: () => isEphemeralKind,
  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(lr) {
  return 1e3 <= lr && lr < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(lr);
}
function isReplaceableKind(lr) {
  return [0, 3].includes(lr) || 1e4 <= lr && lr < 2e4;
}
function isEphemeralKind(lr) {
  return 2e4 <= lr && lr < 3e4;
}
function isParameterizedReplaceableKind(lr) {
  return 3e4 <= lr && lr < 4e4;
}
function classifyKind(lr) {
  return isRegularKind(lr) ? "regular" : isReplaceableKind(lr) ? "replaceable" : isEphemeralKind(lr) ? "ephemeral" : isParameterizedReplaceableKind(lr) ? "parameterized" : "unknown";
}
var Metadata = 0, ShortTextNote = 1, RecommendRelay = 2, Contacts = 3, EncryptedDirectMessage = 4, EncryptedDirectMessages = 4, EventDeletion = 5, Repost = 6, Reaction = 7, BadgeAward = 8, GenericRepost = 16, ChannelCreation = 40, ChannelMetadata = 41, ChannelMessage = 42, ChannelHideMessage = 43, ChannelMuteUser = 44, OpenTimestamps = 1040, FileMetadata = 1063, LiveChatMessage = 1311, ProblemTracker = 1971, Report = 1984, Reporting = 1984, Label = 1985, CommunityPostApproval = 4550, JobRequest = 5999, JobResult = 6999, JobFeedback = 7e3, ZapGoal = 9041, ZapRequest = 9734, Zap = 9735, Highlights = 9802, Mutelist = 1e4, Pinlist = 10001, RelayList = 10002, BookmarkList = 10003, CommunitiesList = 10004, PublicChatsList = 10005, BlockedRelaysList = 10006, SearchRelaysList = 10007, InterestsList = 10015, UserEmojiList = 10030, FileServerPreference = 10096, NWCWalletInfo = 13194, LightningPubRPC = 21e3, ClientAuth = 22242, NWCWalletRequest = 23194, NWCWalletResponse = 23195, NostrConnect = 24133, HTTPAuth = 27235, Followsets = 3e4, Genericlists = 30001, Relaysets = 30002, Bookmarksets = 30003, Curationsets = 30004, ProfileBadges = 30008, BadgeDefinition = 30009, Interestsets = 30015, CreateOrUpdateStall = 30017, CreateOrUpdateProduct = 30018, LongFormArticle = 30023, DraftLong = 30024, Emojisets = 30030, Application = 30078, LiveEvent = 30311, UserStatuses = 30315, ClassifiedListing = 30402, DraftClassifiedListing = 30403, Date2 = 31922, Time = 31923, Calendar = 31924, CalendarEventRSVP = 31925, Handlerrecommendation = 31989, Handlerinformation = 31990, CommunityDefinition = 34550, fakejson_exports = {};
__export(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId(lr, ar) {
  return ar === getHex64(lr, "id");
}
function matchEventPubkey(lr, ar) {
  return ar === getHex64(lr, "pubkey");
}
function matchEventKind(lr, ar) {
  return ar === getInt(lr, "kind");
}
var nip42_exports = {};
__export(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(lr, ar) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", lr],
      ["challenge", ar]
    ],
    content: ""
  };
}
var nip19_exports = {};
__export(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  decode: () => decode$1,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nrelayEncode: () => nrelayEncode,
  nsecEncode: () => nsecEncode
});
var Bech32MaxSize = 5e3, BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$1(lr) {
  var fr, dr, hr, gr, vr, mr, br, yr;
  let { prefix: ar, words: cr } = bech32$1.decode(lr, Bech32MaxSize), ur = new Uint8Array(bech32$1.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let kr = parseTLV(ur);
      if (!((fr = kr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder.decode(Tr)) : []
        }
      };
    }
    case "nevent": {
      let kr = parseTLV(ur);
      if (!((dr = kr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (kr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (kr[2] && kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (kr[3] && kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex(kr[0][0]),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder.decode(Tr)) : [],
          author: (hr = kr[2]) != null && hr[0] ? bytesToHex(kr[2][0]) : void 0,
          kind: (gr = kr[3]) != null && gr[0] ? parseInt(bytesToHex(kr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let kr = parseTLV(ur);
      if (!((vr = kr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((mr = kr[2]) != null && mr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (kr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((br = kr[3]) != null && br[0]))
        throw new Error("missing TLV 3 for naddr");
      if (kr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(kr[0][0]),
          pubkey: bytesToHex(kr[2][0]),
          kind: parseInt(bytesToHex(kr[3][0]), 16),
          relays: kr[1] ? kr[1].map((Tr) => utf8Decoder.decode(Tr)) : []
        }
      };
    }
    case "nrelay": {
      let kr = parseTLV(ur);
      if (!((yr = kr[0]) != null && yr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder.decode(kr[0][0])
      };
    }
    case "nsec":
      return { type: ar, data: ur };
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1], dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode(lr) {
  return encodeBytes("nsec", lr);
}
function npubEncode(lr) {
  return encodeBytes("npub", hexToBytes$1(lr));
}
function noteEncode(lr) {
  return encodeBytes("note", hexToBytes$1(lr));
}
function encodeBech32(lr, ar) {
  let cr = bech32$1.toWords(ar);
  return bech32$1.encode(lr, cr, Bech32MaxSize);
}
function encodeBytes(lr, ar) {
  return encodeBech32(lr, ar);
}
function nprofileEncode(lr) {
  let ar = encodeTLV({
    0: [hexToBytes$1(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder.encode(cr))
  });
  return encodeBech32("nprofile", ar);
}
function neventEncode(lr) {
  let ar;
  lr.kind !== void 0 && (ar = integerToUint8Array(lr.kind));
  let cr = encodeTLV({
    0: [hexToBytes$1(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: lr.author ? [hexToBytes$1(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32("nevent", cr);
}
function naddrEncode(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV({
    0: [utf8Encoder.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: [hexToBytes$1(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32("naddr", cr);
}
function nrelayEncode(lr) {
  let ar = encodeTLV({
    0: [utf8Encoder.encode(lr)]
  });
  return encodeBech32("nrelay", ar);
}
function encodeTLV(lr) {
  let ar = [];
  return Object.entries(lr).reverse().forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes(...ar);
}
var nip04_exports = {};
__export(nip04_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt(lr, ar, cr) {
  const ur = lr instanceof Uint8Array ? bytesToHex(lr) : lr, fr = secp256k1.getSharedSecret(ur, "02" + ar), dr = getNormalizedX(fr);
  let hr = Uint8Array.from(randomBytes(16)), gr = utf8Encoder.encode(cr), vr = await crypto.subtle.importKey("raw", dr, { name: "AES-CBC" }, !1, ["encrypt"]), mr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: hr }, vr, gr), br = base64.encode(new Uint8Array(mr)), yr = base64.encode(new Uint8Array(hr.buffer));
  return `${br}?iv=${yr}`;
}
async function decrypt(lr, ar, cr) {
  const ur = lr instanceof Uint8Array ? bytesToHex(lr) : lr;
  let [fr, dr] = cr.split("?iv="), hr = secp256k1.getSharedSecret(ur, "02" + ar), gr = getNormalizedX(hr), vr = await crypto.subtle.importKey("raw", gr, { name: "AES-CBC" }, !1, ["decrypt"]), mr = base64.decode(fr), br = base64.decode(dr), yr = await crypto.subtle.decrypt({ name: "AES-CBC", iv: br }, vr, mr);
  return utf8Decoder.decode(yr);
}
function getNormalizedX(lr) {
  return lr.slice(1, 33);
}
var nip05_exports = {};
__export(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch;
try {
  _fetch = fetch;
} catch (lr) {
}
function useFetchImplementation(lr) {
  _fetch = lr;
}
async function searchDomain(lr, ar = "") {
  try {
    return (await (await _fetch(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile(lr) {
  const ar = lr.match(NIP05_REGEX);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: hr, relays: gr } = parseNIP05Result(await dr.json()), vr = hr[ur];
    return vr ? { pubkey: vr, relays: gr == null ? void 0 : gr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip10_exports = {};
__export(nip10_exports, {
  parse: () => parse
});
function parse(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, hr, gr, vr] = fr, mr = {
      id: hr,
      relays: gr ? [gr] : []
    }, br = ur === 0, yr = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = mr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = mr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(mr);
      continue;
    }
    if (br) {
      ar.root = mr;
      continue;
    }
    if (yr) {
      ar.reply = mr;
      continue;
    }
    ar.mentions.push(mr);
  }
  return ar;
}
var nip11_exports = {};
__export(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch (lr) {
}
function useFetchImplementation2(lr) {
  _fetch2 = lr;
}
async function fetchRelayInformation(lr) {
  return await (await fetch(lr.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export(nip13_exports, {
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash(ur), getPow(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports = {};
__export(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(lr, ar, cr, ur) {
  var fr;
  return finalizeEvent(
    {
      kind: Repost,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer(lr) {
  if (lr.kind !== Repost)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifyEvent(ur)))
    return ur;
}
var nip21_exports = {};
__export(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(lr);
}
function parse2(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$1(ar[1])
  };
}
var nip25_exports = {};
__export(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((hr) => hr.length >= 2 && (hr[0] === "e" || hr[0] === "p"));
  return finalizeEvent(
    {
      ...lr,
      kind: Reaction,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer(lr) {
  if (lr.kind !== Reaction)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip27_exports = {};
__export(nip27_exports, {
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
function* matchAll(lr) {
  const ar = lr.matchAll(regex());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$1(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll(lr, ar) {
  return lr.replaceAll(regex(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$1(ur)
  }));
}
var nip28_exports = {};
__export(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip30_exports = {};
__export(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll2,
  regex: () => regex2,
  replaceAll: () => replaceAll2
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/, regex2 = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll2(lr) {
  const ar = lr.matchAll(regex2());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        shortcode: ur,
        name: fr,
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll2(lr, ar) {
  return lr.replaceAll(regex2(), (cr, ur) => ar({
    shortcode: cr,
    name: ur
  }));
}
var nip39_exports = {};
__export(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch (lr) {
}
function useFetchImplementation3(lr) {
  _fetch3 = lr;
}
async function validateGithub(lr, ar, cr) {
  try {
    return await (await _fetch3(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip44_exports = {};
__export(nip44_exports, {
  default: () => nip44_default,
  v2: () => v2
});
var decoder = new TextDecoder(), u = {
  minPlaintextSize: 1,
  maxPlaintextSize: 65535,
  utf8Encode: utf8ToBytes,
  utf8Decode(lr) {
    return decoder.decode(lr);
  },
  getConversationKey(lr, ar) {
    const cr = secp256k1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    return extract(sha256, cr, "nip44-v2");
  },
  getMessageKeys(lr, ar) {
    ensureBytes$1(lr, 32), ensureBytes$1(ar, 32);
    const cr = expand(sha256, lr, ar, 76);
    return {
      chacha_key: cr.subarray(0, 32),
      chacha_nonce: cr.subarray(32, 44),
      hmac_key: cr.subarray(44, 76)
    };
  },
  calcPaddedLen(lr) {
    if (!Number.isSafeInteger(lr) || lr < 1)
      throw new Error("expected positive integer");
    if (lr <= 32)
      return 32;
    const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
    return cr * (Math.floor((lr - 1) / cr) + 1);
  },
  writeU16BE(lr) {
    if (!Number.isSafeInteger(lr) || lr < u.minPlaintextSize || lr > u.maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const ar = new Uint8Array(2);
    return new DataView(ar.buffer).setUint16(0, lr, !1), ar;
  },
  pad(lr) {
    const ar = u.utf8Encode(lr), cr = ar.length, ur = u.writeU16BE(cr), fr = new Uint8Array(u.calcPaddedLen(cr) - cr);
    return concatBytes(ur, ar, fr);
  },
  unpad(lr) {
    const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
    if (ar < u.minPlaintextSize || ar > u.maxPlaintextSize || cr.length !== ar || lr.length !== 2 + u.calcPaddedLen(ar))
      throw new Error("invalid padding");
    return u.utf8Decode(cr);
  },
  hmacAad(lr, ar, cr) {
    if (cr.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const ur = concatBytes(cr, ar);
    return hmac(sha256, lr, ur);
  },
  decodePayload(lr) {
    if (typeof lr != "string")
      throw new Error("payload must be a valid string");
    const ar = lr.length;
    if (ar < 132 || ar > 87472)
      throw new Error("invalid payload length: " + ar);
    if (lr[0] === "#")
      throw new Error("unknown encryption version");
    let cr;
    try {
      cr = base64.decode(lr);
    } catch (dr) {
      throw new Error("invalid base64: " + dr.message);
    }
    const ur = cr.length;
    if (ur < 99 || ur > 65603)
      throw new Error("invalid data length: " + ur);
    const fr = cr[0];
    if (fr !== 2)
      throw new Error("unknown encryption version " + fr);
    return {
      nonce: cr.subarray(1, 33),
      ciphertext: cr.subarray(33, -32),
      mac: cr.subarray(-32)
    };
  }
};
function encrypt2(lr, ar, cr = randomBytes(32)) {
  const { chacha_key: ur, chacha_nonce: fr, hmac_key: dr } = u.getMessageKeys(ar, cr), hr = u.pad(lr), gr = chacha20(ur, fr, hr), vr = u.hmacAad(dr, gr, cr);
  return base64.encode(concatBytes(new Uint8Array([2]), cr, gr, vr));
}
function decrypt2(lr, ar) {
  const { nonce: cr, ciphertext: ur, mac: fr } = u.decodePayload(lr), { chacha_key: dr, chacha_nonce: hr, hmac_key: gr } = u.getMessageKeys(ar, cr), vr = u.hmacAad(gr, ur, cr);
  if (!equalBytes$1(vr, fr))
    throw new Error("invalid MAC");
  const mr = chacha20(dr, hr, ur);
  return u.unpad(mr);
}
var v2 = {
  utils: u,
  encrypt: encrypt2,
  decrypt: decrypt2
}, nip44_default = { v2 }, nip47_exports = {};
__export(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent(lr, ar, cr) {
  const fr = await encrypt(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finalizeEvent(dr, ar);
}
var nip57_exports = {};
__export(nip57_exports, {
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch (lr) {
}
function useFetchImplementation4(lr) {
  _fetch4 = lr;
}
async function getZapEndpoint(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: hr } = bech32$1.decode(cr, 1e3), gr = bech32$1.fromWords(hr);
      ar = utf8Decoder.decode(gr);
    } else if (ur) {
      let [hr, gr] = ur.split("@");
      ar = new URL(`/.well-known/lnurlp/${hr}`, `https://${gr}`).toString();
    } else
      return null;
    let dr = await (await _fetch4(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, hr]) => dr === "p" && hr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, hr]) => dr === "e" && hr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, hr]) => dr === "relays" && hr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let fr = JSON.parse(lr), dr = fr.tags.filter(([gr]) => gr === "e" || gr === "p" || gr === "a"), hr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["P", fr.pubkey], ["bolt11", cr], ["description", lr]]
  };
  return ar && hr.tags.push(["preimage", ar]), hr;
}
var nip98_exports = {};
__export(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(lr, ar, cr, ur = !1, fr) {
  const dr = {
    kind: HTTPAuth,
    tags: [
      ["u", lr],
      ["method", ar]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  fr && dr.tags.push(["payload", hashPayload(fr)]);
  const hr = await cr(dr);
  return (ur ? _authorizationScheme : "") + base64.encode(utf8Encoder.encode(JSON.stringify(hr)));
}
async function validateToken(lr, ar, cr) {
  const ur = await unpackEventFromToken(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme, "");
  const ar = utf8Decoder.decode(base64.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
function validateEventTimestamp(lr) {
  return lr.created_at ? Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at < 60 : !1;
}
function validateEventKind(lr) {
  return lr.kind === HTTPAuth;
}
function validateEventUrlTag(lr, ar) {
  const cr = lr.tags.find((ur) => ur[0] === "u");
  return cr ? cr.length > 0 && cr[1] === ar : !1;
}
function validateEventMethodTag(lr, ar) {
  const cr = lr.tags.find((ur) => ur[0] === "method");
  return cr ? cr.length > 0 && cr[1].toLowerCase() === ar.toLowerCase() : !1;
}
function hashPayload(lr) {
  const ar = sha256(utf8Encoder.encode(JSON.stringify(lr)));
  return bytesToHex(ar);
}
function validateEventPayloadTag(lr, ar) {
  const cr = lr.tags.find((fr) => fr[0] === "payload");
  if (!cr)
    return !1;
  const ur = hashPayload(ar);
  return cr.length > 0 && cr[1] === ur;
}
async function validateEvent2(lr, ar, cr, ur) {
  if (!verifyEvent(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (!validateEventKind(lr))
    throw new Error("Invalid nostr event, kind invalid");
  if (!validateEventTimestamp(lr))
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  if (!validateEventUrlTag(lr, ar))
    throw new Error("Invalid nostr event, url tag invalid");
  if (!validateEventMethodTag(lr, cr))
    throw new Error("Invalid nostr event, method tag invalid");
  if (ur && typeof ur == "object" && Object.keys(ur).length > 0 && !validateEventPayloadTag(lr, ur))
    throw new Error("Invalid nostr event, payload tag does not match request body hash");
  return !0;
}
var dist$8 = {};
Object.defineProperty(dist$8, "__esModule", { value: !0 });
dist$8.bech32m = bech32 = dist$8.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let lr = 0; lr < ALPHABET.length; lr++) {
  const ar = ALPHABET.charAt(lr);
  ALPHABET_MAP[ar] = lr;
}
function polymodStep(lr) {
  const ar = lr >> 25;
  return (lr & 33554431) << 5 ^ -(ar >> 0 & 1) & 996825010 ^ -(ar >> 1 & 1) & 642813549 ^ -(ar >> 2 & 1) & 513874426 ^ -(ar >> 3 & 1) & 1027748829 ^ -(ar >> 4 & 1) & 705979059;
}
function prefixChk(lr) {
  let ar = 1;
  for (let cr = 0; cr < lr.length; ++cr) {
    const ur = lr.charCodeAt(cr);
    if (ur < 33 || ur > 126)
      return "Invalid prefix (" + lr + ")";
    ar = polymodStep(ar) ^ ur >> 5;
  }
  ar = polymodStep(ar);
  for (let cr = 0; cr < lr.length; ++cr) {
    const ur = lr.charCodeAt(cr);
    ar = polymodStep(ar) ^ ur & 31;
  }
  return ar;
}
function convert(lr, ar, cr, ur) {
  let fr = 0, dr = 0;
  const hr = (1 << cr) - 1, gr = [];
  for (let vr = 0; vr < lr.length; ++vr)
    for (fr = fr << ar | lr[vr], dr += ar; dr >= cr; )
      dr -= cr, gr.push(fr >> dr & hr);
  if (ur)
    dr > 0 && gr.push(fr << cr - dr & hr);
  else {
    if (dr >= ar)
      return "Excess padding";
    if (fr << cr - dr & hr)
      return "Non-zero padding";
  }
  return gr;
}
function toWords(lr) {
  return convert(lr, 8, 5, !0);
}
function fromWordsUnsafe(lr) {
  const ar = convert(lr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
}
function fromWords(lr) {
  const ar = convert(lr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
  throw new Error(ar);
}
function getLibraryFromEncoding(lr) {
  let ar;
  lr === "bech32" ? ar = 1 : ar = 734539939;
  function cr(hr, gr, vr) {
    if (vr = vr || 90, hr.length + 7 + gr.length > vr)
      throw new TypeError("Exceeds length limit");
    hr = hr.toLowerCase();
    let mr = prefixChk(hr);
    if (typeof mr == "string")
      throw new Error(mr);
    let br = hr + "1";
    for (let yr = 0; yr < gr.length; ++yr) {
      const kr = gr[yr];
      if (kr >> 5)
        throw new Error("Non 5-bit word");
      mr = polymodStep(mr) ^ kr, br += ALPHABET.charAt(kr);
    }
    for (let yr = 0; yr < 6; ++yr)
      mr = polymodStep(mr);
    mr ^= ar;
    for (let yr = 0; yr < 6; ++yr) {
      const kr = mr >> (5 - yr) * 5 & 31;
      br += ALPHABET.charAt(kr);
    }
    return br;
  }
  function ur(hr, gr) {
    if (gr = gr || 90, hr.length < 8)
      return hr + " too short";
    if (hr.length > gr)
      return "Exceeds length limit";
    const vr = hr.toLowerCase(), mr = hr.toUpperCase();
    if (hr !== vr && hr !== mr)
      return "Mixed-case string " + hr;
    hr = vr;
    const br = hr.lastIndexOf("1");
    if (br === -1)
      return "No separator character for " + hr;
    if (br === 0)
      return "Missing prefix for " + hr;
    const yr = hr.slice(0, br), kr = hr.slice(br + 1);
    if (kr.length < 6)
      return "Data too short";
    let Tr = prefixChk(yr);
    if (typeof Tr == "string")
      return Tr;
    const _r = [];
    for (let Er = 0; Er < kr.length; ++Er) {
      const xr = kr.charAt(Er), Cr = ALPHABET_MAP[xr];
      if (Cr === void 0)
        return "Unknown character " + xr;
      Tr = polymodStep(Tr) ^ Cr, !(Er + 6 >= kr.length) && _r.push(Cr);
    }
    return Tr !== ar ? "Invalid checksum for " + hr : { prefix: yr, words: _r };
  }
  function fr(hr, gr) {
    const vr = ur(hr, gr);
    if (typeof vr == "object")
      return vr;
  }
  function dr(hr, gr) {
    const vr = ur(hr, gr);
    if (typeof vr == "object")
      return vr;
    throw new Error(vr);
  }
  return {
    decodeUnsafe: fr,
    decode: dr,
    encode: cr,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
var bech32 = dist$8.bech32 = getLibraryFromEncoding("bech32");
dist$8.bech32m = getLibraryFromEncoding("bech32m");
function hexToBytes(lr) {
  const ar = new Uint8Array(lr.length / 2);
  for (let cr = 0; cr < ar.length; cr++)
    ar[cr] = parseInt(lr.substring(cr * 2, cr * 2 + 2), 16);
  return ar;
}
function convertNostrPubKeyToBech32(lr, ar = "npub") {
  const cr = hexToBytes(lr);
  return bech32.encode(ar, bech32.toWords(cr));
}
function add_css$a(lr) {
  append_styles(lr, "svelte-1xutw13", 'h3.svelte-1xutw13.svelte-1xutw13,h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13,input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13,button.svelte-1xutw13.svelte-1xutw13{font-family:sans-serif}h3.svelte-1xutw13.svelte-1xutw13{font-size:1.5em;color:#767676;margin-top:0}form.svelte-1xutw13.svelte-1xutw13{padding-right:1.5rem}h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13{color:#767676}input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13{color:#333;background-color:#f8f8f8;margin-bottom:1em;width:100%;display:block;border:1px solid #888;padding:0.5em;font-size:1.1em;border-radius:0.3rem}input[type="text"].svelte-1xutw13.svelte-1xutw13{height:50px}textarea.svelte-1xutw13.svelte-1xutw13{height:120px}button.svelte-1xutw13.svelte-1xutw13{background-color:#4DA84D;color:white;border:none;padding:12px 18px;cursor:pointer;font-size:1.1em;border-radius:5px}.copy-key-button.svelte-1xutw13.svelte-1xutw13,.continue-button.svelte-1xutw13.svelte-1xutw13{margin-top:0.5em}.continue-button.svelte-1xutw13.svelte-1xutw13{background-color:#6c757d;border:2px solid #565e66}.key-container.svelte-1xutw13.svelte-1xutw13{background-color:#eaeaea;padding:1em;border-radius:4px;border:1px solid #ccc}.key-container.svelte-1xutw13 input.svelte-1xutw13{background-color:#fff;border:1px solid #888;border-radius:4px;padding:1em;width:100%;box-sizing:border-box;font-size:1.1em}');
}
function create_else_block$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr;
  return {
    c() {
      ar = element("div"), cr = element("p"), cr.innerHTML = "We use <strong>Nostr</strong> to store opinions. You can post and access your posts via your unique private key. Copy your key and keep it in a safe place.", ur = space(), fr = element("div"), dr = element("input"), hr = space(), gr = element("button"), gr.textContent = "Copy my key", vr = space(), mr = element("button"), mr.textContent = "Continue", attr(cr, "class", "svelte-1xutw13"), attr(dr, "id", "privkey"), attr(dr, "type", "text"), dr.readOnly = !0, attr(dr, "class", "svelte-1xutw13"), attr(gr, "class", "copy-key-button svelte-1xutw13"), attr(fr, "class", "key-container svelte-1xutw13"), attr(mr, "class", "continue-button svelte-1xutw13");
    },
    m(_r, Er) {
      insert(_r, ar, Er), append(ar, cr), append(ar, ur), append(ar, fr), append(fr, dr), set_input_value(
        dr,
        /*nsec*/
        lr[0]
      ), append(fr, hr), append(fr, gr), append(ar, vr), append(ar, mr), yr = !0, kr || (Tr = [
        listen(
          dr,
          "input",
          /*input_input_handler*/
          lr[12]
        ),
        listen(
          gr,
          "click",
          /*copyToClipboard*/
          lr[6]
        ),
        listen(
          mr,
          "click",
          /*click_handler*/
          lr[13]
        )
      ], kr = !0);
    },
    p(_r, Er) {
      Er & /*nsec*/
      1 && dr.value !== /*nsec*/
      _r[0] && set_input_value(
        dr,
        /*nsec*/
        _r[0]
      );
    },
    i(_r) {
      yr || (_r && add_render_callback(() => {
        yr && (br || (br = create_bidirectional_transition(ar, slide, {}, !0)), br.run(1));
      }), yr = !0);
    },
    o(_r) {
      _r && (br || (br = create_bidirectional_transition(ar, slide, {}, !1)), br.run(0)), yr = !1;
    },
    d(_r) {
      _r && detach(ar), _r && br && br.end(), kr = !1, run_all(Tr);
    }
  };
}
function create_if_block$4(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr;
  return {
    c() {
      ar = element("form"), cr = element("h2"), cr.textContent = "Set up your profile", ur = space(), fr = element("p"), fr.textContent = "This information will be shown with your comments. To upload images, use a service like Piccy.", dr = space(), hr = element("input"), gr = space(), vr = element("textarea"), mr = space(), br = element("input"), yr = space(), kr = element("button"), kr.textContent = "Save profile", attr(cr, "class", "svelte-1xutw13"), attr(fr, "class", "svelte-1xutw13"), attr(hr, "type", "text"), attr(hr, "placeholder", "Enter your name..."), hr.required = !0, attr(hr, "class", "svelte-1xutw13"), attr(vr, "placeholder", "Share a bit about yourself..."), vr.required = !0, attr(vr, "class", "svelte-1xutw13"), attr(br, "type", "text"), attr(br, "placeholder", "Link to a profile image..."), attr(br, "class", "svelte-1xutw13"), attr(kr, "type", "submit"), attr(kr, "class", "svelte-1xutw13"), attr(ar, "class", "svelte-1xutw13");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), append(ar, hr), set_input_value(
        hr,
        /*name*/
        lr[2]
      ), append(ar, gr), append(ar, vr), set_input_value(
        vr,
        /*about*/
        lr[3]
      ), append(ar, mr), append(ar, br), set_input_value(
        br,
        /*imageUrl*/
        lr[4]
      ), append(ar, yr), append(ar, kr), _r = !0, Er || (xr = [
        listen(
          hr,
          "input",
          /*input0_input_handler*/
          lr[9]
        ),
        listen(
          vr,
          "input",
          /*textarea_input_handler*/
          lr[10]
        ),
        listen(
          br,
          "input",
          /*input1_input_handler*/
          lr[11]
        ),
        listen(ar, "submit", prevent_default(
          /*saveProfile*/
          lr[5]
        ))
      ], Er = !0);
    },
    p(Cr, Ar) {
      Ar & /*name*/
      4 && hr.value !== /*name*/
      Cr[2] && set_input_value(
        hr,
        /*name*/
        Cr[2]
      ), Ar & /*about*/
      8 && set_input_value(
        vr,
        /*about*/
        Cr[3]
      ), Ar & /*imageUrl*/
      16 && br.value !== /*imageUrl*/
      Cr[4] && set_input_value(
        br,
        /*imageUrl*/
        Cr[4]
      );
    },
    i(Cr) {
      _r || (Cr && add_render_callback(() => {
        _r && (Tr || (Tr = create_bidirectional_transition(ar, slide, {}, !0)), Tr.run(1));
      }), _r = !0);
    },
    o(Cr) {
      Cr && (Tr || (Tr = create_bidirectional_transition(ar, slide, {}, !1)), Tr.run(0)), _r = !1;
    },
    d(Cr) {
      Cr && detach(ar), Cr && Tr && Tr.end(), Er = !1, run_all(xr);
    }
  };
}
function create_fragment$k(lr) {
  let ar, cr, ur, fr, dr;
  const hr = [create_if_block$4, create_else_block$3], gr = [];
  function vr(mr, br) {
    return (
      /*showProfileSetup*/
      mr[1] ? 0 : 1
    );
  }
  return ur = vr(lr), fr = gr[ur] = hr[ur](lr), {
    c() {
      ar = element("h3"), ar.textContent = "Register", cr = space(), fr.c(), dr = empty$1(), attr(ar, "class", "svelte-1xutw13");
    },
    m(mr, br) {
      insert(mr, ar, br), insert(mr, cr, br), gr[ur].m(mr, br), insert(mr, dr, br);
    },
    p(mr, [br]) {
      let yr = ur;
      ur = vr(mr), ur === yr ? gr[ur].p(mr, br) : (group_outros(), transition_out(gr[yr], 1, 1, () => {
        gr[yr] = null;
      }), check_outros(), fr = gr[ur], fr ? fr.p(mr, br) : (fr = gr[ur] = hr[ur](mr), fr.c()), transition_in(fr, 1), fr.m(dr.parentNode, dr));
    },
    i(mr) {
      transition_in(fr);
    },
    o(mr) {
      transition_out(fr);
    },
    d(mr) {
      mr && (detach(ar), detach(cr), detach(dr)), gr[ur].d(mr);
    }
  };
}
let pubkey = "";
function instance$b(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkUser, (Nr) => cr(16, ur = Nr)), component_subscribe(lr, ndkStore, (Nr) => cr(17, fr = Nr));
  let dr = "", hr = "", gr = !1, vr = "", mr = "", br = "", yr, { profiles: kr = {} } = ar, { showNewOpinion: Tr } = ar;
  onMount(() => {
    yr = NDKPrivateKeySigner.generate(), hr = yr.privateKey, cr(0, dr = nip19_exports.nsecEncode(hexToBytes(hr)));
  });
  const _r = async () => {
    if (!dr)
      return;
    (br == "" || !br) && cr(4, br = profileImageUrl + pubkey);
    const Nr = { name: vr, about: mr, image: br, pubkey: "" };
    set_store_value(ndkStore, fr.signer = yr, fr), set_store_value(ndkUser, ur = await fr.signer.user(), ur), set_store_value(ndkUser, ur.ndk = fr, ur);
    let Hr = Nr;
    Hr = { ...Hr, pubkey: ur.pubkey }, set_store_value(ndkUser, ur.profile = Nr, ur), cr(7, kr[ur.pubkey] = { content: Hr }, kr), cr(8, Tr = !1), await ur.publish(), await privkeyLogin(hr);
  }, Er = () => {
    navigator.clipboard.writeText(dr).then(
      () => {
        alert("Private Key copied");
      },
      (Nr) => {
        console.error("Could not copy text: ", Nr);
      }
    );
  };
  function xr() {
    vr = this.value, cr(2, vr);
  }
  function Cr() {
    mr = this.value, cr(3, mr);
  }
  function Ar() {
    br = this.value, cr(4, br);
  }
  function Lr() {
    dr = this.value, cr(0, dr);
  }
  const Dr = () => cr(1, gr = !gr);
  return lr.$$set = (Nr) => {
    "profiles" in Nr && cr(7, kr = Nr.profiles), "showNewOpinion" in Nr && cr(8, Tr = Nr.showNewOpinion);
  }, [
    dr,
    gr,
    vr,
    mr,
    br,
    _r,
    Er,
    kr,
    Tr,
    xr,
    Cr,
    Ar,
    Lr,
    Dr
  ];
}
class Register extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$b, create_fragment$k, safe_not_equal, { profiles: 7, showNewOpinion: 8 }, add_css$a);
  }
  get profiles() {
    return this.$$.ctx[7];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[8];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
create_custom_element(Register, { profiles: {}, showNewOpinion: {} }, [], [], !0);
function add_css$9(lr) {
  append_styles(lr, "svelte-19w231", ".container.svelte-19w231{max-width:600px;text-align:left;font-family:sans-serif}.heading.svelte-19w231{font-size:24px;margin-bottom:8px}.text.svelte-19w231{margin-bottom:24px}.input.svelte-19w231{padding:10px;margin-bottom:16px;border:2px solid #ccc;border-radius:4px;width:100%;display:block}.button.svelte-19w231{background-color:#4DA84D;color:white;border:none;font-size:16px;cursor:pointer;padding:10px;margin-bottom:16px}");
}
function create_else_block$2(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br = window && create_if_block_1$2(lr);
  return {
    c() {
      ar = element("div"), cr = element("h2"), cr.textContent = "Log in", ur = space(), fr = element("p"), fr.innerHTML = `You have two options to log in. You can connect with an authentication tool like Alby that
				supports Nostr. Or you can enter your private key (<a href="/" class="text svelte-19w231">view associated risks</a>).`, dr = space(), br && br.c(), hr = space(), gr = element("button"), gr.textContent = "Connect using private key", attr(cr, "class", "heading svelte-19w231"), attr(fr, "class", "text svelte-19w231"), attr(gr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(yr, kr) {
      insert(yr, ar, kr), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), br && br.m(ar, null), append(ar, hr), append(ar, gr), vr || (mr = listen(
        gr,
        "click",
        /*click_handler_2*/
        lr[10]
      ), vr = !0);
    },
    p(yr, kr) {
      window && br.p(yr, kr);
    },
    i: noop$1,
    o: noop$1,
    d(yr) {
      yr && detach(ar), br && br.d(), vr = !1, mr();
    }
  };
}
function create_if_block$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr;
  return {
    c() {
      ar = element("div"), cr = element("h2"), cr.textContent = "Log in", ur = space(), fr = element("p"), fr.innerHTML = `Enter your <strong>Nostr</strong> private key below to be able to post an opinion.<br/>
				Don&#39;t have a key? <a href="/" class="text svelte-19w231">Register</a>.`, dr = space(), hr = element("input"), gr = space(), vr = element("button"), vr.textContent = "Log in", attr(cr, "class", "heading svelte-19w231"), attr(fr, "class", "text svelte-19w231"), attr(hr, "id", "privkey"), attr(hr, "type", "text"), attr(hr, "placeholder", "Your private key..."), attr(hr, "class", "input svelte-19w231"), attr(vr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(Tr, _r) {
      insert(Tr, ar, _r), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), append(ar, hr), set_input_value(
        hr,
        /*nsec*/
        lr[1]
      ), append(ar, gr), append(ar, vr), br = !0, yr || (kr = [
        listen(
          hr,
          "input",
          /*input_input_handler*/
          lr[7]
        ),
        listen(
          vr,
          "click",
          /*click_handler*/
          lr[8]
        )
      ], yr = !0);
    },
    p(Tr, _r) {
      _r & /*nsec*/
      2 && hr.value !== /*nsec*/
      Tr[1] && set_input_value(
        hr,
        /*nsec*/
        Tr[1]
      );
    },
    i(Tr) {
      br || (Tr && add_render_callback(() => {
        br && (mr || (mr = create_bidirectional_transition(ar, slide, {}, !0)), mr.run(1));
      }), br = !0);
    },
    o(Tr) {
      Tr && (mr || (mr = create_bidirectional_transition(ar, slide, {}, !1)), mr.run(0)), br = !1;
    },
    d(Tr) {
      Tr && detach(ar), Tr && mr && mr.end(), yr = !1, run_all(kr);
    }
  };
}
function create_if_block_1$2(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("button"), ar.textContent = "Connect using browser extension", attr(ar, "class", "button svelte-19w231");
    },
    m(fr, dr) {
      insert(fr, ar, dr), cr || (ur = listen(
        ar,
        "click",
        /*click_handler_1*/
        lr[9]
      ), cr = !0);
    },
    p: noop$1,
    d(fr) {
      fr && detach(ar), cr = !1, ur();
    }
  };
}
function create_fragment$j(lr) {
  let ar, cr, ur, fr, dr;
  const hr = [create_if_block$3, create_else_block$2], gr = [];
  function vr(mr, br) {
    return (
      /*showPrivateKeyInput*/
      mr[0] ? 0 : 1
    );
  }
  return cr = vr(lr), ur = gr[cr] = hr[cr](lr), {
    c() {
      ar = element("div"), ur.c();
    },
    m(mr, br) {
      insert(mr, ar, br), gr[cr].m(ar, null), dr = !0;
    },
    p(mr, [br]) {
      let yr = cr;
      cr = vr(mr), cr === yr ? gr[cr].p(mr, br) : (group_outros(), transition_out(gr[yr], 1, 1, () => {
        gr[yr] = null;
      }), check_outros(), ur = gr[cr], ur ? ur.p(mr, br) : (ur = gr[cr] = hr[cr](mr), ur.c()), transition_in(ur, 1), ur.m(ar, null));
    },
    i(mr) {
      dr || (transition_in(ur), mr && add_render_callback(() => {
        dr && (fr || (fr = create_bidirectional_transition(ar, slide, {}, !0)), fr.run(1));
      }), dr = !0);
    },
    o(mr) {
      transition_out(ur), mr && (fr || (fr = create_bidirectional_transition(ar, slide, {}, !1)), fr.run(0)), dr = !1;
    },
    d(mr) {
      mr && detach(ar), gr[cr].d(), mr && fr && fr.end();
    }
  };
}
function instance$a(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkUser, (xr) => cr(11, ur = xr)), component_subscribe(lr, ndkStore, (xr) => cr(12, fr = xr));
  let dr = !1, hr = "", { profiles: gr = {} } = ar, { opinionContent: vr } = ar, { subject: mr } = ar, { showNewOpinion: br } = ar;
  const yr = async (xr) => {
    if (!xr)
      return;
    let Cr;
    switch (xr) {
      case "pk":
        if (!hr.startsWith("nsec")) {
          alert("Please use your nsec to login");
          return;
        }
        Cr = await privkeyLogin(nip19_exports.decode(hr).data);
        break;
      case "nip07":
        Cr = await NDKlogin();
        break;
    }
    if (!Cr) {
      console.error("Something went wrong while login!!");
      return;
    }
    if (!ur) {
      console.error("Can't proceed. $ndkUser is null");
      return;
    }
    let Ar = await fetchUserProfile(ur.pubkey);
    Ar || (Ar = {
      image: profileImageUrl + ur.pubkey,
      pubkey: ur.pubkey
    }), Ar.image || (Ar.image = profileImageUrl + ur.pubkey), Ar.pubkey || (Ar.pubkey = ur.pubkey), cr(5, br = !1);
    const Lr = {
      kinds: [kindOpinion],
      "#d": [mr],
      authors: [ur.pubkey]
    };
    let Dr = await fr.fetchEvent(Lr, { closeOnEose: !0 });
    cr(3, gr[ur.pubkey] = { content: Ar }, gr), Dr && Dr.content && cr(4, vr = Dr.content);
  };
  function kr() {
    hr = this.value, cr(1, hr);
  }
  const Tr = () => {
    yr("pk");
  }, _r = () => {
    yr("nip07");
  }, Er = () => cr(0, dr = !dr);
  return lr.$$set = (xr) => {
    "profiles" in xr && cr(3, gr = xr.profiles), "opinionContent" in xr && cr(4, vr = xr.opinionContent), "subject" in xr && cr(6, mr = xr.subject), "showNewOpinion" in xr && cr(5, br = xr.showNewOpinion);
  }, [
    dr,
    hr,
    yr,
    gr,
    vr,
    br,
    mr,
    kr,
    Tr,
    _r,
    Er
  ];
}
class Login extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$a,
      create_fragment$j,
      safe_not_equal,
      {
        profiles: 3,
        opinionContent: 4,
        subject: 6,
        showNewOpinion: 5
      },
      add_css$9
    );
  }
  get profiles() {
    return this.$$.ctx[3];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[4];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[6];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[5];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
customElements.define("nostr-opinion-login", create_custom_element(Login, { profiles: {}, opinionContent: {}, subject: {}, showNewOpinion: {} }, [], [], !0));
var dist$7 = {}, dist$6, hasRequiredDist$6;
function requireDist$6() {
  if (hasRequiredDist$6)
    return dist$6;
  hasRequiredDist$6 = 1;
  function lr(ar) {
    this.content = ar;
  }
  return lr.prototype = {
    constructor: lr,
    find: function(ar) {
      for (var cr = 0; cr < this.content.length; cr += 2)
        if (this.content[cr] === ar)
          return cr;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(ar) {
      var cr = this.find(ar);
      return cr == -1 ? void 0 : this.content[cr + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(ar, cr, ur) {
      var fr = ur && ur != ar ? this.remove(ur) : this, dr = fr.find(ar), hr = fr.content.slice();
      return dr == -1 ? hr.push(ur || ar, cr) : (hr[dr + 1] = cr, ur && (hr[dr] = ur)), new lr(hr);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(ar) {
      var cr = this.find(ar);
      if (cr == -1)
        return this;
      var ur = this.content.slice();
      return ur.splice(cr, 2), new lr(ur);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(ar, cr) {
      return new lr([ar, cr].concat(this.remove(ar).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(ar, cr) {
      var ur = this.remove(ar).content.slice();
      return ur.push(ar, cr), new lr(ur);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(ar, cr, ur) {
      var fr = this.remove(cr), dr = fr.content.slice(), hr = fr.find(ar);
      return dr.splice(hr == -1 ? dr.length : hr, 0, cr, ur), new lr(dr);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(ar) {
      for (var cr = 0; cr < this.content.length; cr += 2)
        ar(this.content[cr], this.content[cr + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(ar) {
      return ar = lr.from(ar), ar.size ? new lr(ar.content.concat(this.subtract(ar).content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(ar) {
      return ar = lr.from(ar), ar.size ? new lr(this.subtract(ar).content.concat(ar.content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(ar) {
      var cr = this;
      ar = lr.from(ar);
      for (var ur = 0; ur < ar.content.length; ur += 2)
        cr = cr.remove(ar.content[ur]);
      return cr;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var ar = {};
      return this.forEach(function(cr, ur) {
        ar[cr] = ur;
      }), ar;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  }, lr.from = function(ar) {
    if (ar instanceof lr)
      return ar;
    var cr = [];
    if (ar)
      for (var ur in ar)
        cr.push(ur, ar[ur]);
    return new lr(cr);
  }, dist$6 = lr, dist$6;
}
var hasRequiredDist$5;
function requireDist$5() {
  if (hasRequiredDist$5)
    return dist$7;
  hasRequiredDist$5 = 1;
  function lr(si, Qr) {
    return dr(si) || fr(si, Qr) || cr(si, Qr) || ar();
  }
  function ar() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function cr(si, Qr) {
    if (si) {
      if (typeof si == "string")
        return ur(si, Qr);
      var Br = Object.prototype.toString.call(si).slice(8, -1);
      if (Br === "Object" && si.constructor && (Br = si.constructor.name), Br === "Map" || Br === "Set")
        return Array.from(si);
      if (Br === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Br))
        return ur(si, Qr);
    }
  }
  function ur(si, Qr) {
    (Qr == null || Qr > si.length) && (Qr = si.length);
    for (var Br = 0, zr = new Array(Qr); Br < Qr; Br++)
      zr[Br] = si[Br];
    return zr;
  }
  function fr(si, Qr) {
    var Br = si == null ? null : typeof Symbol != "undefined" && si[Symbol.iterator] || si["@@iterator"];
    if (Br != null) {
      var zr = [], Xr = !0, ai = !1, vi, Ti;
      try {
        for (Br = Br.call(si); !(Xr = (vi = Br.next()).done) && (zr.push(vi.value), !(Qr && zr.length === Qr)); Xr = !0)
          ;
      } catch (Fi) {
        ai = !0, Ti = Fi;
      } finally {
        try {
          !Xr && Br.return != null && Br.return();
        } finally {
          if (ai)
            throw Ti;
        }
      }
      return zr;
    }
  }
  function dr(si) {
    if (Array.isArray(si))
      return si;
  }
  function hr() {
    return typeof Reflect != "undefined" && Reflect.get ? hr = Reflect.get : hr = function(Qr, Br, zr) {
      var Xr = gr(Qr, Br);
      if (Xr) {
        var ai = Object.getOwnPropertyDescriptor(Xr, Br);
        return ai.get ? ai.get.call(arguments.length < 3 ? Qr : zr) : ai.value;
      }
    }, hr.apply(this, arguments);
  }
  function gr(si, Qr) {
    for (; !Object.prototype.hasOwnProperty.call(si, Qr) && (si = Cr(si), si !== null); )
      ;
    return si;
  }
  function vr(si, Qr) {
    if (typeof Qr != "function" && Qr !== null)
      throw new TypeError("Super expression must either be null or a function");
    si.prototype = Object.create(Qr && Qr.prototype, { constructor: { value: si, writable: !0, configurable: !0 } }), Object.defineProperty(si, "prototype", { writable: !1 }), Qr && xr(si, Qr);
  }
  function mr(si) {
    var Qr = _r();
    return function() {
      var zr = Cr(si), Xr;
      if (Qr) {
        var ai = Cr(this).constructor;
        Xr = Reflect.construct(zr, arguments, ai);
      } else
        Xr = zr.apply(this, arguments);
      return br(this, Xr);
    };
  }
  function br(si, Qr) {
    if (Qr && (Nr(Qr) === "object" || typeof Qr == "function"))
      return Qr;
    if (Qr !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return yr(si);
  }
  function yr(si) {
    if (si === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return si;
  }
  function kr(si) {
    var Qr = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return kr = function(zr) {
      if (zr === null || !Er(zr))
        return zr;
      if (typeof zr != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof Qr != "undefined") {
        if (Qr.has(zr))
          return Qr.get(zr);
        Qr.set(zr, Xr);
      }
      function Xr() {
        return Tr(zr, arguments, Cr(this).constructor);
      }
      return Xr.prototype = Object.create(zr.prototype, { constructor: { value: Xr, enumerable: !1, writable: !0, configurable: !0 } }), xr(Xr, zr);
    }, kr(si);
  }
  function Tr(si, Qr, Br) {
    return _r() ? Tr = Reflect.construct : Tr = function(Xr, ai, vi) {
      var Ti = [null];
      Ti.push.apply(Ti, ai);
      var Fi = Function.bind.apply(Xr, Ti), ra = new Fi();
      return vi && xr(ra, vi.prototype), ra;
    }, Tr.apply(null, arguments);
  }
  function _r() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (si) {
      return !1;
    }
  }
  function Er(si) {
    return Function.toString.call(si).indexOf("[native code]") !== -1;
  }
  function xr(si, Qr) {
    return xr = Object.setPrototypeOf || function(zr, Xr) {
      return zr.__proto__ = Xr, zr;
    }, xr(si, Qr);
  }
  function Cr(si) {
    return Cr = Object.setPrototypeOf ? Object.getPrototypeOf : function(Br) {
      return Br.__proto__ || Object.getPrototypeOf(Br);
    }, Cr(si);
  }
  function Ar(si, Qr) {
    if (!(si instanceof Qr))
      throw new TypeError("Cannot call a class as a function");
  }
  function Lr(si, Qr) {
    for (var Br = 0; Br < Qr.length; Br++) {
      var zr = Qr[Br];
      zr.enumerable = zr.enumerable || !1, zr.configurable = !0, "value" in zr && (zr.writable = !0), Object.defineProperty(si, zr.key, zr);
    }
  }
  function Dr(si, Qr, Br) {
    return Qr && Lr(si.prototype, Qr), Br && Lr(si, Br), Object.defineProperty(si, "prototype", { writable: !1 }), si;
  }
  function Nr(si) {
    "@babel/helpers - typeof";
    return Nr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Qr) {
      return typeof Qr;
    } : function(Qr) {
      return Qr && typeof Symbol == "function" && Qr.constructor === Symbol && Qr !== Symbol.prototype ? "symbol" : typeof Qr;
    }, Nr(si);
  }
  Object.defineProperty(dist$7, "__esModule", {
    value: !0
  });
  var Hr = requireDist$6();
  function $r(si) {
    return si && Nr(si) === "object" && "default" in si ? si : {
      default: si
    };
  }
  var Wr = $r(Hr);
  function Zr(si, Qr, Br) {
    for (var zr = 0; ; zr++) {
      if (zr == si.childCount || zr == Qr.childCount)
        return si.childCount == Qr.childCount ? null : Br;
      var Xr = si.child(zr), ai = Qr.child(zr);
      if (Xr == ai) {
        Br += Xr.nodeSize;
        continue;
      }
      if (!Xr.sameMarkup(ai))
        return Br;
      if (Xr.isText && Xr.text != ai.text) {
        for (var vi = 0; Xr.text[vi] == ai.text[vi]; vi++)
          Br++;
        return Br;
      }
      if (Xr.content.size || ai.content.size) {
        var Ti = Zr(Xr.content, ai.content, Br + 1);
        if (Ti != null)
          return Ti;
      }
      Br += Xr.nodeSize;
    }
  }
  function oi(si, Qr, Br, zr) {
    for (var Xr = si.childCount, ai = Qr.childCount; ; ) {
      if (Xr == 0 || ai == 0)
        return Xr == ai ? null : {
          a: Br,
          b: zr
        };
      var vi = si.child(--Xr), Ti = Qr.child(--ai), Fi = vi.nodeSize;
      if (vi == Ti) {
        Br -= Fi, zr -= Fi;
        continue;
      }
      if (!vi.sameMarkup(Ti))
        return {
          a: Br,
          b: zr
        };
      if (vi.isText && vi.text != Ti.text) {
        for (var ra = 0, pa = Math.min(vi.text.length, Ti.text.length); ra < pa && vi.text[vi.text.length - ra - 1] == Ti.text[Ti.text.length - ra - 1]; )
          ra++, Br--, zr--;
        return {
          a: Br,
          b: zr
        };
      }
      if (vi.content.size || Ti.content.size) {
        var ca = oi(vi.content, Ti.content, Br - 1, zr - 1);
        if (ca)
          return ca;
      }
      Br -= Fi, zr -= Fi;
    }
  }
  var Jr = function() {
    function si(Qr, Br) {
      if (Ar(this, si), this.content = Qr, this.size = Br || 0, Br == null)
        for (var zr = 0; zr < Qr.length; zr++)
          this.size += Qr[zr].nodeSize;
    }
    return Dr(si, [{
      key: "nodesBetween",
      value: function(Br, zr, Xr) {
        for (var ai = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, vi = arguments.length > 4 ? arguments[4] : void 0, Ti = 0, Fi = 0; Fi < zr; Ti++) {
          var ra = this.content[Ti], pa = Fi + ra.nodeSize;
          if (pa > Br && Xr(ra, ai + Fi, vi || null, Ti) !== !1 && ra.content.size) {
            var ca = Fi + 1;
            ra.nodesBetween(Math.max(0, Br - ca), Math.min(ra.content.size, zr - ca), Xr, ai + ca);
          }
          Fi = pa;
        }
      }
    }, {
      key: "descendants",
      value: function(Br) {
        this.nodesBetween(0, this.size, Br);
      }
    }, {
      key: "textBetween",
      value: function(Br, zr, Xr, ai) {
        var vi = "", Ti = !0;
        return this.nodesBetween(Br, zr, function(Fi, ra) {
          Fi.isText ? (vi += Fi.text.slice(Math.max(Br, ra) - ra, zr - ra), Ti = !Xr) : Fi.isLeaf ? (ai ? vi += typeof ai == "function" ? ai(Fi) : ai : Fi.type.spec.leafText && (vi += Fi.type.spec.leafText(Fi)), Ti = !Xr) : !Ti && Fi.isBlock && (vi += Xr, Ti = !0);
        }, 0), vi;
      }
    }, {
      key: "append",
      value: function(Br) {
        if (!Br.size)
          return this;
        if (!this.size)
          return Br;
        var zr = this.lastChild, Xr = Br.firstChild, ai = this.content.slice(), vi = 0;
        for (zr.isText && zr.sameMarkup(Xr) && (ai[ai.length - 1] = zr.withText(zr.text + Xr.text), vi = 1); vi < Br.content.length; vi++)
          ai.push(Br.content[vi]);
        return new si(ai, this.size + Br.size);
      }
    }, {
      key: "cut",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
        if (Br == 0 && zr == this.size)
          return this;
        var Xr = [], ai = 0;
        if (zr > Br)
          for (var vi = 0, Ti = 0; Ti < zr; vi++) {
            var Fi = this.content[vi], ra = Ti + Fi.nodeSize;
            ra > Br && ((Ti < Br || ra > zr) && (Fi.isText ? Fi = Fi.cut(Math.max(0, Br - Ti), Math.min(Fi.text.length, zr - Ti)) : Fi = Fi.cut(Math.max(0, Br - Ti - 1), Math.min(Fi.content.size, zr - Ti - 1))), Xr.push(Fi), ai += Fi.nodeSize), Ti = ra;
          }
        return new si(Xr, ai);
      }
    }, {
      key: "cutByIndex",
      value: function(Br, zr) {
        return Br == zr ? si.empty : Br == 0 && zr == this.content.length ? this : new si(this.content.slice(Br, zr));
      }
    }, {
      key: "replaceChild",
      value: function(Br, zr) {
        var Xr = this.content[Br];
        if (Xr == zr)
          return this;
        var ai = this.content.slice(), vi = this.size + zr.nodeSize - Xr.nodeSize;
        return ai[Br] = zr, new si(ai, vi);
      }
    }, {
      key: "addToStart",
      value: function(Br) {
        return new si([Br].concat(this.content), this.size + Br.nodeSize);
      }
    }, {
      key: "addToEnd",
      value: function(Br) {
        return new si(this.content.concat(Br), this.size + Br.nodeSize);
      }
    }, {
      key: "eq",
      value: function(Br) {
        if (this.content.length != Br.content.length)
          return !1;
        for (var zr = 0; zr < this.content.length; zr++)
          if (!this.content[zr].eq(Br.content[zr]))
            return !1;
        return !0;
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.length ? this.content[0] : null;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.length;
      }
    }, {
      key: "child",
      value: function(Br) {
        var zr = this.content[Br];
        if (!zr)
          throw new RangeError("Index " + Br + " out of range for " + this);
        return zr;
      }
    }, {
      key: "maybeChild",
      value: function(Br) {
        return this.content[Br] || null;
      }
    }, {
      key: "forEach",
      value: function(Br) {
        for (var zr = 0, Xr = 0; zr < this.content.length; zr++) {
          var ai = this.content[zr];
          Br(ai, Xr, zr), Xr += ai.nodeSize;
        }
      }
    }, {
      key: "findDiffStart",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Zr(this, Br, zr);
      }
    }, {
      key: "findDiffEnd",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size, Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Br.size;
        return oi(this, Br, zr, Xr);
      }
    }, {
      key: "findIndex",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (Br == 0)
          return li(0, Br);
        if (Br == this.size)
          return li(this.content.length, Br);
        if (Br > this.size || Br < 0)
          throw new RangeError("Position ".concat(Br, " outside of fragment (").concat(this, ")"));
        for (var Xr = 0, ai = 0; ; Xr++) {
          var vi = this.child(Xr), Ti = ai + vi.nodeSize;
          if (Ti >= Br)
            return Ti == Br || zr > 0 ? li(Xr + 1, Ti) : li(Xr, ai);
          ai = Ti;
        }
      }
    }, {
      key: "toString",
      value: function() {
        return "<" + this.toStringInner() + ">";
      }
    }, {
      key: "toStringInner",
      value: function() {
        return this.content.join(", ");
      }
    }, {
      key: "toJSON",
      value: function() {
        return this.content.length ? this.content.map(function(Br) {
          return Br.toJSON();
        }) : null;
      }
    }], [{
      key: "fromJSON",
      value: function(Br, zr) {
        if (!zr)
          return si.empty;
        if (!Array.isArray(zr))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new si(zr.map(Br.nodeFromJSON));
      }
    }, {
      key: "fromArray",
      value: function(Br) {
        if (!Br.length)
          return si.empty;
        for (var zr, Xr = 0, ai = 0; ai < Br.length; ai++) {
          var vi = Br[ai];
          Xr += vi.nodeSize, ai && vi.isText && Br[ai - 1].sameMarkup(vi) ? (zr || (zr = Br.slice(0, ai)), zr[zr.length - 1] = vi.withText(zr[zr.length - 1].text + vi.text)) : zr && zr.push(vi);
        }
        return new si(zr || Br, Xr);
      }
    }, {
      key: "from",
      value: function(Br) {
        if (!Br)
          return si.empty;
        if (Br instanceof si)
          return Br;
        if (Array.isArray(Br))
          return this.fromArray(Br);
        if (Br.attrs)
          return new si([Br], Br.nodeSize);
        throw new RangeError("Can not convert " + Br + " to a Fragment" + (Br.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }]), si;
  }();
  Jr.empty = new Jr([], 0);
  var Yr = {
    index: 0,
    offset: 0
  };
  function li(si, Qr) {
    return Yr.index = si, Yr.offset = Qr, Yr;
  }
  function Si(si, Qr) {
    if (si === Qr)
      return !0;
    if (!(si && Nr(si) == "object") || !(Qr && Nr(Qr) == "object"))
      return !1;
    var Br = Array.isArray(si);
    if (Array.isArray(Qr) != Br)
      return !1;
    if (Br) {
      if (si.length != Qr.length)
        return !1;
      for (var zr = 0; zr < si.length; zr++)
        if (!Si(si[zr], Qr[zr]))
          return !1;
    } else {
      for (var Xr in si)
        if (!(Xr in Qr) || !Si(si[Xr], Qr[Xr]))
          return !1;
      for (var ai in Qr)
        if (!(ai in si))
          return !1;
    }
    return !0;
  }
  var ci = function() {
    function si(Qr, Br) {
      Ar(this, si), this.type = Qr, this.attrs = Br;
    }
    return Dr(si, [{
      key: "addToSet",
      value: function(Br) {
        for (var zr, Xr = !1, ai = 0; ai < Br.length; ai++) {
          var vi = Br[ai];
          if (this.eq(vi))
            return Br;
          if (this.type.excludes(vi.type))
            zr || (zr = Br.slice(0, ai));
          else {
            if (vi.type.excludes(this.type))
              return Br;
            !Xr && vi.type.rank > this.type.rank && (zr || (zr = Br.slice(0, ai)), zr.push(this), Xr = !0), zr && zr.push(vi);
          }
        }
        return zr || (zr = Br.slice()), Xr || zr.push(this), zr;
      }
    }, {
      key: "removeFromSet",
      value: function(Br) {
        for (var zr = 0; zr < Br.length; zr++)
          if (this.eq(Br[zr]))
            return Br.slice(0, zr).concat(Br.slice(zr + 1));
        return Br;
      }
    }, {
      key: "isInSet",
      value: function(Br) {
        for (var zr = 0; zr < Br.length; zr++)
          if (this.eq(Br[zr]))
            return !0;
        return !1;
      }
    }, {
      key: "eq",
      value: function(Br) {
        return this == Br || this.type == Br.type && Si(this.attrs, Br.attrs);
      }
    }, {
      key: "toJSON",
      value: function() {
        var Br = {
          type: this.type.name
        };
        for (var zr in this.attrs) {
          Br.attrs = this.attrs;
          break;
        }
        return Br;
      }
    }], [{
      key: "fromJSON",
      value: function(Br, zr) {
        if (!zr)
          throw new RangeError("Invalid input for Mark.fromJSON");
        var Xr = Br.marks[zr.type];
        if (!Xr)
          throw new RangeError("There is no mark type ".concat(zr.type, " in this schema"));
        return Xr.create(zr.attrs);
      }
    }, {
      key: "sameSet",
      value: function(Br, zr) {
        if (Br == zr)
          return !0;
        if (Br.length != zr.length)
          return !1;
        for (var Xr = 0; Xr < Br.length; Xr++)
          if (!Br[Xr].eq(zr[Xr]))
            return !1;
        return !0;
      }
    }, {
      key: "setFrom",
      value: function(Br) {
        if (!Br || Array.isArray(Br) && Br.length == 0)
          return si.none;
        if (Br instanceof si)
          return [Br];
        var zr = Br.slice();
        return zr.sort(function(Xr, ai) {
          return Xr.type.rank - ai.type.rank;
        }), zr;
      }
    }]), si;
  }();
  ci.none = [];
  var hi = function(si) {
    vr(Br, si);
    var Qr = mr(Br);
    function Br() {
      return Ar(this, Br), Qr.apply(this, arguments);
    }
    return Dr(Br);
  }(kr(Error)), Ei = function() {
    function si(Qr, Br, zr) {
      Ar(this, si), this.content = Qr, this.openStart = Br, this.openEnd = zr;
    }
    return Dr(si, [{
      key: "size",
      get: function() {
        return this.content.size - this.openStart - this.openEnd;
      }
    }, {
      key: "insertAt",
      value: function(Br, zr) {
        var Xr = gi(this.content, Br + this.openStart, zr);
        return Xr && new si(Xr, this.openStart, this.openEnd);
      }
    }, {
      key: "removeBetween",
      value: function(Br, zr) {
        return new si(di(this.content, Br + this.openStart, zr + this.openStart), this.openStart, this.openEnd);
      }
    }, {
      key: "eq",
      value: function(Br) {
        return this.content.eq(Br.content) && this.openStart == Br.openStart && this.openEnd == Br.openEnd;
      }
    }, {
      key: "toString",
      value: function() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
    }, {
      key: "toJSON",
      value: function() {
        if (!this.content.size)
          return null;
        var Br = {
          content: this.content.toJSON()
        };
        return this.openStart > 0 && (Br.openStart = this.openStart), this.openEnd > 0 && (Br.openEnd = this.openEnd), Br;
      }
    }], [{
      key: "fromJSON",
      value: function(Br, zr) {
        if (!zr)
          return si.empty;
        var Xr = zr.openStart || 0, ai = zr.openEnd || 0;
        if (typeof Xr != "number" || typeof ai != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new si(Jr.fromJSON(Br, zr.content), Xr, ai);
      }
    }, {
      key: "maxOpen",
      value: function(Br) {
        for (var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Xr = 0, ai = 0, vi = Br.firstChild; vi && !vi.isLeaf && (zr || !vi.type.spec.isolating); vi = vi.firstChild)
          Xr++;
        for (var Ti = Br.lastChild; Ti && !Ti.isLeaf && (zr || !Ti.type.spec.isolating); Ti = Ti.lastChild)
          ai++;
        return new si(Br, Xr, ai);
      }
    }]), si;
  }();
  Ei.empty = new Ei(Jr.empty, 0, 0);
  function di(si, Qr, Br) {
    var zr = si.findIndex(Qr), Xr = zr.index, ai = zr.offset, vi = si.maybeChild(Xr), Ti = si.findIndex(Br), Fi = Ti.index, ra = Ti.offset;
    if (ai == Qr || vi.isText) {
      if (ra != Br && !si.child(Fi).isText)
        throw new RangeError("Removing non-flat range");
      return si.cut(0, Qr).append(si.cut(Br));
    }
    if (Xr != Fi)
      throw new RangeError("Removing non-flat range");
    return si.replaceChild(Xr, vi.copy(di(vi.content, Qr - ai - 1, Br - ai - 1)));
  }
  function gi(si, Qr, Br, zr) {
    var Xr = si.findIndex(Qr), ai = Xr.index, vi = Xr.offset, Ti = si.maybeChild(ai);
    if (vi == Qr || Ti.isText)
      return zr && !zr.canReplace(ai, ai, Br) ? null : si.cut(0, Qr).append(Br).append(si.cut(Qr));
    var Fi = gi(Ti.content, Qr - vi - 1, Br);
    return Fi && si.replaceChild(ai, Ti.copy(Fi));
  }
  function Li(si, Qr, Br) {
    if (Br.openStart > si.depth)
      throw new hi("Inserted content deeper than insertion position");
    if (si.depth - Br.openStart != Qr.depth - Br.openEnd)
      throw new hi("Inconsistent open depths");
    return ui(si, Qr, Br, 0);
  }
  function ui(si, Qr, Br, zr) {
    var Xr = si.index(zr), ai = si.node(zr);
    if (Xr == Qr.index(zr) && zr < si.depth - Br.openStart) {
      var vi = ui(si, Qr, Br, zr + 1);
      return ai.copy(ai.content.replaceChild(Xr, vi));
    } else if (Br.content.size)
      if (!Br.openStart && !Br.openEnd && si.depth == zr && Qr.depth == zr) {
        var Ti = si.parent, Fi = Ti.content;
        return Oi(Ti, Fi.cut(0, si.parentOffset).append(Br.content).append(Fi.cut(Qr.parentOffset)));
      } else {
        var ra = mi(Br, si), pa = ra.start, ca = ra.end;
        return Oi(ai, Mi(si, pa, ca, Qr, zr));
      }
    else
      return Oi(ai, Ii(si, Qr, zr));
  }
  function wi(si, Qr) {
    if (!Qr.type.compatibleContent(si.type))
      throw new hi("Cannot join " + Qr.type.name + " onto " + si.type.name);
  }
  function Ui(si, Qr, Br) {
    var zr = si.node(Br);
    return wi(zr, Qr.node(Br)), zr;
  }
  function yi(si, Qr) {
    var Br = Qr.length - 1;
    Br >= 0 && si.isText && si.sameMarkup(Qr[Br]) ? Qr[Br] = si.withText(Qr[Br].text + si.text) : Qr.push(si);
  }
  function Vi(si, Qr, Br, zr) {
    var Xr = (Qr || si).node(Br), ai = 0, vi = Qr ? Qr.index(Br) : Xr.childCount;
    si && (ai = si.index(Br), si.depth > Br ? ai++ : si.textOffset && (yi(si.nodeAfter, zr), ai++));
    for (var Ti = ai; Ti < vi; Ti++)
      yi(Xr.child(Ti), zr);
    Qr && Qr.depth == Br && Qr.textOffset && yi(Qr.nodeBefore, zr);
  }
  function Oi(si, Qr) {
    return si.type.checkContent(Qr), si.copy(Qr);
  }
  function Mi(si, Qr, Br, zr, Xr) {
    var ai = si.depth > Xr && Ui(si, Qr, Xr + 1), vi = zr.depth > Xr && Ui(Br, zr, Xr + 1), Ti = [];
    return Vi(null, si, Xr, Ti), ai && vi && Qr.index(Xr) == Br.index(Xr) ? (wi(ai, vi), yi(Oi(ai, Mi(si, Qr, Br, zr, Xr + 1)), Ti)) : (ai && yi(Oi(ai, Ii(si, Qr, Xr + 1)), Ti), Vi(Qr, Br, Xr, Ti), vi && yi(Oi(vi, Ii(Br, zr, Xr + 1)), Ti)), Vi(zr, null, Xr, Ti), new Jr(Ti);
  }
  function Ii(si, Qr, Br) {
    var zr = [];
    if (Vi(null, si, Br, zr), si.depth > Br) {
      var Xr = Ui(si, Qr, Br + 1);
      yi(Oi(Xr, Ii(si, Qr, Br + 1)), zr);
    }
    return Vi(Qr, null, Br, zr), new Jr(zr);
  }
  function mi(si, Qr) {
    for (var Br = Qr.depth - si.openStart, zr = Qr.node(Br), Xr = zr.copy(si.content), ai = Br - 1; ai >= 0; ai--)
      Xr = Qr.node(ai).copy(Jr.from(Xr));
    return {
      start: Xr.resolveNoCache(si.openStart + Br),
      end: Xr.resolveNoCache(Xr.content.size - si.openEnd - Br)
    };
  }
  var _i = function() {
    function si(Qr, Br, zr) {
      Ar(this, si), this.pos = Qr, this.path = Br, this.parentOffset = zr, this.depth = Br.length / 3 - 1;
    }
    return Dr(si, [{
      key: "resolveDepth",
      value: function(Br) {
        return Br == null ? this.depth : Br < 0 ? this.depth + Br : Br;
      }
    }, {
      key: "parent",
      get: function() {
        return this.node(this.depth);
      }
    }, {
      key: "doc",
      get: function() {
        return this.node(0);
      }
    }, {
      key: "node",
      value: function(Br) {
        return this.path[this.resolveDepth(Br) * 3];
      }
    }, {
      key: "index",
      value: function(Br) {
        return this.path[this.resolveDepth(Br) * 3 + 1];
      }
    }, {
      key: "indexAfter",
      value: function(Br) {
        return Br = this.resolveDepth(Br), this.index(Br) + (Br == this.depth && !this.textOffset ? 0 : 1);
      }
    }, {
      key: "start",
      value: function(Br) {
        return Br = this.resolveDepth(Br), Br == 0 ? 0 : this.path[Br * 3 - 1] + 1;
      }
    }, {
      key: "end",
      value: function(Br) {
        return Br = this.resolveDepth(Br), this.start(Br) + this.node(Br).content.size;
      }
    }, {
      key: "before",
      value: function(Br) {
        if (Br = this.resolveDepth(Br), !Br)
          throw new RangeError("There is no position before the top-level node");
        return Br == this.depth + 1 ? this.pos : this.path[Br * 3 - 1];
      }
    }, {
      key: "after",
      value: function(Br) {
        if (Br = this.resolveDepth(Br), !Br)
          throw new RangeError("There is no position after the top-level node");
        return Br == this.depth + 1 ? this.pos : this.path[Br * 3 - 1] + this.path[Br * 3].nodeSize;
      }
    }, {
      key: "textOffset",
      get: function() {
        return this.pos - this.path[this.path.length - 1];
      }
    }, {
      key: "nodeAfter",
      get: function() {
        var Br = this.parent, zr = this.index(this.depth);
        if (zr == Br.childCount)
          return null;
        var Xr = this.pos - this.path[this.path.length - 1], ai = Br.child(zr);
        return Xr ? Br.child(zr).cut(Xr) : ai;
      }
    }, {
      key: "nodeBefore",
      get: function() {
        var Br = this.index(this.depth), zr = this.pos - this.path[this.path.length - 1];
        return zr ? this.parent.child(Br).cut(0, zr) : Br == 0 ? null : this.parent.child(Br - 1);
      }
    }, {
      key: "posAtIndex",
      value: function(Br, zr) {
        zr = this.resolveDepth(zr);
        for (var Xr = this.path[zr * 3], ai = zr == 0 ? 0 : this.path[zr * 3 - 1] + 1, vi = 0; vi < Br; vi++)
          ai += Xr.child(vi).nodeSize;
        return ai;
      }
    }, {
      key: "marks",
      value: function() {
        var Br = this.parent, zr = this.index();
        if (Br.content.size == 0)
          return ci.none;
        if (this.textOffset)
          return Br.child(zr).marks;
        var Xr = Br.maybeChild(zr - 1), ai = Br.maybeChild(zr);
        if (!Xr) {
          var vi = Xr;
          Xr = ai, ai = vi;
        }
        for (var Ti = Xr.marks, Fi = 0; Fi < Ti.length; Fi++)
          Ti[Fi].type.spec.inclusive === !1 && (!ai || !Ti[Fi].isInSet(ai.marks)) && (Ti = Ti[Fi--].removeFromSet(Ti));
        return Ti;
      }
    }, {
      key: "marksAcross",
      value: function(Br) {
        var zr = this.parent.maybeChild(this.index());
        if (!zr || !zr.isInline)
          return null;
        for (var Xr = zr.marks, ai = Br.parent.maybeChild(Br.index()), vi = 0; vi < Xr.length; vi++)
          Xr[vi].type.spec.inclusive === !1 && (!ai || !Xr[vi].isInSet(ai.marks)) && (Xr = Xr[vi--].removeFromSet(Xr));
        return Xr;
      }
    }, {
      key: "sharedDepth",
      value: function(Br) {
        for (var zr = this.depth; zr > 0; zr--)
          if (this.start(zr) <= Br && this.end(zr) >= Br)
            return zr;
        return 0;
      }
    }, {
      key: "blockRange",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this, zr = arguments.length > 1 ? arguments[1] : void 0;
        if (Br.pos < this.pos)
          return Br.blockRange(this);
        for (var Xr = this.depth - (this.parent.inlineContent || this.pos == Br.pos ? 1 : 0); Xr >= 0; Xr--)
          if (Br.pos <= this.end(Xr) && (!zr || zr(this.node(Xr))))
            return new ia(this, Br, Xr);
        return null;
      }
    }, {
      key: "sameParent",
      value: function(Br) {
        return this.pos - this.parentOffset == Br.pos - Br.parentOffset;
      }
    }, {
      key: "max",
      value: function(Br) {
        return Br.pos > this.pos ? Br : this;
      }
    }, {
      key: "min",
      value: function(Br) {
        return Br.pos < this.pos ? Br : this;
      }
    }, {
      key: "toString",
      value: function() {
        for (var Br = "", zr = 1; zr <= this.depth; zr++)
          Br += (Br ? "/" : "") + this.node(zr).type.name + "_" + this.index(zr - 1);
        return Br + ":" + this.parentOffset;
      }
    }], [{
      key: "resolve",
      value: function(Br, zr) {
        if (!(zr >= 0 && zr <= Br.content.size))
          throw new RangeError("Position " + zr + " out of range");
        for (var Xr = [], ai = 0, vi = zr, Ti = Br; ; ) {
          var Fi = Ti.content.findIndex(vi), ra = Fi.index, pa = Fi.offset, ca = vi - pa;
          if (Xr.push(Ti, ra, ai + pa), !ca || (Ti = Ti.child(ra), Ti.isText))
            break;
          vi = ca - 1, ai += pa + 1;
        }
        return new si(zr, Xr, vi);
      }
    }, {
      key: "resolveCached",
      value: function(Br, zr) {
        for (var Xr = 0; Xr < Ci.length; Xr++) {
          var ai = Ci[Xr];
          if (ai.pos == zr && ai.doc == Br)
            return ai;
        }
        var vi = Ci[Ki] = si.resolve(Br, zr);
        return Ki = (Ki + 1) % Ni, vi;
      }
    }]), si;
  }(), Ci = [], Ki = 0, Ni = 12, ia = function() {
    function si(Qr, Br, zr) {
      Ar(this, si), this.$from = Qr, this.$to = Br, this.depth = zr;
    }
    return Dr(si, [{
      key: "start",
      get: function() {
        return this.$from.before(this.depth + 1);
      }
    }, {
      key: "end",
      get: function() {
        return this.$to.after(this.depth + 1);
      }
    }, {
      key: "parent",
      get: function() {
        return this.$from.node(this.depth);
      }
    }, {
      key: "startIndex",
      get: function() {
        return this.$from.index(this.depth);
      }
    }, {
      key: "endIndex",
      get: function() {
        return this.$to.indexAfter(this.depth);
      }
    }]), si;
  }(), ea = /* @__PURE__ */ Object.create(null), la = function() {
    function si(Qr, Br, zr) {
      var Xr = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ci.none;
      Ar(this, si), this.type = Qr, this.attrs = Br, this.marks = Xr, this.content = zr || Jr.empty;
    }
    return Dr(si, [{
      key: "nodeSize",
      get: function() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.childCount;
      }
    }, {
      key: "child",
      value: function(Br) {
        return this.content.child(Br);
      }
    }, {
      key: "maybeChild",
      value: function(Br) {
        return this.content.maybeChild(Br);
      }
    }, {
      key: "forEach",
      value: function(Br) {
        this.content.forEach(Br);
      }
    }, {
      key: "nodesBetween",
      value: function(Br, zr, Xr) {
        var ai = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        this.content.nodesBetween(Br, zr, Xr, ai, this);
      }
    }, {
      key: "descendants",
      value: function(Br) {
        this.nodesBetween(0, this.content.size, Br);
      }
    }, {
      key: "textContent",
      get: function() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
    }, {
      key: "textBetween",
      value: function(Br, zr, Xr, ai) {
        return this.content.textBetween(Br, zr, Xr, ai);
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.firstChild;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.lastChild;
      }
    }, {
      key: "eq",
      value: function(Br) {
        return this == Br || this.sameMarkup(Br) && this.content.eq(Br.content);
      }
    }, {
      key: "sameMarkup",
      value: function(Br) {
        return this.hasMarkup(Br.type, Br.attrs, Br.marks);
      }
    }, {
      key: "hasMarkup",
      value: function(Br, zr, Xr) {
        return this.type == Br && Si(this.attrs, zr || Br.defaultAttrs || ea) && ci.sameSet(this.marks, Xr || ci.none);
      }
    }, {
      key: "copy",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return Br == this.content ? this : new si(this.type, this.attrs, Br, this.marks);
      }
    }, {
      key: "mark",
      value: function(Br) {
        return Br == this.marks ? this : new si(this.type, this.attrs, this.content, Br);
      }
    }, {
      key: "cut",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
        return Br == 0 && zr == this.content.size ? this : this.copy(this.content.cut(Br, zr));
      }
    }, {
      key: "slice",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size, Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (Br == zr)
          return Ei.empty;
        var ai = this.resolve(Br), vi = this.resolve(zr), Ti = Xr ? 0 : ai.sharedDepth(zr), Fi = ai.start(Ti), ra = ai.node(Ti), pa = ra.content.cut(ai.pos - Fi, vi.pos - Fi);
        return new Ei(pa, ai.depth - Ti, vi.depth - Ti);
      }
    }, {
      key: "replace",
      value: function(Br, zr, Xr) {
        return Li(this.resolve(Br), this.resolve(zr), Xr);
      }
    }, {
      key: "nodeAt",
      value: function(Br) {
        for (var zr = this; ; ) {
          var Xr = zr.content.findIndex(Br), ai = Xr.index, vi = Xr.offset;
          if (zr = zr.maybeChild(ai), !zr)
            return null;
          if (vi == Br || zr.isText)
            return zr;
          Br -= vi + 1;
        }
      }
    }, {
      key: "childAfter",
      value: function(Br) {
        var zr = this.content.findIndex(Br), Xr = zr.index, ai = zr.offset;
        return {
          node: this.content.maybeChild(Xr),
          index: Xr,
          offset: ai
        };
      }
    }, {
      key: "childBefore",
      value: function(Br) {
        if (Br == 0)
          return {
            node: null,
            index: 0,
            offset: 0
          };
        var zr = this.content.findIndex(Br), Xr = zr.index, ai = zr.offset;
        if (ai < Br)
          return {
            node: this.content.child(Xr),
            index: Xr,
            offset: ai
          };
        var vi = this.content.child(Xr - 1);
        return {
          node: vi,
          index: Xr - 1,
          offset: ai - vi.nodeSize
        };
      }
    }, {
      key: "resolve",
      value: function(Br) {
        return _i.resolveCached(this, Br);
      }
    }, {
      key: "resolveNoCache",
      value: function(Br) {
        return _i.resolve(this, Br);
      }
    }, {
      key: "rangeHasMark",
      value: function(Br, zr, Xr) {
        var ai = !1;
        return zr > Br && this.nodesBetween(Br, zr, function(vi) {
          return Xr.isInSet(vi.marks) && (ai = !0), !ai;
        }), ai;
      }
    }, {
      key: "isBlock",
      get: function() {
        return this.type.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.type.isTextblock;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.type.inlineContent;
      }
    }, {
      key: "isInline",
      get: function() {
        return this.type.isInline;
      }
    }, {
      key: "isText",
      get: function() {
        return this.type.isText;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.type.isLeaf;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.type.isAtom;
      }
    }, {
      key: "toString",
      value: function() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        var Br = this.type.name;
        return this.content.size && (Br += "(" + this.content.toStringInner() + ")"), Ba(this.marks, Br);
      }
    }, {
      key: "contentMatchAt",
      value: function(Br) {
        var zr = this.type.contentMatch.matchFragment(this.content, 0, Br);
        if (!zr)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return zr;
      }
    }, {
      key: "canReplace",
      value: function(Br, zr) {
        var Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Jr.empty, ai = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, vi = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Xr.childCount, Ti = this.contentMatchAt(Br).matchFragment(Xr, ai, vi), Fi = Ti && Ti.matchFragment(this.content, zr);
        if (!Fi || !Fi.validEnd)
          return !1;
        for (var ra = ai; ra < vi; ra++)
          if (!this.type.allowsMarks(Xr.child(ra).marks))
            return !1;
        return !0;
      }
    }, {
      key: "canReplaceWith",
      value: function(Br, zr, Xr, ai) {
        if (ai && !this.type.allowsMarks(ai))
          return !1;
        var vi = this.contentMatchAt(Br).matchType(Xr), Ti = vi && vi.matchFragment(this.content, zr);
        return Ti ? Ti.validEnd : !1;
      }
    }, {
      key: "canAppend",
      value: function(Br) {
        return Br.content.size ? this.canReplace(this.childCount, this.childCount, Br.content) : this.type.compatibleContent(Br.type);
      }
    }, {
      key: "check",
      value: function() {
        this.type.checkContent(this.content);
        for (var Br = ci.none, zr = 0; zr < this.marks.length; zr++)
          Br = this.marks[zr].addToSet(Br);
        if (!ci.sameSet(Br, this.marks))
          throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(Xr) {
            return Xr.type.name;
          })));
        this.content.forEach(function(Xr) {
          return Xr.check();
        });
      }
    }, {
      key: "toJSON",
      value: function() {
        var Br = {
          type: this.type.name
        };
        for (var zr in this.attrs) {
          Br.attrs = this.attrs;
          break;
        }
        return this.content.size && (Br.content = this.content.toJSON()), this.marks.length && (Br.marks = this.marks.map(function(Xr) {
          return Xr.toJSON();
        })), Br;
      }
    }], [{
      key: "fromJSON",
      value: function(Br, zr) {
        if (!zr)
          throw new RangeError("Invalid input for Node.fromJSON");
        var Xr = null;
        if (zr.marks) {
          if (!Array.isArray(zr.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          Xr = zr.marks.map(Br.markFromJSON);
        }
        if (zr.type == "text") {
          if (typeof zr.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return Br.text(zr.text, Xr);
        }
        var ai = Jr.fromJSON(Br, zr.content);
        return Br.nodeType(zr.type).create(zr.attrs, ai, Xr);
      }
    }]), si;
  }();
  la.prototype.text = void 0;
  var ma = function(si) {
    vr(Br, si);
    var Qr = mr(Br);
    function Br(zr, Xr, ai, vi) {
      var Ti;
      if (Ar(this, Br), Ti = Qr.call(this, zr, Xr, null, vi), !ai)
        throw new RangeError("Empty text nodes are not allowed");
      return Ti.text = ai, Ti;
    }
    return Dr(Br, [{
      key: "toString",
      value: function() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Ba(this.marks, JSON.stringify(this.text));
      }
    }, {
      key: "textContent",
      get: function() {
        return this.text;
      }
    }, {
      key: "textBetween",
      value: function(Xr, ai) {
        return this.text.slice(Xr, ai);
      }
    }, {
      key: "nodeSize",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "mark",
      value: function(Xr) {
        return Xr == this.marks ? this : new Br(this.type, this.attrs, this.text, Xr);
      }
    }, {
      key: "withText",
      value: function(Xr) {
        return Xr == this.text ? this : new Br(this.type, this.attrs, Xr, this.marks);
      }
    }, {
      key: "cut",
      value: function() {
        var Xr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, ai = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
        return Xr == 0 && ai == this.text.length ? this : this.withText(this.text.slice(Xr, ai));
      }
    }, {
      key: "eq",
      value: function(Xr) {
        return this.sameMarkup(Xr) && this.text == Xr.text;
      }
    }, {
      key: "toJSON",
      value: function() {
        var Xr = hr(Cr(Br.prototype), "toJSON", this).call(this);
        return Xr.text = this.text, Xr;
      }
    }]), Br;
  }(la);
  function Ba(si, Qr) {
    for (var Br = si.length - 1; Br >= 0; Br--)
      Qr = si[Br].type.name + "(" + Qr + ")";
    return Qr;
  }
  var Fa = function() {
    function si(Qr) {
      Ar(this, si), this.validEnd = Qr, this.next = [], this.wrapCache = [];
    }
    return Dr(si, [{
      key: "matchType",
      value: function(Br) {
        for (var zr = 0; zr < this.next.length; zr++)
          if (this.next[zr].type == Br)
            return this.next[zr].next;
        return null;
      }
    }, {
      key: "matchFragment",
      value: function(Br) {
        for (var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Br.childCount, ai = this, vi = zr; ai && vi < Xr; vi++)
          ai = ai.matchType(Br.child(vi).type);
        return ai;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
    }, {
      key: "defaultType",
      get: function() {
        for (var Br = 0; Br < this.next.length; Br++) {
          var zr = this.next[Br].type;
          if (!(zr.isText || zr.hasRequiredAttrs()))
            return zr;
        }
        return null;
      }
    }, {
      key: "compatible",
      value: function(Br) {
        for (var zr = 0; zr < this.next.length; zr++)
          for (var Xr = 0; Xr < Br.next.length; Xr++)
            if (this.next[zr].type == Br.next[Xr].type)
              return !0;
        return !1;
      }
    }, {
      key: "fillBefore",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ai = [this];
        function vi(Ti, Fi) {
          var ra = Ti.matchFragment(Br, Xr);
          if (ra && (!zr || ra.validEnd))
            return Jr.from(Fi.map(function(yo) {
              return yo.createAndFill();
            }));
          for (var pa = 0; pa < Ti.next.length; pa++) {
            var ca = Ti.next[pa], da = ca.type, qa = ca.next;
            if (!(da.isText || da.hasRequiredAttrs()) && ai.indexOf(qa) == -1) {
              ai.push(qa);
              var co = vi(qa, Fi.concat(da));
              if (co)
                return co;
            }
          }
          return null;
        }
        return vi(this, []);
      }
    }, {
      key: "findWrapping",
      value: function(Br) {
        for (var zr = 0; zr < this.wrapCache.length; zr += 2)
          if (this.wrapCache[zr] == Br)
            return this.wrapCache[zr + 1];
        var Xr = this.computeWrapping(Br);
        return this.wrapCache.push(Br, Xr), Xr;
      }
    }, {
      key: "computeWrapping",
      value: function(Br) {
        for (var zr = /* @__PURE__ */ Object.create(null), Xr = [{
          match: this,
          type: null,
          via: null
        }]; Xr.length; ) {
          var ai = Xr.shift(), vi = ai.match;
          if (vi.matchType(Br)) {
            for (var Ti = [], Fi = ai; Fi.type; Fi = Fi.via)
              Ti.push(Fi.type);
            return Ti.reverse();
          }
          for (var ra = 0; ra < vi.next.length; ra++) {
            var pa = vi.next[ra], ca = pa.type, da = pa.next;
            !ca.isLeaf && !ca.hasRequiredAttrs() && !(ca.name in zr) && (!ai.type || da.validEnd) && (Xr.push({
              match: ca.contentMatch,
              type: ca,
              via: ai
            }), zr[ca.name] = !0);
          }
        }
        return null;
      }
    }, {
      key: "edgeCount",
      get: function() {
        return this.next.length;
      }
    }, {
      key: "edge",
      value: function(Br) {
        if (Br >= this.next.length)
          throw new RangeError("There's no ".concat(Br, "th edge in this content match"));
        return this.next[Br];
      }
    }, {
      key: "toString",
      value: function() {
        var Br = [];
        function zr(Xr) {
          Br.push(Xr);
          for (var ai = 0; ai < Xr.next.length; ai++)
            Br.indexOf(Xr.next[ai].next) == -1 && zr(Xr.next[ai].next);
        }
        return zr(this), Br.map(function(Xr, ai) {
          for (var vi = ai + (Xr.validEnd ? "*" : " ") + " ", Ti = 0; Ti < Xr.next.length; Ti++)
            vi += (Ti ? ", " : "") + Xr.next[Ti].type.name + "->" + Br.indexOf(Xr.next[Ti].next);
          return vi;
        }).join(`
`);
      }
    }], [{
      key: "parse",
      value: function(Br, zr) {
        var Xr = new Ia(Br, zr);
        if (Xr.next == null)
          return si.empty;
        var ai = Hi(Xr);
        Xr.next && Xr.err("Unexpected trailing text");
        var vi = Oa(va(ai));
        return Xa(vi, Xr), vi;
      }
    }]), si;
  }();
  Fa.empty = new Fa(!0);
  var Ia = function() {
    function si(Qr, Br) {
      Ar(this, si), this.string = Qr, this.nodeTypes = Br, this.inline = null, this.pos = 0, this.tokens = Qr.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    return Dr(si, [{
      key: "next",
      get: function() {
        return this.tokens[this.pos];
      }
    }, {
      key: "eat",
      value: function(Br) {
        return this.next == Br && (this.pos++ || !0);
      }
    }, {
      key: "err",
      value: function(Br) {
        throw new SyntaxError(Br + " (in content expression '" + this.string + "')");
      }
    }]), si;
  }();
  function Hi(si) {
    var Qr = [];
    do
      Qr.push(oa(si));
    while (si.eat("|"));
    return Qr.length == 1 ? Qr[0] : {
      type: "choice",
      exprs: Qr
    };
  }
  function oa(si) {
    var Qr = [];
    do
      Qr.push(Gi(si));
    while (si.next && si.next != ")" && si.next != "|");
    return Qr.length == 1 ? Qr[0] : {
      type: "seq",
      exprs: Qr
    };
  }
  function Gi(si) {
    for (var Qr = ua(si); ; )
      if (si.eat("+"))
        Qr = {
          type: "plus",
          expr: Qr
        };
      else if (si.eat("*"))
        Qr = {
          type: "star",
          expr: Qr
        };
      else if (si.eat("?"))
        Qr = {
          type: "opt",
          expr: Qr
        };
      else if (si.eat("{"))
        Qr = Ua(si, Qr);
      else
        break;
    return Qr;
  }
  function ha(si) {
    /\D/.test(si.next) && si.err("Expected number, got '" + si.next + "'");
    var Qr = Number(si.next);
    return si.pos++, Qr;
  }
  function Ua(si, Qr) {
    var Br = ha(si), zr = Br;
    return si.eat(",") && (si.next != "}" ? zr = ha(si) : zr = -1), si.eat("}") || si.err("Unclosed braced range"), {
      type: "range",
      min: Br,
      max: zr,
      expr: Qr
    };
  }
  function eo(si, Qr) {
    var Br = si.nodeTypes, zr = Br[Qr];
    if (zr)
      return [zr];
    var Xr = [];
    for (var ai in Br) {
      var vi = Br[ai];
      vi.groups.indexOf(Qr) > -1 && Xr.push(vi);
    }
    return Xr.length == 0 && si.err("No node type or group '" + Qr + "' found"), Xr;
  }
  function ua(si) {
    if (si.eat("(")) {
      var Qr = Hi(si);
      return si.eat(")") || si.err("Missing closing paren"), Qr;
    } else if (/\W/.test(si.next))
      si.err("Unexpected token '" + si.next + "'");
    else {
      var Br = eo(si, si.next).map(function(zr) {
        return si.inline == null ? si.inline = zr.isInline : si.inline != zr.isInline && si.err("Mixing inline and block content"), {
          type: "name",
          value: zr
        };
      });
      return si.pos++, Br.length == 1 ? Br[0] : {
        type: "choice",
        exprs: Br
      };
    }
  }
  function va(si) {
    var Qr = [[]];
    return Xr(ai(si, 0), Br()), Qr;
    function Br() {
      return Qr.push([]) - 1;
    }
    function zr(vi, Ti, Fi) {
      var ra = {
        term: Fi,
        to: Ti
      };
      return Qr[vi].push(ra), ra;
    }
    function Xr(vi, Ti) {
      vi.forEach(function(Fi) {
        return Fi.to = Ti;
      });
    }
    function ai(vi, Ti) {
      if (vi.type == "choice")
        return vi.exprs.reduce(function(Oo, Do) {
          return Oo.concat(ai(Do, Ti));
        }, []);
      if (vi.type == "seq")
        for (var Fi = 0; ; Fi++) {
          var ra = ai(vi.exprs[Fi], Ti);
          if (Fi == vi.exprs.length - 1)
            return ra;
          Xr(ra, Ti = Br());
        }
      else if (vi.type == "star") {
        var pa = Br();
        return zr(Ti, pa), Xr(ai(vi.expr, pa), pa), [zr(pa)];
      } else if (vi.type == "plus") {
        var ca = Br();
        return Xr(ai(vi.expr, Ti), ca), Xr(ai(vi.expr, ca), ca), [zr(ca)];
      } else {
        if (vi.type == "opt")
          return [zr(Ti)].concat(ai(vi.expr, Ti));
        if (vi.type == "range") {
          for (var da = Ti, qa = 0; qa < vi.min; qa++) {
            var co = Br();
            Xr(ai(vi.expr, da), co), da = co;
          }
          if (vi.max == -1)
            Xr(ai(vi.expr, da), da);
          else
            for (var yo = vi.min; yo < vi.max; yo++) {
              var Mo = Br();
              zr(da, Mo), Xr(ai(vi.expr, da), Mo), da = Mo;
            }
          return [zr(da)];
        } else {
          if (vi.type == "name")
            return [zr(Ti, void 0, vi.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function Ta(si, Qr) {
    return Qr - si;
  }
  function Aa(si, Qr) {
    var Br = [];
    return zr(Qr), Br.sort(Ta);
    function zr(Xr) {
      var ai = si[Xr];
      if (ai.length == 1 && !ai[0].term)
        return zr(ai[0].to);
      Br.push(Xr);
      for (var vi = 0; vi < ai.length; vi++) {
        var Ti = ai[vi], Fi = Ti.term, ra = Ti.to;
        !Fi && Br.indexOf(ra) == -1 && zr(ra);
      }
    }
  }
  function Oa(si) {
    var Qr = /* @__PURE__ */ Object.create(null);
    return Br(Aa(si, 0));
    function Br(zr) {
      var Xr = [];
      zr.forEach(function(Fi) {
        si[Fi].forEach(function(ra) {
          var pa = ra.term, ca = ra.to;
          if (pa) {
            for (var da, qa = 0; qa < Xr.length; qa++)
              Xr[qa][0] == pa && (da = Xr[qa][1]);
            Aa(si, ca).forEach(function(co) {
              da || Xr.push([pa, da = []]), da.indexOf(co) == -1 && da.push(co);
            });
          }
        });
      });
      for (var ai = Qr[zr.join(",")] = new Fa(zr.indexOf(si.length - 1) > -1), vi = 0; vi < Xr.length; vi++) {
        var Ti = Xr[vi][1].sort(Ta);
        ai.next.push({
          type: Xr[vi][0],
          next: Qr[Ti.join(",")] || Br(Ti)
        });
      }
      return ai;
    }
  }
  function Xa(si, Qr) {
    for (var Br = 0, zr = [si]; Br < zr.length; Br++) {
      for (var Xr = zr[Br], ai = !Xr.validEnd, vi = [], Ti = 0; Ti < Xr.next.length; Ti++) {
        var Fi = Xr.next[Ti], ra = Fi.type, pa = Fi.next;
        vi.push(ra.name), ai && !(ra.isText || ra.hasRequiredAttrs()) && (ai = !1), zr.indexOf(pa) == -1 && zr.push(pa);
      }
      ai && Qr.err("Only non-generatable nodes (" + vi.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function Ka(si) {
    var Qr = /* @__PURE__ */ Object.create(null);
    for (var Br in si) {
      var zr = si[Br];
      if (!zr.hasDefault)
        return null;
      Qr[Br] = zr.default;
    }
    return Qr;
  }
  function Pa(si, Qr) {
    var Br = /* @__PURE__ */ Object.create(null);
    for (var zr in si) {
      var Xr = Qr && Qr[zr];
      if (Xr === void 0) {
        var ai = si[zr];
        if (ai.hasDefault)
          Xr = ai.default;
        else
          throw new RangeError("No value supplied for attribute " + zr);
      }
      Br[zr] = Xr;
    }
    return Br;
  }
  function Da(si) {
    var Qr = /* @__PURE__ */ Object.create(null);
    if (si)
      for (var Br in si)
        Qr[Br] = new $a(si[Br]);
    return Qr;
  }
  var Ha = function() {
    function si(Qr, Br, zr) {
      Ar(this, si), this.name = Qr, this.schema = Br, this.spec = zr, this.markSet = null, this.groups = zr.group ? zr.group.split(" ") : [], this.attrs = Da(zr.attrs), this.defaultAttrs = Ka(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(zr.inline || Qr == "text"), this.isText = Qr == "text";
    }
    return Dr(si, [{
      key: "isInline",
      get: function() {
        return !this.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.isBlock && this.inlineContent;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.contentMatch == Fa.empty;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.isLeaf || !!this.spec.atom;
      }
    }, {
      key: "whitespace",
      get: function() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
    }, {
      key: "hasRequiredAttrs",
      value: function() {
        for (var Br in this.attrs)
          if (this.attrs[Br].isRequired)
            return !0;
        return !1;
      }
    }, {
      key: "compatibleContent",
      value: function(Br) {
        return this == Br || this.contentMatch.compatible(Br.contentMatch);
      }
    }, {
      key: "computeAttrs",
      value: function(Br) {
        return !Br && this.defaultAttrs ? this.defaultAttrs : Pa(this.attrs, Br);
      }
    }, {
      key: "create",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, zr = arguments.length > 1 ? arguments[1] : void 0, Xr = arguments.length > 2 ? arguments[2] : void 0;
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new la(this, this.computeAttrs(Br), Jr.from(zr), ci.setFrom(Xr));
      }
    }, {
      key: "createChecked",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, zr = arguments.length > 1 ? arguments[1] : void 0, Xr = arguments.length > 2 ? arguments[2] : void 0;
        return zr = Jr.from(zr), this.checkContent(zr), new la(this, this.computeAttrs(Br), zr, ci.setFrom(Xr));
      }
    }, {
      key: "createAndFill",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, zr = arguments.length > 1 ? arguments[1] : void 0, Xr = arguments.length > 2 ? arguments[2] : void 0;
        if (Br = this.computeAttrs(Br), zr = Jr.from(zr), zr.size) {
          var ai = this.contentMatch.fillBefore(zr);
          if (!ai)
            return null;
          zr = ai.append(zr);
        }
        var vi = this.contentMatch.matchFragment(zr), Ti = vi && vi.fillBefore(Jr.empty, !0);
        return Ti ? new la(this, Br, zr.append(Ti), ci.setFrom(Xr)) : null;
      }
    }, {
      key: "validContent",
      value: function(Br) {
        var zr = this.contentMatch.matchFragment(Br);
        if (!zr || !zr.validEnd)
          return !1;
        for (var Xr = 0; Xr < Br.childCount; Xr++)
          if (!this.allowsMarks(Br.child(Xr).marks))
            return !1;
        return !0;
      }
    }, {
      key: "checkContent",
      value: function(Br) {
        if (!this.validContent(Br))
          throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(Br.toString().slice(0, 50)));
      }
    }, {
      key: "allowsMarkType",
      value: function(Br) {
        return this.markSet == null || this.markSet.indexOf(Br) > -1;
      }
    }, {
      key: "allowsMarks",
      value: function(Br) {
        if (this.markSet == null)
          return !0;
        for (var zr = 0; zr < Br.length; zr++)
          if (!this.allowsMarkType(Br[zr].type))
            return !1;
        return !0;
      }
    }, {
      key: "allowedMarks",
      value: function(Br) {
        if (this.markSet == null)
          return Br;
        for (var zr, Xr = 0; Xr < Br.length; Xr++)
          this.allowsMarkType(Br[Xr].type) ? zr && zr.push(Br[Xr]) : zr || (zr = Br.slice(0, Xr));
        return zr ? zr.length ? zr : ci.none : Br;
      }
    }], [{
      key: "compile",
      value: function(Br, zr) {
        var Xr = /* @__PURE__ */ Object.create(null);
        Br.forEach(function(Ti, Fi) {
          return Xr[Ti] = new si(Ti, zr, Fi);
        });
        var ai = zr.spec.topNode || "doc";
        if (!Xr[ai])
          throw new RangeError("Schema is missing its top node type ('" + ai + "')");
        if (!Xr.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (var vi in Xr.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return Xr;
      }
    }]), si;
  }(), $a = function() {
    function si(Qr) {
      Ar(this, si), this.hasDefault = Object.prototype.hasOwnProperty.call(Qr, "default"), this.default = Qr.default;
    }
    return Dr(si, [{
      key: "isRequired",
      get: function() {
        return !this.hasDefault;
      }
    }]), si;
  }(), Yi = function() {
    function si(Qr, Br, zr, Xr) {
      Ar(this, si), this.name = Qr, this.rank = Br, this.schema = zr, this.spec = Xr, this.attrs = Da(Xr.attrs), this.excluded = null;
      var ai = Ka(this.attrs);
      this.instance = ai ? new ci(this, ai) : null;
    }
    return Dr(si, [{
      key: "create",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return !Br && this.instance ? this.instance : new ci(this, Pa(this.attrs, Br));
      }
    }, {
      key: "removeFromSet",
      value: function(Br) {
        for (var zr = 0; zr < Br.length; zr++)
          Br[zr].type == this && (Br = Br.slice(0, zr).concat(Br.slice(zr + 1)), zr--);
        return Br;
      }
    }, {
      key: "isInSet",
      value: function(Br) {
        for (var zr = 0; zr < Br.length; zr++)
          if (Br[zr].type == this)
            return Br[zr];
      }
    }, {
      key: "excludes",
      value: function(Br) {
        return this.excluded.indexOf(Br) > -1;
      }
    }], [{
      key: "compile",
      value: function(Br, zr) {
        var Xr = /* @__PURE__ */ Object.create(null), ai = 0;
        return Br.forEach(function(vi, Ti) {
          return Xr[vi] = new si(vi, ai++, zr, Ti);
        }), Xr;
      }
    }]), si;
  }(), Zi = function() {
    function si(Qr) {
      Ar(this, si), this.cached = /* @__PURE__ */ Object.create(null);
      var Br = this.spec = {};
      for (var zr in Qr)
        Br[zr] = Qr[zr];
      Br.nodes = Wr.default.from(Qr.nodes), Br.marks = Wr.default.from(Qr.marks || {}), this.nodes = Ha.compile(this.spec.nodes, this), this.marks = Yi.compile(this.spec.marks, this);
      var Xr = /* @__PURE__ */ Object.create(null);
      for (var ai in this.nodes) {
        if (ai in this.marks)
          throw new RangeError(ai + " can not be both a node and a mark");
        var vi = this.nodes[ai], Ti = vi.spec.content || "", Fi = vi.spec.marks;
        vi.contentMatch = Xr[Ti] || (Xr[Ti] = Fa.parse(Ti, this.nodes)), vi.inlineContent = vi.contentMatch.inlineContent, vi.markSet = Fi == "_" ? null : Fi ? ka(this, Fi.split(" ")) : Fi == "" || !vi.inlineContent ? [] : null;
      }
      for (var ra in this.marks) {
        var pa = this.marks[ra], ca = pa.spec.excludes;
        pa.excluded = ca == null ? [pa] : ca == "" ? [] : ka(this, ca.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    return Dr(si, [{
      key: "node",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Xr = arguments.length > 2 ? arguments[2] : void 0, ai = arguments.length > 3 ? arguments[3] : void 0;
        if (typeof Br == "string")
          Br = this.nodeType(Br);
        else if (Br instanceof Ha) {
          if (Br.schema != this)
            throw new RangeError("Node type from different schema used (" + Br.name + ")");
        } else
          throw new RangeError("Invalid node type: " + Br);
        return Br.createChecked(zr, Xr, ai);
      }
    }, {
      key: "text",
      value: function(Br, zr) {
        var Xr = this.nodes.text;
        return new ma(Xr, Xr.defaultAttrs, Br, ci.setFrom(zr));
      }
    }, {
      key: "mark",
      value: function(Br, zr) {
        return typeof Br == "string" && (Br = this.marks[Br]), Br.create(zr);
      }
    }, {
      key: "nodeFromJSON",
      value: function(Br) {
        return la.fromJSON(this, Br);
      }
    }, {
      key: "markFromJSON",
      value: function(Br) {
        return ci.fromJSON(this, Br);
      }
    }, {
      key: "nodeType",
      value: function(Br) {
        var zr = this.nodes[Br];
        if (!zr)
          throw new RangeError("Unknown node type: " + Br);
        return zr;
      }
    }]), si;
  }();
  function ka(si, Qr) {
    for (var Br = [], zr = 0; zr < Qr.length; zr++) {
      var Xr = Qr[zr], ai = si.marks[Xr], vi = ai;
      if (ai)
        Br.push(ai);
      else
        for (var Ti in si.marks) {
          var Fi = si.marks[Ti];
          (Xr == "_" || Fi.spec.group && Fi.spec.group.split(" ").indexOf(Xr) > -1) && Br.push(vi = Fi);
        }
      if (!vi)
        throw new SyntaxError("Unknown mark type: '" + Qr[zr] + "'");
    }
    return Br;
  }
  var zi = function() {
    function si(Qr, Br) {
      var zr = this;
      Ar(this, si), this.schema = Qr, this.rules = Br, this.tags = [], this.styles = [], Br.forEach(function(Xr) {
        Xr.tag ? zr.tags.push(Xr) : Xr.style && zr.styles.push(Xr);
      }), this.normalizeLists = !this.tags.some(function(Xr) {
        if (!/^(ul|ol)\b/.test(Xr.tag) || !Xr.node)
          return !1;
        var ai = Qr.nodes[Xr.node];
        return ai.contentMatch.matchType(ai);
      });
    }
    return Dr(si, [{
      key: "parse",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Xr = new to(this, zr, !1);
        return Xr.addAll(Br, zr.from, zr.to), Xr.finish();
      }
    }, {
      key: "parseSlice",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Xr = new to(this, zr, !0);
        return Xr.addAll(Br, zr.from, zr.to), Ei.maxOpen(Xr.finish());
      }
    }, {
      key: "matchTag",
      value: function(Br, zr, Xr) {
        for (var ai = Xr ? this.tags.indexOf(Xr) + 1 : 0; ai < this.tags.length; ai++) {
          var vi = this.tags[ai];
          if (uo(Br, vi.tag) && (vi.namespace === void 0 || Br.namespaceURI == vi.namespace) && (!vi.context || zr.matchesContext(vi.context))) {
            if (vi.getAttrs) {
              var Ti = vi.getAttrs(Br);
              if (Ti === !1)
                continue;
              vi.attrs = Ti || void 0;
            }
            return vi;
          }
        }
      }
    }, {
      key: "matchStyle",
      value: function(Br, zr, Xr, ai) {
        for (var vi = ai ? this.styles.indexOf(ai) + 1 : 0; vi < this.styles.length; vi++) {
          var Ti = this.styles[vi], Fi = Ti.style;
          if (!(Fi.indexOf(Br) != 0 || Ti.context && !Xr.matchesContext(Ti.context) || Fi.length > Br.length && (Fi.charCodeAt(Br.length) != 61 || Fi.slice(Br.length + 1) != zr))) {
            if (Ti.getAttrs) {
              var ra = Ti.getAttrs(zr);
              if (ra === !1)
                continue;
              Ti.attrs = ra || void 0;
            }
            return Ti;
          }
        }
      }
    }], [{
      key: "schemaRules",
      value: function(Br) {
        var zr = [];
        function Xr(ra) {
          for (var pa = ra.priority == null ? 50 : ra.priority, ca = 0; ca < zr.length; ca++) {
            var da = zr[ca], qa = da.priority == null ? 50 : da.priority;
            if (qa < pa)
              break;
          }
          zr.splice(ca, 0, ra);
        }
        var ai = function(pa) {
          var ca = Br.marks[pa].spec.parseDOM;
          ca && ca.forEach(function(da) {
            Xr(da = Lo(da)), da.mark || da.ignore || da.clearMark || (da.mark = pa);
          });
        };
        for (var vi in Br.marks)
          ai(vi);
        var Ti = function(pa) {
          var ca = Br.nodes[pa].spec.parseDOM;
          ca && ca.forEach(function(da) {
            Xr(da = Lo(da)), da.node || da.ignore || da.mark || (da.node = pa);
          });
        };
        for (var Fi in Br.nodes)
          Ti(Fi);
        return zr;
      }
    }, {
      key: "fromSchema",
      value: function(Br) {
        return Br.cached.domParser || (Br.cached.domParser = new si(Br, si.schemaRules(Br)));
      }
    }]), si;
  }(), Ji = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  }, za = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
  }, Va = {
    ol: !0,
    ul: !0
  }, Ca = 1, ja = 2, ao = 4;
  function Wa(si, Qr, Br) {
    return Qr != null ? (Qr ? Ca : 0) | (Qr === "full" ? ja : 0) : si && si.whitespace == "pre" ? Ca | ja : Br & ~ao;
  }
  var po = function() {
    function si(Qr, Br, zr, Xr, ai, vi, Ti) {
      Ar(this, si), this.type = Qr, this.attrs = Br, this.marks = zr, this.pendingMarks = Xr, this.solid = ai, this.options = Ti, this.content = [], this.activeMarks = ci.none, this.stashMarks = [], this.match = vi || (Ti & ao ? null : Qr.contentMatch);
    }
    return Dr(si, [{
      key: "findWrapping",
      value: function(Br) {
        if (!this.match) {
          if (!this.type)
            return [];
          var zr = this.type.contentMatch.fillBefore(Jr.from(Br));
          if (zr)
            this.match = this.type.contentMatch.matchFragment(zr);
          else {
            var Xr = this.type.contentMatch, ai;
            return (ai = Xr.findWrapping(Br.type)) ? (this.match = Xr, ai) : null;
          }
        }
        return this.match.findWrapping(Br.type);
      }
    }, {
      key: "finish",
      value: function(Br) {
        if (!(this.options & Ca)) {
          var zr = this.content[this.content.length - 1], Xr;
          if (zr && zr.isText && (Xr = /[ \t\r\n\u000c]+$/.exec(zr.text))) {
            var ai = zr;
            zr.text.length == Xr[0].length ? this.content.pop() : this.content[this.content.length - 1] = ai.withText(ai.text.slice(0, ai.text.length - Xr[0].length));
          }
        }
        var vi = Jr.from(this.content);
        return !Br && this.match && (vi = vi.append(this.match.fillBefore(Jr.empty, !0))), this.type ? this.type.create(this.attrs, vi, this.marks) : vi;
      }
    }, {
      key: "popFromStashMark",
      value: function(Br) {
        for (var zr = this.stashMarks.length - 1; zr >= 0; zr--)
          if (Br.eq(this.stashMarks[zr]))
            return this.stashMarks.splice(zr, 1)[0];
      }
    }, {
      key: "applyPending",
      value: function(Br) {
        for (var zr = 0, Xr = this.pendingMarks; zr < Xr.length; zr++) {
          var ai = Xr[zr];
          (this.type ? this.type.allowsMarkType(ai.type) : Eo(ai.type, Br)) && !ai.isInSet(this.activeMarks) && (this.activeMarks = ai.addToSet(this.activeMarks), this.pendingMarks = ai.removeFromSet(this.pendingMarks));
        }
      }
    }, {
      key: "inlineContext",
      value: function(Br) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : Br.parentNode && !Ji.hasOwnProperty(Br.parentNode.nodeName.toLowerCase());
      }
    }]), si;
  }(), to = function() {
    function si(Qr, Br, zr) {
      Ar(this, si), this.parser = Qr, this.options = Br, this.isOpen = zr, this.open = 0;
      var Xr = Br.topNode, ai, vi = Wa(null, Br.preserveWhitespace, 0) | (zr ? ao : 0);
      Xr ? ai = new po(Xr.type, Xr.attrs, ci.none, ci.none, !0, Br.topMatch || Xr.type.contentMatch, vi) : zr ? ai = new po(null, null, ci.none, ci.none, !0, null, vi) : ai = new po(Qr.schema.topNodeType, null, ci.none, ci.none, !0, null, vi), this.nodes = [ai], this.find = Br.findPositions, this.needsBlock = !1;
    }
    return Dr(si, [{
      key: "top",
      get: function() {
        return this.nodes[this.open];
      }
    }, {
      key: "addDOM",
      value: function(Br) {
        Br.nodeType == 3 ? this.addTextNode(Br) : Br.nodeType == 1 && this.addElement(Br);
      }
    }, {
      key: "withStyleRules",
      value: function(Br, zr) {
        var Xr = Br.getAttribute("style");
        if (!Xr)
          return zr();
        var ai = this.readStyles(Io(Xr));
        if (ai) {
          for (var vi = lr(ai, 2), Ti = vi[0], Fi = vi[1], ra = this.top, pa = 0; pa < Fi.length; pa++)
            this.removePendingMark(Fi[pa], ra);
          for (var ca = 0; ca < Ti.length; ca++)
            this.addPendingMark(Ti[ca]);
          zr();
          for (var da = 0; da < Ti.length; da++)
            this.removePendingMark(Ti[da], ra);
          for (var qa = 0; qa < Fi.length; qa++)
            this.addPendingMark(Fi[qa]);
        }
      }
    }, {
      key: "addTextNode",
      value: function(Br) {
        var zr = Br.nodeValue, Xr = this.top;
        if (Xr.options & ja || Xr.inlineContext(Br) || /[^ \t\r\n\u000c]/.test(zr)) {
          if (Xr.options & Ca)
            Xr.options & ja ? zr = zr.replace(/\r\n?/g, `
`) : zr = zr.replace(/\r?\n|\r/g, " ");
          else if (zr = zr.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(zr) && this.open == this.nodes.length - 1) {
            var ai = Xr.content[Xr.content.length - 1], vi = Br.previousSibling;
            (!ai || vi && vi.nodeName == "BR" || ai.isText && /[ \t\r\n\u000c]$/.test(ai.text)) && (zr = zr.slice(1));
          }
          zr && this.insertNode(this.parser.schema.text(zr)), this.findInText(Br);
        } else
          this.findInside(Br);
      }
    }, {
      key: "addElement",
      value: function(Br, zr) {
        var Xr = this, ai = Br.nodeName.toLowerCase(), vi;
        Va.hasOwnProperty(ai) && this.parser.normalizeLists && oo(Br);
        var Ti = this.options.ruleFromNode && this.options.ruleFromNode(Br) || (vi = this.parser.matchTag(Br, this, zr));
        if (Ti ? Ti.ignore : za.hasOwnProperty(ai))
          this.findInside(Br), this.ignoreFallback(Br);
        else if (!Ti || Ti.skip || Ti.closeParent) {
          Ti && Ti.closeParent ? this.open = Math.max(0, this.open - 1) : Ti && Ti.skip.nodeType && (Br = Ti.skip);
          var Fi, ra = this.top, pa = this.needsBlock;
          if (Ji.hasOwnProperty(ai))
            ra.content.length && ra.content[0].isInline && this.open && (this.open--, ra = this.top), Fi = !0, ra.type || (this.needsBlock = !0);
          else if (!Br.firstChild) {
            this.leafFallback(Br);
            return;
          }
          Ti && Ti.skip ? this.addAll(Br) : this.withStyleRules(Br, function() {
            return Xr.addAll(Br);
          }), Fi && this.sync(ra), this.needsBlock = pa;
        } else
          this.withStyleRules(Br, function() {
            Xr.addElementByRule(Br, Ti, Ti.consuming === !1 ? vi : void 0);
          });
      }
    }, {
      key: "leafFallback",
      value: function(Br) {
        Br.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(Br.ownerDocument.createTextNode(`
`));
      }
    }, {
      key: "ignoreFallback",
      value: function(Br) {
        Br.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
      }
    }, {
      key: "readStyles",
      value: function(Br) {
        for (var zr = this, Xr = ci.none, ai = ci.none, vi = 0; vi < Br.length; vi += 2)
          for (var Ti = function(ca) {
            var da = zr.parser.matchStyle(Br[vi], Br[vi + 1], zr, ca);
            if (!da)
              return Fi = ca, "break";
            if (da.ignore)
              return Fi = ca, {
                v: null
              };
            if (da.clearMark ? zr.top.pendingMarks.concat(zr.top.activeMarks).forEach(function(qa) {
              da.clearMark(qa) && (ai = qa.addToSet(ai));
            }) : Xr = zr.parser.schema.marks[da.mark].create(da.attrs).addToSet(Xr), da.consuming === !1)
              ca = da;
            else
              return Fi = ca, "break";
            Fi = ca;
          }, Fi = void 0; ; ) {
            var ra = Ti(Fi);
            if (ra === "break")
              break;
            if (Nr(ra) === "object")
              return ra.v;
          }
        return [Xr, ai];
      }
    }, {
      key: "addElementByRule",
      value: function(Br, zr, Xr) {
        var ai = this, vi, Ti, Fi;
        if (zr.node)
          Ti = this.parser.schema.nodes[zr.node], Ti.isLeaf ? this.insertNode(Ti.create(zr.attrs)) || this.leafFallback(Br) : vi = this.enter(Ti, zr.attrs || null, zr.preserveWhitespace);
        else {
          var ra = this.parser.schema.marks[zr.mark];
          Fi = ra.create(zr.attrs), this.addPendingMark(Fi);
        }
        var pa = this.top;
        if (Ti && Ti.isLeaf)
          this.findInside(Br);
        else if (Xr)
          this.addElement(Br, Xr);
        else if (zr.getContent)
          this.findInside(Br), zr.getContent(Br, this.parser.schema).forEach(function(da) {
            return ai.insertNode(da);
          });
        else {
          var ca = Br;
          typeof zr.contentElement == "string" ? ca = Br.querySelector(zr.contentElement) : typeof zr.contentElement == "function" ? ca = zr.contentElement(Br) : zr.contentElement && (ca = zr.contentElement), this.findAround(Br, ca, !0), this.addAll(ca);
        }
        vi && this.sync(pa) && this.open--, Fi && this.removePendingMark(Fi, pa);
      }
    }, {
      key: "addAll",
      value: function(Br, zr, Xr) {
        for (var ai = zr || 0, vi = zr ? Br.childNodes[zr] : Br.firstChild, Ti = Xr == null ? null : Br.childNodes[Xr]; vi != Ti; vi = vi.nextSibling, ++ai)
          this.findAtPoint(Br, ai), this.addDOM(vi);
        this.findAtPoint(Br, ai);
      }
    }, {
      key: "findPlace",
      value: function(Br) {
        for (var zr, Xr, ai = this.open; ai >= 0; ai--) {
          var vi = this.nodes[ai], Ti = vi.findWrapping(Br);
          if (Ti && (!zr || zr.length > Ti.length) && (zr = Ti, Xr = vi, !Ti.length) || vi.solid)
            break;
        }
        if (!zr)
          return !1;
        this.sync(Xr);
        for (var Fi = 0; Fi < zr.length; Fi++)
          this.enterInner(zr[Fi], null, !1);
        return !0;
      }
    }, {
      key: "insertNode",
      value: function(Br) {
        if (Br.isInline && this.needsBlock && !this.top.type) {
          var zr = this.textblockFromContext();
          zr && this.enterInner(zr);
        }
        if (this.findPlace(Br)) {
          this.closeExtra();
          var Xr = this.top;
          Xr.applyPending(Br.type), Xr.match && (Xr.match = Xr.match.matchType(Br.type));
          for (var ai = Xr.activeMarks, vi = 0; vi < Br.marks.length; vi++)
            (!Xr.type || Xr.type.allowsMarkType(Br.marks[vi].type)) && (ai = Br.marks[vi].addToSet(ai));
          return Xr.content.push(Br.mark(ai)), !0;
        }
        return !1;
      }
    }, {
      key: "enter",
      value: function(Br, zr, Xr) {
        var ai = this.findPlace(Br.create(zr));
        return ai && this.enterInner(Br, zr, !0, Xr), ai;
      }
    }, {
      key: "enterInner",
      value: function(Br) {
        var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, ai = arguments.length > 3 ? arguments[3] : void 0;
        this.closeExtra();
        var vi = this.top;
        vi.applyPending(Br), vi.match = vi.match && vi.match.matchType(Br);
        var Ti = Wa(Br, ai, vi.options);
        vi.options & ao && vi.content.length == 0 && (Ti |= ao), this.nodes.push(new po(Br, zr, vi.activeMarks, vi.pendingMarks, Xr, null, Ti)), this.open++;
      }
    }, {
      key: "closeExtra",
      value: function() {
        var Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, zr = this.nodes.length - 1;
        if (zr > this.open) {
          for (; zr > this.open; zr--)
            this.nodes[zr - 1].content.push(this.nodes[zr].finish(Br));
          this.nodes.length = this.open + 1;
        }
      }
    }, {
      key: "finish",
      value: function() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
      }
    }, {
      key: "sync",
      value: function(Br) {
        for (var zr = this.open; zr >= 0; zr--)
          if (this.nodes[zr] == Br)
            return this.open = zr, !0;
        return !1;
      }
    }, {
      key: "currentPos",
      get: function() {
        this.closeExtra();
        for (var Br = 0, zr = this.open; zr >= 0; zr--) {
          for (var Xr = this.nodes[zr].content, ai = Xr.length - 1; ai >= 0; ai--)
            Br += Xr[ai].nodeSize;
          zr && Br++;
        }
        return Br;
      }
    }, {
      key: "findAtPoint",
      value: function(Br, zr) {
        if (this.find)
          for (var Xr = 0; Xr < this.find.length; Xr++)
            this.find[Xr].node == Br && this.find[Xr].offset == zr && (this.find[Xr].pos = this.currentPos);
      }
    }, {
      key: "findInside",
      value: function(Br) {
        if (this.find)
          for (var zr = 0; zr < this.find.length; zr++)
            this.find[zr].pos == null && Br.nodeType == 1 && Br.contains(this.find[zr].node) && (this.find[zr].pos = this.currentPos);
      }
    }, {
      key: "findAround",
      value: function(Br, zr, Xr) {
        if (Br != zr && this.find) {
          for (var ai = 0; ai < this.find.length; ai++)
            if (this.find[ai].pos == null && Br.nodeType == 1 && Br.contains(this.find[ai].node)) {
              var vi = zr.compareDocumentPosition(this.find[ai].node);
              vi & (Xr ? 2 : 4) && (this.find[ai].pos = this.currentPos);
            }
        }
      }
    }, {
      key: "findInText",
      value: function(Br) {
        if (this.find)
          for (var zr = 0; zr < this.find.length; zr++)
            this.find[zr].node == Br && (this.find[zr].pos = this.currentPos - (Br.nodeValue.length - this.find[zr].offset));
      }
    }, {
      key: "matchesContext",
      value: function(Br) {
        var zr = this;
        if (Br.indexOf("|") > -1)
          return Br.split(/\s*\|\s*/).some(this.matchesContext, this);
        var Xr = Br.split("/"), ai = this.options.context, vi = !this.isOpen && (!ai || ai.parent.type == this.nodes[0].type), Ti = -(ai ? ai.depth + 1 : 0) + (vi ? 0 : 1), Fi = function ra(pa, ca) {
          for (; pa >= 0; pa--) {
            var da = Xr[pa];
            if (da == "") {
              if (pa == Xr.length - 1 || pa == 0)
                continue;
              for (; ca >= Ti; ca--)
                if (ra(pa - 1, ca))
                  return !0;
              return !1;
            } else {
              var qa = ca > 0 || ca == 0 && vi ? zr.nodes[ca].type : ai && ca >= Ti ? ai.node(ca - Ti).type : null;
              if (!qa || qa.name != da && qa.groups.indexOf(da) == -1)
                return !1;
              ca--;
            }
          }
          return !0;
        };
        return Fi(Xr.length - 1, this.open);
      }
    }, {
      key: "textblockFromContext",
      value: function() {
        var Br = this.options.context;
        if (Br)
          for (var zr = Br.depth; zr >= 0; zr--) {
            var Xr = Br.node(zr).contentMatchAt(Br.indexAfter(zr)).defaultType;
            if (Xr && Xr.isTextblock && Xr.defaultAttrs)
              return Xr;
          }
        for (var ai in this.parser.schema.nodes) {
          var vi = this.parser.schema.nodes[ai];
          if (vi.isTextblock && vi.defaultAttrs)
            return vi;
        }
      }
    }, {
      key: "addPendingMark",
      value: function(Br) {
        var zr = lo(Br, this.top.pendingMarks);
        zr && this.top.stashMarks.push(zr), this.top.pendingMarks = Br.addToSet(this.top.pendingMarks);
      }
    }, {
      key: "removePendingMark",
      value: function(Br, zr) {
        for (var Xr = this.open; Xr >= 0; Xr--) {
          var ai = this.nodes[Xr], vi = ai.pendingMarks.lastIndexOf(Br);
          if (vi > -1)
            ai.pendingMarks = Br.removeFromSet(ai.pendingMarks);
          else {
            ai.activeMarks = Br.removeFromSet(ai.activeMarks);
            var Ti = ai.popFromStashMark(Br);
            Ti && ai.type && ai.type.allowsMarkType(Ti.type) && (ai.activeMarks = Ti.addToSet(ai.activeMarks));
          }
          if (ai == zr)
            break;
        }
      }
    }]), si;
  }();
  function oo(si) {
    for (var Qr = si.firstChild, Br = null; Qr; Qr = Qr.nextSibling) {
      var zr = Qr.nodeType == 1 ? Qr.nodeName.toLowerCase() : null;
      zr && Va.hasOwnProperty(zr) && Br ? (Br.appendChild(Qr), Qr = Br) : zr == "li" ? Br = Qr : zr && (Br = null);
    }
  }
  function uo(si, Qr) {
    return (si.matches || si.msMatchesSelector || si.webkitMatchesSelector || si.mozMatchesSelector).call(si, Qr);
  }
  function Io(si) {
    for (var Qr = /\s*([\w-]+)\s*:\s*([^;]+)/g, Br, zr = []; Br = Qr.exec(si); )
      zr.push(Br[1], Br[2].trim());
    return zr;
  }
  function Lo(si) {
    var Qr = {};
    for (var Br in si)
      Qr[Br] = si[Br];
    return Qr;
  }
  function Eo(si, Qr) {
    var Br = Qr.schema.nodes, zr = function(Ti) {
      var Fi = Br[Ti];
      if (!Fi.allowsMarkType(si))
        return "continue";
      var ra = [], pa = function ca(da) {
        ra.push(da);
        for (var qa = 0; qa < da.edgeCount; qa++) {
          var co = da.edge(qa), yo = co.type, Mo = co.next;
          if (yo == Qr || ra.indexOf(Mo) < 0 && ca(Mo))
            return !0;
        }
      };
      if (pa(Fi.contentMatch))
        return {
          v: !0
        };
    };
    for (var Xr in Br) {
      var ai = zr(Xr);
      if (ai !== "continue" && Nr(ai) === "object")
        return ai.v;
    }
  }
  function lo(si, Qr) {
    for (var Br = 0; Br < Qr.length; Br++)
      if (si.eq(Qr[Br]))
        return Qr[Br];
  }
  var ya = function() {
    function si(Qr, Br) {
      Ar(this, si), this.nodes = Qr, this.marks = Br;
    }
    return Dr(si, [{
      key: "serializeFragment",
      value: function(Br) {
        var zr = this, Xr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ai = arguments.length > 2 ? arguments[2] : void 0;
        ai || (ai = sa(Xr).createDocumentFragment());
        var vi = ai, Ti = [];
        return Br.forEach(function(Fi) {
          if (Ti.length || Fi.marks.length) {
            for (var ra = 0, pa = 0; ra < Ti.length && pa < Fi.marks.length; ) {
              var ca = Fi.marks[pa];
              if (!zr.marks[ca.type.name]) {
                pa++;
                continue;
              }
              if (!ca.eq(Ti[ra][0]) || ca.type.spec.spanning === !1)
                break;
              ra++, pa++;
            }
            for (; ra < Ti.length; )
              vi = Ti.pop()[1];
            for (; pa < Fi.marks.length; ) {
              var da = Fi.marks[pa++], qa = zr.serializeMark(da, Fi.isInline, Xr);
              qa && (Ti.push([da, vi]), vi.appendChild(qa.dom), vi = qa.contentDOM || qa.dom);
            }
          }
          vi.appendChild(zr.serializeNodeInner(Fi, Xr));
        }), ai;
      }
    }, {
      key: "serializeNodeInner",
      value: function(Br, zr) {
        var Xr = si.renderSpec(sa(zr), this.nodes[Br.type.name](Br)), ai = Xr.dom, vi = Xr.contentDOM;
        if (vi) {
          if (Br.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(Br.content, zr, vi);
        }
        return ai;
      }
    }, {
      key: "serializeNode",
      value: function(Br) {
        for (var zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Xr = this.serializeNodeInner(Br, zr), ai = Br.marks.length - 1; ai >= 0; ai--) {
          var vi = this.serializeMark(Br.marks[ai], Br.isInline, zr);
          vi && ((vi.contentDOM || vi.dom).appendChild(Xr), Xr = vi.dom);
        }
        return Xr;
      }
    }, {
      key: "serializeMark",
      value: function(Br, zr) {
        var Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ai = this.marks[Br.type.name];
        return ai && si.renderSpec(sa(Xr), ai(Br, zr));
      }
    }], [{
      key: "renderSpec",
      value: function(Br, zr) {
        var Xr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (typeof zr == "string")
          return {
            dom: Br.createTextNode(zr)
          };
        if (zr.nodeType != null)
          return {
            dom: zr
          };
        if (zr.dom && zr.dom.nodeType != null)
          return zr;
        var ai = zr[0], vi = ai.indexOf(" ");
        vi > 0 && (Xr = ai.slice(0, vi), ai = ai.slice(vi + 1));
        var Ti, Fi = Xr ? Br.createElementNS(Xr, ai) : Br.createElement(ai), ra = zr[1], pa = 1;
        if (ra && Nr(ra) == "object" && ra.nodeType == null && !Array.isArray(ra)) {
          pa = 2;
          for (var ca in ra)
            if (ra[ca] != null) {
              var da = ca.indexOf(" ");
              da > 0 ? Fi.setAttributeNS(ca.slice(0, da), ca.slice(da + 1), ra[ca]) : Fi.setAttribute(ca, ra[ca]);
            }
        }
        for (var qa = pa; qa < zr.length; qa++) {
          var co = zr[qa];
          if (co === 0) {
            if (qa < zr.length - 1 || qa > pa)
              throw new RangeError("Content hole must be the only child of its parent node");
            return {
              dom: Fi,
              contentDOM: Fi
            };
          } else {
            var yo = si.renderSpec(Br, co, Xr), Mo = yo.dom, Oo = yo.contentDOM;
            if (Fi.appendChild(Mo), Oo) {
              if (Ti)
                throw new RangeError("Multiple content holes");
              Ti = Oo;
            }
          }
        }
        return {
          dom: Fi,
          contentDOM: Ti
        };
      }
    }, {
      key: "fromSchema",
      value: function(Br) {
        return Br.cached.domSerializer || (Br.cached.domSerializer = new si(this.nodesFromSchema(Br), this.marksFromSchema(Br)));
      }
    }, {
      key: "nodesFromSchema",
      value: function(Br) {
        var zr = qi(Br.nodes);
        return zr.text || (zr.text = function(Xr) {
          return Xr.text;
        }), zr;
      }
    }, {
      key: "marksFromSchema",
      value: function(Br) {
        return qi(Br.marks);
      }
    }]), si;
  }();
  function qi(si) {
    var Qr = {};
    for (var Br in si) {
      var zr = si[Br].spec.toDOM;
      zr && (Qr[Br] = zr);
    }
    return Qr;
  }
  function sa(si) {
    return si.document || window.document;
  }
  return dist$7.ContentMatch = Fa, dist$7.DOMParser = zi, dist$7.DOMSerializer = ya, dist$7.Fragment = Jr, dist$7.Mark = ci, dist$7.MarkType = Yi, dist$7.Node = la, dist$7.NodeRange = ia, dist$7.NodeType = Ha, dist$7.ReplaceError = hi, dist$7.ResolvedPos = _i, dist$7.Schema = Zi, dist$7.Slice = Ei, dist$7;
}
var distExports$5 = requireDist$5(), dist$5 = {}, dist$4 = {};
const lower16 = 65535, factor16 = Math.pow(2, 16);
function makeRecover(lr, ar) {
  return lr + ar * factor16;
}
function recoverIndex(lr) {
  return lr & lower16;
}
function recoverOffset(lr) {
  return (lr - (lr & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(ar, cr, ur) {
    this.pos = ar, this.delInfo = cr, this.recover = ur;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ar, cr = !1) {
    if (this.ranges = ar, this.inverted = cr, !ar.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(ar) {
    let cr = 0, ur = recoverIndex(ar);
    if (!this.inverted)
      for (let fr = 0; fr < ur; fr++)
        cr += this.ranges[fr * 3 + 2] - this.ranges[fr * 3 + 1];
    return this.ranges[ur * 3] + cr + recoverOffset(ar);
  }
  mapResult(ar, cr = 1) {
    return this._map(ar, cr, !1);
  }
  map(ar, cr = 1) {
    return this._map(ar, cr, !0);
  }
  /**
  @internal
  */
  _map(ar, cr, ur) {
    let fr = 0, dr = this.inverted ? 2 : 1, hr = this.inverted ? 1 : 2;
    for (let gr = 0; gr < this.ranges.length; gr += 3) {
      let vr = this.ranges[gr] - (this.inverted ? fr : 0);
      if (vr > ar)
        break;
      let mr = this.ranges[gr + dr], br = this.ranges[gr + hr], yr = vr + mr;
      if (ar <= yr) {
        let kr = mr ? ar == vr ? -1 : ar == yr ? 1 : cr : cr, Tr = vr + fr + (kr < 0 ? 0 : br);
        if (ur)
          return Tr;
        let _r = ar == (cr < 0 ? vr : yr) ? null : makeRecover(gr / 3, ar - vr), Er = ar == vr ? DEL_AFTER : ar == yr ? DEL_BEFORE : DEL_ACROSS;
        return (cr < 0 ? ar != vr : ar != yr) && (Er |= DEL_SIDE), new MapResult(Tr, Er, _r);
      }
      fr += br - mr;
    }
    return ur ? ar + fr : new MapResult(ar + fr, 0, null);
  }
  /**
  @internal
  */
  touches(ar, cr) {
    let ur = 0, fr = recoverIndex(cr), dr = this.inverted ? 2 : 1, hr = this.inverted ? 1 : 2;
    for (let gr = 0; gr < this.ranges.length; gr += 3) {
      let vr = this.ranges[gr] - (this.inverted ? ur : 0);
      if (vr > ar)
        break;
      let mr = this.ranges[gr + dr], br = vr + mr;
      if (ar <= br && gr == fr * 3)
        return !0;
      ur += this.ranges[gr + hr] - mr;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(ar) {
    let cr = this.inverted ? 2 : 1, ur = this.inverted ? 1 : 2;
    for (let fr = 0, dr = 0; fr < this.ranges.length; fr += 3) {
      let hr = this.ranges[fr], gr = hr - (this.inverted ? dr : 0), vr = hr + (this.inverted ? 0 : dr), mr = this.ranges[fr + cr], br = this.ranges[fr + ur];
      ar(gr, gr + mr, vr, vr + br), dr += br - mr;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(ar) {
    return ar == 0 ? StepMap.empty : new StepMap(ar < 0 ? [0, -ar, 0] : [0, 0, ar]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(ar = [], cr, ur = 0, fr = ar.length) {
    this.maps = ar, this.mirror = cr, this.from = ur, this.to = fr;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(ar = 0, cr = this.maps.length) {
    return new Mapping(this.maps, this.mirror, ar, cr);
  }
  /**
  @internal
  */
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(ar, cr) {
    this.to = this.maps.push(ar), cr != null && this.setMirror(this.maps.length - 1, cr);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(ar) {
    for (let cr = 0, ur = this.maps.length; cr < ar.maps.length; cr++) {
      let fr = ar.getMirror(cr);
      this.appendMap(ar.maps[cr], fr != null && fr < cr ? ur + fr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(ar) {
    if (this.mirror) {
      for (let cr = 0; cr < this.mirror.length; cr++)
        if (this.mirror[cr] == ar)
          return this.mirror[cr + (cr % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(ar, cr) {
    this.mirror || (this.mirror = []), this.mirror.push(ar, cr);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(ar) {
    for (let cr = ar.maps.length - 1, ur = this.maps.length + ar.maps.length; cr >= 0; cr--) {
      let fr = ar.getMirror(cr);
      this.appendMap(ar.maps[cr].invert(), fr != null && fr > cr ? ur - fr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let ar = new Mapping();
    return ar.appendMappingInverted(this), ar;
  }
  /**
  Map a position through this mapping.
  */
  map(ar, cr = 1) {
    if (this.mirror)
      return this._map(ar, cr, !0);
    for (let ur = this.from; ur < this.to; ur++)
      ar = this.maps[ur].map(ar, cr);
    return ar;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(ar, cr = 1) {
    return this._map(ar, cr, !1);
  }
  /**
  @internal
  */
  _map(ar, cr, ur) {
    let fr = 0;
    for (let dr = this.from; dr < this.to; dr++) {
      let hr = this.maps[dr], gr = hr.mapResult(ar, cr);
      if (gr.recover != null) {
        let vr = this.getMirror(dr);
        if (vr != null && vr > dr && vr < this.to) {
          dr = vr, ar = this.maps[vr].recover(gr.recover);
          continue;
        }
      }
      fr |= gr.delInfo, ar = gr.pos;
    }
    return ur ? ar : new MapResult(ar, fr, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(ar) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(ar, cr) {
    if (!cr || !cr.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let ur = stepsByID[cr.stepType];
    if (!ur)
      throw new RangeError(`No step type ${cr.stepType} defined`);
    return ur.fromJSON(ar, cr);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(ar, cr) {
    if (ar in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + ar);
    return stepsByID[ar] = cr, cr.prototype.jsonID = ar, cr;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(ar, cr) {
    this.doc = ar, this.failed = cr;
  }
  /**
  Create a successful step result.
  */
  static ok(ar) {
    return new StepResult(ar, null);
  }
  /**
  Create a failed step result.
  */
  static fail(ar) {
    return new StepResult(null, ar);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(ar, cr, ur, fr) {
    try {
      return StepResult.ok(ar.replace(cr, ur, fr));
    } catch (dr) {
      if (dr instanceof distExports$5.ReplaceError)
        return StepResult.fail(dr.message);
      throw dr;
    }
  }
}
function mapFragment(lr, ar, cr) {
  let ur = [];
  for (let fr = 0; fr < lr.childCount; fr++) {
    let dr = lr.child(fr);
    dr.content.size && (dr = dr.copy(mapFragment(dr.content, ar, dr))), dr.isInline && (dr = ar(dr, cr, fr)), ur.push(dr);
  }
  return distExports$5.Fragment.fromArray(ur);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(ar, cr, ur) {
    super(), this.from = ar, this.to = cr, this.mark = ur;
  }
  apply(ar) {
    let cr = ar.slice(this.from, this.to), ur = ar.resolve(this.from), fr = ur.node(ur.sharedDepth(this.to)), dr = new distExports$5.Slice(mapFragment(cr.content, (hr, gr) => !hr.isAtom || !gr.type.allowsMarkType(this.mark.type) ? hr : hr.mark(this.mark.addToSet(hr.marks)), fr), cr.openStart, cr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, dr);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deleted && ur.deleted || cr.pos >= ur.pos ? null : new AddMarkStep(cr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof AddMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new AddMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(cr.from, cr.to, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, cr, ur) {
    super(), this.from = ar, this.to = cr, this.mark = ur;
  }
  apply(ar) {
    let cr = ar.slice(this.from, this.to), ur = new distExports$5.Slice(mapFragment(cr.content, (fr) => fr.mark(this.mark.removeFromSet(fr.marks)), ar), cr.openStart, cr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, ur);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deleted && ur.deleted || cr.pos >= ur.pos ? null : new RemoveMarkStep(cr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof RemoveMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new RemoveMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(cr.from, cr.to, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(ar, cr) {
    super(), this.pos = ar, this.mark = cr;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at mark step's position");
    let ur = cr.type.create(cr.attrs, null, this.mark.addToSet(cr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, cr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let cr = ar.nodeAt(this.pos);
    if (cr) {
      let ur = this.mark.addToSet(cr.marks);
      if (ur.length == cr.marks.length) {
        for (let fr = 0; fr < cr.marks.length; fr++)
          if (!cr.marks[fr].isInSet(ur))
            return new AddNodeMarkStep(this.pos, cr.marks[fr]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new AddNodeMarkStep(cr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(cr.pos, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, cr) {
    super(), this.pos = ar, this.mark = cr;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at mark step's position");
    let ur = cr.type.create(cr.attrs, null, this.mark.removeFromSet(cr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, cr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let cr = ar.nodeAt(this.pos);
    return !cr || !this.mark.isInSet(cr.marks) ? this : new AddNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new RemoveNodeMarkStep(cr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(cr.pos, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(ar, cr, ur, fr = !1) {
    super(), this.from = ar, this.to = cr, this.slice = ur, this.structure = fr;
  }
  apply(ar) {
    return this.structure && contentBetween(ar, this.from, this.to) ? StepResult.fail("Structure replace would overwrite content") : StepResult.fromReplace(ar, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(ar) {
    return new ReplaceStep(this.from, this.from + this.slice.size, ar.slice(this.from, this.to));
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deletedAcross && ur.deletedAcross ? null : new ReplaceStep(cr.pos, Math.max(cr.pos, ur.pos), this.slice);
  }
  merge(ar) {
    if (!(ar instanceof ReplaceStep) || ar.structure || this.structure)
      return null;
    if (this.from + this.slice.size == ar.from && !this.slice.openEnd && !ar.slice.openStart) {
      let cr = this.slice.size + ar.slice.size == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(this.slice.content.append(ar.slice.content), this.slice.openStart, ar.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (ar.to - ar.from), cr, this.structure);
    } else if (ar.to == this.from && !this.slice.openStart && !ar.slice.openEnd) {
      let cr = this.slice.size + ar.slice.size == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(ar.slice.content.append(this.slice.content), ar.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(ar.from, this.to, cr, this.structure);
    } else
      return null;
  }
  toJSON() {
    let ar = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(cr.from, cr.to, distExports$5.Slice.fromJSON(ar, cr.slice), !!cr.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(ar, cr, ur, fr, dr, hr, gr = !1) {
    super(), this.from = ar, this.to = cr, this.gapFrom = ur, this.gapTo = fr, this.slice = dr, this.insert = hr, this.structure = gr;
  }
  apply(ar) {
    if (this.structure && (contentBetween(ar, this.from, this.gapFrom) || contentBetween(ar, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let cr = ar.slice(this.gapFrom, this.gapTo);
    if (cr.openStart || cr.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let ur = this.slice.insertAt(this.insert, cr.content);
    return ur ? StepResult.fromReplace(ar, this.from, this.to, ur) : StepResult.fail("Content does not fit in gap");
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(ar) {
    let cr = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + cr, this.from + this.insert, this.from + this.insert + cr, ar.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1), fr = ar.map(this.gapFrom, -1), dr = ar.map(this.gapTo, 1);
    return cr.deletedAcross && ur.deletedAcross || fr < cr.pos || dr > ur.pos ? null : new ReplaceAroundStep(cr.pos, ur.pos, fr, dr, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let ar = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number" || typeof cr.gapFrom != "number" || typeof cr.gapTo != "number" || typeof cr.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(cr.from, cr.to, cr.gapFrom, cr.gapTo, distExports$5.Slice.fromJSON(ar, cr.slice), cr.insert, !!cr.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(lr, ar, cr) {
  let ur = lr.resolve(ar), fr = cr - ar, dr = ur.depth;
  for (; fr > 0 && dr > 0 && ur.indexAfter(dr) == ur.node(dr).childCount; )
    dr--, fr--;
  if (fr > 0) {
    let hr = ur.node(dr).maybeChild(ur.indexAfter(dr));
    for (; fr > 0; ) {
      if (!hr || hr.isLeaf)
        return !0;
      hr = hr.firstChild, fr--;
    }
  }
  return !1;
}
function addMark(lr, ar, cr, ur) {
  let fr = [], dr = [], hr, gr;
  lr.doc.nodesBetween(ar, cr, (vr, mr, br) => {
    if (!vr.isInline)
      return;
    let yr = vr.marks;
    if (!ur.isInSet(yr) && br.type.allowsMarkType(ur.type)) {
      let kr = Math.max(mr, ar), Tr = Math.min(mr + vr.nodeSize, cr), _r = ur.addToSet(yr);
      for (let Er = 0; Er < yr.length; Er++)
        yr[Er].isInSet(_r) || (hr && hr.to == kr && hr.mark.eq(yr[Er]) ? hr.to = Tr : fr.push(hr = new RemoveMarkStep(kr, Tr, yr[Er])));
      gr && gr.to == kr ? gr.to = Tr : dr.push(gr = new AddMarkStep(kr, Tr, ur));
    }
  }), fr.forEach((vr) => lr.step(vr)), dr.forEach((vr) => lr.step(vr));
}
function removeMark(lr, ar, cr, ur) {
  let fr = [], dr = 0;
  lr.doc.nodesBetween(ar, cr, (hr, gr) => {
    if (!hr.isInline)
      return;
    dr++;
    let vr = null;
    if (ur instanceof distExports$5.MarkType) {
      let mr = hr.marks, br;
      for (; br = ur.isInSet(mr); )
        (vr || (vr = [])).push(br), mr = br.removeFromSet(mr);
    } else
      ur ? ur.isInSet(hr.marks) && (vr = [ur]) : vr = hr.marks;
    if (vr && vr.length) {
      let mr = Math.min(gr + hr.nodeSize, cr);
      for (let br = 0; br < vr.length; br++) {
        let yr = vr[br], kr;
        for (let Tr = 0; Tr < fr.length; Tr++) {
          let _r = fr[Tr];
          _r.step == dr - 1 && yr.eq(fr[Tr].style) && (kr = _r);
        }
        kr ? (kr.to = mr, kr.step = dr) : fr.push({ style: yr, from: Math.max(gr, ar), to: mr, step: dr });
      }
    }
  }), fr.forEach((hr) => lr.step(new RemoveMarkStep(hr.from, hr.to, hr.style)));
}
function clearIncompatible(lr, ar, cr, ur = cr.contentMatch) {
  let fr = lr.doc.nodeAt(ar), dr = [], hr = ar + 1;
  for (let gr = 0; gr < fr.childCount; gr++) {
    let vr = fr.child(gr), mr = hr + vr.nodeSize, br = ur.matchType(vr.type);
    if (!br)
      dr.push(new ReplaceStep(hr, mr, distExports$5.Slice.empty));
    else {
      ur = br;
      for (let yr = 0; yr < vr.marks.length; yr++)
        cr.allowsMarkType(vr.marks[yr].type) || lr.step(new RemoveMarkStep(hr, mr, vr.marks[yr]));
      if (vr.isText && !cr.spec.code) {
        let yr, kr = /\r?\n|\r/g, Tr;
        for (; yr = kr.exec(vr.text); )
          Tr || (Tr = new distExports$5.Slice(distExports$5.Fragment.from(cr.schema.text(" ", cr.allowedMarks(vr.marks))), 0, 0)), dr.push(new ReplaceStep(hr + yr.index, hr + yr.index + yr[0].length, Tr));
      }
    }
    hr = mr;
  }
  if (!ur.validEnd) {
    let gr = ur.fillBefore(distExports$5.Fragment.empty, !0);
    lr.replace(hr, hr, new distExports$5.Slice(gr, 0, 0));
  }
  for (let gr = dr.length - 1; gr >= 0; gr--)
    lr.step(dr[gr]);
}
function canCut(lr, ar, cr) {
  return (ar == 0 || lr.canReplace(ar, lr.childCount)) && (cr == lr.childCount || lr.canReplace(0, cr));
}
function liftTarget(lr) {
  let cr = lr.parent.content.cutByIndex(lr.startIndex, lr.endIndex);
  for (let ur = lr.depth; ; --ur) {
    let fr = lr.$from.node(ur), dr = lr.$from.index(ur), hr = lr.$to.indexAfter(ur);
    if (ur < lr.depth && fr.canReplace(dr, hr, cr))
      return ur;
    if (ur == 0 || fr.type.spec.isolating || !canCut(fr, dr, hr))
      break;
  }
  return null;
}
function lift(lr, ar, cr) {
  let { $from: ur, $to: fr, depth: dr } = ar, hr = ur.before(dr + 1), gr = fr.after(dr + 1), vr = hr, mr = gr, br = distExports$5.Fragment.empty, yr = 0;
  for (let _r = dr, Er = !1; _r > cr; _r--)
    Er || ur.index(_r) > 0 ? (Er = !0, br = distExports$5.Fragment.from(ur.node(_r).copy(br)), yr++) : vr--;
  let kr = distExports$5.Fragment.empty, Tr = 0;
  for (let _r = dr, Er = !1; _r > cr; _r--)
    Er || fr.after(_r + 1) < fr.end(_r) ? (Er = !0, kr = distExports$5.Fragment.from(fr.node(_r).copy(kr)), Tr++) : mr++;
  lr.step(new ReplaceAroundStep(vr, mr, hr, gr, new distExports$5.Slice(br.append(kr), yr, Tr), br.size - yr, !0));
}
function findWrapping(lr, ar, cr = null, ur = lr) {
  let fr = findWrappingOutside$1(lr, ar), dr = fr && findWrappingInside$1(ur, ar);
  return dr ? fr.map(withAttrs).concat({ type: ar, attrs: cr }).concat(dr.map(withAttrs)) : null;
}
function withAttrs(lr) {
  return { type: lr, attrs: null };
}
function findWrappingOutside$1(lr, ar) {
  let { parent: cr, startIndex: ur, endIndex: fr } = lr, dr = cr.contentMatchAt(ur).findWrapping(ar);
  if (!dr)
    return null;
  let hr = dr.length ? dr[0] : ar;
  return cr.canReplaceWith(ur, fr, hr) ? dr : null;
}
function findWrappingInside$1(lr, ar) {
  let { parent: cr, startIndex: ur, endIndex: fr } = lr, dr = cr.child(ur), hr = ar.contentMatch.findWrapping(dr.type);
  if (!hr)
    return null;
  let vr = (hr.length ? hr[hr.length - 1] : ar).contentMatch;
  for (let mr = ur; vr && mr < fr; mr++)
    vr = vr.matchType(cr.child(mr).type);
  return !vr || !vr.validEnd ? null : hr;
}
function wrap(lr, ar, cr) {
  let ur = distExports$5.Fragment.empty;
  for (let hr = cr.length - 1; hr >= 0; hr--) {
    if (ur.size) {
      let gr = cr[hr].type.contentMatch.matchFragment(ur);
      if (!gr || !gr.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    ur = distExports$5.Fragment.from(cr[hr].type.create(cr[hr].attrs, ur));
  }
  let fr = ar.start, dr = ar.end;
  lr.step(new ReplaceAroundStep(fr, dr, fr, dr, new distExports$5.Slice(ur, 0, 0), cr.length, !0));
}
function setBlockType$1(lr, ar, cr, ur, fr) {
  if (!ur.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let dr = lr.steps.length;
  lr.doc.nodesBetween(ar, cr, (hr, gr) => {
    if (hr.isTextblock && !hr.hasMarkup(ur, fr) && canChangeType(lr.doc, lr.mapping.slice(dr).map(gr), ur)) {
      lr.clearIncompatible(lr.mapping.slice(dr).map(gr, 1), ur);
      let vr = lr.mapping.slice(dr), mr = vr.map(gr, 1), br = vr.map(gr + hr.nodeSize, 1);
      return lr.step(new ReplaceAroundStep(mr, br, mr + 1, br - 1, new distExports$5.Slice(distExports$5.Fragment.from(ur.create(fr, null, hr.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function canChangeType(lr, ar, cr) {
  let ur = lr.resolve(ar), fr = ur.index();
  return ur.parent.canReplaceWith(fr, fr + 1, cr);
}
function setNodeMarkup(lr, ar, cr, ur, fr) {
  let dr = lr.doc.nodeAt(ar);
  if (!dr)
    throw new RangeError("No node at given position");
  cr || (cr = dr.type);
  let hr = cr.create(ur, null, fr || dr.marks);
  if (dr.isLeaf)
    return lr.replaceWith(ar, ar + dr.nodeSize, hr);
  if (!cr.validContent(dr.content))
    throw new RangeError("Invalid content for node type " + cr.name);
  lr.step(new ReplaceAroundStep(ar, ar + dr.nodeSize, ar + 1, ar + dr.nodeSize - 1, new distExports$5.Slice(distExports$5.Fragment.from(hr), 0, 0), 1, !0));
}
function canSplit(lr, ar, cr = 1, ur) {
  let fr = lr.resolve(ar), dr = fr.depth - cr, hr = ur && ur[ur.length - 1] || fr.parent;
  if (dr < 0 || fr.parent.type.spec.isolating || !fr.parent.canReplace(fr.index(), fr.parent.childCount) || !hr.type.validContent(fr.parent.content.cutByIndex(fr.index(), fr.parent.childCount)))
    return !1;
  for (let mr = fr.depth - 1, br = cr - 2; mr > dr; mr--, br--) {
    let yr = fr.node(mr), kr = fr.index(mr);
    if (yr.type.spec.isolating)
      return !1;
    let Tr = yr.content.cutByIndex(kr, yr.childCount), _r = ur && ur[br + 1];
    _r && (Tr = Tr.replaceChild(0, _r.type.create(_r.attrs)));
    let Er = ur && ur[br] || yr;
    if (!yr.canReplace(kr + 1, yr.childCount) || !Er.type.validContent(Tr))
      return !1;
  }
  let gr = fr.indexAfter(dr), vr = ur && ur[0];
  return fr.node(dr).canReplaceWith(gr, gr, vr ? vr.type : fr.node(dr + 1).type);
}
function split(lr, ar, cr = 1, ur) {
  let fr = lr.doc.resolve(ar), dr = distExports$5.Fragment.empty, hr = distExports$5.Fragment.empty;
  for (let gr = fr.depth, vr = fr.depth - cr, mr = cr - 1; gr > vr; gr--, mr--) {
    dr = distExports$5.Fragment.from(fr.node(gr).copy(dr));
    let br = ur && ur[mr];
    hr = distExports$5.Fragment.from(br ? br.type.create(br.attrs, hr) : fr.node(gr).copy(hr));
  }
  lr.step(new ReplaceStep(ar, ar, new distExports$5.Slice(dr.append(hr), cr, cr), !0));
}
function canJoin(lr, ar) {
  let cr = lr.resolve(ar), ur = cr.index();
  return joinable(cr.nodeBefore, cr.nodeAfter) && cr.parent.canReplace(ur, ur + 1);
}
function joinable(lr, ar) {
  return !!(lr && ar && !lr.isLeaf && lr.canAppend(ar));
}
function joinPoint(lr, ar, cr = -1) {
  let ur = lr.resolve(ar);
  for (let fr = ur.depth; ; fr--) {
    let dr, hr, gr = ur.index(fr);
    if (fr == ur.depth ? (dr = ur.nodeBefore, hr = ur.nodeAfter) : cr > 0 ? (dr = ur.node(fr + 1), gr++, hr = ur.node(fr).maybeChild(gr)) : (dr = ur.node(fr).maybeChild(gr - 1), hr = ur.node(fr + 1)), dr && !dr.isTextblock && joinable(dr, hr) && ur.node(fr).canReplace(gr, gr + 1))
      return ar;
    if (fr == 0)
      break;
    ar = cr < 0 ? ur.before(fr) : ur.after(fr);
  }
}
function join(lr, ar, cr) {
  let ur = new ReplaceStep(ar - cr, ar + cr, distExports$5.Slice.empty, !0);
  lr.step(ur);
}
function insertPoint(lr, ar, cr) {
  let ur = lr.resolve(ar);
  if (ur.parent.canReplaceWith(ur.index(), ur.index(), cr))
    return ar;
  if (ur.parentOffset == 0)
    for (let fr = ur.depth - 1; fr >= 0; fr--) {
      let dr = ur.index(fr);
      if (ur.node(fr).canReplaceWith(dr, dr, cr))
        return ur.before(fr + 1);
      if (dr > 0)
        return null;
    }
  if (ur.parentOffset == ur.parent.content.size)
    for (let fr = ur.depth - 1; fr >= 0; fr--) {
      let dr = ur.indexAfter(fr);
      if (ur.node(fr).canReplaceWith(dr, dr, cr))
        return ur.after(fr + 1);
      if (dr < ur.node(fr).childCount)
        return null;
    }
  return null;
}
function dropPoint(lr, ar, cr) {
  let ur = lr.resolve(ar);
  if (!cr.content.size)
    return ar;
  let fr = cr.content;
  for (let dr = 0; dr < cr.openStart; dr++)
    fr = fr.firstChild.content;
  for (let dr = 1; dr <= (cr.openStart == 0 && cr.size ? 2 : 1); dr++)
    for (let hr = ur.depth; hr >= 0; hr--) {
      let gr = hr == ur.depth ? 0 : ur.pos <= (ur.start(hr + 1) + ur.end(hr + 1)) / 2 ? -1 : 1, vr = ur.index(hr) + (gr > 0 ? 1 : 0), mr = ur.node(hr), br = !1;
      if (dr == 1)
        br = mr.canReplace(vr, vr, fr);
      else {
        let yr = mr.contentMatchAt(vr).findWrapping(fr.firstChild.type);
        br = yr && mr.canReplaceWith(vr, vr, yr[0]);
      }
      if (br)
        return gr == 0 ? ur.pos : gr < 0 ? ur.before(hr + 1) : ur.after(hr + 1);
    }
  return null;
}
function replaceStep(lr, ar, cr = ar, ur = distExports$5.Slice.empty) {
  if (ar == cr && !ur.size)
    return null;
  let fr = lr.resolve(ar), dr = lr.resolve(cr);
  return fitsTrivially(fr, dr, ur) ? new ReplaceStep(ar, cr, ur) : new Fitter(fr, dr, ur).fit();
}
function fitsTrivially(lr, ar, cr) {
  return !cr.openStart && !cr.openEnd && lr.start() == ar.start() && lr.parent.canReplace(lr.index(), ar.index(), cr.content);
}
class Fitter {
  constructor(ar, cr, ur) {
    this.$from = ar, this.$to = cr, this.unplaced = ur, this.frontier = [], this.placed = distExports$5.Fragment.empty;
    for (let fr = 0; fr <= ar.depth; fr++) {
      let dr = ar.node(fr);
      this.frontier.push({
        type: dr.type,
        match: dr.contentMatchAt(ar.indexAfter(fr))
      });
    }
    for (let fr = ar.depth; fr > 0; fr--)
      this.placed = distExports$5.Fragment.from(ar.node(fr).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let mr = this.findFittable();
      mr ? this.placeNodes(mr) : this.openMore() || this.dropNode();
    }
    let ar = this.mustMoveInline(), cr = this.placed.size - this.depth - this.$from.depth, ur = this.$from, fr = this.close(ar < 0 ? this.$to : ur.doc.resolve(ar));
    if (!fr)
      return null;
    let dr = this.placed, hr = ur.depth, gr = fr.depth;
    for (; hr && gr && dr.childCount == 1; )
      dr = dr.firstChild.content, hr--, gr--;
    let vr = new distExports$5.Slice(dr, hr, gr);
    return ar > -1 ? new ReplaceAroundStep(ur.pos, ar, this.$to.pos, this.$to.end(), vr, cr) : vr.size || ur.pos != this.$to.pos ? new ReplaceStep(ur.pos, fr.pos, vr) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let ar = this.unplaced.openStart;
    for (let cr = this.unplaced.content, ur = 0, fr = this.unplaced.openEnd; ur < ar; ur++) {
      let dr = cr.firstChild;
      if (cr.childCount > 1 && (fr = 0), dr.type.spec.isolating && fr <= ur) {
        ar = ur;
        break;
      }
      cr = dr.content;
    }
    for (let cr = 1; cr <= 2; cr++)
      for (let ur = cr == 1 ? ar : this.unplaced.openStart; ur >= 0; ur--) {
        let fr, dr = null;
        ur ? (dr = contentAt(this.unplaced.content, ur - 1).firstChild, fr = dr.content) : fr = this.unplaced.content;
        let hr = fr.firstChild;
        for (let gr = this.depth; gr >= 0; gr--) {
          let { type: vr, match: mr } = this.frontier[gr], br, yr = null;
          if (cr == 1 && (hr ? mr.matchType(hr.type) || (yr = mr.fillBefore(distExports$5.Fragment.from(hr), !1)) : dr && vr.compatibleContent(dr.type)))
            return { sliceDepth: ur, frontierDepth: gr, parent: dr, inject: yr };
          if (cr == 2 && hr && (br = mr.findWrapping(hr.type)))
            return { sliceDepth: ur, frontierDepth: gr, parent: dr, wrap: br };
          if (dr && mr.matchType(dr.type))
            break;
        }
      }
  }
  openMore() {
    let { content: ar, openStart: cr, openEnd: ur } = this.unplaced, fr = contentAt(ar, cr);
    return !fr.childCount || fr.firstChild.isLeaf ? !1 : (this.unplaced = new distExports$5.Slice(ar, cr + 1, Math.max(ur, fr.size + cr >= ar.size - ur ? cr + 1 : 0)), !0);
  }
  dropNode() {
    let { content: ar, openStart: cr, openEnd: ur } = this.unplaced, fr = contentAt(ar, cr);
    if (fr.childCount <= 1 && cr > 0) {
      let dr = ar.size - cr <= cr + fr.size;
      this.unplaced = new distExports$5.Slice(dropFromFragment(ar, cr - 1, 1), cr - 1, dr ? cr - 1 : ur);
    } else
      this.unplaced = new distExports$5.Slice(dropFromFragment(ar, cr, 1), cr, ur);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: ar, frontierDepth: cr, parent: ur, inject: fr, wrap: dr }) {
    for (; this.depth > cr; )
      this.closeFrontierNode();
    if (dr)
      for (let Er = 0; Er < dr.length; Er++)
        this.openFrontierNode(dr[Er]);
    let hr = this.unplaced, gr = ur ? ur.content : hr.content, vr = hr.openStart - ar, mr = 0, br = [], { match: yr, type: kr } = this.frontier[cr];
    if (fr) {
      for (let Er = 0; Er < fr.childCount; Er++)
        br.push(fr.child(Er));
      yr = yr.matchFragment(fr);
    }
    let Tr = gr.size + ar - (hr.content.size - hr.openEnd);
    for (; mr < gr.childCount; ) {
      let Er = gr.child(mr), xr = yr.matchType(Er.type);
      if (!xr)
        break;
      mr++, (mr > 1 || vr == 0 || Er.content.size) && (yr = xr, br.push(closeNodeStart(Er.mark(kr.allowedMarks(Er.marks)), mr == 1 ? vr : 0, mr == gr.childCount ? Tr : -1)));
    }
    let _r = mr == gr.childCount;
    _r || (Tr = -1), this.placed = addToFragment(this.placed, cr, distExports$5.Fragment.from(br)), this.frontier[cr].match = yr, _r && Tr < 0 && ur && ur.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let Er = 0, xr = gr; Er < Tr; Er++) {
      let Cr = xr.lastChild;
      this.frontier.push({ type: Cr.type, match: Cr.contentMatchAt(Cr.childCount) }), xr = Cr.content;
    }
    this.unplaced = _r ? ar == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(dropFromFragment(hr.content, ar - 1, 1), ar - 1, Tr < 0 ? hr.openEnd : ar - 1) : new distExports$5.Slice(dropFromFragment(hr.content, ar, mr), hr.openStart, hr.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let ar = this.frontier[this.depth], cr;
    if (!ar.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, ar.type, ar.match, !1) || this.$to.depth == this.depth && (cr = this.findCloseLevel(this.$to)) && cr.depth == this.depth)
      return -1;
    let { depth: ur } = this.$to, fr = this.$to.after(ur);
    for (; ur > 1 && fr == this.$to.end(--ur); )
      ++fr;
    return fr;
  }
  findCloseLevel(ar) {
    e:
      for (let cr = Math.min(this.depth, ar.depth); cr >= 0; cr--) {
        let { match: ur, type: fr } = this.frontier[cr], dr = cr < ar.depth && ar.end(cr + 1) == ar.pos + (ar.depth - (cr + 1)), hr = contentAfterFits(ar, cr, fr, ur, dr);
        if (hr) {
          for (let gr = cr - 1; gr >= 0; gr--) {
            let { match: vr, type: mr } = this.frontier[gr], br = contentAfterFits(ar, gr, mr, vr, !0);
            if (!br || br.childCount)
              continue e;
          }
          return { depth: cr, fit: hr, move: dr ? ar.doc.resolve(ar.after(cr + 1)) : ar };
        }
      }
  }
  close(ar) {
    let cr = this.findCloseLevel(ar);
    if (!cr)
      return null;
    for (; this.depth > cr.depth; )
      this.closeFrontierNode();
    cr.fit.childCount && (this.placed = addToFragment(this.placed, cr.depth, cr.fit)), ar = cr.move;
    for (let ur = cr.depth + 1; ur <= ar.depth; ur++) {
      let fr = ar.node(ur), dr = fr.type.contentMatch.fillBefore(fr.content, !0, ar.index(ur));
      this.openFrontierNode(fr.type, fr.attrs, dr);
    }
    return ar;
  }
  openFrontierNode(ar, cr = null, ur) {
    let fr = this.frontier[this.depth];
    fr.match = fr.match.matchType(ar), this.placed = addToFragment(this.placed, this.depth, distExports$5.Fragment.from(ar.create(cr, ur))), this.frontier.push({ type: ar, match: ar.contentMatch });
  }
  closeFrontierNode() {
    let cr = this.frontier.pop().match.fillBefore(distExports$5.Fragment.empty, !0);
    cr.childCount && (this.placed = addToFragment(this.placed, this.frontier.length, cr));
  }
}
function dropFromFragment(lr, ar, cr) {
  return ar == 0 ? lr.cutByIndex(cr, lr.childCount) : lr.replaceChild(0, lr.firstChild.copy(dropFromFragment(lr.firstChild.content, ar - 1, cr)));
}
function addToFragment(lr, ar, cr) {
  return ar == 0 ? lr.append(cr) : lr.replaceChild(lr.childCount - 1, lr.lastChild.copy(addToFragment(lr.lastChild.content, ar - 1, cr)));
}
function contentAt(lr, ar) {
  for (let cr = 0; cr < ar; cr++)
    lr = lr.firstChild.content;
  return lr;
}
function closeNodeStart(lr, ar, cr) {
  if (ar <= 0)
    return lr;
  let ur = lr.content;
  return ar > 1 && (ur = ur.replaceChild(0, closeNodeStart(ur.firstChild, ar - 1, ur.childCount == 1 ? cr - 1 : 0))), ar > 0 && (ur = lr.type.contentMatch.fillBefore(ur).append(ur), cr <= 0 && (ur = ur.append(lr.type.contentMatch.matchFragment(ur).fillBefore(distExports$5.Fragment.empty, !0)))), lr.copy(ur);
}
function contentAfterFits(lr, ar, cr, ur, fr) {
  let dr = lr.node(ar), hr = fr ? lr.indexAfter(ar) : lr.index(ar);
  if (hr == dr.childCount && !cr.compatibleContent(dr.type))
    return null;
  let gr = ur.fillBefore(dr.content, !0, hr);
  return gr && !invalidMarks(cr, dr.content, hr) ? gr : null;
}
function invalidMarks(lr, ar, cr) {
  for (let ur = cr; ur < ar.childCount; ur++)
    if (!lr.allowsMarks(ar.child(ur).marks))
      return !0;
  return !1;
}
function definesContent(lr) {
  return lr.spec.defining || lr.spec.definingForContent;
}
function replaceRange(lr, ar, cr, ur) {
  if (!ur.size)
    return lr.deleteRange(ar, cr);
  let fr = lr.doc.resolve(ar), dr = lr.doc.resolve(cr);
  if (fitsTrivially(fr, dr, ur))
    return lr.step(new ReplaceStep(ar, cr, ur));
  let hr = coveredDepths(fr, lr.doc.resolve(cr));
  hr[hr.length - 1] == 0 && hr.pop();
  let gr = -(fr.depth + 1);
  hr.unshift(gr);
  for (let kr = fr.depth, Tr = fr.pos - 1; kr > 0; kr--, Tr--) {
    let _r = fr.node(kr).type.spec;
    if (_r.defining || _r.definingAsContext || _r.isolating)
      break;
    hr.indexOf(kr) > -1 ? gr = kr : fr.before(kr) == Tr && hr.splice(1, 0, -kr);
  }
  let vr = hr.indexOf(gr), mr = [], br = ur.openStart;
  for (let kr = ur.content, Tr = 0; ; Tr++) {
    let _r = kr.firstChild;
    if (mr.push(_r), Tr == ur.openStart)
      break;
    kr = _r.content;
  }
  for (let kr = br - 1; kr >= 0; kr--) {
    let Tr = mr[kr], _r = definesContent(Tr.type);
    if (_r && !Tr.sameMarkup(fr.node(Math.abs(gr) - 1)))
      br = kr;
    else if (_r || !Tr.type.isTextblock)
      break;
  }
  for (let kr = ur.openStart; kr >= 0; kr--) {
    let Tr = (kr + br + 1) % (ur.openStart + 1), _r = mr[Tr];
    if (_r)
      for (let Er = 0; Er < hr.length; Er++) {
        let xr = hr[(Er + vr) % hr.length], Cr = !0;
        xr < 0 && (Cr = !1, xr = -xr);
        let Ar = fr.node(xr - 1), Lr = fr.index(xr - 1);
        if (Ar.canReplaceWith(Lr, Lr, _r.type, _r.marks))
          return lr.replace(fr.before(xr), Cr ? dr.after(xr) : cr, new distExports$5.Slice(closeFragment(ur.content, 0, ur.openStart, Tr), Tr, ur.openEnd));
      }
  }
  let yr = lr.steps.length;
  for (let kr = hr.length - 1; kr >= 0 && (lr.replace(ar, cr, ur), !(lr.steps.length > yr)); kr--) {
    let Tr = hr[kr];
    Tr < 0 || (ar = fr.before(Tr), cr = dr.after(Tr));
  }
}
function closeFragment(lr, ar, cr, ur, fr) {
  if (ar < cr) {
    let dr = lr.firstChild;
    lr = lr.replaceChild(0, dr.copy(closeFragment(dr.content, ar + 1, cr, ur, dr)));
  }
  if (ar > ur) {
    let dr = fr.contentMatchAt(0), hr = dr.fillBefore(lr).append(lr);
    lr = hr.append(dr.matchFragment(hr).fillBefore(distExports$5.Fragment.empty, !0));
  }
  return lr;
}
function replaceRangeWith(lr, ar, cr, ur) {
  if (!ur.isInline && ar == cr && lr.doc.resolve(ar).parent.content.size) {
    let fr = insertPoint(lr.doc, ar, ur.type);
    fr != null && (ar = cr = fr);
  }
  lr.replaceRange(ar, cr, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, 0));
}
function deleteRange(lr, ar, cr) {
  let ur = lr.doc.resolve(ar), fr = lr.doc.resolve(cr), dr = coveredDepths(ur, fr);
  for (let hr = 0; hr < dr.length; hr++) {
    let gr = dr[hr], vr = hr == dr.length - 1;
    if (vr && gr == 0 || ur.node(gr).type.contentMatch.validEnd)
      return lr.delete(ur.start(gr), fr.end(gr));
    if (gr > 0 && (vr || ur.node(gr - 1).canReplace(ur.index(gr - 1), fr.indexAfter(gr - 1))))
      return lr.delete(ur.before(gr), fr.after(gr));
  }
  for (let hr = 1; hr <= ur.depth && hr <= fr.depth; hr++)
    if (ar - ur.start(hr) == ur.depth - hr && cr > ur.end(hr) && fr.end(hr) - cr != fr.depth - hr)
      return lr.delete(ur.before(hr), cr);
  lr.delete(ar, cr);
}
function coveredDepths(lr, ar) {
  let cr = [], ur = Math.min(lr.depth, ar.depth);
  for (let fr = ur; fr >= 0; fr--) {
    let dr = lr.start(fr);
    if (dr < lr.pos - (lr.depth - fr) || ar.end(fr) > ar.pos + (ar.depth - fr) || lr.node(fr).type.spec.isolating || ar.node(fr).type.spec.isolating)
      break;
    (dr == ar.start(fr) || fr == lr.depth && fr == ar.depth && lr.parent.inlineContent && ar.parent.inlineContent && fr && ar.start(fr - 1) == dr - 1) && cr.push(fr);
  }
  return cr;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, cr, ur) {
    super(), this.pos = ar, this.attr = cr, this.value = ur;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at attribute step's position");
    let ur = /* @__PURE__ */ Object.create(null);
    for (let dr in cr.attrs)
      ur[dr] = cr.attrs[dr];
    ur[this.attr] = this.value;
    let fr = cr.type.create(ur, null, cr.marks);
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(fr), 0, cr.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new AttrStep(this.pos, this.attr, ar.nodeAt(this.pos).attrs[this.attr]);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new AttrStep(cr.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number" || typeof cr.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(cr.pos, cr.attr, cr.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, cr) {
    super(), this.attr = ar, this.value = cr;
  }
  apply(ar) {
    let cr = /* @__PURE__ */ Object.create(null);
    for (let fr in ar.attrs)
      cr[fr] = ar.attrs[fr];
    cr[this.attr] = this.value;
    let ur = ar.type.create(cr, ar.content, ar.marks);
    return StepResult.ok(ur);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new DocAttrStep(this.attr, ar.attrs[this.attr]);
  }
  map(ar) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(ar, cr) {
    if (typeof cr.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(cr.attr, cr.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function lr(ar) {
  let cr = Error.call(this, ar);
  return cr.__proto__ = lr.prototype, cr;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(ar) {
    this.doc = ar, this.steps = [], this.docs = [], this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(ar) {
    let cr = this.maybeStep(ar);
    if (cr.failed)
      throw new TransformError(cr.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(ar) {
    let cr = ar.apply(this.doc);
    return cr.failed || this.addStep(ar, cr.doc), cr;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(ar, cr) {
    this.docs.push(this.doc), this.steps.push(ar), this.mapping.appendMap(ar.getMap()), this.doc = cr;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(ar, cr = ar, ur = distExports$5.Slice.empty) {
    let fr = replaceStep(this.doc, ar, cr, ur);
    return fr && this.step(fr), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(ar, cr, ur) {
    return this.replace(ar, cr, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(ar, cr) {
    return this.replace(ar, cr, distExports$5.Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(ar, cr) {
    return this.replaceWith(ar, ar, cr);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(ar, cr, ur) {
    return replaceRange(this, ar, cr, ur), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(ar, cr, ur) {
    return replaceRangeWith(this, ar, cr, ur), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(ar, cr) {
    return deleteRange(this, ar, cr), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(ar, cr) {
    return lift(this, ar, cr), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(ar, cr = 1) {
    return join(this, ar, cr), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(ar, cr) {
    return wrap(this, ar, cr), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(ar, cr = ar, ur, fr = null) {
    return setBlockType$1(this, ar, cr, ur, fr), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(ar, cr, ur = null, fr) {
    return setNodeMarkup(this, ar, cr, ur, fr), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(ar, cr, ur) {
    return this.step(new AttrStep(ar, cr, ur)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(ar, cr) {
    return this.step(new DocAttrStep(ar, cr)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(ar, cr) {
    return this.step(new AddNodeMarkStep(ar, cr)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(ar, cr) {
    if (!(cr instanceof distExports$5.Mark)) {
      let ur = this.doc.nodeAt(ar);
      if (!ur)
        throw new RangeError("No node at position " + ar);
      if (cr = cr.isInSet(ur.marks), !cr)
        return this;
    }
    return this.step(new RemoveNodeMarkStep(ar, cr)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(ar, cr = 1, ur) {
    return split(this, ar, cr, ur), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(ar, cr, ur) {
    return addMark(this, ar, cr, ur), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(ar, cr, ur) {
    return removeMark(this, ar, cr, ur), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(ar, cr, ur) {
    return clearIncompatible(this, ar, cr, ur), this;
  }
}
const dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddMarkStep,
  AddNodeMarkStep,
  AttrStep,
  DocAttrStep,
  MapResult,
  Mapping,
  RemoveMarkStep,
  RemoveNodeMarkStep,
  ReplaceAroundStep,
  ReplaceStep,
  Step,
  StepMap,
  StepResult,
  Transform,
  get TransformError() {
    return TransformError;
  },
  canJoin,
  canSplit,
  dropPoint,
  findWrapping,
  insertPoint,
  joinPoint,
  liftTarget,
  replaceStep
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
var hasRequiredDist$4;
function requireDist$4() {
  if (hasRequiredDist$4)
    return dist$4;
  hasRequiredDist$4 = 1;
  function lr(Oi) {
    "@babel/helpers - typeof";
    return lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Mi) {
      return typeof Mi;
    } : function(Mi) {
      return Mi && typeof Symbol == "function" && Mi.constructor === Symbol && Mi !== Symbol.prototype ? "symbol" : typeof Mi;
    }, lr(Oi);
  }
  function ar() {
    return typeof Reflect != "undefined" && Reflect.get ? ar = Reflect.get : ar = function(Mi, Ii, mi) {
      var _i = cr(Mi, Ii);
      if (_i) {
        var Ci = Object.getOwnPropertyDescriptor(_i, Ii);
        return Ci.get ? Ci.get.call(arguments.length < 3 ? Mi : mi) : Ci.value;
      }
    }, ar.apply(this, arguments);
  }
  function cr(Oi, Mi) {
    for (; !Object.prototype.hasOwnProperty.call(Oi, Mi) && (Oi = mr(Oi), Oi !== null); )
      ;
    return Oi;
  }
  function ur(Oi, Mi) {
    if (typeof Mi != "function" && Mi !== null)
      throw new TypeError("Super expression must either be null or a function");
    Oi.prototype = Object.create(Mi && Mi.prototype, { constructor: { value: Oi, writable: !0, configurable: !0 } }), Object.defineProperty(Oi, "prototype", { writable: !1 }), Mi && fr(Oi, Mi);
  }
  function fr(Oi, Mi) {
    return fr = Object.setPrototypeOf || function(mi, _i) {
      return mi.__proto__ = _i, mi;
    }, fr(Oi, Mi);
  }
  function dr(Oi) {
    var Mi = vr();
    return function() {
      var mi = mr(Oi), _i;
      if (Mi) {
        var Ci = mr(this).constructor;
        _i = Reflect.construct(mi, arguments, Ci);
      } else
        _i = mi.apply(this, arguments);
      return hr(this, _i);
    };
  }
  function hr(Oi, Mi) {
    if (Mi && (lr(Mi) === "object" || typeof Mi == "function"))
      return Mi;
    if (Mi !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return gr(Oi);
  }
  function gr(Oi) {
    if (Oi === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Oi;
  }
  function vr() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (Oi) {
      return !1;
    }
  }
  function mr(Oi) {
    return mr = Object.setPrototypeOf ? Object.getPrototypeOf : function(Ii) {
      return Ii.__proto__ || Object.getPrototypeOf(Ii);
    }, mr(Oi);
  }
  function br(Oi, Mi) {
    if (!(Oi instanceof Mi))
      throw new TypeError("Cannot call a class as a function");
  }
  function yr(Oi, Mi) {
    for (var Ii = 0; Ii < Mi.length; Ii++) {
      var mi = Mi[Ii];
      mi.enumerable = mi.enumerable || !1, mi.configurable = !0, "value" in mi && (mi.writable = !0), Object.defineProperty(Oi, mi.key, mi);
    }
  }
  function kr(Oi, Mi, Ii) {
    return Mi && yr(Oi.prototype, Mi), Ii && yr(Oi, Ii), Object.defineProperty(Oi, "prototype", { writable: !1 }), Oi;
  }
  Object.defineProperty(dist$4, "__esModule", {
    value: !0
  });
  var Tr = requireDist$5(), _r = require$$1$2, Er = /* @__PURE__ */ Object.create(null), xr = function() {
    function Oi(Mi, Ii, mi) {
      br(this, Oi), this.$anchor = Mi, this.$head = Ii, this.ranges = mi || [new Cr(Mi.min(Ii), Mi.max(Ii))];
    }
    return kr(Oi, [{
      key: "anchor",
      get: function() {
        return this.$anchor.pos;
      }
    }, {
      key: "head",
      get: function() {
        return this.$head.pos;
      }
    }, {
      key: "from",
      get: function() {
        return this.$from.pos;
      }
    }, {
      key: "to",
      get: function() {
        return this.$to.pos;
      }
    }, {
      key: "$from",
      get: function() {
        return this.ranges[0].$from;
      }
    }, {
      key: "$to",
      get: function() {
        return this.ranges[0].$to;
      }
    }, {
      key: "empty",
      get: function() {
        for (var Ii = this.ranges, mi = 0; mi < Ii.length; mi++)
          if (Ii[mi].$from.pos != Ii[mi].$to.pos)
            return !1;
        return !0;
      }
    }, {
      key: "content",
      value: function() {
        return this.$from.doc.slice(this.from, this.to, !0);
      }
    }, {
      key: "replace",
      value: function(Ii) {
        for (var mi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tr.Slice.empty, _i = mi.content.lastChild, Ci = null, Ki = 0; Ki < mi.openEnd; Ki++)
          Ci = _i, _i = _i.lastChild;
        for (var Ni = Ii.steps.length, ia = this.ranges, ea = 0; ea < ia.length; ea++) {
          var la = ia[ea], ma = la.$from, Ba = la.$to, Fa = Ii.mapping.slice(Ni);
          Ii.replaceRange(Fa.map(ma.pos), Fa.map(Ba.pos), ea ? Tr.Slice.empty : mi), ea == 0 && Jr(Ii, Ni, (_i ? _i.isInline : Ci && Ci.isTextblock) ? -1 : 1);
        }
      }
    }, {
      key: "replaceWith",
      value: function(Ii, mi) {
        for (var _i = Ii.steps.length, Ci = this.ranges, Ki = 0; Ki < Ci.length; Ki++) {
          var Ni = Ci[Ki], ia = Ni.$from, ea = Ni.$to, la = Ii.mapping.slice(_i), ma = la.map(ia.pos), Ba = la.map(ea.pos);
          Ki ? Ii.deleteRange(ma, Ba) : (Ii.replaceRangeWith(ma, Ba, mi), Jr(Ii, _i, mi.isInline ? -1 : 1));
        }
      }
    }, {
      key: "getBookmark",
      value: function() {
        return Dr.between(this.$anchor, this.$head).getBookmark();
      }
    }], [{
      key: "findFrom",
      value: function(Ii, mi) {
        var _i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, Ci = Ii.parent.inlineContent ? new Dr(Ii) : oi(Ii.node(0), Ii.parent, Ii.pos, Ii.index(), mi, _i);
        if (Ci)
          return Ci;
        for (var Ki = Ii.depth - 1; Ki >= 0; Ki--) {
          var Ni = mi < 0 ? oi(Ii.node(0), Ii.node(Ki), Ii.before(Ki + 1), Ii.index(Ki), mi, _i) : oi(Ii.node(0), Ii.node(Ki), Ii.after(Ki + 1), Ii.index(Ki) + 1, mi, _i);
          if (Ni)
            return Ni;
        }
        return null;
      }
    }, {
      key: "near",
      value: function(Ii) {
        var mi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return this.findFrom(Ii, mi) || this.findFrom(Ii, -mi) || new Wr(Ii.node(0));
      }
    }, {
      key: "atStart",
      value: function(Ii) {
        return oi(Ii, Ii, 0, 0, 1) || new Wr(Ii);
      }
    }, {
      key: "atEnd",
      value: function(Ii) {
        return oi(Ii, Ii, Ii.content.size, Ii.childCount, -1) || new Wr(Ii);
      }
    }, {
      key: "fromJSON",
      value: function(Ii, mi) {
        if (!mi || !mi.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        var _i = Er[mi.type];
        if (!_i)
          throw new RangeError("No selection type ".concat(mi.type, " defined"));
        return _i.fromJSON(Ii, mi);
      }
    }, {
      key: "jsonID",
      value: function(Ii, mi) {
        if (Ii in Er)
          throw new RangeError("Duplicate use of selection JSON ID " + Ii);
        return Er[Ii] = mi, mi.prototype.jsonID = Ii, mi;
      }
    }]), Oi;
  }();
  xr.prototype.visible = !0;
  var Cr = kr(function Oi(Mi, Ii) {
    br(this, Oi), this.$from = Mi, this.$to = Ii;
  }), Ar = !1;
  function Lr(Oi) {
    !Ar && !Oi.parent.inlineContent && (Ar = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + Oi.parent.type.name + ")"));
  }
  var Dr = function(Oi) {
    ur(Ii, Oi);
    var Mi = dr(Ii);
    function Ii(mi) {
      var _i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mi;
      return br(this, Ii), Lr(mi), Lr(_i), Mi.call(this, mi, _i);
    }
    return kr(Ii, [{
      key: "$cursor",
      get: function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
    }, {
      key: "map",
      value: function(_i, Ci) {
        var Ki = _i.resolve(Ci.map(this.head));
        if (!Ki.parent.inlineContent)
          return xr.near(Ki);
        var Ni = _i.resolve(Ci.map(this.anchor));
        return new Ii(Ni.parent.inlineContent ? Ni : Ki, Ki);
      }
    }, {
      key: "replace",
      value: function(_i) {
        var Ci = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tr.Slice.empty;
        if (ar(mr(Ii.prototype), "replace", this).call(this, _i, Ci), Ci == Tr.Slice.empty) {
          var Ki = this.$from.marksAcross(this.$to);
          Ki && _i.ensureMarks(Ki);
        }
      }
    }, {
      key: "eq",
      value: function(_i) {
        return _i instanceof Ii && _i.anchor == this.anchor && _i.head == this.head;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new Nr(this.anchor, this.head);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "text",
          anchor: this.anchor,
          head: this.head
        };
      }
    }], [{
      key: "fromJSON",
      value: function(_i, Ci) {
        if (typeof Ci.anchor != "number" || typeof Ci.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new Ii(_i.resolve(Ci.anchor), _i.resolve(Ci.head));
      }
    }, {
      key: "create",
      value: function(_i, Ci) {
        var Ki = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ci, Ni = _i.resolve(Ci);
        return new this(Ni, Ki == Ci ? Ni : _i.resolve(Ki));
      }
    }, {
      key: "between",
      value: function(_i, Ci, Ki) {
        var Ni = _i.pos - Ci.pos;
        if ((!Ki || Ni) && (Ki = Ni >= 0 ? 1 : -1), !Ci.parent.inlineContent) {
          var ia = xr.findFrom(Ci, Ki, !0) || xr.findFrom(Ci, -Ki, !0);
          if (ia)
            Ci = ia.$head;
          else
            return xr.near(Ci, Ki);
        }
        return _i.parent.inlineContent || (Ni == 0 ? _i = Ci : (_i = (xr.findFrom(_i, -Ki, !0) || xr.findFrom(_i, Ki, !0)).$anchor, _i.pos < Ci.pos != Ni < 0 && (_i = Ci))), new Ii(_i, Ci);
      }
    }]), Ii;
  }(xr);
  xr.jsonID("text", Dr);
  var Nr = function() {
    function Oi(Mi, Ii) {
      br(this, Oi), this.anchor = Mi, this.head = Ii;
    }
    return kr(Oi, [{
      key: "map",
      value: function(Ii) {
        return new Oi(Ii.map(this.anchor), Ii.map(this.head));
      }
    }, {
      key: "resolve",
      value: function(Ii) {
        return Dr.between(Ii.resolve(this.anchor), Ii.resolve(this.head));
      }
    }]), Oi;
  }(), Hr = function(Oi) {
    ur(Ii, Oi);
    var Mi = dr(Ii);
    function Ii(mi) {
      var _i;
      br(this, Ii);
      var Ci = mi.nodeAfter, Ki = mi.node(0).resolve(mi.pos + Ci.nodeSize);
      return _i = Mi.call(this, mi, Ki), _i.node = Ci, _i;
    }
    return kr(Ii, [{
      key: "map",
      value: function(_i, Ci) {
        var Ki = Ci.mapResult(this.anchor), Ni = Ki.deleted, ia = Ki.pos, ea = _i.resolve(ia);
        return Ni ? xr.near(ea) : new Ii(ea);
      }
    }, {
      key: "content",
      value: function() {
        return new Tr.Slice(Tr.Fragment.from(this.node), 0, 0);
      }
    }, {
      key: "eq",
      value: function(_i) {
        return _i instanceof Ii && _i.anchor == this.anchor;
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "node",
          anchor: this.anchor
        };
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new $r(this.anchor);
      }
    }], [{
      key: "fromJSON",
      value: function(_i, Ci) {
        if (typeof Ci.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new Ii(_i.resolve(Ci.anchor));
      }
    }, {
      key: "create",
      value: function(_i, Ci) {
        return new Ii(_i.resolve(Ci));
      }
    }, {
      key: "isSelectable",
      value: function(_i) {
        return !_i.isText && _i.type.spec.selectable !== !1;
      }
    }]), Ii;
  }(xr);
  Hr.prototype.visible = !1, xr.jsonID("node", Hr);
  var $r = function() {
    function Oi(Mi) {
      br(this, Oi), this.anchor = Mi;
    }
    return kr(Oi, [{
      key: "map",
      value: function(Ii) {
        var mi = Ii.mapResult(this.anchor), _i = mi.deleted, Ci = mi.pos;
        return _i ? new Nr(Ci, Ci) : new Oi(Ci);
      }
    }, {
      key: "resolve",
      value: function(Ii) {
        var mi = Ii.resolve(this.anchor), _i = mi.nodeAfter;
        return _i && Hr.isSelectable(_i) ? new Hr(mi) : xr.near(mi);
      }
    }]), Oi;
  }(), Wr = function(Oi) {
    ur(Ii, Oi);
    var Mi = dr(Ii);
    function Ii(mi) {
      return br(this, Ii), Mi.call(this, mi.resolve(0), mi.resolve(mi.content.size));
    }
    return kr(Ii, [{
      key: "replace",
      value: function(_i) {
        var Ci = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tr.Slice.empty;
        if (Ci == Tr.Slice.empty) {
          _i.delete(0, _i.doc.content.size);
          var Ki = xr.atStart(_i.doc);
          Ki.eq(_i.selection) || _i.setSelection(Ki);
        } else
          ar(mr(Ii.prototype), "replace", this).call(this, _i, Ci);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "all"
        };
      }
    }, {
      key: "map",
      value: function(_i) {
        return new Ii(_i);
      }
    }, {
      key: "eq",
      value: function(_i) {
        return _i instanceof Ii;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return Zr;
      }
    }], [{
      key: "fromJSON",
      value: function(_i) {
        return new Ii(_i);
      }
    }]), Ii;
  }(xr);
  xr.jsonID("all", Wr);
  var Zr = {
    map: function() {
      return this;
    },
    resolve: function(Mi) {
      return new Wr(Mi);
    }
  };
  function oi(Oi, Mi, Ii, mi, _i) {
    var Ci = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
    if (Mi.inlineContent)
      return Dr.create(Oi, Ii);
    for (var Ki = mi - (_i > 0 ? 0 : 1); _i > 0 ? Ki < Mi.childCount : Ki >= 0; Ki += _i) {
      var Ni = Mi.child(Ki);
      if (Ni.isAtom) {
        if (!Ci && Hr.isSelectable(Ni))
          return Hr.create(Oi, Ii - (_i < 0 ? Ni.nodeSize : 0));
      } else {
        var ia = oi(Oi, Ni, Ii + _i, _i < 0 ? Ni.childCount : 0, _i, Ci);
        if (ia)
          return ia;
      }
      Ii += Ni.nodeSize * _i;
    }
    return null;
  }
  function Jr(Oi, Mi, Ii) {
    var mi = Oi.steps.length - 1;
    if (!(mi < Mi)) {
      var _i = Oi.steps[mi];
      if (_i instanceof _r.ReplaceStep || _i instanceof _r.ReplaceAroundStep) {
        var Ci = Oi.mapping.maps[mi], Ki;
        Ci.forEach(function(Ni, ia, ea, la) {
          Ki == null && (Ki = la);
        }), Oi.setSelection(xr.near(Oi.doc.resolve(Ki), Ii));
      }
    }
  }
  var Yr = 1, li = 2, Si = 4, ci = function(Oi) {
    ur(Ii, Oi);
    var Mi = dr(Ii);
    function Ii(mi) {
      var _i;
      return br(this, Ii), _i = Mi.call(this, mi.doc), _i.curSelectionFor = 0, _i.updated = 0, _i.meta = /* @__PURE__ */ Object.create(null), _i.time = Date.now(), _i.curSelection = mi.selection, _i.storedMarks = mi.storedMarks, _i;
    }
    return kr(Ii, [{
      key: "selection",
      get: function() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
    }, {
      key: "setSelection",
      value: function(_i) {
        if (_i.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = _i, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Yr) & ~li, this.storedMarks = null, this;
      }
    }, {
      key: "selectionSet",
      get: function() {
        return (this.updated & Yr) > 0;
      }
    }, {
      key: "setStoredMarks",
      value: function(_i) {
        return this.storedMarks = _i, this.updated |= li, this;
      }
    }, {
      key: "ensureMarks",
      value: function(_i) {
        return Tr.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), _i) || this.setStoredMarks(_i), this;
      }
    }, {
      key: "addStoredMark",
      value: function(_i) {
        return this.ensureMarks(_i.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "removeStoredMark",
      value: function(_i) {
        return this.ensureMarks(_i.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "storedMarksSet",
      get: function() {
        return (this.updated & li) > 0;
      }
    }, {
      key: "addStep",
      value: function(_i, Ci) {
        ar(mr(Ii.prototype), "addStep", this).call(this, _i, Ci), this.updated = this.updated & ~li, this.storedMarks = null;
      }
    }, {
      key: "setTime",
      value: function(_i) {
        return this.time = _i, this;
      }
    }, {
      key: "replaceSelection",
      value: function(_i) {
        return this.selection.replace(this, _i), this;
      }
    }, {
      key: "replaceSelectionWith",
      value: function(_i) {
        var Ci = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Ki = this.selection;
        return Ci && (_i = _i.mark(this.storedMarks || (Ki.empty ? Ki.$from.marks() : Ki.$from.marksAcross(Ki.$to) || Tr.Mark.none))), Ki.replaceWith(this, _i), this;
      }
    }, {
      key: "deleteSelection",
      value: function() {
        return this.selection.replace(this), this;
      }
    }, {
      key: "insertText",
      value: function(_i, Ci, Ki) {
        var Ni = this.doc.type.schema;
        if (Ci == null)
          return _i ? this.replaceSelectionWith(Ni.text(_i), !0) : this.deleteSelection();
        if (Ki == null && (Ki = Ci), Ki = Ki == null ? Ci : Ki, !_i)
          return this.deleteRange(Ci, Ki);
        var ia = this.storedMarks;
        if (!ia) {
          var ea = this.doc.resolve(Ci);
          ia = Ki == Ci ? ea.marks() : ea.marksAcross(this.doc.resolve(Ki));
        }
        return this.replaceRangeWith(Ci, Ki, Ni.text(_i, ia)), this.selection.empty || this.setSelection(xr.near(this.selection.$to)), this;
      }
    }, {
      key: "setMeta",
      value: function(_i, Ci) {
        return this.meta[typeof _i == "string" ? _i : _i.key] = Ci, this;
      }
    }, {
      key: "getMeta",
      value: function(_i) {
        return this.meta[typeof _i == "string" ? _i : _i.key];
      }
    }, {
      key: "isGeneric",
      get: function() {
        for (var _i in this.meta)
          return !1;
        return !0;
      }
    }, {
      key: "scrollIntoView",
      value: function() {
        return this.updated |= Si, this;
      }
    }, {
      key: "scrolledIntoView",
      get: function() {
        return (this.updated & Si) > 0;
      }
    }]), Ii;
  }(_r.Transform);
  function hi(Oi, Mi) {
    return !Mi || !Oi ? Oi : Oi.bind(Mi);
  }
  var Ei = kr(function Oi(Mi, Ii, mi) {
    br(this, Oi), this.name = Mi, this.init = hi(Ii.init, mi), this.apply = hi(Ii.apply, mi);
  }), di = [new Ei("doc", {
    init: function(Mi) {
      return Mi.doc || Mi.schema.topNodeType.createAndFill();
    },
    apply: function(Mi) {
      return Mi.doc;
    }
  }), new Ei("selection", {
    init: function(Mi, Ii) {
      return Mi.selection || xr.atStart(Ii.doc);
    },
    apply: function(Mi) {
      return Mi.selection;
    }
  }), new Ei("storedMarks", {
    init: function(Mi) {
      return Mi.storedMarks || null;
    },
    apply: function(Mi, Ii, mi, _i) {
      return _i.selection.$cursor ? Mi.storedMarks : null;
    }
  }), new Ei("scrollToSelection", {
    init: function() {
      return 0;
    },
    apply: function(Mi, Ii) {
      return Mi.scrolledIntoView ? Ii + 1 : Ii;
    }
  })], gi = kr(function Oi(Mi, Ii) {
    var mi = this;
    br(this, Oi), this.schema = Mi, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = di.slice(), Ii && Ii.forEach(function(_i) {
      if (mi.pluginsByKey[_i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + _i.key + ")");
      mi.plugins.push(_i), mi.pluginsByKey[_i.key] = _i, _i.spec.state && mi.fields.push(new Ei(_i.key, _i.spec.state, _i));
    });
  }), Li = function() {
    function Oi(Mi) {
      br(this, Oi), this.config = Mi;
    }
    return kr(Oi, [{
      key: "schema",
      get: function() {
        return this.config.schema;
      }
    }, {
      key: "plugins",
      get: function() {
        return this.config.plugins;
      }
    }, {
      key: "apply",
      value: function(Ii) {
        return this.applyTransaction(Ii).state;
      }
    }, {
      key: "filterTransaction",
      value: function(Ii) {
        for (var mi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, _i = 0; _i < this.config.plugins.length; _i++)
          if (_i != mi) {
            var Ci = this.config.plugins[_i];
            if (Ci.spec.filterTransaction && !Ci.spec.filterTransaction.call(Ci, Ii, this))
              return !1;
          }
        return !0;
      }
    }, {
      key: "applyTransaction",
      value: function(Ii) {
        if (!this.filterTransaction(Ii))
          return {
            state: this,
            transactions: []
          };
        for (var mi = [Ii], _i = this.applyInner(Ii), Ci = null; ; ) {
          for (var Ki = !1, Ni = 0; Ni < this.config.plugins.length; Ni++) {
            var ia = this.config.plugins[Ni];
            if (ia.spec.appendTransaction) {
              var ea = Ci ? Ci[Ni].n : 0, la = Ci ? Ci[Ni].state : this, ma = ea < mi.length && ia.spec.appendTransaction.call(ia, ea ? mi.slice(ea) : mi, la, _i);
              if (ma && _i.filterTransaction(ma, Ni)) {
                if (ma.setMeta("appendedTransaction", Ii), !Ci) {
                  Ci = [];
                  for (var Ba = 0; Ba < this.config.plugins.length; Ba++)
                    Ci.push(Ba < Ni ? {
                      state: _i,
                      n: mi.length
                    } : {
                      state: this,
                      n: 0
                    });
                }
                mi.push(ma), _i = _i.applyInner(ma), Ki = !0;
              }
              Ci && (Ci[Ni] = {
                state: _i,
                n: mi.length
              });
            }
          }
          if (!Ki)
            return {
              state: _i,
              transactions: mi
            };
        }
      }
    }, {
      key: "applyInner",
      value: function(Ii) {
        if (!Ii.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        for (var mi = new Oi(this.config), _i = this.config.fields, Ci = 0; Ci < _i.length; Ci++) {
          var Ki = _i[Ci];
          mi[Ki.name] = Ki.apply(Ii, this[Ki.name], this, mi);
        }
        return mi;
      }
    }, {
      key: "tr",
      get: function() {
        return new ci(this);
      }
    }, {
      key: "reconfigure",
      value: function(Ii) {
        for (var mi = new gi(this.schema, Ii.plugins), _i = mi.fields, Ci = new Oi(mi), Ki = 0; Ki < _i.length; Ki++) {
          var Ni = _i[Ki].name;
          Ci[Ni] = this.hasOwnProperty(Ni) ? this[Ni] : _i[Ki].init(Ii, Ci);
        }
        return Ci;
      }
    }, {
      key: "toJSON",
      value: function(Ii) {
        var mi = {
          doc: this.doc.toJSON(),
          selection: this.selection.toJSON()
        };
        if (this.storedMarks && (mi.storedMarks = this.storedMarks.map(function(Ni) {
          return Ni.toJSON();
        })), Ii && lr(Ii) == "object")
          for (var _i in Ii) {
            if (_i == "doc" || _i == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            var Ci = Ii[_i], Ki = Ci.spec.state;
            Ki && Ki.toJSON && (mi[_i] = Ki.toJSON.call(Ci, this[Ci.key]));
          }
        return mi;
      }
    }], [{
      key: "create",
      value: function(Ii) {
        for (var mi = new gi(Ii.doc ? Ii.doc.type.schema : Ii.schema, Ii.plugins), _i = new Oi(mi), Ci = 0; Ci < mi.fields.length; Ci++)
          _i[mi.fields[Ci].name] = mi.fields[Ci].init(Ii, _i);
        return _i;
      }
    }, {
      key: "fromJSON",
      value: function(Ii, mi, _i) {
        if (!mi)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!Ii.schema)
          throw new RangeError("Required config field 'schema' missing");
        var Ci = new gi(Ii.schema, Ii.plugins), Ki = new Oi(Ci);
        return Ci.fields.forEach(function(Ni) {
          if (Ni.name == "doc")
            Ki.doc = Tr.Node.fromJSON(Ii.schema, mi.doc);
          else if (Ni.name == "selection")
            Ki.selection = xr.fromJSON(Ki.doc, mi.selection);
          else if (Ni.name == "storedMarks")
            mi.storedMarks && (Ki.storedMarks = mi.storedMarks.map(Ii.schema.markFromJSON));
          else {
            if (_i)
              for (var ia in _i) {
                var ea = _i[ia], la = ea.spec.state;
                if (ea.key == Ni.name && la && la.fromJSON && Object.prototype.hasOwnProperty.call(mi, ia)) {
                  Ki[Ni.name] = la.fromJSON.call(ea, Ii, mi[ia], Ki);
                  return;
                }
              }
            Ki[Ni.name] = Ni.init(Ii, Ki);
          }
        }), Ki;
      }
    }]), Oi;
  }();
  function ui(Oi, Mi, Ii) {
    for (var mi in Oi) {
      var _i = Oi[mi];
      _i instanceof Function ? _i = _i.bind(Mi) : mi == "handleDOMEvents" && (_i = ui(_i, Mi, {})), Ii[mi] = _i;
    }
    return Ii;
  }
  var wi = function() {
    function Oi(Mi) {
      br(this, Oi), this.spec = Mi, this.props = {}, Mi.props && ui(Mi.props, this, this.props), this.key = Mi.key ? Mi.key.key : yi("plugin");
    }
    return kr(Oi, [{
      key: "getState",
      value: function(Ii) {
        return Ii[this.key];
      }
    }]), Oi;
  }(), Ui = /* @__PURE__ */ Object.create(null);
  function yi(Oi) {
    return Oi in Ui ? Oi + "$" + ++Ui[Oi] : (Ui[Oi] = 0, Oi + "$");
  }
  var Vi = function() {
    function Oi() {
      var Mi = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
      br(this, Oi), this.key = yi(Mi);
    }
    return kr(Oi, [{
      key: "get",
      value: function(Ii) {
        return Ii.config.pluginsByKey[this.key];
      }
    }, {
      key: "getState",
      value: function(Ii) {
        return Ii[this.key];
      }
    }]), Oi;
  }();
  return dist$4.AllSelection = Wr, dist$4.EditorState = Li, dist$4.NodeSelection = Hr, dist$4.Plugin = wi, dist$4.PluginKey = Vi, dist$4.Selection = xr, dist$4.SelectionRange = Cr, dist$4.TextSelection = Dr, dist$4.Transaction = ci, dist$4;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3)
    return dist$5;
  hasRequiredDist$3 = 1;
  function lr(Sr) {
    "@babel/helpers - typeof";
    return lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(qr) {
      return typeof qr;
    } : function(qr) {
      return qr && typeof Symbol == "function" && qr.constructor === Symbol && qr !== Symbol.prototype ? "symbol" : typeof qr;
    }, lr(Sr);
  }
  function ar(Sr, qr) {
    var Ir = typeof Symbol != "undefined" && Sr[Symbol.iterator] || Sr["@@iterator"];
    if (!Ir) {
      if (Array.isArray(Sr) || (Ir = cr(Sr)) || qr && Sr && typeof Sr.length == "number") {
        Ir && (Sr = Ir);
        var Ur = 0, jr = function() {
        };
        return { s: jr, n: function() {
          return Ur >= Sr.length ? { done: !0 } : { done: !1, value: Sr[Ur++] };
        }, e: function(ki) {
          throw ki;
        }, f: jr };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Vr = !0, ei = !1, ti;
    return { s: function() {
      Ir = Ir.call(Sr);
    }, n: function() {
      var ki = Ir.next();
      return Vr = ki.done, ki;
    }, e: function(ki) {
      ei = !0, ti = ki;
    }, f: function() {
      try {
        !Vr && Ir.return != null && Ir.return();
      } finally {
        if (ei)
          throw ti;
      }
    } };
  }
  function cr(Sr, qr) {
    if (Sr) {
      if (typeof Sr == "string")
        return ur(Sr, qr);
      var Ir = Object.prototype.toString.call(Sr).slice(8, -1);
      if (Ir === "Object" && Sr.constructor && (Ir = Sr.constructor.name), Ir === "Map" || Ir === "Set")
        return Array.from(Sr);
      if (Ir === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Ir))
        return ur(Sr, qr);
    }
  }
  function ur(Sr, qr) {
    (qr == null || qr > Sr.length) && (qr = Sr.length);
    for (var Ir = 0, Ur = new Array(qr); Ir < qr; Ir++)
      Ur[Ir] = Sr[Ir];
    return Ur;
  }
  function fr() {
    return typeof Reflect != "undefined" && Reflect.get ? fr = Reflect.get : fr = function(qr, Ir, Ur) {
      var jr = dr(qr, Ir);
      if (jr) {
        var Vr = Object.getOwnPropertyDescriptor(jr, Ir);
        return Vr.get ? Vr.get.call(arguments.length < 3 ? qr : Ur) : Vr.value;
      }
    }, fr.apply(this, arguments);
  }
  function dr(Sr, qr) {
    for (; !Object.prototype.hasOwnProperty.call(Sr, qr) && (Sr = kr(Sr), Sr !== null); )
      ;
    return Sr;
  }
  function hr(Sr, qr) {
    if (typeof qr != "function" && qr !== null)
      throw new TypeError("Super expression must either be null or a function");
    Sr.prototype = Object.create(qr && qr.prototype, { constructor: { value: Sr, writable: !0, configurable: !0 } }), Object.defineProperty(Sr, "prototype", { writable: !1 }), qr && gr(Sr, qr);
  }
  function gr(Sr, qr) {
    return gr = Object.setPrototypeOf || function(Ur, jr) {
      return Ur.__proto__ = jr, Ur;
    }, gr(Sr, qr);
  }
  function vr(Sr) {
    var qr = yr();
    return function() {
      var Ur = kr(Sr), jr;
      if (qr) {
        var Vr = kr(this).constructor;
        jr = Reflect.construct(Ur, arguments, Vr);
      } else
        jr = Ur.apply(this, arguments);
      return mr(this, jr);
    };
  }
  function mr(Sr, qr) {
    if (qr && (lr(qr) === "object" || typeof qr == "function"))
      return qr;
    if (qr !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return br(Sr);
  }
  function br(Sr) {
    if (Sr === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Sr;
  }
  function yr() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (Sr) {
      return !1;
    }
  }
  function kr(Sr) {
    return kr = Object.setPrototypeOf ? Object.getPrototypeOf : function(Ir) {
      return Ir.__proto__ || Object.getPrototypeOf(Ir);
    }, kr(Sr);
  }
  function Tr(Sr, qr) {
    if (!(Sr instanceof qr))
      throw new TypeError("Cannot call a class as a function");
  }
  function _r(Sr, qr) {
    for (var Ir = 0; Ir < qr.length; Ir++) {
      var Ur = qr[Ir];
      Ur.enumerable = Ur.enumerable || !1, Ur.configurable = !0, "value" in Ur && (Ur.writable = !0), Object.defineProperty(Sr, Ur.key, Ur);
    }
  }
  function Er(Sr, qr, Ir) {
    return qr && _r(Sr.prototype, qr), Ir && _r(Sr, Ir), Object.defineProperty(Sr, "prototype", { writable: !1 }), Sr;
  }
  var xr = requireDist$4(), Cr = requireDist$5(), Ar = require$$1$2, Lr = function(qr) {
    for (var Ir = 0; ; Ir++)
      if (qr = qr.previousSibling, !qr)
        return Ir;
  }, Dr = function(qr) {
    var Ir = qr.assignedSlot || qr.parentNode;
    return Ir && Ir.nodeType == 11 ? Ir.host : Ir;
  }, Nr = null, Hr = function(qr, Ir, Ur) {
    var jr = Nr || (Nr = document.createRange());
    return jr.setEnd(qr, Ur == null ? qr.nodeValue.length : Ur), jr.setStart(qr, Ir || 0), jr;
  }, $r = function(qr, Ir, Ur, jr) {
    return Ur && (Zr(qr, Ir, Ur, jr, -1) || Zr(qr, Ir, Ur, jr, 1));
  }, Wr = /^(img|br|input|textarea|hr)$/i;
  function Zr(Sr, qr, Ir, Ur, jr) {
    for (; ; ) {
      if (Sr == Ir && qr == Ur)
        return !0;
      if (qr == (jr < 0 ? 0 : oi(Sr))) {
        var Vr = Sr.parentNode;
        if (!Vr || Vr.nodeType != 1 || Yr(Sr) || Wr.test(Sr.nodeName) || Sr.contentEditable == "false")
          return !1;
        qr = Lr(Sr) + (jr < 0 ? 0 : 1), Sr = Vr;
      } else if (Sr.nodeType == 1) {
        if (Sr = Sr.childNodes[qr + (jr < 0 ? -1 : 0)], Sr.contentEditable == "false")
          return !1;
        qr = jr < 0 ? oi(Sr) : 0;
      } else
        return !1;
    }
  }
  function oi(Sr) {
    return Sr.nodeType == 3 ? Sr.nodeValue.length : Sr.childNodes.length;
  }
  function Jr(Sr, qr, Ir) {
    for (var Ur = qr == 0, jr = qr == oi(Sr); Ur || jr; ) {
      if (Sr == Ir)
        return !0;
      var Vr = Lr(Sr);
      if (Sr = Sr.parentNode, !Sr)
        return !1;
      Ur = Ur && Vr == 0, jr = jr && Vr == oi(Sr);
    }
  }
  function Yr(Sr) {
    for (var qr, Ir = Sr; Ir && !(qr = Ir.pmViewDesc); Ir = Ir.parentNode)
      ;
    return qr && qr.node && qr.node.isBlock && (qr.dom == Sr || qr.contentDOM == Sr);
  }
  var li = function(qr) {
    return qr.focusNode && $r(qr.focusNode, qr.focusOffset, qr.anchorNode, qr.anchorOffset);
  };
  function Si(Sr, qr) {
    var Ir = document.createEvent("Event");
    return Ir.initEvent("keydown", !0, !0), Ir.keyCode = Sr, Ir.key = Ir.code = qr, Ir;
  }
  function ci(Sr) {
    for (var qr = Sr.activeElement; qr && qr.shadowRoot; )
      qr = qr.shadowRoot.activeElement;
    return qr;
  }
  function hi(Sr, qr, Ir) {
    if (Sr.caretPositionFromPoint)
      try {
        var Ur = Sr.caretPositionFromPoint(qr, Ir);
        if (Ur)
          return {
            node: Ur.offsetNode,
            offset: Ur.offset
          };
      } catch (Vr) {
      }
    if (Sr.caretRangeFromPoint) {
      var jr = Sr.caretRangeFromPoint(qr, Ir);
      if (jr)
        return {
          node: jr.startContainer,
          offset: jr.startOffset
        };
    }
  }
  var Ei = typeof navigator != "undefined" ? navigator : null, di = typeof document != "undefined" ? document : null, gi = Ei && Ei.userAgent || "", Li = /Edge\/(\d+)/.exec(gi), ui = /MSIE \d/.exec(gi), wi = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gi), Ui = !!(ui || wi || Li), yi = ui ? document.documentMode : wi ? +wi[1] : Li ? +Li[1] : 0, Vi = !Ui && /gecko\/(\d+)/i.test(gi);
  Vi && +(/Firefox\/(\d+)/.exec(gi) || [0, 0])[1];
  var Oi = !Ui && /Chrome\/(\d+)/.exec(gi), Mi = !!Oi, Ii = Oi ? +Oi[1] : 0, mi = !Ui && !!Ei && /Apple Computer/.test(Ei.vendor), _i = mi && (/Mobile\/\w+/.test(gi) || !!Ei && Ei.maxTouchPoints > 2), Ci = _i || (Ei ? /Mac/.test(Ei.platform) : !1), Ki = Ei ? /Win/.test(Ei.platform) : !1, Ni = /Android \d/.test(gi), ia = !!di && "webkitFontSmoothing" in di.documentElement.style, ea = ia ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function la(Sr) {
    return {
      left: 0,
      right: Sr.documentElement.clientWidth,
      top: 0,
      bottom: Sr.documentElement.clientHeight
    };
  }
  function ma(Sr, qr) {
    return typeof Sr == "number" ? Sr : Sr[qr];
  }
  function Ba(Sr) {
    var qr = Sr.getBoundingClientRect(), Ir = qr.width / Sr.offsetWidth || 1, Ur = qr.height / Sr.offsetHeight || 1;
    return {
      left: qr.left,
      right: qr.left + Sr.clientWidth * Ir,
      top: qr.top,
      bottom: qr.top + Sr.clientHeight * Ur
    };
  }
  function Fa(Sr, qr, Ir) {
    for (var Ur = Sr.someProp("scrollThreshold") || 0, jr = Sr.someProp("scrollMargin") || 5, Vr = Sr.dom.ownerDocument, ei = Ir || Sr.dom; ei; ei = Dr(ei))
      if (ei.nodeType == 1) {
        var ti = ei, fi = ti == Vr.body, ki = fi ? la(Vr) : Ba(ti), Ri = 0, ji = 0;
        if (qr.top < ki.top + ma(Ur, "top") ? ji = -(ki.top - qr.top + ma(jr, "top")) : qr.bottom > ki.bottom - ma(Ur, "bottom") && (ji = qr.bottom - qr.top > ki.bottom - ki.top ? qr.top + ma(jr, "top") - ki.top : qr.bottom - ki.bottom + ma(jr, "bottom")), qr.left < ki.left + ma(Ur, "left") ? Ri = -(ki.left - qr.left + ma(jr, "left")) : qr.right > ki.right - ma(Ur, "right") && (Ri = qr.right - ki.right + ma(jr, "right")), Ri || ji)
          if (fi)
            Vr.defaultView.scrollBy(Ri, ji);
          else {
            var Bi = ti.scrollLeft, Qi = ti.scrollTop;
            ji && (ti.scrollTop += ji), Ri && (ti.scrollLeft += Ri);
            var na = ti.scrollLeft - Bi, Ea = ti.scrollTop - Qi;
            qr = {
              left: qr.left - na,
              top: qr.top - Ea,
              right: qr.right - na,
              bottom: qr.bottom - Ea
            };
          }
        if (fi || /^(fixed|sticky)$/.test(getComputedStyle(ei).position))
          break;
      }
  }
  function Ia(Sr) {
    for (var qr = Sr.dom.getBoundingClientRect(), Ir = Math.max(0, qr.top), Ur, jr, Vr = (qr.left + qr.right) / 2, ei = Ir + 1; ei < Math.min(innerHeight, qr.bottom); ei += 5) {
      var ti = Sr.root.elementFromPoint(Vr, ei);
      if (!(!ti || ti == Sr.dom || !Sr.dom.contains(ti))) {
        var fi = ti.getBoundingClientRect();
        if (fi.top >= Ir - 20) {
          Ur = ti, jr = fi.top;
          break;
        }
      }
    }
    return {
      refDOM: Ur,
      refTop: jr,
      stack: Hi(Sr.dom)
    };
  }
  function Hi(Sr) {
    for (var qr = [], Ir = Sr.ownerDocument, Ur = Sr; Ur && (qr.push({
      dom: Ur,
      top: Ur.scrollTop,
      left: Ur.scrollLeft
    }), Sr != Ir); Ur = Dr(Ur))
      ;
    return qr;
  }
  function oa(Sr) {
    var qr = Sr.refDOM, Ir = Sr.refTop, Ur = Sr.stack, jr = qr ? qr.getBoundingClientRect().top : 0;
    Gi(Ur, jr == 0 ? 0 : jr - Ir);
  }
  function Gi(Sr, qr) {
    for (var Ir = 0; Ir < Sr.length; Ir++) {
      var Ur = Sr[Ir], jr = Ur.dom, Vr = Ur.top, ei = Ur.left;
      jr.scrollTop != Vr + qr && (jr.scrollTop = Vr + qr), jr.scrollLeft != ei && (jr.scrollLeft = ei);
    }
  }
  var ha = null;
  function Ua(Sr) {
    if (Sr.setActive)
      return Sr.setActive();
    if (ha)
      return Sr.focus(ha);
    var qr = Hi(Sr);
    Sr.focus(ha == null ? {
      get preventScroll() {
        return ha = {
          preventScroll: !0
        }, !0;
      }
    } : void 0), ha || (ha = !1, Gi(qr, 0));
  }
  function eo(Sr, qr) {
    for (var Ir, Ur = 2e8, jr, Vr = 0, ei = qr.top, ti = qr.top, fi, ki, Ri = Sr.firstChild, ji = 0; Ri; Ri = Ri.nextSibling, ji++) {
      var Bi = void 0;
      if (Ri.nodeType == 1)
        Bi = Ri.getClientRects();
      else if (Ri.nodeType == 3)
        Bi = Hr(Ri).getClientRects();
      else
        continue;
      for (var Qi = 0; Qi < Bi.length; Qi++) {
        var na = Bi[Qi];
        if (na.top <= ei && na.bottom >= ti) {
          ei = Math.max(na.bottom, ei), ti = Math.min(na.top, ti);
          var Ea = na.left > qr.left ? na.left - qr.left : na.right < qr.left ? qr.left - na.right : 0;
          if (Ea < Ur) {
            Ir = Ri, Ur = Ea, jr = Ea && Ir.nodeType == 3 ? {
              left: na.right < qr.left ? na.right : na.left,
              top: qr.top
            } : qr, Ri.nodeType == 1 && Ea && (Vr = ji + (qr.left >= (na.left + na.right) / 2 ? 1 : 0));
            continue;
          }
        } else
          na.top > qr.top && !fi && na.left <= qr.left && na.right >= qr.left && (fi = Ri, ki = {
            left: Math.max(na.left, Math.min(na.right, qr.left)),
            top: na.top
          });
        !Ir && (qr.left >= na.right && qr.top >= na.top || qr.left >= na.left && qr.top >= na.bottom) && (Vr = ji + 1);
      }
    }
    return !Ir && fi && (Ir = fi, jr = ki, Ur = 0), Ir && Ir.nodeType == 3 ? ua(Ir, jr) : !Ir || Ur && Ir.nodeType == 1 ? {
      node: Sr,
      offset: Vr
    } : eo(Ir, jr);
  }
  function ua(Sr, qr) {
    for (var Ir = Sr.nodeValue.length, Ur = document.createRange(), jr = 0; jr < Ir; jr++) {
      Ur.setEnd(Sr, jr + 1), Ur.setStart(Sr, jr);
      var Vr = Da(Ur, 1);
      if (Vr.top != Vr.bottom && va(qr, Vr))
        return {
          node: Sr,
          offset: jr + (qr.left >= (Vr.left + Vr.right) / 2 ? 1 : 0)
        };
    }
    return {
      node: Sr,
      offset: 0
    };
  }
  function va(Sr, qr) {
    return Sr.left >= qr.left - 1 && Sr.left <= qr.right + 1 && Sr.top >= qr.top - 1 && Sr.top <= qr.bottom + 1;
  }
  function Ta(Sr, qr) {
    var Ir = Sr.parentNode;
    return Ir && /^li$/i.test(Ir.nodeName) && qr.left < Sr.getBoundingClientRect().left ? Ir : Sr;
  }
  function Aa(Sr, qr, Ir) {
    var Ur = eo(qr, Ir), jr = Ur.node, Vr = Ur.offset, ei = -1;
    if (jr.nodeType == 1 && !jr.firstChild) {
      var ti = jr.getBoundingClientRect();
      ei = ti.left != ti.right && Ir.left > (ti.left + ti.right) / 2 ? 1 : -1;
    }
    return Sr.docView.posFromDOM(jr, Vr, ei);
  }
  function Oa(Sr, qr, Ir, Ur) {
    for (var jr = -1, Vr = qr, ei = !1; Vr != Sr.dom; ) {
      var ti = Sr.docView.nearestDesc(Vr, !0);
      if (!ti)
        return null;
      if (ti.dom.nodeType == 1 && (ti.node.isBlock && ti.parent && !ei || !ti.contentDOM)) {
        var fi = ti.dom.getBoundingClientRect();
        if (ti.node.isBlock && ti.parent && !ei && (ei = !0, fi.left > Ur.left || fi.top > Ur.top ? jr = ti.posBefore : (fi.right < Ur.left || fi.bottom < Ur.top) && (jr = ti.posAfter)), !ti.contentDOM && jr < 0 && !ti.node.isText) {
          var ki = ti.node.isBlock ? Ur.top < (fi.top + fi.bottom) / 2 : Ur.left < (fi.left + fi.right) / 2;
          return ki ? ti.posBefore : ti.posAfter;
        }
      }
      Vr = ti.dom.parentNode;
    }
    return jr > -1 ? jr : Sr.docView.posFromDOM(qr, Ir, -1);
  }
  function Xa(Sr, qr, Ir) {
    var Ur = Sr.childNodes.length;
    if (Ur && Ir.top < Ir.bottom)
      for (var jr = Math.max(0, Math.min(Ur - 1, Math.floor(Ur * (qr.top - Ir.top) / (Ir.bottom - Ir.top)) - 2)), Vr = jr; ; ) {
        var ei = Sr.childNodes[Vr];
        if (ei.nodeType == 1)
          for (var ti = ei.getClientRects(), fi = 0; fi < ti.length; fi++) {
            var ki = ti[fi];
            if (va(qr, ki))
              return Xa(ei, qr, ki);
          }
        if ((Vr = (Vr + 1) % Ur) == jr)
          break;
      }
    return Sr;
  }
  function Ka(Sr, qr) {
    var Ir = Sr.dom.ownerDocument, Ur, jr = 0, Vr = hi(Ir, qr.left, qr.top);
    Vr && (Ur = Vr.node, jr = Vr.offset);
    var ei = (Sr.root.elementFromPoint ? Sr.root : Ir).elementFromPoint(qr.left, qr.top), ti;
    if (!ei || !Sr.dom.contains(ei.nodeType != 1 ? ei.parentNode : ei)) {
      var fi = Sr.dom.getBoundingClientRect();
      if (!va(qr, fi) || (ei = Xa(Sr.dom, qr, fi), !ei))
        return null;
    }
    if (mi)
      for (var ki = ei; Ur && ki; ki = Dr(ki))
        ki.draggable && (Ur = void 0);
    if (ei = Ta(ei, qr), Ur) {
      if (Vi && Ur.nodeType == 1 && (jr = Math.min(jr, Ur.childNodes.length), jr < Ur.childNodes.length)) {
        var Ri = Ur.childNodes[jr], ji;
        Ri.nodeName == "IMG" && (ji = Ri.getBoundingClientRect()).right <= qr.left && ji.bottom > qr.top && jr++;
      }
      var Bi;
      ia && jr && Ur.nodeType == 1 && (Bi = Ur.childNodes[jr - 1]).nodeType == 1 && Bi.contentEditable == "false" && Bi.getBoundingClientRect().top >= qr.top && jr--, Ur == Sr.dom && jr == Ur.childNodes.length - 1 && Ur.lastChild.nodeType == 1 && qr.top > Ur.lastChild.getBoundingClientRect().bottom ? ti = Sr.state.doc.content.size : (jr == 0 || Ur.nodeType != 1 || Ur.childNodes[jr - 1].nodeName != "BR") && (ti = Oa(Sr, Ur, jr, qr));
    }
    ti == null && (ti = Aa(Sr, ei, qr));
    var Qi = Sr.docView.nearestDesc(ei, !0);
    return {
      pos: ti,
      inside: Qi ? Qi.posAtStart - Qi.border : -1
    };
  }
  function Pa(Sr) {
    return Sr.top < Sr.bottom || Sr.left < Sr.right;
  }
  function Da(Sr, qr) {
    var Ir = Sr.getClientRects();
    if (Ir.length) {
      var Ur = Ir[qr < 0 ? 0 : Ir.length - 1];
      if (Pa(Ur))
        return Ur;
    }
    return Array.prototype.find.call(Ir, Pa) || Sr.getBoundingClientRect();
  }
  var Ha = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function $a(Sr, qr, Ir) {
    var Ur = Sr.docView.domFromPos(qr, Ir < 0 ? -1 : 1), jr = Ur.node, Vr = Ur.offset, ei = Ur.atom, ti = ia || Vi;
    if (jr.nodeType == 3)
      if (ti && (Ha.test(jr.nodeValue) || (Ir < 0 ? !Vr : Vr == jr.nodeValue.length))) {
        var fi = Da(Hr(jr, Vr, Vr), Ir);
        if (Vi && Vr && /\s/.test(jr.nodeValue[Vr - 1]) && Vr < jr.nodeValue.length) {
          var ki = Da(Hr(jr, Vr - 1, Vr - 1), -1);
          if (ki.top == fi.top) {
            var Ri = Da(Hr(jr, Vr, Vr + 1), -1);
            if (Ri.top != fi.top)
              return Yi(Ri, Ri.left < ki.left);
          }
        }
        return fi;
      } else {
        var ji = Vr, Bi = Vr, Qi = Ir < 0 ? 1 : -1;
        return Ir < 0 && !Vr ? (Bi++, Qi = -1) : Ir >= 0 && Vr == jr.nodeValue.length ? (ji--, Qi = 1) : Ir < 0 ? ji-- : Bi++, Yi(Da(Hr(jr, ji, Bi), Qi), Qi < 0);
      }
    var na = Sr.state.doc.resolve(qr - (ei || 0));
    if (!na.parent.inlineContent) {
      if (ei == null && Vr && (Ir < 0 || Vr == oi(jr))) {
        var Ea = jr.childNodes[Vr - 1];
        if (Ea.nodeType == 1)
          return Zi(Ea.getBoundingClientRect(), !1);
      }
      if (ei == null && Vr < oi(jr)) {
        var La = jr.childNodes[Vr];
        if (La.nodeType == 1)
          return Zi(La.getBoundingClientRect(), !0);
      }
      return Zi(jr.getBoundingClientRect(), Ir >= 0);
    }
    if (ei == null && Vr && (Ir < 0 || Vr == oi(jr))) {
      var fa = jr.childNodes[Vr - 1], so = fa.nodeType == 3 ? Hr(fa, oi(fa) - (ti ? 0 : 1)) : fa.nodeType == 1 && (fa.nodeName != "BR" || !fa.nextSibling) ? fa : null;
      if (so)
        return Yi(Da(so, 1), !1);
    }
    if (ei == null && Vr < oi(jr)) {
      for (var Za = jr.childNodes[Vr]; Za.pmViewDesc && Za.pmViewDesc.ignoreForCoords; )
        Za = Za.nextSibling;
      var no = Za ? Za.nodeType == 3 ? Hr(Za, 0, ti ? 0 : 1) : Za.nodeType == 1 ? Za : null : null;
      if (no)
        return Yi(Da(no, -1), !0);
    }
    return Yi(Da(jr.nodeType == 3 ? Hr(jr) : jr, -Ir), Ir >= 0);
  }
  function Yi(Sr, qr) {
    if (Sr.width == 0)
      return Sr;
    var Ir = qr ? Sr.left : Sr.right;
    return {
      top: Sr.top,
      bottom: Sr.bottom,
      left: Ir,
      right: Ir
    };
  }
  function Zi(Sr, qr) {
    if (Sr.height == 0)
      return Sr;
    var Ir = qr ? Sr.top : Sr.bottom;
    return {
      top: Ir,
      bottom: Ir,
      left: Sr.left,
      right: Sr.right
    };
  }
  function ka(Sr, qr, Ir) {
    var Ur = Sr.state, jr = Sr.root.activeElement;
    Ur != qr && Sr.updateState(qr), jr != Sr.dom && Sr.focus();
    try {
      return Ir();
    } finally {
      Ur != qr && Sr.updateState(Ur), jr != Sr.dom && jr && jr.focus();
    }
  }
  function zi(Sr, qr, Ir) {
    var Ur = qr.selection, jr = Ir == "up" ? Ur.$from : Ur.$to;
    return ka(Sr, qr, function() {
      for (var Vr = Sr.docView.domFromPos(jr.pos, Ir == "up" ? -1 : 1), ei = Vr.node; ; ) {
        var ti = Sr.docView.nearestDesc(ei, !0);
        if (!ti)
          break;
        if (ti.node.isBlock) {
          ei = ti.contentDOM || ti.dom;
          break;
        }
        ei = ti.dom.parentNode;
      }
      for (var fi = $a(Sr, jr.pos, 1), ki = ei.firstChild; ki; ki = ki.nextSibling) {
        var Ri = void 0;
        if (ki.nodeType == 1)
          Ri = ki.getClientRects();
        else if (ki.nodeType == 3)
          Ri = Hr(ki, 0, ki.nodeValue.length).getClientRects();
        else
          continue;
        for (var ji = 0; ji < Ri.length; ji++) {
          var Bi = Ri[ji];
          if (Bi.bottom > Bi.top + 1 && (Ir == "up" ? fi.top - Bi.top > (Bi.bottom - fi.top) * 2 : Bi.bottom - fi.bottom > (fi.bottom - Bi.top) * 2))
            return !1;
        }
      }
      return !0;
    });
  }
  var Ji = /[\u0590-\u08ac]/;
  function za(Sr, qr, Ir) {
    var Ur = qr.selection.$head;
    if (!Ur.parent.isTextblock)
      return !1;
    var jr = Ur.parentOffset, Vr = !jr, ei = jr == Ur.parent.content.size, ti = Sr.domSelection();
    return !Ji.test(Ur.parent.textContent) || !ti.modify ? Ir == "left" || Ir == "backward" ? Vr : ei : ka(Sr, qr, function() {
      var fi = Sr.domSelectionRange(), ki = fi.focusNode, Ri = fi.focusOffset, ji = fi.anchorNode, Bi = fi.anchorOffset, Qi = ti.caretBidiLevel;
      ti.modify("move", Ir, "character");
      var na = Ur.depth ? Sr.docView.domAfterPos(Ur.before()) : Sr.dom, Ea = Sr.domSelectionRange(), La = Ea.focusNode, fa = Ea.focusOffset, so = La && !na.contains(La.nodeType == 1 ? La : La.parentNode) || ki == La && Ri == fa;
      try {
        ti.collapse(ji, Bi), ki && (ki != ji || Ri != Bi) && ti.extend && ti.extend(ki, Ri);
      } catch (Za) {
      }
      return Qi != null && (ti.caretBidiLevel = Qi), so;
    });
  }
  var Va = null, Ca = null, ja = !1;
  function ao(Sr, qr, Ir) {
    return Va == qr && Ca == Ir ? ja : (Va = qr, Ca = Ir, ja = Ir == "up" || Ir == "down" ? zi(Sr, qr, Ir) : za(Sr, qr, Ir));
  }
  var Wa = 0, po = 1, to = 2, oo = 3, uo = function() {
    function Sr(qr, Ir, Ur, jr) {
      Tr(this, Sr), this.parent = qr, this.children = Ir, this.dom = Ur, this.contentDOM = jr, this.dirty = Wa, Ur.pmViewDesc = this;
    }
    return Er(Sr, [{
      key: "matchesWidget",
      value: function(Ir) {
        return !1;
      }
    }, {
      key: "matchesMark",
      value: function(Ir) {
        return !1;
      }
    }, {
      key: "matchesNode",
      value: function(Ir, Ur, jr) {
        return !1;
      }
    }, {
      key: "matchesHack",
      value: function(Ir) {
        return !1;
      }
    }, {
      key: "parseRule",
      value: function() {
        return null;
      }
    }, {
      key: "stopEvent",
      value: function(Ir) {
        return !1;
      }
    }, {
      key: "size",
      get: function() {
        for (var Ir = 0, Ur = 0; Ur < this.children.length; Ur++)
          Ir += this.children[Ur].size;
        return Ir;
      }
    }, {
      key: "border",
      get: function() {
        return 0;
      }
    }, {
      key: "destroy",
      value: function() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (var Ir = 0; Ir < this.children.length; Ir++)
          this.children[Ir].destroy();
      }
    }, {
      key: "posBeforeChild",
      value: function(Ir) {
        for (var Ur = 0, jr = this.posAtStart; ; Ur++) {
          var Vr = this.children[Ur];
          if (Vr == Ir)
            return jr;
          jr += Vr.size;
        }
      }
    }, {
      key: "posBefore",
      get: function() {
        return this.parent.posBeforeChild(this);
      }
    }, {
      key: "posAtStart",
      get: function() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
    }, {
      key: "posAfter",
      get: function() {
        return this.posBefore + this.size;
      }
    }, {
      key: "posAtEnd",
      get: function() {
        return this.posAtStart + this.size - 2 * this.border;
      }
    }, {
      key: "localPosFromDOM",
      value: function(Ir, Ur, jr) {
        if (this.contentDOM && this.contentDOM.contains(Ir.nodeType == 1 ? Ir : Ir.parentNode))
          if (jr < 0) {
            var Vr, ei;
            if (Ir == this.contentDOM)
              Vr = Ir.childNodes[Ur - 1];
            else {
              for (; Ir.parentNode != this.contentDOM; )
                Ir = Ir.parentNode;
              Vr = Ir.previousSibling;
            }
            for (; Vr && !((ei = Vr.pmViewDesc) && ei.parent == this); )
              Vr = Vr.previousSibling;
            return Vr ? this.posBeforeChild(ei) + ei.size : this.posAtStart;
          } else {
            var ti, fi;
            if (Ir == this.contentDOM)
              ti = Ir.childNodes[Ur];
            else {
              for (; Ir.parentNode != this.contentDOM; )
                Ir = Ir.parentNode;
              ti = Ir.nextSibling;
            }
            for (; ti && !((fi = ti.pmViewDesc) && fi.parent == this); )
              ti = ti.nextSibling;
            return ti ? this.posBeforeChild(fi) : this.posAtEnd;
          }
        var ki;
        if (Ir == this.dom && this.contentDOM)
          ki = Ur > Lr(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          ki = Ir.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (Ur == 0)
            for (var Ri = Ir; ; Ri = Ri.parentNode) {
              if (Ri == this.dom) {
                ki = !1;
                break;
              }
              if (Ri.previousSibling)
                break;
            }
          if (ki == null && Ur == Ir.childNodes.length)
            for (var ji = Ir; ; ji = ji.parentNode) {
              if (ji == this.dom) {
                ki = !0;
                break;
              }
              if (ji.nextSibling)
                break;
            }
        }
        return (ki == null ? jr > 0 : ki) ? this.posAtEnd : this.posAtStart;
      }
    }, {
      key: "nearestDesc",
      value: function(Ir) {
        for (var Ur = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, jr = !0, Vr = Ir; Vr; Vr = Vr.parentNode) {
          var ei = this.getDesc(Vr), ti = void 0;
          if (ei && (!Ur || ei.node))
            if (jr && (ti = ei.nodeDOM) && !(ti.nodeType == 1 ? ti.contains(Ir.nodeType == 1 ? Ir : Ir.parentNode) : ti == Ir))
              jr = !1;
            else
              return ei;
        }
      }
    }, {
      key: "getDesc",
      value: function(Ir) {
        for (var Ur = Ir.pmViewDesc, jr = Ur; jr; jr = jr.parent)
          if (jr == this)
            return Ur;
      }
    }, {
      key: "posFromDOM",
      value: function(Ir, Ur, jr) {
        for (var Vr = Ir; Vr; Vr = Vr.parentNode) {
          var ei = this.getDesc(Vr);
          if (ei)
            return ei.localPosFromDOM(Ir, Ur, jr);
        }
        return -1;
      }
    }, {
      key: "descAt",
      value: function(Ir) {
        for (var Ur = 0, jr = 0; Ur < this.children.length; Ur++) {
          var Vr = this.children[Ur], ei = jr + Vr.size;
          if (jr == Ir && ei != jr) {
            for (; !Vr.border && Vr.children.length; )
              Vr = Vr.children[0];
            return Vr;
          }
          if (Ir < ei)
            return Vr.descAt(Ir - jr - Vr.border);
          jr = ei;
        }
      }
    }, {
      key: "domFromPos",
      value: function(Ir, Ur) {
        if (!this.contentDOM)
          return {
            node: this.dom,
            offset: 0,
            atom: Ir + 1
          };
        for (var jr = 0, Vr = 0, ei = 0; jr < this.children.length; jr++) {
          var ti = this.children[jr], fi = ei + ti.size;
          if (fi > Ir || ti instanceof sa) {
            Vr = Ir - ei;
            break;
          }
          ei = fi;
        }
        if (Vr)
          return this.children[jr].domFromPos(Vr - this.children[jr].border, Ur);
        for (var ki; jr && !(ki = this.children[jr - 1]).size && ki instanceof Io && ki.side >= 0; jr--)
          ;
        if (Ur <= 0) {
          for (var Ri, ji = !0; Ri = jr ? this.children[jr - 1] : null, !(!Ri || Ri.dom.parentNode == this.contentDOM); jr--, ji = !1)
            ;
          return Ri && Ur && ji && !Ri.border && !Ri.domAtom ? Ri.domFromPos(Ri.size, Ur) : {
            node: this.contentDOM,
            offset: Ri ? Lr(Ri.dom) + 1 : 0
          };
        } else {
          for (var Bi, Qi = !0; Bi = jr < this.children.length ? this.children[jr] : null, !(!Bi || Bi.dom.parentNode == this.contentDOM); jr++, Qi = !1)
            ;
          return Bi && Qi && !Bi.border && !Bi.domAtom ? Bi.domFromPos(0, Ur) : {
            node: this.contentDOM,
            offset: Bi ? Lr(Bi.dom) : this.contentDOM.childNodes.length
          };
        }
      }
    }, {
      key: "parseRange",
      value: function(Ir, Ur) {
        var jr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        if (this.children.length == 0)
          return {
            node: this.contentDOM,
            from: Ir,
            to: Ur,
            fromOffset: 0,
            toOffset: this.contentDOM.childNodes.length
          };
        for (var Vr = -1, ei = -1, ti = jr, fi = 0; ; fi++) {
          var ki = this.children[fi], Ri = ti + ki.size;
          if (Vr == -1 && Ir <= Ri) {
            var ji = ti + ki.border;
            if (Ir >= ji && Ur <= Ri - ki.border && ki.node && ki.contentDOM && this.contentDOM.contains(ki.contentDOM))
              return ki.parseRange(Ir, Ur, ji);
            Ir = ti;
            for (var Bi = fi; Bi > 0; Bi--) {
              var Qi = this.children[Bi - 1];
              if (Qi.size && Qi.dom.parentNode == this.contentDOM && !Qi.emptyChildAt(1)) {
                Vr = Lr(Qi.dom) + 1;
                break;
              }
              Ir -= Qi.size;
            }
            Vr == -1 && (Vr = 0);
          }
          if (Vr > -1 && (Ri > Ur || fi == this.children.length - 1)) {
            Ur = Ri;
            for (var na = fi + 1; na < this.children.length; na++) {
              var Ea = this.children[na];
              if (Ea.size && Ea.dom.parentNode == this.contentDOM && !Ea.emptyChildAt(-1)) {
                ei = Lr(Ea.dom);
                break;
              }
              Ur += Ea.size;
            }
            ei == -1 && (ei = this.contentDOM.childNodes.length);
            break;
          }
          ti = Ri;
        }
        return {
          node: this.contentDOM,
          from: Ir,
          to: Ur,
          fromOffset: Vr,
          toOffset: ei
        };
      }
    }, {
      key: "emptyChildAt",
      value: function(Ir) {
        if (this.border || !this.contentDOM || !this.children.length)
          return !1;
        var Ur = this.children[Ir < 0 ? 0 : this.children.length - 1];
        return Ur.size == 0 || Ur.emptyChildAt(Ir);
      }
    }, {
      key: "domAfterPos",
      value: function(Ir) {
        var Ur = this.domFromPos(Ir, 0), jr = Ur.node, Vr = Ur.offset;
        if (jr.nodeType != 1 || Vr == jr.childNodes.length)
          throw new RangeError("No node after pos " + Ir);
        return jr.childNodes[Vr];
      }
    }, {
      key: "setSelection",
      value: function(Ir, Ur, jr) {
        for (var Vr = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, ei = Math.min(Ir, Ur), ti = Math.max(Ir, Ur), fi = 0, ki = 0; fi < this.children.length; fi++) {
          var Ri = this.children[fi], ji = ki + Ri.size;
          if (ei > ki && ti < ji)
            return Ri.setSelection(Ir - ki - Ri.border, Ur - ki - Ri.border, jr, Vr);
          ki = ji;
        }
        var Bi = this.domFromPos(Ir, Ir ? -1 : 1), Qi = Ur == Ir ? Bi : this.domFromPos(Ur, Ur ? -1 : 1), na = jr.getSelection(), Ea = !1;
        if ((Vi || mi) && Ir == Ur) {
          var La = Bi, fa = La.node, so = La.offset;
          if (fa.nodeType == 3) {
            if (Ea = !!(so && fa.nodeValue[so - 1] == `
`), Ea && so == fa.nodeValue.length)
              for (var Za = fa, no; Za; Za = Za.parentNode) {
                if (no = Za.nextSibling) {
                  no.nodeName == "BR" && (Bi = Qi = {
                    node: no.parentNode,
                    offset: Lr(no) + 1
                  });
                  break;
                }
                var Ga = Za.pmViewDesc;
                if (Ga && Ga.node && Ga.node.isBlock)
                  break;
              }
          } else {
            var Ja = fa.childNodes[so - 1];
            Ea = Ja && (Ja.nodeName == "BR" || Ja.contentEditable == "false");
          }
        }
        if (Vi && na.focusNode && na.focusNode != Qi.node && na.focusNode.nodeType == 1) {
          var ho = na.focusNode.childNodes[na.focusOffset];
          ho && ho.contentEditable == "false" && (Vr = !0);
        }
        if (!(!(Vr || Ea && mi) && $r(Bi.node, Bi.offset, na.anchorNode, na.anchorOffset) && $r(Qi.node, Qi.offset, na.focusNode, na.focusOffset))) {
          var No = !1;
          if ((na.extend || Ir == Ur) && !Ea) {
            na.collapse(Bi.node, Bi.offset);
            try {
              Ir != Ur && na.extend(Qi.node, Qi.offset), No = !0;
            } catch (Ko) {
            }
          }
          if (!No) {
            if (Ir > Ur) {
              var qo = Bi;
              Bi = Qi, Qi = qo;
            }
            var Co = document.createRange();
            Co.setEnd(Qi.node, Qi.offset), Co.setStart(Bi.node, Bi.offset), na.removeAllRanges(), na.addRange(Co);
          }
        }
      }
    }, {
      key: "ignoreMutation",
      value: function(Ir) {
        return !this.contentDOM && Ir.type != "selection";
      }
    }, {
      key: "contentLost",
      get: function() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
    }, {
      key: "markDirty",
      value: function(Ir, Ur) {
        for (var jr = 0, Vr = 0; Vr < this.children.length; Vr++) {
          var ei = this.children[Vr], ti = jr + ei.size;
          if (jr == ti ? Ir <= ti && Ur >= jr : Ir < ti && Ur > jr) {
            var fi = jr + ei.border, ki = ti - ei.border;
            if (Ir >= fi && Ur <= ki) {
              this.dirty = Ir == jr || Ur == ti ? to : po, Ir == fi && Ur == ki && (ei.contentLost || ei.dom.parentNode != this.contentDOM) ? ei.dirty = oo : ei.markDirty(Ir - fi, Ur - fi);
              return;
            } else
              ei.dirty = ei.dom == ei.contentDOM && ei.dom.parentNode == this.contentDOM && !ei.children.length ? to : oo;
          }
          jr = ti;
        }
        this.dirty = to;
      }
    }, {
      key: "markParentsDirty",
      value: function() {
        for (var Ir = 1, Ur = this.parent; Ur; Ur = Ur.parent, Ir++) {
          var jr = Ir == 1 ? to : po;
          Ur.dirty < jr && (Ur.dirty = jr);
        }
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return !1;
      }
    }]), Sr;
  }(), Io = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei) {
      var ti;
      Tr(this, Ir);
      var fi, ki = jr.type.toDOM;
      if (typeof ki == "function" && (ki = ki(Vr, function() {
        if (!fi)
          return ei;
        if (fi.parent)
          return fi.parent.posBeforeChild(fi);
      })), !jr.type.spec.raw) {
        if (ki.nodeType != 1) {
          var Ri = document.createElement("span");
          Ri.appendChild(ki), ki = Ri;
        }
        ki.contentEditable = "false", ki.classList.add("ProseMirror-widget");
      }
      return ti = qr.call(this, Ur, [], ki, null), ti.widget = jr, ti.widget = jr, fi = br(ti), ti;
    }
    return Er(Ir, [{
      key: "matchesWidget",
      value: function(jr) {
        return this.dirty == Wa && jr.type.eq(this.widget.type);
      }
    }, {
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "stopEvent",
      value: function(jr) {
        var Vr = this.widget.spec.stopEvent;
        return Vr ? Vr(jr) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(jr) {
        return jr.type != "selection" || this.widget.spec.ignoreSelection;
      }
    }, {
      key: "destroy",
      value: function() {
        this.widget.type.destroy(this.dom), fr(kr(Ir.prototype), "destroy", this).call(this);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "side",
      get: function() {
        return this.widget.type.side;
      }
    }]), Ir;
  }(uo), Lo = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei) {
      var ti;
      return Tr(this, Ir), ti = qr.call(this, Ur, [], jr, null), ti.textDOM = Vr, ti.text = ei, ti;
    }
    return Er(Ir, [{
      key: "size",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "localPosFromDOM",
      value: function(jr, Vr) {
        return jr != this.textDOM ? this.posAtStart + (Vr ? this.size : 0) : this.posAtStart + Vr;
      }
    }, {
      key: "domFromPos",
      value: function(jr) {
        return {
          node: this.textDOM,
          offset: jr
        };
      }
    }, {
      key: "ignoreMutation",
      value: function(jr) {
        return jr.type === "characterData" && jr.target.nodeValue == jr.oldValue;
      }
    }]), Ir;
  }(uo), Eo = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei) {
      var ti;
      return Tr(this, Ir), ti = qr.call(this, Ur, [], Vr, ei), ti.mark = jr, ti;
    }
    return Er(Ir, [{
      key: "parseRule",
      value: function() {
        return this.dirty & oo || this.mark.type.spec.reparseInView ? null : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM
        };
      }
    }, {
      key: "matchesMark",
      value: function(jr) {
        return this.dirty != oo && this.mark.eq(jr);
      }
    }, {
      key: "markDirty",
      value: function(jr, Vr) {
        if (fr(kr(Ir.prototype), "markDirty", this).call(this, jr, Vr), this.dirty != Wa) {
          for (var ei = this.parent; !ei.node; )
            ei = ei.parent;
          ei.dirty < this.dirty && (ei.dirty = this.dirty), this.dirty = Wa;
        }
      }
    }, {
      key: "slice",
      value: function(jr, Vr, ei) {
        var ti = Ir.create(this.parent, this.mark, !0, ei), fi = this.children, ki = this.size;
        Vr < ki && (fi = Oo(fi, Vr, ki, ei)), jr > 0 && (fi = Oo(fi, 0, jr, ei));
        for (var Ri = 0; Ri < fi.length; Ri++)
          fi[Ri].parent = ti;
        return ti.children = fi, ti;
      }
    }], [{
      key: "create",
      value: function(jr, Vr, ei, ti) {
        var fi = ti.nodeViews[Vr.type.name], ki = fi && fi(Vr, ti, ei);
        return (!ki || !ki.dom) && (ki = Cr.DOMSerializer.renderSpec(document, Vr.type.spec.toDOM(Vr, ei))), new Ir(jr, Vr, ki.dom, ki.contentDOM || ki.dom);
      }
    }]), Ir;
  }(uo), lo = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei, ti, fi, ki, Ri, ji) {
      var Bi;
      return Tr(this, Ir), Bi = qr.call(this, Ur, [], ti, fi), Bi.node = jr, Bi.outerDeco = Vr, Bi.innerDeco = ei, Bi.nodeDOM = ki, Bi;
    }
    return Er(Ir, [{
      key: "parseRule",
      value: function() {
        var jr = this;
        if (this.node.type.spec.reparseInView)
          return null;
        var Vr = {
          node: this.node.type.name,
          attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (Vr.preserveWhitespace = "full"), !this.contentDOM)
          Vr.getContent = function() {
            return jr.node.content;
          };
        else if (!this.contentLost)
          Vr.contentElement = this.contentDOM;
        else {
          for (var ei = this.children.length - 1; ei >= 0; ei--) {
            var ti = this.children[ei];
            if (this.dom.contains(ti.dom.parentNode)) {
              Vr.contentElement = ti.dom.parentNode;
              break;
            }
          }
          Vr.contentElement || (Vr.getContent = function() {
            return Cr.Fragment.empty;
          });
        }
        return Vr;
      }
    }, {
      key: "matchesNode",
      value: function(jr, Vr, ei) {
        return this.dirty == Wa && jr.eq(this.node) && Fi(Vr, this.outerDeco) && ei.eq(this.innerDeco);
      }
    }, {
      key: "size",
      get: function() {
        return this.node.nodeSize;
      }
    }, {
      key: "border",
      get: function() {
        return this.node.isLeaf ? 0 : 1;
      }
    }, {
      key: "updateChildren",
      value: function(jr, Vr) {
        var ei = this, ti = this.node.inlineContent, fi = Vr, ki = jr.composing ? this.localCompositionInfo(jr, Vr) : null, Ri = ki && ki.pos > -1 ? ki : null, ji = ki && ki.pos < 0, Bi = new pa(this, Ri && Ri.node, jr);
        qa(this.node, this.innerDeco, function(Qi, na, Ea) {
          Qi.spec.marks ? Bi.syncToMarks(Qi.spec.marks, ti, jr) : Qi.type.side >= 0 && !Ea && Bi.syncToMarks(na == ei.node.childCount ? Cr.Mark.none : ei.node.child(na).marks, ti, jr), Bi.placeWidget(Qi, jr, fi);
        }, function(Qi, na, Ea, La) {
          Bi.syncToMarks(Qi.marks, ti, jr);
          var fa;
          Bi.findNodeMatch(Qi, na, Ea, La) || ji && jr.state.selection.from > fi && jr.state.selection.to < fi + Qi.nodeSize && (fa = Bi.findIndexWithChild(ki.node)) > -1 && Bi.updateNodeAt(Qi, na, Ea, fa, jr) || Bi.updateNextNode(Qi, na, Ea, jr, La, fi) || Bi.addNode(Qi, na, Ea, jr, fi), fi += Qi.nodeSize;
        }), Bi.syncToMarks([], ti, jr), this.node.isTextblock && Bi.addTextblockHacks(), Bi.destroyRest(), (Bi.changed || this.dirty == to) && (Ri && this.protectLocalComposition(jr, Ri), Qr(this.contentDOM, this.children, jr), _i && co(this.dom));
      }
    }, {
      key: "localCompositionInfo",
      value: function(jr, Vr) {
        var ei = jr.state.selection, ti = ei.from, fi = ei.to;
        if (!(jr.state.selection instanceof xr.TextSelection) || ti < Vr || fi > Vr + this.node.content.size)
          return null;
        var ki = jr.domSelectionRange(), Ri = yo(ki.focusNode, ki.focusOffset);
        if (!Ri || !this.dom.contains(Ri.parentNode))
          return null;
        if (this.node.inlineContent) {
          var ji = Ri.nodeValue, Bi = Mo(this.node.content, ji, ti - Vr, fi - Vr);
          return Bi < 0 ? null : {
            node: Ri,
            pos: Bi,
            text: ji
          };
        } else
          return {
            node: Ri,
            pos: -1,
            text: ""
          };
      }
    }, {
      key: "protectLocalComposition",
      value: function(jr, Vr) {
        var ei = Vr.node, ti = Vr.pos, fi = Vr.text;
        if (!this.getDesc(ei)) {
          for (var ki = ei; ki.parentNode != this.contentDOM; ki = ki.parentNode) {
            for (; ki.previousSibling; )
              ki.parentNode.removeChild(ki.previousSibling);
            for (; ki.nextSibling; )
              ki.parentNode.removeChild(ki.nextSibling);
            ki.pmViewDesc && (ki.pmViewDesc = void 0);
          }
          var Ri = new Lo(this, ki, ei, fi);
          jr.input.compositionNodes.push(Ri), this.children = Oo(this.children, ti, ti + fi.length, jr, Ri);
        }
      }
    }, {
      key: "update",
      value: function(jr, Vr, ei, ti) {
        return this.dirty == oo || !jr.sameMarkup(this.node) ? !1 : (this.updateInner(jr, Vr, ei, ti), !0);
      }
    }, {
      key: "updateInner",
      value: function(jr, Vr, ei, ti) {
        this.updateOuterDeco(Vr), this.node = jr, this.innerDeco = ei, this.contentDOM && this.updateChildren(ti, this.posAtStart), this.dirty = Wa;
      }
    }, {
      key: "updateOuterDeco",
      value: function(jr) {
        if (!Fi(jr, this.outerDeco)) {
          var Vr = this.nodeDOM.nodeType != 1, ei = this.dom;
          this.dom = ai(this.dom, this.nodeDOM, Xr(this.outerDeco, this.node, Vr), Xr(jr, this.node, Vr)), this.dom != ei && (ei.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = jr;
        }
      }
    }, {
      key: "selectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
      }
    }, {
      key: "domAtom",
      get: function() {
        return this.node.isAtom;
      }
    }], [{
      key: "create",
      value: function(jr, Vr, ei, ti, fi, ki) {
        var Ri = fi.nodeViews[Vr.type.name], ji, Bi = Ri && Ri(Vr, fi, function() {
          if (!ji)
            return ki;
          if (ji.parent)
            return ji.parent.posBeforeChild(ji);
        }, ei, ti), Qi = Bi && Bi.dom, na = Bi && Bi.contentDOM;
        if (Vr.isText) {
          if (!Qi)
            Qi = document.createTextNode(Vr.text);
          else if (Qi.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!Qi) {
          var Ea = Cr.DOMSerializer.renderSpec(document, Vr.type.spec.toDOM(Vr));
          Qi = Ea.dom, na = Ea.contentDOM;
        }
        !na && !Vr.isText && Qi.nodeName != "BR" && (Qi.hasAttribute("contenteditable") || (Qi.contentEditable = "false"), Vr.type.spec.draggable && (Qi.draggable = !0));
        var La = Qi;
        return Qi = Ti(Qi, ei, Vr), Bi ? ji = new si(jr, Vr, ei, ti, Qi, na || null, La, Bi, fi, ki + 1) : Vr.isText ? new qi(jr, Vr, ei, ti, Qi, La, fi) : new Ir(jr, Vr, ei, ti, Qi, na || null, La);
      }
    }]), Ir;
  }(uo);
  function ya(Sr, qr, Ir, Ur, jr) {
    Ti(Ur, qr, Sr);
    var Vr = new lo(void 0, Sr, qr, Ir, Ur, Ur, Ur, jr, 0);
    return Vr.contentDOM && Vr.updateChildren(jr, 0), Vr;
  }
  var qi = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei, ti, fi, ki) {
      return Tr(this, Ir), qr.call(this, Ur, jr, Vr, ei, ti, null, fi, ki, 0);
    }
    return Er(Ir, [{
      key: "parseRule",
      value: function() {
        for (var jr = this.nodeDOM.parentNode; jr && jr != this.dom && !jr.pmIsDeco; )
          jr = jr.parentNode;
        return {
          skip: jr || !0
        };
      }
    }, {
      key: "update",
      value: function(jr, Vr, ei, ti) {
        return this.dirty == oo || this.dirty != Wa && !this.inParent() || !jr.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(Vr), (this.dirty != Wa || jr.text != this.node.text) && jr.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = jr.text, ti.trackWrites == this.nodeDOM && (ti.trackWrites = null)), this.node = jr, this.dirty = Wa, !0);
      }
    }, {
      key: "inParent",
      value: function() {
        for (var jr = this.parent.contentDOM, Vr = this.nodeDOM; Vr; Vr = Vr.parentNode)
          if (Vr == jr)
            return !0;
        return !1;
      }
    }, {
      key: "domFromPos",
      value: function(jr) {
        return {
          node: this.nodeDOM,
          offset: jr
        };
      }
    }, {
      key: "localPosFromDOM",
      value: function(jr, Vr, ei) {
        return jr == this.nodeDOM ? this.posAtStart + Math.min(Vr, this.node.text.length) : fr(kr(Ir.prototype), "localPosFromDOM", this).call(this, jr, Vr, ei);
      }
    }, {
      key: "ignoreMutation",
      value: function(jr) {
        return jr.type != "characterData" && jr.type != "selection";
      }
    }, {
      key: "slice",
      value: function(jr, Vr, ei) {
        var ti = this.node.cut(jr, Vr), fi = document.createTextNode(ti.text);
        return new Ir(this.parent, ti, this.outerDeco, this.innerDeco, fi, fi, ei);
      }
    }, {
      key: "markDirty",
      value: function(jr, Vr) {
        fr(kr(Ir.prototype), "markDirty", this).call(this, jr, Vr), this.dom != this.nodeDOM && (jr == 0 || Vr == this.nodeDOM.nodeValue.length) && (this.dirty = oo);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }]), Ir;
  }(lo), sa = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir() {
      return Tr(this, Ir), qr.apply(this, arguments);
    }
    return Er(Ir, [{
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "matchesHack",
      value: function(jr) {
        return this.dirty == Wa && this.dom.nodeName == jr;
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return this.dom.nodeName == "IMG";
      }
    }]), Ir;
  }(uo), si = function(Sr) {
    hr(Ir, Sr);
    var qr = vr(Ir);
    function Ir(Ur, jr, Vr, ei, ti, fi, ki, Ri, ji, Bi) {
      var Qi;
      return Tr(this, Ir), Qi = qr.call(this, Ur, jr, Vr, ei, ti, fi, ki, ji, Bi), Qi.spec = Ri, Qi;
    }
    return Er(Ir, [{
      key: "update",
      value: function(jr, Vr, ei, ti) {
        if (this.dirty == oo)
          return !1;
        if (this.spec.update) {
          var fi = this.spec.update(jr, Vr, ei);
          return fi && this.updateInner(jr, Vr, ei, ti), fi;
        } else
          return !this.contentDOM && !jr.isLeaf ? !1 : fr(kr(Ir.prototype), "update", this).call(this, jr, Vr, ei, ti);
      }
    }, {
      key: "selectNode",
      value: function() {
        this.spec.selectNode ? this.spec.selectNode() : fr(kr(Ir.prototype), "selectNode", this).call(this);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.spec.deselectNode ? this.spec.deselectNode() : fr(kr(Ir.prototype), "deselectNode", this).call(this);
      }
    }, {
      key: "setSelection",
      value: function(jr, Vr, ei, ti) {
        this.spec.setSelection ? this.spec.setSelection(jr, Vr, ei) : fr(kr(Ir.prototype), "setSelection", this).call(this, jr, Vr, ei, ti);
      }
    }, {
      key: "destroy",
      value: function() {
        this.spec.destroy && this.spec.destroy(), fr(kr(Ir.prototype), "destroy", this).call(this);
      }
    }, {
      key: "stopEvent",
      value: function(jr) {
        return this.spec.stopEvent ? this.spec.stopEvent(jr) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(jr) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(jr) : fr(kr(Ir.prototype), "ignoreMutation", this).call(this, jr);
      }
    }]), Ir;
  }(lo);
  function Qr(Sr, qr, Ir) {
    for (var Ur = Sr.firstChild, jr = !1, Vr = 0; Vr < qr.length; Vr++) {
      var ei = qr[Vr], ti = ei.dom;
      if (ti.parentNode == Sr) {
        for (; ti != Ur; )
          Ur = ra(Ur), jr = !0;
        Ur = Ur.nextSibling;
      } else
        jr = !0, Sr.insertBefore(ti, Ur);
      if (ei instanceof Eo) {
        var fi = Ur ? Ur.previousSibling : Sr.lastChild;
        Qr(ei.contentDOM, ei.children, Ir), Ur = fi ? fi.nextSibling : Sr.firstChild;
      }
    }
    for (; Ur; )
      Ur = ra(Ur), jr = !0;
    jr && Ir.trackWrites == Sr && (Ir.trackWrites = null);
  }
  var Br = function(qr) {
    qr && (this.nodeName = qr);
  };
  Br.prototype = /* @__PURE__ */ Object.create(null);
  var zr = [new Br()];
  function Xr(Sr, qr, Ir) {
    if (Sr.length == 0)
      return zr;
    for (var Ur = Ir ? zr[0] : new Br(), jr = [Ur], Vr = 0; Vr < Sr.length; Vr++) {
      var ei = Sr[Vr].type.attrs;
      if (ei) {
        ei.nodeName && jr.push(Ur = new Br(ei.nodeName));
        for (var ti in ei) {
          var fi = ei[ti];
          fi != null && (Ir && jr.length == 1 && jr.push(Ur = new Br(qr.isInline ? "span" : "div")), ti == "class" ? Ur.class = (Ur.class ? Ur.class + " " : "") + fi : ti == "style" ? Ur.style = (Ur.style ? Ur.style + ";" : "") + fi : ti != "nodeName" && (Ur[ti] = fi));
        }
      }
    }
    return jr;
  }
  function ai(Sr, qr, Ir, Ur) {
    if (Ir == zr && Ur == zr)
      return qr;
    for (var jr = qr, Vr = 0; Vr < Ur.length; Vr++) {
      var ei = Ur[Vr], ti = Ir[Vr];
      if (Vr) {
        var fi = void 0;
        ti && ti.nodeName == ei.nodeName && jr != Sr && (fi = jr.parentNode) && fi.nodeName.toLowerCase() == ei.nodeName || (fi = document.createElement(ei.nodeName), fi.pmIsDeco = !0, fi.appendChild(jr), ti = zr[0]), jr = fi;
      }
      vi(jr, ti || zr[0], ei);
    }
    return jr;
  }
  function vi(Sr, qr, Ir) {
    for (var Ur in qr)
      Ur != "class" && Ur != "style" && Ur != "nodeName" && !(Ur in Ir) && Sr.removeAttribute(Ur);
    for (var jr in Ir)
      jr != "class" && jr != "style" && jr != "nodeName" && Ir[jr] != qr[jr] && Sr.setAttribute(jr, Ir[jr]);
    if (qr.class != Ir.class) {
      for (var Vr = qr.class ? qr.class.split(" ").filter(Boolean) : [], ei = Ir.class ? Ir.class.split(" ").filter(Boolean) : [], ti = 0; ti < Vr.length; ti++)
        ei.indexOf(Vr[ti]) == -1 && Sr.classList.remove(Vr[ti]);
      for (var fi = 0; fi < ei.length; fi++)
        Vr.indexOf(ei[fi]) == -1 && Sr.classList.add(ei[fi]);
      Sr.classList.length == 0 && Sr.removeAttribute("class");
    }
    if (qr.style != Ir.style) {
      if (qr.style)
        for (var ki = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, Ri; Ri = ki.exec(qr.style); )
          Sr.style.removeProperty(Ri[1]);
      Ir.style && (Sr.style.cssText += Ir.style);
    }
  }
  function Ti(Sr, qr, Ir) {
    return ai(Sr, Sr, zr, Xr(qr, Ir, Sr.nodeType != 1));
  }
  function Fi(Sr, qr) {
    if (Sr.length != qr.length)
      return !1;
    for (var Ir = 0; Ir < Sr.length; Ir++)
      if (!Sr[Ir].type.eq(qr[Ir].type))
        return !1;
    return !0;
  }
  function ra(Sr) {
    var qr = Sr.nextSibling;
    return Sr.parentNode.removeChild(Sr), qr;
  }
  var pa = function() {
    function Sr(qr, Ir, Ur) {
      Tr(this, Sr), this.lock = Ir, this.view = Ur, this.index = 0, this.stack = [], this.changed = !1, this.top = qr, this.preMatch = ca(qr.node.content, qr);
    }
    return Er(Sr, [{
      key: "destroyBetween",
      value: function(Ir, Ur) {
        if (Ir != Ur) {
          for (var jr = Ir; jr < Ur; jr++)
            this.top.children[jr].destroy();
          this.top.children.splice(Ir, Ur - Ir), this.changed = !0;
        }
      }
    }, {
      key: "destroyRest",
      value: function() {
        this.destroyBetween(this.index, this.top.children.length);
      }
    }, {
      key: "syncToMarks",
      value: function(Ir, Ur, jr) {
        for (var Vr = 0, ei = this.stack.length >> 1, ti = Math.min(ei, Ir.length); Vr < ti && (Vr == ei - 1 ? this.top : this.stack[Vr + 1 << 1]).matchesMark(Ir[Vr]) && Ir[Vr].type.spec.spanning !== !1; )
          Vr++;
        for (; Vr < ei; )
          this.destroyRest(), this.top.dirty = Wa, this.index = this.stack.pop(), this.top = this.stack.pop(), ei--;
        for (; ei < Ir.length; ) {
          this.stack.push(this.top, this.index + 1);
          for (var fi = -1, ki = this.index; ki < Math.min(this.index + 3, this.top.children.length); ki++) {
            var Ri = this.top.children[ki];
            if (Ri.matchesMark(Ir[ei]) && !this.isLocked(Ri.dom)) {
              fi = ki;
              break;
            }
          }
          if (fi > -1)
            fi > this.index && (this.changed = !0, this.destroyBetween(this.index, fi)), this.top = this.top.children[this.index];
          else {
            var ji = Eo.create(this.top, Ir[ei], Ur, jr);
            this.top.children.splice(this.index, 0, ji), this.top = ji, this.changed = !0;
          }
          this.index = 0, ei++;
        }
      }
    }, {
      key: "findNodeMatch",
      value: function(Ir, Ur, jr, Vr) {
        var ei = -1, ti;
        if (Vr >= this.preMatch.index && (ti = this.preMatch.matches[Vr - this.preMatch.index]).parent == this.top && ti.matchesNode(Ir, Ur, jr))
          ei = this.top.children.indexOf(ti, this.index);
        else
          for (var fi = this.index, ki = Math.min(this.top.children.length, fi + 5); fi < ki; fi++) {
            var Ri = this.top.children[fi];
            if (Ri.matchesNode(Ir, Ur, jr) && !this.preMatch.matched.has(Ri)) {
              ei = fi;
              break;
            }
          }
        return ei < 0 ? !1 : (this.destroyBetween(this.index, ei), this.index++, !0);
      }
    }, {
      key: "updateNodeAt",
      value: function(Ir, Ur, jr, Vr, ei) {
        var ti = this.top.children[Vr];
        return ti.dirty == oo && ti.dom == ti.contentDOM && (ti.dirty = to), ti.update(Ir, Ur, jr, ei) ? (this.destroyBetween(this.index, Vr), this.index++, !0) : !1;
      }
    }, {
      key: "findIndexWithChild",
      value: function(Ir) {
        for (; ; ) {
          var Ur = Ir.parentNode;
          if (!Ur)
            return -1;
          if (Ur == this.top.contentDOM) {
            var jr = Ir.pmViewDesc;
            if (jr) {
              for (var Vr = this.index; Vr < this.top.children.length; Vr++)
                if (this.top.children[Vr] == jr)
                  return Vr;
            }
            return -1;
          }
          Ir = Ur;
        }
      }
    }, {
      key: "updateNextNode",
      value: function(Ir, Ur, jr, Vr, ei, ti) {
        for (var fi = this.index; fi < this.top.children.length; fi++) {
          var ki = this.top.children[fi];
          if (ki instanceof lo) {
            var Ri = this.preMatch.matched.get(ki);
            if (Ri != null && Ri != ei)
              return !1;
            var ji = ki.dom, Bi = void 0, Qi = this.isLocked(ji) && !(Ir.isText && ki.node && ki.node.isText && ki.nodeDOM.nodeValue == Ir.text && ki.dirty != oo && Fi(Ur, ki.outerDeco));
            if (!Qi && ki.update(Ir, Ur, jr, Vr))
              return this.destroyBetween(this.index, fi), ki.dom != ji && (this.changed = !0), this.index++, !0;
            if (!Qi && (Bi = this.recreateWrapper(ki, Ir, Ur, jr, Vr, ti)))
              return this.top.children[this.index] = Bi, Bi.contentDOM && (Bi.dirty = to, Bi.updateChildren(Vr, ti + 1), Bi.dirty = Wa), this.changed = !0, this.index++, !0;
            break;
          }
        }
        return !1;
      }
    }, {
      key: "recreateWrapper",
      value: function(Ir, Ur, jr, Vr, ei, ti) {
        if (Ir.dirty || Ur.isAtom || !Ir.children.length || !Ir.node.content.eq(Ur.content))
          return null;
        var fi = lo.create(this.top, Ur, jr, Vr, ei, ti);
        if (fi.contentDOM) {
          fi.children = Ir.children, Ir.children = [];
          var ki = ar(fi.children), Ri;
          try {
            for (ki.s(); !(Ri = ki.n()).done; ) {
              var ji = Ri.value;
              ji.parent = fi;
            }
          } catch (Bi) {
            ki.e(Bi);
          } finally {
            ki.f();
          }
        }
        return Ir.destroy(), fi;
      }
    }, {
      key: "addNode",
      value: function(Ir, Ur, jr, Vr, ei) {
        var ti = lo.create(this.top, Ir, Ur, jr, Vr, ei);
        ti.contentDOM && ti.updateChildren(Vr, ei + 1), this.top.children.splice(this.index++, 0, ti), this.changed = !0;
      }
    }, {
      key: "placeWidget",
      value: function(Ir, Ur, jr) {
        var Vr = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (Vr && Vr.matchesWidget(Ir) && (Ir == Vr.widget || !Vr.widget.type.toDOM.parentNode))
          this.index++;
        else {
          var ei = new Io(this.top, Ir, Ur, jr);
          this.top.children.splice(this.index++, 0, ei), this.changed = !0;
        }
      }
    }, {
      key: "addTextblockHacks",
      value: function() {
        for (var Ir = this.top.children[this.index - 1], Ur = this.top; Ir instanceof Eo; )
          Ur = Ir, Ir = Ur.children[Ur.children.length - 1];
        (!Ir || !(Ir instanceof qi) || /\n$/.test(Ir.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(Ir.node.text)) && ((mi || Mi) && Ir && Ir.dom.contentEditable == "false" && this.addHackNode("IMG", Ur), this.addHackNode("BR", this.top));
      }
    }, {
      key: "addHackNode",
      value: function(Ir, Ur) {
        if (Ur == this.top && this.index < Ur.children.length && Ur.children[this.index].matchesHack(Ir))
          this.index++;
        else {
          var jr = document.createElement(Ir);
          Ir == "IMG" && (jr.className = "ProseMirror-separator", jr.alt = ""), Ir == "BR" && (jr.className = "ProseMirror-trailingBreak");
          var Vr = new sa(this.top, [], jr, null);
          Ur != this.top ? Ur.children.push(Vr) : Ur.children.splice(this.index++, 0, Vr), this.changed = !0;
        }
      }
    }, {
      key: "isLocked",
      value: function(Ir) {
        return this.lock && (Ir == this.lock || Ir.nodeType == 1 && Ir.contains(this.lock.parentNode));
      }
    }]), Sr;
  }();
  function ca(Sr, qr) {
    var Ir = qr, Ur = Ir.children.length, jr = Sr.childCount, Vr = /* @__PURE__ */ new Map(), ei = [];
    e:
      for (; jr > 0; ) {
        for (var ti = void 0; ; )
          if (Ur) {
            var fi = Ir.children[Ur - 1];
            if (fi instanceof Eo)
              Ir = fi, Ur = fi.children.length;
            else {
              ti = fi, Ur--;
              break;
            }
          } else {
            if (Ir == qr)
              break e;
            Ur = Ir.parent.children.indexOf(Ir), Ir = Ir.parent;
          }
        var ki = ti.node;
        if (ki) {
          if (ki != Sr.child(jr - 1))
            break;
          --jr, Vr.set(ti, jr), ei.push(ti);
        }
      }
    return {
      index: jr,
      matched: Vr,
      matches: ei.reverse()
    };
  }
  function da(Sr, qr) {
    return Sr.type.side - qr.type.side;
  }
  function qa(Sr, qr, Ir, Ur) {
    var jr = qr.locals(Sr), Vr = 0;
    if (jr.length == 0) {
      for (var ei = 0; ei < Sr.childCount; ei++) {
        var ti = Sr.child(ei);
        Ur(ti, jr, qr.forChild(Vr, ti), ei), Vr += ti.nodeSize;
      }
      return;
    }
    for (var fi = 0, ki = [], Ri = null, ji = 0; ; ) {
      for (var Bi = void 0, Qi = void 0; fi < jr.length && jr[fi].to == Vr; ) {
        var na = jr[fi++];
        na.widget && (Bi ? (Qi || (Qi = [Bi])).push(na) : Bi = na);
      }
      if (Bi)
        if (Qi) {
          Qi.sort(da);
          for (var Ea = 0; Ea < Qi.length; Ea++)
            Ir(Qi[Ea], ji, !!Ri);
        } else
          Ir(Bi, ji, !!Ri);
      var La = void 0, fa = void 0;
      if (Ri)
        fa = -1, La = Ri, Ri = null;
      else if (ji < Sr.childCount)
        fa = ji, La = Sr.child(ji++);
      else
        break;
      for (var so = 0; so < ki.length; so++)
        ki[so].to <= Vr && ki.splice(so--, 1);
      for (; fi < jr.length && jr[fi].from <= Vr && jr[fi].to > Vr; )
        ki.push(jr[fi++]);
      var Za = Vr + La.nodeSize;
      if (La.isText) {
        var no = Za;
        fi < jr.length && jr[fi].from < no && (no = jr[fi].from);
        for (var Ga = 0; Ga < ki.length; Ga++)
          ki[Ga].to < no && (no = ki[Ga].to);
        no < Za && (Ri = La.cut(no - Vr), La = La.cut(0, no - Vr), Za = no, fa = -1);
      }
      var Ja = La.isInline && !La.isLeaf ? ki.filter(function(ho) {
        return !ho.inline;
      }) : ki.slice();
      Ur(La, Ja, qr.forChild(Vr, La), fa), Vr = Za;
    }
  }
  function co(Sr) {
    if (Sr.nodeName == "UL" || Sr.nodeName == "OL") {
      var qr = Sr.style.cssText;
      Sr.style.cssText = qr + "; list-style: square !important", window.getComputedStyle(Sr).listStyle, Sr.style.cssText = qr;
    }
  }
  function yo(Sr, qr) {
    for (; ; ) {
      if (Sr.nodeType == 3)
        return Sr;
      if (Sr.nodeType == 1 && qr > 0) {
        if (Sr.childNodes.length > qr && Sr.childNodes[qr].nodeType == 3)
          return Sr.childNodes[qr];
        Sr = Sr.childNodes[qr - 1], qr = oi(Sr);
      } else if (Sr.nodeType == 1 && qr < Sr.childNodes.length)
        Sr = Sr.childNodes[qr], qr = 0;
      else
        return null;
    }
  }
  function Mo(Sr, qr, Ir, Ur) {
    for (var jr = 0, Vr = 0; jr < Sr.childCount && Vr <= Ur; ) {
      var ei = Sr.child(jr++), ti = Vr;
      if (Vr += ei.nodeSize, !!ei.isText) {
        for (var fi = ei.text; jr < Sr.childCount; ) {
          var ki = Sr.child(jr++);
          if (Vr += ki.nodeSize, !ki.isText)
            break;
          fi += ki.text;
        }
        if (Vr >= Ir) {
          if (Vr >= Ur && fi.slice(Ur - qr.length - ti, Ur - ti) == qr)
            return Ur - qr.length;
          var Ri = ti < Ur ? fi.lastIndexOf(qr, Ur - ti - 1) : -1;
          if (Ri >= 0 && Ri + qr.length + ti >= Ir)
            return ti + Ri;
          if (Ir == Ur && fi.length >= Ur + qr.length - ti && fi.slice(Ur - ti, Ur - ti + qr.length) == qr)
            return Ur;
        }
      }
    }
    return -1;
  }
  function Oo(Sr, qr, Ir, Ur, jr) {
    for (var Vr = [], ei = 0, ti = 0; ei < Sr.length; ei++) {
      var fi = Sr[ei], ki = ti, Ri = ti += fi.size;
      ki >= Ir || Ri <= qr ? Vr.push(fi) : (ki < qr && Vr.push(fi.slice(0, qr - ki, Ur)), jr && (Vr.push(jr), jr = void 0), Ri > Ir && Vr.push(fi.slice(Ir - ki, fi.size, Ur)));
    }
    return Vr;
  }
  function Do(Sr) {
    var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Ir = Sr.domSelectionRange(), Ur = Sr.state.doc;
    if (!Ir.focusNode)
      return null;
    var jr = Sr.docView.nearestDesc(Ir.focusNode), Vr = jr && jr.size == 0, ei = Sr.docView.posFromDOM(Ir.focusNode, Ir.focusOffset, 1);
    if (ei < 0)
      return null;
    var ti = Ur.resolve(ei), fi, ki;
    if (li(Ir)) {
      for (fi = ti; jr && !jr.node; )
        jr = jr.parent;
      var Ri = jr.node;
      if (jr && Ri.isAtom && xr.NodeSelection.isSelectable(Ri) && jr.parent && !(Ri.isInline && Jr(Ir.focusNode, Ir.focusOffset, jr.dom))) {
        var ji = jr.posBefore;
        ki = new xr.NodeSelection(ei == ji ? ti : Ur.resolve(ji));
      }
    } else {
      var Bi = Sr.docView.posFromDOM(Ir.anchorNode, Ir.anchorOffset, 1);
      if (Bi < 0)
        return null;
      fi = Ur.resolve(Bi);
    }
    if (!ki) {
      var Qi = qr == "pointer" || Sr.state.selection.head < ti.pos && !Vr ? 1 : -1;
      ki = Ss(Sr, fi, ti, Qi);
    }
    return ki;
  }
  function us(Sr) {
    return Sr.editable ? Sr.hasFocus() : Fs(Sr) && document.activeElement && document.activeElement.contains(Sr.dom);
  }
  function Bo(Sr) {
    var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, Ir = Sr.state.selection;
    if (zs(Sr, Ir), !!us(Sr)) {
      if (!qr && Sr.input.mouseDown && Sr.input.mouseDown.allowDefault && Mi) {
        var Ur = Sr.domSelectionRange(), jr = Sr.domObserver.currentSelection;
        if (Ur.anchorNode && jr.anchorNode && $r(Ur.anchorNode, Ur.anchorOffset, jr.anchorNode, jr.anchorOffset)) {
          Sr.input.mouseDown.delayedSelectionSync = !0, Sr.domObserver.setCurSelection();
          return;
        }
      }
      if (Sr.domObserver.disconnectSelection(), Sr.cursorWrapper)
        rs(Sr);
      else {
        var Vr = Ir.anchor, ei = Ir.head, ti, fi;
        fs && !(Ir instanceof xr.TextSelection) && (Ir.$from.parent.inlineContent || (ti = Us(Sr, Ir.from)), !Ir.empty && !Ir.$from.parent.inlineContent && (fi = Us(Sr, Ir.to))), Sr.docView.setSelection(Vr, ei, Sr.root, qr), fs && (ti && es(ti), fi && es(fi)), Ir.visible ? Sr.dom.classList.remove("ProseMirror-hideselection") : (Sr.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && ts(Sr));
      }
      Sr.domObserver.setCurSelection(), Sr.domObserver.connectSelection();
    }
  }
  var fs = mi || Mi && Ii < 63;
  function Us(Sr, qr) {
    var Ir = Sr.docView.domFromPos(qr, 0), Ur = Ir.node, jr = Ir.offset, Vr = jr < Ur.childNodes.length ? Ur.childNodes[jr] : null, ei = jr ? Ur.childNodes[jr - 1] : null;
    if (mi && Vr && Vr.contentEditable == "false")
      return ds(Vr);
    if ((!Vr || Vr.contentEditable == "false") && (!ei || ei.contentEditable == "false")) {
      if (Vr)
        return ds(Vr);
      if (ei)
        return ds(ei);
    }
  }
  function ds(Sr) {
    return Sr.contentEditable = "true", mi && Sr.draggable && (Sr.draggable = !1, Sr.wasDraggable = !0), Sr;
  }
  function es(Sr) {
    Sr.contentEditable = "false", Sr.wasDraggable && (Sr.draggable = !0, Sr.wasDraggable = null);
  }
  function ts(Sr) {
    var qr = Sr.dom.ownerDocument;
    qr.removeEventListener("selectionchange", Sr.input.hideSelectionGuard);
    var Ir = Sr.domSelectionRange(), Ur = Ir.anchorNode, jr = Ir.anchorOffset;
    qr.addEventListener("selectionchange", Sr.input.hideSelectionGuard = function() {
      (Ir.anchorNode != Ur || Ir.anchorOffset != jr) && (qr.removeEventListener("selectionchange", Sr.input.hideSelectionGuard), setTimeout(function() {
        (!us(Sr) || Sr.state.selection.visible) && Sr.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function rs(Sr) {
    var qr = Sr.domSelection(), Ir = document.createRange(), Ur = Sr.cursorWrapper.dom, jr = Ur.nodeName == "IMG";
    jr ? Ir.setEnd(Ur.parentNode, Lr(Ur) + 1) : Ir.setEnd(Ur, 0), Ir.collapse(!1), qr.removeAllRanges(), qr.addRange(Ir), !jr && !Sr.state.selection.visible && Ui && yi <= 11 && (Ur.disabled = !0, Ur.disabled = !1);
  }
  function zs(Sr, qr) {
    if (qr instanceof xr.NodeSelection) {
      var Ir = Sr.docView.descAt(qr.from);
      Ir != Sr.lastSelectedViewDesc && (qs(Sr), Ir && Ir.selectNode(), Sr.lastSelectedViewDesc = Ir);
    } else
      qs(Sr);
  }
  function qs(Sr) {
    Sr.lastSelectedViewDesc && (Sr.lastSelectedViewDesc.parent && Sr.lastSelectedViewDesc.deselectNode(), Sr.lastSelectedViewDesc = void 0);
  }
  function Ss(Sr, qr, Ir, Ur) {
    return Sr.someProp("createSelectionBetween", function(jr) {
      return jr(Sr, qr, Ir);
    }) || xr.TextSelection.between(qr, Ir, Ur);
  }
  function Is(Sr) {
    return Sr.editable && !Sr.hasFocus() ? !1 : Fs(Sr);
  }
  function Fs(Sr) {
    var qr = Sr.domSelectionRange();
    if (!qr.anchorNode)
      return !1;
    try {
      return Sr.dom.contains(qr.anchorNode.nodeType == 3 ? qr.anchorNode.parentNode : qr.anchorNode) && (Sr.editable || Sr.dom.contains(qr.focusNode.nodeType == 3 ? qr.focusNode.parentNode : qr.focusNode));
    } catch (Ir) {
      return !1;
    }
  }
  function js(Sr) {
    var qr = Sr.docView.domFromPos(Sr.state.selection.anchor, 0), Ir = Sr.domSelectionRange();
    return $r(qr.node, qr.offset, Ir.anchorNode, Ir.anchorOffset);
  }
  function hs(Sr, qr) {
    var Ir = Sr.selection, Ur = Ir.$anchor, jr = Ir.$head, Vr = qr > 0 ? Ur.max(jr) : Ur.min(jr), ei = Vr.parent.inlineContent ? Vr.depth ? Sr.doc.resolve(qr > 0 ? Vr.after() : Vr.before()) : null : Vr;
    return ei && xr.Selection.findFrom(ei, qr);
  }
  function xo(Sr, qr) {
    return Sr.dispatch(Sr.state.tr.setSelection(qr).scrollIntoView()), !0;
  }
  function ps(Sr, qr, Ir) {
    var Ur = Sr.state.selection;
    if (Ur instanceof xr.TextSelection)
      if (Ir.indexOf("s") > -1) {
        var jr = Ur.$head, Vr = jr.textOffset ? null : qr < 0 ? jr.nodeBefore : jr.nodeAfter;
        if (!Vr || Vr.isText || !Vr.isLeaf)
          return !1;
        var ei = Sr.state.doc.resolve(jr.pos + Vr.nodeSize * (qr < 0 ? -1 : 1));
        return xo(Sr, new xr.TextSelection(Ur.$anchor, ei));
      } else if (Ur.empty) {
        if (Sr.endOfTextblock(qr > 0 ? "forward" : "backward")) {
          var ti = hs(Sr.state, qr);
          return ti && ti instanceof xr.NodeSelection ? xo(Sr, ti) : !1;
        } else if (!(Ci && Ir.indexOf("m") > -1)) {
          var fi = Ur.$head, ki = fi.textOffset ? null : qr < 0 ? fi.nodeBefore : fi.nodeAfter, Ri;
          if (!ki || ki.isText)
            return !1;
          var ji = qr < 0 ? fi.pos - ki.nodeSize : fi.pos;
          return ki.isAtom || (Ri = Sr.docView.descAt(ji)) && !Ri.contentDOM ? xr.NodeSelection.isSelectable(ki) ? xo(Sr, new xr.NodeSelection(qr < 0 ? Sr.state.doc.resolve(fi.pos - ki.nodeSize) : fi)) : ia ? xo(Sr, new xr.TextSelection(Sr.state.doc.resolve(qr < 0 ? ji : ji + ki.nodeSize))) : !1 : !1;
        }
      } else
        return !1;
    else {
      if (Ur instanceof xr.NodeSelection && Ur.node.isInline)
        return xo(Sr, new xr.TextSelection(qr > 0 ? Ur.$to : Ur.$from));
      var Bi = hs(Sr.state, qr);
      return Bi ? xo(Sr, Bi) : !1;
    }
  }
  function ns(Sr) {
    return Sr.nodeType == 3 ? Sr.nodeValue.length : Sr.childNodes.length;
  }
  function Po(Sr, qr) {
    var Ir = Sr.pmViewDesc;
    return Ir && Ir.size == 0 && (qr < 0 || Sr.nextSibling || Sr.nodeName != "BR");
  }
  function is(Sr, qr) {
    return qr < 0 ? kl(Sr) : as(Sr);
  }
  function kl(Sr) {
    var qr = Sr.domSelectionRange(), Ir = qr.focusNode, Ur = qr.focusOffset;
    if (Ir) {
      var jr, Vr, ei = !1;
      for (Vi && Ir.nodeType == 1 && Ur < ns(Ir) && Po(Ir.childNodes[Ur], -1) && (ei = !0); ; )
        if (Ur > 0) {
          if (Ir.nodeType != 1)
            break;
          var ti = Ir.childNodes[Ur - 1];
          if (Po(ti, -1))
            jr = Ir, Vr = --Ur;
          else if (ti.nodeType == 3)
            Ir = ti, Ur = Ir.nodeValue.length;
          else
            break;
        } else {
          if (Xo(Ir))
            break;
          for (var fi = Ir.previousSibling; fi && Po(fi, -1); )
            jr = Ir.parentNode, Vr = Lr(fi), fi = fi.previousSibling;
          if (fi)
            Ir = fi, Ur = ns(Ir);
          else {
            if (Ir = Ir.parentNode, Ir == Sr.dom)
              break;
            Ur = 0;
          }
        }
      ei ? Ls(Sr, Ir, Ur) : jr && Ls(Sr, jr, Vr);
    }
  }
  function as(Sr) {
    var qr = Sr.domSelectionRange(), Ir = qr.focusNode, Ur = qr.focusOffset;
    if (Ir) {
      for (var jr = ns(Ir), Vr, ei; ; )
        if (Ur < jr) {
          if (Ir.nodeType != 1)
            break;
          var ti = Ir.childNodes[Ur];
          if (Po(ti, 1))
            Vr = Ir, ei = ++Ur;
          else
            break;
        } else {
          if (Xo(Ir))
            break;
          for (var fi = Ir.nextSibling; fi && Po(fi, 1); )
            Vr = fi.parentNode, ei = Lr(fi) + 1, fi = fi.nextSibling;
          if (fi)
            Ir = fi, Ur = 0, jr = ns(Ir);
          else {
            if (Ir = Ir.parentNode, Ir == Sr.dom)
              break;
            Ur = jr = 0;
          }
        }
      Vr && Ls(Sr, Vr, ei);
    }
  }
  function Xo(Sr) {
    var qr = Sr.pmViewDesc;
    return qr && qr.node && qr.node.isBlock;
  }
  function _l(Sr, qr) {
    for (; Sr && qr == Sr.childNodes.length && !Yr(Sr); )
      qr = Lr(Sr) + 1, Sr = Sr.parentNode;
    for (; Sr && qr < Sr.childNodes.length; ) {
      var Ir = Sr.childNodes[qr];
      if (Ir.nodeType == 3)
        return Ir;
      if (Ir.nodeType == 1 && Ir.contentEditable == "false")
        break;
      Sr = Ir, qr = 0;
    }
  }
  function $s(Sr, qr) {
    for (; Sr && !qr && !Yr(Sr); )
      qr = Lr(Sr), Sr = Sr.parentNode;
    for (; Sr && qr; ) {
      var Ir = Sr.childNodes[qr - 1];
      if (Ir.nodeType == 3)
        return Ir;
      if (Ir.nodeType == 1 && Ir.contentEditable == "false")
        break;
      Sr = Ir, qr = Sr.childNodes.length;
    }
  }
  function Ls(Sr, qr, Ir) {
    if (qr.nodeType != 3) {
      var Ur, jr;
      (jr = _l(qr, Ir)) ? (qr = jr, Ir = 0) : (Ur = $s(qr, Ir)) && (qr = Ur, Ir = Ur.nodeValue.length);
    }
    var Vr = Sr.domSelection();
    if (li(Vr)) {
      var ei = document.createRange();
      ei.setEnd(qr, Ir), ei.setStart(qr, Ir), Vr.removeAllRanges(), Vr.addRange(ei);
    } else
      Vr.extend && Vr.extend(qr, Ir);
    Sr.domObserver.setCurSelection();
    var ti = Sr.state;
    setTimeout(function() {
      Sr.state == ti && Bo(Sr);
    }, 50);
  }
  function Vs(Sr, qr) {
    var Ir = Sr.state.doc.resolve(qr);
    if (!(Mi || Ki) && Ir.parent.inlineContent) {
      var Ur = Sr.coordsAtPos(qr);
      if (qr > Ir.start()) {
        var jr = Sr.coordsAtPos(qr - 1), Vr = (jr.top + jr.bottom) / 2;
        if (Vr > Ur.top && Vr < Ur.bottom && Math.abs(jr.left - Ur.left) > 1)
          return jr.left < Ur.left ? "ltr" : "rtl";
      }
      if (qr < Ir.end()) {
        var ei = Sr.coordsAtPos(qr + 1), ti = (ei.top + ei.bottom) / 2;
        if (ti > Ur.top && ti < Ur.bottom && Math.abs(ei.left - Ur.left) > 1)
          return ei.left > Ur.left ? "ltr" : "rtl";
      }
    }
    var fi = getComputedStyle(Sr.dom).direction;
    return fi == "rtl" ? "rtl" : "ltr";
  }
  function gs(Sr, qr, Ir) {
    var Ur = Sr.state.selection;
    if (Ur instanceof xr.TextSelection && !Ur.empty || Ir.indexOf("s") > -1 || Ci && Ir.indexOf("m") > -1)
      return !1;
    var jr = Ur.$from, Vr = Ur.$to;
    if (!jr.parent.inlineContent || Sr.endOfTextblock(qr < 0 ? "up" : "down")) {
      var ei = hs(Sr.state, qr);
      if (ei && ei instanceof xr.NodeSelection)
        return xo(Sr, ei);
    }
    if (!jr.parent.inlineContent) {
      var ti = qr < 0 ? jr : Vr, fi = Ur instanceof xr.AllSelection ? xr.Selection.near(ti, qr) : xr.Selection.findFrom(ti, qr);
      return fi ? xo(Sr, fi) : !1;
    }
    return !1;
  }
  function Ms(Sr, qr) {
    if (!(Sr.state.selection instanceof xr.TextSelection))
      return !0;
    var Ir = Sr.state.selection, Ur = Ir.$head, jr = Ir.$anchor, Vr = Ir.empty;
    if (!Ur.sameParent(jr))
      return !0;
    if (!Vr)
      return !1;
    if (Sr.endOfTextblock(qr > 0 ? "forward" : "backward"))
      return !0;
    var ei = !Ur.textOffset && (qr < 0 ? Ur.nodeBefore : Ur.nodeAfter);
    if (ei && !ei.isText) {
      var ti = Sr.state.tr;
      return qr < 0 ? ti.delete(Ur.pos - ei.nodeSize, Ur.pos) : ti.delete(Ur.pos, Ur.pos + ei.nodeSize), Sr.dispatch(ti), !0;
    }
    return !1;
  }
  function ol(Sr, qr, Ir) {
    Sr.domObserver.stop(), qr.contentEditable = Ir, Sr.domObserver.start();
  }
  function Ho(Sr) {
    if (!mi || Sr.state.selection.$head.parentOffset > 0)
      return !1;
    var qr = Sr.domSelectionRange(), Ir = qr.focusNode, Ur = qr.focusOffset;
    if (Ir && Ir.nodeType == 1 && Ur == 0 && Ir.firstChild && Ir.firstChild.contentEditable == "false") {
      var jr = Ir.firstChild;
      ol(Sr, jr, "true"), setTimeout(function() {
        return ol(Sr, jr, "false");
      }, 20);
    }
    return !1;
  }
  function sl(Sr) {
    var qr = "";
    return Sr.ctrlKey && (qr += "c"), Sr.metaKey && (qr += "m"), Sr.altKey && (qr += "a"), Sr.shiftKey && (qr += "s"), qr;
  }
  function cl(Sr, qr) {
    var Ir = qr.keyCode, Ur = sl(qr);
    if (Ir == 8 || Ci && Ir == 72 && Ur == "c")
      return Ms(Sr, -1) || is(Sr, -1);
    if (Ir == 46 && !qr.shiftKey || Ci && Ir == 68 && Ur == "c")
      return Ms(Sr, 1) || is(Sr, 1);
    if (Ir == 13 || Ir == 27)
      return !0;
    if (Ir == 37 || Ci && Ir == 66 && Ur == "c") {
      var jr = Ir == 37 ? Vs(Sr, Sr.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return ps(Sr, jr, Ur) || is(Sr, jr);
    } else if (Ir == 39 || Ci && Ir == 70 && Ur == "c") {
      var Vr = Ir == 39 ? Vs(Sr, Sr.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return ps(Sr, Vr, Ur) || is(Sr, Vr);
    } else {
      if (Ir == 38 || Ci && Ir == 80 && Ur == "c")
        return gs(Sr, -1, Ur) || is(Sr, -1);
      if (Ir == 40 || Ci && Ir == 78 && Ur == "c")
        return Ho(Sr) || gs(Sr, 1, Ur) || is(Sr, 1);
      if (Ur == (Ci ? "m" : "c") && (Ir == 66 || Ir == 73 || Ir == 89 || Ir == 90))
        return !0;
    }
    return !1;
  }
  function Rs(Sr, qr) {
    Sr.someProp("transformCopied", function(fa) {
      qr = fa(qr, Sr);
    });
    for (var Ir = [], Ur = qr, jr = Ur.content, Vr = Ur.openStart, ei = Ur.openEnd; Vr > 1 && ei > 1 && jr.childCount == 1 && jr.firstChild.childCount == 1; ) {
      Vr--, ei--;
      var ti = jr.firstChild;
      Ir.push(ti.type.name, ti.attrs != ti.type.defaultAttrs ? ti.attrs : null), jr = ti.content;
    }
    var fi = Sr.someProp("clipboardSerializer") || Cr.DOMSerializer.fromSchema(Sr.state.schema), ki = Sa(), Ri = ki.createElement("div");
    Ri.appendChild(fi.serializeFragment(jr, {
      document: ki
    }));
    for (var ji = Ri.firstChild, Bi, Qi = 0; ji && ji.nodeType == 1 && (Bi = $i[ji.nodeName.toLowerCase()]); ) {
      for (var na = Bi.length - 1; na >= 0; na--) {
        for (var Ea = ki.createElement(Bi[na]); Ri.firstChild; )
          Ea.appendChild(Ri.firstChild);
        Ri.appendChild(Ea), Qi++;
      }
      ji = Ri.firstChild;
    }
    ji && ji.nodeType == 1 && ji.setAttribute("data-pm-slice", "".concat(Vr, " ").concat(ei).concat(Qi ? " -".concat(Qi) : "", " ").concat(JSON.stringify(Ir)));
    var La = Sr.someProp("clipboardTextSerializer", function(fa) {
      return fa(qr, Sr);
    }) || qr.content.textBetween(0, qr.content.size, `

`);
    return {
      dom: Ri,
      text: La
    };
  }
  function Ks(Sr, qr, Ir, Ur, jr) {
    var Vr = jr.parent.type.spec.code, ei, ti;
    if (!Ir && !qr)
      return null;
    var fi = qr && (Ur || Vr || !Ir);
    if (fi) {
      if (Sr.someProp("transformPastedText", function(Ja) {
        qr = Ja(qr, Vr || Ur, Sr);
      }), Vr)
        return qr ? new Cr.Slice(Cr.Fragment.from(Sr.state.schema.text(qr.replace(/\r\n?/g, `
`))), 0, 0) : Cr.Slice.empty;
      var ki = Sr.someProp("clipboardTextParser", function(Ja) {
        return Ja(qr, jr, Ur, Sr);
      });
      if (ki)
        ti = ki;
      else {
        var Ri = jr.marks(), ji = Sr.state.schema, Bi = Cr.DOMSerializer.fromSchema(ji);
        ei = document.createElement("div"), qr.split(/(?:\r\n?|\n)+/).forEach(function(Ja) {
          var ho = ei.appendChild(document.createElement("p"));
          Ja && ho.appendChild(Bi.serializeNode(ji.text(Ja, Ri)));
        });
      }
    } else
      Sr.someProp("transformPastedHTML", function(Ja) {
        Ir = Ja(Ir, Sr);
      }), ei = ro(Ir), ia && ko(ei);
    var Qi = ei && ei.querySelector("[data-pm-slice]"), na = Qi && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(Qi.getAttribute("data-pm-slice") || "");
    if (na && na[3])
      for (var Ea = +na[3]; Ea > 0; Ea--) {
        for (var La = ei.firstChild; La && La.nodeType != 1; )
          La = La.nextSibling;
        if (!La)
          break;
        ei = La;
      }
    if (!ti) {
      var fa = Sr.someProp("clipboardParser") || Sr.someProp("domParser") || Cr.DOMParser.fromSchema(Sr.state.schema);
      ti = fa.parseSlice(ei, {
        preserveWhitespace: !!(fi || na),
        context: jr,
        ruleFromNode: function(ho) {
          return ho.nodeName == "BR" && !ho.nextSibling && ho.parentNode && !vs.test(ho.parentNode.nodeName) ? {
            ignore: !0
          } : null;
        }
      });
    }
    if (na)
      ti = _o(Ma(ti, +na[1], +na[2]), na[4]);
    else if (ti = Cr.Slice.maxOpen(Uo(ti.content, jr), !0), ti.openStart || ti.openEnd) {
      for (var so = 0, Za = 0, no = ti.content.firstChild; so < ti.openStart && !no.type.spec.isolating; so++, no = no.firstChild)
        ;
      for (var Ga = ti.content.lastChild; Za < ti.openEnd && !Ga.type.spec.isolating; Za++, Ga = Ga.lastChild)
        ;
      ti = Ma(ti, so, Za);
    }
    return Sr.someProp("transformPasted", function(Ja) {
      ti = Ja(ti, Sr);
    }), ti;
  }
  var vs = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function Uo(Sr, qr) {
    if (Sr.childCount < 2)
      return Sr;
    for (var Ir = function(ei) {
      var ti = qr.node(ei), fi = ti.contentMatchAt(qr.index(ei)), ki = void 0, Ri = [];
      if (Sr.forEach(function(ji) {
        if (Ri) {
          var Bi = fi.findWrapping(ji.type), Qi;
          if (!Bi)
            return Ri = null;
          if (Qi = Ri.length && ki.length && Ws(Bi, ki, ji, Ri[Ri.length - 1], 0))
            Ri[Ri.length - 1] = Qi;
          else {
            Ri.length && (Ri[Ri.length - 1] = Zs(Ri[Ri.length - 1], ki.length));
            var na = Gs(ji, Bi);
            Ri.push(na), fi = fi.matchType(na.type), ki = Bi;
          }
        }
      }), Ri)
        return {
          v: Cr.Fragment.from(Ri)
        };
    }, Ur = qr.depth; Ur >= 0; Ur--) {
      var jr = Ir(Ur);
      if (lr(jr) === "object")
        return jr.v;
    }
    return Sr;
  }
  function Gs(Sr, qr) {
    for (var Ir = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, Ur = qr.length - 1; Ur >= Ir; Ur--)
      Sr = qr[Ur].create(null, Cr.Fragment.from(Sr));
    return Sr;
  }
  function Ws(Sr, qr, Ir, Ur, jr) {
    if (jr < Sr.length && jr < qr.length && Sr[jr] == qr[jr]) {
      var Vr = Ws(Sr, qr, Ir, Ur.lastChild, jr + 1);
      if (Vr)
        return Ur.copy(Ur.content.replaceChild(Ur.childCount - 1, Vr));
      var ei = Ur.contentMatchAt(Ur.childCount);
      if (ei.matchType(jr == Sr.length - 1 ? Ir.type : Sr[jr + 1]))
        return Ur.copy(Ur.content.append(Cr.Fragment.from(Gs(Ir, Sr, jr + 1))));
    }
  }
  function Zs(Sr, qr) {
    if (qr == 0)
      return Sr;
    var Ir = Sr.content.replaceChild(Sr.childCount - 1, Zs(Sr.lastChild, qr - 1)), Ur = Sr.contentMatchAt(Sr.childCount).fillBefore(Cr.Fragment.empty, !0);
    return Sr.copy(Ir.append(Ur));
  }
  function Xs(Sr, qr, Ir, Ur, jr, Vr) {
    var ei = qr < 0 ? Sr.firstChild : Sr.lastChild, ti = ei.content;
    return Sr.childCount > 1 && (Vr = 0), jr < Ur - 1 && (ti = Xs(ti, qr, Ir, Ur, jr + 1, Vr)), jr >= Ir && (ti = qr < 0 ? ei.contentMatchAt(0).fillBefore(ti, Vr <= jr).append(ti) : ti.append(ei.contentMatchAt(ei.childCount).fillBefore(Cr.Fragment.empty, !0))), Sr.replaceChild(qr < 0 ? 0 : Sr.childCount - 1, ei.copy(ti));
  }
  function Ma(Sr, qr, Ir) {
    return qr < Sr.openStart && (Sr = new Cr.Slice(Xs(Sr.content, -1, qr, Sr.openStart, 0, Sr.openEnd), qr, Sr.openEnd)), Ir < Sr.openEnd && (Sr = new Cr.Slice(Xs(Sr.content, 1, Ir, Sr.openEnd, 0, 0), Sr.openStart, Ir)), Sr;
  }
  var $i = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  }, ga = null;
  function Sa() {
    return ga || (ga = document.implementation.createHTMLDocument("title"));
  }
  function ro(Sr) {
    var qr = /^(\s*<meta [^>]*>)*/.exec(Sr);
    qr && (Sr = Sr.slice(qr[0].length));
    var Ir = Sa().createElement("div"), Ur = /<([a-z][^>\s]+)/i.exec(Sr), jr;
    if ((jr = Ur && $i[Ur[1].toLowerCase()]) && (Sr = jr.map(function(ei) {
      return "<" + ei + ">";
    }).join("") + Sr + jr.map(function(ei) {
      return "</" + ei + ">";
    }).reverse().join("")), Ir.innerHTML = Sr, jr)
      for (var Vr = 0; Vr < jr.length; Vr++)
        Ir = Ir.querySelector(jr[Vr]) || Ir;
    return Ir;
  }
  function ko(Sr) {
    for (var qr = Sr.querySelectorAll(Mi ? "span:not([class]):not([style])" : "span.Apple-converted-space"), Ir = 0; Ir < qr.length; Ir++) {
      var Ur = qr[Ir];
      Ur.childNodes.length == 1 && Ur.textContent == " " && Ur.parentNode && Ur.parentNode.replaceChild(Sr.ownerDocument.createTextNode(" "), Ur);
    }
  }
  function _o(Sr, qr) {
    if (!Sr.size)
      return Sr;
    var Ir = Sr.content.firstChild.type.schema, Ur;
    try {
      Ur = JSON.parse(qr);
    } catch (ki) {
      return Sr;
    }
    for (var jr = Sr.content, Vr = Sr.openStart, ei = Sr.openEnd, ti = Ur.length - 2; ti >= 0; ti -= 2) {
      var fi = Ir.nodes[Ur[ti]];
      if (!fi || fi.hasRequiredAttrs())
        break;
      jr = Cr.Fragment.from(fi.create(Ur[ti + 1], jr)), Vr++, ei++;
    }
    return new Cr.Slice(jr, Vr, ei);
  }
  var Qa = {}, fo = {}, bs = {
    touchstart: !0,
    touchmove: !0
  }, ul = Er(function Sr() {
    Tr(this, Sr), this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = {
      time: 0,
      x: 0,
      y: 0,
      type: ""
    }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  });
  function wl(Sr) {
    var qr = function(jr) {
      var Vr = Qa[jr];
      Sr.dom.addEventListener(jr, Sr.input.eventHandlers[jr] = function(ei) {
        Tc(Sr, ei) && !xl(Sr, ei) && (Sr.editable || !(ei.type in fo)) && Vr(Sr, ei);
      }, bs[jr] ? {
        passive: !0
      } : void 0);
    };
    for (var Ir in Qa)
      qr(Ir);
    mi && Sr.dom.addEventListener("input", function() {
      return null;
    }), El(Sr);
  }
  function Jo(Sr, qr) {
    Sr.input.lastSelectionOrigin = qr, Sr.input.lastSelectionTime = Date.now();
  }
  function Cc(Sr) {
    Sr.domObserver.stop();
    for (var qr in Sr.input.eventHandlers)
      Sr.dom.removeEventListener(qr, Sr.input.eventHandlers[qr]);
    clearTimeout(Sr.input.composingTimeout), clearTimeout(Sr.input.lastIOSEnterFallbackTimeout);
  }
  function El(Sr) {
    Sr.someProp("handleDOMEvents", function(qr) {
      for (var Ir in qr)
        Sr.input.eventHandlers[Ir] || Sr.dom.addEventListener(Ir, Sr.input.eventHandlers[Ir] = function(Ur) {
          return xl(Sr, Ur);
        });
    });
  }
  function xl(Sr, qr) {
    return Sr.someProp("handleDOMEvents", function(Ir) {
      var Ur = Ir[qr.type];
      return Ur ? Ur(Sr, qr) || qr.defaultPrevented : !1;
    });
  }
  function Tc(Sr, qr) {
    if (!qr.bubbles)
      return !0;
    if (qr.defaultPrevented)
      return !1;
    for (var Ir = qr.target; Ir != Sr.dom; Ir = Ir.parentNode)
      if (!Ir || Ir.nodeType == 11 || Ir.pmViewDesc && Ir.pmViewDesc.stopEvent(qr))
        return !1;
    return !0;
  }
  function Ac(Sr, qr) {
    !xl(Sr, qr) && Qa[qr.type] && (Sr.editable || !(qr.type in fo)) && Qa[qr.type](Sr, qr);
  }
  fo.keydown = function(Sr, qr) {
    var Ir = qr;
    if (Sr.input.shiftKey = Ir.keyCode == 16 || Ir.shiftKey, !Bl(Sr, Ir) && (Sr.input.lastKeyCode = Ir.keyCode, Sr.input.lastKeyCodeTime = Date.now(), !(Ni && Mi && Ir.keyCode == 13)))
      if (Ir.keyCode != 229 && Sr.domObserver.forceFlush(), _i && Ir.keyCode == 13 && !Ir.ctrlKey && !Ir.altKey && !Ir.metaKey) {
        var Ur = Date.now();
        Sr.input.lastIOSEnter = Ur, Sr.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          Sr.input.lastIOSEnter == Ur && (Sr.someProp("handleKeyDown", function(jr) {
            return jr(Sr, Si(13, "Enter"));
          }), Sr.input.lastIOSEnter = 0);
        }, 200);
      } else
        Sr.someProp("handleKeyDown", function(jr) {
          return jr(Sr, Ir);
        }) || cl(Sr, Ir) ? Ir.preventDefault() : Jo(Sr, "key");
  }, fo.keyup = function(Sr, qr) {
    qr.keyCode == 16 && (Sr.input.shiftKey = !1);
  }, fo.keypress = function(Sr, qr) {
    var Ir = qr;
    if (!(Bl(Sr, Ir) || !Ir.charCode || Ir.ctrlKey && !Ir.altKey || Ci && Ir.metaKey)) {
      if (Sr.someProp("handleKeyPress", function(Vr) {
        return Vr(Sr, Ir);
      })) {
        Ir.preventDefault();
        return;
      }
      var Ur = Sr.state.selection;
      if (!(Ur instanceof xr.TextSelection) || !Ur.$from.sameParent(Ur.$to)) {
        var jr = String.fromCharCode(Ir.charCode);
        !/[\r\n]/.test(jr) && !Sr.someProp("handleTextInput", function(Vr) {
          return Vr(Sr, Ur.$from.pos, Ur.$to.pos, jr);
        }) && Sr.dispatch(Sr.state.tr.insertText(jr).scrollIntoView()), Ir.preventDefault();
      }
    }
  };
  function fl(Sr) {
    return {
      left: Sr.clientX,
      top: Sr.clientY
    };
  }
  function Ic(Sr, qr) {
    var Ir = qr.x - Sr.clientX, Ur = qr.y - Sr.clientY;
    return Ir * Ir + Ur * Ur < 100;
  }
  function Cl(Sr, qr, Ir, Ur, jr) {
    if (Ur == -1)
      return !1;
    for (var Vr = Sr.state.doc.resolve(Ur), ei = function(Ri) {
      if (Sr.someProp(qr, function(ji) {
        return Ri > Vr.depth ? ji(Sr, Ir, Vr.nodeAfter, Vr.before(Ri), jr, !0) : ji(Sr, Ir, Vr.node(Ri), Vr.before(Ri), jr, !1);
      }))
        return {
          v: !0
        };
    }, ti = Vr.depth + 1; ti > 0; ti--) {
      var fi = ei(ti);
      if (lr(fi) === "object")
        return fi.v;
    }
    return !1;
  }
  function Ns(Sr, qr, Ir) {
    Sr.focused || Sr.focus();
    var Ur = Sr.state.tr.setSelection(qr);
    Ir == "pointer" && Ur.setMeta("pointer", !0), Sr.dispatch(Ur);
  }
  function Lc(Sr, qr) {
    if (qr == -1)
      return !1;
    var Ir = Sr.state.doc.resolve(qr), Ur = Ir.nodeAfter;
    return Ur && Ur.isAtom && xr.NodeSelection.isSelectable(Ur) ? (Ns(Sr, new xr.NodeSelection(Ir), "pointer"), !0) : !1;
  }
  function Mc(Sr, qr) {
    if (qr == -1)
      return !1;
    var Ir = Sr.state.selection, Ur, jr;
    Ir instanceof xr.NodeSelection && (Ur = Ir.node);
    for (var Vr = Sr.state.doc.resolve(qr), ei = Vr.depth + 1; ei > 0; ei--) {
      var ti = ei > Vr.depth ? Vr.nodeAfter : Vr.node(ei);
      if (xr.NodeSelection.isSelectable(ti)) {
        Ur && Ir.$from.depth > 0 && ei >= Ir.$from.depth && Vr.before(Ir.$from.depth + 1) == Ir.$from.pos ? jr = Vr.before(Ir.$from.depth) : jr = Vr.before(ei);
        break;
      }
    }
    return jr != null ? (Ns(Sr, xr.NodeSelection.create(Sr.state.doc, jr), "pointer"), !0) : !1;
  }
  function Rc(Sr, qr, Ir, Ur, jr) {
    return Cl(Sr, "handleClickOn", qr, Ir, Ur) || Sr.someProp("handleClick", function(Vr) {
      return Vr(Sr, qr, Ur);
    }) || (jr ? Mc(Sr, Ir) : Lc(Sr, Ir));
  }
  function Nc(Sr, qr, Ir, Ur) {
    return Cl(Sr, "handleDoubleClickOn", qr, Ir, Ur) || Sr.someProp("handleDoubleClick", function(jr) {
      return jr(Sr, qr, Ur);
    });
  }
  function Oc(Sr, qr, Ir, Ur) {
    return Cl(Sr, "handleTripleClickOn", qr, Ir, Ur) || Sr.someProp("handleTripleClick", function(jr) {
      return jr(Sr, qr, Ur);
    }) || Dc(Sr, Ir, Ur);
  }
  function Dc(Sr, qr, Ir) {
    if (Ir.button != 0)
      return !1;
    var Ur = Sr.state.doc;
    if (qr == -1)
      return Ur.inlineContent ? (Ns(Sr, xr.TextSelection.create(Ur, 0, Ur.content.size), "pointer"), !0) : !1;
    for (var jr = Ur.resolve(qr), Vr = jr.depth + 1; Vr > 0; Vr--) {
      var ei = Vr > jr.depth ? jr.nodeAfter : jr.node(Vr), ti = jr.before(Vr);
      if (ei.inlineContent)
        Ns(Sr, xr.TextSelection.create(Ur, ti + 1, ti + 1 + ei.content.size), "pointer");
      else if (xr.NodeSelection.isSelectable(ei))
        Ns(Sr, xr.NodeSelection.create(Ur, ti), "pointer");
      else
        continue;
      return !0;
    }
  }
  function Tl(Sr) {
    return Js(Sr);
  }
  var Dl = Ci ? "metaKey" : "ctrlKey";
  Qa.mousedown = function(Sr, qr) {
    var Ir = qr;
    Sr.input.shiftKey = Ir.shiftKey;
    var Ur = Tl(Sr), jr = Date.now(), Vr = "singleClick";
    jr - Sr.input.lastClick.time < 500 && Ic(Ir, Sr.input.lastClick) && !Ir[Dl] && (Sr.input.lastClick.type == "singleClick" ? Vr = "doubleClick" : Sr.input.lastClick.type == "doubleClick" && (Vr = "tripleClick")), Sr.input.lastClick = {
      time: jr,
      x: Ir.clientX,
      y: Ir.clientY,
      type: Vr
    };
    var ei = Sr.posAtCoords(fl(Ir));
    ei && (Vr == "singleClick" ? (Sr.input.mouseDown && Sr.input.mouseDown.done(), Sr.input.mouseDown = new Bc(Sr, ei, Ir, !!Ur)) : (Vr == "doubleClick" ? Nc : Oc)(Sr, ei.pos, ei.inside, Ir) ? Ir.preventDefault() : Jo(Sr, "pointer"));
  };
  var Bc = function() {
    function Sr(qr, Ir, Ur, jr) {
      var Vr = this;
      Tr(this, Sr), this.view = qr, this.pos = Ir, this.event = Ur, this.flushed = jr, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = qr.state.doc, this.selectNode = !!Ur[Dl], this.allowDefault = Ur.shiftKey;
      var ei, ti;
      if (Ir.inside > -1)
        ei = qr.state.doc.nodeAt(Ir.inside), ti = Ir.inside;
      else {
        var fi = qr.state.doc.resolve(Ir.pos);
        ei = fi.parent, ti = fi.depth ? fi.before() : 0;
      }
      var ki = jr ? null : Ur.target, Ri = ki ? qr.docView.nearestDesc(ki, !0) : null;
      this.target = Ri ? Ri.dom : null;
      var ji = qr.state.selection;
      (Ur.button == 0 && ei.type.spec.draggable && ei.type.spec.selectable !== !1 || ji instanceof xr.NodeSelection && ji.from <= ti && ji.to > ti) && (this.mightDrag = {
        node: ei,
        pos: ti,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && Vi && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(function() {
        Vr.view.input.mouseDown == Vr && Vr.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), qr.root.addEventListener("mouseup", this.up = this.up.bind(this)), qr.root.addEventListener("mousemove", this.move = this.move.bind(this)), Jo(qr, "pointer");
    }
    return Er(Sr, [{
      key: "done",
      value: function() {
        var Ir = this;
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(function() {
          return Bo(Ir.view);
        }), this.view.input.mouseDown = null;
      }
    }, {
      key: "up",
      value: function(Ir) {
        if (this.done(), !!this.view.dom.contains(Ir.target)) {
          var Ur = this.pos;
          this.view.state.doc != this.startDoc && (Ur = this.view.posAtCoords(fl(Ir))), this.updateAllowDefault(Ir), this.allowDefault || !Ur ? Jo(this.view, "pointer") : Rc(this.view, Ur.pos, Ur.inside, Ir, this.selectNode) ? Ir.preventDefault() : Ir.button == 0 && (this.flushed || mi && this.mightDrag && !this.mightDrag.node.isAtom || Mi && !this.view.state.selection.visible && Math.min(Math.abs(Ur.pos - this.view.state.selection.from), Math.abs(Ur.pos - this.view.state.selection.to)) <= 2) ? (Ns(this.view, xr.Selection.near(this.view.state.doc.resolve(Ur.pos)), "pointer"), Ir.preventDefault()) : Jo(this.view, "pointer");
        }
      }
    }, {
      key: "move",
      value: function(Ir) {
        this.updateAllowDefault(Ir), Jo(this.view, "pointer"), Ir.buttons == 0 && this.done();
      }
    }, {
      key: "updateAllowDefault",
      value: function(Ir) {
        !this.allowDefault && (Math.abs(this.event.x - Ir.clientX) > 4 || Math.abs(this.event.y - Ir.clientY) > 4) && (this.allowDefault = !0);
      }
    }]), Sr;
  }();
  Qa.touchstart = function(Sr) {
    Sr.input.lastTouch = Date.now(), Tl(Sr), Jo(Sr, "pointer");
  }, Qa.touchmove = function(Sr) {
    Sr.input.lastTouch = Date.now(), Jo(Sr, "pointer");
  }, Qa.contextmenu = function(Sr) {
    return Tl(Sr);
  };
  function Bl(Sr, qr) {
    return Sr.composing ? !0 : mi && Math.abs(qr.timeStamp - Sr.input.compositionEndedAt) < 500 ? (Sr.input.compositionEndedAt = -2e8, !0) : !1;
  }
  var Pc = Ni ? 5e3 : -1;
  fo.compositionstart = fo.compositionupdate = function(Sr) {
    if (!Sr.composing) {
      Sr.domObserver.flush();
      var qr = Sr.state, Ir = qr.selection.$from;
      if (qr.selection.empty && (qr.storedMarks || !Ir.textOffset && Ir.parentOffset && Ir.nodeBefore.marks.some(function(ti) {
        return ti.type.spec.inclusive === !1;
      })))
        Sr.markCursor = Sr.state.storedMarks || Ir.marks(), Js(Sr, !0), Sr.markCursor = null;
      else if (Js(Sr), Vi && qr.selection.empty && Ir.parentOffset && !Ir.textOffset && Ir.nodeBefore.marks.length)
        for (var Ur = Sr.domSelectionRange(), jr = Ur.focusNode, Vr = Ur.focusOffset; jr && jr.nodeType == 1 && Vr != 0; ) {
          var ei = Vr < 0 ? jr.lastChild : jr.childNodes[Vr - 1];
          if (!ei)
            break;
          if (ei.nodeType == 3) {
            Sr.domSelection().collapse(ei, ei.nodeValue.length);
            break;
          } else
            jr = ei, Vr = -1;
        }
      Sr.input.composing = !0;
    }
    Pl(Sr, Pc);
  }, fo.compositionend = function(Sr, qr) {
    Sr.composing && (Sr.input.composing = !1, Sr.input.compositionEndedAt = qr.timeStamp, Sr.input.compositionPendingChanges = Sr.domObserver.pendingRecords().length ? Sr.input.compositionID : 0, Sr.input.compositionPendingChanges && Promise.resolve().then(function() {
      return Sr.domObserver.flush();
    }), Sr.input.compositionID++, Pl(Sr, 20));
  };
  function Pl(Sr, qr) {
    clearTimeout(Sr.input.composingTimeout), qr > -1 && (Sr.input.composingTimeout = setTimeout(function() {
      return Js(Sr);
    }, qr));
  }
  function Hl(Sr) {
    for (Sr.composing && (Sr.input.composing = !1, Sr.input.compositionEndedAt = Hc()); Sr.input.compositionNodes.length > 0; )
      Sr.input.compositionNodes.pop().markParentsDirty();
  }
  function Hc() {
    var Sr = document.createEvent("Event");
    return Sr.initEvent("event", !0, !0), Sr.timeStamp;
  }
  function Js(Sr) {
    var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!(Ni && Sr.domObserver.flushingSoon >= 0)) {
      if (Sr.domObserver.forceFlush(), Hl(Sr), qr || Sr.docView && Sr.docView.dirty) {
        var Ir = Do(Sr);
        return Ir && !Ir.eq(Sr.state.selection) ? Sr.dispatch(Sr.state.tr.setSelection(Ir)) : Sr.updateState(Sr.state), !0;
      }
      return !1;
    }
  }
  function Uc(Sr, qr) {
    if (Sr.dom.parentNode) {
      var Ir = Sr.dom.parentNode.appendChild(document.createElement("div"));
      Ir.appendChild(qr), Ir.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var Ur = getSelection(), jr = document.createRange();
      jr.selectNodeContents(qr), Sr.dom.blur(), Ur.removeAllRanges(), Ur.addRange(jr), setTimeout(function() {
        Ir.parentNode && Ir.parentNode.removeChild(Ir), Sr.focus();
      }, 50);
    }
  }
  var Ys = Ui && yi < 15 || _i && ea < 604;
  Qa.copy = fo.cut = function(Sr, qr) {
    var Ir = qr, Ur = Sr.state.selection, jr = Ir.type == "cut";
    if (!Ur.empty) {
      var Vr = Ys ? null : Ir.clipboardData, ei = Ur.content(), ti = Rs(Sr, ei), fi = ti.dom, ki = ti.text;
      Vr ? (Ir.preventDefault(), Vr.clearData(), Vr.setData("text/html", fi.innerHTML), Vr.setData("text/plain", ki)) : Uc(Sr, fi), jr && Sr.dispatch(Sr.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  };
  function zc(Sr) {
    return Sr.openStart == 0 && Sr.openEnd == 0 && Sr.content.childCount == 1 ? Sr.content.firstChild : null;
  }
  function qc(Sr, qr) {
    if (Sr.dom.parentNode) {
      var Ir = Sr.input.shiftKey || Sr.state.selection.$from.parent.type.spec.code, Ur = Sr.dom.parentNode.appendChild(document.createElement(Ir ? "textarea" : "div"));
      Ir || (Ur.contentEditable = "true"), Ur.style.cssText = "position: fixed; left: -10000px; top: 10px", Ur.focus();
      var jr = Sr.input.shiftKey && Sr.input.lastKeyCode != 45;
      setTimeout(function() {
        Sr.focus(), Ur.parentNode && Ur.parentNode.removeChild(Ur), Ir ? Qs(Sr, Ur.value, null, jr, qr) : Qs(Sr, Ur.textContent, Ur.innerHTML, jr, qr);
      }, 50);
    }
  }
  function Qs(Sr, qr, Ir, Ur, jr) {
    var Vr = Ks(Sr, qr, Ir, Ur, Sr.state.selection.$from);
    if (Sr.someProp("handlePaste", function(fi) {
      return fi(Sr, jr, Vr || Cr.Slice.empty);
    }))
      return !0;
    if (!Vr)
      return !1;
    var ei = zc(Vr), ti = ei ? Sr.state.tr.replaceSelectionWith(ei, Ur) : Sr.state.tr.replaceSelection(Vr);
    return Sr.dispatch(ti.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
  }
  function Ul(Sr) {
    var qr = Sr.getData("text/plain") || Sr.getData("Text");
    if (qr)
      return qr;
    var Ir = Sr.getData("text/uri-list");
    return Ir ? Ir.replace(/\r?\n/g, " ") : "";
  }
  fo.paste = function(Sr, qr) {
    var Ir = qr;
    if (!(Sr.composing && !Ni)) {
      var Ur = Ys ? null : Ir.clipboardData, jr = Sr.input.shiftKey && Sr.input.lastKeyCode != 45;
      Ur && Qs(Sr, Ul(Ur), Ur.getData("text/html"), jr, Ir) ? Ir.preventDefault() : qc(Sr, Ir);
    }
  };
  var zl = Er(function Sr(qr, Ir, Ur) {
    Tr(this, Sr), this.slice = qr, this.move = Ir, this.node = Ur;
  }), ql = Ci ? "altKey" : "ctrlKey";
  Qa.dragstart = function(Sr, qr) {
    var Ir = qr, Ur = Sr.input.mouseDown;
    if (Ur && Ur.done(), !!Ir.dataTransfer) {
      var jr = Sr.state.selection, Vr = jr.empty ? null : Sr.posAtCoords(fl(Ir)), ei;
      if (!(Vr && Vr.pos >= jr.from && Vr.pos <= (jr instanceof xr.NodeSelection ? jr.to - 1 : jr.to))) {
        if (Ur && Ur.mightDrag)
          ei = xr.NodeSelection.create(Sr.state.doc, Ur.mightDrag.pos);
        else if (Ir.target && Ir.target.nodeType == 1) {
          var ti = Sr.docView.nearestDesc(Ir.target, !0);
          ti && ti.node.type.spec.draggable && ti != Sr.docView && (ei = xr.NodeSelection.create(Sr.state.doc, ti.posBefore));
        }
      }
      var fi = (ei || Sr.state.selection).content(), ki = Rs(Sr, fi), Ri = ki.dom, ji = ki.text;
      Ir.dataTransfer.clearData(), Ir.dataTransfer.setData(Ys ? "Text" : "text/html", Ri.innerHTML), Ir.dataTransfer.effectAllowed = "copyMove", Ys || Ir.dataTransfer.setData("text/plain", ji), Sr.dragging = new zl(fi, !Ir[ql], ei);
    }
  }, Qa.dragend = function(Sr) {
    var qr = Sr.dragging;
    window.setTimeout(function() {
      Sr.dragging == qr && (Sr.dragging = null);
    }, 50);
  }, fo.dragover = fo.dragenter = function(Sr, qr) {
    return qr.preventDefault();
  }, fo.drop = function(Sr, qr) {
    var Ir = qr, Ur = Sr.dragging;
    if (Sr.dragging = null, !!Ir.dataTransfer) {
      var jr = Sr.posAtCoords(fl(Ir));
      if (jr) {
        var Vr = Sr.state.doc.resolve(jr.pos), ei = Ur && Ur.slice;
        ei ? Sr.someProp("transformPasted", function(La) {
          ei = La(ei, Sr);
        }) : ei = Ks(Sr, Ul(Ir.dataTransfer), Ys ? null : Ir.dataTransfer.getData("text/html"), !1, Vr);
        var ti = !!(Ur && !Ir[ql]);
        if (Sr.someProp("handleDrop", function(La) {
          return La(Sr, Ir, ei || Cr.Slice.empty, ti);
        })) {
          Ir.preventDefault();
          return;
        }
        if (ei) {
          Ir.preventDefault();
          var fi = ei ? Ar.dropPoint(Sr.state.doc, Vr.pos, ei) : Vr.pos;
          fi == null && (fi = Vr.pos);
          var ki = Sr.state.tr;
          if (ti) {
            var Ri = Ur.node;
            Ri ? Ri.replace(ki) : ki.deleteSelection();
          }
          var ji = ki.mapping.map(fi), Bi = ei.openStart == 0 && ei.openEnd == 0 && ei.content.childCount == 1, Qi = ki.doc;
          if (Bi ? ki.replaceRangeWith(ji, ji, ei.content.firstChild) : ki.replaceRange(ji, ji, ei), !ki.doc.eq(Qi)) {
            var na = ki.doc.resolve(ji);
            if (Bi && xr.NodeSelection.isSelectable(ei.content.firstChild) && na.nodeAfter && na.nodeAfter.sameMarkup(ei.content.firstChild))
              ki.setSelection(new xr.NodeSelection(na));
            else {
              var Ea = ki.mapping.map(fi);
              ki.mapping.maps[ki.mapping.maps.length - 1].forEach(function(La, fa, so, Za) {
                return Ea = Za;
              }), ki.setSelection(Ss(Sr, na, ki.doc.resolve(Ea)));
            }
            Sr.focus(), Sr.dispatch(ki.setMeta("uiEvent", "drop"));
          }
        }
      }
    }
  }, Qa.focus = function(Sr) {
    Sr.input.lastFocus = Date.now(), Sr.focused || (Sr.domObserver.stop(), Sr.dom.classList.add("ProseMirror-focused"), Sr.domObserver.start(), Sr.focused = !0, setTimeout(function() {
      Sr.docView && Sr.hasFocus() && !Sr.domObserver.currentSelection.eq(Sr.domSelectionRange()) && Bo(Sr);
    }, 20));
  }, Qa.blur = function(Sr, qr) {
    var Ir = qr;
    Sr.focused && (Sr.domObserver.stop(), Sr.dom.classList.remove("ProseMirror-focused"), Sr.domObserver.start(), Ir.relatedTarget && Sr.dom.contains(Ir.relatedTarget) && Sr.domObserver.currentSelection.clear(), Sr.focused = !1);
  }, Qa.beforeinput = function(Sr, qr) {
    var Ir = qr;
    if (Mi && Ni && Ir.inputType == "deleteContentBackward") {
      Sr.domObserver.flushSoon();
      var Ur = Sr.input.domChangeCount;
      setTimeout(function() {
        if (Sr.input.domChangeCount == Ur && (Sr.dom.blur(), Sr.focus(), !Sr.someProp("handleKeyDown", function(Vr) {
          return Vr(Sr, Si(8, "Backspace"));
        }))) {
          var jr = Sr.state.selection.$cursor;
          jr && jr.pos > 0 && Sr.dispatch(Sr.state.tr.delete(jr.pos - 1, jr.pos).scrollIntoView());
        }
      }, 50);
    }
  };
  for (var Fl in fo)
    Qa[Fl] = fo[Fl];
  function tl(Sr, qr) {
    if (Sr == qr)
      return !0;
    for (var Ir in Sr)
      if (Sr[Ir] !== qr[Ir])
        return !1;
    for (var Ur in qr)
      if (!(Ur in Sr))
        return !1;
    return !0;
  }
  var jl = function() {
    function Sr(qr, Ir) {
      Tr(this, Sr), this.toDOM = qr, this.spec = Ir || ks, this.side = this.spec.side || 0;
    }
    return Er(Sr, [{
      key: "map",
      value: function(Ir, Ur, jr, Vr) {
        var ei = Ir.mapResult(Ur.from + Vr, this.side < 0 ? -1 : 1), ti = ei.pos, fi = ei.deleted;
        return fi ? null : new ys(ti - jr, ti - jr, this);
      }
    }, {
      key: "valid",
      value: function() {
        return !0;
      }
    }, {
      key: "eq",
      value: function(Ir) {
        return this == Ir || Ir instanceof Sr && (this.spec.key && this.spec.key == Ir.spec.key || this.toDOM == Ir.toDOM && tl(this.spec, Ir.spec));
      }
    }, {
      key: "destroy",
      value: function(Ir) {
        this.spec.destroy && this.spec.destroy(Ir);
      }
    }]), Sr;
  }(), rl = function() {
    function Sr(qr, Ir) {
      Tr(this, Sr), this.attrs = qr, this.spec = Ir || ks;
    }
    return Er(Sr, [{
      key: "map",
      value: function(Ir, Ur, jr, Vr) {
        var ei = Ir.map(Ur.from + Vr, this.spec.inclusiveStart ? -1 : 1) - jr, ti = Ir.map(Ur.to + Vr, this.spec.inclusiveEnd ? 1 : -1) - jr;
        return ei >= ti ? null : new ys(ei, ti, this);
      }
    }, {
      key: "valid",
      value: function(Ir, Ur) {
        return Ur.from < Ur.to;
      }
    }, {
      key: "eq",
      value: function(Ir) {
        return this == Ir || Ir instanceof Sr && tl(this.attrs, Ir.attrs) && tl(this.spec, Ir.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }], [{
      key: "is",
      value: function(Ir) {
        return Ir.type instanceof Sr;
      }
    }]), Sr;
  }(), Fc = function() {
    function Sr(qr, Ir) {
      Tr(this, Sr), this.attrs = qr, this.spec = Ir || ks;
    }
    return Er(Sr, [{
      key: "map",
      value: function(Ir, Ur, jr, Vr) {
        var ei = Ir.mapResult(Ur.from + Vr, 1);
        if (ei.deleted)
          return null;
        var ti = Ir.mapResult(Ur.to + Vr, -1);
        return ti.deleted || ti.pos <= ei.pos ? null : new ys(ei.pos - jr, ti.pos - jr, this);
      }
    }, {
      key: "valid",
      value: function(Ir, Ur) {
        var jr = Ir.content.findIndex(Ur.from), Vr = jr.index, ei = jr.offset, ti;
        return ei == Ur.from && !(ti = Ir.child(Vr)).isText && ei + ti.nodeSize == Ur.to;
      }
    }, {
      key: "eq",
      value: function(Ir) {
        return this == Ir || Ir instanceof Sr && tl(this.attrs, Ir.attrs) && tl(this.spec, Ir.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }]), Sr;
  }(), ys = function() {
    function Sr(qr, Ir, Ur) {
      Tr(this, Sr), this.from = qr, this.to = Ir, this.type = Ur;
    }
    return Er(Sr, [{
      key: "copy",
      value: function(Ir, Ur) {
        return new Sr(Ir, Ur, this.type);
      }
    }, {
      key: "eq",
      value: function(Ir) {
        var Ur = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.type.eq(Ir.type) && this.from + Ur == Ir.from && this.to + Ur == Ir.to;
      }
    }, {
      key: "map",
      value: function(Ir, Ur, jr) {
        return this.type.map(Ir, this, Ur, jr);
      }
    }, {
      key: "spec",
      get: function() {
        return this.type.spec;
      }
    }, {
      key: "inline",
      get: function() {
        return this.type instanceof rl;
      }
    }, {
      key: "widget",
      get: function() {
        return this.type instanceof jl;
      }
    }], [{
      key: "widget",
      value: function(Ir, Ur, jr) {
        return new Sr(Ir, Ir, new jl(Ur, jr));
      }
    }, {
      key: "inline",
      value: function(Ir, Ur, jr, Vr) {
        return new Sr(Ir, Ur, new rl(jr, Vr));
      }
    }, {
      key: "node",
      value: function(Ir, Ur, jr, Vr) {
        return new Sr(Ir, Ur, new Fc(jr, Vr));
      }
    }]), Sr;
  }(), Os = [], ks = {}, zo = function() {
    function Sr(qr, Ir) {
      Tr(this, Sr), this.local = qr.length ? qr : Os, this.children = Ir.length ? Ir : Os;
    }
    return Er(Sr, [{
      key: "find",
      value: function(Ir, Ur, jr) {
        var Vr = [];
        return this.findInner(Ir == null ? 0 : Ir, Ur == null ? 1e9 : Ur, Vr, 0, jr), Vr;
      }
    }, {
      key: "findInner",
      value: function(Ir, Ur, jr, Vr, ei) {
        for (var ti = 0; ti < this.local.length; ti++) {
          var fi = this.local[ti];
          fi.from <= Ur && fi.to >= Ir && (!ei || ei(fi.spec)) && jr.push(fi.copy(fi.from + Vr, fi.to + Vr));
        }
        for (var ki = 0; ki < this.children.length; ki += 3)
          if (this.children[ki] < Ur && this.children[ki + 1] > Ir) {
            var Ri = this.children[ki] + 1;
            this.children[ki + 2].findInner(Ir - Ri, Ur - Ri, jr, Vr + Ri, ei);
          }
      }
    }, {
      key: "map",
      value: function(Ir, Ur, jr) {
        return this == Ao || Ir.maps.length == 0 ? this : this.mapInner(Ir, Ur, 0, 0, jr || ks);
      }
    }, {
      key: "mapInner",
      value: function(Ir, Ur, jr, Vr, ei) {
        for (var ti, fi = 0; fi < this.local.length; fi++) {
          var ki = this.local[fi].map(Ir, jr, Vr);
          ki && ki.type.valid(Ur, ki) ? (ti || (ti = [])).push(ki) : ei.onRemove && ei.onRemove(this.local[fi].spec);
        }
        return this.children.length ? jc(this.children, ti || [], Ir, Ur, jr, Vr, ei) : ti ? new Sr(ti.sort(_s), Os) : Ao;
      }
    }, {
      key: "add",
      value: function(Ir, Ur) {
        return Ur.length ? this == Ao ? Sr.create(Ir, Ur) : this.addInner(Ir, Ur, 0) : this;
      }
    }, {
      key: "addInner",
      value: function(Ir, Ur, jr) {
        var Vr = this, ei, ti = 0;
        Ir.forEach(function(Ri, ji) {
          var Bi = ji + jr, Qi;
          if (Qi = Gl(Ur, Ri, Bi)) {
            for (ei || (ei = Vr.children.slice()); ti < ei.length && ei[ti] < ji; )
              ti += 3;
            ei[ti] == ji ? ei[ti + 2] = ei[ti + 2].addInner(Ri, Qi, Bi + 1) : ei.splice(ti, 0, ji, ji + Ri.nodeSize, dl(Qi, Ri, Bi + 1, ks)), ti += 3;
          }
        });
        for (var fi = Vl(ti ? Wl(Ur) : Ur, -jr), ki = 0; ki < fi.length; ki++)
          fi[ki].type.valid(Ir, fi[ki]) || fi.splice(ki--, 1);
        return new Sr(fi.length ? this.local.concat(fi).sort(_s) : this.local, ei || this.children);
      }
    }, {
      key: "remove",
      value: function(Ir) {
        return Ir.length == 0 || this == Ao ? this : this.removeInner(Ir, 0);
      }
    }, {
      key: "removeInner",
      value: function(Ir, Ur) {
        for (var jr = this.children, Vr = this.local, ei = 0; ei < jr.length; ei += 3) {
          for (var ti = void 0, fi = jr[ei] + Ur, ki = jr[ei + 1] + Ur, Ri = 0, ji; Ri < Ir.length; Ri++)
            (ji = Ir[Ri]) && ji.from > fi && ji.to < ki && (Ir[Ri] = null, (ti || (ti = [])).push(ji));
          if (ti) {
            jr == this.children && (jr = this.children.slice());
            var Bi = jr[ei + 2].removeInner(ti, fi + 1);
            Bi != Ao ? jr[ei + 2] = Bi : (jr.splice(ei, 3), ei -= 3);
          }
        }
        if (Vr.length) {
          for (var Qi = 0, na; Qi < Ir.length; Qi++)
            if (na = Ir[Qi])
              for (var Ea = 0; Ea < Vr.length; Ea++)
                Vr[Ea].eq(na, Ur) && (Vr == this.local && (Vr = this.local.slice()), Vr.splice(Ea--, 1));
        }
        return jr == this.children && Vr == this.local ? this : Vr.length || jr.length ? new Sr(Vr, jr) : Ao;
      }
    }, {
      key: "forChild",
      value: function(Ir, Ur) {
        if (this == Ao)
          return this;
        if (Ur.isLeaf)
          return Sr.empty;
        for (var jr, Vr, ei = 0; ei < this.children.length; ei += 3)
          if (this.children[ei] >= Ir) {
            this.children[ei] == Ir && (jr = this.children[ei + 2]);
            break;
          }
        for (var ti = Ir + 1, fi = ti + Ur.content.size, ki = 0; ki < this.local.length; ki++) {
          var Ri = this.local[ki];
          if (Ri.from < fi && Ri.to > ti && Ri.type instanceof rl) {
            var ji = Math.max(ti, Ri.from) - ti, Bi = Math.min(fi, Ri.to) - ti;
            ji < Bi && (Vr || (Vr = [])).push(Ri.copy(ji, Bi));
          }
        }
        if (Vr) {
          var Qi = new Sr(Vr.sort(_s), Os);
          return jr ? new $l([Qi, jr]) : Qi;
        }
        return jr || Ao;
      }
    }, {
      key: "eq",
      value: function(Ir) {
        if (this == Ir)
          return !0;
        if (!(Ir instanceof Sr) || this.local.length != Ir.local.length || this.children.length != Ir.children.length)
          return !1;
        for (var Ur = 0; Ur < this.local.length; Ur++)
          if (!this.local[Ur].eq(Ir.local[Ur]))
            return !1;
        for (var jr = 0; jr < this.children.length; jr += 3)
          if (this.children[jr] != Ir.children[jr] || this.children[jr + 1] != Ir.children[jr + 1] || !this.children[jr + 2].eq(Ir.children[jr + 2]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(Ir) {
        return Al(this.localsInner(Ir));
      }
    }, {
      key: "localsInner",
      value: function(Ir) {
        if (this == Ao)
          return Os;
        if (Ir.inlineContent || !this.local.some(rl.is))
          return this.local;
        for (var Ur = [], jr = 0; jr < this.local.length; jr++)
          this.local[jr].type instanceof rl || Ur.push(this.local[jr]);
        return Ur;
      }
    }], [{
      key: "create",
      value: function(Ir, Ur) {
        return Ur.length ? dl(Ur, Ir, 0, ks) : Ao;
      }
    }]), Sr;
  }();
  zo.empty = new zo([], []), zo.removeOverlap = Al;
  var Ao = zo.empty, $l = function() {
    function Sr(qr) {
      Tr(this, Sr), this.members = qr;
    }
    return Er(Sr, [{
      key: "map",
      value: function(Ir, Ur) {
        var jr = this.members.map(function(Vr) {
          return Vr.map(Ir, Ur, ks);
        });
        return Sr.from(jr);
      }
    }, {
      key: "forChild",
      value: function(Ir, Ur) {
        if (Ur.isLeaf)
          return zo.empty;
        for (var jr = [], Vr = 0; Vr < this.members.length; Vr++) {
          var ei = this.members[Vr].forChild(Ir, Ur);
          ei != Ao && (ei instanceof Sr ? jr = jr.concat(ei.members) : jr.push(ei));
        }
        return Sr.from(jr);
      }
    }, {
      key: "eq",
      value: function(Ir) {
        if (!(Ir instanceof Sr) || Ir.members.length != this.members.length)
          return !1;
        for (var Ur = 0; Ur < this.members.length; Ur++)
          if (!this.members[Ur].eq(Ir.members[Ur]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(Ir) {
        for (var Ur, jr = !0, Vr = 0; Vr < this.members.length; Vr++) {
          var ei = this.members[Vr].localsInner(Ir);
          if (ei.length)
            if (!Ur)
              Ur = ei;
            else {
              jr && (Ur = Ur.slice(), jr = !1);
              for (var ti = 0; ti < ei.length; ti++)
                Ur.push(ei[ti]);
            }
        }
        return Ur ? Al(jr ? Ur : Ur.sort(_s)) : Os;
      }
    }], [{
      key: "from",
      value: function(Ir) {
        switch (Ir.length) {
          case 0:
            return Ao;
          case 1:
            return Ir[0];
          default:
            return new Sr(Ir.every(function(Ur) {
              return Ur instanceof zo;
            }) ? Ir : Ir.reduce(function(Ur, jr) {
              return Ur.concat(jr instanceof zo ? jr : jr.members);
            }, []));
        }
      }
    }]), Sr;
  }();
  function jc(Sr, qr, Ir, Ur, jr, Vr, ei) {
    for (var ti = Sr.slice(), fi = function(Ds, Go) {
      var Bs = 0;
      Ir.maps[Ds].forEach(function(Fo, vo, lc, fu) {
        for (var hl = fu - lc - (vo - Fo), ws = 0; ws < ti.length; ws += 3) {
          var cc = ti[ws + 1];
          if (!(cc < 0 || Fo > cc + Go - Bs)) {
            var uc = ti[ws] + Go - Bs;
            vo >= uc ? ti[ws + 1] = Fo <= uc ? -2 : -1 : lc >= jr && hl && (ti[ws] += hl, ti[ws + 1] += hl);
          }
        }
        Bs += hl;
      }), Go = Ir.maps[Ds].map(Go, -1), Ri = Go;
    }, ki = 0, Ri = Vr; ki < Ir.maps.length; ki++)
      fi(ki, Ri);
    for (var ji = !1, Bi = 0; Bi < ti.length; Bi += 3)
      if (ti[Bi + 1] < 0) {
        if (ti[Bi + 1] == -2) {
          ji = !0, ti[Bi + 1] = -1;
          continue;
        }
        var Qi = Ir.map(Sr[Bi] + Vr), na = Qi - jr;
        if (na < 0 || na >= Ur.content.size) {
          ji = !0;
          continue;
        }
        var Ea = Ir.map(Sr[Bi + 1] + Vr, -1), La = Ea - jr, fa = Ur.content.findIndex(na), so = fa.index, Za = fa.offset, no = Ur.maybeChild(so);
        if (no && Za == na && Za + no.nodeSize == La) {
          var Ga = ti[Bi + 2].mapInner(Ir, no, Qi + 1, Sr[Bi] + Vr + 1, ei);
          Ga != Ao ? (ti[Bi] = na, ti[Bi + 1] = La, ti[Bi + 2] = Ga) : (ti[Bi + 1] = -2, ji = !0);
        } else
          ji = !0;
      }
    if (ji) {
      var Ja = $c(ti, Sr, qr, Ir, jr, Vr, ei), ho = dl(Ja, Ur, 0, ei);
      qr = ho.local;
      for (var No = 0; No < ti.length; No += 3)
        ti[No + 1] < 0 && (ti.splice(No, 3), No -= 3);
      for (var qo = 0, Co = 0; qo < ho.children.length; qo += 3) {
        for (var Ko = ho.children[qo]; Co < ti.length && ti[Co] < Ko; )
          Co += 3;
        ti.splice(Co, 0, ho.children[qo], ho.children[qo + 1], ho.children[qo + 2]);
      }
    }
    return new zo(qr.sort(_s), ti);
  }
  function Vl(Sr, qr) {
    if (!qr || !Sr.length)
      return Sr;
    for (var Ir = [], Ur = 0; Ur < Sr.length; Ur++) {
      var jr = Sr[Ur];
      Ir.push(new ys(jr.from + qr, jr.to + qr, jr.type));
    }
    return Ir;
  }
  function $c(Sr, qr, Ir, Ur, jr, Vr, ei) {
    function ti(ki, Ri) {
      for (var ji = 0; ji < ki.local.length; ji++) {
        var Bi = ki.local[ji].map(Ur, jr, Ri);
        Bi ? Ir.push(Bi) : ei.onRemove && ei.onRemove(ki.local[ji].spec);
      }
      for (var Qi = 0; Qi < ki.children.length; Qi += 3)
        ti(ki.children[Qi + 2], ki.children[Qi] + Ri + 1);
    }
    for (var fi = 0; fi < Sr.length; fi += 3)
      Sr[fi + 1] == -1 && ti(Sr[fi + 2], qr[fi] + Vr + 1);
    return Ir;
  }
  function Gl(Sr, qr, Ir) {
    if (qr.isLeaf)
      return null;
    for (var Ur = Ir + qr.nodeSize, jr = null, Vr = 0, ei; Vr < Sr.length; Vr++)
      (ei = Sr[Vr]) && ei.from > Ir && ei.to < Ur && ((jr || (jr = [])).push(ei), Sr[Vr] = null);
    return jr;
  }
  function Wl(Sr) {
    for (var qr = [], Ir = 0; Ir < Sr.length; Ir++)
      Sr[Ir] != null && qr.push(Sr[Ir]);
    return qr;
  }
  function dl(Sr, qr, Ir, Ur) {
    var jr = [], Vr = !1;
    qr.forEach(function(fi, ki) {
      var Ri = Gl(Sr, fi, ki + Ir);
      if (Ri) {
        Vr = !0;
        var ji = dl(Ri, fi, Ir + ki + 1, Ur);
        ji != Ao && jr.push(ki, ki + fi.nodeSize, ji);
      }
    });
    for (var ei = Vl(Vr ? Wl(Sr) : Sr, -Ir).sort(_s), ti = 0; ti < ei.length; ti++)
      ei[ti].type.valid(qr, ei[ti]) || (Ur.onRemove && Ur.onRemove(ei[ti].spec), ei.splice(ti--, 1));
    return ei.length || jr.length ? new zo(ei, jr) : Ao;
  }
  function _s(Sr, qr) {
    return Sr.from - qr.from || Sr.to - qr.to;
  }
  function Al(Sr) {
    for (var qr = Sr, Ir = 0; Ir < qr.length - 1; Ir++) {
      var Ur = qr[Ir];
      if (Ur.from != Ur.to)
        for (var jr = Ir + 1; jr < qr.length; jr++) {
          var Vr = qr[jr];
          if (Vr.from == Ur.from) {
            Vr.to != Ur.to && (qr == Sr && (qr = Sr.slice()), qr[jr] = Vr.copy(Vr.from, Ur.to), Zl(qr, jr + 1, Vr.copy(Ur.to, Vr.to)));
            continue;
          } else {
            Vr.from < Ur.to && (qr == Sr && (qr = Sr.slice()), qr[Ir] = Ur.copy(Ur.from, Vr.from), Zl(qr, jr, Ur.copy(Vr.from, Ur.to)));
            break;
          }
        }
    }
    return qr;
  }
  function Zl(Sr, qr, Ir) {
    for (; qr < Sr.length && _s(Ir, Sr[qr]) > 0; )
      qr++;
    Sr.splice(qr, 0, Ir);
  }
  function Sl(Sr) {
    var qr = [];
    return Sr.someProp("decorations", function(Ir) {
      var Ur = Ir(Sr.state);
      Ur && Ur != Ao && qr.push(Ur);
    }), Sr.cursorWrapper && qr.push(zo.create(Sr.state.doc, [Sr.cursorWrapper.deco])), $l.from(qr);
  }
  var Vc = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  }, Kc = Ui && yi <= 11, Gc = function() {
    function Sr() {
      Tr(this, Sr), this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    return Er(Sr, [{
      key: "set",
      value: function(Ir) {
        this.anchorNode = Ir.anchorNode, this.anchorOffset = Ir.anchorOffset, this.focusNode = Ir.focusNode, this.focusOffset = Ir.focusOffset;
      }
    }, {
      key: "clear",
      value: function() {
        this.anchorNode = this.focusNode = null;
      }
    }, {
      key: "eq",
      value: function(Ir) {
        return Ir.anchorNode == this.anchorNode && Ir.anchorOffset == this.anchorOffset && Ir.focusNode == this.focusNode && Ir.focusOffset == this.focusOffset;
      }
    }]), Sr;
  }(), Wc = function() {
    function Sr(qr, Ir) {
      var Ur = this;
      Tr(this, Sr), this.view = qr, this.handleDOMChange = Ir, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Gc(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver(function(jr) {
        for (var Vr = 0; Vr < jr.length; Vr++)
          Ur.queue.push(jr[Vr]);
        Ui && yi <= 11 && jr.some(function(ei) {
          return ei.type == "childList" && ei.removedNodes.length || ei.type == "characterData" && ei.oldValue.length > ei.target.nodeValue.length;
        }) ? Ur.flushSoon() : Ur.flush();
      }), Kc && (this.onCharData = function(jr) {
        Ur.queue.push({
          target: jr.target,
          type: "characterData",
          oldValue: jr.prevValue
        }), Ur.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    return Er(Sr, [{
      key: "flushSoon",
      value: function() {
        var Ir = this;
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(function() {
          Ir.flushingSoon = -1, Ir.flush();
        }, 20));
      }
    }, {
      key: "forceFlush",
      value: function() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
    }, {
      key: "start",
      value: function() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Vc)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
    }, {
      key: "stop",
      value: function() {
        var Ir = this;
        if (this.observer) {
          var Ur = this.observer.takeRecords();
          if (Ur.length) {
            for (var jr = 0; jr < Ur.length; jr++)
              this.queue.push(Ur[jr]);
            window.setTimeout(function() {
              return Ir.flush();
            }, 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
    }, {
      key: "connectSelection",
      value: function() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "disconnectSelection",
      value: function() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "suppressSelectionUpdates",
      value: function() {
        var Ir = this;
        this.suppressingSelectionUpdates = !0, setTimeout(function() {
          return Ir.suppressingSelectionUpdates = !1;
        }, 50);
      }
    }, {
      key: "onSelectionChange",
      value: function() {
        if (Is(this.view)) {
          if (this.suppressingSelectionUpdates)
            return Bo(this.view);
          if (Ui && yi <= 11 && !this.view.state.selection.empty) {
            var Ir = this.view.domSelectionRange();
            if (Ir.focusNode && $r(Ir.focusNode, Ir.focusOffset, Ir.anchorNode, Ir.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
    }, {
      key: "setCurSelection",
      value: function() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
    }, {
      key: "ignoreSelectionChange",
      value: function(Ir) {
        if (!Ir.focusNode)
          return !0;
        for (var Ur = /* @__PURE__ */ new Set(), jr, Vr = Ir.focusNode; Vr; Vr = Dr(Vr))
          Ur.add(Vr);
        for (var ei = Ir.anchorNode; ei; ei = Dr(ei))
          if (Ur.has(ei)) {
            jr = ei;
            break;
          }
        var ti = jr && this.view.docView.nearestDesc(jr);
        if (ti && ti.ignoreMutation({
          type: "selection",
          target: jr.nodeType == 3 ? jr.parentNode : jr
        }))
          return this.setCurSelection(), !0;
      }
    }, {
      key: "pendingRecords",
      value: function() {
        if (this.observer) {
          var Ir = ar(this.observer.takeRecords()), Ur;
          try {
            for (Ir.s(); !(Ur = Ir.n()).done; ) {
              var jr = Ur.value;
              this.queue.push(jr);
            }
          } catch (Vr) {
            Ir.e(Vr);
          } finally {
            Ir.f();
          }
        }
        return this.queue;
      }
    }, {
      key: "flush",
      value: function() {
        var Ir = this.view;
        if (!(!Ir.docView || this.flushingSoon > -1)) {
          var Ur = this.pendingRecords();
          Ur.length && (this.queue = []);
          var jr = Ir.domSelectionRange(), Vr = !this.suppressingSelectionUpdates && !this.currentSelection.eq(jr) && Is(Ir) && !this.ignoreSelectionChange(jr), ei = -1, ti = -1, fi = !1, ki = [];
          if (Ir.editable)
            for (var Ri = 0; Ri < Ur.length; Ri++) {
              var ji = this.registerMutation(Ur[Ri], ki);
              ji && (ei = ei < 0 ? ji.from : Math.min(ji.from, ei), ti = ti < 0 ? ji.to : Math.max(ji.to, ti), ji.typeOver && (fi = !0));
            }
          if (Vi && ki.length > 1) {
            var Bi = ki.filter(function(La) {
              return La.nodeName == "BR";
            });
            if (Bi.length == 2) {
              var Qi = Bi[0], na = Bi[1];
              Qi.parentNode && Qi.parentNode.parentNode == na.parentNode ? na.remove() : Qi.remove();
            }
          }
          var Ea = null;
          ei < 0 && Vr && Ir.input.lastFocus > Date.now() - 200 && Math.max(Ir.input.lastTouch, Ir.input.lastClick.time) < Date.now() - 300 && li(jr) && (Ea = Do(Ir)) && Ea.eq(xr.Selection.near(Ir.state.doc.resolve(0), 1)) ? (Ir.input.lastFocus = 0, Bo(Ir), this.currentSelection.set(jr), Ir.scrollToSelection()) : (ei > -1 || Vr) && (ei > -1 && (Ir.docView.markDirty(ei, ti), Zc(Ir)), this.handleDOMChange(ei, ti, fi, ki), Ir.docView && Ir.docView.dirty ? Ir.updateState(Ir.state) : this.currentSelection.eq(jr) || Bo(Ir), this.currentSelection.set(jr));
        }
      }
    }, {
      key: "registerMutation",
      value: function(Ir, Ur) {
        if (Ur.indexOf(Ir.target) > -1)
          return null;
        var jr = this.view.docView.nearestDesc(Ir.target);
        if (Ir.type == "attributes" && (jr == this.view.docView || Ir.attributeName == "contenteditable" || Ir.attributeName == "style" && !Ir.oldValue && !Ir.target.getAttribute("style")) || !jr || jr.ignoreMutation(Ir))
          return null;
        if (Ir.type == "childList") {
          for (var Vr = 0; Vr < Ir.addedNodes.length; Vr++)
            Ur.push(Ir.addedNodes[Vr]);
          if (jr.contentDOM && jr.contentDOM != jr.dom && !jr.contentDOM.contains(Ir.target))
            return {
              from: jr.posBefore,
              to: jr.posAfter
            };
          var ei = Ir.previousSibling, ti = Ir.nextSibling;
          if (Ui && yi <= 11 && Ir.addedNodes.length)
            for (var fi = 0; fi < Ir.addedNodes.length; fi++) {
              var ki = Ir.addedNodes[fi], Ri = ki.previousSibling, ji = ki.nextSibling;
              (!Ri || Array.prototype.indexOf.call(Ir.addedNodes, Ri) < 0) && (ei = Ri), (!ji || Array.prototype.indexOf.call(Ir.addedNodes, ji) < 0) && (ti = ji);
            }
          var Bi = ei && ei.parentNode == Ir.target ? Lr(ei) + 1 : 0, Qi = jr.localPosFromDOM(Ir.target, Bi, -1), na = ti && ti.parentNode == Ir.target ? Lr(ti) : Ir.target.childNodes.length, Ea = jr.localPosFromDOM(Ir.target, na, 1);
          return {
            from: Qi,
            to: Ea
          };
        } else
          return Ir.type == "attributes" ? {
            from: jr.posAtStart - jr.border,
            to: jr.posAtEnd + jr.border
          } : {
            from: jr.posAtStart,
            to: jr.posAtEnd,
            typeOver: Ir.target.nodeValue == Ir.oldValue
          };
      }
    }]), Sr;
  }(), Xl = /* @__PURE__ */ new WeakMap(), Jl = !1;
  function Zc(Sr) {
    if (!Xl.has(Sr) && (Xl.set(Sr, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(Sr.dom).whiteSpace) !== -1)) {
      if (Sr.requiresGeckoHackNode = Vi, Jl)
        return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Jl = !0;
    }
  }
  function Xc(Sr) {
    var qr;
    function Ir(ki) {
      ki.preventDefault(), ki.stopImmediatePropagation(), qr = ki.getTargetRanges()[0];
    }
    Sr.dom.addEventListener("beforeinput", Ir, !0), document.execCommand("indent"), Sr.dom.removeEventListener("beforeinput", Ir, !0);
    var Ur = qr.startContainer, jr = qr.startOffset, Vr = qr.endContainer, ei = qr.endOffset, ti = Sr.domAtPos(Sr.state.selection.anchor);
    if ($r(ti.node, ti.offset, Vr, ei)) {
      var fi = [Vr, ei, Ur, jr];
      Ur = fi[0], jr = fi[1], Vr = fi[2], ei = fi[3];
    }
    return {
      anchorNode: Ur,
      anchorOffset: jr,
      focusNode: Vr,
      focusOffset: ei
    };
  }
  function Jc(Sr, qr, Ir) {
    var Ur = Sr.docView.parseRange(qr, Ir), jr = Ur.node, Vr = Ur.fromOffset, ei = Ur.toOffset, ti = Ur.from, fi = Ur.to, ki = Sr.domSelectionRange(), Ri, ji = ki.anchorNode;
    if (ji && Sr.dom.contains(ji.nodeType == 1 ? ji : ji.parentNode) && (Ri = [{
      node: ji,
      offset: ki.anchorOffset
    }], li(ki) || Ri.push({
      node: ki.focusNode,
      offset: ki.focusOffset
    })), Mi && Sr.input.lastKeyCode === 8)
      for (var Bi = ei; Bi > Vr; Bi--) {
        var Qi = jr.childNodes[Bi - 1], na = Qi.pmViewDesc;
        if (Qi.nodeName == "BR" && !na) {
          ei = Bi;
          break;
        }
        if (!na || na.size)
          break;
      }
    var Ea = Sr.state.doc, La = Sr.someProp("domParser") || Cr.DOMParser.fromSchema(Sr.state.schema), fa = Ea.resolve(ti), so = null, Za = La.parse(jr, {
      topNode: fa.parent,
      topMatch: fa.parent.contentMatchAt(fa.index()),
      topOpen: !0,
      from: Vr,
      to: ei,
      preserveWhitespace: fa.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: Ri,
      ruleFromNode: Yc,
      context: fa
    });
    if (Ri && Ri[0].pos != null) {
      var no = Ri[0].pos, Ga = Ri[1] && Ri[1].pos;
      Ga == null && (Ga = no), so = {
        anchor: no + ti,
        head: Ga + ti
      };
    }
    return {
      doc: Za,
      sel: so,
      from: ti,
      to: fi
    };
  }
  function Yc(Sr) {
    var qr = Sr.pmViewDesc;
    if (qr)
      return qr.parseRule();
    if (Sr.nodeName == "BR" && Sr.parentNode) {
      if (mi && /^(ul|ol)$/i.test(Sr.parentNode.nodeName)) {
        var Ir = document.createElement("div");
        return Ir.appendChild(document.createElement("li")), {
          skip: Ir
        };
      } else if (Sr.parentNode.lastChild == Sr || mi && /^(tr|table)$/i.test(Sr.parentNode.nodeName))
        return {
          ignore: !0
        };
    } else if (Sr.nodeName == "IMG" && Sr.getAttribute("mark-placeholder"))
      return {
        ignore: !0
      };
    return null;
  }
  var Qc = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function eu(Sr, qr, Ir, Ur, jr) {
    var Vr = Sr.input.compositionPendingChanges || (Sr.composing ? Sr.input.compositionID : 0);
    if (Sr.input.compositionPendingChanges = 0, qr < 0) {
      var ei = Sr.input.lastSelectionTime > Date.now() - 50 ? Sr.input.lastSelectionOrigin : null, ti = Do(Sr, ei);
      if (ti && !Sr.state.selection.eq(ti)) {
        if (Mi && Ni && Sr.input.lastKeyCode === 13 && Date.now() - 100 < Sr.input.lastKeyCodeTime && Sr.someProp("handleKeyDown", function(vo) {
          return vo(Sr, Si(13, "Enter"));
        }))
          return;
        var fi = Sr.state.tr.setSelection(ti);
        ei == "pointer" ? fi.setMeta("pointer", !0) : ei == "key" && fi.scrollIntoView(), Vr && fi.setMeta("composition", Vr), Sr.dispatch(fi);
      }
      return;
    }
    var ki = Sr.state.doc.resolve(qr), Ri = ki.sharedDepth(Ir);
    qr = ki.before(Ri + 1), Ir = Sr.state.doc.resolve(Ir).after(Ri + 1);
    var ji = Sr.state.selection, Bi = Jc(Sr, qr, Ir), Qi = Sr.state.doc, na = Qi.slice(Bi.from, Bi.to), Ea, La;
    Sr.input.lastKeyCode === 8 && Date.now() - 100 < Sr.input.lastKeyCodeTime ? (Ea = Sr.state.selection.to, La = "end") : (Ea = Sr.state.selection.from, La = "start"), Sr.input.lastKeyCode = null;
    var fa = iu(na.content, Bi.doc.content, Bi.from, Ea, La);
    if ((_i && Sr.input.lastIOSEnter > Date.now() - 225 || Ni) && jr.some(function(vo) {
      return vo.nodeType == 1 && !Qc.test(vo.nodeName);
    }) && (!fa || fa.endA >= fa.endB) && Sr.someProp("handleKeyDown", function(vo) {
      return vo(Sr, Si(13, "Enter"));
    })) {
      Sr.input.lastIOSEnter = 0;
      return;
    }
    if (!fa)
      if (Ur && ji instanceof xr.TextSelection && !ji.empty && ji.$head.sameParent(ji.$anchor) && !Sr.composing && !(Bi.sel && Bi.sel.anchor != Bi.sel.head))
        fa = {
          start: ji.from,
          endA: ji.to,
          endB: ji.to
        };
      else {
        if (Bi.sel) {
          var so = Yl(Sr, Sr.state.doc, Bi.sel);
          if (so && !so.eq(Sr.state.selection)) {
            var Za = Sr.state.tr.setSelection(so);
            Vr && Za.setMeta("composition", Vr), Sr.dispatch(Za);
          }
        }
        return;
      }
    if (Mi && Sr.cursorWrapper && Bi.sel && Bi.sel.anchor == Sr.cursorWrapper.deco.from && Bi.sel.head == Bi.sel.anchor) {
      var no = fa.endB - fa.start;
      Bi.sel = {
        anchor: Bi.sel.anchor + no,
        head: Bi.sel.anchor + no
      };
    }
    Sr.input.domChangeCount++, Sr.state.selection.from < Sr.state.selection.to && fa.start == fa.endB && Sr.state.selection instanceof xr.TextSelection && (fa.start > Sr.state.selection.from && fa.start <= Sr.state.selection.from + 2 && Sr.state.selection.from >= Bi.from ? fa.start = Sr.state.selection.from : fa.endA < Sr.state.selection.to && fa.endA >= Sr.state.selection.to - 2 && Sr.state.selection.to <= Bi.to && (fa.endB += Sr.state.selection.to - fa.endA, fa.endA = Sr.state.selection.to)), Ui && yi <= 11 && fa.endB == fa.start + 1 && fa.endA == fa.start && fa.start > Bi.from && Bi.doc.textBetween(fa.start - Bi.from - 1, fa.start - Bi.from + 1) == "  " && (fa.start--, fa.endA--, fa.endB--);
    var Ga = Bi.doc.resolveNoCache(fa.start - Bi.from), Ja = Bi.doc.resolveNoCache(fa.endB - Bi.from), ho = Qi.resolve(fa.start), No = Ga.sameParent(Ja) && Ga.parent.inlineContent && ho.end() >= fa.endA, qo;
    if ((_i && Sr.input.lastIOSEnter > Date.now() - 225 && (!No || jr.some(function(vo) {
      return vo.nodeName == "DIV" || vo.nodeName == "P";
    })) || !No && Ga.pos < Bi.doc.content.size && !Ga.sameParent(Ja) && (qo = xr.Selection.findFrom(Bi.doc.resolve(Ga.pos + 1), 1, !0)) && qo.head == Ja.pos) && Sr.someProp("handleKeyDown", function(vo) {
      return vo(Sr, Si(13, "Enter"));
    })) {
      Sr.input.lastIOSEnter = 0;
      return;
    }
    if (Sr.state.selection.anchor > fa.start && ru(Qi, fa.start, fa.endA, Ga, Ja) && Sr.someProp("handleKeyDown", function(vo) {
      return vo(Sr, Si(8, "Backspace"));
    })) {
      Ni && Mi && Sr.domObserver.suppressSelectionUpdates();
      return;
    }
    Mi && Ni && fa.endB == fa.start && (Sr.input.lastAndroidDelete = Date.now()), Ni && !No && Ga.start() != Ja.start() && Ja.parentOffset == 0 && Ga.depth == Ja.depth && Bi.sel && Bi.sel.anchor == Bi.sel.head && Bi.sel.head == fa.endA && (fa.endB -= 2, Ja = Bi.doc.resolveNoCache(fa.endB - Bi.from), setTimeout(function() {
      Sr.someProp("handleKeyDown", function(vo) {
        return vo(Sr, Si(13, "Enter"));
      });
    }, 20));
    var Co = fa.start, Ko = fa.endA, Ro, Ds, Go;
    if (No) {
      if (Ga.pos == Ja.pos)
        Ui && yi <= 11 && Ga.parentOffset == 0 && (Sr.domObserver.suppressSelectionUpdates(), setTimeout(function() {
          return Bo(Sr);
        }, 20)), Ro = Sr.state.tr.delete(Co, Ko), Ds = Qi.resolve(fa.start).marksAcross(Qi.resolve(fa.endA));
      else if (fa.endA == fa.endB && (Go = tu(Ga.parent.content.cut(Ga.parentOffset, Ja.parentOffset), ho.parent.content.cut(ho.parentOffset, fa.endA - ho.start()))))
        Ro = Sr.state.tr, Go.type == "add" ? Ro.addMark(Co, Ko, Go.mark) : Ro.removeMark(Co, Ko, Go.mark);
      else if (Ga.parent.child(Ga.index()).isText && Ga.index() == Ja.index() - (Ja.textOffset ? 0 : 1)) {
        var Bs = Ga.parent.textBetween(Ga.parentOffset, Ja.parentOffset);
        if (Sr.someProp("handleTextInput", function(vo) {
          return vo(Sr, Co, Ko, Bs);
        }))
          return;
        Ro = Sr.state.tr.insertText(Bs, Co, Ko);
      }
    }
    if (Ro || (Ro = Sr.state.tr.replace(Co, Ko, Bi.doc.slice(fa.start - Bi.from, fa.endB - Bi.from))), Bi.sel) {
      var Fo = Yl(Sr, Ro.doc, Bi.sel);
      Fo && !(Mi && Ni && Sr.composing && Fo.empty && (fa.start != fa.endB || Sr.input.lastAndroidDelete < Date.now() - 100) && (Fo.head == Co || Fo.head == Ro.mapping.map(Ko) - 1) || Ui && Fo.empty && Fo.head == Co) && Ro.setSelection(Fo);
    }
    Ds && Ro.ensureMarks(Ds), Vr && Ro.setMeta("composition", Vr), Sr.dispatch(Ro.scrollIntoView());
  }
  function Yl(Sr, qr, Ir) {
    return Math.max(Ir.anchor, Ir.head) > qr.content.size ? null : Ss(Sr, qr.resolve(Ir.anchor), qr.resolve(Ir.head));
  }
  function tu(Sr, qr) {
    for (var Ir = Sr.firstChild.marks, Ur = qr.firstChild.marks, jr = Ir, Vr = Ur, ei, ti, fi, ki = 0; ki < Ur.length; ki++)
      jr = Ur[ki].removeFromSet(jr);
    for (var Ri = 0; Ri < Ir.length; Ri++)
      Vr = Ir[Ri].removeFromSet(Vr);
    if (jr.length == 1 && Vr.length == 0)
      ti = jr[0], ei = "add", fi = function(na) {
        return na.mark(ti.addToSet(na.marks));
      };
    else if (jr.length == 0 && Vr.length == 1)
      ti = Vr[0], ei = "remove", fi = function(na) {
        return na.mark(ti.removeFromSet(na.marks));
      };
    else
      return null;
    for (var ji = [], Bi = 0; Bi < qr.childCount; Bi++)
      ji.push(fi(qr.child(Bi)));
    if (Cr.Fragment.from(ji).eq(Sr))
      return {
        mark: ti,
        type: ei
      };
  }
  function ru(Sr, qr, Ir, Ur, jr) {
    if (!Ur.parent.isTextblock || Ir - qr <= jr.pos - Ur.pos || Il(Ur, !0, !1) < jr.pos)
      return !1;
    var Vr = Sr.resolve(qr);
    if (Vr.parentOffset < Vr.parent.content.size || !Vr.parent.isTextblock)
      return !1;
    var ei = Sr.resolve(Il(Vr, !0, !0));
    return !ei.parent.isTextblock || ei.pos > Ir || Il(ei, !0, !1) < Ir ? !1 : Ur.parent.content.cut(Ur.parentOffset).eq(ei.parent.content);
  }
  function Il(Sr, qr, Ir) {
    for (var Ur = Sr.depth, jr = qr ? Sr.end() : Sr.pos; Ur > 0 && (qr || Sr.indexAfter(Ur) == Sr.node(Ur).childCount); )
      Ur--, jr++, qr = !1;
    if (Ir)
      for (var Vr = Sr.node(Ur).maybeChild(Sr.indexAfter(Ur)); Vr && !Vr.isLeaf; )
        Vr = Vr.firstChild, jr++;
    return jr;
  }
  function iu(Sr, qr, Ir, Ur, jr) {
    var Vr = Sr.findDiffStart(qr, Ir);
    if (Vr == null)
      return null;
    var ei = Sr.findDiffEnd(qr, Ir + Sr.size, Ir + qr.size), ti = ei.a, fi = ei.b;
    if (jr == "end") {
      var ki = Math.max(0, Vr - Math.min(ti, fi));
      Ur -= ti + ki - Vr;
    }
    if (ti < Vr && Sr.size < qr.size) {
      var Ri = Ur <= Vr && Ur >= ti ? Vr - Ur : 0;
      Vr -= Ri, Vr && Vr < qr.size && Ql(qr.textBetween(Vr - 1, Vr + 1)) && (Vr += Ri ? 1 : -1), fi = Vr + (fi - ti), ti = Vr;
    } else if (fi < Vr) {
      var ji = Ur <= Vr && Ur >= fi ? Vr - Ur : 0;
      Vr -= ji, Vr && Vr < Sr.size && Ql(Sr.textBetween(Vr - 1, Vr + 1)) && (Vr += ji ? 1 : -1), ti = Vr + (ti - fi), fi = Vr;
    }
    return {
      start: Vr,
      endA: ti,
      endB: fi
    };
  }
  function Ql(Sr) {
    if (Sr.length != 2)
      return !1;
    var qr = Sr.charCodeAt(0), Ir = Sr.charCodeAt(1);
    return qr >= 56320 && qr <= 57343 && Ir >= 55296 && Ir <= 56319;
  }
  var au = Rs, ou = Ks, su = Js, lu = function() {
    function Sr(qr, Ir) {
      var Ur = this;
      Tr(this, Sr), this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ul(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = Ir, this.state = Ir.state, this.directPlugins = Ir.plugins || [], this.directPlugins.forEach(oc), this.dispatch = this.dispatch.bind(this), this.dom = qr && qr.mount || document.createElement("div"), qr && (qr.appendChild ? qr.appendChild(this.dom) : typeof qr == "function" ? qr(this.dom) : qr.mount && (this.mounted = !0)), this.editable = rc(this), tc(this), this.nodeViews = nc(this), this.docView = ya(this.state.doc, ec(this), Sl(this), this.dom, this), this.domObserver = new Wc(this, function(jr, Vr, ei, ti) {
        return eu(Ur, jr, Vr, ei, ti);
      }), this.domObserver.start(), wl(this), this.updatePluginViews();
    }
    return Er(Sr, [{
      key: "composing",
      get: function() {
        return this.input.composing;
      }
    }, {
      key: "props",
      get: function() {
        if (this._props.state != this.state) {
          var Ir = this._props;
          this._props = {};
          for (var Ur in Ir)
            this._props[Ur] = Ir[Ur];
          this._props.state = this.state;
        }
        return this._props;
      }
    }, {
      key: "update",
      value: function(Ir) {
        Ir.handleDOMEvents != this._props.handleDOMEvents && El(this);
        var Ur = this._props;
        this._props = Ir, Ir.plugins && (Ir.plugins.forEach(oc), this.directPlugins = Ir.plugins), this.updateStateInner(Ir.state, Ur);
      }
    }, {
      key: "setProps",
      value: function(Ir) {
        var Ur = {};
        for (var jr in this._props)
          Ur[jr] = this._props[jr];
        Ur.state = this.state;
        for (var Vr in Ir)
          Ur[Vr] = Ir[Vr];
        this.update(Ur);
      }
    }, {
      key: "updateState",
      value: function(Ir) {
        this.updateStateInner(Ir, this._props);
      }
    }, {
      key: "updateStateInner",
      value: function(Ir, Ur) {
        var jr, Vr = this.state, ei = !1, ti = !1;
        Ir.storedMarks && this.composing && (Hl(this), ti = !0), this.state = Ir;
        var fi = Vr.plugins != Ir.plugins || this._props.plugins != Ur.plugins;
        if (fi || this._props.plugins != Ur.plugins || this._props.nodeViews != Ur.nodeViews) {
          var ki = nc(this);
          uu(ki, this.nodeViews) && (this.nodeViews = ki, ei = !0);
        }
        (fi || Ur.handleDOMEvents != this._props.handleDOMEvents) && El(this), this.editable = rc(this), tc(this);
        var Ri = Sl(this), ji = ec(this), Bi = Vr.plugins != Ir.plugins && !Vr.doc.eq(Ir.doc) ? "reset" : Ir.scrollToSelection > Vr.scrollToSelection ? "to selection" : "preserve", Qi = ei || !this.docView.matchesNode(Ir.doc, ji, Ri);
        (Qi || !Ir.selection.eq(Vr.selection)) && (ti = !0);
        var na = Bi == "preserve" && ti && this.dom.style.overflowAnchor == null && Ia(this);
        if (ti) {
          this.domObserver.stop();
          var Ea = Qi && (Ui || Mi) && !this.composing && !Vr.selection.empty && !Ir.selection.empty && cu(Vr.selection, Ir.selection);
          if (Qi) {
            var La = Mi ? this.trackWrites = this.domSelectionRange().focusNode : null;
            (ei || !this.docView.update(Ir.doc, ji, Ri, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = ya(Ir.doc, ji, Ri, this.dom, this)), La && !this.trackWrites && (Ea = !0);
          }
          Ea || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && js(this)) ? Bo(this, Ea) : (zs(this, Ir.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(Vr), !((jr = this.dragging) === null || jr === void 0) && jr.node && !Vr.doc.eq(Ir.doc) && this.updateDraggedNode(this.dragging, Vr), Bi == "reset" ? this.dom.scrollTop = 0 : Bi == "to selection" ? this.scrollToSelection() : na && oa(na);
      }
    }, {
      key: "scrollToSelection",
      value: function() {
        var Ir = this, Ur = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", function(Vr) {
          return Vr(Ir);
        }))
          if (this.state.selection instanceof xr.NodeSelection) {
            var jr = this.docView.domAfterPos(this.state.selection.from);
            jr.nodeType == 1 && Fa(this, jr.getBoundingClientRect(), Ur);
          } else
            Fa(this, this.coordsAtPos(this.state.selection.head, 1), Ur);
      }
    }, {
      key: "destroyPluginViews",
      value: function() {
        for (var Ir; Ir = this.pluginViews.pop(); )
          Ir.destroy && Ir.destroy();
      }
    }, {
      key: "updatePluginViews",
      value: function(Ir) {
        if (!Ir || Ir.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (var Ur = 0; Ur < this.directPlugins.length; Ur++) {
            var jr = this.directPlugins[Ur];
            jr.spec.view && this.pluginViews.push(jr.spec.view(this));
          }
          for (var Vr = 0; Vr < this.state.plugins.length; Vr++) {
            var ei = this.state.plugins[Vr];
            ei.spec.view && this.pluginViews.push(ei.spec.view(this));
          }
        } else
          for (var ti = 0; ti < this.pluginViews.length; ti++) {
            var fi = this.pluginViews[ti];
            fi.update && fi.update(this, Ir);
          }
      }
    }, {
      key: "updateDraggedNode",
      value: function(Ir, Ur) {
        var jr = Ir.node, Vr = -1;
        if (this.state.doc.nodeAt(jr.from) == jr.node)
          Vr = jr.from;
        else {
          var ei = jr.from + (this.state.doc.content.size - Ur.doc.content.size), ti = ei > 0 && this.state.doc.nodeAt(ei);
          ti == jr.node && (Vr = ei);
        }
        this.dragging = new zl(Ir.slice, Ir.move, Vr < 0 ? void 0 : xr.NodeSelection.create(this.state.doc, Vr));
      }
    }, {
      key: "someProp",
      value: function(Ir, Ur) {
        var jr = this._props && this._props[Ir], Vr;
        if (jr != null && (Vr = Ur ? Ur(jr) : jr))
          return Vr;
        for (var ei = 0; ei < this.directPlugins.length; ei++) {
          var ti = this.directPlugins[ei].props[Ir];
          if (ti != null && (Vr = Ur ? Ur(ti) : ti))
            return Vr;
        }
        var fi = this.state.plugins;
        if (fi)
          for (var ki = 0; ki < fi.length; ki++) {
            var Ri = fi[ki].props[Ir];
            if (Ri != null && (Vr = Ur ? Ur(Ri) : Ri))
              return Vr;
          }
      }
    }, {
      key: "hasFocus",
      value: function() {
        if (Ui) {
          var Ir = this.root.activeElement;
          if (Ir == this.dom)
            return !0;
          if (!Ir || !this.dom.contains(Ir))
            return !1;
          for (; Ir && this.dom != Ir && this.dom.contains(Ir); ) {
            if (Ir.contentEditable == "false")
              return !1;
            Ir = Ir.parentElement;
          }
          return !0;
        }
        return this.root.activeElement == this.dom;
      }
    }, {
      key: "focus",
      value: function() {
        this.domObserver.stop(), this.editable && Ua(this.dom), Bo(this), this.domObserver.start();
      }
    }, {
      key: "root",
      get: function() {
        var Ir = this, Ur = this._root;
        if (Ur == null)
          for (var jr = function(fi) {
            if (fi.nodeType == 9 || fi.nodeType == 11 && fi.host)
              return fi.getSelection || (Object.getPrototypeOf(fi).getSelection = function() {
                return fi.ownerDocument.getSelection();
              }), {
                v: Ir._root = fi
              };
          }, Vr = this.dom.parentNode; Vr; Vr = Vr.parentNode) {
            var ei = jr(Vr);
            if (lr(ei) === "object")
              return ei.v;
          }
        return Ur || document;
      }
    }, {
      key: "updateRoot",
      value: function() {
        this._root = null;
      }
    }, {
      key: "posAtCoords",
      value: function(Ir) {
        return Ka(this, Ir);
      }
    }, {
      key: "coordsAtPos",
      value: function(Ir) {
        var Ur = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return $a(this, Ir, Ur);
      }
    }, {
      key: "domAtPos",
      value: function(Ir) {
        var Ur = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.docView.domFromPos(Ir, Ur);
      }
    }, {
      key: "nodeDOM",
      value: function(Ir) {
        var Ur = this.docView.descAt(Ir);
        return Ur ? Ur.nodeDOM : null;
      }
    }, {
      key: "posAtDOM",
      value: function(Ir, Ur) {
        var jr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, Vr = this.docView.posFromDOM(Ir, Ur, jr);
        if (Vr == null)
          throw new RangeError("DOM position not inside the editor");
        return Vr;
      }
    }, {
      key: "endOfTextblock",
      value: function(Ir, Ur) {
        return ao(this, Ur || this.state, Ir);
      }
    }, {
      key: "pasteHTML",
      value: function(Ir, Ur) {
        return Qs(this, "", Ir, !1, Ur || new ClipboardEvent("paste"));
      }
    }, {
      key: "pasteText",
      value: function(Ir, Ur) {
        return Qs(this, Ir, null, !0, Ur || new ClipboardEvent("paste"));
      }
    }, {
      key: "destroy",
      value: function() {
        this.docView && (Cc(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Sl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
      }
    }, {
      key: "isDestroyed",
      get: function() {
        return this.docView == null;
      }
    }, {
      key: "dispatchEvent",
      value: function(Ir) {
        return Ac(this, Ir);
      }
    }, {
      key: "dispatch",
      value: function(Ir) {
        var Ur = this._props.dispatchTransaction;
        Ur ? Ur.call(this, Ir) : this.updateState(this.state.apply(Ir));
      }
    }, {
      key: "domSelectionRange",
      value: function() {
        return mi && this.root.nodeType === 11 && ci(this.dom.ownerDocument) == this.dom ? Xc(this) : this.domSelection();
      }
    }, {
      key: "domSelection",
      value: function() {
        return this.root.getSelection();
      }
    }]), Sr;
  }();
  function ec(Sr) {
    var qr = /* @__PURE__ */ Object.create(null);
    return qr.class = "ProseMirror", qr.contenteditable = String(Sr.editable), Sr.someProp("attributes", function(Ir) {
      if (typeof Ir == "function" && (Ir = Ir(Sr.state)), Ir)
        for (var Ur in Ir)
          Ur == "class" ? qr.class += " " + Ir[Ur] : Ur == "style" ? qr.style = (qr.style ? qr.style + ";" : "") + Ir[Ur] : !qr[Ur] && Ur != "contenteditable" && Ur != "nodeName" && (qr[Ur] = String(Ir[Ur]));
    }), qr.translate || (qr.translate = "no"), [ys.node(0, Sr.state.doc.content.size, qr)];
  }
  function tc(Sr) {
    if (Sr.markCursor) {
      var qr = document.createElement("img");
      qr.className = "ProseMirror-separator", qr.setAttribute("mark-placeholder", "true"), qr.setAttribute("alt", ""), Sr.cursorWrapper = {
        dom: qr,
        deco: ys.widget(Sr.state.selection.head, qr, {
          raw: !0,
          marks: Sr.markCursor
        })
      };
    } else
      Sr.cursorWrapper = null;
  }
  function rc(Sr) {
    return !Sr.someProp("editable", function(qr) {
      return qr(Sr.state) === !1;
    });
  }
  function cu(Sr, qr) {
    var Ir = Math.min(Sr.$anchor.sharedDepth(Sr.head), qr.$anchor.sharedDepth(qr.head));
    return Sr.$anchor.start(Ir) != qr.$anchor.start(Ir);
  }
  function nc(Sr) {
    var qr = /* @__PURE__ */ Object.create(null);
    function Ir(Ur) {
      for (var jr in Ur)
        Object.prototype.hasOwnProperty.call(qr, jr) || (qr[jr] = Ur[jr]);
    }
    return Sr.someProp("nodeViews", Ir), Sr.someProp("markViews", Ir), qr;
  }
  function uu(Sr, qr) {
    var Ir = 0, Ur = 0;
    for (var jr in Sr) {
      if (Sr[jr] != qr[jr])
        return !0;
      Ir++;
    }
    for (var Vr in qr)
      Ur++;
    return Ir != Ur;
  }
  function oc(Sr) {
    if (Sr.spec.state || Sr.spec.filterTransaction || Sr.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  return dist$5.Decoration = ys, dist$5.DecorationSet = zo, dist$5.EditorView = lu, dist$5.__endComposition = su, dist$5.__parseFromClipboard = ou, dist$5.__serializeForClipboard = au, dist$5;
}
var distExports$4 = requireDist$3(), distExports$3 = requireDist$4(), dist$2 = {}, w3cKeyname = {}, hasRequiredW3cKeyname;
function requireW3cKeyname() {
  if (hasRequiredW3cKeyname)
    return w3cKeyname;
  hasRequiredW3cKeyname = 1, Object.defineProperty(w3cKeyname, "__esModule", { value: !0 });
  for (var lr = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, ar = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, cr = typeof navigator != "undefined" && /Mac/.test(navigator.platform), ur = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), fr = 0; fr < 10; fr++)
    lr[48 + fr] = lr[96 + fr] = String(fr);
  for (var fr = 1; fr <= 24; fr++)
    lr[fr + 111] = "F" + fr;
  for (var fr = 65; fr <= 90; fr++)
    lr[fr] = String.fromCharCode(fr + 32), ar[fr] = String.fromCharCode(fr);
  for (var dr in lr)
    ar.hasOwnProperty(dr) || (ar[dr] = lr[dr]);
  function hr(gr) {
    var vr = cr && gr.metaKey && gr.shiftKey && !gr.ctrlKey && !gr.altKey || ur && gr.shiftKey && gr.key && gr.key.length == 1 || gr.key == "Unidentified", mr = !vr && gr.key || (gr.shiftKey ? ar : lr)[gr.keyCode] || gr.key || "Unidentified";
    return mr == "Esc" && (mr = "Escape"), mr == "Del" && (mr = "Delete"), mr == "Left" && (mr = "ArrowLeft"), mr == "Up" && (mr = "ArrowUp"), mr == "Right" && (mr = "ArrowRight"), mr == "Down" && (mr = "ArrowDown"), mr;
  }
  return w3cKeyname.base = lr, w3cKeyname.keyName = hr, w3cKeyname.shift = ar, w3cKeyname;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2)
    return dist$2;
  hasRequiredDist$2 = 1, Object.defineProperty(dist$2, "__esModule", {
    value: !0
  });
  var lr = requireW3cKeyname(), ar = requireDist$4(), cr = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
  function ur(vr) {
    var mr = vr.split(/-(?!$)/), br = mr[mr.length - 1];
    br == "Space" && (br = " ");
    for (var yr, kr, Tr, _r, Er = 0; Er < mr.length - 1; Er++) {
      var xr = mr[Er];
      if (/^(cmd|meta|m)$/i.test(xr))
        _r = !0;
      else if (/^a(lt)?$/i.test(xr))
        yr = !0;
      else if (/^(c|ctrl|control)$/i.test(xr))
        kr = !0;
      else if (/^s(hift)?$/i.test(xr))
        Tr = !0;
      else if (/^mod$/i.test(xr))
        cr ? _r = !0 : kr = !0;
      else
        throw new Error("Unrecognized modifier name: " + xr);
    }
    return yr && (br = "Alt-" + br), kr && (br = "Ctrl-" + br), _r && (br = "Meta-" + br), Tr && (br = "Shift-" + br), br;
  }
  function fr(vr) {
    var mr = /* @__PURE__ */ Object.create(null);
    for (var br in vr)
      mr[ur(br)] = vr[br];
    return mr;
  }
  function dr(vr, mr) {
    var br = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return mr.altKey && (vr = "Alt-" + vr), mr.ctrlKey && (vr = "Ctrl-" + vr), mr.metaKey && (vr = "Meta-" + vr), br && mr.shiftKey && (vr = "Shift-" + vr), vr;
  }
  function hr(vr) {
    return new ar.Plugin({
      props: {
        handleKeyDown: gr(vr)
      }
    });
  }
  function gr(vr) {
    var mr = fr(vr);
    return function(br, yr) {
      var kr = lr.keyName(yr), Tr, _r = mr[dr(kr, yr)];
      if (_r && _r(br.state, br.dispatch, br))
        return !0;
      if (kr.length == 1 && kr != " ") {
        if (yr.shiftKey) {
          var Er = mr[dr(kr, yr, !1)];
          if (Er && Er(br.state, br.dispatch, br))
            return !0;
        }
        if ((yr.shiftKey || yr.altKey || yr.metaKey || kr.charCodeAt(0) > 127) && (Tr = lr.base[yr.keyCode]) && Tr != kr) {
          var xr = mr[dr(Tr, yr)];
          if (xr && xr(br.state, br.dispatch, br))
            return !0;
        }
      }
      return !1;
    };
  }
  return dist$2.keydownHandler = gr, dist$2.keymap = hr, dist$2;
}
var distExports$2 = requireDist$2();
const deleteSelection = (lr, ar) => lr.selection.empty ? !1 : (ar && ar(lr.tr.deleteSelection().scrollIntoView()), !0);
function atBlockStart(lr, ar) {
  let { $cursor: cr } = lr.selection;
  return !cr || (ar ? !ar.endOfTextblock("backward", lr) : cr.parentOffset > 0) ? null : cr;
}
const joinBackward = (lr, ar, cr) => {
  let ur = atBlockStart(lr, cr);
  if (!ur)
    return !1;
  let fr = findCutBefore(ur);
  if (!fr) {
    let hr = ur.blockRange(), gr = hr && liftTarget(hr);
    return gr == null ? !1 : (ar && ar(lr.tr.lift(hr, gr).scrollIntoView()), !0);
  }
  let dr = fr.nodeBefore;
  if (!dr.type.spec.isolating && deleteBarrier(lr, fr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(dr, "end") || distExports$3.NodeSelection.isSelectable(dr))) {
    let hr = replaceStep(lr.doc, ur.before(), ur.after(), distExports$5.Slice.empty);
    if (hr && hr.slice.size < hr.to - hr.from) {
      if (ar) {
        let gr = lr.tr.step(hr);
        gr.setSelection(textblockAt(dr, "end") ? distExports$3.Selection.findFrom(gr.doc.resolve(gr.mapping.map(fr.pos, -1)), -1) : distExports$3.NodeSelection.create(gr.doc, fr.pos - dr.nodeSize)), ar(gr.scrollIntoView());
      }
      return !0;
    }
  }
  return dr.isAtom && fr.depth == ur.depth - 1 ? (ar && ar(lr.tr.delete(fr.pos - dr.nodeSize, fr.pos).scrollIntoView()), !0) : !1;
};
function textblockAt(lr, ar, cr = !1) {
  for (let ur = lr; ur; ur = ar == "start" ? ur.firstChild : ur.lastChild) {
    if (ur.isTextblock)
      return !0;
    if (cr && ur.childCount != 1)
      return !1;
  }
  return !1;
}
const selectNodeBackward = (lr, ar, cr) => {
  let { $head: ur, empty: fr } = lr.selection, dr = ur;
  if (!fr)
    return !1;
  if (ur.parent.isTextblock) {
    if (cr ? !cr.endOfTextblock("backward", lr) : ur.parentOffset > 0)
      return !1;
    dr = findCutBefore(ur);
  }
  let hr = dr && dr.nodeBefore;
  return !hr || !distExports$3.NodeSelection.isSelectable(hr) ? !1 : (ar && ar(lr.tr.setSelection(distExports$3.NodeSelection.create(lr.doc, dr.pos - hr.nodeSize)).scrollIntoView()), !0);
};
function findCutBefore(lr) {
  if (!lr.parent.type.spec.isolating)
    for (let ar = lr.depth - 1; ar >= 0; ar--) {
      if (lr.index(ar) > 0)
        return lr.doc.resolve(lr.before(ar + 1));
      if (lr.node(ar).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(lr, ar) {
  let { $cursor: cr } = lr.selection;
  return !cr || (ar ? !ar.endOfTextblock("forward", lr) : cr.parentOffset < cr.parent.content.size) ? null : cr;
}
const joinForward = (lr, ar, cr) => {
  let ur = atBlockEnd(lr, cr);
  if (!ur)
    return !1;
  let fr = findCutAfter(ur);
  if (!fr)
    return !1;
  let dr = fr.nodeAfter;
  if (deleteBarrier(lr, fr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(dr, "start") || distExports$3.NodeSelection.isSelectable(dr))) {
    let hr = replaceStep(lr.doc, ur.before(), ur.after(), distExports$5.Slice.empty);
    if (hr && hr.slice.size < hr.to - hr.from) {
      if (ar) {
        let gr = lr.tr.step(hr);
        gr.setSelection(textblockAt(dr, "start") ? distExports$3.Selection.findFrom(gr.doc.resolve(gr.mapping.map(fr.pos)), 1) : distExports$3.NodeSelection.create(gr.doc, gr.mapping.map(fr.pos))), ar(gr.scrollIntoView());
      }
      return !0;
    }
  }
  return dr.isAtom && fr.depth == ur.depth - 1 ? (ar && ar(lr.tr.delete(fr.pos, fr.pos + dr.nodeSize).scrollIntoView()), !0) : !1;
}, selectNodeForward = (lr, ar, cr) => {
  let { $head: ur, empty: fr } = lr.selection, dr = ur;
  if (!fr)
    return !1;
  if (ur.parent.isTextblock) {
    if (cr ? !cr.endOfTextblock("forward", lr) : ur.parentOffset < ur.parent.content.size)
      return !1;
    dr = findCutAfter(ur);
  }
  let hr = dr && dr.nodeAfter;
  return !hr || !distExports$3.NodeSelection.isSelectable(hr) ? !1 : (ar && ar(lr.tr.setSelection(distExports$3.NodeSelection.create(lr.doc, dr.pos)).scrollIntoView()), !0);
};
function findCutAfter(lr) {
  if (!lr.parent.type.spec.isolating)
    for (let ar = lr.depth - 1; ar >= 0; ar--) {
      let cr = lr.node(ar);
      if (lr.index(ar) + 1 < cr.childCount)
        return lr.doc.resolve(lr.after(ar + 1));
      if (cr.type.spec.isolating)
        break;
    }
  return null;
}
const newlineInCode = (lr, ar) => {
  let { $head: cr, $anchor: ur } = lr.selection;
  return !cr.parent.type.spec.code || !cr.sameParent(ur) ? !1 : (ar && ar(lr.tr.insertText(`
`).scrollIntoView()), !0);
};
function defaultBlockAt(lr) {
  for (let ar = 0; ar < lr.edgeCount; ar++) {
    let { type: cr } = lr.edge(ar);
    if (cr.isTextblock && !cr.hasRequiredAttrs())
      return cr;
  }
  return null;
}
const exitCode = (lr, ar) => {
  let { $head: cr, $anchor: ur } = lr.selection;
  if (!cr.parent.type.spec.code || !cr.sameParent(ur))
    return !1;
  let fr = cr.node(-1), dr = cr.indexAfter(-1), hr = defaultBlockAt(fr.contentMatchAt(dr));
  if (!hr || !fr.canReplaceWith(dr, dr, hr))
    return !1;
  if (ar) {
    let gr = cr.after(), vr = lr.tr.replaceWith(gr, gr, hr.createAndFill());
    vr.setSelection(distExports$3.Selection.near(vr.doc.resolve(gr), 1)), ar(vr.scrollIntoView());
  }
  return !0;
}, createParagraphNear = (lr, ar) => {
  let cr = lr.selection, { $from: ur, $to: fr } = cr;
  if (cr instanceof distExports$3.AllSelection || ur.parent.inlineContent || fr.parent.inlineContent)
    return !1;
  let dr = defaultBlockAt(fr.parent.contentMatchAt(fr.indexAfter()));
  if (!dr || !dr.isTextblock)
    return !1;
  if (ar) {
    let hr = (!ur.parentOffset && fr.index() < fr.parent.childCount ? ur : fr).pos, gr = lr.tr.insert(hr, dr.createAndFill());
    gr.setSelection(distExports$3.TextSelection.create(gr.doc, hr + 1)), ar(gr.scrollIntoView());
  }
  return !0;
}, liftEmptyBlock = (lr, ar) => {
  let { $cursor: cr } = lr.selection;
  if (!cr || cr.parent.content.size)
    return !1;
  if (cr.depth > 1 && cr.after() != cr.end(-1)) {
    let dr = cr.before();
    if (canSplit(lr.doc, dr))
      return ar && ar(lr.tr.split(dr).scrollIntoView()), !0;
  }
  let ur = cr.blockRange(), fr = ur && liftTarget(ur);
  return fr == null ? !1 : (ar && ar(lr.tr.lift(ur, fr).scrollIntoView()), !0);
};
function splitBlockAs(lr) {
  return (ar, cr) => {
    let { $from: ur, $to: fr } = ar.selection;
    if (ar.selection instanceof distExports$3.NodeSelection && ar.selection.node.isBlock)
      return !ur.parentOffset || !canSplit(ar.doc, ur.pos) ? !1 : (cr && cr(ar.tr.split(ur.pos).scrollIntoView()), !0);
    if (!ur.parent.isBlock)
      return !1;
    if (cr) {
      let dr = fr.parentOffset == fr.parent.content.size, hr = ar.tr;
      (ar.selection instanceof distExports$3.TextSelection || ar.selection instanceof distExports$3.AllSelection) && hr.deleteSelection();
      let gr = ur.depth == 0 ? null : defaultBlockAt(ur.node(-1).contentMatchAt(ur.indexAfter(-1))), vr = lr && lr(fr.parent, dr), mr = vr ? [vr] : dr && gr ? [{ type: gr }] : void 0, br = canSplit(hr.doc, hr.mapping.map(ur.pos), 1, mr);
      if (!mr && !br && canSplit(hr.doc, hr.mapping.map(ur.pos), 1, gr ? [{ type: gr }] : void 0) && (gr && (mr = [{ type: gr }]), br = !0), br && (hr.split(hr.mapping.map(ur.pos), 1, mr), !dr && !ur.parentOffset && ur.parent.type != gr)) {
        let yr = hr.mapping.map(ur.before()), kr = hr.doc.resolve(yr);
        gr && ur.node(-1).canReplaceWith(kr.index(), kr.index() + 1, gr) && hr.setNodeMarkup(hr.mapping.map(ur.before()), gr);
      }
      cr(hr.scrollIntoView());
    }
    return !0;
  };
}
const splitBlock = splitBlockAs(), selectAll = (lr, ar) => (ar && ar(lr.tr.setSelection(new distExports$3.AllSelection(lr.doc))), !0);
function joinMaybeClear(lr, ar, cr) {
  let ur = ar.nodeBefore, fr = ar.nodeAfter, dr = ar.index();
  return !ur || !fr || !ur.type.compatibleContent(fr.type) ? !1 : !ur.content.size && ar.parent.canReplace(dr - 1, dr) ? (cr && cr(lr.tr.delete(ar.pos - ur.nodeSize, ar.pos).scrollIntoView()), !0) : !ar.parent.canReplace(dr, dr + 1) || !(fr.isTextblock || canJoin(lr.doc, ar.pos)) ? !1 : (cr && cr(lr.tr.clearIncompatible(ar.pos, ur.type, ur.contentMatchAt(ur.childCount)).join(ar.pos).scrollIntoView()), !0);
}
function deleteBarrier(lr, ar, cr) {
  let ur = ar.nodeBefore, fr = ar.nodeAfter, dr, hr;
  if (ur.type.spec.isolating || fr.type.spec.isolating)
    return !1;
  if (joinMaybeClear(lr, ar, cr))
    return !0;
  let gr = ar.parent.canReplace(ar.index(), ar.index() + 1);
  if (gr && (dr = (hr = ur.contentMatchAt(ur.childCount)).findWrapping(fr.type)) && hr.matchType(dr[0] || fr.type).validEnd) {
    if (cr) {
      let yr = ar.pos + fr.nodeSize, kr = distExports$5.Fragment.empty;
      for (let Er = dr.length - 1; Er >= 0; Er--)
        kr = distExports$5.Fragment.from(dr[Er].create(null, kr));
      kr = distExports$5.Fragment.from(ur.copy(kr));
      let Tr = lr.tr.step(new ReplaceAroundStep(ar.pos - 1, yr, ar.pos, yr, new distExports$5.Slice(kr, 1, 0), dr.length, !0)), _r = yr + 2 * dr.length;
      canJoin(Tr.doc, _r) && Tr.join(_r), cr(Tr.scrollIntoView());
    }
    return !0;
  }
  let vr = distExports$3.Selection.findFrom(ar, 1), mr = vr && vr.$from.blockRange(vr.$to), br = mr && liftTarget(mr);
  if (br != null && br >= ar.depth)
    return cr && cr(lr.tr.lift(mr, br).scrollIntoView()), !0;
  if (gr && textblockAt(fr, "start", !0) && textblockAt(ur, "end")) {
    let yr = ur, kr = [];
    for (; kr.push(yr), !yr.isTextblock; )
      yr = yr.lastChild;
    let Tr = fr, _r = 1;
    for (; !Tr.isTextblock; Tr = Tr.firstChild)
      _r++;
    if (yr.canReplace(yr.childCount, yr.childCount, Tr.content)) {
      if (cr) {
        let Er = distExports$5.Fragment.empty;
        for (let Cr = kr.length - 1; Cr >= 0; Cr--)
          Er = distExports$5.Fragment.from(kr[Cr].copy(Er));
        let xr = lr.tr.step(new ReplaceAroundStep(ar.pos - kr.length, ar.pos + fr.nodeSize, ar.pos + _r, ar.pos + fr.nodeSize - _r, new distExports$5.Slice(Er, kr.length, 0), 0, !0));
        cr(xr.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function selectTextblockSide(lr) {
  return function(ar, cr) {
    let ur = ar.selection, fr = lr < 0 ? ur.$from : ur.$to, dr = fr.depth;
    for (; fr.node(dr).isInline; ) {
      if (!dr)
        return !1;
      dr--;
    }
    return fr.node(dr).isTextblock ? (cr && cr(ar.tr.setSelection(distExports$3.TextSelection.create(ar.doc, lr < 0 ? fr.start(dr) : fr.end(dr)))), !0) : !1;
  };
}
const selectTextblockStart = selectTextblockSide(-1), selectTextblockEnd = selectTextblockSide(1);
function wrapIn(lr, ar = null) {
  return function(cr, ur) {
    let { $from: fr, $to: dr } = cr.selection, hr = fr.blockRange(dr), gr = hr && findWrapping(hr, lr, ar);
    return gr ? (ur && ur(cr.tr.wrap(hr, gr).scrollIntoView()), !0) : !1;
  };
}
function setBlockType(lr, ar = null) {
  return function(cr, ur) {
    let fr = !1;
    for (let dr = 0; dr < cr.selection.ranges.length && !fr; dr++) {
      let { $from: { pos: hr }, $to: { pos: gr } } = cr.selection.ranges[dr];
      cr.doc.nodesBetween(hr, gr, (vr, mr) => {
        if (fr)
          return !1;
        if (!(!vr.isTextblock || vr.hasMarkup(lr, ar)))
          if (vr.type == lr)
            fr = !0;
          else {
            let br = cr.doc.resolve(mr), yr = br.index();
            fr = br.parent.canReplaceWith(yr, yr + 1, lr);
          }
      });
    }
    if (!fr)
      return !1;
    if (ur) {
      let dr = cr.tr;
      for (let hr = 0; hr < cr.selection.ranges.length; hr++) {
        let { $from: { pos: gr }, $to: { pos: vr } } = cr.selection.ranges[hr];
        dr.setBlockType(gr, vr, lr, ar);
      }
      ur(dr.scrollIntoView());
    }
    return !0;
  };
}
function markApplies(lr, ar, cr) {
  for (let ur = 0; ur < ar.length; ur++) {
    let { $from: fr, $to: dr } = ar[ur], hr = fr.depth == 0 ? lr.inlineContent && lr.type.allowsMarkType(cr) : !1;
    if (lr.nodesBetween(fr.pos, dr.pos, (gr) => {
      if (hr)
        return !1;
      hr = gr.inlineContent && gr.type.allowsMarkType(cr);
    }), hr)
      return !0;
  }
  return !1;
}
function toggleMark$1(lr, ar = null) {
  return function(cr, ur) {
    let { empty: fr, $cursor: dr, ranges: hr } = cr.selection;
    if (fr && !dr || !markApplies(cr.doc, hr, lr))
      return !1;
    if (ur)
      if (dr)
        lr.isInSet(cr.storedMarks || dr.marks()) ? ur(cr.tr.removeStoredMark(lr)) : ur(cr.tr.addStoredMark(lr.create(ar)));
      else {
        let gr = !1, vr = cr.tr;
        for (let mr = 0; !gr && mr < hr.length; mr++) {
          let { $from: br, $to: yr } = hr[mr];
          gr = cr.doc.rangeHasMark(br.pos, yr.pos, lr);
        }
        for (let mr = 0; mr < hr.length; mr++) {
          let { $from: br, $to: yr } = hr[mr];
          if (gr)
            vr.removeMark(br.pos, yr.pos, lr);
          else {
            let kr = br.pos, Tr = yr.pos, _r = br.nodeAfter, Er = yr.nodeBefore, xr = _r && _r.isText ? /^\s*/.exec(_r.text)[0].length : 0, Cr = Er && Er.isText ? /\s*$/.exec(Er.text)[0].length : 0;
            kr + xr < Tr && (kr += xr, Tr -= Cr), vr.addMark(kr, Tr, lr.create(ar));
          }
        }
        ur(vr.scrollIntoView());
      }
    return !0;
  };
}
function chainCommands(...lr) {
  return function(ar, cr, ur) {
    for (let fr = 0; fr < lr.length; fr++)
      if (lr[fr](ar, cr, ur))
        return !0;
    return !1;
  };
}
let backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward), del = chainCommands(deleteSelection, joinForward, selectNodeForward);
const pcBaseKeymap = {
  Enter: chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  Backspace: backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  Delete: del,
  "Mod-Delete": del,
  "Mod-a": selectAll
}, macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap.Backspace,
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap.Delete,
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let lr in pcBaseKeymap)
  macBaseKeymap[lr] = pcBaseKeymap[lr];
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : !1, baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
var dist$1 = {}, hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1)
    return dist$1;
  hasRequiredDist$1 = 1;
  function lr(Dr, Nr) {
    for (var Hr = 0; Hr < Nr.length; Hr++) {
      var $r = Nr[Hr];
      $r.enumerable = $r.enumerable || !1, $r.configurable = !0, "value" in $r && ($r.writable = !0), Object.defineProperty(Dr, $r.key, $r);
    }
  }
  function ar(Dr, Nr, Hr) {
    return Nr && lr(Dr.prototype, Nr), Hr && lr(Dr, Hr), Object.defineProperty(Dr, "prototype", { writable: !1 }), Dr;
  }
  function cr(Dr, Nr) {
    if (!(Dr instanceof Nr))
      throw new TypeError("Cannot call a class as a function");
  }
  var ur = requireDist$4(), fr = require$$1$2, dr = ar(function Dr(Nr, Hr) {
    var $r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    cr(this, Dr), this.match = Nr, this.match = Nr, this.handler = typeof Hr == "string" ? hr(Hr) : Hr, this.undoable = $r.undoable !== !1;
  });
  function hr(Dr) {
    return function(Nr, Hr, $r, Wr) {
      var Zr = Dr;
      if (Hr[1]) {
        var oi = Hr[0].lastIndexOf(Hr[1]);
        Zr += Hr[0].slice(oi + Hr[1].length), $r += oi;
        var Jr = $r - Wr;
        Jr > 0 && (Zr = Hr[0].slice(oi - Jr, oi) + Zr, $r = Wr);
      }
      return Nr.tr.insertText(Zr, $r, Wr);
    };
  }
  var gr = 500;
  function vr(Dr) {
    var Nr = Dr.rules, Hr = new ur.Plugin({
      state: {
        init: function() {
          return null;
        },
        apply: function(Wr, Zr) {
          var oi = Wr.getMeta(this);
          return oi || (Wr.selectionSet || Wr.docChanged ? null : Zr);
        }
      },
      props: {
        handleTextInput: function(Wr, Zr, oi, Jr) {
          return mr(Wr, Zr, oi, Jr, Nr, Hr);
        },
        handleDOMEvents: {
          compositionend: function(Wr) {
            setTimeout(function() {
              var Zr = Wr.state.selection.$cursor;
              Zr && mr(Wr, Zr.pos, Zr.pos, "", Nr, Hr);
            });
          }
        }
      },
      isInputRules: !0
    });
    return Hr;
  }
  function mr(Dr, Nr, Hr, $r, Wr, Zr) {
    if (Dr.composing)
      return !1;
    var oi = Dr.state, Jr = oi.doc.resolve(Nr);
    if (Jr.parent.type.spec.code)
      return !1;
    for (var Yr = Jr.parent.textBetween(Math.max(0, Jr.parentOffset - gr), Jr.parentOffset, null, "￼") + $r, li = 0; li < Wr.length; li++) {
      var Si = Wr[li], ci = Si.match.exec(Yr), hi = ci && Si.handler(oi, ci, Nr - (ci[0].length - $r.length), Hr);
      if (hi)
        return Si.undoable && hi.setMeta(Zr, {
          transform: hi,
          from: Nr,
          to: Hr,
          text: $r
        }), Dr.dispatch(hi), !0;
    }
    return !1;
  }
  var br = function(Nr, Hr) {
    for (var $r = Nr.plugins, Wr = 0; Wr < $r.length; Wr++) {
      var Zr = $r[Wr], oi = void 0;
      if (Zr.spec.isInputRules && (oi = Zr.getState(Nr))) {
        if (Hr) {
          for (var Jr = Nr.tr, Yr = oi.transform, li = Yr.steps.length - 1; li >= 0; li--)
            Jr.step(Yr.steps[li].invert(Yr.docs[li]));
          if (oi.text) {
            var Si = Jr.doc.resolve(oi.from).marks();
            Jr.replaceWith(oi.from, oi.to, Nr.schema.text(oi.text, Si));
          } else
            Jr.delete(oi.from, oi.to);
          Hr(Jr);
        }
        return !0;
      }
    }
    return !1;
  }, yr = new dr(/--$/, "—"), kr = new dr(/\.\.\.$/, "…"), Tr = new dr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"), _r = new dr(/"$/, "”"), Er = new dr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"), xr = new dr(/'$/, "’"), Cr = [Tr, _r, Er, xr];
  function Ar(Dr, Nr) {
    var Hr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, $r = arguments.length > 3 ? arguments[3] : void 0;
    return new dr(Dr, function(Wr, Zr, oi, Jr) {
      var Yr = Hr instanceof Function ? Hr(Zr) : Hr, li = Wr.tr.delete(oi, Jr), Si = li.doc.resolve(oi), ci = Si.blockRange(), hi = ci && fr.findWrapping(ci, Nr, Yr);
      if (!hi)
        return null;
      li.wrap(ci, hi);
      var Ei = li.doc.resolve(oi - 1).nodeBefore;
      return Ei && Ei.type == Nr && fr.canJoin(li.doc, oi - 1) && (!$r || $r(Zr, Ei)) && li.join(oi - 1), li;
    });
  }
  function Lr(Dr, Nr) {
    var Hr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return new dr(Dr, function($r, Wr, Zr, oi) {
      var Jr = $r.doc.resolve(Zr), Yr = Hr instanceof Function ? Hr(Wr) : Hr;
      return Jr.node(-1).canReplaceWith(Jr.index(-1), Jr.indexAfter(-1), Nr) ? $r.tr.delete(Zr, oi).setBlockType(Zr, Zr, Nr, Yr) : null;
    });
  }
  return dist$1.InputRule = dr, dist$1.closeDoubleQuote = _r, dist$1.closeSingleQuote = xr, dist$1.ellipsis = kr, dist$1.emDash = yr, dist$1.inputRules = vr, dist$1.openDoubleQuote = Tr, dist$1.openSingleQuote = Er, dist$1.smartQuotes = Cr, dist$1.textblockTypeInputRule = Lr, dist$1.undoInputRule = br, dist$1.wrappingInputRule = Ar, dist$1;
}
var distExports$1 = requireDist$1(), GOOD_LEAF_SIZE = 200, RopeSequence = function lr() {
};
RopeSequence.prototype.append = function lr(ar) {
  return ar.length ? (ar = RopeSequence.from(ar), !this.length && ar || ar.length < GOOD_LEAF_SIZE && this.leafAppend(ar) || this.length < GOOD_LEAF_SIZE && ar.leafPrepend(this) || this.appendInner(ar)) : this;
};
RopeSequence.prototype.prepend = function lr(ar) {
  return ar.length ? RopeSequence.from(ar).append(this) : this;
};
RopeSequence.prototype.appendInner = function lr(ar) {
  return new Append(this, ar);
};
RopeSequence.prototype.slice = function lr(ar, cr) {
  return ar === void 0 && (ar = 0), cr === void 0 && (cr = this.length), ar >= cr ? RopeSequence.empty : this.sliceInner(Math.max(0, ar), Math.min(this.length, cr));
};
RopeSequence.prototype.get = function lr(ar) {
  if (!(ar < 0 || ar >= this.length))
    return this.getInner(ar);
};
RopeSequence.prototype.forEach = function lr(ar, cr, ur) {
  cr === void 0 && (cr = 0), ur === void 0 && (ur = this.length), cr <= ur ? this.forEachInner(ar, cr, ur, 0) : this.forEachInvertedInner(ar, cr, ur, 0);
};
RopeSequence.prototype.map = function lr(ar, cr, ur) {
  cr === void 0 && (cr = 0), ur === void 0 && (ur = this.length);
  var fr = [];
  return this.forEach(function(dr, hr) {
    return fr.push(ar(dr, hr));
  }, cr, ur), fr;
};
RopeSequence.from = function lr(ar) {
  return ar instanceof RopeSequence ? ar : ar && ar.length ? new Leaf(ar) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(lr) {
  function ar(ur) {
    lr.call(this), this.values = ur;
  }
  lr && (ar.__proto__ = lr), ar.prototype = Object.create(lr && lr.prototype), ar.prototype.constructor = ar;
  var cr = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return ar.prototype.flatten = function() {
    return this.values;
  }, ar.prototype.sliceInner = function(fr, dr) {
    return fr == 0 && dr == this.length ? this : new ar(this.values.slice(fr, dr));
  }, ar.prototype.getInner = function(fr) {
    return this.values[fr];
  }, ar.prototype.forEachInner = function(fr, dr, hr, gr) {
    for (var vr = dr; vr < hr; vr++)
      if (fr(this.values[vr], gr + vr) === !1)
        return !1;
  }, ar.prototype.forEachInvertedInner = function(fr, dr, hr, gr) {
    for (var vr = dr - 1; vr >= hr; vr--)
      if (fr(this.values[vr], gr + vr) === !1)
        return !1;
  }, ar.prototype.leafAppend = function(fr) {
    if (this.length + fr.length <= GOOD_LEAF_SIZE)
      return new ar(this.values.concat(fr.flatten()));
  }, ar.prototype.leafPrepend = function(fr) {
    if (this.length + fr.length <= GOOD_LEAF_SIZE)
      return new ar(fr.flatten().concat(this.values));
  }, cr.length.get = function() {
    return this.values.length;
  }, cr.depth.get = function() {
    return 0;
  }, Object.defineProperties(ar.prototype, cr), ar;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(lr) {
  function ar(cr, ur) {
    lr.call(this), this.left = cr, this.right = ur, this.length = cr.length + ur.length, this.depth = Math.max(cr.depth, ur.depth) + 1;
  }
  return lr && (ar.__proto__ = lr), ar.prototype = Object.create(lr && lr.prototype), ar.prototype.constructor = ar, ar.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, ar.prototype.getInner = function(ur) {
    return ur < this.left.length ? this.left.get(ur) : this.right.get(ur - this.left.length);
  }, ar.prototype.forEachInner = function(ur, fr, dr, hr) {
    var gr = this.left.length;
    if (fr < gr && this.left.forEachInner(ur, fr, Math.min(dr, gr), hr) === !1 || dr > gr && this.right.forEachInner(ur, Math.max(fr - gr, 0), Math.min(this.length, dr) - gr, hr + gr) === !1)
      return !1;
  }, ar.prototype.forEachInvertedInner = function(ur, fr, dr, hr) {
    var gr = this.left.length;
    if (fr > gr && this.right.forEachInvertedInner(ur, fr - gr, Math.max(dr, gr) - gr, hr + gr) === !1 || dr < gr && this.left.forEachInvertedInner(ur, Math.min(fr, gr), dr, hr) === !1)
      return !1;
  }, ar.prototype.sliceInner = function(ur, fr) {
    if (ur == 0 && fr == this.length)
      return this;
    var dr = this.left.length;
    return fr <= dr ? this.left.slice(ur, fr) : ur >= dr ? this.right.slice(ur - dr, fr - dr) : this.left.slice(ur, dr).append(this.right.slice(0, fr - dr));
  }, ar.prototype.leafAppend = function(ur) {
    var fr = this.right.leafAppend(ur);
    if (fr)
      return new ar(this.left, fr);
  }, ar.prototype.leafPrepend = function(ur) {
    var fr = this.left.leafPrepend(ur);
    if (fr)
      return new ar(fr, this.right);
  }, ar.prototype.appendInner = function(ur) {
    return this.left.depth >= Math.max(this.right.depth, ur.depth) + 1 ? new ar(this.left, new ar(this.right, ur)) : new ar(this, ur);
  }, ar;
}(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(ar, cr) {
    this.items = ar, this.eventCount = cr;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(ar, cr) {
    if (this.eventCount == 0)
      return null;
    let ur = this.items.length;
    for (; ; ur--)
      if (this.items.get(ur - 1).selection) {
        --ur;
        break;
      }
    let fr, dr;
    cr && (fr = this.remapping(ur, this.items.length), dr = fr.maps.length);
    let hr = ar.tr, gr, vr, mr = [], br = [];
    return this.items.forEach((yr, kr) => {
      if (!yr.step) {
        fr || (fr = this.remapping(ur, kr + 1), dr = fr.maps.length), dr--, br.push(yr);
        return;
      }
      if (fr) {
        br.push(new Item(yr.map));
        let Tr = yr.step.map(fr.slice(dr)), _r;
        Tr && hr.maybeStep(Tr).doc && (_r = hr.mapping.maps[hr.mapping.maps.length - 1], mr.push(new Item(_r, void 0, void 0, mr.length + br.length))), dr--, _r && fr.appendMap(_r, dr);
      } else
        hr.maybeStep(yr.step);
      if (yr.selection)
        return gr = fr ? yr.selection.map(fr.slice(dr)) : yr.selection, vr = new Branch(this.items.slice(0, ur).append(br.reverse().concat(mr)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: vr, transform: hr, selection: gr };
  }
  // Create a new branch with the given transform added.
  addTransform(ar, cr, ur, fr) {
    let dr = [], hr = this.eventCount, gr = this.items, vr = !fr && gr.length ? gr.get(gr.length - 1) : null;
    for (let br = 0; br < ar.steps.length; br++) {
      let yr = ar.steps[br].invert(ar.docs[br]), kr = new Item(ar.mapping.maps[br], yr, cr), Tr;
      (Tr = vr && vr.merge(kr)) && (kr = Tr, br ? dr.pop() : gr = gr.slice(0, gr.length - 1)), dr.push(kr), cr && (hr++, cr = void 0), fr || (vr = kr);
    }
    let mr = hr - ur.depth;
    return mr > DEPTH_OVERFLOW && (gr = cutOffEvents(gr, mr), hr -= mr), new Branch(gr.append(dr), hr);
  }
  remapping(ar, cr) {
    let ur = new Mapping();
    return this.items.forEach((fr, dr) => {
      let hr = fr.mirrorOffset != null && dr - fr.mirrorOffset >= ar ? ur.maps.length - fr.mirrorOffset : void 0;
      ur.appendMap(fr.map, hr);
    }, ar, cr), ur;
  }
  addMaps(ar) {
    return this.eventCount == 0 ? this : new Branch(this.items.append(ar.map((cr) => new Item(cr))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(ar, cr) {
    if (!this.eventCount)
      return this;
    let ur = [], fr = Math.max(0, this.items.length - cr), dr = ar.mapping, hr = ar.steps.length, gr = this.eventCount;
    this.items.forEach((kr) => {
      kr.selection && gr--;
    }, fr);
    let vr = cr;
    this.items.forEach((kr) => {
      let Tr = dr.getMirror(--vr);
      if (Tr == null)
        return;
      hr = Math.min(hr, Tr);
      let _r = dr.maps[Tr];
      if (kr.step) {
        let Er = ar.steps[Tr].invert(ar.docs[Tr]), xr = kr.selection && kr.selection.map(dr.slice(vr + 1, Tr));
        xr && gr++, ur.push(new Item(_r, Er, xr));
      } else
        ur.push(new Item(_r));
    }, fr);
    let mr = [];
    for (let kr = cr; kr < hr; kr++)
      mr.push(new Item(dr.maps[kr]));
    let br = this.items.slice(0, fr).append(mr).append(ur), yr = new Branch(br, gr);
    return yr.emptyItemCount() > max_empty_items && (yr = yr.compress(this.items.length - ur.length)), yr;
  }
  emptyItemCount() {
    let ar = 0;
    return this.items.forEach((cr) => {
      cr.step || ar++;
    }), ar;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(ar = this.items.length) {
    let cr = this.remapping(0, ar), ur = cr.maps.length, fr = [], dr = 0;
    return this.items.forEach((hr, gr) => {
      if (gr >= ar)
        fr.push(hr), hr.selection && dr++;
      else if (hr.step) {
        let vr = hr.step.map(cr.slice(ur)), mr = vr && vr.getMap();
        if (ur--, mr && cr.appendMap(mr, ur), vr) {
          let br = hr.selection && hr.selection.map(cr.slice(ur));
          br && dr++;
          let yr = new Item(mr.invert(), vr, br), kr, Tr = fr.length - 1;
          (kr = fr.length && fr[Tr].merge(yr)) ? fr[Tr] = kr : fr.push(yr);
        }
      } else
        hr.map && ur--;
    }, this.items.length, 0), new Branch(RopeSequence.from(fr.reverse()), dr);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(lr, ar) {
  let cr;
  return lr.forEach((ur, fr) => {
    if (ur.selection && ar-- == 0)
      return cr = fr, !1;
  }), lr.slice(cr);
}
class Item {
  constructor(ar, cr, ur, fr) {
    this.map = ar, this.step = cr, this.selection = ur, this.mirrorOffset = fr;
  }
  merge(ar) {
    if (this.step && ar.step && !ar.selection) {
      let cr = ar.step.merge(this.step);
      if (cr)
        return new Item(cr.getMap().invert(), cr, this.selection);
    }
  }
}
class HistoryState {
  constructor(ar, cr, ur, fr, dr) {
    this.done = ar, this.undone = cr, this.prevRanges = ur, this.prevTime = fr, this.prevComposition = dr;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(lr, ar, cr, ur) {
  let fr = cr.getMeta(historyKey), dr;
  if (fr)
    return fr.historyState;
  cr.getMeta(closeHistoryKey) && (lr = new HistoryState(lr.done, lr.undone, null, 0, -1));
  let hr = cr.getMeta("appendedTransaction");
  if (cr.steps.length == 0)
    return lr;
  if (hr && hr.getMeta(historyKey))
    return hr.getMeta(historyKey).redo ? new HistoryState(lr.done.addTransform(cr, void 0, ur, mustPreserveItems(ar)), lr.undone, rangesFor(cr.mapping.maps[cr.steps.length - 1]), lr.prevTime, lr.prevComposition) : new HistoryState(lr.done, lr.undone.addTransform(cr, void 0, ur, mustPreserveItems(ar)), null, lr.prevTime, lr.prevComposition);
  if (cr.getMeta("addToHistory") !== !1 && !(hr && hr.getMeta("addToHistory") === !1)) {
    let gr = cr.getMeta("composition"), vr = lr.prevTime == 0 || !hr && lr.prevComposition != gr && (lr.prevTime < (cr.time || 0) - ur.newGroupDelay || !isAdjacentTo(cr, lr.prevRanges)), mr = hr ? mapRanges(lr.prevRanges, cr.mapping) : rangesFor(cr.mapping.maps[cr.steps.length - 1]);
    return new HistoryState(lr.done.addTransform(cr, vr ? ar.selection.getBookmark() : void 0, ur, mustPreserveItems(ar)), Branch.empty, mr, cr.time, gr == null ? lr.prevComposition : gr);
  } else
    return (dr = cr.getMeta("rebased")) ? new HistoryState(lr.done.rebased(cr, dr), lr.undone.rebased(cr, dr), mapRanges(lr.prevRanges, cr.mapping), lr.prevTime, lr.prevComposition) : new HistoryState(lr.done.addMaps(cr.mapping.maps), lr.undone.addMaps(cr.mapping.maps), mapRanges(lr.prevRanges, cr.mapping), lr.prevTime, lr.prevComposition);
}
function isAdjacentTo(lr, ar) {
  if (!ar)
    return !1;
  if (!lr.docChanged)
    return !0;
  let cr = !1;
  return lr.mapping.maps[0].forEach((ur, fr) => {
    for (let dr = 0; dr < ar.length; dr += 2)
      ur <= ar[dr + 1] && fr >= ar[dr] && (cr = !0);
  }), cr;
}
function rangesFor(lr) {
  let ar = [];
  return lr.forEach((cr, ur, fr, dr) => ar.push(fr, dr)), ar;
}
function mapRanges(lr, ar) {
  if (!lr)
    return null;
  let cr = [];
  for (let ur = 0; ur < lr.length; ur += 2) {
    let fr = ar.map(lr[ur], 1), dr = ar.map(lr[ur + 1], -1);
    fr <= dr && cr.push(fr, dr);
  }
  return cr;
}
function histTransaction(lr, ar, cr, ur) {
  let fr = mustPreserveItems(ar), dr = historyKey.get(ar).spec.config, hr = (ur ? lr.undone : lr.done).popEvent(ar, fr);
  if (!hr)
    return;
  let gr = hr.selection.resolve(hr.transform.doc), vr = (ur ? lr.done : lr.undone).addTransform(hr.transform, ar.selection.getBookmark(), dr, fr), mr = new HistoryState(ur ? vr : hr.remaining, ur ? hr.remaining : vr, null, 0, -1);
  cr(hr.transform.setSelection(gr).setMeta(historyKey, { redo: ur, historyState: mr }).scrollIntoView());
}
let cachedPreserveItems = !1, cachedPreserveItemsPlugins = null;
function mustPreserveItems(lr) {
  let ar = lr.plugins;
  if (cachedPreserveItemsPlugins != ar) {
    cachedPreserveItems = !1, cachedPreserveItemsPlugins = ar;
    for (let cr = 0; cr < ar.length; cr++)
      if (ar[cr].spec.historyPreserveItems) {
        cachedPreserveItems = !0;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new distExports$3.PluginKey("history"), closeHistoryKey = new distExports$3.PluginKey("closeHistory");
function history(lr = {}) {
  return lr = {
    depth: lr.depth || 100,
    newGroupDelay: lr.newGroupDelay || 500
  }, new distExports$3.Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(ar, cr, ur) {
        return applyTransaction(cr, ur, ar, lr);
      }
    },
    config: lr,
    props: {
      handleDOMEvents: {
        beforeinput(ar, cr) {
          let ur = cr.inputType, fr = ur == "historyUndo" ? undo : ur == "historyRedo" ? redo : null;
          return fr ? (cr.preventDefault(), fr(ar.state, ar.dispatch)) : !1;
        }
      }
    }
  });
}
const undo = (lr, ar) => {
  let cr = historyKey.getState(lr);
  return !cr || cr.done.eventCount == 0 ? !1 : (ar && histTransaction(cr, lr, ar, !1), !0);
}, redo = (lr, ar) => {
  let cr = historyKey.getState(lr);
  return !cr || cr.undone.eventCount == 0 ? !1 : (ar && histTransaction(cr, lr, ar, !0), !0);
};
function undoDepth(lr) {
  let ar = historyKey.getState(lr);
  return ar ? ar.done.eventCount : 0;
}
/**
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(lr, ar) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(cr, ur) {
    cr.__proto__ = ur;
  } || function(cr, ur) {
    for (var fr in ur)
      Object.prototype.hasOwnProperty.call(ur, fr) && (cr[fr] = ur[fr]);
  }, extendStatics$1(lr, ar);
};
function __extends$1(lr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics$1(lr, ar);
  function cr() {
    this.constructor = lr;
  }
  lr.prototype = ar === null ? Object.create(ar) : (cr.prototype = ar.prototype, new cr());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(ar) {
    for (var cr, ur = 1, fr = arguments.length; ur < fr; ur++) {
      cr = arguments[ur];
      for (var dr in cr)
        Object.prototype.hasOwnProperty.call(cr, dr) && (ar[dr] = cr[dr]);
    }
    return ar;
  }, __assign$1.apply(this, arguments);
};
function __spreadArray$1(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
}
function __makeTemplateObject(lr, ar) {
  return Object.defineProperty ? Object.defineProperty(lr, "raw", { value: ar }) : lr.raw = ar, lr;
}
function forEachOwnProperties$2(lr, ar, cr) {
  var ur;
  cr = cr || null;
  for (ur in lr)
    if (lr.hasOwnProperty(ur) && ar.call(cr, lr[ur], ur, lr) === !1)
      break;
}
var forEachOwnProperties_1 = forEachOwnProperties$2;
function extend(lr, ar) {
  var cr = Object.prototype.hasOwnProperty, ur, fr, dr, hr;
  for (dr = 1, hr = arguments.length; dr < hr; dr += 1) {
    ur = arguments[dr];
    for (fr in ur)
      cr.call(ur, fr) && (lr[fr] = ur[fr]);
  }
  return lr;
}
var extend_1 = extend;
function isString$3(lr) {
  return typeof lr == "string" || lr instanceof String;
}
var isString_1 = isString$3;
function isArray$3(lr) {
  return lr instanceof Array;
}
var isArray_1 = isArray$3;
function forEachArray$3(lr, ar, cr) {
  var ur = 0, fr = lr.length;
  for (cr = cr || null; ur < fr && ar.call(cr, lr[ur], ur, lr) !== !1; ur += 1)
    ;
}
var forEachArray_1 = forEachArray$3, isArray$2 = isArray_1, forEachArray$2 = forEachArray_1, forEachOwnProperties$1 = forEachOwnProperties_1;
function forEach$4(lr, ar, cr) {
  isArray$2(lr) ? forEachArray$2(lr, ar, cr) : forEachOwnProperties$1(lr, ar, cr);
}
var forEach_1 = forEach$4, isString$2 = isString_1, forEach$3 = forEach_1;
function css$2(lr, ar, cr) {
  var ur = lr.style;
  if (isString$2(ar)) {
    ur[ar] = cr;
    return;
  }
  forEach$3(ar, function(fr, dr) {
    ur[dr] = fr;
  });
}
var css_1 = css$2, isArray$1 = isArray_1;
function inArray$4(lr, ar, cr) {
  var ur, fr;
  if (cr = cr || 0, !isArray$1(ar))
    return -1;
  if (Array.prototype.indexOf)
    return Array.prototype.indexOf.call(ar, lr, cr);
  for (fr = ar.length, ur = cr; cr >= 0 && ur < fr; ur += 1)
    if (ar[ur] === lr)
      return ur;
  return -1;
}
var inArray_1 = inArray$4;
function isUndefined$4(lr) {
  return lr === void 0;
}
var isUndefined_1 = isUndefined$4, isUndefined$3 = isUndefined_1;
function getClass$3(lr) {
  return !lr || !lr.className ? "" : isUndefined$3(lr.className.baseVal) ? lr.className : lr.className.baseVal;
}
var getClass_1 = getClass$3, isArray = isArray_1, isUndefined$2 = isUndefined_1;
function setClassName$2(lr, ar) {
  if (ar = isArray(ar) ? ar.join(" ") : ar, ar = ar.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), isUndefined$2(lr.className.baseVal)) {
    lr.className = ar;
    return;
  }
  lr.className.baseVal = ar;
}
var _setClassName = setClassName$2, forEach$2 = forEach_1, inArray$3 = inArray_1, getClass$2 = getClass_1, setClassName$1 = _setClassName;
function addClass(lr) {
  var ar = Array.prototype.slice.call(arguments, 1), cr = lr.classList, ur = [], fr;
  if (cr) {
    forEach$2(ar, function(dr) {
      lr.classList.add(dr);
    });
    return;
  }
  fr = getClass$2(lr), fr && (ar = [].concat(fr.split(/\s+/), ar)), forEach$2(ar, function(dr) {
    inArray$3(dr, ur) < 0 && ur.push(dr);
  }), setClassName$1(lr, ur);
}
var addClass_1 = addClass, forEachArray$1 = forEachArray_1, inArray$2 = inArray_1, getClass$1 = getClass_1, setClassName = _setClassName;
function removeClass(lr) {
  var ar = Array.prototype.slice.call(arguments, 1), cr = lr.classList, ur, fr;
  if (cr) {
    forEachArray$1(ar, function(dr) {
      cr.remove(dr);
    });
    return;
  }
  ur = getClass$1(lr).split(/\s+/), fr = [], forEachArray$1(ur, function(dr) {
    inArray$2(dr, ar) < 0 && fr.push(dr);
  }), setClassName(lr, fr);
}
var removeClass_1 = removeClass;
function isNumber(lr) {
  return typeof lr == "number" || lr instanceof Number;
}
var isNumber_1 = isNumber;
function isNull$1(lr) {
  return lr === null;
}
var isNull_1 = isNull$1, forEachOwnProperties = forEachOwnProperties_1;
function imagePing$1(lr, ar) {
  var cr = document.createElement("img"), ur = "";
  return forEachOwnProperties(ar, function(fr, dr) {
    ur += "&" + dr + "=" + fr;
  }), ur = ur.substring(1), cr.src = lr + "?" + ur, cr.style.display = "none", document.body.appendChild(cr), document.body.removeChild(cr), cr;
}
var imagePing_1 = imagePing$1, isUndefined$1 = isUndefined_1, imagePing = imagePing_1, ms7days = 7 * 24 * 60 * 60 * 1e3;
function isExpired(lr) {
  var ar = (/* @__PURE__ */ new Date()).getTime();
  return ar - lr > ms7days;
}
function sendHostname(lr, ar) {
  var cr = "https://www.google-analytics.com/collect", ur = location.hostname, fr = "event", dr = "use", hr = "TOAST UI " + lr + " for " + ur + ": Statistics", gr = window.localStorage.getItem(hr);
  !isUndefined$1(window.tui) && window.tui.usageStatistics === !1 || gr && !isExpired(gr) || (window.localStorage.setItem(hr, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
    (document.readyState === "interactive" || document.readyState === "complete") && imagePing(cr, {
      v: 1,
      t: fr,
      tid: ar,
      cid: ur,
      dp: ur,
      dh: lr,
      el: lr,
      ec: dr
    });
  }, 1e3));
}
var sendHostname_1 = sendHostname, reSpaceMoreThanOne = /[\u0020]+/g, reEscapeChars$1 = /[>(){}[\]+-.!#|]/g, reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g, reEscapeBackSlash = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g, reEscapePairedChars = /[*_~`]/g, reMdImageSyntax = /!\[.*\]\(.*\)/g, reEscapedCharInLinkSyntax = /[[\]]/g, reEscapeBackSlashInSentence = /(?:^|[^\\])\\(?!\\)/g, XMLSPECIAL$1 = '[&<>"]', reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, "g");
function replaceUnsafeChar$1(lr) {
  switch (lr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return lr;
  }
}
function escapeXml$1(lr) {
  return reXmlSpecial$1.test(lr) ? lr.replace(reXmlSpecial$1, replaceUnsafeChar$1) : lr;
}
function sendHostName() {
  sendHostname_1("editor", "UA-129966929-1");
}
function includes(lr, ar) {
  return lr.indexOf(ar) !== -1;
}
var availableLinkAttributes = ["rel", "target", "hreflang", "type"], reMarkdownTextToEscapeMap = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function sanitizeLinkAttribute(lr) {
  if (!lr)
    return null;
  var ar = {};
  return availableLinkAttributes.forEach(function(cr) {
    isUndefined_1(lr[cr]) || (ar[cr] = lr[cr]);
  }), ar;
}
function repeat$1(lr, ar) {
  for (var cr = "", ur = 0; ur < ar; ur += 1)
    cr += lr;
  return cr;
}
function isNeedEscapeText(lr) {
  var ar = !1;
  return forEachOwnProperties_1(reMarkdownTextToEscapeMap, function(cr) {
    return cr.test(lr) && (ar = !0), !ar;
  }), ar;
}
function escapeTextForLink(lr) {
  for (var ar = [], cr = reMdImageSyntax.exec(lr); cr; )
    ar.push([cr.index, cr.index + cr[0].length]), cr = reMdImageSyntax.exec(lr);
  return lr.replace(reEscapedCharInLinkSyntax, function(ur, fr) {
    var dr = ar.some(function(hr) {
      return fr > hr[0] && fr < hr[1];
    });
    return dr ? ur : "\\" + ur;
  });
}
function escape$1(lr) {
  var ar = function(fr) {
    return "\\" + fr;
  }, cr = function(fr) {
    return fr + "\\";
  }, ur = lr.replace(reSpaceMoreThanOne, " ");
  return reEscapeBackSlash.test(ur) && (ur = ur.replace(reEscapeBackSlash, ar)), reEscapeBackSlashInSentence.test(ur) && (ur = ur.replace(reEscapeBackSlashInSentence, cr)), ur = ur.replace(reEscapePairedChars, ar), reEscapeHTML.test(ur) && (ur = ur.replace(reEscapeHTML, ar)), isNeedEscapeText(ur) && (ur = ur.replace(reEscapeChars$1, ar)), ur;
}
function quote(lr) {
  var ar;
  return lr.indexOf('"') === -1 ? ar = '""' : ar = lr.indexOf("'") === -1 ? "''" : "()", ar[0] + lr + ar[1];
}
function isNil(lr) {
  return isNull_1(lr) || isUndefined_1(lr);
}
function shallowEqual(lr, ar) {
  if (lr === null && lr === ar)
    return !0;
  if (typeof lr != "object" || typeof ar != "object" || isNil(lr) || isNil(ar))
    return lr === ar;
  for (var cr in lr)
    if (lr[cr] !== ar[cr])
      return !1;
  for (var cr in ar)
    if (!(cr in lr))
      return !1;
  return !0;
}
function last$1(lr) {
  return lr[lr.length - 1];
}
function between$1(lr, ar, cr) {
  return lr >= ar && lr <= cr;
}
function isObject$1(lr) {
  return typeof lr == "object" && lr !== null;
}
function deepMergedCopy(lr, ar) {
  var cr = __assign$1({}, lr);
  return lr && ar && Object.keys(ar).forEach(function(ur) {
    isObject$1(cr[ur]) ? Array.isArray(ar[ur]) ? cr[ur] = deepCopyArray(ar[ur]) : cr.hasOwnProperty(ur) ? cr[ur] = deepMergedCopy(cr[ur], ar[ur]) : cr[ur] = deepCopy(ar[ur]) : cr[ur] = ar[ur];
  }), cr;
}
function deepCopyArray(lr) {
  return lr.map(function(ar) {
    return isObject$1(ar) ? Array.isArray(ar) ? deepCopyArray(ar) : deepCopy(ar) : ar;
  });
}
function deepCopy(lr) {
  var ar = Object.keys(lr);
  return ar.length ? ar.reduce(function(cr, ur) {
    return isObject$1(lr[ur]) ? cr[ur] = Array.isArray(lr[ur]) ? deepCopyArray(lr[ur]) : deepCopy(lr[ur]) : cr[ur] = lr[ur], cr;
  }, {}) : lr;
}
function assign(lr, ar) {
  return ar === void 0 && (ar = {}), Object.keys(ar).forEach(function(cr) {
    lr.hasOwnProperty(cr) && typeof lr[cr] == "object" ? Array.isArray(ar[cr]) ? lr[cr] = ar[cr] : assign(lr[cr], ar[cr]) : lr[cr] = ar[cr];
  }), lr;
}
function getSortedNumPair(lr, ar) {
  return lr > ar ? [ar, lr] : [lr, ar];
}
var forEachArray = forEachArray_1;
function toArray$1(lr) {
  var ar;
  try {
    ar = Array.prototype.slice.call(lr);
  } catch (cr) {
    ar = [], forEachArray(lr, function(ur) {
      ar.push(ur);
    });
  }
  return ar;
}
var toArray_1 = toArray$1;
function createParagraph(lr, ar) {
  var cr = lr.nodes.paragraph;
  return ar ? cr.create(null, isString_1(ar) ? lr.text(ar) : ar) : cr.createAndFill();
}
function createTextNode$1(lr, ar, cr) {
  return lr.text(ar, cr);
}
function createTextSelection(lr, ar, cr) {
  cr === void 0 && (cr = ar);
  var ur = lr.doc.content.size, fr = ur > 0 ? ur - 1 : 1;
  return distExports$3.TextSelection.create(lr.doc, Math.min(ar, fr), Math.min(cr, fr));
}
function addParagraph(lr, ar, cr) {
  var ur = ar.pos;
  return lr.replaceWith(ur, ur, createParagraph(cr)), lr.setSelection(createTextSelection(lr, ur + 1));
}
function replaceTextNode(lr) {
  for (var ar = lr.state, cr = lr.from, ur = lr.startIndex, fr = lr.endIndex, dr = lr.createText, hr = ar.tr, gr = ar.doc, vr = ar.schema, mr = ur; mr <= fr; mr += 1) {
    var br = gr.child(mr), yr = br.nodeSize, kr = br.textContent, Tr = br.content, _r = dr(kr), Er = _r ? createTextNode$1(vr, _r) : distExports$5.Fragment.empty, xr = hr.mapping.map(cr), Cr = xr + Tr.size;
    hr.replaceWith(xr, Cr, Er), cr += yr;
  }
  return hr;
}
function splitAndExtendBlock(lr, ar, cr, ur) {
  var fr = cr.length;
  lr.split(ar).delete(ar - fr, ar).insert(lr.mapping.map(ar), ur).setSelection(createTextSelection(lr, lr.mapping.map(ar) - fr));
}
function getMdStartLine(lr) {
  return lr.sourcepos[0][0];
}
function getMdEndLine(lr) {
  return lr.sourcepos[1][0];
}
function getMdStartCh(lr) {
  return lr.sourcepos[0][1];
}
function getMdEndCh(lr) {
  return lr.sourcepos[1][1];
}
function isHTMLNode(lr) {
  var ar = lr.type;
  return ar === "htmlBlock" || ar === "htmlInline";
}
function isStyledInlineNode(lr) {
  var ar = lr.type;
  return ar === "strike" || ar === "strong" || ar === "emph" || ar === "code" || ar === "link" || ar === "image";
}
function isCodeBlockNode(lr) {
  return lr && lr.type === "codeBlock";
}
function isListNode$1(lr) {
  return lr && (lr.type === "item" || lr.type === "list");
}
function isOrderedListNode(lr) {
  return isListNode$1(lr) && lr.listData.type === "ordered";
}
function isBulletListNode(lr) {
  return isListNode$1(lr) && lr.listData.type !== "ordered";
}
function isTableCellNode(lr) {
  return lr && (lr.type === "tableCell" || lr.type === "tableDelimCell");
}
function isInlineNode$1(lr) {
  switch (lr.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function findClosestNode(lr, ar, cr) {
  for (cr === void 0 && (cr = !0), lr = cr ? lr : lr.parent; lr && lr.type !== "document"; ) {
    if (ar(lr))
      return lr;
    lr = lr.parent;
  }
  return null;
}
function traverseParentNodes(lr, ar, cr) {
  for (cr === void 0 && (cr = !0), lr = cr ? lr : lr.parent; lr && lr.type !== "document"; )
    ar(lr), lr = lr.parent;
}
function addOffsetPos(lr, ar) {
  return [lr[0], lr[1] + ar];
}
function setOffsetPos(lr, ar) {
  return [lr[0], ar];
}
function getInlineMarkdownText(lr) {
  var ar = lr.firstChild.literal;
  switch (lr.type) {
    case "emph":
      return "*" + ar + "*";
    case "strong":
      return "**" + ar + "**";
    case "strike":
      return "~~" + ar + "~~";
    case "code":
      return "`" + ar + "`";
    case "link":
    case "image":
      var cr = lr, ur = cr.destination, fr = cr.title, dr = lr.type === "link" ? "" : "!";
      return dr + "[" + ar + "](" + ur + (fr ? ' "' + fr + '"' : "") + ")";
    default:
      return null;
  }
}
function isContainer$2(lr) {
  switch (lr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function getChildrenText$1(lr) {
  for (var ar = [], cr = lr.walker(), ur = null; ur = cr.next(); ) {
    var fr = ur.node;
    fr.type === "text" && ar.push(fr.literal);
  }
  return ar.join("");
}
var widgetRules = [], widgetRuleMap = {}, reWidgetPrefix = /\$\$widget\d+\s/;
function unwrapWidgetSyntax(lr) {
  var ar = lr.search(reWidgetPrefix);
  if (ar !== -1) {
    var cr = lr.substring(ar), ur = cr.replace(reWidgetPrefix, "").replace("$$", "");
    lr = lr.substring(0, ar), lr += unwrapWidgetSyntax(ur);
  }
  return lr;
}
function createWidgetContent(lr, ar) {
  return "$$" + lr + " " + ar + "$$";
}
function widgetToDOM(lr, ar) {
  var cr = widgetRuleMap[lr], ur = cr.rule, fr = cr.toDOM, dr = unwrapWidgetSyntax(ar).match(ur);
  return dr && (ar = dr[0]), fr(ar);
}
function getWidgetRules() {
  return widgetRules;
}
function setWidgetRules(lr) {
  widgetRules = lr, widgetRules.forEach(function(ar, cr) {
    widgetRuleMap["widget" + cr] = ar;
  });
}
function mergeNodes(lr, ar, cr, ur) {
  return lr.concat(createNodesWithWidget(ar, cr, ur));
}
function createNodesWithWidget(lr, ar, cr) {
  cr === void 0 && (cr = 0);
  var ur = [], fr = (widgetRules[cr] || {}).rule, dr = cr + 1;
  if (lr = unwrapWidgetSyntax(lr), fr && fr.test(lr)) {
    for (var hr = void 0; (hr = lr.search(fr)) !== -1; ) {
      var gr = lr.substring(0, hr);
      gr && (ur = mergeNodes(ur, gr, ar, dr)), lr = lr.substring(hr);
      var vr = lr.match(fr)[0], mr = "widget" + cr;
      ur.push(ar.nodes.widget.create({ info: mr }, ar.text(createWidgetContent(mr, vr)))), lr = lr.substring(vr.length);
    }
    lr && (ur = mergeNodes(ur, lr, ar, dr));
  } else
    lr && (ur = cr < widgetRules.length - 1 ? mergeNodes(ur, lr, ar, dr) : [ar.text(lr)]);
  return ur;
}
function getWidgetContent(lr) {
  for (var ar, cr = "", ur = lr.walker(); ar = ur.next(); ) {
    var fr = ar.node, dr = ar.entering;
    dr && (fr !== lr && fr.type !== "text" ? (cr += getInlineMarkdownText(fr), ur.resumeAt(lr, !1), ur.next()) : fr.type === "text" && (cr += fr.literal));
  }
  return cr;
}
function getDefaultCommands() {
  return {
    deleteSelection: function() {
      return deleteSelection;
    },
    selectAll: function() {
      return selectAll;
    },
    undo: function() {
      return undo;
    },
    redo: function() {
      return redo;
    }
  };
}
function placeholder(lr) {
  return new distExports$3.Plugin({
    props: {
      decorations: function(ar) {
        var cr = ar.doc;
        if (lr.text && cr.childCount === 1 && cr.firstChild.isTextblock && cr.firstChild.content.size === 0) {
          var ur = document.createElement("span");
          return addClass_1(ur, "placeholder"), lr.className && addClass_1(ur, lr.className), ur.textContent = lr.text, distExports$4.DecorationSet.create(cr, [distExports$4.Decoration.widget(1, ur)]);
        }
        return null;
      }
    }
  });
}
var inArray$1 = inArray_1, getClass = getClass_1;
function hasClass(lr, ar) {
  var cr;
  return lr.classList ? lr.classList.contains(ar) : (cr = getClass(lr).split(/\s+/), inArray$1(ar, cr) > -1);
}
var hasClass_1 = hasClass, inArray = inArray_1, toArray = toArray_1, elProto = Element.prototype, matchSelector = elProto.matches || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || function(lr) {
  var ar = this.document || this.ownerDocument;
  return inArray(this, toArray(ar.querySelectorAll(lr))) > -1;
};
function matches(lr, ar) {
  return matchSelector.call(lr, ar);
}
var matches_1 = matches, TAG_NAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTE_NAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTED_VALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLE_QUOTED_VALUE = "'[^']*'", DOUBLE_QUOTED_VALUE = '"[^"]*"', ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")", ATTRIBUTE_VALUE_SPEC = "(?:\\s*=\\s*" + ATTRIBUTE_VALUE + ")", ATTRIBUTE$1 = "(?:\\s+" + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)", OPEN_TAG = "<(" + TAG_NAME + ")(" + ATTRIBUTE$1 + ")*\\s*/?>", CLOSE_TAG = "</(" + TAG_NAME + ")\\s*[>]", HTML_TAG = "(?:" + OPEN_TAG + "|" + CLOSE_TAG + ")", reHTMLTag = new RegExp("^" + HTML_TAG, "i"), reBR = /<br\s*\/*>/i, reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/, ALTERNATIVE_TAG_FOR_BR = "</p><p>";
function isPositionInBox(lr, ar, cr) {
  var ur = parseInt(lr.left, 10), fr = parseInt(lr.top, 10), dr = parseInt(lr.width, 10) + parseInt(lr.paddingLeft, 10) + parseInt(lr.paddingRight, 10), hr = parseInt(lr.height, 10) + parseInt(lr.paddingTop, 10) + parseInt(lr.paddingBottom, 10);
  return ar >= ur && ar <= ur + dr && cr >= fr && cr <= fr + hr;
}
var CLS_PREFIX = "toastui-editor-";
function cls() {
  for (var lr = [], ar = 0; ar < arguments.length; ar++)
    lr[ar] = arguments[ar];
  for (var cr = [], ur = 0, fr = lr; ur < fr.length; ur++) {
    var dr = fr[ur], hr = void 0;
    Array.isArray(dr) ? hr = dr[0] ? dr[1] : null : hr = dr, hr && cr.push("" + CLS_PREFIX + hr);
  }
  return cr.join(" ");
}
function clsWithMdPrefix() {
  for (var lr = [], ar = 0; ar < arguments.length; ar++)
    lr[ar] = arguments[ar];
  return lr.map(function(cr) {
    return CLS_PREFIX + "md-" + cr;
  }).join(" ");
}
function isTextNode(lr) {
  return (lr == null ? void 0 : lr.nodeType) === Node.TEXT_NODE;
}
function isElemNode(lr) {
  return lr && lr.nodeType === Node.ELEMENT_NODE;
}
function findNodes(lr, ar) {
  var cr = toArray_1(lr.querySelectorAll(ar));
  return cr.length ? cr : [];
}
function appendNodes(lr, ar) {
  ar = isArray_1(ar) ? toArray_1(ar) : [ar], ar.forEach(function(cr) {
    lr.appendChild(cr);
  });
}
function insertBeforeNode(lr, ar) {
  ar.parentNode && ar.parentNode.insertBefore(lr, ar);
}
function removeNode$1(lr) {
  lr.parentNode && lr.parentNode.removeChild(lr);
}
function unwrapNode(lr) {
  for (var ar = []; lr.firstChild; )
    ar.push(lr.firstChild), lr.parentNode && lr.parentNode.insertBefore(lr.firstChild, lr);
  return removeNode$1(lr), ar;
}
function toggleClass(lr, ar, cr) {
  isUndefined_1(cr) && (cr = !hasClass_1(lr, ar));
  var ur = cr ? addClass_1 : removeClass_1;
  ur(lr, ar);
}
function createElementWith(lr, ar) {
  var cr = document.createElement("div");
  isString_1(lr) ? cr.innerHTML = lr : cr.appendChild(lr);
  var ur = cr.firstChild;
  return ar && ar.appendChild(ur), ur;
}
function getOuterWidth(lr) {
  var ar = window.getComputedStyle(lr);
  return ["margin-left", "margin-right"].reduce(function(cr, ur) {
    return cr + parseInt(ar.getPropertyValue(ur), 10);
  }, 0) + lr.offsetWidth;
}
function closest(lr, ar) {
  var cr;
  for (isString_1(ar) ? cr = function(ur) {
    return matches_1(ur, ar);
  } : cr = function(ur) {
    return ur === ar;
  }; lr && lr !== document; ) {
    if (isElemNode(lr) && cr(lr))
      return lr;
    lr = lr.parentNode;
  }
  return null;
}
function getTotalOffset(lr, ar) {
  for (var cr = 0, ur = 0; lr && lr !== ar; ) {
    var fr = lr.offsetTop, dr = lr.offsetLeft, hr = lr.offsetParent;
    if (cr += fr, ur += dr, hr === ar.offsetParent)
      break;
    lr = lr.offsetParent;
  }
  return { offsetTop: cr, offsetLeft: ur };
}
function setAttributes(lr, ar) {
  Object.keys(lr).forEach(function(cr) {
    isNil(lr[cr]) ? ar.removeAttribute(cr) : ar.setAttribute(cr, lr[cr]);
  });
}
function replaceBRWithEmptyBlock(lr) {
  var ar = lr.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"), cr = new RegExp(HTML_TAG, "ig"), ur = ar.match(cr);
  return ur == null || ur.forEach(function(fr, dr) {
    if (reBR.test(fr)) {
      var hr = ALTERNATIVE_TAG_FOR_BR;
      if (dr) {
        var gr = ur[dr - 1], vr = gr.match(OPEN_TAG);
        if (vr && !/br/i.test(vr[1])) {
          var mr = vr[1];
          hr = "</" + mr + "><" + mr + ">";
        }
      }
      ar = ar.replace(reBR, hr);
    }
  }), ar;
}
function removeProseMirrorHackNodes(lr) {
  var ar = /<img class="ProseMirror-separator" alt="">/g, cr = / class="ProseMirror-trailingBreak"/g, ur = lr;
  return ur = ur.replace(ar, ""), ur = ur.replace(cr, ""), ur;
}
var pluginKey$1 = new distExports$3.PluginKey("widget"), MARGIN = 5, PopupWidget = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = this;
      this.popup = null, this.removeWidget = function() {
        ur.popup && (ur.rootEl.removeChild(ur.popup), ur.popup = null);
      }, this.rootEl = ar.dom.parentElement, this.eventEmitter = cr, this.eventEmitter.listen("blur", this.removeWidget), this.eventEmitter.listen("loadUI", function() {
        ur.rootEl = closest(ar.dom.parentElement, "." + cls("defaultUI"));
      }), this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    return lr.prototype.update = function(ar) {
      var cr = pluginKey$1.getState(ar.state);
      if (this.removeWidget(), cr) {
        var ur = cr.node, fr = cr.style, dr = ar.coordsAtPos(cr.pos), hr = dr.top, gr = dr.left, vr = dr.bottom, mr = vr - hr, br = this.rootEl.getBoundingClientRect(), yr = hr - br.top;
        css_1(ur, { opacity: "0" }), this.rootEl.appendChild(ur), css_1(ur, {
          position: "absolute",
          left: gr - br.left + MARGIN + "px",
          top: (fr === "bottom" ? yr + mr - MARGIN : yr - mr) + "px",
          opacity: "1"
        }), this.popup = ur, ar.focus();
      }
    }, lr.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    }, lr;
  }()
);
function addWidget(lr) {
  return new distExports$3.Plugin({
    key: pluginKey$1,
    state: {
      init: function() {
        return null;
      },
      apply: function(ar) {
        return ar.getMeta("widget");
      }
    },
    view: function(ar) {
      return new PopupWidget(ar, lr);
    }
  });
}
function addDefaultImageBlobHook(lr) {
  lr.listen("addImageBlobHook", function(ar, cr) {
    var ur = new FileReader();
    ur.onload = function(fr) {
      var dr = fr.target;
      return cr(dr.result);
    }, ur.readAsDataURL(ar);
  });
}
function emitImageBlobHook(lr, ar, cr) {
  var ur = function(fr, dr) {
    lr.emit("command", "addImage", {
      imageUrl: fr,
      altText: dr || ar.name || "image"
    });
  };
  lr.emit("addImageBlobHook", ar, ur, cr);
}
function pasteImageOnly(lr) {
  var ar = toArray_1(lr).filter(function(ur) {
    var fr = ur.type;
    return fr.indexOf("image") !== -1;
  });
  if (ar.length === 1) {
    var cr = ar[0];
    if (cr)
      return cr.getAsFile();
  }
  return null;
}
function dropImage(lr) {
  var ar = lr.eventEmitter;
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        drop: function(cr, ur) {
          var fr, dr = (fr = ur.dataTransfer) === null || fr === void 0 ? void 0 : fr.files;
          return dr && forEachArray_1(dr, function(hr) {
            return hr.type.indexOf("image") !== -1 ? (ur.preventDefault(), ur.stopPropagation(), emitImageBlobHook(ar, hr, ur.type), !1) : !0;
          }), !0;
        }
      }
    }
  });
}
var Node$2 = (
  /** @class */
  function() {
    function lr() {
    }
    return Object.defineProperty(lr.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.setContext = function(ar) {
      this.context = ar;
    }, lr;
  }()
);
function widgetNodeView(lr) {
  var ar = document.createElement("span"), cr = widgetToDOM(lr.attrs.info, lr.textContent);
  return ar.className = "tui-widget", ar.appendChild(cr), { dom: ar };
}
function isWidgetNode(lr) {
  return lr.type.name === "widget";
}
var Widget = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: !0,
          content: "text*",
          selectable: !1,
          atom: !0,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(cr) {
                var ur = cr.textContent, fr = ur.match(/\$\$(widget\d+)/), dr = fr[1];
                return { info: dr };
              }
            }
          ]
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), EditorBase = (
  /** @class */
  function() {
    function lr(ar) {
      this.timer = null, this.el = document.createElement("div"), this.el.className = "toastui-editor", this.eventEmitter = ar, this.placeholder = { text: "" };
    }
    return lr.prototype.createState = function() {
      return distExports$3.EditorState.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    }, lr.prototype.initEvent = function() {
      var ar = this, cr = ar.eventEmitter, ur = ar.view, fr = ar.editorType;
      ur.dom.addEventListener("focus", function() {
        return cr.emit("focus", fr);
      }), ur.dom.addEventListener("blur", function() {
        return cr.emit("blur", fr);
      });
    }, lr.prototype.emitChangeEvent = function(ar) {
      this.eventEmitter.emit("caretChange", this.editorType), ar.docChanged && this.eventEmitter.emit("change", this.editorType);
    }, Object.defineProperty(lr.prototype, "defaultPlugins", {
      get: function() {
        var ar = this.createInputRules(), cr = __spreadArray$1(__spreadArray$1([], this.keymaps), [
          distExports$2.keymap(__assign$1({ "Shift-Enter": baseKeymap.Enter }, baseKeymap)),
          history(),
          placeholder(this.placeholder),
          addWidget(this.eventEmitter),
          dropImage(this.context)
        ]);
        return ar ? cr.concat(ar) : cr;
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.createInputRules = function() {
      var ar = getWidgetRules(), cr = ar.map(function(ur) {
        var fr = ur.rule;
        return new distExports$1.InputRule(fr, function(dr, hr, gr, vr) {
          var mr = dr.schema, br = dr.tr, yr = dr.doc, kr = hr.input.match(new RegExp(fr, "g")), Tr = yr.resolve(gr), _r = Tr.parent, Er = 0;
          if (isWidgetNode(_r) && (_r = Tr.node(Tr.depth - 1)), _r.forEach(function(Ar) {
            return isWidgetNode(Ar) && (Er += 1);
          }), kr.length > Er) {
            var xr = last$1(kr), Cr = createNodesWithWidget(xr, mr);
            return br.replaceWith(vr - xr.length + 1, vr, Cr);
          }
          return null;
        });
      });
      return cr.length ? distExports$1.inputRules({ rules: cr }) : null;
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.createSchema = function() {
      return new distExports$5.Schema({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    }, lr.prototype.createKeymaps = function(ar) {
      var cr = getDefaultCommands(), ur = cr.undo, fr = cr.redo, dr = this.specs.keymaps(ar), hr = {
        "Mod-z": ur(),
        "Shift-Mod-z": fr()
      };
      return ar ? dr.concat(distExports$2.keymap(hr)) : dr;
    }, lr.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, lr.prototype.createPluginProps = function() {
      var ar = this;
      return this.extraPlugins.map(function(cr) {
        return cr(ar.eventEmitter);
      });
    }, lr.prototype.focus = function() {
      var ar = this;
      this.clearTimer(), this.timer = setTimeout(function() {
        ar.view.focus(), ar.view.dispatch(ar.view.state.tr.scrollIntoView());
      });
    }, lr.prototype.blur = function() {
      this.view.dom.blur();
    }, lr.prototype.destroy = function() {
      var ar = this;
      this.clearTimer(), this.view.destroy(), Object.keys(this).forEach(function(cr) {
        delete ar[cr];
      });
    }, lr.prototype.moveCursorToStart = function(ar) {
      var cr = this.view.state.tr;
      this.view.dispatch(cr.setSelection(createTextSelection(cr, 1)).scrollIntoView()), ar && this.focus();
    }, lr.prototype.moveCursorToEnd = function(ar) {
      var cr = this.view.state.tr;
      this.view.dispatch(cr.setSelection(createTextSelection(cr, cr.doc.content.size - 1)).scrollIntoView()), ar && this.focus();
    }, lr.prototype.setScrollTop = function(ar) {
      this.view.dom.scrollTop = ar;
    }, lr.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    }, lr.prototype.setPlaceholder = function(ar) {
      this.placeholder.text = ar, this.view.dispatch(this.view.state.tr.scrollIntoView());
    }, lr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, lr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, lr.prototype.getElement = function() {
      return this.el;
    }, lr;
  }()
);
function isFunction(lr) {
  return lr instanceof Function;
}
var isFunction_1 = isFunction, defaultCommandShortcuts = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function execCommand(lr, ar, cr) {
  return lr.focus(), ar(cr)(lr.state, lr.dispatch, lr);
}
var SpecManager = (
  /** @class */
  function() {
    function lr(ar) {
      this.specs = ar;
    }
    return Object.defineProperty(lr.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "node";
        }).reduce(function(ar, cr) {
          var ur, fr = cr.name, dr = cr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[fr] = dr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "mark";
        }).reduce(function(ar, cr) {
          var ur, fr = cr.name, dr = cr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[fr] = dr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.commands = function(ar, cr) {
      var ur = this.specs.filter(function(dr) {
        var hr = dr.commands;
        return hr;
      }).reduce(function(dr, hr) {
        var gr = {}, vr = hr.commands();
        return isFunction_1(vr) ? gr[hr.name] = function(mr) {
          return execCommand(ar, vr, mr);
        } : Object.keys(vr).forEach(function(mr) {
          gr[mr] = function(br) {
            return execCommand(ar, vr[mr], br);
          };
        }), __assign$1(__assign$1({}, dr), gr);
      }, {}), fr = getDefaultCommands();
      return Object.keys(fr).forEach(function(dr) {
        ur[dr] = function(hr) {
          return execCommand(ar, fr[dr], hr);
        };
      }), cr && Object.keys(cr).forEach(function(dr) {
        ur[dr] = function(hr) {
          return execCommand(ar, cr[dr], hr);
        };
      }), ur;
    }, lr.prototype.keymaps = function(ar) {
      var cr = this.specs.filter(function(ur) {
        return ur.keymaps;
      }).map(function(ur) {
        return ur.keymaps();
      });
      return cr.map(function(ur) {
        return ar || Object.keys(ur).forEach(function(fr) {
          includes(defaultCommandShortcuts, fr) || delete ur[fr];
        }), distExports$2.keymap(ur);
      });
    }, lr.prototype.setContext = function(ar) {
      this.specs.forEach(function(cr) {
        cr.setContext(ar);
      });
    }, lr;
  }()
);
function resolveSelectionPos(lr) {
  var ar = lr.from, cr = lr.to;
  return lr instanceof distExports$3.AllSelection ? [ar + 1, cr - 1] : [ar, cr];
}
function getMdLine(lr) {
  return lr.index(0) + 1;
}
function getWidgetNodePos(lr, ar, cr) {
  cr === void 0 && (cr = 1);
  var ur = 0;
  return lr.forEach(function(fr, dr) {
    isWidgetNode(fr) && dr + 2 < ar && (ur += 2 * cr);
  }), ur;
}
function getEditorToMdPos(lr, ar, cr) {
  cr === void 0 && (cr = ar);
  var ur = ar === cr, fr = lr.resolve(ar), dr = getMdLine(fr), hr = dr, gr = fr.start(1), vr = gr;
  if (!ur) {
    var mr = lr.resolve(cr === lr.content.size ? cr - 1 : cr);
    vr = mr.start(1), hr = getMdLine(mr), mr.pos === lr.content.size && (cr = lr.content.size - 2);
  }
  var br = Math.max(ar - gr + 1, 1), yr = Math.max(cr - vr + 1, 1);
  return [
    [dr, br + getWidgetNodePos(lr.child(dr - 1), br, -1)],
    [hr, yr + getWidgetNodePos(lr.child(hr - 1), yr, -1)]
  ];
}
function getStartPosListPerLine(lr, ar) {
  for (var cr = [], ur = 0, fr = 0; ur < ar; ur += 1) {
    var dr = lr.child(ur);
    cr[ur] = fr, fr += dr.nodeSize;
  }
  return cr;
}
function getMdToEditorPos(lr, ar, cr) {
  var ur = getStartPosListPerLine(lr, cr[0]), fr = ar[0] - 1, dr = cr[0] - 1, hr = lr.child(fr), gr = lr.child(dr), vr = ur[fr], mr = ur[dr];
  return vr += ar[1] + getWidgetNodePos(hr, ar[1] - 1), mr += cr[1] + getWidgetNodePos(gr, cr[1] - 1), [vr, Math.min(mr, lr.content.size)];
}
function getRangeInfo(lr) {
  var ar = lr.$from, cr = lr.$to, ur = lr.from, fr = lr.to, dr = ar.doc;
  return lr instanceof distExports$3.AllSelection && (ar = dr.resolve(ur + 1), cr = dr.resolve(fr - 1)), ar.depth === 0 && (ar = dr.resolve(ur - 1), cr = ar), {
    startFromOffset: ar.start(1),
    endFromOffset: cr.start(1),
    startToOffset: ar.end(1),
    endToOffset: cr.end(1),
    startIndex: ar.index(0),
    endIndex: cr.index(0),
    from: ar.pos,
    to: cr.pos
  };
}
function getNodeContentOffsetRange(lr, ar) {
  for (var cr = 1, ur = 1, fr = 0, dr = 0; fr < lr.childCount; fr += 1) {
    var hr = lr.child(fr).nodeSize;
    if (cr = dr + 1, ur = dr + hr - 1, fr === ar)
      break;
    dr += hr;
  }
  return { startOffset: cr, endOffset: ur };
}
var HEADING = "heading", BLOCK_QUOTE = "blockQuote", LIST_ITEM = "listItem", TABLE = "table", TABLE_CELL = "tableCell", CODE_BLOCK = "codeBlock", THEMATIC_BREAK = "thematicBreak", LINK = "link", CODE = "code", META = "meta", DELIM = "delimiter", TASK_DELIM = "taskDelimiter", TEXT = "markedText", HTML = "html", CUSTOM_BLOCK = "customBlock", delimSize = {
  strong: 2,
  emph: 1,
  strike: 2
};
function markInfo(lr, ar, cr, ur) {
  return { start: lr, end: ar, spec: { type: cr, attrs: ur } };
}
function heading$1(lr, ar, cr) {
  var ur = lr.level, fr = lr.headingType, dr = [markInfo(ar, cr, HEADING, { level: ur })];
  return fr === "atx" ? dr.push(markInfo(ar, addOffsetPos(ar, ur), DELIM)) : dr.push(markInfo(setOffsetPos(cr, 0), cr, HEADING, { seText: !0 })), dr;
}
function emphasisAndStrikethrough(lr, ar, cr) {
  var ur = lr.type, fr = addOffsetPos(ar, delimSize[ur]), dr = addOffsetPos(cr, -delimSize[ur]);
  return [
    markInfo(fr, dr, ur),
    markInfo(ar, fr, DELIM),
    markInfo(dr, cr, DELIM)
  ];
}
function markLink(lr, ar, cr, ur) {
  return [
    markInfo(lr, ar, LINK),
    markInfo(setOffsetPos(lr, cr[1] + 1), setOffsetPos(ar, ur), LINK, {
      desc: !0
    }),
    markInfo(setOffsetPos(ar, ur + 2), addOffsetPos(ar, -1), LINK, { url: !0 })
  ];
}
function image$1(lr, ar, cr) {
  var ur = lr.lastChild, fr = ur ? getMdEndCh(ur) + 1 : 3, dr = addOffsetPos(ar, 1);
  return __spreadArray$1([markInfo(ar, dr, META)], markLink(ar, cr, dr, fr));
}
function link(lr, ar, cr) {
  var ur = lr.lastChild, fr = lr.extendedAutolink, dr = ur ? getMdEndCh(ur) + 1 : 2;
  return fr ? [markInfo(ar, cr, LINK, { desc: !0 })] : markLink(ar, cr, ar, dr);
}
function code(lr, ar, cr) {
  var ur = lr.tickCount, fr = addOffsetPos(ar, ur), dr = addOffsetPos(cr, -ur);
  return [
    markInfo(ar, cr, CODE),
    markInfo(ar, fr, CODE, { start: !0 }),
    markInfo(fr, dr, CODE, { marked: !0 }),
    markInfo(dr, cr, CODE, { end: !0 })
  ];
}
function lineBackground(lr, ar, cr, ur) {
  var fr = {
    start: ar,
    end: cr,
    spec: {
      attrs: { className: ur + "-line-background", codeStart: ar[0], codeEnd: cr[0] }
    },
    lineBackground: !0
  };
  return lr.type !== "item" && lr.type !== "blockQuote" ? [
    __assign$1(__assign$1({}, fr), { end: ar, spec: { attrs: { className: ur + "-line-background start" } } }),
    __assign$1(__assign$1({}, fr), { start: [Math.min(ar[0] + 1, cr[0]), ar[1]] })
  ] : null;
}
function codeBlock$1(lr, ar, cr, ur) {
  var fr = lr.fenceOffset, dr = lr.fenceLength, hr = lr.fenceChar, gr = lr.info, vr = lr.infoPadding, mr = lr.parent, br = fr + dr, yr = [markInfo(setOffsetPos(ar, 1), cr, CODE_BLOCK)];
  hr && yr.push(markInfo(ar, addOffsetPos(ar, br), DELIM)), gr && yr.push(markInfo(addOffsetPos(ar, dr), addOffsetPos(ar, dr + vr + gr.length), META));
  var kr = "^(\\s{0,4})(" + hr + "{" + dr + ",})", Tr = new RegExp(kr);
  Tr.test(ur) && yr.push(markInfo(setOffsetPos(cr, 1), cr, DELIM));
  var _r = lineBackground(mr, ar, cr, "code-block");
  return _r ? yr.concat(_r) : yr;
}
function customBlock$2(lr, ar, cr) {
  var ur = lr, fr = ur.offset, dr = ur.syntaxLength, hr = ur.info, gr = ur.parent, vr = fr + dr, mr = [markInfo(setOffsetPos(ar, 1), cr, CUSTOM_BLOCK)];
  mr.push(markInfo(ar, addOffsetPos(ar, vr), DELIM)), hr && mr.push(markInfo(addOffsetPos(ar, vr), addOffsetPos(ar, dr + hr.length), META)), mr.push(markInfo(setOffsetPos(cr, 1), cr, DELIM));
  var br = lineBackground(gr, ar, cr, "custom-block");
  return br ? mr.concat(br) : mr;
}
function markListItemChildren(lr, ar) {
  for (var cr = []; lr; ) {
    var ur = lr.type;
    (ur === "paragraph" || ur === "codeBlock") && cr.push(markInfo([getMdStartLine(lr), getMdStartCh(lr) - 1], [getMdEndLine(lr), getMdEndCh(lr) + 1], ar)), lr = lr.next;
  }
  return cr;
}
function markParagraphInBlockQuote(lr) {
  for (var ar = []; lr; )
    ar.push(markInfo([getMdStartLine(lr), getMdStartCh(lr)], [getMdEndLine(lr), getMdEndCh(lr) + 1], TEXT)), lr = lr.next;
  return ar;
}
function blockQuote$2(lr, ar, cr) {
  var ur = lr.parent && lr.parent.type !== "blockQuote" ? [markInfo(ar, cr, BLOCK_QUOTE)] : [];
  if (lr.firstChild) {
    var fr = [];
    lr.firstChild.type === "paragraph" ? fr = markParagraphInBlockQuote(lr.firstChild.firstChild) : lr.firstChild.type === "list" && (fr = markListItemChildren(lr.firstChild, TEXT)), ur = __spreadArray$1(__spreadArray$1([], ur), fr);
  }
  return ur;
}
function getSpecOfListItemStyle(lr) {
  for (var ar = 0; lr.parent.parent && lr.parent.parent.type === "item"; )
    lr = lr.parent.parent, ar += 1;
  var cr = [{ odd: !0 }, { even: !0 }][ar % 2];
  return [LIST_ITEM, __assign$1(__assign$1({}, cr), { listStyle: !0 })];
}
function item$1(lr, ar) {
  var cr = lr.listData, ur = cr.padding, fr = cr.task, dr = getSpecOfListItemStyle(lr), hr = [markInfo.apply(void 0, __spreadArray$1([ar, addOffsetPos(ar, ur)], dr))];
  return fr && (hr.push(markInfo(addOffsetPos(ar, ur), addOffsetPos(ar, ur + 3), TASK_DELIM)), hr.push(markInfo(addOffsetPos(ar, ur + 1), addOffsetPos(ar, ur + 2), META))), hr.concat(markListItemChildren(lr.firstChild, TEXT));
}
var markNodeFuncMap = {
  heading: heading$1,
  strong: emphasisAndStrikethrough,
  emph: emphasisAndStrikethrough,
  strike: emphasisAndStrikethrough,
  link,
  image: image$1,
  code,
  codeBlock: codeBlock$1,
  blockQuote: blockQuote$2,
  item: item$1,
  customBlock: customBlock$2
}, simpleMarkClassNameMap = {
  thematicBreak: THEMATIC_BREAK,
  table: TABLE,
  tableCell: TABLE_CELL,
  htmlInline: HTML
};
function getMarkInfo(lr, ar, cr, ur) {
  var fr = lr.type;
  return isFunction_1(markNodeFuncMap[fr]) ? markNodeFuncMap[fr](lr, ar, cr, ur) : simpleMarkClassNameMap[fr] ? [markInfo(ar, cr, simpleMarkClassNameMap[fr])] : null;
}
var removingBackgroundIndexMap = {};
function syntaxHighlight(lr) {
  var ar = lr.schema, cr = lr.toastMark;
  return new distExports$3.Plugin({
    appendTransaction: function(ur, fr, dr) {
      var hr = ur[0], gr = dr.tr;
      if (hr.docChanged) {
        var vr = [], mr = hr.getMeta("editResult");
        mr.forEach(function(br) {
          var yr = br.nodes, kr = br.removedNodeRange;
          if (yr.length) {
            vr = vr.concat(getMarkForRemoving(gr, yr));
            for (var Tr = 0, _r = yr; Tr < _r.length; Tr++)
              for (var Er = _r[Tr], xr = Er.walker(), Cr = xr.next(); Cr; ) {
                var Ar = Cr.node, Lr = Cr.entering;
                Lr && (vr = vr.concat(getMarkForAdding(Ar, cr))), Cr = xr.next();
              }
          } else if (kr)
            for (var Dr = gr.doc.childCount - 1, Nr = kr.line, Hr = Nr[0], $r = Nr[1], Wr = Math.min(Hr, Dr), Zr = Math.min($r, Dr), oi = Wr; oi <= Zr; oi += 1)
              removingBackgroundIndexMap[oi] = !0;
        }), appendMarkTr(gr, ar, vr);
      }
      return gr.setMeta("widget", hr.getMeta("widget"));
    }
  });
}
function isDifferentBlock(lr, ar, cr) {
  return Object.keys(cr).some(function(ur) {
    return cr[ur] !== lr.child(ar).attrs[ur];
  });
}
function addLineBackground(lr, ar, cr, ur, fr) {
  fr === void 0 && (fr = {});
  for (var dr = ur.startIndex, hr = ur.endIndex, gr = ur.from, vr = ur.to, mr = !1, br = dr; br <= hr; br += 1)
    delete removingBackgroundIndexMap[br], mr = isDifferentBlock(ar, br, fr);
  mr && lr.setBlockType(gr, vr, cr, fr);
}
function appendMarkTr(lr, ar, cr) {
  var ur = lr.doc, fr = ar.nodes.paragraph, dr = getStartPosListPerLine(ur, ur.childCount);
  cr.forEach(function(hr) {
    var gr = hr.start, vr = hr.end, mr = hr.spec, br = hr.lineBackground, yr = Math.min(gr[0], ur.childCount) - 1, kr = Math.min(vr[0], ur.childCount) - 1, Tr = ur.child(yr), _r = ur.child(kr), Er = dr[yr], xr = dr[kr];
    if (Er += gr[1] + getWidgetNodePos(Tr, gr[1] - 1), xr += vr[1] + getWidgetNodePos(_r, vr[1] - 1), mr)
      if (br) {
        var Cr = { from: Er, to: xr, startIndex: yr, endIndex: kr };
        addLineBackground(lr, ur, fr, Cr, mr.attrs);
      } else
        lr.addMark(Er, xr, ar.mark(mr.type, mr.attrs));
    else
      lr.removeMark(Er, xr);
  }), removeBlockBackground(lr, dr, fr);
}
function removeBlockBackground(lr, ar, cr) {
  Object.keys(removingBackgroundIndexMap).forEach(function(ur) {
    var fr = Number(ur), dr = Math.min(Number(ur) + 1, lr.doc.childCount - 1), hr = ar[fr], gr = ar[dr] - 1;
    fr === dr && (gr += 2), lr.setBlockType(hr, gr, cr);
  });
}
function cacheIndexToRemoveBackground(lr, ar, cr) {
  var ur = [];
  removingBackgroundIndexMap = {};
  for (var fr = ar[0] - 1; fr < cr[0]; fr += 1) {
    var dr = lr.child(fr), hr = dr.attrs.codeEnd, gr = dr.attrs.codeStart;
    if (gr && hr && !includes(ur, gr)) {
      ur.push(gr), hr = Math.min(hr, lr.childCount);
      for (var vr = gr - 1, mr = cr[0], br = vr; br < mr; br += 1)
        removingBackgroundIndexMap[br] = !0;
    }
  }
}
function getMarkForRemoving(lr, ar) {
  var cr = lr.doc, ur = ar[0].sourcepos[0], fr = last$1(ar).sourcepos, dr = fr[1], hr = [ur[0], ur[1]], gr = [dr[0], dr[1] + 1], vr = [];
  return cacheIndexToRemoveBackground(cr, ur, dr), vr.push({ start: hr, end: gr }), vr;
}
function getMarkForAdding(lr, ar) {
  var cr = ar.getLineTexts(), ur = [getMdStartLine(lr), getMdStartCh(lr)], fr = [getMdEndLine(lr), getMdEndCh(lr) + 1], dr = getMarkInfo(lr, ur, fr, cr[fr[0] - 1]);
  return dr != null ? dr : [];
}
var defaultToolbarStateKeys = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function getToolbarStateType$1(lr) {
  var ar = lr.type;
  return isListNode$1(lr) ? lr.listData.task ? "taskList" : lr.listData.type === "ordered" ? "orderedList" : "bulletList" : ar.indexOf("table") !== -1 ? "table" : includes(defaultToolbarStateKeys, ar) ? ar : null;
}
function getToolbarState$1(lr) {
  var ar = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  }, cr = !0;
  return traverseParentNodes(lr, function(ur) {
    var fr = getToolbarStateType$1(ur);
    fr && (fr === "bulletList" || fr === "orderedList" ? cr && (ar[fr] = { active: !0 }, ar.indent.disabled = !1, ar.outdent.disabled = !1, cr = !1) : ar[fr] = { active: !0 });
  }), ar;
}
function previewHighlight(lr) {
  var ar = lr.toastMark, cr = lr.eventEmitter;
  return new distExports$3.Plugin({
    view: function() {
      return {
        update: function(ur, fr) {
          var dr = ur.state, hr = dr.doc, gr = dr.selection;
          if (!(fr && fr.doc.eq(hr) && fr.selection.eq(gr))) {
            var vr = gr.from, mr = dr.doc.resolve(vr).start(), br = dr.doc.content.findIndex(vr).index + 1, yr = vr - mr;
            vr === mr && (yr += 1);
            var kr = [br, yr], Tr = ar.findNodeAtPosition(kr), _r = getToolbarState$1(Tr);
            cr.emit("changeToolbarState", {
              cursorPos: kr,
              mdNode: Tr,
              toolbarState: _r
            }), cr.emit("setFocusedNode", Tr);
          }
        }
      };
    }
  });
}
var Doc$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Mark = (
  /** @class */
  function() {
    function lr() {
    }
    return Object.defineProperty(lr.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.setContext = function(ar) {
      this.context = ar;
    }, lr;
  }()
);
function getTextByMdLine(lr, ar) {
  return getTextContent(lr, ar - 1);
}
function getTextContent(lr, ar) {
  return lr.child(ar).textContent;
}
var reBlockQuote = /^\s*> ?/, BlockQuote$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("block-quote") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createBlockQuoteText = function(cr, ur) {
      return ur ? cr.replace(reBlockQuote, "").trim() : "> " + cr.trim();
    }, ar.prototype.extendBlockQuote = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, hr = ur.doc, gr = ur.tr, vr = ur.schema, mr = getRangeInfo(dr), br = mr.endFromOffset, yr = mr.endToOffset, kr = mr.endIndex, Tr = mr.to, _r = getTextContent(hr, kr), Er = reBlockQuote.test(_r);
        if (Er && Tr > br && dr.empty) {
          var xr = !_r.replace(reBlockQuote, "").trim();
          if (xr)
            gr.deleteRange(br, yr).split(gr.mapping.map(yr));
          else {
            var Cr = _r.slice(Tr - br).trim(), Ar = createTextNode$1(vr, cr.createBlockQuoteText(Cr));
            splitAndExtendBlock(gr, yr, Cr, Ar);
          }
          return fr(gr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      var cr = this;
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, hr = ur.doc, gr = getRangeInfo(dr), vr = gr.startFromOffset, mr = gr.endToOffset, br = gr.startIndex, yr = gr.endIndex, kr = reBlockQuote.test(getTextContent(hr, br)), Tr = replaceTextNode({
            state: ur,
            startIndex: br,
            endIndex: yr,
            from: vr,
            createText: function(_r) {
              return cr.createBlockQuoteText(_r, kr);
            }
          });
          return fr(Tr.setSelection(createTextSelection(Tr, Tr.mapping.map(mr)))), !0;
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "alt-q": cr,
        "alt-Q": cr,
        Enter: this.extendBlockQuote()
      };
    }, ar;
  }(Mark)
), reList = /(^\s*)([-*+] |[\d]+\. )/, reOrderedList = /(^\s*)([\d])+\.( \[[ xX]])? /, reOrderedListGroup = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/, reCanBeTaskList = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /, reBulletListGroup = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/, reTaskList = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/, reBulletTaskList = /(^\s*)([-*+])( \[[ xX]]) /;
function getListType(lr) {
  return reOrderedList.test(lr) ? "ordered" : "bullet";
}
function getListDepth(lr) {
  for (var ar = 0; lr && lr.type !== "document"; )
    lr.type === "list" && (ar += 1), lr = lr.parent;
  return ar;
}
function findSameDepthList(lr, ar, cr, ur) {
  for (var fr = lr.getLineTexts(), dr = fr.length, hr = [], gr = ar; ur ? gr < dr : gr > 1; ) {
    gr = ur ? gr + 1 : gr - 1;
    var vr = lr.findFirstNodeAtLine(gr), mr = getListDepth(vr);
    if (mr === cr)
      hr.push({ line: gr, depth: cr, mdNode: vr });
    else if (mr < cr)
      break;
  }
  return hr;
}
function getSameDepthItems(lr) {
  var ar = lr.toastMark, cr = lr.mdNode, ur = lr.line, fr = getListDepth(cr), dr = findSameDepthList(ar, ur, fr, !1).reverse(), hr = findSameDepthList(ar, ur, fr, !0);
  return dr.concat([{ line: ur, depth: fr, mdNode: cr }]).concat(hr);
}
function textToBullet(lr) {
  if (!reList.test(lr))
    return "* " + lr;
  var ar = getListType(lr);
  return ar === "bullet" && reCanBeTaskList.test(lr) ? lr = lr.replace(reBulletTaskList, "$1$2 ") : ar === "ordered" && (lr = lr.replace(reOrderedList, "$1* ")), lr;
}
function textToOrdered(lr, ar) {
  if (!reList.test(lr))
    return ar + ". " + lr;
  var cr = getListType(lr);
  if (cr === "bullet" || cr === "ordered" && reCanBeTaskList.test(lr))
    lr = lr.replace(reCanBeTaskList, "$1" + ar + ". ");
  else if (cr === "ordered") {
    var ur = reOrderedListGroup.exec(lr)[3];
    Number(ur) !== ar && (lr = lr.replace(reOrderedList, "$1" + ar + ". "));
  }
  return lr;
}
function getChangedInfo(lr, ar, cr, ur) {
  ur === void 0 && (ur = 0);
  var fr = Number.MAX_VALUE, dr = 0, hr = ar.map(function(gr, vr) {
    var mr = gr.line;
    fr = Math.min(mr - 1, fr), dr = Math.max(mr - 1, dr);
    var br = getTextByMdLine(lr, mr);
    return br = cr === "bullet" ? textToBullet(br) : textToOrdered(br, vr + 1 + ur), { text: br, line: mr };
  });
  return { changedResults: hr, firstIndex: fr, lastIndex: dr };
}
function getBulletOrOrdered(lr, ar) {
  var cr = getSameDepthItems(ar);
  return getChangedInfo(ar.doc, cr, lr);
}
var otherListToList = {
  bullet: function(lr) {
    return getBulletOrOrdered("bullet", lr);
  },
  ordered: function(lr) {
    return getBulletOrOrdered("ordered", lr);
  },
  task: function(lr) {
    var ar = lr.mdNode, cr = lr.doc, ur = lr.line, fr = getTextByMdLine(cr, ur);
    return ar.listData.task ? fr = fr.replace(reTaskList, "$1$2") : isListNode$1(ar) && (fr = fr.replace(reList, "$1$2[ ] ")), { changedResults: [{ text: fr, line: ur }] };
  }
}, otherNodeToList = {
  bullet: function(lr) {
    var ar = lr.doc, cr = lr.line, ur = getTextByMdLine(ar, cr), fr = [{ text: "* " + ur, line: cr }];
    return { changedResults: fr };
  },
  ordered: function(lr) {
    for (var ar = lr.toastMark, cr = lr.doc, ur = lr.line, fr = lr.startLine, dr = getTextByMdLine(cr, ur), hr = 1, gr = fr, vr = 0, mr = fr - 1; mr > 0; mr -= 1) {
      var br = ar.findFirstNodeAtLine(mr), yr = getTextByMdLine(cr, mr), kr = yr && !!findClosestNode(br, function(Lr) {
        return isListNode$1(Lr);
      }), Tr = reOrderedListGroup.exec(getTextByMdLine(cr, mr));
      if (!Tr && !kr)
        break;
      if (!Tr && kr) {
        vr += 1;
        continue;
      }
      var _r = Tr, Er = _r[1], xr = _r[3];
      if (!Er) {
        hr = Number(xr), gr = mr;
        break;
      }
    }
    var Cr = hr + ur - gr - vr, Ar = [{ text: Cr + ". " + dr, line: ur }];
    return { changedResults: Ar };
  },
  task: function(lr) {
    var ar = lr.doc, cr = lr.line, ur = getTextByMdLine(ar, cr), fr = [{ text: "* [ ] " + ur, line: cr }];
    return { changedResults: fr };
  }
}, extendList = {
  bullet: function(lr) {
    var ar = lr.line, cr = lr.doc, ur = getTextByMdLine(cr, ar), fr = reBulletListGroup.exec(ur), dr = fr[1], hr = fr[2];
    return { listSyntax: "" + dr + hr };
  },
  ordered: function(lr) {
    var ar = lr.toastMark, cr = lr.line, ur = lr.mdNode, fr = lr.doc, dr = getListDepth(ur), hr = getTextByMdLine(fr, cr), gr = reOrderedListGroup.exec(hr), vr = gr[1], mr = gr[3], br = gr[4], yr = Number(mr) + 1, kr = "" + vr + yr + br, Tr = findSameDepthList(ar, cr, dr, !0), _r = Tr.filter(function(Er) {
      var xr = reOrderedListGroup.exec(getTextByMdLine(fr, Er.line));
      return xr && xr[1].length === vr.length && !!findClosestNode(Er.mdNode, function(Cr) {
        return isOrderedListNode(Cr);
      });
    });
    return __assign$1({ listSyntax: kr }, getChangedInfo(fr, _r, "ordered", yr));
  }
};
function getReorderedListInfo(lr, ar, cr, ur, fr) {
  for (var dr = [], hr = getTextByMdLine(lr, cr), gr = reOrderedListGroup.exec(hr); gr; ) {
    var vr = gr[1], mr = gr[4], br = gr[5], yr = vr.length;
    if (yr === fr)
      dr.push(createTextNode$1(ar, "" + vr + ur + mr + br)), ur += 1, cr += 1;
    else if (yr > fr) {
      var kr = getReorderedListInfo(lr, ar, cr, 1, yr);
      cr = kr.line, dr = dr.concat(kr.nodes);
    }
    if (yr < fr || cr > lr.childCount)
      break;
    hr = getTextByMdLine(lr, cr), gr = reOrderedListGroup.exec(hr);
  }
  return { nodes: dr, line: cr };
}
var reStartSpace = /(^\s{1,4})(.*)/;
function isBlockUnit(lr, ar, cr) {
  return lr < ar || reList.test(cr) || reBlockQuote.test(cr);
}
function isInTableCellNode(lr, ar, cr) {
  var ur = cr.$from;
  ur.depth === 0 && (ur = lr.resolve(ur.pos - 1));
  var fr = ur.node(1), dr = ur.start(1), hr = fr.content.size;
  return fr.rangeHasMark(0, hr, ar.marks.table) && ur.pos - dr !== hr && ur.pos !== dr;
}
function createSelection(lr, ar) {
  var cr = ar.from, ur = ar.to;
  if (ar.type === "indent") {
    var fr = 4;
    cr += fr, ur += (ar.lineLen + 1) * fr;
  } else {
    var dr = ar.spaceLenList;
    cr -= dr[0];
    for (var hr = 0; hr < dr.length; hr += 1)
      ur -= dr[hr];
  }
  return createTextSelection(lr, cr, ur);
}
var Paragraph$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: !1,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ur.className ? ["div", { class: clsWithMdPrefix(ur.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.reorderList = function(cr, ur) {
      for (var fr = this.context, dr = fr.view, hr = fr.toastMark, gr = fr.schema, vr = dr.state, mr = vr.tr, br = vr.selection, yr = vr.doc, kr = hr.findFirstNodeAtLine(cr), Tr = kr; kr && !isBulletListNode(kr) && kr.parent.type !== "document"; )
        if (kr = kr.parent, isOrderedListNode(kr)) {
          Tr = kr;
          break;
        }
      Tr && (cr = Tr.sourcepos[0][0]);
      var _r = reOrderedListGroup.exec(getTextByMdLine(yr, cr)), Er = _r[1], xr = _r[3], Cr = Er.length, Ar = getReorderedListInfo(yr, gr, cr, Number(xr), Cr), Lr = Ar.line, Dr = Ar.nodes;
      ur = Math.max(ur, Lr - 1);
      for (var Nr = getNodeContentOffsetRange(yr, cr - 1).startOffset, Hr = cr - 1; Hr <= ur - 1; Hr += 1) {
        var $r = yr.child(Hr), Wr = $r.nodeSize, Zr = $r.content, oi = mr.mapping.map(Nr), Jr = oi + Zr.size;
        mr.replaceWith(oi, Jr, Dr[Hr - cr + 1]), Nr += Wr;
      }
      var Yr = createTextSelection(mr, br.from, br.to);
      dr.dispatch(mr.setSelection(Yr));
    }, ar.prototype.indent = function(cr) {
      var ur = this;
      return cr === void 0 && (cr = !1), function() {
        return function(fr, dr) {
          var hr = fr.schema, gr = fr.selection, vr = fr.doc, mr = getRangeInfo(gr), br = mr.from, yr = mr.to, kr = mr.startFromOffset, Tr = mr.startIndex, _r = mr.endIndex;
          if (cr && isInTableCellNode(vr, hr, gr))
            return !1;
          var Er = getTextContent(vr, Tr);
          if (cr && isBlockUnit(br, yr, Er) || !cr && reList.test(Er)) {
            var xr = replaceTextNode({
              state: fr,
              from: kr,
              startIndex: Tr,
              endIndex: _r,
              createText: function(Ar) {
                return "    " + Ar;
              }
            }), Cr = {
              type: "indent",
              from: br,
              to: yr,
              lineLen: _r - Tr
            };
            dr(xr.setSelection(createSelection(xr, Cr))), reOrderedListGroup.test(Er) && ur.reorderList(Tr + 1, _r + 1);
          } else
            cr && dr(fr.tr.insert(yr, createTextNode$1(hr, "    ")));
          return !0;
        };
      };
    }, ar.prototype.outdent = function(cr) {
      var ur = this;
      return cr === void 0 && (cr = !1), function() {
        return function(fr, dr) {
          var hr = fr.selection, gr = fr.doc, vr = fr.schema, mr = getRangeInfo(hr), br = mr.from, yr = mr.to, kr = mr.startFromOffset, Tr = mr.startIndex, _r = mr.endIndex;
          if (cr && isInTableCellNode(gr, vr, hr))
            return !1;
          var Er = getTextContent(gr, Tr);
          if (cr && isBlockUnit(br, yr, Er) || !cr && reList.test(Er)) {
            var xr = [], Cr = replaceTextNode({
              state: fr,
              from: kr,
              startIndex: Tr,
              endIndex: _r,
              createText: function(Hr) {
                var $r = reStartSpace.exec(Hr);
                return xr.push($r ? $r[1].length : 0), Hr.replace(reStartSpace, "$2");
              }
            }), Ar = { type: "outdent", from: br, to: yr, spaceLenList: xr };
            dr(Cr.setSelection(createSelection(Cr, Ar))), reOrderedListGroup.test(Er) && ur.reorderList(Tr + 1, _r + 1);
          } else if (cr) {
            var Lr = Er.slice(0, yr - kr), Dr = Lr.replace(/\s{1,4}$/, ""), Nr = yr - (Lr.length - Dr.length);
            dr(fr.tr.delete(Nr, yr));
          }
          return !0;
        };
      };
    }, ar.prototype.deleteLines = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = cr.context.view, hr = getRangeInfo(ur.selection), gr = hr.startFromOffset, vr = hr.endToOffset, mr = function() {
          return fr(ur.tr.deleteRange(gr, vr)), !0;
        };
        return chainCommands(mr, joinForward)(ur, fr, dr);
      };
    }, ar.prototype.moveDown = function() {
      return function(cr, ur) {
        var fr = cr.doc, dr = cr.tr, hr = cr.selection, gr = cr.schema, vr = getRangeInfo(hr), mr = vr.startFromOffset, br = vr.endToOffset, yr = vr.endIndex;
        if (yr < fr.content.childCount - 1) {
          var kr = fr.child(yr + 1), Tr = kr.nodeSize, _r = kr.textContent;
          return dr.delete(br, br + Tr).split(mr).insert(dr.mapping.map(mr) - 2, createTextNode$1(gr, _r)), ur(dr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveUp = function() {
      return function(cr, ur) {
        var fr = cr.tr, dr = cr.doc, hr = cr.selection, gr = cr.schema, vr = getRangeInfo(hr), mr = vr.startFromOffset, br = vr.endToOffset, yr = vr.startIndex;
        if (yr > 0) {
          var kr = dr.child(yr - 1), Tr = kr.nodeSize, _r = kr.textContent;
          return fr.delete(mr - Tr, mr).split(fr.mapping.map(br)).insert(fr.mapping.map(br), createTextNode$1(gr, _r)), ur(fr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.indent(!0)(),
        "Shift-Tab": this.outdent(!0)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    }, ar;
  }(Node$2)
), Text$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reHeading = /^#{1,6}\s/, Heading$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.level, dr = ur.seText, hr = "heading|heading" + fr;
            return dr && (hr += "|delimiter|setext"), ["span", { class: clsWithMdPrefix.apply(void 0, hr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createHeadingText = function(cr, ur, fr) {
      for (var dr = ur.replace(fr, "").trim(), hr = ""; cr > 0; )
        hr += "#", cr -= 1;
      return hr + " " + dr;
    }, ar.prototype.commands = function() {
      var cr = this;
      return function(ur) {
        return function(fr, dr) {
          var hr = ur.level, gr = getRangeInfo(fr.selection), vr = gr.startFromOffset, mr = gr.endToOffset, br = gr.startIndex, yr = gr.endIndex, kr = replaceTextNode({
            state: fr,
            from: vr,
            startIndex: br,
            endIndex: yr,
            createText: function(Tr) {
              var _r = Tr.match(reHeading), Er = _r ? _r[0] : "";
              return cr.createHeadingText(hr, Tr, Er);
            }
          });
          return dr(kr.setSelection(createTextSelection(kr, kr.mapping.map(mr)))), !0;
        };
      };
    }, ar;
  }(Mark)
), fencedCodeBlockSyntax = "```", CodeBlock$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("code-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.schema, hr = cr.tr, gr = getRangeInfo(fr), vr = gr.startFromOffset, mr = gr.endToOffset, br = createTextNode$1(dr, fencedCodeBlockSyntax);
          return hr.insert(vr, br).split(vr + fencedCodeBlockSyntax.length), hr.split(hr.mapping.map(mr)).insert(hr.mapping.map(mr), br), ur(hr.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            createTextSelection(hr, hr.mapping.map(mr) - (fencedCodeBlockSyntax.length + 2))
          )), !0;
        };
      };
    }, ar.prototype.keepIndentation = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, hr = ur.tr, gr = ur.doc, vr = ur.schema, mr = cr.context.toastMark, br = getRangeInfo(dr), yr = br.startFromOffset, kr = br.endToOffset, Tr = br.endIndex, _r = br.from, Er = br.to, xr = getTextContent(gr, Tr);
        if (_r === Er && xr.trim()) {
          var Cr = xr.match(/^\s+/), Ar = mr.findFirstNodeAtLine(Tr + 1);
          if (isCodeBlockNode(Ar) && Cr) {
            var Lr = Cr[0], Dr = xr.slice(Er - yr), Nr = createTextNode$1(vr, Lr + Dr);
            return splitAndExtendBlock(hr, kr, Dr, Nr), fr(hr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-p": cr,
        "Shift-Mod-P": cr,
        Enter: this.keepIndentation()
      };
    }, ar;
  }(Mark)
), reEmptyTable = /\||\s/g;
function createTableHeader(lr) {
  return [createTableRow(lr), createTableRow(lr, !0)];
}
function createTableBody$1(lr, ar) {
  for (var cr = [], ur = 0; ur < ar; ur += 1)
    cr.push(createTableRow(lr));
  return cr;
}
function createTableRow(lr, ar) {
  for (var cr = "|", ur = 0; ur < lr; ur += 1)
    cr += ar ? " --- |" : "  |";
  return cr;
}
function createTargetTypes(lr) {
  return lr ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var Table$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendTable = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, hr = ur.doc, gr = ur.tr, vr = ur.schema;
        if (!dr.empty)
          return !1;
        var mr = getRangeInfo(dr), br = mr.endFromOffset, yr = mr.endToOffset, kr = mr.endIndex, Tr = mr.to, _r = getTextContent(hr, kr), Er = [kr + 1, Tr - br + 1], xr = cr.context.toastMark.findNodeAtPosition(Er), Cr = findClosestNode(xr, function(Hr) {
          return isTableCellNode(Hr) && (Hr.parent.type === "tableDelimRow" || Hr.parent.parent.type === "tableBody");
        });
        if (Cr) {
          var Ar = !_r.replace(reEmptyTable, "").trim(), Lr = Cr.parent, Dr = Lr.parent.parent.columns.length, Nr = createTableRow(Dr);
          return Ar ? gr.deleteRange(br, yr).split(gr.mapping.map(yr)) : gr.split(yr).insert(gr.mapping.map(yr), createTextNode$1(vr, Nr)).setSelection(createTextSelection(gr, gr.mapping.map(yr) - 2)), fr(gr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveTableCell = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var hr = fr.selection, gr = fr.tr, vr = getRangeInfo(hr), mr = vr.endFromOffset, br = vr.endIndex, yr = vr.to, kr = [br + 1, yr - mr], Tr = ur.context.toastMark.findNodeAtPosition(kr), _r = findClosestNode(Tr, function($r) {
          return isTableCellNode($r);
        });
        if (_r) {
          var Er = _r.parent, xr = createTargetTypes(cr), Cr = xr.type, Ar = xr.parentType, Lr = xr.childType, Dr = getMdEndCh(_r);
          if (_r[Cr])
            Dr = getMdEndCh(_r[Cr]) - 1;
          else {
            var Nr = !Er[Cr] && Er.parent.type === Ar ? Er.parent[Cr][Lr] : Er[Cr];
            if (Cr === "next") {
              var Hr = Nr ? getMdEndCh(Nr[Lr]) : 0;
              Dr += Hr + 2;
            } else
              Cr === "prev" && (Dr = Nr ? -4 : 0);
          }
          return dr(gr.setSelection(createTextSelection(gr, mr + Dr))), !0;
        }
        return !1;
      };
    }, ar.prototype.addTable = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.selection, hr = ur.tr, gr = ur.schema, vr = cr, mr = vr.columnCount, br = vr.rowCount, yr = getRangeInfo(dr).endToOffset, kr = createTableHeader(mr), Tr = createTableBody$1(mr, br - 1), _r = __spreadArray$1(__spreadArray$1([], kr), Tr);
          return _r.forEach(function(Er) {
            hr.split(hr.mapping.map(yr)).insert(hr.mapping.map(yr), createTextNode$1(gr, Er));
          }), fr(hr.setSelection(createTextSelection(hr, yr + 4))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { addTable: this.addTable() };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(!0),
        "Shift-Tab": this.moveTableCell(!1)
      };
    }, ar;
  }(Mark)
), thematicBreakSyntax = "***", ThematicBreak$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("thematic-break") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.schema, hr = cr.tr, gr = getRangeInfo(fr), vr = gr.from, mr = gr.to, br = gr.endToOffset, yr = createTextNode$1(dr, thematicBreakSyntax);
          return hr.split(vr).replaceWith(hr.mapping.map(vr), hr.mapping.map(mr), yr).split(hr.mapping.map(mr)).setSelection(createTextSelection(hr, hr.mapping.map(br))), ur(hr), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var cr = this.hr()();
      return { "Mod-l": cr, "Mod-L": cr };
    }, ar;
  }(Mark)
);
function cannotBeListNode(lr, ar) {
  var cr = lr.type, ur = lr.sourcepos, fr = ur[0][0];
  return ar <= fr && (cr === "codeBlock" || cr === "heading" || cr.match("table"));
}
var ListItem$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: !1 },
            even: { default: !1 },
            listStyle: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.odd, dr = ur.even, hr = ur.listStyle, gr = "list-item";
            return hr && (gr += "|list-item-style"), fr && (gr += "|list-item-odd"), dr && (gr += "|list-item-even"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendList = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, hr = ur.doc, gr = ur.schema, vr = ur.tr, mr = cr.context.toastMark, br = getRangeInfo(dr), yr = br.to, kr = br.startFromOffset, Tr = br.endFromOffset, _r = br.endIndex, Er = br.endToOffset, xr = getTextContent(hr, _r), Cr = reList.test(xr);
        if (!Cr || dr.from === kr || !dr.empty)
          return !1;
        var Ar = !xr.replace(reCanBeTaskList, "").trim();
        if (Ar)
          vr.deleteRange(Tr, Er).split(vr.mapping.map(Er));
        else {
          var Lr = getListType(xr), Dr = mr.findFirstNodeAtLine(_r + 1), Nr = xr.slice(yr - Tr), Hr = { toastMark: mr, mdNode: Dr, doc: hr, line: _r + 1 }, $r = extendList[Lr](Hr), Wr = $r.listSyntax, Zr = $r.changedResults;
          if (Zr != null && Zr.length) {
            vr.split(yr), Zr.unshift({ text: Wr + Nr, line: _r + 1 }), cr.changeToListPerLine(vr, Zr, {
              from: yr,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: Zr[0].line,
              endLine: last$1(Zr).line
            });
            var oi = vr.mapping.map(Er) - Nr.length;
            vr.setSelection(createTextSelection(vr, oi));
          } else {
            var Jr = createTextNode$1(gr, Wr + Nr);
            splitAndExtendBlock(vr, Er, Nr, Jr);
          }
        }
        return fr(vr), !0;
      };
    }, ar.prototype.toList = function(cr) {
      var ur = this;
      return function() {
        return function(fr, dr) {
          for (var hr = fr.doc, gr = fr.tr, vr = fr.selection, mr = ur.context.toastMark, br = getRangeInfo(vr), yr = br.startIndex + 1, kr = br.endIndex + 1, Tr = br.endToOffset, _r = [], Er = yr; Er <= kr; Er += 1) {
            var xr = mr.findFirstNodeAtLine(Er);
            if (xr && cannotBeListNode(xr, Er))
              break;
            if (_r.indexOf(Er) === -1) {
              var Cr = { toastMark: mr, mdNode: xr, doc: hr, line: Er, startLine: yr }, Ar = (isListNode$1(xr) ? otherListToList[cr](Cr) : otherNodeToList[cr](Cr)).changedResults, Lr = ur.changeToListPerLine(gr, Ar, {
                from: getNodeContentOffsetRange(hr, Ar[0].line - 1).startOffset,
                startLine: Ar[0].line,
                endLine: last$1(Ar).line,
                indexDiff: 1
              });
              Tr = Math.max(Lr, Tr), Ar && (_r = _r.concat(Ar.map(function(Dr) {
                return Dr.line;
              })));
            }
          }
          return dr(gr.setSelection(createTextSelection(gr, gr.mapping.map(Tr)))), !0;
        };
      };
    }, ar.prototype.changeToListPerLine = function(cr, ur, fr) {
      for (var dr = fr.from, hr = fr.startLine, gr = fr.endLine, vr = fr.indexDiff, mr = vr === void 0 ? 0 : vr, br = 0, yr = function(_r) {
        var Er = cr.doc.child(_r), xr = Er.nodeSize, Cr = Er.content, Ar = cr.mapping.map(dr), Lr = Ar + Cr.size, Dr = ur.filter(function(Nr) {
          return Nr.line - mr === _r;
        })[0];
        Dr && (cr.replaceWith(Ar, Lr, createTextNode$1(kr.context.schema, Dr.text)), br = Math.max(br, dr + Cr.size)), dr += xr;
      }, kr = this, Tr = hr - mr; Tr <= gr - mr; Tr += 1)
        yr(Tr);
      return br;
    }, ar.prototype.toggleTask = function() {
      var cr = this;
      return function(ur, fr) {
        for (var dr = ur.selection, hr = ur.tr, gr = ur.doc, vr = ur.schema, mr = cr.context.toastMark, br = getRangeInfo(dr), yr = br.startIndex, kr = br.endIndex, Tr = null, _r = yr; _r <= kr; _r += 1) {
          var Er = mr.findFirstNodeAtLine(_r + 1);
          if (isListNode$1(Er) && Er.listData.task) {
            var xr = Er.listData, Cr = xr.checked, Ar = xr.padding, Lr = Cr ? " " : "x", Dr = Er.sourcepos[0], Nr = getNodeContentOffsetRange(gr, Dr[0] - 1).startOffset;
            Nr += Dr[1] + Ar, Tr = hr.replaceWith(Nr, Nr + 1, vr.text(Lr));
          }
        }
        return Tr ? (fr(Tr), !0) : !1;
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.toList("bullet")(), ur = this.toList("ordered")(), fr = this.toList("task")(), dr = this.toggleTask();
      return {
        "Mod-u": cr,
        "Mod-U": cr,
        "Mod-o": ur,
        "Mod-O": ur,
        "alt-t": fr,
        "alt-T": fr,
        "Shift-Ctrl-x": dr,
        "Shift-Ctrl-X": dr,
        Enter: this.extendList()
      };
    }, ar;
  }(Mark)
);
function toggleMark(lr, ar) {
  return function() {
    return function(cr, ur) {
      var fr = cr.tr, dr = cr.selection, hr = isFunction_1(lr) ? lr : function(Lr) {
        return lr.test(Lr);
      }, gr = ar.length, vr = fr.doc, mr = resolveSelectionPos(dr), br = mr[0], yr = mr[1], kr = Math.max(br - gr, 1), Tr = Math.min(yr + gr, vr.content.size - 1), _r = dr.content(), Er = _r.content.textBetween(0, _r.content.size, `
`), xr = vr.textBetween(kr, br, `
`), Cr = vr.textBetween(yr, Tr, `
`);
      if (Er = "" + xr + Er + Cr, xr && Cr && hr(Er))
        fr.delete(Tr - gr, Tr).delete(kr, kr + gr);
      else {
        fr.insertText(ar, yr).insertText(ar, br);
        var Ar = dr.empty ? createTextSelection(fr, br + gr) : createTextSelection(fr, br + gr, yr + gr);
        fr.setSelection(Ar);
      }
      return ur(fr), !0;
    };
  };
}
var reStrong = /^(\*{2}|_{2}).*([\s\S]*)\1$/m, strongSyntax = "**", Strong$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strong") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return toggleMark(reStrong, strongSyntax);
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var cr = this.bold()();
      return { "Mod-b": cr, "Mod-B": cr };
    }, ar;
  }(Mark)
), reStrike = /^(~{2}).*([\s\S]*)\1$/m, strikeSyntax = "~~", Strike$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strike") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reStrike, strikeSyntax);
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return { "Mod-s": cr, "Mod-S": cr };
    }, ar;
  }(Mark)
), reEmph = /^(\*|_).*([\s\S]*)\1$/m, emphSyntax = "*", Emph$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("emph") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return toggleMark(reEmph, emphSyntax);
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var cr = this.italic()();
      return { "Mod-i": cr, "Mod-I": cr };
    }, ar;
  }(Mark)
), reCode = /^(`).*([\s\S]*)\1$/m, codeSyntax = "`", Code$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: !1 },
            end: { default: !1 },
            marked: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.start, dr = ur.end, hr = ur.marked, gr = "code";
            return fr && (gr += "|delimiter|start"), dr && (gr += "|delimiter|end"), hr && (gr += "|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reCode, codeSyntax);
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return { "Shift-Mod-c": cr, "Shift-Mod-C": cr };
    }, ar;
  }(Mark)
), Link$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: !1 },
            desc: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.url, dr = ur.desc, hr = "link";
            return fr && (hr += "|link-url|marked-text"), dr && (hr += "|link-desc|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, hr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLinkOrImage = function(cr) {
      return function(ur) {
        return function(fr, dr) {
          var hr = fr.selection, gr = fr.tr, vr = fr.schema, mr = resolveSelectionPos(hr), br = mr[0], yr = mr[1], kr = ur, Tr = kr.linkText, _r = kr.altText, Er = kr.linkUrl, xr = kr.imageUrl, Cr = Tr, Ar = Er, Lr = "";
          return cr === "image" && (Cr = _r, Ar = xr, Lr = "!"), Cr = escapeTextForLink(Cr), Lr += "[" + Cr + "](" + Ar + ")", dr(gr.replaceWith(br, yr, createTextNode$1(vr, Lr))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    }, ar;
  }(Mark)
), TaskDelimiter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Delimiter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Meta = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("meta") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), MarkedText = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("marked-text") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), TableCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table-cell") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Html = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("html") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), customBlockSyntax = "$$", CustomBlock$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("custom-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.selection, hr = ur.schema, gr = ur.tr, vr = getRangeInfo(dr), mr = vr.startFromOffset, br = vr.endToOffset;
          if (!(cr != null && cr.info))
            return !1;
          var yr = "" + customBlockSyntax + cr.info, kr = createTextNode$1(hr, yr), Tr = createTextNode$1(hr, customBlockSyntax);
          return gr.insert(mr, kr).split(mr + yr.length), gr.split(gr.mapping.map(br)).insert(gr.mapping.map(br), Tr), fr(gr.setSelection(createTextSelection(gr, gr.mapping.map(br) - (customBlockSyntax.length + 2)))), !0;
        };
      };
    }, ar;
  }(Mark)
), reTaskMarkerKey = /x|backspace/i, reTaskMarker = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function smartTask(lr) {
  var ar = lr.schema, cr = lr.toastMark;
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        keyup: function(ur, fr) {
          var dr, hr = ur.state, gr = hr.doc, vr = hr.tr, mr = hr.selection;
          if (mr.empty && reTaskMarkerKey.test(fr.key)) {
            var br = getRangeInfo(mr), yr = br.startIndex, kr = br.startFromOffset, Tr = br.from, _r = [yr + 1, Tr - kr + 1], Er = cr.findNodeAtPosition(_r), xr = findClosestNode(Er, function(Jr) {
              var Yr;
              return Jr.type === "paragraph" && ((Yr = Jr.parent) === null || Yr === void 0 ? void 0 : Yr.type) === "item";
            });
            if (!((dr = xr == null ? void 0 : xr.firstChild) === null || dr === void 0) && dr.literal) {
              var Cr = xr.firstChild, Ar = Cr.literal.match(reTaskMarker);
              if (Ar) {
                var Lr = Cr.sourcepos[0], Dr = Ar[1], Nr = Ar[2], Hr = Ar[3], $r = Dr.length + Hr.length, Wr = getNodeContentOffsetRange(gr, Lr[0] - 1).startOffset, Zr = Lr[1] + Wr;
                if (Nr) {
                  var oi = $r ? $r + 1 : 0;
                  vr.replaceWith(Zr, oi + Zr, ar.text(Nr)), ur.dispatch(vr);
                } else
                  $r || (vr.insertText(" ", Zr), ur.dispatch(vr));
              }
            }
          }
          return !1;
        }
      }
    }
  });
}
var EVENT_TYPE = "cut", reLineEnding$2 = /\r\n|\n|\r/, MdEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr) || this, dr = ur.toastMark, hr = ur.useCommandShortcut, gr = hr === void 0 ? !0 : hr, vr = ur.mdPlugins, mr = vr === void 0 ? [] : vr;
      return fr.editorType = "markdown", fr.el.classList.add("md-mode"), fr.toastMark = dr, fr.extraPlugins = mr, fr.specs = fr.createSpecs(), fr.schema = fr.createSchema(), fr.context = fr.createContext(), fr.keymaps = fr.createKeymaps(gr), fr.view = fr.createView(), fr.commands = fr.createCommands(), fr.specs.setContext(__assign$1(__assign$1({}, fr.context), { view: fr.view })), fr.createClipboard(), fr.eventEmitter.listen("changePreviewTabWrite", function(br) {
        return fr.toggleActive(!0, br);
      }), fr.eventEmitter.listen("changePreviewTabPreview", function() {
        return fr.toggleActive(!1);
      }), fr.initEvent(), fr;
    }
    return ar.prototype.toggleActive = function(cr, ur) {
      toggleClass(this.el, "active", cr), cr ? ur || this.focus() : this.blur();
    }, ar.prototype.createClipboard = function() {
      var cr = this;
      this.clipboard = document.createElement("textarea"), this.clipboard.className = cls("pseudo-clipboard"), this.clipboard.addEventListener("paste", function(ur) {
        var fr = ur.clipboardData || window.clipboardData, dr = fr && fr.items;
        if (dr) {
          var hr = toArray_1(dr).some(function(vr) {
            return vr.kind === "string" && vr.type === "text/rtf";
          });
          if (!hr) {
            var gr = pasteImageOnly(dr);
            gr && (ur.preventDefault(), emitImageBlobHook(cr.eventEmitter, gr, ur.type));
          }
        }
      }), this.clipboard.addEventListener("input", function(ur) {
        var fr = ur.target.value;
        cr.replaceSelection(fr), ur.preventDefault(), ur.target.value = "";
      }), this.el.insertBefore(this.clipboard, this.view.dom);
    }, ar.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSpecs = function() {
      return new SpecManager([
        new Doc$1(),
        new Paragraph$1(),
        new Widget(),
        new Text$1(),
        new Heading$1(),
        new BlockQuote$1(),
        new CodeBlock$1(),
        new CustomBlock$1(),
        new Table$1(),
        new TableCell(),
        new ThematicBreak$1(),
        new ListItem$1(),
        new Strong$1(),
        new Strike$1(),
        new Emph$1(),
        new Code$1(),
        new Link$1(),
        new Delimiter(),
        new TaskDelimiter(),
        new MarkedText(),
        new Meta(),
        new Html()
      ]);
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        syntaxHighlight(this.context),
        previewHighlight(this.context),
        smartTask(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createView = function() {
      var cr = this;
      return new distExports$4.EditorView(this.el, {
        state: this.createState(),
        dispatchTransaction: function(ur) {
          cr.updateMarkdown(ur);
          var fr = cr.view.state.applyTransaction(ur).state;
          cr.view.updateState(fr), cr.emitChangeEvent(ur);
        },
        handleKeyDown: function(ur, fr) {
          return (fr.metaKey || fr.ctrlKey) && fr.key.toUpperCase() === "V" && cr.clipboard.focus(), cr.eventEmitter.emit("keydown", cr.editorType, fr), !1;
        },
        handleDOMEvents: {
          copy: function(ur, fr) {
            return cr.captureCopy(fr);
          },
          cut: function(ur, fr) {
            return cr.captureCopy(fr, EVENT_TYPE);
          },
          scroll: function() {
            return cr.eventEmitter.emit("scroll", "editor"), !0;
          },
          keyup: function(ur, fr) {
            return cr.eventEmitter.emit("keyup", cr.editorType, fr), !1;
          }
        },
        nodeViews: {
          widget: widgetNodeView
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, ar.prototype.captureCopy = function(cr, ur) {
      cr.preventDefault();
      var fr = this.view.state, dr = fr.selection, hr = fr.tr;
      if (dr.empty)
        return !0;
      var gr = this.getChanged(dr.content());
      return cr.clipboardData ? cr.clipboardData.setData("text/plain", gr) : window.clipboardData.setData("Text", gr), ur === EVENT_TYPE && this.view.dispatch(hr.deleteSelection().scrollIntoView().setMeta("uiEvent", EVENT_TYPE)), !0;
    }, ar.prototype.updateMarkdown = function(cr) {
      var ur = this;
      cr.docChanged && cr.steps.forEach(function(fr, dr) {
        if (fr.slice && !(fr instanceof ReplaceAroundStep)) {
          var hr = cr.docs[dr], gr = [fr.from, fr.to], vr = gr[0], mr = gr[1], br = getEditorToMdPos(hr, vr, mr), yr = br[0], kr = br[1], Tr = ur.getChanged(fr.slice);
          yr[0] === kr[0] && yr[1] === kr[1] && Tr === "" && (Tr = `
`);
          var _r = ur.toastMark.editMarkdown(yr, kr, Tr);
          ur.eventEmitter.emit("updatePreview", _r), cr.setMeta("editResult", _r).scrollIntoView();
        }
      });
    }, ar.prototype.getChanged = function(cr) {
      var ur = "", fr = 0, dr = cr.content.size;
      return cr.content.nodesBetween(fr, dr, function(hr, gr) {
        hr.isText ? ur += hr.text.slice(Math.max(fr, gr) - gr, dr - gr) : hr.isBlock && gr > 0 && (ur += `
`);
      }), ur;
    }, ar.prototype.setSelection = function(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this.view.state.tr, dr = getMdToEditorPos(fr.doc, cr, ur), hr = dr[0], gr = dr[1];
      this.view.dispatch(fr.setSelection(createTextSelection(fr, hr, gr)).scrollIntoView());
    }, ar.prototype.replaceSelection = function(cr, ur, fr) {
      var dr, hr = this.view.state, gr = hr.tr, vr = hr.schema, mr = hr.doc, br = cr.split(reLineEnding$2), yr = br.map(function(xr) {
        return createParagraph(vr, createNodesWithWidget(xr, vr));
      }), kr = new distExports$5.Slice(distExports$5.Fragment.from(yr), 1, 1);
      if (this.focus(), ur && fr) {
        var Tr = getMdToEditorPos(mr, ur, fr), _r = Tr[0], Er = Tr[1];
        dr = gr.replaceRange(_r, Er, kr);
      } else
        dr = gr.replaceSelection(kr);
      this.view.dispatch(dr.scrollIntoView());
    }, ar.prototype.deleteSelection = function(cr, ur) {
      var fr, dr = this.view.state, hr = dr.tr, gr = dr.doc;
      if (cr && ur) {
        var vr = getMdToEditorPos(gr, cr, ur), mr = vr[0], br = vr[1];
        fr = hr.deleteRange(mr, br);
      } else
        fr = hr.deleteSelection();
      this.view.dispatch(fr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(cr, ur) {
      var fr = this.view.state, dr = fr.doc, hr = fr.selection, gr = hr.from, vr = hr.to;
      if (cr && ur) {
        var mr = getMdToEditorPos(dr, cr, ur);
        gr = mr[0], vr = mr[1];
      }
      return dr.textBetween(gr, vr, `
`);
    }, ar.prototype.getSelection = function() {
      var cr = this.view.state.selection, ur = cr.from, fr = cr.to;
      return getEditorToMdPos(this.view.state.tr.doc, ur, fr);
    }, ar.prototype.setMarkdown = function(cr, ur) {
      ur === void 0 && (ur = !0);
      var fr = cr.split(reLineEnding$2), dr = this.view.state, hr = dr.tr, gr = dr.doc, vr = dr.schema, mr = fr.map(function(br) {
        return createParagraph(vr, createNodesWithWidget(br, vr));
      });
      this.view.dispatch(hr.replaceWith(0, gr.content.size, mr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.addWidget = function(cr, ur, fr) {
      var dr = this.view.state, hr = dr.tr, gr = dr.doc, vr = dr.selection, mr = fr ? getMdToEditorPos(gr, fr, fr)[0] : vr.to;
      this.view.dispatch(hr.setMeta("widget", { pos: mr, node: cr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(cr, ur, fr) {
      var dr = this.view.state, hr = dr.tr, gr = dr.schema, vr = dr.doc, mr = getMdToEditorPos(vr, cr, ur), br = createNodesWithWidget(fr, gr);
      this.view.dispatch(hr.replaceWith(mr[0], mr[1], br));
    }, ar.prototype.getRangeInfoOfNode = function(cr) {
      var ur = this.view.state, fr = ur.doc, dr = ur.selection, hr = cr || getEditorToMdPos(fr, dr.from)[0], gr = this.toastMark.findNodeAtPosition(hr);
      return gr.type === "text" && gr.parent.type !== "paragraph" && (gr = gr.parent), gr.sourcepos[1][1] += 1, { range: gr.sourcepos, type: gr.type };
    }, ar.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(cr) {
        return unwrapWidgetSyntax(cr);
      }).join(`
`);
    }, ar.prototype.getToastMark = function() {
      return this.toastMark;
    }, ar;
  }(EditorBase)
), EVENT_KEY = "_feEventKey";
function safeEvent$2(lr, ar) {
  var cr = lr[EVENT_KEY], ur;
  return cr || (cr = lr[EVENT_KEY] = {}), ur = cr[ar], ur || (ur = cr[ar] = []), ur;
}
var _safeEvent = safeEvent$2, isString$1 = isString_1, forEach$1 = forEach_1, safeEvent$1 = _safeEvent;
function off(lr, ar, cr) {
  if (isString$1(ar)) {
    forEach$1(ar.split(/\s+/g), function(ur) {
      unbindEvent(lr, ur, cr);
    });
    return;
  }
  forEach$1(ar, function(ur, fr) {
    unbindEvent(lr, fr, ur);
  });
}
function unbindEvent(lr, ar, cr) {
  var ur = safeEvent$1(lr, ar), fr;
  cr ? (forEach$1(ur, function(dr, hr) {
    return cr === dr.handler ? (removeHandler(lr, ar, dr.wrappedHandler), fr = hr, !1) : !0;
  }), ur.splice(fr, 1)) : (forEach$1(ur, function(dr) {
    removeHandler(lr, ar, dr.wrappedHandler);
  }), ur.splice(0, ur.length));
}
function removeHandler(lr, ar, cr) {
  "removeEventListener" in lr ? lr.removeEventListener(ar, cr) : "detachEvent" in lr && lr.detachEvent("on" + ar, cr);
}
var off_1 = off, isString = isString_1, forEach = forEach_1, safeEvent = _safeEvent;
function on(lr, ar, cr, ur) {
  if (isString(ar)) {
    forEach(ar.split(/\s+/g), function(fr) {
      bindEvent(lr, fr, cr, ur);
    });
    return;
  }
  forEach(ar, function(fr, dr) {
    bindEvent(lr, dr, fr, cr);
  });
}
function bindEvent(lr, ar, cr, ur) {
  function fr(dr) {
    cr.call(ur || lr, dr || window.event);
  }
  "addEventListener" in lr ? lr.addEventListener(ar, fr) : "attachEvent" in lr && lr.attachEvent("on" + ar, fr), memorizeHandler(lr, ar, cr, fr);
}
function memorizeHandler(lr, ar, cr, ur) {
  var fr = safeEvent(lr, ar), dr = !1;
  forEach(fr, function(hr) {
    return hr.handler === cr ? (dr = !0, !1) : !0;
  }), dr || fr.push({
    handler: cr,
    wrappedHandler: ur
  });
}
var on_1 = on;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(lr, ar) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(cr, ur) {
    cr.__proto__ = ur;
  } || function(cr, ur) {
    for (var fr in ur)
      Object.prototype.hasOwnProperty.call(ur, fr) && (cr[fr] = ur[fr]);
  }, extendStatics(lr, ar);
};
function __extends(lr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics(lr, ar);
  function cr() {
    this.constructor = lr;
  }
  lr.prototype = ar === null ? Object.create(ar) : (cr.prototype = ar.prototype, new cr());
}
var __assign = function() {
  return __assign = Object.assign || function(ar) {
    for (var cr, ur = 1, fr = arguments.length; ur < fr; ur++) {
      cr = arguments[ur];
      for (var dr in cr)
        Object.prototype.hasOwnProperty.call(cr, dr) && (ar[dr] = cr[dr]);
    }
    return ar;
  }, __assign.apply(this, arguments);
};
function __spreadArray(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
}
var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, encodeCache = {};
function getEncodeCache(lr) {
  var ar, cr, ur = encodeCache[lr];
  if (ur)
    return ur;
  for (ur = encodeCache[lr] = [], ar = 0; ar < 128; ar++)
    cr = String.fromCharCode(ar), /^[0-9a-z]$/i.test(cr) ? ur.push(cr) : ur.push("%" + ("0" + ar.toString(16).toUpperCase()).slice(-2));
  for (ar = 0; ar < lr.length; ar++)
    ur[lr.charCodeAt(ar)] = lr[ar];
  return ur;
}
function encode$1(lr, ar, cr) {
  var ur, fr, dr, hr, gr, vr = "";
  for (typeof ar != "string" && (cr = ar, ar = encode$1.defaultChars), typeof cr == "undefined" && (cr = !0), gr = getEncodeCache(ar), ur = 0, fr = lr.length; ur < fr; ur++) {
    if (dr = lr.charCodeAt(ur), cr && dr === 37 && ur + 2 < fr && /^[0-9a-f]{2}$/i.test(lr.slice(ur + 1, ur + 3))) {
      vr += lr.slice(ur, ur + 3), ur += 2;
      continue;
    }
    if (dr < 128) {
      vr += gr[dr];
      continue;
    }
    if (dr >= 55296 && dr <= 57343) {
      if (dr >= 55296 && dr <= 56319 && ur + 1 < fr && (hr = lr.charCodeAt(ur + 1), hr >= 56320 && hr <= 57343)) {
        vr += encodeURIComponent(lr[ur] + lr[ur + 1]), ur++;
        continue;
      }
      vr += "%EF%BF%BD";
      continue;
    }
    vr += encodeURIComponent(lr[ur]);
  }
  return vr;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1, lib = {}, decode = {}, Aacute$1 = "Á", aacute$1 = "á", Abreve = "Ă", abreve = "ă", ac = "∾", acd = "∿", acE = "∾̳", Acirc$1 = "Â", acirc$1 = "â", acute$1 = "´", Acy = "А", acy = "а", AElig$1 = "Æ", aelig$1 = "æ", af = "⁡", Afr = "𝔄", afr = "𝔞", Agrave$1 = "À", agrave$1 = "à", alefsym = "ℵ", aleph = "ℵ", Alpha = "Α", alpha = "α", Amacr = "Ā", amacr = "ā", amalg = "⨿", amp$2 = "&", AMP$1 = "&", andand = "⩕", And = "⩓", and = "∧", andd = "⩜", andslope = "⩘", andv = "⩚", ang = "∠", ange = "⦤", angle = "∠", angmsdaa = "⦨", angmsdab = "⦩", angmsdac = "⦪", angmsdad = "⦫", angmsdae = "⦬", angmsdaf = "⦭", angmsdag = "⦮", angmsdah = "⦯", angmsd = "∡", angrt = "∟", angrtvb = "⊾", angrtvbd = "⦝", angsph = "∢", angst = "Å", angzarr = "⍼", Aogon = "Ą", aogon = "ą", Aopf = "𝔸", aopf = "𝕒", apacir = "⩯", ap = "≈", apE = "⩰", ape = "≊", apid = "≋", apos$1 = "'", ApplyFunction = "⁡", approx = "≈", approxeq = "≊", Aring$1 = "Å", aring$1 = "å", Ascr = "𝒜", ascr = "𝒶", Assign = "≔", ast = "*", asymp = "≈", asympeq = "≍", Atilde$1 = "Ã", atilde$1 = "ã", Auml$1 = "Ä", auml$1 = "ä", awconint = "∳", awint = "⨑", backcong = "≌", backepsilon = "϶", backprime = "‵", backsim = "∽", backsimeq = "⋍", Backslash = "∖", Barv = "⫧", barvee = "⊽", barwed = "⌅", Barwed = "⌆", barwedge = "⌅", bbrk = "⎵", bbrktbrk = "⎶", bcong = "≌", Bcy = "Б", bcy = "б", bdquo = "„", becaus = "∵", because = "∵", Because = "∵", bemptyv = "⦰", bepsi = "϶", bernou = "ℬ", Bernoullis = "ℬ", Beta = "Β", beta = "β", beth = "ℶ", between = "≬", Bfr = "𝔅", bfr = "𝔟", bigcap = "⋂", bigcirc = "◯", bigcup = "⋃", bigodot = "⨀", bigoplus = "⨁", bigotimes = "⨂", bigsqcup = "⨆", bigstar = "★", bigtriangledown = "▽", bigtriangleup = "△", biguplus = "⨄", bigvee = "⋁", bigwedge = "⋀", bkarow = "⤍", blacklozenge = "⧫", blacksquare = "▪", blacktriangle = "▴", blacktriangledown = "▾", blacktriangleleft = "◂", blacktriangleright = "▸", blank = "␣", blk12 = "▒", blk14 = "░", blk34 = "▓", block = "█", bne = "=⃥", bnequiv = "≡⃥", bNot = "⫭", bnot = "⌐", Bopf = "𝔹", bopf = "𝕓", bot = "⊥", bottom = "⊥", bowtie = "⋈", boxbox = "⧉", boxdl = "┐", boxdL = "╕", boxDl = "╖", boxDL = "╗", boxdr = "┌", boxdR = "╒", boxDr = "╓", boxDR = "╔", boxh = "─", boxH = "═", boxhd = "┬", boxHd = "╤", boxhD = "╥", boxHD = "╦", boxhu = "┴", boxHu = "╧", boxhU = "╨", boxHU = "╩", boxminus = "⊟", boxplus = "⊞", boxtimes = "⊠", boxul = "┘", boxuL = "╛", boxUl = "╜", boxUL = "╝", boxur = "└", boxuR = "╘", boxUr = "╙", boxUR = "╚", boxv = "│", boxV = "║", boxvh = "┼", boxvH = "╪", boxVh = "╫", boxVH = "╬", boxvl = "┤", boxvL = "╡", boxVl = "╢", boxVL = "╣", boxvr = "├", boxvR = "╞", boxVr = "╟", boxVR = "╠", bprime = "‵", breve = "˘", Breve = "˘", brvbar$1 = "¦", bscr = "𝒷", Bscr = "ℬ", bsemi = "⁏", bsim = "∽", bsime = "⋍", bsolb = "⧅", bsol = "\\", bsolhsub = "⟈", bull = "•", bullet = "•", bump = "≎", bumpE = "⪮", bumpe = "≏", Bumpeq = "≎", bumpeq = "≏", Cacute = "Ć", cacute = "ć", capand = "⩄", capbrcup = "⩉", capcap = "⩋", cap = "∩", Cap = "⋒", capcup = "⩇", capdot = "⩀", CapitalDifferentialD = "ⅅ", caps = "∩︀", caret = "⁁", caron = "ˇ", Cayleys = "ℭ", ccaps = "⩍", Ccaron = "Č", ccaron = "č", Ccedil$1 = "Ç", ccedil$1 = "ç", Ccirc = "Ĉ", ccirc = "ĉ", Cconint = "∰", ccups = "⩌", ccupssm = "⩐", Cdot = "Ċ", cdot = "ċ", cedil$1 = "¸", Cedilla = "¸", cemptyv = "⦲", cent$1 = "¢", centerdot = "·", CenterDot = "·", cfr = "𝔠", Cfr = "ℭ", CHcy = "Ч", chcy = "ч", check = "✓", checkmark = "✓", Chi = "Χ", chi = "χ", circ = "ˆ", circeq = "≗", circlearrowleft = "↺", circlearrowright = "↻", circledast = "⊛", circledcirc = "⊚", circleddash = "⊝", CircleDot = "⊙", circledR = "®", circledS = "Ⓢ", CircleMinus = "⊖", CirclePlus = "⊕", CircleTimes = "⊗", cir = "○", cirE = "⧃", cire = "≗", cirfnint = "⨐", cirmid = "⫯", cirscir = "⧂", ClockwiseContourIntegral = "∲", CloseCurlyDoubleQuote = "”", CloseCurlyQuote = "’", clubs = "♣", clubsuit = "♣", colon = ":", Colon = "∷", Colone = "⩴", colone = "≔", coloneq = "≔", comma = ",", commat = "@", comp = "∁", compfn = "∘", complement = "∁", complexes = "ℂ", cong = "≅", congdot = "⩭", Congruent = "≡", conint = "∮", Conint = "∯", ContourIntegral = "∮", copf = "𝕔", Copf = "ℂ", coprod = "∐", Coproduct = "∐", copy$1 = "©", COPY$1 = "©", copysr = "℗", CounterClockwiseContourIntegral = "∳", crarr = "↵", cross = "✗", Cross = "⨯", Cscr = "𝒞", cscr = "𝒸", csub = "⫏", csube = "⫑", csup = "⫐", csupe = "⫒", ctdot = "⋯", cudarrl = "⤸", cudarrr = "⤵", cuepr = "⋞", cuesc = "⋟", cularr = "↶", cularrp = "⤽", cupbrcap = "⩈", cupcap = "⩆", CupCap = "≍", cup = "∪", Cup = "⋓", cupcup = "⩊", cupdot = "⊍", cupor = "⩅", cups = "∪︀", curarr = "↷", curarrm = "⤼", curlyeqprec = "⋞", curlyeqsucc = "⋟", curlyvee = "⋎", curlywedge = "⋏", curren$1 = "¤", curvearrowleft = "↶", curvearrowright = "↷", cuvee = "⋎", cuwed = "⋏", cwconint = "∲", cwint = "∱", cylcty = "⌭", dagger = "†", Dagger = "‡", daleth = "ℸ", darr = "↓", Darr = "↡", dArr = "⇓", dash = "‐", Dashv = "⫤", dashv = "⊣", dbkarow = "⤏", dblac = "˝", Dcaron = "Ď", dcaron = "ď", Dcy = "Д", dcy = "д", ddagger = "‡", ddarr = "⇊", DD = "ⅅ", dd = "ⅆ", DDotrahd = "⤑", ddotseq = "⩷", deg$1 = "°", Del = "∇", Delta = "Δ", delta = "δ", demptyv = "⦱", dfisht = "⥿", Dfr = "𝔇", dfr = "𝔡", dHar = "⥥", dharl = "⇃", dharr = "⇂", DiacriticalAcute = "´", DiacriticalDot = "˙", DiacriticalDoubleAcute = "˝", DiacriticalGrave = "`", DiacriticalTilde = "˜", diam = "⋄", diamond = "⋄", Diamond = "⋄", diamondsuit = "♦", diams = "♦", die = "¨", DifferentialD = "ⅆ", digamma = "ϝ", disin = "⋲", div = "÷", divide$1 = "÷", divideontimes = "⋇", divonx = "⋇", DJcy = "Ђ", djcy = "ђ", dlcorn = "⌞", dlcrop = "⌍", dollar = "$", Dopf = "𝔻", dopf = "𝕕", Dot = "¨", dot = "˙", DotDot = "⃜", doteq = "≐", doteqdot = "≑", DotEqual = "≐", dotminus = "∸", dotplus = "∔", dotsquare = "⊡", doublebarwedge = "⌆", DoubleContourIntegral = "∯", DoubleDot = "¨", DoubleDownArrow = "⇓", DoubleLeftArrow = "⇐", DoubleLeftRightArrow = "⇔", DoubleLeftTee = "⫤", DoubleLongLeftArrow = "⟸", DoubleLongLeftRightArrow = "⟺", DoubleLongRightArrow = "⟹", DoubleRightArrow = "⇒", DoubleRightTee = "⊨", DoubleUpArrow = "⇑", DoubleUpDownArrow = "⇕", DoubleVerticalBar = "∥", DownArrowBar = "⤓", downarrow = "↓", DownArrow = "↓", Downarrow = "⇓", DownArrowUpArrow = "⇵", DownBreve = "̑", downdownarrows = "⇊", downharpoonleft = "⇃", downharpoonright = "⇂", DownLeftRightVector = "⥐", DownLeftTeeVector = "⥞", DownLeftVectorBar = "⥖", DownLeftVector = "↽", DownRightTeeVector = "⥟", DownRightVectorBar = "⥗", DownRightVector = "⇁", DownTeeArrow = "↧", DownTee = "⊤", drbkarow = "⤐", drcorn = "⌟", drcrop = "⌌", Dscr = "𝒟", dscr = "𝒹", DScy = "Ѕ", dscy = "ѕ", dsol = "⧶", Dstrok = "Đ", dstrok = "đ", dtdot = "⋱", dtri = "▿", dtrif = "▾", duarr = "⇵", duhar = "⥯", dwangle = "⦦", DZcy = "Џ", dzcy = "џ", dzigrarr = "⟿", Eacute$1 = "É", eacute$1 = "é", easter = "⩮", Ecaron = "Ě", ecaron = "ě", Ecirc$1 = "Ê", ecirc$1 = "ê", ecir = "≖", ecolon = "≕", Ecy = "Э", ecy = "э", eDDot = "⩷", Edot = "Ė", edot = "ė", eDot = "≑", ee = "ⅇ", efDot = "≒", Efr = "𝔈", efr = "𝔢", eg = "⪚", Egrave$1 = "È", egrave$1 = "è", egs = "⪖", egsdot = "⪘", el = "⪙", Element$1 = "∈", elinters = "⏧", ell = "ℓ", els = "⪕", elsdot = "⪗", Emacr = "Ē", emacr = "ē", empty = "∅", emptyset = "∅", EmptySmallSquare = "◻", emptyv = "∅", EmptyVerySmallSquare = "▫", emsp13 = " ", emsp14 = " ", emsp = " ", ENG = "Ŋ", eng = "ŋ", ensp = " ", Eogon = "Ę", eogon = "ę", Eopf = "𝔼", eopf = "𝕖", epar = "⋕", eparsl = "⧣", eplus = "⩱", epsi = "ε", Epsilon = "Ε", epsilon = "ε", epsiv = "ϵ", eqcirc = "≖", eqcolon = "≕", eqsim = "≂", eqslantgtr = "⪖", eqslantless = "⪕", Equal = "⩵", equals = "=", EqualTilde = "≂", equest = "≟", Equilibrium = "⇌", equiv = "≡", equivDD = "⩸", eqvparsl = "⧥", erarr = "⥱", erDot = "≓", escr = "ℯ", Escr = "ℰ", esdot = "≐", Esim = "⩳", esim = "≂", Eta = "Η", eta = "η", ETH$1 = "Ð", eth$1 = "ð", Euml$1 = "Ë", euml$1 = "ë", euro = "€", excl = "!", exist = "∃", Exists = "∃", expectation = "ℰ", exponentiale = "ⅇ", ExponentialE = "ⅇ", fallingdotseq = "≒", Fcy = "Ф", fcy = "ф", female = "♀", ffilig = "ﬃ", fflig = "ﬀ", ffllig = "ﬄ", Ffr = "𝔉", ffr = "𝔣", filig = "ﬁ", FilledSmallSquare = "◼", FilledVerySmallSquare = "▪", fjlig = "fj", flat = "♭", fllig = "ﬂ", fltns = "▱", fnof = "ƒ", Fopf = "𝔽", fopf = "𝕗", forall = "∀", ForAll = "∀", fork = "⋔", forkv = "⫙", Fouriertrf = "ℱ", fpartint = "⨍", frac12$1 = "½", frac13 = "⅓", frac14$1 = "¼", frac15 = "⅕", frac16 = "⅙", frac18 = "⅛", frac23 = "⅔", frac25 = "⅖", frac34$1 = "¾", frac35 = "⅗", frac38 = "⅜", frac45 = "⅘", frac56 = "⅚", frac58 = "⅝", frac78 = "⅞", frasl = "⁄", frown = "⌢", fscr = "𝒻", Fscr = "ℱ", gacute = "ǵ", Gamma = "Γ", gamma = "γ", Gammad = "Ϝ", gammad = "ϝ", gap = "⪆", Gbreve = "Ğ", gbreve = "ğ", Gcedil = "Ģ", Gcirc = "Ĝ", gcirc = "ĝ", Gcy = "Г", gcy = "г", Gdot = "Ġ", gdot = "ġ", ge = "≥", gE = "≧", gEl = "⪌", gel = "⋛", geq = "≥", geqq = "≧", geqslant = "⩾", gescc = "⪩", ges = "⩾", gesdot = "⪀", gesdoto = "⪂", gesdotol = "⪄", gesl = "⋛︀", gesles = "⪔", Gfr = "𝔊", gfr = "𝔤", gg = "≫", Gg = "⋙", ggg = "⋙", gimel = "ℷ", GJcy = "Ѓ", gjcy = "ѓ", gla = "⪥", gl = "≷", glE = "⪒", glj = "⪤", gnap = "⪊", gnapprox = "⪊", gne = "⪈", gnE = "≩", gneq = "⪈", gneqq = "≩", gnsim = "⋧", Gopf = "𝔾", gopf = "𝕘", grave = "`", GreaterEqual = "≥", GreaterEqualLess = "⋛", GreaterFullEqual = "≧", GreaterGreater = "⪢", GreaterLess = "≷", GreaterSlantEqual = "⩾", GreaterTilde = "≳", Gscr = "𝒢", gscr = "ℊ", gsim = "≳", gsime = "⪎", gsiml = "⪐", gtcc = "⪧", gtcir = "⩺", gt$2 = ">", GT$1 = ">", Gt = "≫", gtdot = "⋗", gtlPar = "⦕", gtquest = "⩼", gtrapprox = "⪆", gtrarr = "⥸", gtrdot = "⋗", gtreqless = "⋛", gtreqqless = "⪌", gtrless = "≷", gtrsim = "≳", gvertneqq = "≩︀", gvnE = "≩︀", Hacek = "ˇ", hairsp = " ", half = "½", hamilt = "ℋ", HARDcy = "Ъ", hardcy = "ъ", harrcir = "⥈", harr = "↔", hArr = "⇔", harrw = "↭", Hat = "^", hbar = "ℏ", Hcirc = "Ĥ", hcirc = "ĥ", hearts = "♥", heartsuit = "♥", hellip = "…", hercon = "⊹", hfr = "𝔥", Hfr = "ℌ", HilbertSpace = "ℋ", hksearow = "⤥", hkswarow = "⤦", hoarr = "⇿", homtht = "∻", hookleftarrow = "↩", hookrightarrow = "↪", hopf = "𝕙", Hopf = "ℍ", horbar = "―", HorizontalLine = "─", hscr = "𝒽", Hscr = "ℋ", hslash = "ℏ", Hstrok = "Ħ", hstrok = "ħ", HumpDownHump = "≎", HumpEqual = "≏", hybull = "⁃", hyphen = "‐", Iacute$1 = "Í", iacute$1 = "í", ic = "⁣", Icirc$1 = "Î", icirc$1 = "î", Icy = "И", icy = "и", Idot = "İ", IEcy = "Е", iecy = "е", iexcl$1 = "¡", iff = "⇔", ifr = "𝔦", Ifr = "ℑ", Igrave$1 = "Ì", igrave$1 = "ì", ii = "ⅈ", iiiint = "⨌", iiint = "∭", iinfin = "⧜", iiota = "℩", IJlig = "Ĳ", ijlig = "ĳ", Imacr = "Ī", imacr = "ī", image = "ℑ", ImaginaryI = "ⅈ", imagline = "ℐ", imagpart = "ℑ", imath = "ı", Im = "ℑ", imof = "⊷", imped = "Ƶ", Implies = "⇒", incare = "℅", infin = "∞", infintie = "⧝", inodot = "ı", intcal = "⊺", int = "∫", Int = "∬", integers = "ℤ", Integral = "∫", intercal = "⊺", Intersection = "⋂", intlarhk = "⨗", intprod = "⨼", InvisibleComma = "⁣", InvisibleTimes = "⁢", IOcy = "Ё", iocy = "ё", Iogon = "Į", iogon = "į", Iopf = "𝕀", iopf = "𝕚", Iota = "Ι", iota = "ι", iprod = "⨼", iquest$1 = "¿", iscr = "𝒾", Iscr = "ℐ", isin = "∈", isindot = "⋵", isinE = "⋹", isins = "⋴", isinsv = "⋳", isinv = "∈", it = "⁢", Itilde = "Ĩ", itilde = "ĩ", Iukcy = "І", iukcy = "і", Iuml$1 = "Ï", iuml$1 = "ï", Jcirc = "Ĵ", jcirc = "ĵ", Jcy = "Й", jcy = "й", Jfr = "𝔍", jfr = "𝔧", jmath = "ȷ", Jopf = "𝕁", jopf = "𝕛", Jscr = "𝒥", jscr = "𝒿", Jsercy = "Ј", jsercy = "ј", Jukcy = "Є", jukcy = "є", Kappa = "Κ", kappa = "κ", kappav = "ϰ", Kcedil = "Ķ", kcedil = "ķ", Kcy = "К", kcy = "к", Kfr = "𝔎", kfr = "𝔨", kgreen = "ĸ", KHcy = "Х", khcy = "х", KJcy = "Ќ", kjcy = "ќ", Kopf = "𝕂", kopf = "𝕜", Kscr = "𝒦", kscr = "𝓀", lAarr = "⇚", Lacute = "Ĺ", lacute = "ĺ", laemptyv = "⦴", lagran = "ℒ", Lambda = "Λ", lambda = "λ", lang = "⟨", Lang = "⟪", langd = "⦑", langle = "⟨", lap = "⪅", Laplacetrf = "ℒ", laquo$1 = "«", larrb = "⇤", larrbfs = "⤟", larr = "←", Larr = "↞", lArr = "⇐", larrfs = "⤝", larrhk = "↩", larrlp = "↫", larrpl = "⤹", larrsim = "⥳", larrtl = "↢", latail = "⤙", lAtail = "⤛", lat = "⪫", late = "⪭", lates = "⪭︀", lbarr = "⤌", lBarr = "⤎", lbbrk = "❲", lbrace = "{", lbrack = "[", lbrke = "⦋", lbrksld = "⦏", lbrkslu = "⦍", Lcaron = "Ľ", lcaron = "ľ", Lcedil = "Ļ", lcedil = "ļ", lceil = "⌈", lcub = "{", Lcy = "Л", lcy = "л", ldca = "⤶", ldquo = "“", ldquor = "„", ldrdhar = "⥧", ldrushar = "⥋", ldsh = "↲", le = "≤", lE = "≦", LeftAngleBracket = "⟨", LeftArrowBar = "⇤", leftarrow = "←", LeftArrow = "←", Leftarrow = "⇐", LeftArrowRightArrow = "⇆", leftarrowtail = "↢", LeftCeiling = "⌈", LeftDoubleBracket = "⟦", LeftDownTeeVector = "⥡", LeftDownVectorBar = "⥙", LeftDownVector = "⇃", LeftFloor = "⌊", leftharpoondown = "↽", leftharpoonup = "↼", leftleftarrows = "⇇", leftrightarrow = "↔", LeftRightArrow = "↔", Leftrightarrow = "⇔", leftrightarrows = "⇆", leftrightharpoons = "⇋", leftrightsquigarrow = "↭", LeftRightVector = "⥎", LeftTeeArrow = "↤", LeftTee = "⊣", LeftTeeVector = "⥚", leftthreetimes = "⋋", LeftTriangleBar = "⧏", LeftTriangle = "⊲", LeftTriangleEqual = "⊴", LeftUpDownVector = "⥑", LeftUpTeeVector = "⥠", LeftUpVectorBar = "⥘", LeftUpVector = "↿", LeftVectorBar = "⥒", LeftVector = "↼", lEg = "⪋", leg = "⋚", leq = "≤", leqq = "≦", leqslant = "⩽", lescc = "⪨", les = "⩽", lesdot = "⩿", lesdoto = "⪁", lesdotor = "⪃", lesg = "⋚︀", lesges = "⪓", lessapprox = "⪅", lessdot = "⋖", lesseqgtr = "⋚", lesseqqgtr = "⪋", LessEqualGreater = "⋚", LessFullEqual = "≦", LessGreater = "≶", lessgtr = "≶", LessLess = "⪡", lesssim = "≲", LessSlantEqual = "⩽", LessTilde = "≲", lfisht = "⥼", lfloor = "⌊", Lfr = "𝔏", lfr = "𝔩", lg = "≶", lgE = "⪑", lHar = "⥢", lhard = "↽", lharu = "↼", lharul = "⥪", lhblk = "▄", LJcy = "Љ", ljcy = "љ", llarr = "⇇", ll = "≪", Ll = "⋘", llcorner = "⌞", Lleftarrow = "⇚", llhard = "⥫", lltri = "◺", Lmidot = "Ŀ", lmidot = "ŀ", lmoustache = "⎰", lmoust = "⎰", lnap = "⪉", lnapprox = "⪉", lne = "⪇", lnE = "≨", lneq = "⪇", lneqq = "≨", lnsim = "⋦", loang = "⟬", loarr = "⇽", lobrk = "⟦", longleftarrow = "⟵", LongLeftArrow = "⟵", Longleftarrow = "⟸", longleftrightarrow = "⟷", LongLeftRightArrow = "⟷", Longleftrightarrow = "⟺", longmapsto = "⟼", longrightarrow = "⟶", LongRightArrow = "⟶", Longrightarrow = "⟹", looparrowleft = "↫", looparrowright = "↬", lopar = "⦅", Lopf = "𝕃", lopf = "𝕝", loplus = "⨭", lotimes = "⨴", lowast = "∗", lowbar = "_", LowerLeftArrow = "↙", LowerRightArrow = "↘", loz = "◊", lozenge = "◊", lozf = "⧫", lpar = "(", lparlt = "⦓", lrarr = "⇆", lrcorner = "⌟", lrhar = "⇋", lrhard = "⥭", lrm = "‎", lrtri = "⊿", lsaquo = "‹", lscr = "𝓁", Lscr = "ℒ", lsh = "↰", Lsh = "↰", lsim = "≲", lsime = "⪍", lsimg = "⪏", lsqb = "[", lsquo = "‘", lsquor = "‚", Lstrok = "Ł", lstrok = "ł", ltcc = "⪦", ltcir = "⩹", lt$2 = "<", LT$1 = "<", Lt = "≪", ltdot = "⋖", lthree = "⋋", ltimes = "⋉", ltlarr = "⥶", ltquest = "⩻", ltri = "◃", ltrie = "⊴", ltrif = "◂", ltrPar = "⦖", lurdshar = "⥊", luruhar = "⥦", lvertneqq = "≨︀", lvnE = "≨︀", macr$1 = "¯", male = "♂", malt = "✠", maltese = "✠", map = "↦", mapsto = "↦", mapstodown = "↧", mapstoleft = "↤", mapstoup = "↥", marker = "▮", mcomma = "⨩", Mcy = "М", mcy = "м", mdash = "—", mDDot = "∺", measuredangle = "∡", MediumSpace = " ", Mellintrf = "ℳ", Mfr = "𝔐", mfr = "𝔪", mho = "℧", micro$1 = "µ", midast = "*", midcir = "⫰", mid = "∣", middot$1 = "·", minusb = "⊟", minus = "−", minusd = "∸", minusdu = "⨪", MinusPlus = "∓", mlcp = "⫛", mldr = "…", mnplus = "∓", models = "⊧", Mopf = "𝕄", mopf = "𝕞", mp = "∓", mscr = "𝓂", Mscr = "ℳ", mstpos = "∾", Mu = "Μ", mu = "μ", multimap = "⊸", mumap = "⊸", nabla = "∇", Nacute = "Ń", nacute = "ń", nang = "∠⃒", nap = "≉", napE = "⩰̸", napid = "≋̸", napos = "ŉ", napprox = "≉", natural = "♮", naturals = "ℕ", natur = "♮", nbsp$1 = " ", nbump = "≎̸", nbumpe = "≏̸", ncap = "⩃", Ncaron = "Ň", ncaron = "ň", Ncedil = "Ņ", ncedil = "ņ", ncong = "≇", ncongdot = "⩭̸", ncup = "⩂", Ncy = "Н", ncy = "н", ndash = "–", nearhk = "⤤", nearr = "↗", neArr = "⇗", nearrow = "↗", ne = "≠", nedot = "≐̸", NegativeMediumSpace = "​", NegativeThickSpace = "​", NegativeThinSpace = "​", NegativeVeryThinSpace = "​", nequiv = "≢", nesear = "⤨", nesim = "≂̸", NestedGreaterGreater = "≫", NestedLessLess = "≪", NewLine = `
`, nexist = "∄", nexists = "∄", Nfr = "𝔑", nfr = "𝔫", ngE = "≧̸", nge = "≱", ngeq = "≱", ngeqq = "≧̸", ngeqslant = "⩾̸", nges = "⩾̸", nGg = "⋙̸", ngsim = "≵", nGt = "≫⃒", ngt = "≯", ngtr = "≯", nGtv = "≫̸", nharr = "↮", nhArr = "⇎", nhpar = "⫲", ni = "∋", nis = "⋼", nisd = "⋺", niv = "∋", NJcy = "Њ", njcy = "њ", nlarr = "↚", nlArr = "⇍", nldr = "‥", nlE = "≦̸", nle = "≰", nleftarrow = "↚", nLeftarrow = "⇍", nleftrightarrow = "↮", nLeftrightarrow = "⇎", nleq = "≰", nleqq = "≦̸", nleqslant = "⩽̸", nles = "⩽̸", nless = "≮", nLl = "⋘̸", nlsim = "≴", nLt = "≪⃒", nlt = "≮", nltri = "⋪", nltrie = "⋬", nLtv = "≪̸", nmid = "∤", NoBreak = "⁠", NonBreakingSpace = " ", nopf = "𝕟", Nopf = "ℕ", Not = "⫬", not$1 = "¬", NotCongruent = "≢", NotCupCap = "≭", NotDoubleVerticalBar = "∦", NotElement = "∉", NotEqual = "≠", NotEqualTilde = "≂̸", NotExists = "∄", NotGreater = "≯", NotGreaterEqual = "≱", NotGreaterFullEqual = "≧̸", NotGreaterGreater = "≫̸", NotGreaterLess = "≹", NotGreaterSlantEqual = "⩾̸", NotGreaterTilde = "≵", NotHumpDownHump = "≎̸", NotHumpEqual = "≏̸", notin = "∉", notindot = "⋵̸", notinE = "⋹̸", notinva = "∉", notinvb = "⋷", notinvc = "⋶", NotLeftTriangleBar = "⧏̸", NotLeftTriangle = "⋪", NotLeftTriangleEqual = "⋬", NotLess = "≮", NotLessEqual = "≰", NotLessGreater = "≸", NotLessLess = "≪̸", NotLessSlantEqual = "⩽̸", NotLessTilde = "≴", NotNestedGreaterGreater = "⪢̸", NotNestedLessLess = "⪡̸", notni = "∌", notniva = "∌", notnivb = "⋾", notnivc = "⋽", NotPrecedes = "⊀", NotPrecedesEqual = "⪯̸", NotPrecedesSlantEqual = "⋠", NotReverseElement = "∌", NotRightTriangleBar = "⧐̸", NotRightTriangle = "⋫", NotRightTriangleEqual = "⋭", NotSquareSubset = "⊏̸", NotSquareSubsetEqual = "⋢", NotSquareSuperset = "⊐̸", NotSquareSupersetEqual = "⋣", NotSubset = "⊂⃒", NotSubsetEqual = "⊈", NotSucceeds = "⊁", NotSucceedsEqual = "⪰̸", NotSucceedsSlantEqual = "⋡", NotSucceedsTilde = "≿̸", NotSuperset = "⊃⃒", NotSupersetEqual = "⊉", NotTilde = "≁", NotTildeEqual = "≄", NotTildeFullEqual = "≇", NotTildeTilde = "≉", NotVerticalBar = "∤", nparallel = "∦", npar = "∦", nparsl = "⫽⃥", npart = "∂̸", npolint = "⨔", npr = "⊀", nprcue = "⋠", nprec = "⊀", npreceq = "⪯̸", npre = "⪯̸", nrarrc = "⤳̸", nrarr = "↛", nrArr = "⇏", nrarrw = "↝̸", nrightarrow = "↛", nRightarrow = "⇏", nrtri = "⋫", nrtrie = "⋭", nsc = "⊁", nsccue = "⋡", nsce = "⪰̸", Nscr = "𝒩", nscr = "𝓃", nshortmid = "∤", nshortparallel = "∦", nsim = "≁", nsime = "≄", nsimeq = "≄", nsmid = "∤", nspar = "∦", nsqsube = "⋢", nsqsupe = "⋣", nsub = "⊄", nsubE = "⫅̸", nsube = "⊈", nsubset = "⊂⃒", nsubseteq = "⊈", nsubseteqq = "⫅̸", nsucc = "⊁", nsucceq = "⪰̸", nsup = "⊅", nsupE = "⫆̸", nsupe = "⊉", nsupset = "⊃⃒", nsupseteq = "⊉", nsupseteqq = "⫆̸", ntgl = "≹", Ntilde$1 = "Ñ", ntilde$1 = "ñ", ntlg = "≸", ntriangleleft = "⋪", ntrianglelefteq = "⋬", ntriangleright = "⋫", ntrianglerighteq = "⋭", Nu = "Ν", nu = "ν", num = "#", numero = "№", numsp = " ", nvap = "≍⃒", nvdash = "⊬", nvDash = "⊭", nVdash = "⊮", nVDash = "⊯", nvge = "≥⃒", nvgt = ">⃒", nvHarr = "⤄", nvinfin = "⧞", nvlArr = "⤂", nvle = "≤⃒", nvlt = "<⃒", nvltrie = "⊴⃒", nvrArr = "⤃", nvrtrie = "⊵⃒", nvsim = "∼⃒", nwarhk = "⤣", nwarr = "↖", nwArr = "⇖", nwarrow = "↖", nwnear = "⤧", Oacute$1 = "Ó", oacute$1 = "ó", oast = "⊛", Ocirc$1 = "Ô", ocirc$1 = "ô", ocir = "⊚", Ocy = "О", ocy = "о", odash = "⊝", Odblac = "Ő", odblac = "ő", odiv = "⨸", odot = "⊙", odsold = "⦼", OElig = "Œ", oelig = "œ", ofcir = "⦿", Ofr = "𝔒", ofr = "𝔬", ogon = "˛", Ograve$1 = "Ò", ograve$1 = "ò", ogt = "⧁", ohbar = "⦵", ohm = "Ω", oint = "∮", olarr = "↺", olcir = "⦾", olcross = "⦻", oline = "‾", olt = "⧀", Omacr = "Ō", omacr = "ō", Omega = "Ω", omega = "ω", Omicron = "Ο", omicron = "ο", omid = "⦶", ominus = "⊖", Oopf = "𝕆", oopf = "𝕠", opar = "⦷", OpenCurlyDoubleQuote = "“", OpenCurlyQuote = "‘", operp = "⦹", oplus = "⊕", orarr = "↻", Or = "⩔", or = "∨", ord = "⩝", order = "ℴ", orderof = "ℴ", ordf$1 = "ª", ordm$1 = "º", origof = "⊶", oror = "⩖", orslope = "⩗", orv = "⩛", oS = "Ⓢ", Oscr = "𝒪", oscr = "ℴ", Oslash$1 = "Ø", oslash$1 = "ø", osol = "⊘", Otilde$1 = "Õ", otilde$1 = "õ", otimesas = "⨶", Otimes = "⨷", otimes = "⊗", Ouml$1 = "Ö", ouml$1 = "ö", ovbar = "⌽", OverBar = "‾", OverBrace = "⏞", OverBracket = "⎴", OverParenthesis = "⏜", para$1 = "¶", parallel = "∥", par = "∥", parsim = "⫳", parsl = "⫽", part = "∂", PartialD = "∂", Pcy = "П", pcy = "п", percnt = "%", period = ".", permil = "‰", perp = "⊥", pertenk = "‱", Pfr = "𝔓", pfr = "𝔭", Phi = "Φ", phi = "φ", phiv = "ϕ", phmmat = "ℳ", phone = "☎", Pi = "Π", pi = "π", pitchfork = "⋔", piv = "ϖ", planck = "ℏ", planckh = "ℎ", plankv = "ℏ", plusacir = "⨣", plusb = "⊞", pluscir = "⨢", plus = "+", plusdo = "∔", plusdu = "⨥", pluse = "⩲", PlusMinus = "±", plusmn$1 = "±", plussim = "⨦", plustwo = "⨧", pm = "±", Poincareplane = "ℌ", pointint = "⨕", popf = "𝕡", Popf = "ℙ", pound$1 = "£", prap = "⪷", Pr = "⪻", pr = "≺", prcue = "≼", precapprox = "⪷", prec = "≺", preccurlyeq = "≼", Precedes = "≺", PrecedesEqual = "⪯", PrecedesSlantEqual = "≼", PrecedesTilde = "≾", preceq = "⪯", precnapprox = "⪹", precneqq = "⪵", precnsim = "⋨", pre = "⪯", prE = "⪳", precsim = "≾", prime = "′", Prime = "″", primes = "ℙ", prnap = "⪹", prnE = "⪵", prnsim = "⋨", prod = "∏", Product = "∏", profalar = "⌮", profline = "⌒", profsurf = "⌓", prop = "∝", Proportional = "∝", Proportion = "∷", propto = "∝", prsim = "≾", prurel = "⊰", Pscr = "𝒫", pscr = "𝓅", Psi = "Ψ", psi = "ψ", puncsp = " ", Qfr = "𝔔", qfr = "𝔮", qint = "⨌", qopf = "𝕢", Qopf = "ℚ", qprime = "⁗", Qscr = "𝒬", qscr = "𝓆", quaternions = "ℍ", quatint = "⨖", quest = "?", questeq = "≟", quot$2 = '"', QUOT$1 = '"', rAarr = "⇛", race = "∽̱", Racute = "Ŕ", racute = "ŕ", radic = "√", raemptyv = "⦳", rang = "⟩", Rang = "⟫", rangd = "⦒", range = "⦥", rangle = "⟩", raquo$1 = "»", rarrap = "⥵", rarrb = "⇥", rarrbfs = "⤠", rarrc = "⤳", rarr = "→", Rarr = "↠", rArr = "⇒", rarrfs = "⤞", rarrhk = "↪", rarrlp = "↬", rarrpl = "⥅", rarrsim = "⥴", Rarrtl = "⤖", rarrtl = "↣", rarrw = "↝", ratail = "⤚", rAtail = "⤜", ratio = "∶", rationals = "ℚ", rbarr = "⤍", rBarr = "⤏", RBarr = "⤐", rbbrk = "❳", rbrace = "}", rbrack = "]", rbrke = "⦌", rbrksld = "⦎", rbrkslu = "⦐", Rcaron = "Ř", rcaron = "ř", Rcedil = "Ŗ", rcedil = "ŗ", rceil = "⌉", rcub = "}", Rcy = "Р", rcy = "р", rdca = "⤷", rdldhar = "⥩", rdquo = "”", rdquor = "”", rdsh = "↳", real = "ℜ", realine = "ℛ", realpart = "ℜ", reals = "ℝ", Re = "ℜ", rect = "▭", reg$1 = "®", REG$1 = "®", ReverseElement = "∋", ReverseEquilibrium = "⇋", ReverseUpEquilibrium = "⥯", rfisht = "⥽", rfloor = "⌋", rfr = "𝔯", Rfr = "ℜ", rHar = "⥤", rhard = "⇁", rharu = "⇀", rharul = "⥬", Rho = "Ρ", rho = "ρ", rhov = "ϱ", RightAngleBracket = "⟩", RightArrowBar = "⇥", rightarrow = "→", RightArrow = "→", Rightarrow = "⇒", RightArrowLeftArrow = "⇄", rightarrowtail = "↣", RightCeiling = "⌉", RightDoubleBracket = "⟧", RightDownTeeVector = "⥝", RightDownVectorBar = "⥕", RightDownVector = "⇂", RightFloor = "⌋", rightharpoondown = "⇁", rightharpoonup = "⇀", rightleftarrows = "⇄", rightleftharpoons = "⇌", rightrightarrows = "⇉", rightsquigarrow = "↝", RightTeeArrow = "↦", RightTee = "⊢", RightTeeVector = "⥛", rightthreetimes = "⋌", RightTriangleBar = "⧐", RightTriangle = "⊳", RightTriangleEqual = "⊵", RightUpDownVector = "⥏", RightUpTeeVector = "⥜", RightUpVectorBar = "⥔", RightUpVector = "↾", RightVectorBar = "⥓", RightVector = "⇀", ring = "˚", risingdotseq = "≓", rlarr = "⇄", rlhar = "⇌", rlm = "‏", rmoustache = "⎱", rmoust = "⎱", rnmid = "⫮", roang = "⟭", roarr = "⇾", robrk = "⟧", ropar = "⦆", ropf = "𝕣", Ropf = "ℝ", roplus = "⨮", rotimes = "⨵", RoundImplies = "⥰", rpar = ")", rpargt = "⦔", rppolint = "⨒", rrarr = "⇉", Rrightarrow = "⇛", rsaquo = "›", rscr = "𝓇", Rscr = "ℛ", rsh = "↱", Rsh = "↱", rsqb = "]", rsquo = "’", rsquor = "’", rthree = "⋌", rtimes = "⋊", rtri = "▹", rtrie = "⊵", rtrif = "▸", rtriltri = "⧎", RuleDelayed = "⧴", ruluhar = "⥨", rx = "℞", Sacute = "Ś", sacute = "ś", sbquo = "‚", scap = "⪸", Scaron = "Š", scaron = "š", Sc = "⪼", sc = "≻", sccue = "≽", sce = "⪰", scE = "⪴", Scedil = "Ş", scedil = "ş", Scirc = "Ŝ", scirc = "ŝ", scnap = "⪺", scnE = "⪶", scnsim = "⋩", scpolint = "⨓", scsim = "≿", Scy = "С", scy = "с", sdotb = "⊡", sdot = "⋅", sdote = "⩦", searhk = "⤥", searr = "↘", seArr = "⇘", searrow = "↘", sect$1 = "§", semi = ";", seswar = "⤩", setminus = "∖", setmn = "∖", sext = "✶", Sfr = "𝔖", sfr = "𝔰", sfrown = "⌢", sharp = "♯", SHCHcy = "Щ", shchcy = "щ", SHcy = "Ш", shcy = "ш", ShortDownArrow = "↓", ShortLeftArrow = "←", shortmid = "∣", shortparallel = "∥", ShortRightArrow = "→", ShortUpArrow = "↑", shy$1 = "­", Sigma = "Σ", sigma = "σ", sigmaf = "ς", sigmav = "ς", sim = "∼", simdot = "⩪", sime = "≃", simeq = "≃", simg = "⪞", simgE = "⪠", siml = "⪝", simlE = "⪟", simne = "≆", simplus = "⨤", simrarr = "⥲", slarr = "←", SmallCircle = "∘", smallsetminus = "∖", smashp = "⨳", smeparsl = "⧤", smid = "∣", smile = "⌣", smt = "⪪", smte = "⪬", smtes = "⪬︀", SOFTcy = "Ь", softcy = "ь", solbar = "⌿", solb = "⧄", sol = "/", Sopf = "𝕊", sopf = "𝕤", spades = "♠", spadesuit = "♠", spar = "∥", sqcap = "⊓", sqcaps = "⊓︀", sqcup = "⊔", sqcups = "⊔︀", Sqrt = "√", sqsub = "⊏", sqsube = "⊑", sqsubset = "⊏", sqsubseteq = "⊑", sqsup = "⊐", sqsupe = "⊒", sqsupset = "⊐", sqsupseteq = "⊒", square = "□", Square = "□", SquareIntersection = "⊓", SquareSubset = "⊏", SquareSubsetEqual = "⊑", SquareSuperset = "⊐", SquareSupersetEqual = "⊒", SquareUnion = "⊔", squarf = "▪", squ = "□", squf = "▪", srarr = "→", Sscr = "𝒮", sscr = "𝓈", ssetmn = "∖", ssmile = "⌣", sstarf = "⋆", Star = "⋆", star = "☆", starf = "★", straightepsilon = "ϵ", straightphi = "ϕ", strns = "¯", sub = "⊂", Sub = "⋐", subdot = "⪽", subE = "⫅", sube = "⊆", subedot = "⫃", submult = "⫁", subnE = "⫋", subne = "⊊", subplus = "⪿", subrarr = "⥹", subset = "⊂", Subset = "⋐", subseteq = "⊆", subseteqq = "⫅", SubsetEqual = "⊆", subsetneq = "⊊", subsetneqq = "⫋", subsim = "⫇", subsub = "⫕", subsup = "⫓", succapprox = "⪸", succ = "≻", succcurlyeq = "≽", Succeeds = "≻", SucceedsEqual = "⪰", SucceedsSlantEqual = "≽", SucceedsTilde = "≿", succeq = "⪰", succnapprox = "⪺", succneqq = "⪶", succnsim = "⋩", succsim = "≿", SuchThat = "∋", sum = "∑", Sum = "∑", sung = "♪", sup1$1 = "¹", sup2$1 = "²", sup3$1 = "³", sup = "⊃", Sup = "⋑", supdot = "⪾", supdsub = "⫘", supE = "⫆", supe = "⊇", supedot = "⫄", Superset = "⊃", SupersetEqual = "⊇", suphsol = "⟉", suphsub = "⫗", suplarr = "⥻", supmult = "⫂", supnE = "⫌", supne = "⊋", supplus = "⫀", supset = "⊃", Supset = "⋑", supseteq = "⊇", supseteqq = "⫆", supsetneq = "⊋", supsetneqq = "⫌", supsim = "⫈", supsub = "⫔", supsup = "⫖", swarhk = "⤦", swarr = "↙", swArr = "⇙", swarrow = "↙", swnwar = "⤪", szlig$1 = "ß", Tab = "	", target = "⌖", Tau = "Τ", tau = "τ", tbrk = "⎴", Tcaron = "Ť", tcaron = "ť", Tcedil = "Ţ", tcedil = "ţ", Tcy = "Т", tcy = "т", tdot = "⃛", telrec = "⌕", Tfr = "𝔗", tfr = "𝔱", there4 = "∴", therefore = "∴", Therefore = "∴", Theta = "Θ", theta = "θ", thetasym = "ϑ", thetav = "ϑ", thickapprox = "≈", thicksim = "∼", ThickSpace = "  ", ThinSpace = " ", thinsp = " ", thkap = "≈", thksim = "∼", THORN$1 = "Þ", thorn$1 = "þ", tilde = "˜", Tilde = "∼", TildeEqual = "≃", TildeFullEqual = "≅", TildeTilde = "≈", timesbar = "⨱", timesb = "⊠", times$1 = "×", timesd = "⨰", tint = "∭", toea = "⤨", topbot = "⌶", topcir = "⫱", top = "⊤", Topf = "𝕋", topf = "𝕥", topfork = "⫚", tosa = "⤩", tprime = "‴", trade = "™", TRADE = "™", triangle = "▵", triangledown = "▿", triangleleft = "◃", trianglelefteq = "⊴", triangleq = "≜", triangleright = "▹", trianglerighteq = "⊵", tridot = "◬", trie = "≜", triminus = "⨺", TripleDot = "⃛", triplus = "⨹", trisb = "⧍", tritime = "⨻", trpezium = "⏢", Tscr = "𝒯", tscr = "𝓉", TScy = "Ц", tscy = "ц", TSHcy = "Ћ", tshcy = "ћ", Tstrok = "Ŧ", tstrok = "ŧ", twixt = "≬", twoheadleftarrow = "↞", twoheadrightarrow = "↠", Uacute$1 = "Ú", uacute$1 = "ú", uarr = "↑", Uarr = "↟", uArr = "⇑", Uarrocir = "⥉", Ubrcy = "Ў", ubrcy = "ў", Ubreve = "Ŭ", ubreve = "ŭ", Ucirc$1 = "Û", ucirc$1 = "û", Ucy = "У", ucy = "у", udarr = "⇅", Udblac = "Ű", udblac = "ű", udhar = "⥮", ufisht = "⥾", Ufr = "𝔘", ufr = "𝔲", Ugrave$1 = "Ù", ugrave$1 = "ù", uHar = "⥣", uharl = "↿", uharr = "↾", uhblk = "▀", ulcorn = "⌜", ulcorner = "⌜", ulcrop = "⌏", ultri = "◸", Umacr = "Ū", umacr = "ū", uml$1 = "¨", UnderBar = "_", UnderBrace = "⏟", UnderBracket = "⎵", UnderParenthesis = "⏝", Union = "⋃", UnionPlus = "⊎", Uogon = "Ų", uogon = "ų", Uopf = "𝕌", uopf = "𝕦", UpArrowBar = "⤒", uparrow = "↑", UpArrow = "↑", Uparrow = "⇑", UpArrowDownArrow = "⇅", updownarrow = "↕", UpDownArrow = "↕", Updownarrow = "⇕", UpEquilibrium = "⥮", upharpoonleft = "↿", upharpoonright = "↾", uplus = "⊎", UpperLeftArrow = "↖", UpperRightArrow = "↗", upsi = "υ", Upsi = "ϒ", upsih = "ϒ", Upsilon = "Υ", upsilon = "υ", UpTeeArrow = "↥", UpTee = "⊥", upuparrows = "⇈", urcorn = "⌝", urcorner = "⌝", urcrop = "⌎", Uring = "Ů", uring = "ů", urtri = "◹", Uscr = "𝒰", uscr = "𝓊", utdot = "⋰", Utilde = "Ũ", utilde = "ũ", utri = "▵", utrif = "▴", uuarr = "⇈", Uuml$1 = "Ü", uuml$1 = "ü", uwangle = "⦧", vangrt = "⦜", varepsilon = "ϵ", varkappa = "ϰ", varnothing = "∅", varphi = "ϕ", varpi = "ϖ", varpropto = "∝", varr = "↕", vArr = "⇕", varrho = "ϱ", varsigma = "ς", varsubsetneq = "⊊︀", varsubsetneqq = "⫋︀", varsupsetneq = "⊋︀", varsupsetneqq = "⫌︀", vartheta = "ϑ", vartriangleleft = "⊲", vartriangleright = "⊳", vBar = "⫨", Vbar = "⫫", vBarv = "⫩", Vcy = "В", vcy = "в", vdash = "⊢", vDash = "⊨", Vdash = "⊩", VDash = "⊫", Vdashl = "⫦", veebar = "⊻", vee = "∨", Vee = "⋁", veeeq = "≚", vellip = "⋮", verbar = "|", Verbar = "‖", vert = "|", Vert = "‖", VerticalBar = "∣", VerticalLine = "|", VerticalSeparator = "❘", VerticalTilde = "≀", VeryThinSpace = " ", Vfr = "𝔙", vfr = "𝔳", vltri = "⊲", vnsub = "⊂⃒", vnsup = "⊃⃒", Vopf = "𝕍", vopf = "𝕧", vprop = "∝", vrtri = "⊳", Vscr = "𝒱", vscr = "𝓋", vsubnE = "⫋︀", vsubne = "⊊︀", vsupnE = "⫌︀", vsupne = "⊋︀", Vvdash = "⊪", vzigzag = "⦚", Wcirc = "Ŵ", wcirc = "ŵ", wedbar = "⩟", wedge = "∧", Wedge = "⋀", wedgeq = "≙", weierp = "℘", Wfr = "𝔚", wfr = "𝔴", Wopf = "𝕎", wopf = "𝕨", wp = "℘", wr = "≀", wreath = "≀", Wscr = "𝒲", wscr = "𝓌", xcap = "⋂", xcirc = "◯", xcup = "⋃", xdtri = "▽", Xfr = "𝔛", xfr = "𝔵", xharr = "⟷", xhArr = "⟺", Xi = "Ξ", xi = "ξ", xlarr = "⟵", xlArr = "⟸", xmap = "⟼", xnis = "⋻", xodot = "⨀", Xopf = "𝕏", xopf = "𝕩", xoplus = "⨁", xotime = "⨂", xrarr = "⟶", xrArr = "⟹", Xscr = "𝒳", xscr = "𝓍", xsqcup = "⨆", xuplus = "⨄", xutri = "△", xvee = "⋁", xwedge = "⋀", Yacute$1 = "Ý", yacute$1 = "ý", YAcy = "Я", yacy = "я", Ycirc = "Ŷ", ycirc = "ŷ", Ycy = "Ы", ycy = "ы", yen$1 = "¥", Yfr = "𝔜", yfr = "𝔶", YIcy = "Ї", yicy = "ї", Yopf = "𝕐", yopf = "𝕪", Yscr = "𝒴", yscr = "𝓎", YUcy = "Ю", yucy = "ю", yuml$1 = "ÿ", Yuml = "Ÿ", Zacute = "Ź", zacute = "ź", Zcaron = "Ž", zcaron = "ž", Zcy = "З", zcy = "з", Zdot = "Ż", zdot = "ż", zeetrf = "ℨ", ZeroWidthSpace = "​", Zeta = "Ζ", zeta = "ζ", zfr = "𝔷", Zfr = "ℨ", ZHcy = "Ж", zhcy = "ж", zigrarr = "⇝", zopf = "𝕫", Zopf = "ℤ", Zscr = "𝒵", zscr = "𝓏", zwj = "‍", zwnj = "‌", require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  in: "∈",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  Map: "⤅",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
}, Aacute = "Á", aacute = "á", Acirc = "Â", acirc = "â", acute = "´", AElig = "Æ", aelig = "æ", Agrave = "À", agrave = "à", amp$1 = "&", AMP = "&", Aring = "Å", aring = "å", Atilde = "Ã", atilde = "ã", Auml = "Ä", auml = "ä", brvbar = "¦", Ccedil = "Ç", ccedil = "ç", cedil = "¸", cent = "¢", copy = "©", COPY = "©", curren = "¤", deg = "°", divide = "÷", Eacute = "É", eacute = "é", Ecirc = "Ê", ecirc = "ê", Egrave = "È", egrave = "è", ETH = "Ð", eth = "ð", Euml = "Ë", euml = "ë", frac12 = "½", frac14 = "¼", frac34 = "¾", gt$1 = ">", GT = ">", Iacute = "Í", iacute = "í", Icirc = "Î", icirc = "î", iexcl = "¡", Igrave = "Ì", igrave = "ì", iquest = "¿", Iuml = "Ï", iuml = "ï", laquo = "«", lt$1 = "<", LT = "<", macr = "¯", micro = "µ", middot = "·", nbsp = " ", not = "¬", Ntilde = "Ñ", ntilde = "ñ", Oacute = "Ó", oacute = "ó", Ocirc = "Ô", ocirc = "ô", Ograve = "Ò", ograve = "ò", ordf = "ª", ordm = "º", Oslash = "Ø", oslash = "ø", Otilde = "Õ", otilde = "õ", Ouml = "Ö", ouml = "ö", para = "¶", plusmn = "±", pound = "£", quot$1 = '"', QUOT = '"', raquo = "»", reg = "®", REG = "®", sect = "§", shy = "­", sup1 = "¹", sup2 = "²", sup3 = "³", szlig = "ß", THORN = "Þ", thorn = "þ", times = "×", Uacute = "Ú", uacute = "ú", Ucirc = "Û", ucirc = "û", Ugrave = "Ù", ugrave = "ù", uml = "¨", Uuml = "Ü", uuml = "ü", Yacute = "Ý", yacute = "ý", yen = "¥", yuml = "ÿ", require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
}, amp = "&", apos = "'", gt = ">", lt = "<", quot = '"', require$$0$1 = {
  amp,
  apos,
  gt,
  lt,
  quot
}, decode_codepoint = {}, require$$0$2 = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: !0 });
var decode_json_1 = __importDefault$2(require$$0$2), fromCodePoint$2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(lr) {
    var ar = "";
    return lr > 65535 && (lr -= 65536, ar += String.fromCharCode(lr >>> 10 & 1023 | 55296), lr = 56320 | lr & 1023), ar += String.fromCharCode(lr), ar;
  }
);
function decodeCodePoint(lr) {
  return lr >= 55296 && lr <= 57343 || lr > 1114111 ? "�" : (lr in decode_json_1.default && (lr = decode_json_1.default[lr]), fromCodePoint$2(lr));
}
decode_codepoint.default = decodeCodePoint;
var __importDefault$1$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(decode, "__esModule", { value: !0 });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$1$1(require$$1$1), legacy_json_1 = __importDefault$1$1(require$$1), xml_json_1$1 = __importDefault$1$1(require$$0$1), decode_codepoint_1 = __importDefault$1$1(decode_codepoint), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(lr) {
  var ar = getReplacer(lr);
  return function(cr) {
    return String(cr).replace(strictEntityRe, ar);
  };
}
var sorter = function(lr, ar) {
  return lr < ar ? 1 : -1;
};
decode.decodeHTML = function() {
  for (var lr = Object.keys(legacy_json_1.default).sort(sorter), ar = Object.keys(entities_json_1$1.default).sort(sorter), cr = 0, ur = 0; cr < ar.length; cr++)
    lr[ur] === ar[cr] ? (ar[cr] += ";?", ur++) : ar[cr] += ";";
  var fr = new RegExp("&(?:" + ar.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), dr = getReplacer(entities_json_1$1.default);
  function hr(gr) {
    return gr.substr(-1) !== ";" && (gr += ";"), dr(gr);
  }
  return function(gr) {
    return String(gr).replace(fr, hr);
  };
}();
function getReplacer(lr) {
  return function(cr) {
    if (cr.charAt(1) === "#") {
      var ur = cr.charAt(2);
      return ur === "X" || ur === "x" ? decode_codepoint_1.default(parseInt(cr.substr(3), 16)) : decode_codepoint_1.default(parseInt(cr.substr(2), 10));
    }
    return lr[cr.slice(1, -1)] || cr;
  };
}
var encode = {}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(encode, "__esModule", { value: !0 });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault$3(require$$0$1), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$3(require$$1$1), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(lr) {
  return Object.keys(lr).sort().reduce(function(ar, cr) {
    return ar[lr[cr]] = "&" + cr + ";", ar;
  }, {});
}
function getInverseReplacer(lr) {
  for (var ar = [], cr = [], ur = 0, fr = Object.keys(lr); ur < fr.length; ur++) {
    var dr = fr[ur];
    dr.length === 1 ? ar.push("\\" + dr) : cr.push(dr);
  }
  ar.sort();
  for (var hr = 0; hr < ar.length - 1; hr++) {
    for (var gr = hr; gr < ar.length - 1 && ar[gr].charCodeAt(1) + 1 === ar[gr + 1].charCodeAt(1); )
      gr += 1;
    var vr = 1 + gr - hr;
    vr < 3 || ar.splice(hr, vr, ar[hr] + "-" + ar[gr]);
  }
  return cr.unshift("[" + ar.join("") + "]"), new RegExp(cr.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(lr) {
      return lr.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(lr) {
      return (lr.charCodeAt(0) - 55296) * 1024 + lr.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function singleCharReplacer(lr) {
  return "&#x" + (lr.length > 1 ? getCodePoint(lr) : lr.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(lr, ar) {
  return function(cr) {
    return cr.replace(ar, function(ur) {
      return lr[ur];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
function escape$2(lr) {
  return lr.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape$2;
function escapeUTF8(lr) {
  return lr.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(lr) {
  return function(ar) {
    return ar.replace(reEscapeChars, function(cr) {
      return lr[cr] || singleCharReplacer(cr);
    });
  };
}
(function(lr) {
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.decodeXMLStrict = lr.decodeHTML5Strict = lr.decodeHTML4Strict = lr.decodeHTML5 = lr.decodeHTML4 = lr.decodeHTMLStrict = lr.decodeHTML = lr.decodeXML = lr.encodeHTML5 = lr.encodeHTML4 = lr.escapeUTF8 = lr.escape = lr.encodeNonAsciiHTML = lr.encodeHTML = lr.encodeXML = lr.encode = lr.decodeStrict = lr.decode = void 0;
  var ar = decode, cr = encode;
  function ur(vr, mr) {
    return (!mr || mr <= 0 ? ar.decodeXML : ar.decodeHTML)(vr);
  }
  lr.decode = ur;
  function fr(vr, mr) {
    return (!mr || mr <= 0 ? ar.decodeXML : ar.decodeHTMLStrict)(vr);
  }
  lr.decodeStrict = fr;
  function dr(vr, mr) {
    return (!mr || mr <= 0 ? cr.encodeXML : cr.encodeHTML)(vr);
  }
  lr.encode = dr;
  var hr = encode;
  Object.defineProperty(lr, "encodeXML", { enumerable: !0, get: function() {
    return hr.encodeXML;
  } }), Object.defineProperty(lr, "encodeHTML", { enumerable: !0, get: function() {
    return hr.encodeHTML;
  } }), Object.defineProperty(lr, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return hr.encodeNonAsciiHTML;
  } }), Object.defineProperty(lr, "escape", { enumerable: !0, get: function() {
    return hr.escape;
  } }), Object.defineProperty(lr, "escapeUTF8", { enumerable: !0, get: function() {
    return hr.escapeUTF8;
  } }), Object.defineProperty(lr, "encodeHTML4", { enumerable: !0, get: function() {
    return hr.encodeHTML;
  } }), Object.defineProperty(lr, "encodeHTML5", { enumerable: !0, get: function() {
    return hr.encodeHTML;
  } });
  var gr = decode;
  Object.defineProperty(lr, "decodeXML", { enumerable: !0, get: function() {
    return gr.decodeXML;
  } }), Object.defineProperty(lr, "decodeHTML", { enumerable: !0, get: function() {
    return gr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return gr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeHTML4", { enumerable: !0, get: function() {
    return gr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTML5", { enumerable: !0, get: function() {
    return gr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return gr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return gr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeXMLStrict", { enumerable: !0, get: function() {
    return gr.decodeXML;
  } });
})(lib);
var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", C_BACKSLASH$1 = 92, reBackslashOrAmp = /[\\&]/, ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi"), XMLSPECIAL = '[&<>"]', reXmlSpecial = new RegExp(XMLSPECIAL, "g"), unescapeChar = function(lr) {
  return lr.charCodeAt(0) === C_BACKSLASH$1 ? lr.charAt(1) : lib.decodeHTML(lr);
};
function unescapeString(lr) {
  return reBackslashOrAmp.test(lr) ? lr.replace(reEntityOrEscapedChar, unescapeChar) : lr;
}
function normalizeURI(lr) {
  try {
    return encode_1(lr);
  } catch (ar) {
    return lr;
  }
}
function replaceUnsafeChar(lr) {
  switch (lr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return lr;
  }
}
function escapeXml(lr) {
  return reXmlSpecial.test(lr) ? lr.replace(reXmlSpecial, replaceUnsafeChar) : lr;
}
function repeat(lr, ar) {
  for (var cr = [], ur = 0; ur < ar; ur++)
    cr.push(lr);
  return cr.join("");
}
function isEmpty(lr) {
  return lr ? !/[^ \t]+/.test(lr) : !0;
}
var NodeWalker = (
  /** @class */
  function() {
    function lr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return lr.prototype.next = function() {
      var ar = this.current, cr = this.entering;
      if (ar === null)
        return null;
      var ur = isContainer$1(ar);
      return cr && ur ? ar.firstChild ? (this.current = ar.firstChild, this.entering = !0) : this.entering = !1 : ar === this.root ? this.current = null : ar.next === null ? (this.current = ar.parent, this.entering = !1) : (this.current = ar.next, this.entering = !0), { entering: cr, node: ar };
    }, lr.prototype.resumeAt = function(ar, cr) {
      this.current = ar, this.entering = cr === !0;
    }, lr;
  }()
);
function isContainer$1(lr) {
  switch (lr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
var lastNodeId = 1, nodeMap = {};
function getNodeById(lr) {
  return nodeMap[lr];
}
function removeNodeById(lr) {
  delete nodeMap[lr];
}
function removeAllNode() {
  nodeMap = {};
}
var Node$1 = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, ar === "document" ? this.id = -1 : this.id = lastNodeId++, this.type = ar, this.sourcepos = cr, nodeMap[this.id] = this;
    }
    return lr.prototype.isContainer = function() {
      return isContainer$1(this);
    }, lr.prototype.unlink = function() {
      this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
    }, lr.prototype.replaceWith = function(ar) {
      this.insertBefore(ar), this.unlink();
    }, lr.prototype.insertAfter = function(ar) {
      ar.unlink(), ar.next = this.next, ar.next && (ar.next.prev = ar), ar.prev = this, this.next = ar, this.parent && (ar.parent = this.parent, ar.next || (ar.parent.lastChild = ar));
    }, lr.prototype.insertBefore = function(ar) {
      ar.unlink(), ar.prev = this.prev, ar.prev && (ar.prev.next = ar), ar.next = this, this.prev = ar, ar.parent = this.parent, ar.prev || (ar.parent.firstChild = ar);
    }, lr.prototype.appendChild = function(ar) {
      ar.unlink(), ar.parent = this, this.lastChild ? (this.lastChild.next = ar, ar.prev = this.lastChild, this.lastChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, lr.prototype.prependChild = function(ar) {
      ar.unlink(), ar.parent = this, this.firstChild ? (this.firstChild.prev = ar, ar.next = this.firstChild, this.firstChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, lr.prototype.walker = function() {
      return new NodeWalker(this);
    }, lr;
  }()
), BlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr, ur) || this;
      return fr.open = !0, fr.lineOffsets = null, fr.stringContent = null, fr.lastLineBlank = !1, fr.lastLineChecked = !1, fr.type = cr, fr;
    }
    return ar;
  }(Node$1)
), ListNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.listData = null, cr;
    }
    return ar;
  }(BlockNode)
), HeadingNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.level = 0, cr.headingType = "atx", cr;
    }
    return ar;
  }(BlockNode)
), CodeBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.isFenced = !1, cr.fenceChar = null, cr.fenceLength = 0, cr.fenceOffset = -1, cr.info = null, cr.infoPadding = 0, cr;
    }
    return ar;
  }(BlockNode)
), TableNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.columns = [], cr;
    }
    return ar;
  }(BlockNode)
), TableCellNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.startIdx = 0, cr.endIdx = 0, cr.paddingLeft = 0, cr.paddingRight = 0, cr.ignored = !1, cr;
    }
    return ar;
  }(BlockNode)
), RefDefNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.title = "", cr.dest = "", cr.label = "", cr;
    }
    return ar;
  }(BlockNode)
), CustomBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.syntaxLength = 0, cr.offset = -1, cr.info = "", cr;
    }
    return ar;
  }(BlockNode)
), HtmlBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.htmlBlockType = -1, cr;
    }
    return ar;
  }(BlockNode)
), LinkNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.destination = null, cr.title = null, cr.extendedAutolink = !1, cr;
    }
    return ar;
  }(Node$1)
), CodeNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.tickCount = 0, cr;
    }
    return ar;
  }(Node$1)
), CustomInlineNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.info = "", cr;
    }
    return ar;
  }(Node$1)
);
function createNode$1(lr, ar) {
  switch (lr) {
    case "heading":
      return new HeadingNode(lr, ar);
    case "list":
    case "item":
      return new ListNode(lr, ar);
    case "link":
    case "image":
      return new LinkNode(lr, ar);
    case "codeBlock":
      return new CodeBlockNode(lr, ar);
    case "htmlBlock":
      return new HtmlBlockNode(lr, ar);
    case "table":
      return new TableNode(lr, ar);
    case "tableCell":
      return new TableCellNode(lr, ar);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new BlockNode(lr, ar);
    case "code":
      return new CodeNode(lr, ar);
    case "refDef":
      return new RefDefNode(lr, ar);
    case "customBlock":
      return new CustomBlockNode(lr, ar);
    case "customInline":
      return new CustomInlineNode(lr, ar);
    default:
      return new Node$1(lr, ar);
  }
}
function isCodeBlock(lr) {
  return lr.type === "codeBlock";
}
function isHtmlBlock(lr) {
  return lr.type === "htmlBlock";
}
function isHeading(lr) {
  return lr.type === "heading";
}
function isList(lr) {
  return lr.type === "list";
}
function isTable(lr) {
  return lr.type === "table";
}
function isRefDef(lr) {
  return lr.type === "refDef";
}
function isCustomBlock(lr) {
  return lr.type === "customBlock";
}
function isCustomInline(lr) {
  return lr.type === "customInline";
}
function text$1(lr, ar) {
  var cr = createNode$1("text", ar);
  return cr.literal = lr, cr;
}
var TAGNAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTENAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLEQUOTEDVALUE = "'[^']*'", DOUBLEQUOTEDVALUE = '"[^"]*"', ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")", ATTRIBUTEVALUESPEC = "(?:\\s*=\\s*" + ATTRIBUTEVALUE + ")", ATTRIBUTE = "(?:\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)", OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*\\s*/?>", CLOSETAG = "</" + TAGNAME + "\\s*[>]", HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", PROCESSINGINSTRUCTION = "[<][?].*?[?][>]", DECLARATION = "<![A-Z]+\\s+[^>]*>", CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")", reHtmlTag = new RegExp("^" + HTMLTAG, "i");
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var fromCodePoint;
if (String.fromCodePoint)
  fromCodePoint = function(lr) {
    try {
      return String.fromCodePoint(lr);
    } catch (ar) {
      if (ar instanceof RangeError)
        return String.fromCharCode(65533);
      throw ar;
    }
  };
else {
  var stringFromCharCode_1 = String.fromCharCode, floor_1 = Math.floor;
  fromCodePoint = function() {
    for (var lr = [], ar = 0; ar < arguments.length; ar++)
      lr[ar] = arguments[ar];
    var cr = 16384, ur = [], fr, dr, hr = -1, gr = lr.length;
    if (!gr)
      return "";
    for (var vr = ""; ++hr < gr; ) {
      var mr = Number(lr[hr]);
      if (!isFinite(mr) || // `NaN`, `+Infinity`, or `-Infinity`
      mr < 0 || // not a valid Unicode code point
      mr > 1114111 || // not a valid Unicode code point
      floor_1(mr) !== mr)
        return String.fromCharCode(65533);
      mr <= 65535 ? ur.push(mr) : (mr -= 65536, fr = (mr >> 10) + 55296, dr = mr % 1024 + 56320, ur.push(fr, dr)), (hr + 1 === gr || ur.length > cr) && (vr += stringFromCharCode_1.apply(void 0, ur), ur.length = 0);
    }
    return vr;
  };
}
var fromCodePoint$1 = fromCodePoint, DOMAIN = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", PATH = "[^<\\s]*[^<?!.,:*_?~\\s]", EMAIL = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function trimUnmatchedTrailingParens(lr) {
  var ar = /\)+$/.exec(lr);
  if (ar) {
    for (var cr = 0, ur = 0, fr = lr; ur < fr.length; ur++) {
      var dr = fr[ur];
      dr === "(" ? cr < 0 ? cr = 1 : cr += 1 : dr === ")" && (cr -= 1);
    }
    if (cr < 0) {
      var hr = Math.min(-cr, ar[0].length);
      return lr.substring(0, lr.length - hr);
    }
  }
  return lr;
}
function trimTrailingEntity(lr) {
  return lr.replace(/&[A-Za-z0-9]+;$/, "");
}
function parseEmailLink(lr) {
  for (var ar = new RegExp(EMAIL, "g"), cr = [], ur; ur = ar.exec(lr); ) {
    var fr = ur[0];
    /[_-]+$/.test(fr) || cr.push({
      text: fr,
      range: [ur.index, ur.index + fr.length - 1],
      url: "mailto:" + fr
    });
  }
  return cr;
}
function parseUrlLink(lr) {
  for (var ar = new RegExp("(www|https?://)." + DOMAIN + PATH, "g"), cr = [], ur; ur = ar.exec(lr); ) {
    var fr = trimTrailingEntity(trimUnmatchedTrailingParens(ur[0])), dr = ur[1] === "www" ? "http://" : "";
    cr.push({
      text: fr,
      range: [ur.index, ur.index + fr.length - 1],
      url: "" + dr + fr
    });
  }
  return cr;
}
function baseAutolinkParser(lr) {
  return __spreadArray(__spreadArray([], parseUrlLink(lr)), parseEmailLink(lr)).sort(function(ar, cr) {
    return ar.range[0] - cr.range[0];
  });
}
function convertExtAutoLinks(lr, ar) {
  typeof ar == "boolean" && (ar = baseAutolinkParser);
  for (var cr, ur = function() {
    var fr = cr.entering, dr = cr.node;
    if (fr && dr.type === "text" && dr.parent.type !== "link") {
      var hr = dr.literal, gr = ar(hr);
      if (!gr || !gr.length)
        return "continue";
      for (var vr = 0, mr = dr.sourcepos[0], br = mr[0], yr = mr[1], kr = function(Wr, Zr) {
        return [
          [br, yr + Wr],
          [br, yr + Zr]
        ];
      }, Tr = [], _r = 0, Er = gr; _r < Er.length; _r++) {
        var xr = Er[_r], Cr = xr.range, Ar = xr.url, Lr = xr.text;
        Cr[0] > vr && Tr.push(text$1(hr.substring(vr, Cr[0]), kr(vr, Cr[0] - 1)));
        var Dr = createNode$1("link", kr.apply(void 0, Cr));
        Dr.appendChild(text$1(Lr, kr.apply(void 0, Cr))), Dr.destination = Ar, Dr.extendedAutolink = !0, Tr.push(Dr), vr = Cr[1] + 1;
      }
      vr < hr.length && Tr.push(text$1(hr.substring(vr), kr(vr, hr.length - 1)));
      for (var Nr = 0, Hr = Tr; Nr < Hr.length; Nr++) {
        var $r = Hr[Nr];
        dr.insertBefore($r);
      }
      dr.unlink();
    }
  }; cr = lr.next(); )
    ur();
}
function last(lr) {
  return lr[lr.length - 1];
}
function normalizeReference(lr) {
  return lr.slice(1, lr.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function iterateObject(lr, ar) {
  Object.keys(lr).forEach(function(cr) {
    ar(cr, lr[cr]);
  });
}
function omit(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  var ur = __assign({}, lr);
  return ar.forEach(function(fr) {
    delete ur[fr];
  }), ur;
}
function isEmptyObj(lr) {
  return !Object.keys(lr).length;
}
function clearObj(lr) {
  Object.keys(lr).forEach(function(ar) {
    delete lr[ar];
  });
}
var C_NEWLINE = 10, C_ASTERISK = 42, C_UNDERSCORE = 95, C_BACKTICK = 96, C_OPEN_BRACKET$1 = 91, C_CLOSE_BRACKET = 93, C_TILDE = 126, C_LESSTHAN$1 = 60, C_BANG = 33, C_BACKSLASH = 92, C_AMPERSAND = 38, C_OPEN_PAREN = 40, C_CLOSE_PAREN = 41, C_COLON = 58, C_SINGLEQUOTE = 39, C_DOUBLEQUOTE = 34, C_DOLLAR = 36, ESCAPED_CHAR = "\\\\" + ESCAPABLE, rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), reLinkTitle = new RegExp('^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"|' + ("'(" + ESCAPED_CHAR + "|[^'\\x00])*'") + "|" + ("\\((" + ESCAPED_CHAR + "|[^()\\x00])*\\))")), reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, reEscapable = new RegExp("^" + ESCAPABLE), reEntityHere = new RegExp("^" + ENTITY, "i"), reTicks = /`+/, reTicksHere = /^`+/, reEllipses = /\.\.\./g, reDash = /--+/g, reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, reSpnl = /^ *(?:\n *)?/, reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/, reUnicodeWhitespaceChar = /^\s/, reFinalSpace = / *$/, reInitialSpace = /^ */, reSpaceAtEndOfLine = /^ *(?:\n|$)/, reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, reMain = /^[^\n`\[\]\\!<&*_'"~$]+/m, InlineParser = (
  /** @class */
  function() {
    function lr(ar) {
      this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = ar;
    }
    return lr.prototype.sourcepos = function(ar, cr) {
      var ur = this.linePosOffset + this.lineOffsets[this.lineIdx], fr = this.lineStartNum + this.lineIdx, dr = [fr, ar + ur];
      return typeof cr == "number" ? [dr, [fr, cr + ur]] : dr;
    }, lr.prototype.nextLine = function() {
      this.lineIdx += 1, this.linePosOffset = -this.pos;
    }, lr.prototype.match = function(ar) {
      var cr = ar.exec(this.subject.slice(this.pos));
      return cr === null ? null : (this.pos += cr.index + cr[0].length, cr[0]);
    }, lr.prototype.peek = function() {
      return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
    }, lr.prototype.spnl = function() {
      return this.match(reSpnl), !0;
    }, lr.prototype.parseBackticks = function(ar) {
      var cr = this.pos + 1, ur = this.match(reTicksHere);
      if (ur === null)
        return !1;
      for (var fr = this.pos, dr; (dr = this.match(reTicks)) !== null; )
        if (dr === ur) {
          var hr = this.subject.slice(fr, this.pos - ur.length), gr = this.sourcepos(cr, this.pos), vr = hr.split(`
`);
          if (vr.length > 1) {
            var mr = last(vr);
            this.lineIdx += vr.length - 1, this.linePosOffset = -(this.pos - mr.length - ur.length), gr[1] = this.sourcepos(this.pos), hr = vr.join(" ");
          }
          var br = createNode$1("code", gr);
          return hr.length > 0 && hr.match(/[^ ]/) !== null && hr[0] == " " && hr[hr.length - 1] == " " ? br.literal = hr.slice(1, hr.length - 1) : br.literal = hr, br.tickCount = ur.length, ar.appendChild(br), !0;
        }
      return this.pos = fr, ar.appendChild(text$1(ur, this.sourcepos(cr, this.pos - 1))), !0;
    }, lr.prototype.parseBackslash = function(ar) {
      var cr = this.subject, ur;
      this.pos += 1;
      var fr = this.pos;
      return this.peek() === C_NEWLINE ? (this.pos += 1, ur = createNode$1("linebreak", this.sourcepos(this.pos - 1, this.pos)), ar.appendChild(ur), this.nextLine()) : reEscapable.test(cr.charAt(this.pos)) ? (ar.appendChild(text$1(cr.charAt(this.pos), this.sourcepos(fr, this.pos))), this.pos += 1) : ar.appendChild(text$1("\\", this.sourcepos(fr, fr))), !0;
    }, lr.prototype.parseAutolink = function(ar) {
      var cr, ur, fr, dr = this.pos + 1;
      return (cr = this.match(reEmailAutolink)) ? (ur = cr.slice(1, cr.length - 1), fr = createNode$1("link", this.sourcepos(dr, this.pos)), fr.destination = normalizeURI("mailto:" + ur), fr.title = "", fr.appendChild(text$1(ur, this.sourcepos(dr + 1, this.pos - 1))), ar.appendChild(fr), !0) : (cr = this.match(reAutolink)) ? (ur = cr.slice(1, cr.length - 1), fr = createNode$1("link", this.sourcepos(dr, this.pos)), fr.destination = normalizeURI(ur), fr.title = "", fr.appendChild(text$1(ur, this.sourcepos(dr + 1, this.pos - 1))), ar.appendChild(fr), !0) : !1;
    }, lr.prototype.parseHtmlTag = function(ar) {
      var cr = this.pos + 1, ur = this.match(reHtmlTag);
      if (ur === null)
        return !1;
      var fr = createNode$1("htmlInline", this.sourcepos(cr, this.pos));
      return fr.literal = ur, ar.appendChild(fr), !0;
    }, lr.prototype.scanDelims = function(ar) {
      var cr = 0, ur = this.pos;
      if (ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE)
        cr++, this.pos++;
      else
        for (; this.peek() === ar; )
          cr++, this.pos++;
      if (cr === 0 || cr < 2 && (ar === C_TILDE || ar === C_DOLLAR))
        return this.pos = ur, null;
      var fr = ur === 0 ? `
` : this.subject.charAt(ur - 1), dr = this.peek(), hr;
      dr === -1 ? hr = `
` : hr = fromCodePoint$1(dr);
      var gr = reUnicodeWhitespaceChar.test(hr), vr = rePunctuation.test(hr), mr = reUnicodeWhitespaceChar.test(fr), br = rePunctuation.test(fr), yr = !gr && (!vr || mr || br), kr = !mr && (!br || gr || vr), Tr, _r;
      return ar === C_UNDERSCORE ? (Tr = yr && (!kr || br), _r = kr && (!yr || vr)) : ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE ? (Tr = yr && !kr, _r = kr) : ar === C_DOLLAR ? (Tr = !gr, _r = !mr) : (Tr = yr, _r = kr), this.pos = ur, { numdelims: cr, canOpen: Tr, canClose: _r };
    }, lr.prototype.handleDelim = function(ar, cr) {
      var ur = this.scanDelims(ar);
      if (!ur)
        return !1;
      var fr = ur.numdelims, dr = this.pos + 1, hr;
      this.pos += fr, ar === C_SINGLEQUOTE ? hr = "’" : ar === C_DOUBLEQUOTE ? hr = "“" : hr = this.subject.slice(dr - 1, this.pos);
      var gr = text$1(hr, this.sourcepos(dr, this.pos));
      return cr.appendChild(gr), (ur.canOpen || ur.canClose) && (this.options.smart || ar !== C_SINGLEQUOTE && ar !== C_DOUBLEQUOTE) && (this.delimiters = {
        cc: ar,
        numdelims: fr,
        origdelims: fr,
        node: gr,
        previous: this.delimiters,
        next: null,
        canOpen: ur.canOpen,
        canClose: ur.canClose
      }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
    }, lr.prototype.removeDelimiter = function(ar) {
      ar.previous !== null && (ar.previous.next = ar.next), ar.next === null ? this.delimiters = ar.previous : ar.next.previous = ar.previous;
    }, lr.prototype.removeDelimitersBetween = function(ar, cr) {
      ar.next !== cr && (ar.next = cr, cr.previous = ar);
    }, lr.prototype.processEmphasis = function(ar) {
      var cr, ur, fr, dr, hr, gr, vr, mr = !1, br = (cr = {}, cr[C_UNDERSCORE] = [ar, ar, ar], cr[C_ASTERISK] = [ar, ar, ar], cr[C_SINGLEQUOTE] = [ar], cr[C_DOUBLEQUOTE] = [ar], cr[C_TILDE] = [ar], cr[C_DOLLAR] = [ar], cr);
      for (fr = this.delimiters; fr !== null && fr.previous !== ar; )
        fr = fr.previous;
      for (; fr !== null; ) {
        var yr = fr.cc, kr = yr === C_UNDERSCORE || yr === C_ASTERISK;
        if (!fr.canClose)
          fr = fr.next;
        else {
          for (ur = fr.previous, vr = !1; ur !== null && ur !== ar && ur !== br[yr][kr ? fr.origdelims % 3 : 0]; ) {
            if (mr = kr && (fr.canOpen || ur.canClose) && fr.origdelims % 3 !== 0 && (ur.origdelims + fr.origdelims) % 3 === 0, ur.cc === fr.cc && ur.canOpen && !mr) {
              vr = !0;
              break;
            }
            ur = ur.previous;
          }
          if (dr = fr, kr || yr === C_TILDE || yr === C_DOLLAR) {
            if (!vr)
              fr = fr.next;
            else if (ur) {
              var Tr = fr.numdelims >= 2 && ur.numdelims >= 2 ? 2 : 1, _r = kr ? 0 : 1;
              hr = ur.node, gr = fr.node;
              var Er = kr ? Tr === 1 ? "emph" : "strong" : "strike";
              yr === C_DOLLAR && (Er = "customInline");
              var xr = createNode$1(Er), Cr = hr.sourcepos[1], Ar = gr.sourcepos[0];
              xr.sourcepos = [
                [Cr[0], Cr[1] - Tr + 1],
                [Ar[0], Ar[1] + Tr - 1]
              ], hr.sourcepos[1][1] -= Tr, gr.sourcepos[0][1] += Tr, hr.literal = hr.literal.slice(Tr), gr.literal = gr.literal.slice(Tr), ur.numdelims -= Tr, fr.numdelims -= Tr;
              for (var Lr = hr.next, Dr = void 0; Lr && Lr !== gr; )
                Dr = Lr.next, Lr.unlink(), xr.appendChild(Lr), Lr = Dr;
              if (yr === C_DOLLAR) {
                var Nr = xr.firstChild, Hr = Nr.literal || "", $r = Hr.split(/\s/)[0];
                xr.info = $r, Hr.length <= $r.length ? Nr.unlink() : (Nr.sourcepos[0][1] += $r.length, Nr.literal = Hr.replace($r + " ", ""));
              }
              if (hr.insertAfter(xr), this.removeDelimitersBetween(ur, fr), ur.numdelims <= _r && (ur.numdelims === 0 && hr.unlink(), this.removeDelimiter(ur)), fr.numdelims <= _r) {
                fr.numdelims === 0 && gr.unlink();
                var Wr = fr.next;
                this.removeDelimiter(fr), fr = Wr;
              }
            }
          } else
            yr === C_SINGLEQUOTE ? (fr.node.literal = "’", vr && (ur.node.literal = "‘"), fr = fr.next) : yr === C_DOUBLEQUOTE && (fr.node.literal = "”", vr && (ur.node.literal = "“"), fr = fr.next);
          vr || (br[yr][kr ? dr.origdelims % 3 : 0] = dr.previous, dr.canOpen || this.removeDelimiter(dr));
        }
      }
      for (; this.delimiters !== null && this.delimiters !== ar; )
        this.removeDelimiter(this.delimiters);
    }, lr.prototype.parseLinkTitle = function() {
      var ar = this.match(reLinkTitle);
      return ar === null ? null : unescapeString(ar.substr(1, ar.length - 2));
    }, lr.prototype.parseLinkDestination = function() {
      var ar = this.match(reLinkDestinationBraces);
      if (ar === null) {
        if (this.peek() === C_LESSTHAN$1)
          return null;
        for (var cr = this.pos, ur = 0, fr = void 0; (fr = this.peek()) !== -1; )
          if (fr === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1)))
            this.pos += 1, this.peek() !== -1 && (this.pos += 1);
          else if (fr === C_OPEN_PAREN)
            this.pos += 1, ur += 1;
          else if (fr === C_CLOSE_PAREN) {
            if (ur < 1)
              break;
            this.pos += 1, ur -= 1;
          } else {
            if (reWhitespaceChar.exec(fromCodePoint$1(fr)) !== null)
              break;
            this.pos += 1;
          }
        return this.pos === cr && fr !== C_CLOSE_PAREN || ur !== 0 ? null : (ar = this.subject.substr(cr, this.pos - cr), normalizeURI(unescapeString(ar)));
      }
      return normalizeURI(unescapeString(ar.substr(1, ar.length - 2)));
    }, lr.prototype.parseLinkLabel = function() {
      var ar = this.match(reLinkLabel);
      return ar === null || ar.length > 1001 ? 0 : ar.length;
    }, lr.prototype.parseOpenBracket = function(ar) {
      var cr = this.pos;
      this.pos += 1;
      var ur = text$1("[", this.sourcepos(this.pos, this.pos));
      return ar.appendChild(ur), this.addBracket(ur, cr, !1), !0;
    }, lr.prototype.parseBang = function(ar) {
      var cr = this.pos;
      if (this.pos += 1, this.peek() === C_OPEN_BRACKET$1) {
        this.pos += 1;
        var ur = text$1("![", this.sourcepos(this.pos - 1, this.pos));
        ar.appendChild(ur), this.addBracket(ur, cr + 1, !0);
      } else {
        var ur = text$1("!", this.sourcepos(this.pos, this.pos));
        ar.appendChild(ur);
      }
      return !0;
    }, lr.prototype.parseCloseBracket = function(ar) {
      var cr = null, ur = null, fr = !1;
      this.pos += 1;
      var dr = this.pos, hr = this.brackets;
      if (hr === null)
        return ar.appendChild(text$1("]", this.sourcepos(dr, dr))), !0;
      if (!hr.active)
        return ar.appendChild(text$1("]", this.sourcepos(dr, dr))), this.removeBracket(), !0;
      var gr = hr.image, vr = this.pos;
      this.peek() === C_OPEN_PAREN && (this.pos++, this.spnl() && (cr = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
      (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) && (ur = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === C_CLOSE_PAREN ? (this.pos += 1, fr = !0) : this.pos = vr);
      var mr = "";
      if (!fr) {
        var br = this.pos, yr = this.parseLinkLabel();
        if (yr > 2 ? mr = this.subject.slice(br, br + yr) : hr.bracketAfter || (mr = this.subject.slice(hr.index, dr)), yr === 0 && (this.pos = vr), mr) {
          mr = normalizeReference(mr);
          var kr = this.refMap[mr];
          kr && (cr = kr.destination, ur = kr.title, fr = !0);
        }
      }
      if (fr) {
        var Tr = createNode$1(gr ? "image" : "link");
        Tr.destination = cr, Tr.title = ur || "", Tr.sourcepos = [hr.startpos, this.sourcepos(this.pos)];
        for (var _r = hr.node.next, Er = void 0; _r; )
          Er = _r.next, _r.unlink(), Tr.appendChild(_r), _r = Er;
        if (ar.appendChild(Tr), this.processEmphasis(hr.previousDelimiter), this.removeBracket(), hr.node.unlink(), !gr)
          for (hr = this.brackets; hr !== null; )
            hr.image || (hr.active = !1), hr = hr.previous;
        return this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: mr }), !0;
      }
      return this.removeBracket(), this.pos = dr, ar.appendChild(text$1("]", this.sourcepos(dr, dr))), this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: mr }), !0;
    }, lr.prototype.addBracket = function(ar, cr, ur) {
      this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
        node: ar,
        startpos: this.sourcepos(cr + (ur ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: cr,
        image: ur,
        active: !0
      };
    }, lr.prototype.removeBracket = function() {
      this.brackets && (this.brackets = this.brackets.previous);
    }, lr.prototype.parseEntity = function(ar) {
      var cr, ur = this.pos + 1;
      return (cr = this.match(reEntityHere)) ? (ar.appendChild(text$1(lib.decodeHTML(cr), this.sourcepos(ur, this.pos))), !0) : !1;
    }, lr.prototype.parseString = function(ar) {
      var cr, ur = this.pos + 1;
      if (cr = this.match(reMain)) {
        if (this.options.smart) {
          var fr = cr.replace(reEllipses, "…").replace(reDash, function(hr) {
            var gr = 0, vr = 0;
            return hr.length % 3 === 0 ? vr = hr.length / 3 : hr.length % 2 === 0 ? gr = hr.length / 2 : hr.length % 3 === 2 ? (gr = 1, vr = (hr.length - 2) / 3) : (gr = 2, vr = (hr.length - 4) / 3), repeat("—", vr) + repeat("–", gr);
          });
          ar.appendChild(text$1(fr, this.sourcepos(ur, this.pos)));
        } else {
          var dr = text$1(cr, this.sourcepos(ur, this.pos));
          ar.appendChild(dr);
        }
        return !0;
      }
      return !1;
    }, lr.prototype.parseNewline = function(ar) {
      this.pos += 1;
      var cr = ar.lastChild;
      if (cr && cr.type === "text" && cr.literal[cr.literal.length - 1] === " ") {
        var ur = cr.literal[cr.literal.length - 2] === " ", fr = cr.literal.length;
        cr.literal = cr.literal.replace(reFinalSpace, "");
        var dr = fr - cr.literal.length;
        cr.sourcepos[1][1] -= dr, ar.appendChild(createNode$1(ur ? "linebreak" : "softbreak", this.sourcepos(this.pos - dr, this.pos)));
      } else
        ar.appendChild(createNode$1("softbreak", this.sourcepos(this.pos, this.pos)));
      return this.nextLine(), this.match(reInitialSpace), !0;
    }, lr.prototype.parseReference = function(ar, cr) {
      if (!this.options.referenceDefinition)
        return 0;
      this.subject = ar.stringContent, this.pos = 0;
      var ur = null, fr = this.pos, dr = this.parseLinkLabel();
      if (dr === 0)
        return 0;
      var hr = this.subject.substr(0, dr);
      if (this.peek() === C_COLON)
        this.pos++;
      else
        return this.pos = fr, 0;
      this.spnl();
      var gr = this.parseLinkDestination();
      if (gr === null)
        return this.pos = fr, 0;
      var vr = this.pos;
      this.spnl(), this.pos !== vr && (ur = this.parseLinkTitle()), ur === null && (ur = "", this.pos = vr);
      var mr = !0;
      if (this.match(reSpaceAtEndOfLine) === null && (ur === "" ? mr = !1 : (ur = "", this.pos = vr, mr = this.match(reSpaceAtEndOfLine) !== null)), !mr)
        return this.pos = fr, 0;
      var br = normalizeReference(hr);
      if (br === "")
        return this.pos = fr, 0;
      var yr = this.getReferenceDefSourcepos(ar);
      ar.sourcepos[0][0] = yr[1][0] + 1;
      var kr = createNode$1("refDef", yr);
      return kr.title = ur, kr.dest = gr, kr.label = br, ar.insertBefore(kr), cr[br] ? this.refDefCandidateMap[kr.id] = kr : cr[br] = createRefDefState(kr), this.pos - fr;
    }, lr.prototype.mergeTextNodes = function(ar) {
      for (var cr, ur = []; cr = ar.next(); ) {
        var fr = cr.entering, dr = cr.node;
        if (fr && dr.type === "text")
          ur.push(dr);
        else if (ur.length === 1)
          ur = [];
        else if (ur.length > 1) {
          var hr = ur[0], gr = ur[ur.length - 1];
          hr.sourcepos && gr.sourcepos && (hr.sourcepos[1] = gr.sourcepos[1]), hr.next = gr.next, hr.next && (hr.next.prev = hr);
          for (var vr = 1; vr < ur.length; vr += 1)
            hr.literal += ur[vr].literal, ur[vr].unlink();
          ur = [];
        }
      }
    }, lr.prototype.getReferenceDefSourcepos = function(ar) {
      for (var cr = ar.stringContent.split(/\n|\r\n/), ur = !1, fr = 0, dr = { line: 0, ch: 0 }, hr = 0; hr < cr.length; hr += 1) {
        var gr = cr[hr];
        if (reWhitespaceChar.test(gr))
          break;
        if (/\:/.test(gr) && fr === 0) {
          if (ur)
            break;
          var vr = gr.indexOf(":") === gr.length - 1 ? hr + 1 : hr;
          dr = { line: vr, ch: cr[vr].length }, ur = !0;
        }
        var mr = gr.match(/'|"/g);
        if (mr && (fr += mr.length), fr === 2) {
          dr = { line: hr, ch: gr.length };
          break;
        }
      }
      return [
        [ar.sourcepos[0][0], ar.sourcepos[0][1]],
        [ar.sourcepos[0][0] + dr.line, dr.ch]
      ];
    }, lr.prototype.parseInline = function(ar) {
      var cr, ur = !1, fr = this.peek();
      if (fr === -1)
        return !1;
      switch (fr) {
        case C_NEWLINE:
          ur = this.parseNewline(ar);
          break;
        case C_BACKSLASH:
          ur = this.parseBackslash(ar);
          break;
        case C_BACKTICK:
          ur = this.parseBackticks(ar);
          break;
        case C_ASTERISK:
        case C_UNDERSCORE:
        case C_TILDE:
        case C_DOLLAR:
          ur = this.handleDelim(fr, ar);
          break;
        case C_SINGLEQUOTE:
        case C_DOUBLEQUOTE:
          ur = !!(!((cr = this.options) === null || cr === void 0) && cr.smart) && this.handleDelim(fr, ar);
          break;
        case C_OPEN_BRACKET$1:
          ur = this.parseOpenBracket(ar);
          break;
        case C_BANG:
          ur = this.parseBang(ar);
          break;
        case C_CLOSE_BRACKET:
          ur = this.parseCloseBracket(ar);
          break;
        case C_LESSTHAN$1:
          ur = this.parseAutolink(ar) || this.parseHtmlTag(ar);
          break;
        case C_AMPERSAND:
          ar.disabledEntityParse || (ur = this.parseEntity(ar));
          break;
        default:
          ur = this.parseString(ar);
          break;
      }
      return ur || (this.pos += 1, ar.appendChild(text$1(fromCodePoint$1(fr), this.sourcepos(this.pos, this.pos + 1)))), !0;
    }, lr.prototype.parse = function(ar) {
      for (this.subject = ar.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = ar.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = ar.sourcepos[0][0], isHeading(ar) && (this.lineOffsets[0] += ar.level + 1); this.parseInline(ar); )
        ;
      ar.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(ar.walker());
      var cr = this.options, ur = cr.extendedAutolinks, fr = cr.customParser;
      if (ur && convertExtAutoLinks(ar.walker(), ur), fr && ar.firstChild)
        for (var dr, hr = ar.firstChild.walker(); dr = hr.next(); ) {
          var gr = dr.node, vr = dr.entering;
          fr[gr.type] && fr[gr.type](gr, { entering: vr, options: this.options });
        }
    }, lr;
  }()
), reTaskListItemMarker = /^\[([ \txX])\][ \t]+/;
function taskListItemFinalize(lr, ar) {
  if (ar.firstChild && ar.firstChild.type === "paragraph") {
    var cr = ar.firstChild, ur = cr.stringContent.match(reTaskListItemMarker);
    if (ur) {
      var fr = ur[0].length;
      cr.stringContent = cr.stringContent.substring(fr - 1), cr.sourcepos[0][1] += fr, cr.lineOffsets[0] += fr, ar.listData.task = !0, ar.listData.checked = /[xX]/.test(ur[1]);
    }
  }
}
var table = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableHead" || lr === "tableBody";
  },
  acceptsLines: !1
}, tableBody$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableRow";
  },
  acceptsLines: !1
}, tableHead$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableRow" || lr === "tableDelimRow";
  },
  acceptsLines: !1
}, tableDelimRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableDelimCell";
  },
  acceptsLines: !1
}, tableDelimCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, tableRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableCell";
  },
  acceptsLines: !1
}, tableCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, CODE_INDENT = 4, C_TAB = 9, C_GREATERTHAN = 62, C_LESSTHAN = 60, C_SPACE = 32, C_OPEN_BRACKET = 91, reNonSpace = /[^ \t\f\v\r\n]/, reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
function endsWithBlankLine(lr) {
  for (var ar = lr; ar; ) {
    if (ar.lastLineBlank)
      return !0;
    var cr = ar.type;
    if (!ar.lastLineChecked && (cr === "list" || cr === "item"))
      ar.lastLineChecked = !0, ar = ar.lastChild;
    else {
      ar.lastLineChecked = !0;
      break;
    }
  }
  return !1;
}
function peek(lr, ar) {
  return ar < lr.length ? lr.charCodeAt(ar) : -1;
}
function isBlank(lr) {
  return !reNonSpace.test(lr);
}
function isSpaceOrTab(lr) {
  return lr === C_SPACE || lr === C_TAB;
}
var reClosingCustomBlock = /^\$\$$/, customBlock$1 = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = cr.match(reClosingCustomBlock);
    if (ur)
      return lr.lastLineLength = ur[0].length, lr.finalize(ar, lr.lineNumber), 2;
    for (var fr = ar.offset; fr > 0 && isSpaceOrTab(peek(cr, lr.offset)); )
      lr.advanceOffset(1, !0), fr--;
    return 0;
  },
  finalize: function(lr, ar) {
    if (ar.stringContent !== null) {
      var cr = ar.stringContent, ur = cr.indexOf(`
`), fr = cr.slice(0, ur), dr = cr.slice(ur + 1), hr = fr.match(/^(\s*)(.*)/);
      ar.info = unescapeString(hr[2].trim()), ar.literal = dr, ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, noop = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, document$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, list = {
  continue: function() {
    return 0;
  },
  finalize: function(lr, ar) {
    for (var cr = ar.firstChild; cr; ) {
      if (endsWithBlankLine(cr) && cr.next) {
        ar.listData.tight = !1;
        break;
      }
      for (var ur = cr.firstChild; ur; ) {
        if (endsWithBlankLine(ur) && (cr.next || ur.next)) {
          ar.listData.tight = !1;
          break;
        }
        ur = ur.next;
      }
      cr = cr.next;
    }
  },
  canContain: function(lr) {
    return lr === "item";
  },
  acceptsLines: !1
}, blockQuote$1 = {
  continue: function(lr) {
    var ar = lr.currentLine;
    if (!lr.indented && peek(ar, lr.nextNonspace) === C_GREATERTHAN)
      lr.advanceNextNonspace(), lr.advanceOffset(1, !1), isSpaceOrTab(peek(ar, lr.offset)) && lr.advanceOffset(1, !0);
    else
      return 1;
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, item = {
  continue: function(lr, ar) {
    if (lr.blank) {
      if (ar.firstChild === null)
        return 1;
      lr.advanceNextNonspace();
    } else if (lr.indent >= ar.listData.markerOffset + ar.listData.padding)
      lr.advanceOffset(ar.listData.markerOffset + ar.listData.padding, !0);
    else
      return 1;
    return 0;
  },
  finalize: taskListItemFinalize,
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, heading = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, thematicBreak$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, codeBlock = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = lr.indent;
    if (ar.isFenced) {
      var fr = ur <= 3 && cr.charAt(lr.nextNonspace) === ar.fenceChar && cr.slice(lr.nextNonspace).match(reClosingCodeFence);
      if (fr && fr[0].length >= ar.fenceLength)
        return lr.lastLineLength = lr.offset + ur + fr[0].length, lr.finalize(ar, lr.lineNumber), 2;
      for (var dr = ar.fenceOffset; dr > 0 && isSpaceOrTab(peek(cr, lr.offset)); )
        lr.advanceOffset(1, !0), dr--;
    } else if (ur >= CODE_INDENT)
      lr.advanceOffset(CODE_INDENT, !0);
    else if (lr.blank)
      lr.advanceNextNonspace();
    else
      return 1;
    return 0;
  },
  finalize: function(lr, ar) {
    var cr;
    if (ar.stringContent !== null) {
      if (ar.isFenced) {
        var ur = ar.stringContent, fr = ur.indexOf(`
`), dr = ur.slice(0, fr), hr = ur.slice(fr + 1), gr = dr.match(/^(\s*)(.*)/);
        ar.infoPadding = gr[1].length, ar.info = unescapeString(gr[2].trim()), ar.literal = hr;
      } else
        ar.literal = (cr = ar.stringContent) === null || cr === void 0 ? void 0 : cr.replace(/(\n *)+$/, `
`);
      ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, htmlBlock$1 = {
  continue: function(lr, ar) {
    return lr.blank && (ar.htmlBlockType === 6 || ar.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(lr, ar) {
    var cr;
    ar.literal = ((cr = ar.stringContent) === null || cr === void 0 ? void 0 : cr.replace(/(\n *)+$/, "")) || null, ar.stringContent = null;
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, paragraph = {
  continue: function(lr) {
    return lr.blank ? 1 : 0;
  },
  finalize: function(lr, ar) {
    if (ar.stringContent !== null) {
      for (var cr, ur = !1; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (cr = lr.inlineParser.parseReference(ar, lr.refMap)); )
        ar.stringContent = ar.stringContent.slice(cr), ur = !0;
      ur && isBlank(ar.stringContent) && ar.unlink();
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, refDef = noop, frontMatter$2 = noop, blockHandlers = {
  document: document$1,
  list,
  blockQuote: blockQuote$1,
  item,
  heading,
  thematicBreak: thematicBreak$1,
  codeBlock,
  htmlBlock: htmlBlock$1,
  paragraph,
  table,
  tableBody: tableBody$1,
  tableHead: tableHead$1,
  tableRow,
  tableCell,
  tableDelimRow,
  tableDelimCell,
  refDef,
  customBlock: customBlock$1,
  frontMatter: frontMatter$2
};
function parseRowContent(lr) {
  for (var ar = 0, cr = 0, ur = [], fr = 0; fr < lr.length; fr += 1)
    if (lr[fr] === "|" && lr[fr - 1] !== "\\") {
      var dr = lr.substring(ar, fr);
      ar === 0 && isEmpty(dr) ? cr = fr + 1 : ur.push(dr), ar = fr + 1;
    }
  if (ar < lr.length) {
    var dr = lr.substring(ar, lr.length);
    isEmpty(dr) || ur.push(dr);
  }
  return [cr, ur];
}
function generateTableCells(lr, ar, cr, ur) {
  for (var fr = [], dr = 0, hr = ar; dr < hr.length; dr++) {
    var gr = hr[dr], vr = gr.match(/^[ \t]+/), mr = vr ? vr[0].length : 0, br = void 0, yr = void 0;
    if (mr === gr.length)
      mr = 0, br = 0, yr = "";
    else {
      var kr = gr.match(/[ \t]+$/);
      br = kr ? kr[0].length : 0, yr = gr.slice(mr, gr.length - br);
    }
    var Tr = ur + mr, _r = createNode$1(lr, [
      [cr, ur],
      [cr, ur + gr.length - 1]
    ]);
    _r.stringContent = yr.replace(/\\\|/g, "|"), _r.startIdx = fr.length, _r.endIdx = fr.length, _r.lineOffsets = [Tr - 1], _r.paddingLeft = mr, _r.paddingRight = br, fr.push(_r), ur += gr.length + 1;
  }
  return fr;
}
function getColumnFromDelimCell(lr) {
  var ar = null, cr = lr.stringContent, ur = cr[0], fr = cr[cr.length - 1];
  return fr === ":" ? ar = ur === ":" ? "center" : "right" : ur === ":" && (ar = "left"), { align: ar };
}
var tableHead = function(lr, ar) {
  var cr = ar.stringContent;
  if (ar.type === "paragraph" && !lr.indented && !lr.blank) {
    var ur = cr.length - 1, fr = cr.lastIndexOf(`
`, ur - 1) + 1, dr = cr.slice(fr, ur), hr = lr.currentLine.slice(lr.nextNonspace), gr = parseRowContent(dr), vr = gr[0], mr = gr[1], br = parseRowContent(hr), yr = br[0], kr = br[1], Tr = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !mr.length || !kr.length || kr.some(function(Wr) {
        return !Tr.test(Wr);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      kr.length === 1 && hr.indexOf("|") !== 0
    )
      return 0;
    var _r = ar.lineOffsets, Er = lr.lineNumber - 1, xr = last(_r) + 1, Cr = createNode$1("table", [
      [Er, xr],
      [lr.lineNumber, lr.offset]
    ]);
    if (Cr.columns = kr.map(function() {
      return { align: null };
    }), ar.insertAfter(Cr), _r.length === 1)
      ar.unlink();
    else {
      ar.stringContent = cr.slice(0, fr);
      var Ar = cr.lastIndexOf(`
`, fr - 2) + 1, Lr = fr - Ar - 1;
      lr.lastLineLength = _r[_r.length - 2] + Lr, lr.finalize(ar, Er - 1);
    }
    lr.advanceOffset(lr.currentLine.length - lr.offset, !1);
    var Dr = createNode$1("tableHead", [
      [Er, xr],
      [lr.lineNumber, lr.offset]
    ]);
    Cr.appendChild(Dr);
    var Nr = createNode$1("tableRow", [
      [Er, xr],
      [Er, xr + dr.length - 1]
    ]), Hr = createNode$1("tableDelimRow", [
      [lr.lineNumber, lr.nextNonspace + 1],
      [lr.lineNumber, lr.offset]
    ]);
    Dr.appendChild(Nr), Dr.appendChild(Hr), generateTableCells("tableCell", mr, Er, xr + vr).forEach(function(Wr) {
      Nr.appendChild(Wr);
    });
    var $r = generateTableCells("tableDelimCell", kr, lr.lineNumber, lr.nextNonspace + 1 + yr);
    return $r.forEach(function(Wr) {
      Hr.appendChild(Wr);
    }), Cr.columns = $r.map(getColumnFromDelimCell), lr.tip = Cr, 2;
  }
  return 0;
}, tableBody = function(lr, ar) {
  if (ar.type !== "table" && ar.type !== "tableBody" || !lr.blank && lr.currentLine.indexOf("|") === -1)
    return 0;
  if (lr.advanceOffset(lr.currentLine.length - lr.offset, !1), lr.blank) {
    var cr = ar;
    return ar.type === "tableBody" && (cr = ar.parent, lr.finalize(ar, lr.lineNumber - 1)), lr.finalize(cr, lr.lineNumber - 1), 0;
  }
  var ur = ar;
  ar.type === "table" && (ur = lr.addChild("tableBody", lr.nextNonspace), ur.stringContent = null);
  var fr = createNode$1("tableRow", [
    [lr.lineNumber, lr.nextNonspace + 1],
    [lr.lineNumber, lr.currentLine.length]
  ]);
  ur.appendChild(fr);
  var dr = ur.parent, hr = lr.currentLine.slice(lr.nextNonspace), gr = parseRowContent(hr), vr = gr[0], mr = gr[1];
  return generateTableCells("tableCell", mr, lr.lineNumber, lr.nextNonspace + 1 + vr).forEach(function(br, yr) {
    yr >= dr.columns.length && (br.ignored = !0), fr.appendChild(br);
  }), 2;
}, reCustomBlock = /^(\$\$)(\s*[a-zA-Z])+/, reCanBeCustomInline = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, customBlock = function(lr) {
  var ar;
  if (!lr.indented && !reCanBeCustomInline.test(lr.currentLine) && (ar = lr.currentLine.match(reCustomBlock))) {
    var cr = ar[1].length;
    lr.closeUnmatchedBlocks();
    var ur = lr.addChild("customBlock", lr.nextNonspace);
    return ur.syntaxLength = cr, ur.offset = lr.indent, lr.advanceNextNonspace(), lr.advanceOffset(cr, !1), 2;
  }
  return 0;
}, reCodeFence = /^`{3,}(?!.*`)|^~{3,}/, reHtmlBlockOpen = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", "i")
], reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/, reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/, reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, reBulletListMarker = /^[*+-]/, reOrderedListMarker = /^(\d{1,9})([.)])/;
function parseListMarker(lr, ar) {
  var cr = lr.currentLine.slice(lr.nextNonspace), ur, fr, dr = {
    type: "bullet",
    tight: !0,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: lr.indent,
    // GFM: Task List Item
    task: !1,
    checked: !1
  };
  if (lr.indent >= 4)
    return null;
  if (ur = cr.match(reBulletListMarker))
    dr.type = "bullet", dr.bulletChar = ur[0][0];
  else if ((ur = cr.match(reOrderedListMarker)) && (ar.type !== "paragraph" || ur[1] === "1"))
    dr.type = "ordered", dr.start = parseInt(ur[1], 10), dr.delimiter = ur[2];
  else
    return null;
  if (fr = peek(lr.currentLine, lr.nextNonspace + ur[0].length), !(fr === -1 || fr === C_TAB || fr === C_SPACE) || ar.type === "paragraph" && !lr.currentLine.slice(lr.nextNonspace + ur[0].length).match(reNonSpace))
    return null;
  lr.advanceNextNonspace(), lr.advanceOffset(ur[0].length, !0);
  var hr = lr.column, gr = lr.offset;
  do
    lr.advanceOffset(1, !0), fr = peek(lr.currentLine, lr.offset);
  while (lr.column - hr < 5 && isSpaceOrTab(fr));
  var vr = peek(lr.currentLine, lr.offset) === -1, mr = lr.column - hr;
  return mr >= 5 || mr < 1 || vr ? (dr.padding = ur[0].length + 1, lr.column = hr, lr.offset = gr, isSpaceOrTab(peek(lr.currentLine, lr.offset)) && lr.advanceOffset(1, !0)) : dr.padding = ur[0].length + mr, dr;
}
function listsMatch(lr, ar) {
  return lr.type === ar.type && lr.delimiter === ar.delimiter && lr.bulletChar === ar.bulletChar;
}
function isDisallowedDeepHeading(lr, ar) {
  return lr.options.disallowDeepHeading && (ar.type === "blockQuote" || ar.type === "item");
}
var blockQuote = function(lr) {
  return !lr.indented && peek(lr.currentLine, lr.nextNonspace) === C_GREATERTHAN ? (lr.advanceNextNonspace(), lr.advanceOffset(1, !1), isSpaceOrTab(peek(lr.currentLine, lr.offset)) && lr.advanceOffset(1, !0), lr.closeUnmatchedBlocks(), lr.addChild("blockQuote", lr.nextNonspace), 1) : 0;
}, atxHeading = function(lr, ar) {
  var cr;
  if (!lr.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(lr, ar) && (cr = lr.currentLine.slice(lr.nextNonspace).match(reATXHeadingMarker))) {
    lr.advanceNextNonspace(), lr.advanceOffset(cr[0].length, !1), lr.closeUnmatchedBlocks();
    var ur = lr.addChild("heading", lr.nextNonspace);
    return ur.level = cr[0].trim().length, ur.headingType = "atx", ur.stringContent = lr.currentLine.slice(lr.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), lr.advanceOffset(lr.currentLine.length - lr.offset), 2;
  }
  return 0;
}, fencedCodeBlock = function(lr) {
  var ar;
  if (!lr.indented && (ar = lr.currentLine.slice(lr.nextNonspace).match(reCodeFence))) {
    var cr = ar[0].length;
    lr.closeUnmatchedBlocks();
    var ur = lr.addChild("codeBlock", lr.nextNonspace);
    return ur.isFenced = !0, ur.fenceLength = cr, ur.fenceChar = ar[0][0], ur.fenceOffset = lr.indent, lr.advanceNextNonspace(), lr.advanceOffset(cr, !1), 2;
  }
  return 0;
}, htmlBlock = function(lr, ar) {
  if (!lr.indented && peek(lr.currentLine, lr.nextNonspace) === C_LESSTHAN) {
    var cr = lr.currentLine.slice(lr.nextNonspace), ur = lr.options.disallowedHtmlBlockTags, fr = void 0;
    for (fr = 1; fr <= 7; fr++) {
      var dr = cr.match(reHtmlBlockOpen[fr]);
      if (dr) {
        if (fr === 7) {
          if (ar.type === "paragraph")
            return 0;
          if (ur.length > 0) {
            var hr = new RegExp("</?(?:" + ur.join("|") + ")", "i");
            if (hr.test(dr[0]))
              return 0;
          }
        }
        lr.closeUnmatchedBlocks();
        var gr = lr.addChild("htmlBlock", lr.offset);
        return gr.htmlBlockType = fr, 2;
      }
    }
  }
  return 0;
}, seTextHeading = function(lr, ar) {
  var cr;
  if (ar.stringContent !== null && !lr.indented && ar.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(lr, ar.parent) && (cr = lr.currentLine.slice(lr.nextNonspace).match(reSetextHeadingLine))) {
    lr.closeUnmatchedBlocks();
    for (var ur = void 0; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (ur = lr.inlineParser.parseReference(ar, lr.refMap)); )
      ar.stringContent = ar.stringContent.slice(ur);
    if (ar.stringContent.length > 0) {
      var fr = createNode$1("heading", ar.sourcepos);
      return fr.level = cr[0][0] === "=" ? 1 : 2, fr.headingType = "setext", fr.stringContent = ar.stringContent, ar.insertAfter(fr), ar.unlink(), lr.tip = fr, lr.advanceOffset(lr.currentLine.length - lr.offset, !1), 2;
    }
    return 0;
  }
  return 0;
}, thematicBreak = function(lr) {
  return !lr.indented && reThematicBreak.test(lr.currentLine.slice(lr.nextNonspace)) ? (lr.closeUnmatchedBlocks(), lr.addChild("thematicBreak", lr.nextNonspace), lr.advanceOffset(lr.currentLine.length - lr.offset, !1), 2) : 0;
}, listItem = function(lr, ar) {
  var cr, ur = ar;
  return (!lr.indented || ar.type === "list") && (cr = parseListMarker(lr, ur)) ? (lr.closeUnmatchedBlocks(), (lr.tip.type !== "list" || !listsMatch(ur.listData, cr)) && (ur = lr.addChild("list", lr.nextNonspace), ur.listData = cr), ur = lr.addChild("item", lr.nextNonspace), ur.listData = cr, 1) : 0;
}, indentedCodeBlock = function(lr) {
  return lr.indented && lr.tip.type !== "paragraph" && !lr.blank ? (lr.advanceOffset(CODE_INDENT, !0), lr.closeUnmatchedBlocks(), lr.addChild("codeBlock", lr.offset), 2) : 0;
}, blockStarts = [
  blockQuote,
  atxHeading,
  fencedCodeBlock,
  htmlBlock,
  seTextHeading,
  thematicBreak,
  listItem,
  indentedCodeBlock,
  tableHead,
  tableBody,
  customBlock
], reFrontMatter = /^(-{3}|\+{3}|;{3})$/, frontMatter$1 = function(lr, ar) {
  var cr = lr.currentLine, ur = lr.lineNumber, fr = lr.indented;
  if (ur === 1 && !fr && ar.type === "document" && reFrontMatter.test(cr)) {
    lr.closeUnmatchedBlocks();
    var dr = lr.addChild("frontMatter", lr.nextNonspace);
    return dr.stringContent = cr, lr.advanceNextNonspace(), lr.advanceOffset(cr.length, !1), 2;
  }
  return 0;
}, frontMatter = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = cr.match(reFrontMatter);
    return ar.type === "frontMatter" && ur ? (ar.stringContent += cr, lr.lastLineLength = ur[0].length, lr.finalize(ar, lr.lineNumber), 2) : 0;
  },
  finalize: function(lr, ar) {
    ar.stringContent !== null && (ar.literal = ar.stringContent, ar.stringContent = null);
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, reHtmlBlockClose = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
], reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/, reLineEnding$1 = /\r\n|\n|\r/;
function document$2() {
  return createNode$1("document", [
    [1, 1],
    [0, 0]
  ]);
}
var defaultOptions$1 = {
  smart: !1,
  tagFilter: !1,
  extendedAutolinks: !1,
  disallowedHtmlBlockTags: [],
  referenceDefinition: !1,
  disallowDeepHeading: !1,
  customParser: null,
  frontMatter: !1
}, Parser = (
  /** @class */
  function() {
    function lr(ar) {
      this.options = __assign(__assign({}, defaultOptions$1), ar), this.doc = document$2(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (blockHandlers.frontMatter = frontMatter, blockStarts.unshift(frontMatter$1)), this.inlineParser = new InlineParser(this.options);
    }
    return lr.prototype.advanceOffset = function(ar, cr) {
      cr === void 0 && (cr = !1);
      for (var ur = this.currentLine, fr, dr, hr; ar > 0 && (hr = ur[this.offset]); )
        hr === "	" ? (fr = 4 - this.column % 4, cr ? (this.partiallyConsumedTab = fr > ar, dr = fr > ar ? ar : fr, this.column += dr, this.offset += this.partiallyConsumedTab ? 0 : 1, ar -= dr) : (this.partiallyConsumedTab = !1, this.column += fr, this.offset += 1, ar -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, ar -= 1);
    }, lr.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
    }, lr.prototype.findNextNonspace = function() {
      for (var ar = this.currentLine, cr = this.offset, ur = this.column, fr; (fr = ar.charAt(cr)) !== ""; )
        if (fr === " ")
          cr++, ur++;
        else if (fr === "	")
          cr++, ur += 4 - ur % 4;
        else
          break;
      this.blank = fr === `
` || fr === "\r" || fr === "", this.nextNonspace = cr, this.nextNonspaceColumn = ur, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= CODE_INDENT;
    }, lr.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var ar = 4 - this.column % 4;
        this.tip.stringContent += repeat(" ", ar);
      }
      this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
    }, lr.prototype.addChild = function(ar, cr) {
      for (; !blockHandlers[this.tip.type].canContain(ar); )
        this.finalize(this.tip, this.lineNumber - 1);
      var ur = cr + 1, fr = createNode$1(ar, [
        [this.lineNumber, ur],
        [0, 0]
      ]);
      return fr.stringContent = "", this.tip.appendChild(fr), this.tip = fr, fr;
    }, lr.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        for (; this.oldtip !== this.lastMatchedContainer; ) {
          var ar = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = ar;
        }
        this.allClosed = !0;
      }
    }, lr.prototype.finalize = function(ar, cr) {
      var ur = ar.parent;
      ar.open = !1, ar.sourcepos[1] = [cr, this.lastLineLength], blockHandlers[ar.type].finalize(this, ar), this.tip = ur;
    }, lr.prototype.processInlines = function(ar) {
      var cr, ur = this.options.customParser, fr = ar.walker();
      for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; cr = fr.next(); ) {
        var dr = cr.node, hr = cr.entering, gr = dr.type;
        ur && ur[gr] && ur[gr](dr, { entering: hr, options: this.options }), !hr && (gr === "paragraph" || gr === "heading" || gr === "tableCell" && !dr.ignored) && this.inlineParser.parse(dr);
      }
    }, lr.prototype.incorporateLine = function(ar) {
      var cr = this.doc;
      this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, ar.indexOf("\0") !== -1 && (ar = ar.replace(/\0/g, "�")), this.currentLine = ar;
      for (var ur = !0, fr; (fr = cr.lastChild) && fr.open; ) {
        switch (cr = fr, this.findNextNonspace(), blockHandlers[cr.type].continue(this, cr)) {
          case 0:
            break;
          case 1:
            ur = !1;
            break;
          case 2:
            this.lastLineLength = ar.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!ur) {
          cr = cr.parent;
          break;
        }
      }
      this.allClosed = cr === this.oldtip, this.lastMatchedContainer = cr;
      for (var dr = cr.type !== "paragraph" && blockHandlers[cr.type].acceptsLines, hr = blockStarts.length; !dr; ) {
        if (this.findNextNonspace(), cr.type !== "table" && cr.type !== "tableBody" && cr.type !== "paragraph" && !this.indented && !reMaybeSpecial.test(ar.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        for (var gr = 0; gr < hr; ) {
          var vr = blockStarts[gr](this, cr);
          if (vr === 1) {
            cr = this.tip;
            break;
          } else if (vr === 2) {
            cr = this.tip, dr = !0;
            break;
          } else
            gr++;
        }
        if (gr === hr) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
        this.addLine();
      else {
        this.closeUnmatchedBlocks(), this.blank && cr.lastChild && (cr.lastChild.lastLineBlank = !0);
        for (var mr = cr.type, br = this.blank && !(mr === "blockQuote" || isCodeBlock(cr) && cr.isFenced || mr === "item" && !cr.firstChild && cr.sourcepos[0][0] === this.lineNumber), yr = cr; yr; )
          yr.lastLineBlank = br, yr = yr.parent;
        blockHandlers[mr].acceptsLines ? (this.addLine(), isHtmlBlock(cr) && cr.htmlBlockType >= 1 && cr.htmlBlockType <= 5 && reHtmlBlockClose[cr.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = ar.length, this.finalize(cr, this.lineNumber))) : this.offset < ar.length && !this.blank && (cr = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
      }
      this.lastLineLength = ar.length;
    }, lr.prototype.parse = function(ar, cr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      var ur = ar.split(reLineEnding$1), fr = ur.length;
      this.lines = cr || ur, this.options.referenceDefinition && this.clearRefMaps(), ar.charCodeAt(ar.length - 1) === C_NEWLINE && (fr -= 1);
      for (var dr = 0; dr < fr; dr++)
        this.incorporateLine(ur[dr]);
      for (; this.tip; )
        this.finalize(this.tip, fr);
      return this.processInlines(this.doc), this.doc;
    }, lr.prototype.partialParseStart = function(ar, cr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = ar - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      for (var ur = cr.length, fr = 0; fr < ur; fr++)
        this.incorporateLine(cr[fr]);
      return this.doc;
    }, lr.prototype.partialParseExtends = function(ar) {
      for (var cr = 0; cr < ar.length; cr++)
        this.incorporateLine(ar[cr]);
    }, lr.prototype.partialParseFinish = function() {
      for (; this.tip; )
        this.finalize(this.tip, this.lineNumber);
      this.processInlines(this.doc);
    }, lr.prototype.setRefMaps = function(ar, cr, ur) {
      this.refMap = ar, this.refLinkCandidateMap = cr, this.refDefCandidateMap = ur;
    }, lr.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        clearObj(ar);
      });
    }, lr;
  }()
);
function comparePos(lr, ar) {
  return lr[0] < ar[0] ? 1 : lr[0] > ar[0] ? -1 : lr[1] < ar[1] ? 1 : lr[1] > ar[1] ? -1 : 0;
}
function compareRangeAndPos(lr, ar) {
  var cr = lr[0], ur = lr[1];
  return comparePos(ur, ar) === 1 ? 1 : comparePos(cr, ar) === -1 ? -1 : 0;
}
function removeNextUntil(lr, ar) {
  if (!(lr.parent !== ar.parent || lr === ar)) {
    for (var cr = lr.next; cr && cr !== ar; ) {
      for (var ur = cr.next, fr = 0, dr = ["parent", "prev", "next"]; fr < dr.length; fr++) {
        var hr = dr[fr];
        cr[hr] && (removeNodeById(cr[hr].id), cr[hr] = null);
      }
      cr = ur;
    }
    lr.next = ar.next, ar.next ? ar.next.prev = lr : lr.parent.lastChild = lr;
  }
}
function getChildNodes(lr) {
  for (var ar = [], cr = lr.firstChild; cr; )
    ar.push(cr), cr = cr.next;
  return ar;
}
function insertNodesBefore(lr, ar) {
  for (var cr = 0, ur = ar; cr < ur.length; cr++) {
    var fr = ur[cr];
    lr.insertBefore(fr);
  }
}
function prependChildNodes(lr, ar) {
  for (var cr = ar.length - 1; cr >= 0; cr -= 1)
    lr.prependChild(ar[cr]);
}
function updateNextLineNumbers(lr, ar) {
  if (!(!lr || !lr.parent || ar === 0)) {
    var cr = lr.parent.walker();
    cr.resumeAt(lr, !0);
    for (var ur; ur = cr.next(); ) {
      var fr = ur.node, dr = ur.entering;
      dr && (fr.sourcepos[0][0] += ar, fr.sourcepos[1][0] += ar);
    }
  }
}
function compareRangeAndLine(lr, ar) {
  var cr = lr[0], ur = lr[1];
  return ur[0] < ar ? 1 : cr[0] > ar ? -1 : 0;
}
function findChildNodeAtLine(lr, ar) {
  for (var cr = lr.firstChild; cr; ) {
    var ur = compareRangeAndLine(cr.sourcepos, ar);
    if (ur === 0)
      return cr;
    if (ur === -1)
      return cr.prev || cr;
    cr = cr.next;
  }
  return lr.lastChild;
}
function lastLeafNode(lr) {
  for (; lr.lastChild; )
    lr = lr.lastChild;
  return lr;
}
function sameLineTopAncestor(lr) {
  for (; lr.parent && lr.parent.type !== "document" && lr.parent.sourcepos[0][0] === lr.sourcepos[0][0]; )
    lr = lr.parent;
  return lr;
}
function findFirstNodeAtLine(lr, ar) {
  for (var cr = lr.firstChild, ur = null; cr; ) {
    var fr = compareRangeAndLine(cr.sourcepos, ar);
    if (fr === 0) {
      if (cr.sourcepos[0][0] === ar || !cr.firstChild)
        return cr;
      ur = cr, cr = cr.firstChild;
    } else {
      if (fr === -1)
        break;
      ur = cr, cr = cr.next;
    }
  }
  return ur ? sameLineTopAncestor(lastLeafNode(ur)) : null;
}
function findNodeAtPosition(lr, ar) {
  for (var cr = lr, ur = null; cr; ) {
    var fr = compareRangeAndPos(cr.sourcepos, ar);
    if (fr === 0)
      if (cr.firstChild)
        ur = cr, cr = cr.firstChild;
      else
        return cr;
    else {
      if (fr === -1)
        return ur;
      if (cr.next)
        cr = cr.next;
      else
        return ur;
    }
  }
  return cr;
}
function findNodeById(lr) {
  return getNodeById(lr) || null;
}
function invokeNextUntil(lr, ar, cr) {
  if (cr === void 0 && (cr = null), ar)
    for (var ur = ar.walker(); ar && ar !== cr; ) {
      lr(ar);
      var fr = ur.next();
      if (fr)
        ar = fr.node;
      else
        break;
    }
}
function isUnlinked(lr) {
  var ar = findNodeById(lr);
  if (!ar)
    return !0;
  for (; ar && ar.type !== "document"; ) {
    if (!ar.parent && !ar.prev && !ar.next)
      return !0;
    ar = ar.parent;
  }
  return !1;
}
var reLineEnding = /\r\n|\n|\r/;
function canBeContinuedListItem(lr) {
  var ar = lr.match(/^[ \t]+/);
  if (ar && (ar[0].length >= 2 || /\t/.test(ar[0])))
    return !0;
  var cr = ar ? lr.slice(ar.length) : lr;
  return reBulletListMarker.test(cr) || reOrderedListMarker.test(cr);
}
function canBeContinuedTableBody(lr) {
  return !isBlank(lr) && lr.indexOf("|") !== -1;
}
function createRefDefState(lr) {
  var ar = lr.id, cr = lr.title, ur = lr.sourcepos, fr = lr.dest;
  return {
    id: ar,
    title: cr,
    sourcepos: ur,
    unlinked: !1,
    destination: fr
  };
}
var ToastMark = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(cr != null && cr.referenceDefinition), this.parser = new Parser(cr), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, ar = ar || "", this.lineTexts = ar.split(reLineEnding), this.root = this.parser.parse(ar, this.lineTexts);
    }
    return lr.prototype.updateLineTexts = function(ar, cr, ur) {
      var fr, dr = ar[0], hr = ar[1], gr = cr[0], vr = cr[1], mr = ur.split(reLineEnding), br = mr.length, yr = this.lineTexts[dr - 1], kr = this.lineTexts[gr - 1];
      mr[0] = yr.slice(0, hr - 1) + mr[0], mr[br - 1] = mr[br - 1] + kr.slice(vr - 1);
      var Tr = gr - dr + 1;
      return (fr = this.lineTexts).splice.apply(fr, __spreadArray([dr - 1, Tr], mr)), br - Tr;
    }, lr.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = !0, this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
      for (var ar = this.lineTexts, cr = ar.length - 1; ar[cr] === ""; )
        cr -= 1;
      ar.length - 2 > cr && (cr += 1), this.root.sourcepos[1] = [cr + 1, ar[cr].length];
    }, lr.prototype.replaceRangeNodes = function(ar, cr, ur) {
      ar ? (insertNodesBefore(ar, ur), removeNextUntil(ar, cr), [ar.id, cr.id].forEach(function(fr) {
        return removeNodeById(fr);
      }), ar.unlink()) : cr ? (insertNodesBefore(cr, ur), removeNodeById(cr.id), cr.unlink()) : prependChildNodes(this.root, ur);
    }, lr.prototype.getNodeRange = function(ar, cr) {
      var ur = findChildNodeAtLine(this.root, ar[0]), fr = findChildNodeAtLine(this.root, cr[0]);
      return fr && fr.next && cr[0] + 1 === fr.next.sourcepos[0][0] && (fr = fr.next), [ur, fr];
    }, lr.prototype.trigger = function(ar, cr) {
      this.eventHandlerMap[ar].forEach(function(ur) {
        ur(cr);
      });
    }, lr.prototype.extendEndLine = function(ar) {
      for (; this.lineTexts[ar] === ""; )
        ar += 1;
      return ar;
    }, lr.prototype.parseRange = function(ar, cr, ur, fr) {
      ar && ar.prev && (isList(ar.prev) && canBeContinuedListItem(this.lineTexts[ur - 1]) || isTable(ar.prev) && canBeContinuedTableBody(this.lineTexts[ur - 1])) && (ar = ar.prev, ur = ar.sourcepos[0][0]);
      for (var dr = this.lineTexts.slice(ur - 1, fr), hr = this.parser.partialParseStart(ur, dr), gr = cr ? cr.next : this.root.firstChild, vr = hr.lastChild, mr = vr && isCodeBlock(vr) && vr.open, br = vr && isCustomBlock(vr) && vr.open, yr = vr && isList(vr); (mr || br) && gr || yr && gr && (gr.type === "list" || gr.sourcepos[0][1] >= 2); ) {
        var kr = this.extendEndLine(gr.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(fr, kr)), ar || (ar = cr), cr = gr, fr = kr, gr = gr.next;
      }
      this.parser.partialParseFinish();
      var Tr = getChildNodes(hr);
      return { newNodes: Tr, extStartNode: ar, extEndNode: cr };
    }, lr.prototype.getRemovedNodeRange = function(ar, cr) {
      return !ar || ar && isRefDef(ar) || cr && isRefDef(cr) ? null : {
        id: [ar.id, cr.id],
        line: [ar.sourcepos[0][0] - 1, cr.sourcepos[1][0] - 1]
      };
    }, lr.prototype.markDeletedRefMap = function(ar, cr) {
      var ur = this;
      if (!isEmptyObj(this.refMap)) {
        var fr = function(dr) {
          if (isRefDef(dr)) {
            var hr = ur.refMap[dr.label];
            hr && dr.id === hr.id && (hr.unlinked = !0);
          }
        };
        ar && invokeNextUntil(fr, ar.parent, cr), cr && invokeNextUntil(fr, cr);
      }
    }, lr.prototype.replaceWithNewRefDefState = function(ar) {
      var cr = this;
      if (!isEmptyObj(this.refMap)) {
        var ur = function(fr) {
          if (isRefDef(fr)) {
            var dr = fr.label, hr = cr.refMap[dr];
            (!hr || hr.unlinked) && (cr.refMap[dr] = createRefDefState(fr));
          }
        };
        ar.forEach(function(fr) {
          invokeNextUntil(ur, fr);
        });
      }
    }, lr.prototype.replaceWithRefDefCandidate = function() {
      var ar = this;
      isEmptyObj(this.refDefCandidateMap) || iterateObject(this.refDefCandidateMap, function(cr, ur) {
        var fr = ur.label, dr = ur.sourcepos, hr = ar.refMap[fr];
        (!hr || hr.unlinked || hr.sourcepos[0][0] > dr[0][0]) && (ar.refMap[fr] = createRefDefState(ur));
      });
    }, lr.prototype.getRangeWithRefDef = function(ar, cr, ur, fr, dr) {
      if (this.referenceDefinition && !isEmptyObj(this.refMap)) {
        var hr = findChildNodeAtLine(this.root, ar - 1), gr = findChildNodeAtLine(this.root, cr + 1);
        hr && isRefDef(hr) && hr !== ur && hr !== fr && (ur = hr, ar = ur.sourcepos[0][0]), gr && isRefDef(gr) && gr !== ur && gr !== fr && (fr = gr, cr = this.extendEndLine(fr.sourcepos[1][0] + dr));
      }
      return [ur, fr, ar, cr];
    }, lr.prototype.parse = function(ar, cr, ur) {
      ur === void 0 && (ur = 0);
      var fr = this.getNodeRange(ar, cr), dr = fr[0], hr = fr[1], gr = dr ? Math.min(dr.sourcepos[0][0], ar[0]) : ar[0], vr = this.extendEndLine((hr ? Math.max(hr.sourcepos[1][0], cr[0]) : cr[0]) + ur), mr = this.parseRange.apply(this, this.getRangeWithRefDef(gr, vr, dr, hr, ur)), br = mr.newNodes, yr = mr.extStartNode, kr = mr.extEndNode, Tr = this.getRemovedNodeRange(yr, kr), _r = kr ? kr.next : this.root.firstChild;
      return this.referenceDefinition ? (this.markDeletedRefMap(yr, kr), this.replaceRangeNodes(yr, kr, br), this.replaceWithNewRefDefState(br)) : this.replaceRangeNodes(yr, kr, br), { nodes: br, removedNodeRange: Tr, nextNode: _r };
    }, lr.prototype.parseRefLink = function() {
      var ar = this, cr = [];
      return isEmptyObj(this.refMap) || iterateObject(this.refMap, function(ur, fr) {
        fr.unlinked && delete ar.refMap[ur], iterateObject(ar.refLinkCandidateMap, function(dr, hr) {
          var gr = hr.node, vr = hr.refLabel;
          vr === ur && cr.push(ar.parse(gr.sourcepos[0], gr.sourcepos[1]));
        });
      }), cr;
    }, lr.prototype.removeUnlinkedCandidate = function() {
      isEmptyObj(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        iterateObject(ar, function(cr) {
          isUnlinked(cr) && delete ar[cr];
        });
      });
    }, lr.prototype.editMarkdown = function(ar, cr, ur) {
      var fr = this.updateLineTexts(ar, cr, ur), dr = this.parse(ar, cr, fr), hr = omit(dr, "nextNode");
      updateNextLineNumbers(dr.nextNode, fr), this.updateRootNodeState();
      var gr = [hr];
      return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), gr = gr.concat(this.parseRefLink())), this.trigger("change", gr), gr;
    }, lr.prototype.getLineTexts = function() {
      return this.lineTexts;
    }, lr.prototype.getRootNode = function() {
      return this.root;
    }, lr.prototype.findNodeAtPosition = function(ar) {
      var cr = findNodeAtPosition(this.root, ar);
      return !cr || cr === this.root ? null : cr;
    }, lr.prototype.findFirstNodeAtLine = function(ar) {
      return findFirstNodeAtLine(this.root, ar);
    }, lr.prototype.on = function(ar, cr) {
      this.eventHandlerMap[ar].push(cr);
    }, lr.prototype.off = function(ar, cr) {
      var ur = this.eventHandlerMap[ar], fr = ur.indexOf(cr);
      ur.splice(fr, 1);
    }, lr.prototype.findNodeById = function(ar) {
      return findNodeById(ar);
    }, lr.prototype.removeAllNode = function() {
      removeAllNode();
    }, lr;
  }()
), disallowedTags = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
], reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join("|") + ")[^>]*>)", "ig");
function filterDisallowedTags(lr) {
  return reDisallowedTag.test(lr) ? lr.replace(reDisallowedTag, function(ar, cr) {
    return "&lt;" + cr;
  }) : lr;
}
var baseConvertors$1 = {
  heading: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "h" + lr.level,
      outerNewLine: !0
    };
  },
  text: function(lr) {
    return {
      type: "text",
      content: lr.literal
    };
  },
  softbreak: function(lr, ar) {
    var cr = ar.options;
    return {
      type: "html",
      content: cr.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: `<br />
`
    };
  },
  emph: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(lr, ar) {
    var cr, ur = ar.entering, fr = (cr = lr.parent) === null || cr === void 0 ? void 0 : cr.parent;
    return fr && fr.type === "list" && fr.listData.tight ? null : {
      type: ur ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: !0
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: !0,
      selfClose: !0
    };
  },
  blockQuote: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: !0,
      innerNewLine: !0
    };
  },
  list: function(lr, ar) {
    var cr = ar.entering, ur = lr.listData, fr = ur.type, dr = ur.start, hr = fr === "bullet" ? "ul" : "ol", gr = {};
    return hr === "ol" && dr !== null && dr !== 1 && (gr.start = dr.toString()), {
      type: cr ? "openTag" : "closeTag",
      tagName: hr,
      attributes: gr,
      outerNewLine: !0
    };
  },
  item: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  htmlInline: function(lr, ar) {
    var cr = ar.options, ur = cr.tagFilter ? filterDisallowedTags(lr.literal) : lr.literal;
    return { type: "html", content: ur };
  },
  htmlBlock: function(lr, ar) {
    var cr = ar.options, ur = cr.tagFilter ? filterDisallowedTags(lr.literal) : lr.literal;
    return cr.nodeId ? [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "html", content: ur },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ] : { type: "html", content: ur, outerNewLine: !0 };
  },
  code: function(lr) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(lr) {
    var ar = lr.info, cr = ar ? ar.split(/\s+/) : [], ur = [];
    return cr.length > 0 && cr[0].length > 0 && ur.push("language-" + escapeXml(cr[0])), [
      { type: "openTag", tagName: "pre", outerNewLine: !0 },
      { type: "openTag", tagName: "code", classNames: ur },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: !0 }
    ];
  },
  link: function(lr, ar) {
    var cr = ar.entering;
    if (cr) {
      var ur = lr, fr = ur.title, dr = ur.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: __assign({ href: escapeXml(dr) }, fr && { title: escapeXml(fr) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(lr, ar) {
    var cr = ar.getChildrenText, ur = ar.skipChildren, fr = lr, dr = fr.title, hr = fr.destination;
    return ur(), {
      type: "openTag",
      tagName: "img",
      selfClose: !0,
      attributes: __assign({ src: escapeXml(hr), alt: cr(lr) }, dr && { title: escapeXml(dr) })
    };
  },
  customBlock: function(lr, ar, cr) {
    var ur = lr.info.trim().toLowerCase(), fr = cr[ur];
    if (fr)
      try {
        return fr(lr, ar);
      } catch (dr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + ur + " block node was parsed in markdown renderer: " + dr);
      }
    return [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  frontMatter: function(lr) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: !0,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  customInline: function(lr, ar, cr) {
    var ur = lr, fr = ur.info, dr = ur.firstChild, hr = fr.trim().toLowerCase(), gr = cr[hr], vr = ar.entering;
    if (gr)
      try {
        return gr(lr, ar);
      } catch (mr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + hr + " inline node was parsed in markdown renderer: " + mr);
      }
    return vr ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + fr + (dr ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
}, gfmConvertors = {
  strike: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(lr, ar) {
    var cr = ar.entering, ur = lr.listData, fr = ur.checked, dr = ur.task;
    if (cr) {
      var hr = {
        type: "openTag",
        tagName: "li",
        outerNewLine: !0
      };
      return dr ? [
        hr,
        {
          type: "openTag",
          tagName: "input",
          selfClose: !0,
          attributes: __assign(__assign({}, fr && { checked: "" }), { disabled: "", type: "checkbox" })
        },
        {
          type: "text",
          content: " "
        }
      ] : hr;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  table: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: !0
    };
  },
  tableHead: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: !0
    };
  },
  tableBody: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: !0
    };
  },
  tableRow: function(lr, ar) {
    var cr = ar.entering;
    if (cr)
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: !0
      };
    var ur = [];
    if (lr.lastChild)
      for (var fr = lr.parent.parent.columns.length, dr = lr.lastChild.endIdx, hr = dr + 1; hr < fr; hr += 1)
        ur.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: !0
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: !0
        });
    return ur.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: !0
    }), ur;
  },
  tableCell: function(lr, ar) {
    var cr = ar.entering;
    if (lr.ignored)
      return {
        type: "text",
        content: ""
      };
    var ur = lr.parent.parent, fr = ur.type === "tableHead" ? "th" : "td", dr = ur.parent, hr = dr.columns[lr.startIdx], gr = hr != null && hr.align ? { align: hr.align } : null;
    return cr ? __assign({ type: "openTag", tagName: fr, outerNewLine: !0 }, gr && { attributes: gr }) : {
      type: "closeTag",
      tagName: fr,
      outerNewLine: !0
    };
  }
}, defaultOptions = {
  softbreak: `
`,
  gfm: !1,
  tagFilter: !1,
  nodeId: !1
};
function getChildrenText(lr) {
  for (var ar = [], cr = lr.walker(), ur = null; ur = cr.next(); ) {
    var fr = ur.node;
    fr.type === "text" && ar.push(fr.literal);
  }
  return ar.join("");
}
var Renderer = (
  /** @class */
  function() {
    function lr(ar) {
      this.buffer = [], this.options = __assign(__assign({}, defaultOptions), ar), this.convertors = this.createConvertors(), delete this.options.convertors;
    }
    return lr.prototype.createConvertors = function() {
      var ar = __assign({}, baseConvertors$1);
      if (this.options.gfm && (ar = __assign(__assign({}, ar), gfmConvertors)), this.options.convertors) {
        var cr = this.options.convertors, ur = Object.keys(cr), fr = __assign(__assign({}, baseConvertors$1), gfmConvertors);
        ur.forEach(function(dr) {
          var hr = ar[dr], gr = cr[dr], vr = Object.keys(fr).indexOf(dr) === -1 ? dr.toLowerCase() : dr;
          hr ? ar[vr] = function(mr, br, yr) {
            return br.origin = function() {
              return hr(mr, br, yr);
            }, gr(mr, br);
          } : ar[vr] = gr;
        });
      }
      return ar;
    }, lr.prototype.getConvertors = function() {
      return this.convertors;
    }, lr.prototype.getOptions = function() {
      return this.options;
    }, lr.prototype.render = function(ar) {
      var cr = this;
      this.buffer = [];
      for (var ur = ar.walker(), fr = null, dr = function() {
        var gr = fr.node, vr = fr.entering, mr = hr.convertors[gr.type];
        if (!mr)
          return "continue";
        var br = !1, yr = {
          entering: vr,
          leaf: !isContainer$1(gr),
          options: hr.options,
          getChildrenText,
          skipChildren: function() {
            br = !0;
          }
        }, kr = isCustomBlock(gr) || isCustomInline(gr) ? mr(gr, yr, hr.convertors) : mr(gr, yr);
        if (kr) {
          var Tr = Array.isArray(kr) ? kr : [kr];
          Tr.forEach(function(_r, Er) {
            _r.type === "openTag" && cr.options.nodeId && Er === 0 && (_r.attributes || (_r.attributes = {}), _r.attributes["data-nodeid"] = String(gr.id)), cr.renderHTMLNode(_r);
          }), br && (ur.resumeAt(gr, !1), ur.next());
        }
      }, hr = this; fr = ur.next(); )
        dr();
      return this.addNewLine(), this.buffer.join("");
    }, lr.prototype.renderHTMLNode = function(ar) {
      switch (ar.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(ar);
          break;
        case "text":
          this.renderTextNode(ar);
          break;
        case "html":
          this.renderRawHtmlNode(ar);
          break;
      }
    }, lr.prototype.generateOpenTagString = function(ar) {
      var cr = this, ur = ar.tagName, fr = ar.classNames, dr = ar.attributes;
      this.buffer.push("<" + ur), fr && fr.length > 0 && this.buffer.push(' class="' + fr.join(" ") + '"'), dr && Object.keys(dr).forEach(function(hr) {
        var gr = dr[hr];
        cr.buffer.push(" " + hr + '="' + gr + '"');
      }), ar.selfClose && this.buffer.push(" /"), this.buffer.push(">");
    }, lr.prototype.generateCloseTagString = function(ar) {
      var cr = ar.tagName;
      this.buffer.push("</" + cr + ">");
    }, lr.prototype.addNewLine = function() {
      this.buffer.length && last(last(this.buffer)) !== `
` && this.buffer.push(`
`);
    }, lr.prototype.addOuterNewLine = function(ar) {
      ar.outerNewLine && this.addNewLine();
    }, lr.prototype.addInnerNewLine = function(ar) {
      ar.innerNewLine && this.addNewLine();
    }, lr.prototype.renderTextNode = function(ar) {
      this.buffer.push(escapeXml(ar.content));
    }, lr.prototype.renderRawHtmlNode = function(ar) {
      this.addOuterNewLine(ar), this.buffer.push(ar.content), this.addOuterNewLine(ar);
    }, lr.prototype.renderElementNode = function(ar) {
      ar.type === "openTag" ? (this.addOuterNewLine(ar), this.generateOpenTagString(ar), ar.selfClose ? this.addOuterNewLine(ar) : this.addInnerNewLine(ar)) : (this.addInnerNewLine(ar), this.generateCloseTagString(ar), this.addOuterNewLine(ar));
    }, lr;
  }()
);
/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
function _toConsumableArray(lr) {
  if (Array.isArray(lr)) {
    for (var ar = 0, cr = Array(lr.length); ar < lr.length; ar++)
      cr[ar] = lr[ar];
    return cr;
  } else
    return Array.from(lr);
}
var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf$1 = Object.setPrototypeOf, isFrozen$1 = Object.isFrozen, getPrototypeOf$1 = Object.getPrototypeOf, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, freeze$1 = Object.freeze, seal$1 = Object.seal, create$1 = Object.create, _ref = typeof Reflect != "undefined" && Reflect, apply$1 = _ref.apply, construct$1 = _ref.construct;
apply$1 || (apply$1 = function(ar, cr, ur) {
  return ar.apply(cr, ur);
});
freeze$1 || (freeze$1 = function(ar) {
  return ar;
});
seal$1 || (seal$1 = function(ar) {
  return ar;
});
construct$1 || (construct$1 = function(ar, cr) {
  return new (Function.prototype.bind.apply(ar, [null].concat(_toConsumableArray(cr))))();
});
var arrayForEach$1 = unapply$1(Array.prototype.forEach), arrayPop$1 = unapply$1(Array.prototype.pop), arrayPush$1 = unapply$1(Array.prototype.push), stringToLowerCase$1 = unapply$1(String.prototype.toLowerCase), stringMatch$1 = unapply$1(String.prototype.match), stringReplace$1 = unapply$1(String.prototype.replace), stringIndexOf$1 = unapply$1(String.prototype.indexOf), stringTrim$1 = unapply$1(String.prototype.trim), regExpTest$1 = unapply$1(RegExp.prototype.test), typeErrorCreate$1 = unconstruct$1(TypeError);
function unapply$1(lr) {
  return function(ar) {
    for (var cr = arguments.length, ur = Array(cr > 1 ? cr - 1 : 0), fr = 1; fr < cr; fr++)
      ur[fr - 1] = arguments[fr];
    return apply$1(lr, ar, ur);
  };
}
function unconstruct$1(lr) {
  return function() {
    for (var ar = arguments.length, cr = Array(ar), ur = 0; ur < ar; ur++)
      cr[ur] = arguments[ur];
    return construct$1(lr, cr);
  };
}
function addToSet$1(lr, ar) {
  setPrototypeOf$1 && setPrototypeOf$1(lr, null);
  for (var cr = ar.length; cr--; ) {
    var ur = ar[cr];
    if (typeof ur == "string") {
      var fr = stringToLowerCase$1(ur);
      fr !== ur && (isFrozen$1(ar) || (ar[cr] = fr), ur = fr);
    }
    lr[ur] = !0;
  }
  return lr;
}
function clone$1(lr) {
  var ar = create$1(null), cr = void 0;
  for (cr in lr)
    apply$1(hasOwnProperty, lr, [cr]) && (ar[cr] = lr[cr]);
  return ar;
}
function lookupGetter$1(lr, ar) {
  for (; lr !== null; ) {
    var cr = getOwnPropertyDescriptor$1(lr, ar);
    if (cr) {
      if (cr.get)
        return unapply$1(cr.get);
      if (typeof cr.value == "function")
        return unapply$1(cr.value);
    }
    lr = getPrototypeOf$1(lr);
  }
  function ur(fr) {
    return console.warn("fallback value for", fr), null;
  }
  return ur;
}
var html$2 = freeze$1(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$2 = freeze$1(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters$1 = freeze$1(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed$1 = freeze$1(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$2 = freeze$1(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), mathMlDisallowed$1 = freeze$1(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$2 = freeze$1(["#text"]), html$1$1 = freeze$1(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg$1$1 = freeze$1(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl$1$1 = freeze$1(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml$1 = freeze$1(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR$1 = seal$1(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ERB_EXPR$1 = seal$1(/<%[\s\S]*|[\s\S]*%>/gm), DATA_ATTR$1 = seal$1(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR$1 = seal$1(/^aria-[\-\w]+$/), IS_ALLOWED_URI$1 = seal$1(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA$1 = seal$1(/^(?:\w+script|data):/i), ATTR_WHITESPACE$1 = seal$1(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(lr) {
  return typeof lr;
} : function(lr) {
  return lr && typeof Symbol == "function" && lr.constructor === Symbol && lr !== Symbol.prototype ? "symbol" : typeof lr;
};
function _toConsumableArray$1(lr) {
  if (Array.isArray(lr)) {
    for (var ar = 0, cr = Array(lr.length); ar < lr.length; ar++)
      cr[ar] = lr[ar];
    return cr;
  } else
    return Array.from(lr);
}
var getGlobal$1 = function lr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy$1 = function lr(ar, cr) {
  if ((typeof ar == "undefined" ? "undefined" : _typeof(ar)) !== "object" || typeof ar.createPolicy != "function")
    return null;
  var ur = null, fr = "data-tt-policy-suffix";
  cr.currentScript && cr.currentScript.hasAttribute(fr) && (ur = cr.currentScript.getAttribute(fr));
  var dr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(dr, {
      createHTML: function(gr) {
        return gr;
      }
    });
  } catch (hr) {
    return console.warn("TrustedTypes policy " + dr + " could not be created."), null;
  }
};
function createDOMPurify$1() {
  var lr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal$1(), ar = function(qi) {
    return createDOMPurify$1(qi);
  };
  if (ar.version = "2.3.3", ar.removed = [], !lr || !lr.document || lr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  var cr = lr.document, ur = lr.document, fr = lr.DocumentFragment, dr = lr.HTMLTemplateElement, hr = lr.Node, gr = lr.Element, vr = lr.NodeFilter, mr = lr.NamedNodeMap, br = mr === void 0 ? lr.NamedNodeMap || lr.MozNamedAttrMap : mr, yr = lr.Text, kr = lr.Comment, Tr = lr.DOMParser, _r = lr.trustedTypes, Er = gr.prototype, xr = lookupGetter$1(Er, "cloneNode"), Cr = lookupGetter$1(Er, "nextSibling"), Ar = lookupGetter$1(Er, "childNodes"), Lr = lookupGetter$1(Er, "parentNode");
  if (typeof dr == "function") {
    var Dr = ur.createElement("template");
    Dr.content && Dr.content.ownerDocument && (ur = Dr.content.ownerDocument);
  }
  var Nr = _createTrustedTypesPolicy$1(_r, cr), Hr = Nr && Ba ? Nr.createHTML("") : "", $r = ur, Wr = $r.implementation, Zr = $r.createNodeIterator, oi = $r.createDocumentFragment, Jr = $r.getElementsByTagName, Yr = cr.importNode, li = {};
  try {
    li = clone$1(ur).documentMode ? ur.documentMode : {};
  } catch (ya) {
  }
  var Si = {};
  ar.isSupported = typeof Lr == "function" && Wr && typeof Wr.createHTMLDocument != "undefined" && li !== 9;
  var ci = MUSTACHE_EXPR$1, hi = ERB_EXPR$1, Ei = DATA_ATTR$1, di = ARIA_ATTR$1, gi = IS_SCRIPT_OR_DATA$1, Li = ATTR_WHITESPACE$1, ui = IS_ALLOWED_URI$1, wi = null, Ui = addToSet$1({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg$2), _toConsumableArray$1(svgFilters$1), _toConsumableArray$1(mathMl$2), _toConsumableArray$1(text$2))), yi = null, Vi = addToSet$1({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1$1), _toConsumableArray$1(mathMl$1$1), _toConsumableArray$1(xml$1))), Oi = null, Mi = null, Ii = !0, mi = !0, _i = !1, Ci = !1, Ki = !1, Ni = !1, ia = !1, ea = !1, la = !1, ma = !0, Ba = !1, Fa = !0, Ia = !0, Hi = !1, oa = {}, Gi = null, ha = addToSet$1({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Ua = null, eo = addToSet$1({}, ["audio", "video", "img", "source", "image", "track"]), ua = null, va = addToSet$1({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ta = "http://www.w3.org/1998/Math/MathML", Aa = "http://www.w3.org/2000/svg", Oa = "http://www.w3.org/1999/xhtml", Xa = Oa, Ka = !1, Pa = void 0, Da = ["application/xhtml+xml", "text/html"], Ha = "text/html", $a = void 0, Yi = null, Zi = ur.createElement("form"), ka = function(qi) {
    Yi && Yi === qi || ((!qi || (typeof qi == "undefined" ? "undefined" : _typeof(qi)) !== "object") && (qi = {}), qi = clone$1(qi), wi = "ALLOWED_TAGS" in qi ? addToSet$1({}, qi.ALLOWED_TAGS) : Ui, yi = "ALLOWED_ATTR" in qi ? addToSet$1({}, qi.ALLOWED_ATTR) : Vi, ua = "ADD_URI_SAFE_ATTR" in qi ? addToSet$1(clone$1(va), qi.ADD_URI_SAFE_ATTR) : va, Ua = "ADD_DATA_URI_TAGS" in qi ? addToSet$1(clone$1(eo), qi.ADD_DATA_URI_TAGS) : eo, Gi = "FORBID_CONTENTS" in qi ? addToSet$1({}, qi.FORBID_CONTENTS) : ha, Oi = "FORBID_TAGS" in qi ? addToSet$1({}, qi.FORBID_TAGS) : {}, Mi = "FORBID_ATTR" in qi ? addToSet$1({}, qi.FORBID_ATTR) : {}, oa = "USE_PROFILES" in qi ? qi.USE_PROFILES : !1, Ii = qi.ALLOW_ARIA_ATTR !== !1, mi = qi.ALLOW_DATA_ATTR !== !1, _i = qi.ALLOW_UNKNOWN_PROTOCOLS || !1, Ci = qi.SAFE_FOR_TEMPLATES || !1, Ki = qi.WHOLE_DOCUMENT || !1, ea = qi.RETURN_DOM || !1, la = qi.RETURN_DOM_FRAGMENT || !1, ma = qi.RETURN_DOM_IMPORT !== !1, Ba = qi.RETURN_TRUSTED_TYPE || !1, ia = qi.FORCE_BODY || !1, Fa = qi.SANITIZE_DOM !== !1, Ia = qi.KEEP_CONTENT !== !1, Hi = qi.IN_PLACE || !1, ui = qi.ALLOWED_URI_REGEXP || ui, Xa = qi.NAMESPACE || Oa, Pa = // eslint-disable-next-line unicorn/prefer-includes
    Da.indexOf(qi.PARSER_MEDIA_TYPE) === -1 ? Pa = Ha : Pa = qi.PARSER_MEDIA_TYPE, $a = Pa === "application/xhtml+xml" ? function(sa) {
      return sa;
    } : stringToLowerCase$1, Ci && (mi = !1), la && (ea = !0), oa && (wi = addToSet$1({}, [].concat(_toConsumableArray$1(text$2))), yi = [], oa.html === !0 && (addToSet$1(wi, html$2), addToSet$1(yi, html$1$1)), oa.svg === !0 && (addToSet$1(wi, svg$2), addToSet$1(yi, svg$1$1), addToSet$1(yi, xml$1)), oa.svgFilters === !0 && (addToSet$1(wi, svgFilters$1), addToSet$1(yi, svg$1$1), addToSet$1(yi, xml$1)), oa.mathMl === !0 && (addToSet$1(wi, mathMl$2), addToSet$1(yi, mathMl$1$1), addToSet$1(yi, xml$1))), qi.ADD_TAGS && (wi === Ui && (wi = clone$1(wi)), addToSet$1(wi, qi.ADD_TAGS)), qi.ADD_ATTR && (yi === Vi && (yi = clone$1(yi)), addToSet$1(yi, qi.ADD_ATTR)), qi.ADD_URI_SAFE_ATTR && addToSet$1(ua, qi.ADD_URI_SAFE_ATTR), qi.FORBID_CONTENTS && (Gi === ha && (Gi = clone$1(Gi)), addToSet$1(Gi, qi.FORBID_CONTENTS)), Ia && (wi["#text"] = !0), Ki && addToSet$1(wi, ["html", "head", "body"]), wi.table && (addToSet$1(wi, ["tbody"]), delete Oi.tbody), freeze$1 && freeze$1(qi), Yi = qi);
  }, zi = addToSet$1({}, ["mi", "mo", "mn", "ms", "mtext"]), Ji = addToSet$1({}, ["foreignobject", "desc", "title", "annotation-xml"]), za = addToSet$1({}, svg$2);
  addToSet$1(za, svgFilters$1), addToSet$1(za, svgDisallowed$1);
  var Va = addToSet$1({}, mathMl$2);
  addToSet$1(Va, mathMlDisallowed$1);
  var Ca = function(qi) {
    var sa = Lr(qi);
    (!sa || !sa.tagName) && (sa = {
      namespaceURI: Oa,
      tagName: "template"
    });
    var si = stringToLowerCase$1(qi.tagName), Qr = stringToLowerCase$1(sa.tagName);
    if (qi.namespaceURI === Aa)
      return sa.namespaceURI === Oa ? si === "svg" : sa.namespaceURI === Ta ? si === "svg" && (Qr === "annotation-xml" || zi[Qr]) : !!za[si];
    if (qi.namespaceURI === Ta)
      return sa.namespaceURI === Oa ? si === "math" : sa.namespaceURI === Aa ? si === "math" && Ji[Qr] : !!Va[si];
    if (qi.namespaceURI === Oa) {
      if (sa.namespaceURI === Aa && !Ji[Qr] || sa.namespaceURI === Ta && !zi[Qr])
        return !1;
      var Br = addToSet$1({}, ["title", "style", "font", "a", "script"]);
      return !Va[si] && (Br[si] || !za[si]);
    }
    return !1;
  }, ja = function(qi) {
    arrayPush$1(ar.removed, { element: qi });
    try {
      qi.parentNode.removeChild(qi);
    } catch (sa) {
      try {
        qi.outerHTML = Hr;
      } catch (si) {
        qi.remove();
      }
    }
  }, ao = function(qi, sa) {
    try {
      arrayPush$1(ar.removed, {
        attribute: sa.getAttributeNode(qi),
        from: sa
      });
    } catch (si) {
      arrayPush$1(ar.removed, {
        attribute: null,
        from: sa
      });
    }
    if (sa.removeAttribute(qi), qi === "is" && !yi[qi])
      if (ea || la)
        try {
          ja(sa);
        } catch (si) {
        }
      else
        try {
          sa.setAttribute(qi, "");
        } catch (si) {
        }
  }, Wa = function(qi) {
    var sa = void 0, si = void 0;
    if (ia)
      qi = "<remove></remove>" + qi;
    else {
      var Qr = stringMatch$1(qi, /^[\r\n\t ]+/);
      si = Qr && Qr[0];
    }
    Pa === "application/xhtml+xml" && (qi = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + qi + "</body></html>");
    var Br = Nr ? Nr.createHTML(qi) : qi;
    if (Xa === Oa)
      try {
        sa = new Tr().parseFromString(Br, Pa);
      } catch (Xr) {
      }
    if (!sa || !sa.documentElement) {
      sa = Wr.createDocument(Xa, "template", null);
      try {
        sa.documentElement.innerHTML = Ka ? "" : Br;
      } catch (Xr) {
      }
    }
    var zr = sa.body || sa.documentElement;
    return qi && si && zr.insertBefore(ur.createTextNode(si), zr.childNodes[0] || null), Xa === Oa ? Jr.call(sa, Ki ? "html" : "body")[0] : Ki ? sa.documentElement : zr;
  }, po = function(qi) {
    return Zr.call(qi.ownerDocument || qi, qi, vr.SHOW_ELEMENT | vr.SHOW_COMMENT | vr.SHOW_TEXT, null, !1);
  }, to = function(qi) {
    return qi instanceof yr || qi instanceof kr ? !1 : typeof qi.nodeName != "string" || typeof qi.textContent != "string" || typeof qi.removeChild != "function" || !(qi.attributes instanceof br) || typeof qi.removeAttribute != "function" || typeof qi.setAttribute != "function" || typeof qi.namespaceURI != "string" || typeof qi.insertBefore != "function";
  }, oo = function(qi) {
    return (typeof hr == "undefined" ? "undefined" : _typeof(hr)) === "object" ? qi instanceof hr : qi && (typeof qi == "undefined" ? "undefined" : _typeof(qi)) === "object" && typeof qi.nodeType == "number" && typeof qi.nodeName == "string";
  }, uo = function(qi, sa, si) {
    Si[qi] && arrayForEach$1(Si[qi], function(Qr) {
      Qr.call(ar, sa, si, Yi);
    });
  }, Io = function(qi) {
    var sa = void 0;
    if (uo("beforeSanitizeElements", qi, null), to(qi) || stringMatch$1(qi.nodeName, /[\u0080-\uFFFF]/))
      return ja(qi), !0;
    var si = $a(qi.nodeName);
    if (uo("uponSanitizeElement", qi, {
      tagName: si,
      allowedTags: wi
    }), !oo(qi.firstElementChild) && (!oo(qi.content) || !oo(qi.content.firstElementChild)) && regExpTest$1(/<[/\w]/g, qi.innerHTML) && regExpTest$1(/<[/\w]/g, qi.textContent) || si === "select" && regExpTest$1(/<template/i, qi.innerHTML))
      return ja(qi), !0;
    if (!wi[si] || Oi[si]) {
      if (Ia && !Gi[si]) {
        var Qr = Lr(qi) || qi.parentNode, Br = Ar(qi) || qi.childNodes;
        if (Br && Qr)
          for (var zr = Br.length, Xr = zr - 1; Xr >= 0; --Xr)
            Qr.insertBefore(xr(Br[Xr], !0), Cr(qi));
      }
      return ja(qi), !0;
    }
    return qi instanceof gr && !Ca(qi) || (si === "noscript" || si === "noembed") && regExpTest$1(/<\/no(script|embed)/i, qi.innerHTML) ? (ja(qi), !0) : (Ci && qi.nodeType === 3 && (sa = qi.textContent, sa = stringReplace$1(sa, ci, " "), sa = stringReplace$1(sa, hi, " "), qi.textContent !== sa && (arrayPush$1(ar.removed, { element: qi.cloneNode() }), qi.textContent = sa)), uo("afterSanitizeElements", qi, null), !1);
  }, Lo = function(qi, sa, si) {
    if (Fa && (sa === "id" || sa === "name") && (si in ur || si in Zi))
      return !1;
    if (!(mi && !Mi[sa] && regExpTest$1(Ei, sa))) {
      if (!(Ii && regExpTest$1(di, sa))) {
        if (!yi[sa] || Mi[sa])
          return !1;
        if (!ua[sa]) {
          if (!regExpTest$1(ui, stringReplace$1(si, Li, ""))) {
            if (!((sa === "src" || sa === "xlink:href" || sa === "href") && qi !== "script" && stringIndexOf$1(si, "data:") === 0 && Ua[qi])) {
              if (!(_i && !regExpTest$1(gi, stringReplace$1(si, Li, "")))) {
                if (si)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Eo = function(qi) {
    var sa = void 0, si = void 0, Qr = void 0, Br = void 0;
    uo("beforeSanitizeAttributes", qi, null);
    var zr = qi.attributes;
    if (zr) {
      var Xr = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: yi
      };
      for (Br = zr.length; Br--; ) {
        sa = zr[Br];
        var ai = sa, vi = ai.name, Ti = ai.namespaceURI;
        if (si = stringTrim$1(sa.value), Qr = $a(vi), Xr.attrName = Qr, Xr.attrValue = si, Xr.keepAttr = !0, Xr.forceKeepAttr = void 0, uo("uponSanitizeAttribute", qi, Xr), si = Xr.attrValue, !Xr.forceKeepAttr && (ao(vi, qi), !!Xr.keepAttr)) {
          if (regExpTest$1(/\/>/i, si)) {
            ao(vi, qi);
            continue;
          }
          Ci && (si = stringReplace$1(si, ci, " "), si = stringReplace$1(si, hi, " "));
          var Fi = $a(qi.nodeName);
          if (Lo(Fi, Qr, si))
            try {
              Ti ? qi.setAttributeNS(Ti, vi, si) : qi.setAttribute(vi, si), arrayPop$1(ar.removed);
            } catch (ra) {
            }
        }
      }
      uo("afterSanitizeAttributes", qi, null);
    }
  }, lo = function ya(qi) {
    var sa = void 0, si = po(qi);
    for (uo("beforeSanitizeShadowDOM", qi, null); sa = si.nextNode(); )
      uo("uponSanitizeShadowNode", sa, null), !Io(sa) && (sa.content instanceof fr && ya(sa.content), Eo(sa));
    uo("afterSanitizeShadowDOM", qi, null);
  };
  return ar.sanitize = function(ya, qi) {
    var sa = void 0, si = void 0, Qr = void 0, Br = void 0, zr = void 0;
    if (Ka = !ya, Ka && (ya = "<!-->"), typeof ya != "string" && !oo(ya)) {
      if (typeof ya.toString != "function")
        throw typeErrorCreate$1("toString is not a function");
      if (ya = ya.toString(), typeof ya != "string")
        throw typeErrorCreate$1("dirty is not a string, aborting");
    }
    if (!ar.isSupported) {
      if (_typeof(lr.toStaticHTML) === "object" || typeof lr.toStaticHTML == "function") {
        if (typeof ya == "string")
          return lr.toStaticHTML(ya);
        if (oo(ya))
          return lr.toStaticHTML(ya.outerHTML);
      }
      return ya;
    }
    if (Ni || ka(qi), ar.removed = [], typeof ya == "string" && (Hi = !1), !Hi)
      if (ya instanceof hr)
        sa = Wa("<!---->"), si = sa.ownerDocument.importNode(ya, !0), si.nodeType === 1 && si.nodeName === "BODY" || si.nodeName === "HTML" ? sa = si : sa.appendChild(si);
      else {
        if (!ea && !Ci && !Ki && // eslint-disable-next-line unicorn/prefer-includes
        ya.indexOf("<") === -1)
          return Nr && Ba ? Nr.createHTML(ya) : ya;
        if (sa = Wa(ya), !sa)
          return ea ? null : Hr;
      }
    sa && ia && ja(sa.firstChild);
    for (var Xr = po(Hi ? ya : sa); Qr = Xr.nextNode(); )
      Qr.nodeType === 3 && Qr === Br || Io(Qr) || (Qr.content instanceof fr && lo(Qr.content), Eo(Qr), Br = Qr);
    if (Br = null, Hi)
      return ya;
    if (ea) {
      if (la)
        for (zr = oi.call(sa.ownerDocument); sa.firstChild; )
          zr.appendChild(sa.firstChild);
      else
        zr = sa;
      return ma && (zr = Yr.call(cr, zr, !0)), zr;
    }
    var ai = Ki ? sa.outerHTML : sa.innerHTML;
    return Ci && (ai = stringReplace$1(ai, ci, " "), ai = stringReplace$1(ai, hi, " ")), Nr && Ba ? Nr.createHTML(ai) : ai;
  }, ar.setConfig = function(ya) {
    ka(ya), Ni = !0;
  }, ar.clearConfig = function() {
    Yi = null, Ni = !1;
  }, ar.isValidAttribute = function(ya, qi, sa) {
    Yi || ka({});
    var si = $a(ya), Qr = $a(qi);
    return Lo(si, Qr, sa);
  }, ar.addHook = function(ya, qi) {
    typeof qi == "function" && (Si[ya] = Si[ya] || [], arrayPush$1(Si[ya], qi));
  }, ar.removeHook = function(ya) {
    Si[ya] && arrayPop$1(Si[ya]);
  }, ar.removeHooks = function(ya) {
    Si[ya] && (Si[ya] = []);
  }, ar.removeAllHooks = function() {
    Si = {};
  }, ar;
}
var purify$1 = createDOMPurify$1(), CAN_BE_WHITE_TAG_LIST = ["iframe", "embed"], whiteTagList = [];
function registerTagWhitelistIfPossible(lr) {
  includes(CAN_BE_WHITE_TAG_LIST, lr) && whiteTagList.push(lr.toLowerCase());
}
function sanitizeHTML(lr, ar) {
  return purify$1.sanitize(lr, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, ar));
}
function getChildrenHTML(lr, ar) {
  return lr.literal.replace(new RegExp("(<\\s*" + ar + "[^>]*>)|(</" + ar + "\\s*[>])", "ig"), "").trim();
}
function getHTMLAttrsByHTMLString(lr) {
  lr = lr.match(reHTMLTag)[0];
  var ar = lr.match(new RegExp(ATTRIBUTE$1, "g"));
  return ar ? ar.reduce(function(cr, ur) {
    var fr = ur.trim().split("="), dr = fr[0], hr = fr.slice(1);
    return hr.length && (cr[dr] = hr.join("=").replace(/'|"/g, "").trim()), cr;
  }, {}) : {};
}
function getHTMLAttrs(lr) {
  return toArray_1(lr.attributes).reduce(function(ar, cr) {
    return ar[cr.nodeName] = cr.nodeValue, ar;
  }, {});
}
function sanitizeDOM(lr, ar, cr, ur) {
  var fr = ur.getToDOMNode(ar)(lr), dr = cr(fr.outerHTML), hr = document.createElement("div");
  hr.innerHTML = dr, fr = hr.firstChild;
  var gr = getHTMLAttrs(fr);
  return { dom: fr, htmlAttrs: gr };
}
var schemaFactory = {
  htmlBlock: function(lr, ar, cr) {
    return {
      atom: !0,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: !0 }
      },
      parseDOM: [
        {
          tag: lr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur),
              childrenHTML: ur.innerHTML
            };
          }
        }
      ],
      toDOM: function(ur) {
        var fr = sanitizeDOM(ur, lr, ar, cr), dr = fr.dom, hr = fr.htmlAttrs;
        return hr.class = hr.class ? hr.class + " html-block" : "html-block", __spreadArray$1([lr, hr], toArray_1(dr.childNodes));
      }
    };
  },
  htmlInline: function(lr, ar, cr) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: !0 }
      },
      parseDOM: [
        {
          tag: lr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur)
            };
          }
        }
      ],
      toDOM: function(ur) {
        var fr = sanitizeDOM(ur, lr, ar, cr).htmlAttrs;
        return [lr, fr, 0];
      }
    };
  }
};
function createHTMLSchemaMap(lr, ar, cr) {
  var ur = { nodes: {}, marks: {} };
  return ["htmlBlock", "htmlInline"].forEach(function(fr) {
    lr[fr] && Object.keys(lr[fr]).forEach(function(dr) {
      var hr = fr === "htmlBlock" ? "nodes" : "marks";
      registerTagWhitelistIfPossible(dr), ur[hr][dr] = schemaFactory[fr](dr, ar, cr);
    });
  }), ur;
}
var reCloseTag = /^\s*<\s*\//, baseConvertors = {
  paragraph: function(lr, ar) {
    var cr = ar.entering, ur = ar.origin, fr = ar.options;
    return fr.nodeId ? {
      type: cr ? "openTag" : "closeTag",
      outerNewLine: !0,
      tagName: "p"
    } : ur();
  },
  softbreak: function(lr) {
    var ar = lr.prev && lr.prev.type === "htmlInline", cr = ar && /<br ?\/?>/.test(lr.prev.literal), ur = cr ? `
` : `<br>
`;
    return { type: "html", content: ur };
  },
  item: function(lr, ar) {
    var cr = ar.entering;
    if (cr) {
      var ur = {}, fr = [];
      return lr.listData.task && (ur["data-task"] = "", fr.push("task-list-item"), lr.listData.checked && (fr.push("checked"), ur["data-task-checked"] = "")), {
        type: "openTag",
        tagName: "li",
        classNames: fr,
        attributes: ur,
        outerNewLine: !0
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  code: function(lr) {
    var ar = { "data-backticks": String(lr.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes: ar },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(lr) {
    var ar = lr, cr = ar.fenceLength, ur = ar.info, fr = ur ? ur.split(/\s+/) : [], dr = [], hr = {};
    if (cr > 3 && (hr["data-backticks"] = cr), fr.length > 0 && fr[0].length > 0) {
      var gr = fr[0];
      dr.push("lang-" + gr), hr["data-language"] = gr;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: dr },
      { type: "openTag", tagName: "code", attributes: hr },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(lr, ar) {
    var cr = ar.origin, ur = ar.entering, fr = ar.skipChildren, dr = lr.info;
    if (dr.indexOf("widget") !== -1 && ur) {
      fr();
      var hr = getWidgetContent(lr), gr = widgetToDOM(dr, hr).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: gr },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return cr();
  }
};
function getHTMLRenderConvertors(lr, ar) {
  var cr = __assign$1({}, baseConvertors);
  return lr && (cr.link = function(ur, fr) {
    var dr = fr.entering, hr = fr.origin, gr = hr();
    return dr && (gr.attributes = __assign$1(__assign$1({}, gr.attributes), lr)), gr;
  }), ar && Object.keys(ar).forEach(function(ur) {
    var fr = cr[ur], dr = ar[ur];
    fr && isFunction_1(dr) ? cr[ur] = function(hr, gr) {
      var vr = __assign$1({}, gr);
      return vr.origin = function() {
        return fr(hr, gr);
      }, dr(hr, vr);
    } : includes(["htmlBlock", "htmlInline"], ur) && !isFunction_1(dr) ? cr[ur] = function(hr, gr) {
      var vr = hr.literal.match(reHTMLTag);
      if (vr) {
        var mr = vr[0], br = vr[1], yr = vr[3], kr = (br || yr).toLowerCase(), Tr = dr[kr], _r = getChildrenHTML(hr, kr);
        if (Tr) {
          var Er = __assign$1({}, hr);
          return Er.attrs = getHTMLAttrsByHTMLString(mr), Er.childrenHTML = _r, Er.type = kr, gr.entering = !reCloseTag.test(hr.literal), Tr(Er, gr);
        }
      }
      return gr.origin();
    } : cr[ur] = dr;
  }), cr;
}
var nestableTypes = ["list", "item", "blockQuote"], nestableTagNames = ["UL", "OL", "BLOCKQUOTE"];
function isBlankLine(lr, ar) {
  var cr, ur = lr.child(ar);
  return !ur.childCount || ur.childCount === 1 && !(!((cr = ur.firstChild.text) === null || cr === void 0) && cr.trim());
}
function getEditorRangeHeightInfo(lr, ar, cr) {
  var ur = getMdStartLine(ar) - 1, fr = getMdEndLine(ar) - 1, dr = cr[ur].getBoundingClientRect(), hr = cr[fr].offsetTop - cr[ur].offsetTop + cr[fr].clientHeight;
  return {
    height: hr <= 0 ? cr[ur].clientHeight : hr + getBlankLinesHeight(lr, cr, Math.min(fr + 1, lr.childCount - 1)),
    rect: dr
  };
}
function getBlankLinesHeight(lr, ar, cr) {
  for (var ur = lr.childCount - 1, fr = 0; cr <= ur && isBlankLine(lr, cr); )
    fr += ar[cr].clientHeight, cr += 1;
  return fr;
}
function findAncestorHavingId(lr, ar) {
  for (; !lr.getAttribute("data-nodeid") && lr.parentElement !== ar; )
    lr = lr.parentElement;
  return lr;
}
function getTotalOffsetTop(lr, ar) {
  for (var cr = 0; lr && lr !== ar && (includes(nestableTagNames, lr.tagName) || (cr += lr.offsetTop), lr.offsetParent !== ar.offsetParent); )
    lr = lr.parentElement;
  return cr;
}
function findAdjacentElementToScrollTop(lr, ar) {
  for (var cr = ar, ur = null; cr; ) {
    var fr = cr.firstElementChild;
    if (!fr)
      break;
    var dr = findLastSiblingElementToScrollTop(fr, lr, getTotalOffsetTop(cr, ar));
    ur = cr, cr = dr;
  }
  var hr = cr || ur;
  return hr === ar ? null : hr;
}
function findLastSiblingElementToScrollTop(lr, ar, cr) {
  return lr && ar > cr + lr.offsetTop ? findLastSiblingElementToScrollTop(lr.nextElementSibling, ar, cr) || lr : null;
}
function getAdditionalPos(lr, ar, cr, ur) {
  var fr = Math.min((lr - ar) / cr, 1);
  return fr * ur;
}
function getParentNodeObj(lr, ar) {
  for (var cr = lr.querySelector('[data-nodeid="' + ar.id + '"]'); !cr || isStyledInlineNode(ar); )
    ar = ar.parent, cr = lr.querySelector('[data-nodeid="' + ar.id + '"]');
  return getNonNestableNodeObj({ mdNode: ar, el: cr });
}
function getNonNestableNodeObj(lr) {
  for (var ar = lr.mdNode, cr = lr.el; (includes(nestableTypes, ar.type) || ar.type === "table") && ar.firstChild; )
    ar = ar.firstChild, cr = cr.firstElementChild;
  return { mdNode: ar, el: cr };
}
var offsetInfoMap = {};
function setHeight(lr, ar) {
  offsetInfoMap[lr] = offsetInfoMap[lr] || {}, offsetInfoMap[lr].height = ar;
}
function setOffsetTop(lr, ar) {
  offsetInfoMap[lr] = offsetInfoMap[lr] || {}, offsetInfoMap[lr].offsetTop = ar;
}
function getHeight(lr) {
  return offsetInfoMap[lr] && offsetInfoMap[lr].height;
}
function getOffsetTop(lr) {
  return offsetInfoMap[lr] && offsetInfoMap[lr].offsetTop;
}
function removeOffsetInfoByNode(lr) {
  lr && (delete offsetInfoMap[Number(lr.getAttribute("data-nodeid"))], toArray_1(lr.children).forEach(function(ar) {
    removeOffsetInfoByNode(ar);
  }));
}
function getAndSaveOffsetInfo(lr, ar, cr) {
  var ur = getHeight(cr), fr = getOffsetTop(cr), dr = ur || lr.clientHeight, hr = fr || getTotalOffsetTop(lr, ar) || lr.offsetTop;
  return ur || setHeight(cr, dr), fr || setOffsetTop(cr, hr), { nodeHeight: dr, offsetTop: hr };
}
var CLASS_HIGHLIGHT = cls("md-preview-highlight");
function findTableCell(lr, ar) {
  for (var cr = lr.firstChild; cr && cr.next && !(getMdStartCh(cr.next) > ar + 1); )
    cr = cr.next;
  return cr;
}
var MarkdownPreview = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = document.createElement("div");
      this.el = ur, this.eventEmitter = ar, this.isViewer = !!cr.isViewer, this.el.className = cls("md-preview");
      var fr = cr.linkAttributes, dr = cr.customHTMLRenderer, hr = cr.sanitizer, gr = cr.highlight, vr = gr === void 0 ? !1 : gr;
      this.renderer = new Renderer({
        gfm: !0,
        nodeId: !0,
        convertors: getHTMLRenderConvertors(fr, dr)
      }), this.cursorNodeId = null, this.sanitizer = hr, this.initEvent(vr), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
    }
    return lr.prototype.initContentSection = function() {
      this.previewContent = createElementWith('<div class="' + cls("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
    }, lr.prototype.toggleActive = function(ar) {
      toggleClass(this.el, "active", ar);
    }, lr.prototype.initEvent = function(ar) {
      var cr = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (ar && (this.eventEmitter.listen("changeToolbarState", function(ur) {
        var fr = ur.mdNode, dr = ur.cursorPos;
        cr.updateCursorNode(fr, dr);
      }), this.eventEmitter.listen("blur", function() {
        cr.removeHighlight();
      })), on_1(this.el, "scroll", function(ur) {
        cr.eventEmitter.emit("scroll", "preview", findAdjacentElementToScrollTop(ur.target.scrollTop, cr.previewContent));
      }), this.eventEmitter.listen("changePreviewTabPreview", function() {
        return cr.toggleActive(!0);
      }), this.eventEmitter.listen("changePreviewTabWrite", function() {
        return cr.toggleActive(!1);
      }));
    }, lr.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var ar = this.getElementByNodeId(this.cursorNodeId);
        ar && removeClass_1(ar, CLASS_HIGHLIGHT);
      }
    }, lr.prototype.updateCursorNode = function(ar, cr) {
      ar && (ar = findClosestNode(ar, function(hr) {
        return !isInlineNode$1(hr);
      }), ar.type === "tableRow" ? ar = findTableCell(ar, cr[1]) : ar.type === "tableBody" && (ar = null));
      var ur = ar ? ar.id : null;
      if (this.cursorNodeId !== ur) {
        var fr = this.getElementByNodeId(this.cursorNodeId), dr = this.getElementByNodeId(ur);
        fr && removeClass_1(fr, CLASS_HIGHLIGHT), dr && addClass_1(dr, CLASS_HIGHLIGHT), this.cursorNodeId = ur;
      }
    }, lr.prototype.getElementByNodeId = function(ar) {
      return ar ? this.previewContent.querySelector('[data-nodeid="' + ar + '"]') : null;
    }, lr.prototype.update = function(ar) {
      var cr = this;
      ar.forEach(function(ur) {
        return cr.replaceRangeNodes(ur);
      }), this.eventEmitter.emit("afterPreviewRender", this);
    }, lr.prototype.replaceRangeNodes = function(ar) {
      var cr = this, ur = ar.nodes, fr = ar.removedNodeRange, dr = this.previewContent, hr = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(ur.map(function(_r) {
        return cr.renderer.render(_r);
      }).join("")));
      if (!fr)
        dr.insertAdjacentHTML("afterbegin", hr);
      else {
        var gr = fr.id, vr = gr[0], mr = gr[1], br = this.getElementByNodeId(vr), yr = this.getElementByNodeId(mr);
        if (br) {
          br.insertAdjacentHTML("beforebegin", hr);
          for (var kr = br; kr && kr !== yr; ) {
            var Tr = kr.nextElementSibling;
            removeNode$1(kr), removeOffsetInfoByNode(kr), kr = Tr;
          }
          kr != null && kr.parentNode && (removeNode$1(kr), removeOffsetInfoByNode(kr));
        }
      }
    }, lr.prototype.getRenderer = function() {
      return this.renderer;
    }, lr.prototype.destroy = function() {
      off_1(this.el, "scroll"), this.el = null;
    }, lr.prototype.getElement = function() {
      return this.el;
    }, lr.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.previewContent.innerHTML);
    }, lr.prototype.setHTML = function(ar) {
      this.previewContent.innerHTML = ar;
    }, lr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, lr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, lr;
  }()
);
function findNodeBy(lr, ar) {
  for (var cr = lr.depth; cr; ) {
    var ur = lr.node(cr);
    if (ar(ur, cr))
      return {
        node: ur,
        depth: cr,
        offset: cr > 0 ? lr.before(cr) : 0
      };
    cr -= 1;
  }
  return null;
}
function isInListNode(lr) {
  return !!findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "listItem" || cr.name === "bulletList" || cr.name === "orderedList";
  });
}
function isInTableNode(lr) {
  return !!findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "tableHeadCell" || cr.name === "tableBodyCell";
  });
}
function findListItem(lr) {
  return findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "listItem";
  });
}
function createDOMInfoParsedRawHTML(lr) {
  return {
    tag: lr,
    getAttrs: function(ar) {
      var cr = ar.getAttribute("data-raw-html");
      return __assign$1({}, cr && { rawHTML: cr });
    }
  };
}
function createCellAttrs(lr) {
  return Object.keys(lr).reduce(function(ar, cr) {
    return cr !== "rawHTML" && lr[cr] && (cr = cr === "className" ? "class" : cr, ar[cr] = lr[cr]), ar;
  }, {});
}
function createParsedCellDOM(lr) {
  return {
    tag: lr,
    getAttrs: function(ar) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(cr, ur) {
        var fr = ur === "rawHTML" ? "data-raw-html" : ur, dr = ar.getAttribute(fr);
        return dr && (cr[ur] = includes(["rawHTML", "extended"], ur) ? dr : Number(dr)), cr;
      }, {});
    }
  };
}
function getDefaultCustomAttrs() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function getCustomAttrs(lr) {
  var ar = lr.htmlAttrs, cr = lr.classNames;
  return __assign$1(__assign$1({}, ar), { class: cr ? cr.join(" ") : null });
}
function findWrappingOutside(lr, ar) {
  var cr = lr.parent, ur = lr.startIndex, fr = lr.endIndex, dr = cr.contentMatchAt(ur).findWrapping(ar);
  if (dr) {
    var hr = dr.length ? dr[0] : ar;
    return cr.canReplaceWith(ur, fr, hr) ? dr : null;
  }
  return null;
}
function findWrappingInside(lr, ar) {
  var cr = lr.parent, ur = lr.startIndex, fr = lr.endIndex, dr = cr.child(ur), hr = ar.contentMatch.findWrapping(dr.type);
  if (hr) {
    for (var gr = hr.length ? hr[hr.length - 1] : ar, vr = gr.contentMatch, mr = ur; vr && mr < fr; mr += 1)
      vr = vr.matchType(cr.child(mr).type);
    if (vr && vr.validEnd)
      return hr;
  }
  return null;
}
function findWrappers(lr, ar, cr, ur) {
  var fr = findWrappingOutside(lr, cr), dr = findWrappingInside(ar, cr);
  if (fr && dr) {
    var hr = fr.map(function(vr) {
      return { type: vr };
    }), gr = dr.map(function(vr) {
      return { type: vr, attrs: ur };
    });
    return hr.concat({ type: cr }).concat(gr);
  }
  return null;
}
function wrapInList(lr, ar, cr, ur, fr) {
  for (var dr = ar.start, hr = ar.end, gr = ar.startIndex, vr = ar.endIndex, mr = ar.parent, br = distExports$5.Fragment.empty, yr = cr.length - 1; yr >= 0; yr -= 1)
    br = distExports$5.Fragment.from(cr[yr].type.create(cr[yr].attrs, br));
  lr.step(new ReplaceAroundStep(dr - (ur ? 2 : 0), hr, dr, hr, new distExports$5.Slice(br, 0, 0), cr.length, !0));
  for (var kr = 0, yr = 0; yr < cr.length; yr += 1)
    if (cr[yr].type === fr) {
      kr = yr + 1;
      break;
    }
  for (var Tr = cr.length - kr, _r = dr + cr.length - (ur ? 2 : 0), yr = gr, Er = vr; yr < Er; yr += 1) {
    var xr = yr === gr;
    !xr && canSplit(lr.doc, _r, Tr) && (lr.split(_r, Tr), _r += Tr * 2), _r += mr.child(yr).nodeSize;
  }
  return lr;
}
function changeToList(lr, ar, cr, ur) {
  var fr = ar.$from, dr = ar.$to, hr = ar.depth, gr = ar, vr = !1;
  if (hr >= 2 && fr.node(hr - 1).type.compatibleContent(cr) && ar.startIndex === 0 && fr.index(hr - 1)) {
    var mr = lr.doc.resolve(ar.start - 2);
    gr = new distExports$5.NodeRange(mr, mr, hr), ar.endIndex < ar.parent.childCount && (ar = new distExports$5.NodeRange(fr, lr.doc.resolve(dr.end(hr)), hr)), vr = !0;
  }
  var br = findWrappers(gr, ar, cr, ur);
  return br ? wrapInList(lr, ar, br, vr, cr) : lr;
}
function getBeforeLineListItem(lr, ar) {
  for (var cr = lr.resolve(ar); cr.node().type.name !== "paragraph"; )
    ar -= 2, cr = lr.resolve(ar);
  return findListItem(cr);
}
function toggleTaskListItems(lr, ar) {
  var cr = ar.$from, ur = ar.$to, fr = findListItem(cr), dr = findListItem(ur);
  if (fr && dr)
    for (; dr; ) {
      var hr = dr.offset, gr = dr.node, vr = { task: !gr.attrs.task, checked: !1 };
      if (lr.setNodeMarkup(hr, null, vr), hr === fr.offset)
        break;
      dr = getBeforeLineListItem(lr.doc, hr);
    }
  return lr;
}
function changeListType(lr, ar, cr) {
  var ur = ar.$from, fr = ar.$to, dr = findListItem(ur), hr = findListItem(fr);
  if (dr && hr)
    for (; hr; ) {
      var gr = hr.offset, vr = hr.node, mr = hr.depth;
      vr.attrs.task && lr.setNodeMarkup(gr, null, { task: !1, checked: !1 });
      var br = lr.doc.resolve(gr);
      if (br.parent.type !== cr) {
        var yr = br.before(mr - 1);
        lr.setNodeMarkup(yr, cr);
      }
      if (gr === dr.offset)
        break;
      hr = getBeforeLineListItem(lr.doc, gr);
    }
  return lr;
}
function changeList(lr) {
  return function(ar, cr) {
    var ur = ar.selection, fr = ar.tr, dr = ur.$from, hr = ur.$to, gr = dr.blockRange(hr);
    if (gr) {
      var vr = isInListNode(dr) ? changeListType(fr, gr, lr) : changeToList(fr, gr, lr);
      return cr(vr), !0;
    }
    return !1;
  };
}
function toggleTask() {
  return function(lr, ar) {
    var cr = lr.selection, ur = lr.tr, fr = lr.schema, dr = cr.$from, hr = cr.$to, gr = dr.blockRange(hr);
    if (gr) {
      var vr = isInListNode(dr) ? toggleTaskListItems(ur, gr) : changeToList(ur, gr, fr.nodes.bulletList, { task: !0 });
      return ar(vr), !0;
    }
    return !1;
  };
}
function sinkListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, hr = fr.$to, gr = dr.blockRange(hr, function(Er) {
      var xr = Er.childCount, Cr = Er.firstChild;
      return !!xr && Cr.type === lr;
    });
    if (gr && gr.startIndex > 0) {
      var vr = gr.parent, mr = vr.child(gr.startIndex - 1);
      if (mr.type !== lr)
        return !1;
      var br = mr.lastChild && mr.lastChild.type === vr.type, yr = br ? distExports$5.Fragment.from(lr.create()) : null, kr = new distExports$5.Slice(distExports$5.Fragment.from(lr.create(null, distExports$5.Fragment.from(vr.type.create(null, yr)))), br ? 3 : 1, 0), Tr = gr.start, _r = gr.end;
      return ur.step(new ReplaceAroundStep(Tr - (br ? 3 : 1), _r, Tr, _r, kr, 1, !0)), cr(ur), !0;
    }
    return !1;
  };
}
function liftToOuterList(lr, ar, cr) {
  var ur = ar.$from, fr = ar.$to, dr = ar.end, hr = ar.depth, gr = ar.parent, vr = fr.end(hr);
  return dr < vr && (lr.step(new ReplaceAroundStep(dr - 1, vr, dr, vr, new distExports$5.Slice(distExports$5.Fragment.from(cr.create(null, gr.copy())), 1, 0), 1, !0)), ar = new distExports$5.NodeRange(lr.doc.resolve(ur.pos), lr.doc.resolve(vr), hr)), lr.lift(ar, liftTarget(ar)), lr;
}
function liftOutOfList(lr, ar) {
  for (var cr = ar.parent, ur = ar.end, fr = ar.endIndex - 1, dr = ar.startIndex; fr > dr; fr -= 1)
    ur -= cr.child(fr).nodeSize, lr.delete(ur - 1, ur + 1);
  var hr = lr.doc.resolve(ar.start), gr = hr.nodeAfter, vr = ar.startIndex === 0, mr = ar.endIndex === cr.childCount, br = hr.node(-1), yr = hr.index(-1), kr = br.canReplace(yr + (vr ? 0 : 1), yr + 1, gr == null ? void 0 : gr.content.append(mr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr)));
  if (gr && kr) {
    var Tr = hr.pos, _r = Tr + gr.nodeSize;
    lr.step(new ReplaceAroundStep(Tr - (vr ? 1 : 0), _r + (mr ? 1 : 0), Tr + 1, _r - 1, new distExports$5.Slice((vr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr.copy(distExports$5.Fragment.empty))).append(mr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr.copy(distExports$5.Fragment.empty))), vr ? 0 : 1, mr ? 0 : 1), vr ? 0 : 1));
  }
  return lr;
}
function liftListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, hr = fr.$to, gr = dr.blockRange(hr, function(br) {
      var yr = br.childCount, kr = br.firstChild;
      return !!yr && kr.type === lr;
    });
    if (gr) {
      var vr = dr.node(gr.depth - 1).type === lr, mr = vr ? liftToOuterList(ur, gr, lr) : liftOutOfList(ur, gr);
      return cr(mr), !0;
    }
    return !1;
  };
}
function splitListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, hr = fr.$to;
    if (dr.depth < 2 || !dr.sameParent(hr))
      return !1;
    var gr = dr.node(-1);
    if (gr.type !== lr)
      return !1;
    if (dr.parent.content.size === 0 && dr.node(-1).childCount === dr.indexAfter(-1)) {
      if (dr.depth === 2 || dr.node(-3).type !== lr || dr.index(-2) !== dr.node(-2).childCount - 1)
        return !1;
      for (var vr = dr.index(-1) > 0, mr = distExports$5.Fragment.empty, br = dr.depth - (vr ? 1 : 2); br >= dr.depth - 3; br -= 1)
        mr = distExports$5.Fragment.from(dr.node(br).copy(mr));
      return mr = mr.append(distExports$5.Fragment.from(lr.createAndFill())), ur.replace(vr ? dr.before() : dr.before(-1), dr.after(-3), new distExports$5.Slice(mr, vr ? 3 : 2, 2)), ur.setSelection(distExports$3.Selection.near(ur.doc.resolve(dr.pos + (vr ? 3 : 2)))), cr(ur), !0;
    }
    var yr = hr.pos === dr.end() ? gr.contentMatchAt(0).defaultType : null, kr = yr && [null, { type: yr }];
    return ur.delete(dr.pos, hr.pos), canSplit(ur.doc, dr.pos, 2, kr) ? (ur.split(dr.pos, 2, kr), cr(ur), !0) : !1;
  };
}
function indent() {
  return function() {
    return function(lr, ar) {
      var cr = lr.selection, ur = lr.schema, fr = cr.$from, dr = cr.$to, hr = fr.blockRange(dr);
      return hr && isInListNode(fr) ? sinkListItem(ur.nodes.listItem)(lr, ar) : !1;
    };
  };
}
function outdent() {
  return function() {
    return function(lr, ar) {
      var cr = lr.selection, ur = lr.schema, fr = cr.$from, dr = cr.$to, hr = fr.blockRange(dr);
      return hr && isInListNode(fr) ? liftListItem(ur.nodes.listItem)(lr, ar) : !1;
    };
  };
}
function getWwCommands() {
  return {
    indent: indent(),
    outdent: outdent()
  };
}
var cache = /* @__PURE__ */ new Map(), TableOffsetMap = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      this.table = ar, this.tableRows = cr, this.tableStartPos = ur, this.rowInfo = fr;
    }
    return lr.create = function(ar) {
      var cr = findNodeBy(ar, function(_r) {
        var Er = _r.type;
        return Er.name === "table";
      });
      if (cr) {
        var ur = cr.node, fr = cr.depth, dr = cr.offset, hr = cache.get(ur);
        if ((hr == null ? void 0 : hr.tableStartPos) === dr + 1)
          return hr;
        var gr = [], vr = ar.start(fr), mr = ur.child(0), br = ur.child(1), yr = createOffsetMap(mr, vr), kr = createOffsetMap(br, vr + mr.nodeSize);
        mr.forEach(function(_r) {
          return gr.push(_r);
        }), br.forEach(function(_r) {
          return gr.push(_r);
        });
        var Tr = new lr(ur, gr, vr, yr.concat(kr));
        return cache.set(ur, Tr), Tr;
      }
      return null;
    }, Object.defineProperty(lr.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.getCellInfo = function(ar, cr) {
      return this.rowInfo[ar][cr];
    }, lr.prototype.posAt = function(ar, cr) {
      for (var ur = 0, fr = this.tableStartPos; ; ur += 1) {
        var dr = fr + this.tableRows[ur].nodeSize;
        if (ur === ar) {
          for (var hr = cr; hr < this.totalColumnCount && this.rowInfo[ur][hr].offset < fr; )
            hr += 1;
          return hr === this.totalColumnCount ? dr : this.rowInfo[ur][hr].offset;
        }
        fr = dr;
      }
    }, lr.prototype.getNodeAndPos = function(ar, cr) {
      var ur = this.rowInfo[ar][cr];
      return {
        node: this.table.nodeAt(ur.offset - this.tableStartOffset),
        pos: ur.offset
      };
    }, lr.prototype.extendedRowspan = function(ar, cr) {
      return !1;
    }, lr.prototype.extendedColspan = function(ar, cr) {
      return !1;
    }, lr.prototype.getRowspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.getColspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.decreaseColspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.decreaseRowspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.getColspanStartInfo = function(ar, cr) {
      return null;
    }, lr.prototype.getRowspanStartInfo = function(ar, cr) {
      return null;
    }, lr.prototype.getCellStartOffset = function(ar, cr) {
      var ur = this.rowInfo[ar][cr].offset;
      return this.extendedRowspan(ar, cr) ? this.posAt(ar, cr) : ur;
    }, lr.prototype.getCellEndOffset = function(ar, cr) {
      var ur = this.rowInfo[ar][cr], fr = ur.offset, dr = ur.nodeSize;
      return this.extendedRowspan(ar, cr) ? this.posAt(ar, cr) : fr + dr;
    }, lr.prototype.getCellIndex = function(ar) {
      for (var cr = 0; cr < this.totalRowCount; cr += 1)
        for (var ur = this.rowInfo[cr], fr = 0; fr < this.totalColumnCount; fr += 1)
          if (ur[fr].offset + 1 > ar.pos)
            return [cr, fr];
      return [0, 0];
    }, lr.prototype.getRectOffsets = function(ar, cr) {
      var ur, fr, dr;
      cr === void 0 && (cr = ar), ar.pos > cr.pos && (ur = [cr, ar], ar = ur[0], cr = ur[1]);
      var hr = this.getCellIndex(ar), gr = hr[0], vr = hr[1], mr = this.getCellIndex(cr), br = mr[0], yr = mr[1];
      return fr = getSortedNumPair(gr, br), gr = fr[0], br = fr[1], dr = getSortedNumPair(vr, yr), vr = dr[0], yr = dr[1], this.getSpannedOffsets({ startRowIdx: gr, startColIdx: vr, endRowIdx: br, endColIdx: yr });
    }, lr.prototype.getSpannedOffsets = function(ar) {
      return ar;
    }, lr;
  }()
), createOffsetMap = function(lr, ar) {
  var cr = [];
  return lr.forEach(function(ur, fr) {
    var dr = { rowspanMap: {}, colspanMap: {}, length: 0 };
    ur.forEach(function(hr, gr) {
      for (var vr = hr.nodeSize, mr = 0; dr[mr]; )
        mr += 1;
      dr[mr] = {
        // 2 is the sum of the front and back positions of the tag
        offset: ar + fr + gr + 2,
        nodeSize: vr
      }, dr.length += 1;
    }), cr.push(dr);
  }), cr;
};
function mixinTableOffsetMapPrototype(lr, ar) {
  return assign(TableOffsetMap.prototype, lr), createOffsetMap = ar, TableOffsetMap;
}
function getSelectionRanges(lr, ar, cr) {
  for (var ur = cr.startRowIdx, fr = cr.startColIdx, dr = cr.endRowIdx, hr = cr.endColIdx, gr = [], vr = ur; vr <= dr; vr += 1)
    for (var mr = fr; mr <= hr; mr += 1) {
      var br = ar.getCellInfo(vr, mr), yr = br.offset, kr = br.nodeSize;
      gr.push(new distExports$3.SelectionRange(lr.resolve(yr + 1), lr.resolve(yr + kr - 1)));
    }
  return gr;
}
function createTableFragment(lr, ar) {
  var cr = [];
  return lr.childCount && cr.push(lr), ar.childCount && cr.push(ar), distExports$5.Fragment.from(cr);
}
var CellSelection = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this, dr = cr.node(0), hr = TableOffsetMap.create(cr), gr = hr.getRectOffsets(cr, ur), vr = getSelectionRanges(dr, hr, gr);
      return fr = lr.call(this, vr[0].$from, vr[0].$to, vr) || this, fr.startCell = cr, fr.endCell = ur, fr.offsetMap = hr, fr.isCellSelection = !0, fr.visible = !1, fr;
    }
    return ar.prototype.map = function(cr, ur) {
      var fr = this.startCell.pos, dr = this.endCell.pos, hr = cr.resolve(ur.map(fr)), gr = cr.resolve(ur.map(dr)), vr = TableOffsetMap.create(hr);
      if (this.offsetMap.totalColumnCount > vr.totalColumnCount || this.offsetMap.totalRowCount > vr.totalRowCount) {
        var mr = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 }, br = mr[gr.parent.type.name], yr = gr.end(gr.depth - br), kr = Math.min(yr - 4, gr.pos);
        return distExports$3.TextSelection.create(cr, kr);
      }
      return new ar(hr, gr);
    }, ar.prototype.eq = function(cr) {
      return cr instanceof ar && cr.startCell.pos === this.startCell.pos && cr.endCell.pos === this.endCell.pos;
    }, ar.prototype.content = function() {
      for (var cr = this.startCell.node(-2), ur = this.startCell.start(-2), fr = cr.child(1).firstChild, dr = cr.child(0).type.create(), hr = cr.child(1).type.create(), gr = TableOffsetMap.create(this.startCell), vr = gr.getRectOffsets(this.startCell, this.endCell), mr = vr.startRowIdx, br = vr.startColIdx, yr = vr.endRowIdx, kr = vr.endColIdx, Tr = !1, _r = mr; _r <= yr; _r += 1) {
        for (var Er = [], xr = br; xr <= kr; xr += 1) {
          var Cr = gr.getCellInfo(_r, xr).offset, Ar = cr.nodeAt(Cr - ur);
          Ar && (Tr = Ar.type.name === "tableHeadCell", gr.extendedRowspan(_r, xr) || gr.extendedColspan(_r, xr) ? Er.push(Ar.type.create({ extended: !0 })) : Er.push(Ar.copy(Ar.content)));
        }
        var Lr = fr.copy(distExports$5.Fragment.from(Er)), Dr = Tr ? dr : hr;
        Dr.content = Dr.content.append(distExports$5.Fragment.from(Lr));
      }
      return new distExports$5.Slice(createTableFragment(dr, hr), 1, 1);
    }, ar.prototype.toJSON = function() {
      return JSON.stringify(this);
    }, ar;
  }(distExports$3.Selection)
);
function createTableHeadRow(lr, ar, cr) {
  for (var ur = ar.nodes, fr = ur.tableRow, dr = ur.tableHeadCell, hr = ur.paragraph, gr = [], vr = 0; vr < lr; vr += 1) {
    var mr = cr && cr[vr], br = hr.create(null, mr ? ar.text(mr) : []);
    gr.push(dr.create(null, br));
  }
  return [fr.create(null, gr)];
}
function createTableBodyRows(lr, ar, cr, ur) {
  for (var fr = cr.nodes, dr = fr.tableRow, hr = fr.tableBodyCell, gr = fr.paragraph, vr = [], mr = 0; mr < lr; mr += 1) {
    for (var br = [], yr = 0; yr < ar; yr += 1) {
      var kr = ur && ur[mr * ar + yr], Tr = gr.create(null, kr ? cr.text(kr) : []);
      br.push(hr.create(null, Tr));
    }
    vr.push(dr.create(null, br));
  }
  return vr;
}
function createDummyCells(lr, ar, cr, ur) {
  ur === void 0 && (ur = null);
  for (var fr = cr.nodes, dr = fr.tableHeadCell, hr = fr.tableBodyCell, gr = fr.paragraph, vr = ar === 0 ? dr : hr, mr = [], br = 0; br < lr; br += 1)
    mr.push(vr.create(ur, gr.create()));
  return mr;
}
function findCellElement(lr, ar) {
  for (; lr && lr !== ar; ) {
    if (lr.nodeName === "TD" || lr.nodeName === "TH")
      return lr;
    lr = lr.parentNode;
  }
  return null;
}
function findCell(lr) {
  return findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "tableHeadCell" || cr.name === "tableBodyCell";
  });
}
function getResolvedSelection(lr) {
  if (lr instanceof distExports$3.TextSelection) {
    var ar = lr.$anchor, cr = findCell(ar);
    if (cr) {
      var ur = ar.node(0).resolve(ar.before(cr.depth));
      return { anchor: ur, head: ur };
    }
  }
  var fr = lr, dr = fr.startCell, hr = fr.endCell;
  return { anchor: dr, head: hr };
}
function getTableContentFromSlice(lr) {
  var ar;
  if (lr.size) {
    var cr = lr.content, ur = lr.openStart, fr = lr.openEnd;
    if (cr.childCount !== 1)
      return null;
    for (; cr.childCount === 1 && (ur > 0 && fr > 0 || ((ar = cr.firstChild) === null || ar === void 0 ? void 0 : ar.type.name) === "table"); )
      ur -= 1, fr -= 1, cr = cr.firstChild.content;
    if (cr.firstChild.type.name === "tableHead" || cr.firstChild.type.name === "tableBody")
      return cr;
  }
  return null;
}
function getRowAndColumnCount(lr) {
  var ar = lr.startRowIdx, cr = lr.startColIdx, ur = lr.endRowIdx, fr = lr.endColIdx, dr = ur - ar + 1, hr = fr - cr + 1;
  return { rowCount: dr, columnCount: hr };
}
function setAttrs(lr, ar) {
  return __assign$1(__assign$1({}, lr.attrs), ar);
}
var pluginKey = new distExports$3.PluginKey("cellSelection"), MOUSE_RIGHT_BUTTON = 2, TableSelection = (
  /** @class */
  function() {
    function lr(ar) {
      this.view = ar, this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      }, this.startCellPos = null, this.init();
    }
    return lr.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    }, lr.prototype.handleMousedown = function(ar) {
      var cr = findCellElement(ar.target, this.view.dom);
      if (ar.button === MOUSE_RIGHT_BUTTON) {
        ar.preventDefault();
        return;
      }
      if (cr) {
        var ur = this.getCellPos(ar);
        ur && (this.startCellPos = ur), this.bindEvent();
      }
    }, lr.prototype.handleMousemove = function(ar) {
      var cr = pluginKey.getState(this.view.state), ur = this.getCellPos(ar), fr = this.startCellPos, dr;
      cr ? dr = this.view.state.doc.resolve(cr) : fr !== ur && (dr = fr), dr && fr && ur && this.setCellSelection(fr, ur);
    }, lr.prototype.handleMouseup = function() {
      this.startCellPos = null, this.unbindEvent(), pluginKey.getState(this.view.state) !== null && this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));
    }, lr.prototype.bindEvent = function() {
      var ar = this.view.dom;
      ar.addEventListener("mousemove", this.handlers.mousemove), ar.addEventListener("mouseup", this.handlers.mouseup);
    }, lr.prototype.unbindEvent = function() {
      var ar = this.view.dom;
      ar.removeEventListener("mousemove", this.handlers.mousemove), ar.removeEventListener("mouseup", this.handlers.mouseup);
    }, lr.prototype.getCellPos = function(ar) {
      var cr = ar.clientX, ur = ar.clientY, fr = this.view.posAtCoords({ left: cr, top: ur });
      if (fr) {
        var dr = this.view.state.doc, hr = dr.resolve(fr.pos), gr = findCell(hr);
        if (gr) {
          var vr = hr.before(gr.depth);
          return dr.resolve(vr);
        }
      }
      return null;
    }, lr.prototype.setCellSelection = function(ar, cr) {
      var ur = this.view.state, fr = ur.selection, dr = ur.tr, hr = pluginKey.getState(this.view.state) === null, gr = new CellSelection(ar, cr);
      if (hr || !fr.eq(gr)) {
        var vr = dr.setSelection(gr);
        hr && vr.setMeta(pluginKey, cr.pos), this.view.dispatch(vr);
      }
    }, lr.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    }, lr;
  }()
), SELECTED_CELL_CLASS_NAME = cls("cell-selected");
function drawCellSelection(lr) {
  var ar = lr.selection, cr = lr.doc;
  if (ar instanceof CellSelection) {
    var ur = [], fr = ar.ranges;
    return fr.forEach(function(dr) {
      var hr = dr.$from, gr = dr.$to;
      ur.push(distExports$4.Decoration.node(hr.pos - 1, gr.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));
    }), distExports$4.DecorationSet.create(cr, ur);
  }
  return null;
}
function tableSelection() {
  return new distExports$3.Plugin({
    key: pluginKey,
    state: {
      init: function() {
        return null;
      },
      apply: function(lr, ar) {
        var cr = lr.getMeta(pluginKey);
        if (cr)
          return cr === -1 ? null : cr;
        if (isNull_1(ar) || !lr.docChanged)
          return ar;
        var ur = lr.mapping.mapResult(ar), fr = ur.deleted, dr = ur.pos;
        return fr ? null : dr;
      }
    },
    props: {
      decorations: drawCellSelection,
      createSelectionBetween: function(lr) {
        var ar = lr.state;
        return isNull_1(pluginKey.getState(ar)) ? null : ar.selection;
      }
    },
    view: function(lr) {
      return new TableSelection(lr);
    }
  });
}
var Map$1 = (
  /** @class */
  function() {
    function lr() {
      this.keys = [], this.values = [];
    }
    return lr.prototype.getKeyIndex = function(ar) {
      return inArray_1(ar, this.keys);
    }, lr.prototype.get = function(ar) {
      return this.values[this.getKeyIndex(ar)];
    }, lr.prototype.set = function(ar, cr) {
      var ur = this.getKeyIndex(ar);
      return ur > -1 ? this.values[ur] = cr : (this.keys.push(ar), this.values.push(cr)), this;
    }, lr.prototype.has = function(ar) {
      return this.getKeyIndex(ar) > -1;
    }, lr.prototype.delete = function(ar) {
      var cr = this.getKeyIndex(ar);
      return cr > -1 ? (this.keys.splice(cr, 1), this.values.splice(cr, 1), !0) : !1;
    }, lr.prototype.forEach = function(ar, cr) {
      var ur = this;
      cr === void 0 && (cr = this), this.values.forEach(function(fr, dr) {
        fr && ur.keys[dr] && ar.call(cr, fr, ur.keys[dr], ur);
      });
    }, lr.prototype.clear = function() {
      this.keys = [], this.values = [];
    }, lr;
  }()
), DEFAULT_CODE = "en-US", I18n = (
  /** @class */
  function() {
    function lr() {
      this.code = DEFAULT_CODE, this.langs = new Map$1();
    }
    return lr.prototype.setCode = function(ar) {
      this.code = ar || DEFAULT_CODE;
    }, lr.prototype.setLanguage = function(ar, cr) {
      var ur = this;
      ar = [].concat(ar), ar.forEach(function(fr) {
        if (!ur.langs.has(fr))
          ur.langs.set(fr, cr);
        else {
          var dr = ur.langs.get(fr);
          ur.langs.set(fr, extend_1(dr, cr));
        }
      });
    }, lr.prototype.get = function(ar, cr) {
      cr || (cr = this.code);
      var ur = this.langs.get(cr);
      ur || (ur = this.langs.get(DEFAULT_CODE));
      var fr = ur[ar];
      if (!fr)
        throw new Error('There is no text key "' + ar + '" in ' + cr);
      return fr;
    }, lr;
  }()
), i18n = new I18n(), contextMenuGroups = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: !0,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: !0,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function getContextMenuGroups(lr, ar) {
  return contextMenuGroups.map(function(cr) {
    return cr.map(function(ur) {
      var fr = ur.action, dr = ur.command, hr = ur.payload, gr = ur.disableInThead, vr = ur.className;
      return {
        label: i18n.get(fr),
        onClick: function() {
          lr.emit("command", dr, hr);
        },
        disabled: ar && !!gr,
        className: vr
      };
    });
  }).concat();
}
function tableContextMenu(lr) {
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        contextmenu: function(ar, cr) {
          var ur = findCellElement(cr.target, ar.dom);
          if (ur) {
            cr.preventDefault();
            var fr = cr, dr = fr.clientX, hr = fr.clientY, gr = ar.dom.parentNode.getBoundingClientRect(), vr = gr.left, mr = gr.top, br = ur.nodeName === "TH";
            return lr.emit("contextmenu", {
              pos: { left: dr - vr + 10 + "px", top: hr - mr + 30 + "px" },
              menuGroups: getContextMenuGroups(lr, br),
              tableCell: ur
            }), !0;
          }
          return !1;
        }
      }
    }
  });
}
function task() {
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        mousedown: function(lr, ar) {
          var cr = ar, ur = cr.clientX, fr = cr.clientY, dr = lr.posAtCoords({ left: ur, top: fr });
          if (dr) {
            var hr = lr.state, gr = hr.doc, vr = hr.tr, mr = gr.resolve(dr.pos), br = findListItem(mr), yr = ar.target, kr = getComputedStyle(yr, ":before"), Tr = ar, _r = Tr.offsetX, Er = Tr.offsetY;
            if (!br || !isPositionInBox(kr, _r, Er))
              return !1;
            ar.preventDefault();
            var xr = mr.before(br.depth), Cr = br.node.attrs;
            return vr.setNodeMarkup(xr, null, __assign$1(__assign$1({}, Cr), { checked: !Cr.checked })), lr.dispatch(vr), !0;
          }
          return !1;
        }
      }
    }
  });
}
var EXCEPT_TYPES = ["image", "link", "customBlock", "frontMatter"], MARK_TYPES = ["strong", "strike", "emph", "code"], LIST_TYPES = ["bulletList", "orderedList", "taskList"];
function getToolbarStateType(lr, ar) {
  var cr = lr.type.name;
  return cr === "listItem" ? lr.attrs.task ? "taskList" : ar.type.name : cr.indexOf("table") !== -1 ? "table" : cr;
}
function setListNodeToolbarState(lr, ar) {
  ar[lr] = { active: !0 }, LIST_TYPES.filter(function(cr) {
    return cr !== lr;
  }).forEach(function(cr) {
    ar[cr] && delete ar[cr];
  });
}
function setMarkTypeStates(lr, ar, cr, ur) {
  MARK_TYPES.forEach(function(fr) {
    var dr = cr.marks[fr], hr = lr.marksAcross(ar) || [], gr = !!dr.isInSet(hr);
    gr && (ur[fr] = { active: !0 });
  });
}
function getToolbarState(lr, ar, cr) {
  var ur = lr.$from, fr = lr.$to, dr = lr.from, hr = lr.to, gr = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  };
  return ar.nodesBetween(dr, hr, function(vr, mr, br) {
    var yr = getToolbarStateType(vr, br);
    includes(EXCEPT_TYPES, yr) || (includes(LIST_TYPES, yr) ? (setListNodeToolbarState(yr, gr), gr.indent.disabled = !1, gr.outdent.disabled = !1) : yr === "paragraph" || yr === "text" ? setMarkTypeStates(ur, fr, cr, gr) : gr[yr] = { active: !0 });
  }), gr;
}
function toolbarStateHighlight(lr) {
  return new distExports$3.Plugin({
    view: function() {
      return {
        update: function(ar) {
          var cr = ar.state, ur = cr.selection, fr = cr.doc, dr = cr.schema;
          lr.emit("changeToolbarState", {
            toolbarState: getToolbarState(ur, fr, dr)
          });
        }
      };
    }
  });
}
var CustomBlockView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.openEditor = function() {
        if (dr.innerEditorView)
          throw new Error("The editor is already opened.");
        dr.dom.draggable = !1, dr.wrapper.style.display = "none", dr.innerViewContainer.style.display = "block", dr.innerEditorView = new distExports$4.EditorView(dr.innerViewContainer, {
          state: distExports$3.EditorState.create({
            doc: dr.node,
            plugins: [
              distExports$2.keymap({
                "Mod-z": function() {
                  return undo(dr.innerEditorView.state, dr.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return redo(dr.innerEditorView.state, dr.innerEditorView.dispatch);
                },
                Tab: function(hr, gr) {
                  return gr(hr.tr.insertText("	")), !0;
                },
                Enter: newlineInCode,
                Escape: function() {
                  return dr.cancelEditing(), !0;
                },
                "Ctrl-Enter": function() {
                  return dr.saveAndFinishEditing(), !0;
                }
              }),
              history()
            ]
          }),
          dispatchTransaction: function(hr) {
            return dr.dispatchInner(hr);
          },
          handleDOMEvents: {
            mousedown: function() {
              return dr.editorView.hasFocus() && dr.innerEditorView.focus(), !0;
            },
            blur: function() {
              return dr.saveAndFinishEditing(), !0;
            }
          }
        }), dr.innerEditorView.focus();
      }, this.node = ar, this.editorView = cr, this.getPos = ur, this.toDOMAdaptor = fr, this.innerEditorView = null, this.canceled = !1, this.dom = document.createElement("div"), this.dom.className = cls("custom-block"), this.wrapper = document.createElement("div"), this.wrapper.className = cls("custom-block-view"), this.createInnerViewContainer(), this.renderCustomBlock(), this.dom.appendChild(this.innerViewContainer), this.dom.appendChild(this.wrapper);
    }
    return lr.prototype.renderToolArea = function() {
      var ar = this, cr = document.createElement("div"), ur = document.createElement("span"), fr = document.createElement("button");
      cr.className = "tool", ur.textContent = this.node.attrs.info, ur.className = "info", fr.type = "button", fr.addEventListener("click", function() {
        return ar.openEditor();
      }), cr.appendChild(ur), cr.appendChild(fr), this.wrapper.appendChild(cr);
    }, lr.prototype.renderCustomBlock = function() {
      var ar = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (ar) {
        for (var cr = ar(this.node); this.wrapper.hasChildNodes(); )
          this.wrapper.removeChild(this.wrapper.lastChild);
        cr && this.wrapper.appendChild(cr), this.renderToolArea();
      }
    }, lr.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div"), this.innerViewContainer.className = cls("custom-block-editor"), this.innerViewContainer.style.display = "none";
    }, lr.prototype.closeEditor = function() {
      this.innerEditorView && (this.innerEditorView.destroy(), this.innerEditorView = null, this.innerViewContainer.style.display = "none"), this.wrapper.style.display = "block";
    }, lr.prototype.saveAndFinishEditing = function() {
      var ar = this.editorView.state.selection.to, cr = this.editorView.state;
      this.editorView.dispatch(cr.tr.setSelection(createTextSelection(cr.tr, ar))), this.editorView.focus(), this.renderCustomBlock(), this.closeEditor();
    }, lr.prototype.cancelEditing = function() {
      var ar = undoDepth(this.innerEditorView.state);
      for (this.canceled = !0; ar--; )
        undo(this.innerEditorView.state, this.innerEditorView.dispatch), undo(this.editorView.state, this.editorView.dispatch);
      this.canceled = !1;
      var cr = this.editorView.state.selection.to, ur = this.editorView.state;
      this.editorView.dispatch(ur.tr.setSelection(distExports$3.TextSelection.create(ur.doc, cr))), this.editorView.focus(), this.closeEditor();
    }, lr.prototype.dispatchInner = function(ar) {
      var cr = this.innerEditorView.state.applyTransaction(ar), ur = cr.state, fr = cr.transactions;
      if (this.innerEditorView.updateState(ur), !this.canceled && isFunction_1(this.getPos)) {
        for (var dr = this.editorView.state.tr, hr = StepMap.offset(this.getPos() + 1), gr = 0; gr < fr.length; gr += 1)
          for (var vr = fr[gr].steps, mr = 0; mr < vr.length; mr += 1)
            dr.step(vr[mr].map(hr));
        dr.docChanged && this.editorView.dispatch(dr);
      }
    }, lr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, this.innerEditorView || this.renderCustomBlock(), !0) : !1;
    }, lr.prototype.stopEvent = function(ar) {
      return !!this.innerEditorView && !!ar.target && this.innerEditorView.dom.contains(ar.target);
    }, lr.prototype.ignoreMutation = function() {
      return !0;
    }, lr.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor();
    }, lr;
  }()
), IMAGE_LINK_CLASS_NAME = "image-link", ImageView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this, hr;
      this.handleMousedown = function(gr) {
        gr.preventDefault();
        var vr = gr.target, mr = gr.offsetX, br = gr.offsetY;
        if (dr.imageLink && isFunction_1(dr.getPos) && hasClass_1(vr, IMAGE_LINK_CLASS_NAME)) {
          var yr = getComputedStyle(vr, ":before");
          if (gr.stopPropagation(), isPositionInBox(yr, mr, br)) {
            var kr = dr.view.state.tr, Tr = dr.getPos();
            kr.setSelection(createTextSelection(kr, Tr, Tr + 1)), dr.view.dispatch(kr), dr.eventEmitter.emit("openPopup", "link", dr.imageLink.attrs);
          }
        }
      }, this.node = ar, this.view = cr, this.getPos = ur, this.eventEmitter = fr, this.imageLink = (hr = ar.marks.filter(function(gr) {
        var vr = gr.type;
        return vr.name === "link";
      })[0]) !== null && hr !== void 0 ? hr : null, this.dom = this.createElement(), this.bindEvent();
    }
    return lr.prototype.createElement = function() {
      var ar = this.createImageElement(this.node);
      if (this.imageLink) {
        var cr = document.createElement("span");
        return cr.className = IMAGE_LINK_CLASS_NAME, cr.appendChild(ar), cr;
      }
      return ar;
    }, lr.prototype.createImageElement = function(ar) {
      var cr = document.createElement("img"), ur = ar.attrs, fr = ur.imageUrl, dr = ur.altText, hr = getCustomAttrs(ar.attrs);
      return cr.src = fr, dr && (cr.alt = dr), setAttributes(hr, cr), cr;
    }, lr.prototype.bindEvent = function() {
      this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown);
    }, lr.prototype.stopEvent = function() {
      return !0;
    }, lr.prototype.destroy = function() {
      this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown);
    }, lr;
  }()
), WRAPPER_CLASS_NAME = "toastui-editor-ww-code-block", CODE_BLOCK_LANG_CLASS_NAME = "toastui-editor-ww-code-block-language", CodeBlockView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.contentDOM = null, this.input = null, this.timer = null, this.handleMousedown = function(hr) {
        var gr = hr.target, vr = getComputedStyle(gr, ":after");
        if (vr.backgroundImage !== "none" && isFunction_1(dr.getPos)) {
          var mr = dr.view.coordsAtPos(dr.getPos()), br = mr.top, yr = mr.right;
          dr.createLanguageEditor({ top: br, right: yr });
        }
      }, this.handleKeydown = function(hr) {
        hr.key === "Enter" && dr.input && (hr.preventDefault(), dr.changeLanguage());
      }, this.node = ar, this.view = cr, this.getPos = ur, this.eventEmitter = fr, this.createElement(), this.bindDOMEvent(), this.bindEvent();
    }
    return lr.prototype.createElement = function() {
      var ar = this.node.attrs.language, cr = document.createElement("div");
      cr.setAttribute("data-language", ar || "text"), cr.className = WRAPPER_CLASS_NAME;
      var ur = this.createCodeBlockElement(), fr = ur.firstChild;
      cr.appendChild(ur), this.dom = cr, this.contentDOM = fr;
    }, lr.prototype.createCodeBlockElement = function() {
      var ar = document.createElement("pre"), cr = document.createElement("code"), ur = this.node.attrs.language, fr = getCustomAttrs(this.node.attrs);
      return ur && cr.setAttribute("data-language", ur), setAttributes(fr, ar), ar.appendChild(cr), ar;
    }, lr.prototype.createLanguageEditor = function(ar) {
      var cr = this, ur = ar.top, fr = ar.right, dr = document.createElement("span");
      dr.className = CODE_BLOCK_LANG_CLASS_NAME;
      var hr = document.createElement("input");
      hr.type = "text", hr.value = this.node.attrs.language, dr.appendChild(hr), this.view.dom.parentElement.appendChild(dr);
      var gr = dr.clientWidth;
      css_1(dr, {
        top: ur + 10 + "px",
        left: fr - gr - 10 + "px",
        width: gr + "px"
      }), this.input = hr, this.input.addEventListener("blur", function() {
        return cr.changeLanguage();
      }), this.input.addEventListener("keydown", this.handleKeydown), this.clearTimer(), this.timer = setTimeout(function() {
        cr.input.focus();
      });
    }, lr.prototype.bindDOMEvent = function() {
      this.dom && this.dom.addEventListener("click", this.handleMousedown);
    }, lr.prototype.bindEvent = function() {
      var ar = this;
      this.eventEmitter.listen("scroll", function() {
        ar.input && ar.reset();
      });
    }, lr.prototype.changeLanguage = function() {
      if (this.input && isFunction_1(this.getPos)) {
        var ar = this.input.value;
        this.reset();
        var cr = this.getPos(), ur = this.view.state.tr;
        ur.setNodeMarkup(cr, null, { language: ar }), this.view.dispatch(ur);
      }
    }, lr.prototype.reset = function() {
      var ar;
      if (!((ar = this.input) === null || ar === void 0) && ar.parentElement) {
        var cr = this.input.parentElement;
        this.input = null, removeNode$1(cr);
      }
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.stopEvent = function() {
      return !0;
    }, lr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, !0) : !1;
    }, lr.prototype.destroy = function() {
      this.reset(), this.clearTimer(), this.dom && this.dom.removeEventListener("click", this.handleMousedown);
    }, lr;
  }()
), reMSOListClassName = /MsoListParagraph/, reMSOStylePrefix = /style=(.|\n)*mso-/, reMSOListStyle = /mso-list:(.*)/, reMSOTagName = /O:P/, reMSOListBullet = /^(n|u|l)/, MSO_CLASS_NAME_LIST_PARA = "p.MsoListParagraph";
function isFromMso(lr) {
  return reMSOStylePrefix.test(lr);
}
function getListItemContents(lr) {
  for (var ar = [], cr = document.createTreeWalker(lr, 1, null, !1); cr.nextNode(); ) {
    var ur = cr.currentNode;
    if (isElemNode(ur)) {
      var fr = ur, dr = fr.outerHTML, hr = fr.textContent, gr = reMSOStylePrefix.test(dr), vr = reMSOListStyle.test(dr);
      gr && !vr && hr ? ar.push([ur, !0]) : (reMSOTagName.test(ur.nodeName) || gr && !hr || vr) && ar.push([ur, !1]);
    }
  }
  return ar.forEach(function(mr) {
    var br = mr[0], yr = mr[1];
    yr ? unwrapNode(br) : removeNode$1(br);
  }), lr.innerHTML.trim();
}
function createListItemDataFromParagraph(lr, ar) {
  var cr = lr.getAttribute("style");
  if (cr) {
    var ur = cr.match(reMSOListStyle), fr = ur[1], dr = fr.trim().split(" "), hr = dr[1], gr = parseInt(hr.replace("level", ""), 10), vr = reMSOListBullet.test(lr.textContent || "");
    return {
      id: ar,
      level: gr,
      prev: null,
      parent: null,
      children: [],
      unordered: vr,
      contents: getListItemContents(lr)
    };
  }
  return null;
}
function addListItemDetailData(lr, ar) {
  if (ar.level < lr.level)
    ar.children.push(lr), lr.parent = ar;
  else {
    for (; ar && ar.level !== lr.level; )
      ar = ar.parent;
    ar && (lr.prev = ar, lr.parent = ar.parent, lr.parent && lr.parent.children.push(lr));
  }
}
function createListData(lr) {
  var ar = [];
  return lr.forEach(function(cr, ur) {
    var fr = ar[ur - 1], dr = createListItemDataFromParagraph(cr, ur);
    dr && (fr && addListItemDetailData(dr, fr), ar.push(dr));
  }), ar;
}
function makeList(lr) {
  var ar = lr[0].unordered ? "ul" : "ol", cr = document.createElement(ar);
  return lr.forEach(function(ur) {
    var fr = ur.children, dr = ur.contents, hr = document.createElement("li");
    hr.innerHTML = dr, cr.appendChild(hr), fr.length && cr.appendChild(makeList(fr));
  }), cr;
}
function makeListFromParagraphs(lr) {
  var ar = createListData(lr), cr = ar.filter(function(ur) {
    var fr = ur.parent;
    return !fr;
  });
  return makeList(cr);
}
function isMsoListParagraphEnd(lr) {
  for (; lr && !isElemNode(lr); )
    lr = lr.nextSibling;
  return lr ? !reMSOListClassName.test(lr.className) : !0;
}
function convertMsoParagraphsToList(lr) {
  var ar = document.createElement("div");
  ar.innerHTML = lr;
  var cr = [], ur = findNodes(ar, MSO_CLASS_NAME_LIST_PARA);
  ur.forEach(function(dr) {
    var hr = isMsoListParagraphEnd(dr.nextSibling);
    if (cr.push(dr), hr) {
      var gr = makeListFromParagraphs(cr), vr = dr.nextSibling;
      vr ? insertBeforeNode(gr, vr) : appendNodes(ar, gr), cr = [];
    }
    removeNode$1(dr);
  });
  var fr = ur.length ? "<p></p>" : "";
  return "" + fr + ar.innerHTML;
}
var START_FRAGMENT_COMMENT = "<!--StartFragment-->", END_FRAGMENT_COMMENT = "<!--EndFragment-->";
function getContentBetweenFragmentComments(lr) {
  var ar = lr.indexOf(START_FRAGMENT_COMMENT), cr = lr.lastIndexOf(END_FRAGMENT_COMMENT);
  return ar > -1 && cr > -1 && (lr = lr.slice(ar + START_FRAGMENT_COMMENT.length, cr)), lr.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);
}
function convertMsoTableToCompletedTable(lr) {
  return /<\/td>((?!<\/tr>)[\s\S])*$/i.test(lr) && (lr = "<tr>" + lr + "</tr>"), /<\/tr>((?!<\/table>)[\s\S])*$/i.test(lr) && (lr = "<table>" + lr + "</table>"), lr;
}
function changePastedHTML(lr) {
  return lr = getContentBetweenFragmentComments(lr), lr = convertMsoTableToCompletedTable(lr), isFromMso(lr) && (lr = convertMsoParagraphsToList(lr)), lr;
}
function getMaxColumnCount(lr) {
  var ar = lr.reduce(function(cr, ur) {
    return cr.childCount > ur.childCount ? cr : ur;
  });
  return ar.childCount;
}
function createCells(lr, ar, cr) {
  for (var ur = [], fr = lr.childCount, dr = 0; dr < fr; dr += 1)
    if (!lr.child(dr).attrs.extended) {
      var hr = dr < fr ? cr.create(lr.child(dr).attrs, lr.child(dr).content) : cr.createAndFill();
      ur.push(hr);
    }
  return ur;
}
function copyTableHeadRow(lr, ar, cr) {
  var ur = cr.nodes, fr = ur.tableRow, dr = ur.tableHeadCell, hr = createCells(lr, ar, dr);
  return fr.create(null, hr);
}
function copyTableBodyRow(lr, ar, cr) {
  var ur = cr.nodes, fr = ur.tableRow, dr = ur.tableBodyCell, hr = createCells(lr, ar, dr);
  return fr.create(null, hr);
}
function creatTableBodyDummyRow(lr, ar) {
  for (var cr = ar.nodes, ur = cr.tableRow, fr = cr.tableBodyCell, dr = [], hr = 0; hr < lr; hr += 1) {
    var gr = fr.createAndFill();
    dr.push(gr);
  }
  return ur.create({ dummyRowForPasting: !0 }, dr);
}
function createRowsFromPastingTable(lr) {
  var ar = [], cr = [];
  if (lr.firstChild.type.name === "tableHead") {
    var ur = lr.firstChild;
    ur.forEach(function(dr) {
      return ar.push(dr);
    });
  }
  if (lr.lastChild.type.name === "tableBody") {
    var fr = lr.lastChild;
    fr.forEach(function(dr) {
      return cr.push(dr);
    });
  }
  return __spreadArray$1(__spreadArray$1([], ar), cr);
}
function createTableHead(lr, ar, cr) {
  var ur = copyTableHeadRow(lr, ar, cr);
  return cr.nodes.tableHead.create(null, ur);
}
function createTableBody(lr, ar, cr) {
  var ur = lr.map(function(dr) {
    return copyTableBodyRow(dr, ar, cr);
  });
  if (!lr.length) {
    var fr = creatTableBodyDummyRow(ar, cr);
    ur.push(fr);
  }
  return cr.nodes.tableBody.create(null, ur);
}
function createTableFromPastingTable(lr, ar, cr, ur) {
  var fr = getMaxColumnCount(lr);
  if (cr && ur)
    return ar.nodes.table.create(null, [createTableBody(lr, fr, ar)]);
  var dr = lr[0], hr = lr.slice(1), gr = [createTableHead(dr, fr, ar)];
  return hr.length && gr.push(createTableBody(hr, fr, ar)), ar.nodes.table.create(null, gr);
}
function changePastedSlice(lr, ar, cr) {
  var ur = [], fr = lr.content, dr = lr.openStart, hr = lr.openEnd;
  return fr.forEach(function(gr) {
    if (gr.type.name === "table") {
      var vr = getTableContentFromSlice(new distExports$5.Slice(distExports$5.Fragment.from(gr), 0, 0));
      if (vr) {
        var mr = createRowsFromPastingTable(vr), br = vr.firstChild.type.name === "tableBody", yr = createTableFromPastingTable(mr, ar, br, cr);
        ur.push(yr);
      }
    } else
      ur.push(gr);
  }), new distExports$5.Slice(distExports$5.Fragment.from(ur), dr, hr);
}
var DUMMY_CELL_SIZE = 4, TR_NODES_SIZE = 2;
function getDummyCellSize(lr) {
  return lr * DUMMY_CELL_SIZE;
}
function createPastingCells(lr, ar, cr) {
  var ur = [], fr = createRowsFromPastingTable(lr), dr = fr[0].childCount, hr = fr.length, gr = ar.startRowIdx === 0, vr = fr.slice(0, hr);
  if (gr) {
    var mr = vr.shift();
    if (mr) {
      var br = copyTableHeadRow(mr, dr, cr).content;
      ur.push(br);
    }
  }
  return vr.forEach(function(yr) {
    if (!yr.attrs.dummyRowForPasting) {
      var kr = copyTableBodyRow(yr, dr, cr).content;
      ur.push(kr);
    }
  }), ur;
}
function getPastingRangeInfo(lr, ar, cr) {
  for (var ur = ar.startRowIdx, fr = ar.startColIdx, dr = cr.length, hr = 0, gr = function(Tr) {
    var _r = cr[Tr].childCount;
    cr[Tr].forEach(function(Er) {
      var xr = Er.attrs, Cr = xr.colspan;
      Cr > 1 && (_r += Cr - 1);
    }), hr = Math.max(hr, _r);
  }, vr = 0; vr < dr; vr += 1)
    gr(vr);
  var mr = ur + dr - 1, br = fr + hr - 1, yr = Math.max(mr + 1 - lr.totalRowCount, 0), kr = Math.max(br + 1 - lr.totalColumnCount, 0);
  return {
    startRowIdx: ur,
    startColIdx: fr,
    endRowIdx: mr,
    endColIdx: br,
    addedRowCount: yr,
    addedColumnCount: kr
  };
}
function addReplacedOffsets(lr, ar) {
  for (var cr = lr.startRowIdx, ur = lr.startColIdx, fr = lr.endRowIdx, dr = lr.endColIdx, hr = lr.addedRowCount, gr = lr.addedColumnCount, vr = cr; vr <= fr - hr; vr += 1)
    ar.push({
      rowIdx: vr,
      startColIdx: ur,
      endColIdx: dr - gr
    });
}
function expandColumns(lr, ar, cr, ur, fr) {
  for (var dr = ur.startRowIdx, hr = ur.startColIdx, gr = ur.endRowIdx, vr = ur.endColIdx, mr = ur.addedRowCount, br = ur.addedColumnCount, yr = cr.totalRowCount, kr = 0, Tr = 0; Tr < yr; Tr += 1) {
    var _r = cr.getCellInfo(Tr, vr - br), Er = _r.offset, xr = _r.nodeSize, Cr = lr.mapping.map(Er + xr), Ar = createDummyCells(br, Tr, ar);
    if (lr.insert(Cr, Ar), Tr >= dr && Tr <= gr - mr) {
      var Lr = cr.getCellInfo(Tr, vr - br), Dr = lr.mapping.map(Lr.offset), Nr = Cr + getDummyCellSize(br);
      fr[kr] = {
        rowIdx: Tr,
        startColIdx: hr,
        endColIdx: vr,
        dummyOffsets: [Dr, Nr]
      }, kr += 1;
    }
  }
}
function expandRows(lr, ar, cr, ur, fr) {
  var dr = ur.addedRowCount, hr = ur.addedColumnCount, gr = ur.startColIdx, vr = ur.endColIdx, mr = lr.mapping.maps.length, br = cr.tableEndOffset - 2, yr = createTableBodyRows(dr, cr.totalColumnCount + hr, ar), kr = br;
  lr.insert(lr.mapping.slice(mr).map(kr), yr);
  for (var Tr = 0; Tr < dr; Tr += 1) {
    var _r = kr + getDummyCellSize(gr) + 1, Er = kr + getDummyCellSize(vr + 1) + 1, xr = kr + getDummyCellSize(cr.totalColumnCount + hr) + TR_NODES_SIZE;
    fr.push({
      rowIdx: Tr + cr.totalRowCount,
      startColIdx: gr,
      endColIdx: vr,
      dummyOffsets: [_r, Er]
    }), kr = xr;
  }
}
function replaceCells(lr, ar, cr, ur) {
  var fr = lr.mapping.maps.length;
  cr.forEach(function(dr, hr) {
    var gr = dr.rowIdx, vr = dr.startColIdx, mr = dr.endColIdx, br = dr.dummyOffsets, yr = lr.mapping.slice(fr), kr = new distExports$5.Slice(ar[hr], 0, 0), Tr = br ? br[0] : ur.getCellStartOffset(gr, vr), _r = br ? br[1] : ur.getCellEndOffset(gr, mr);
    lr.replace(yr.map(Tr), yr.map(_r), kr);
  });
}
function pasteToTable(lr, ar) {
  var cr = lr.state, ur = cr.selection, fr = cr.schema, dr = cr.tr, hr = getResolvedSelection(ur), gr = hr.anchor, vr = hr.head;
  if (gr && vr) {
    var mr = getTableContentFromSlice(ar);
    if (!mr)
      return !1;
    var br = TableOffsetMap.create(gr), yr = br.getRectOffsets(gr, vr), kr = createPastingCells(mr, yr, fr), Tr = getPastingRangeInfo(br, yr, kr), _r = [];
    return canMerge(br, Tr) && (addReplacedOffsets(Tr, _r), Tr.addedColumnCount && expandColumns(dr, fr, br, Tr, _r), Tr.addedRowCount && expandRows(dr, fr, br, Tr, _r), replaceCells(dr, kr, _r, br), lr.dispatch(dr), setSelection(lr, _r, br.getCellInfo(0, 0).offset)), !0;
  }
  return !1;
}
function setSelection(lr, ar, cr) {
  var ur = lr.state, fr = ur.tr, dr = ur.doc, hr = TableOffsetMap.create(dr.resolve(cr)), gr = ar[0], vr = gr.rowIdx, mr = gr.startColIdx, br = last$1(ar), yr = br.rowIdx, kr = br.endColIdx, Tr = hr.getCellInfo(vr, mr).offset, _r = hr.getCellInfo(yr, kr).offset;
  lr.dispatch(fr.setSelection(new CellSelection(dr.resolve(Tr), dr.resolve(_r))));
}
function canMerge(lr, ar) {
  var cr = lr.getSpannedOffsets(ar), ur = getRowAndColumnCount(cr), fr = ur.rowCount, dr = ur.columnCount, hr = getRowAndColumnCount(ar), gr = hr.rowCount, vr = hr.columnCount;
  return fr === gr && dr === vr;
}
var Doc = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Paragraph = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: __assign$1({}, getDefaultCustomAttrs()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["p", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reSoftTabLen = /\s{1,4}$/, Text = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addSpaces = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, hr = fr.$from, gr = fr.$to, vr = hr.blockRange(gr);
        return vr && !isInListNode(hr) && !isInTableNode(hr) ? (ur(dr.insertText("    ", hr.pos, gr.pos)), !0) : !1;
      };
    }, ar.prototype.removeSpaces = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, hr = fr.$from, gr = fr.$to, vr = fr.from, mr = hr.blockRange(gr);
        if (mr && !isInListNode(hr) && !isInTableNode(hr)) {
          var br = hr.nodeBefore;
          if (br && br.isText) {
            var yr = br.text, kr = yr.replace(reSoftTabLen, ""), Tr = yr.length - kr.length;
            return ur(dr.delete(vr - Tr, vr)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    }, ar;
  }(Node$2)
), Heading = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = this.levels.map(function(ur) {
          return {
            tag: "h" + ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({ level: ur }, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "inline*",
          group: "block",
          defining: !0,
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return ["h" + fr.level, getCustomAttrs(fr), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.schema.nodes[cr.level ? "heading" : "paragraph"];
          return setBlockType(dr, cr)(ur, fr);
        };
      };
    }, ar;
  }(Node$2)
), CodeBlock = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          code: !0,
          defining: !0,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html"), fr = cr.firstElementChild;
                return __assign$1({ language: (fr == null ? void 0 : fr.getAttribute("data-language")) || null }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "pre",
              ["code", __assign$1({ "data-language": ur.language }, getCustomAttrs(ur)), 0]
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return setBlockType(cr.schema.nodes.codeBlock)(cr, ur);
        };
      };
    }, ar.prototype.moveCursor = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var hr = fr.tr, gr = fr.doc, vr = fr.schema, mr = fr.selection.$from, br = ur.context.view;
        if (br.endOfTextblock(cr) && mr.node().type.name === "codeBlock") {
          var yr = mr.parent.textContent.split(`
`), kr = cr === "up" ? mr.start() : mr.end(), Tr = cr === "up" ? [kr, yr[0].length + kr] : [kr - last$1(yr).length, kr], _r = gr.resolve(cr === "up" ? mr.before() : mr.after()), Er = cr === "up" ? _r.nodeBefore : _r.nodeAfter;
          if (between$1(mr.pos, Tr[0], Tr[1]) && !Er) {
            var xr = addParagraph(hr, _r, vr);
            if (xr)
              return dr(xr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-p": cr,
        "Shift-Mod-P": cr,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    }, ar;
  }(Node$2)
), BulletList = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("ul")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["ul", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.changeList = function() {
      return function(cr, ur) {
        return changeList(cr.schema.nodes.bulletList)(cr, ur);
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: toggleTask
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.changeList(), ur = getWwCommands(), fr = ur.indent, dr = ur.outdent;
      return {
        "Mod-u": cr,
        "Mod-U": cr,
        Tab: fr(),
        "Shift-Tab": dr()
      };
    }, ar;
  }(Node$2)
), OrderedList = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("start"), fr = cr.getAttribute("data-raw-html");
                return __assign$1({ order: cr.hasAttribute("start") ? Number(ur) : 1 }, fr && { rawHTML: fr });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "ol",
              __assign$1({ start: ur.order === 1 ? null : ur.order }, getCustomAttrs(ur)),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return changeList(cr.schema.nodes.orderedList)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()(), ur = getWwCommands(), fr = ur.indent, dr = ur.outdent;
      return {
        "Mod-o": cr,
        "Mod-O": cr,
        Tab: fr(),
        "Shift-Tab": dr()
      };
    }, ar;
  }(Node$2)
), ListItem = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: !1,
          attrs: {
            task: { default: !1 },
            checked: { default: !1 },
            rawHTML: { default: null }
          },
          defining: !0,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html");
                return __assign$1({ task: cr.hasAttribute("data-task"), checked: cr.hasAttribute("data-task-checked") }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.task, dr = ur.checked;
            if (!fr)
              return [ur.rawHTML || "li", 0];
            var hr = ["task-list-item"];
            return dr && hr.push("checked"), [
              ur.rawHTML || "li",
              __assign$1({ class: hr.join(" "), "data-task": fr }, dr && { "data-task-checked": dr }),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.liftToPrevListItem = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, hr = cr.schema, gr = fr.$from, vr = fr.empty, mr = hr.nodes.listItem, br = gr.parent, yr = gr.node(-1);
        if (vr && !br.childCount && yr.type === mr) {
          if (gr.index(-2) >= 1)
            return dr.delete(gr.start(-1) - 1, gr.end(-1)), ur(dr), !0;
          var kr = gr.node(-3);
          if (kr.type === mr)
            return dr.delete(gr.start(-2) - 1, gr.end(-1)), ur(dr), !0;
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = function(ur, fr) {
        return splitListItem(ur.schema.nodes.listItem)(ur, fr);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: cr
      };
    }, ar;
  }(Node$2)
), BlockQuote = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "block+",
          group: "block",
          parseDOM: [createDOMInfoParsedRawHTML("blockquote")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["blockquote", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return wrapIn(cr.schema.nodes.blockQuote)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Alt-q": cr,
        "Alt-Q": cr
      };
    }, ar;
  }(Node$2)
), cellOffsetFnMap = {
  left: getLeftCellOffset,
  right: getRightCellOffset,
  up: getUpCellOffset,
  down: getDownCellOffset
};
function isInFirstListItem(lr, ar, cr) {
  var ur = cr[0], fr = cr[1], dr = ar.resolve(lr.before(ur - 1));
  return fr === ur && !dr.nodeBefore;
}
function isInLastListItem(lr) {
  for (var ar, cr = lr.depth, ur; cr && (ur = lr.node(cr), ur.type.name !== "tableBodyCell"); ) {
    if (ur.type.name === "listItem") {
      var fr = lr.node(cr - 1), dr = fr.lastChild === ur, hr = ((ar = ur.lastChild) === null || ar === void 0 ? void 0 : ar.type.name) !== "paragraph";
      return dr ? !hr : !1;
    }
    cr -= 1;
  }
  return !1;
}
function canMoveToBeforeCell(lr, ar, cr, ur, fr) {
  var dr = ar[0], hr = ar[1], gr = ar[2];
  if (lr === "left" || lr === "up") {
    if (fr && !isInFirstListItem(cr, ur, [dr, hr]))
      return !1;
    var vr = cr.before(gr), mr = ur.resolve(vr).nodeBefore;
    if (mr)
      return !1;
  }
  return !0;
}
function canMoveToAfterCell(lr, ar, cr, ur, fr) {
  if (lr === "right" || lr === "down") {
    if (fr && !isInLastListItem(cr))
      return !1;
    var dr = cr.after(ar), hr = ur.resolve(dr).nodeAfter;
    if (hr)
      return !1;
  }
  return !0;
}
function canMoveBetweenCells(lr, ar, cr, ur) {
  var fr = ar[0], dr = ar[1], hr = fr + 3, gr = dr >= hr, vr = gr ? fr + 1 : dr, mr = canMoveToBeforeCell(lr, [dr, hr, vr], cr, ur, gr), br = canMoveToAfterCell(lr, vr, cr, ur, gr);
  return mr && br;
}
function canBeOutOfTable(lr, ar, cr) {
  var ur = cr[0], fr = cr[1], dr = ar.getRowspanStartInfo(ur, fr), hr = lr === "up" && ur === 0, gr = lr === "down" && ((dr == null ? void 0 : dr.count) > 1 ? ur + dr.count - 1 : ur) === ar.totalRowCount - 1;
  return hr || gr;
}
function addParagraphBeforeTable(lr, ar, cr) {
  var ur = lr.doc.resolve(ar.tableStartOffset - 1);
  return ur.nodeBefore ? lr.setSelection(distExports$3.Selection.near(ur, -1)) : addParagraph(lr, ur, cr);
}
function addParagraphAfterTable(lr, ar, cr, ur) {
  ur === void 0 && (ur = !1);
  var fr = lr.doc.resolve(ar.tableEndOffset);
  return ur || !fr.nodeAfter ? addParagraph(lr, fr, cr) : lr.setSelection(distExports$3.Selection.near(fr, 1));
}
function getRightCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalRowCount, dr = ar.totalColumnCount, hr = ur === dr - 1, gr = cr === fr - 1 && hr;
  if (!gr) {
    var vr = ur + 1, mr = ar.getColspanStartInfo(cr, ur);
    (mr == null ? void 0 : mr.count) > 1 && (vr += mr.count - 1), (hr || vr === dr) && (cr += 1, vr = 0);
    var br = ar.getCellInfo(cr, vr).offset;
    return br + 2;
  }
  return null;
}
function getLeftCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalColumnCount, dr = ur === 0, hr = cr === 0 && dr;
  if (!hr) {
    ur -= 1, dr && (cr -= 1, ur = fr - 1);
    var gr = ar.getCellInfo(cr, ur), vr = gr.offset, mr = gr.nodeSize;
    return vr + mr - 2;
  }
  return null;
}
function getUpCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1];
  if (cr > 0) {
    var fr = ar.getCellInfo(cr - 1, ur), dr = fr.offset, hr = fr.nodeSize;
    return dr + hr - 2;
  }
  return null;
}
function getDownCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalRowCount;
  if (cr < fr - 1) {
    var dr = cr + 1, hr = ar.getRowspanStartInfo(cr, ur);
    (hr == null ? void 0 : hr.count) > 1 && (dr += hr.count - 1);
    var gr = ar.getCellInfo(dr, ur).offset;
    return gr + 2;
  }
  return null;
}
function moveToCell(lr, ar, cr, ur) {
  var fr = cellOffsetFnMap[lr], dr = fr(cr, ur);
  if (dr) {
    var hr = lr === "right" || lr === "down" ? 1 : -1;
    return ar.setSelection(distExports$3.Selection.near(ar.doc.resolve(dr), hr));
  }
  return null;
}
function canSelectTableNode(lr, ar, cr) {
  var ur = cr[0], fr = cr[1];
  if (lr === "up" || lr === "down")
    return !1;
  var dr = ar.tableStartOffset, hr = ar.tableEndOffset, gr = ar.getCellInfo(ur, fr), vr = gr.offset, mr = gr.nodeSize, br = lr === "left" ? dr : hr, yr = lr === "left" ? vr - 2 : vr + mr + 3;
  return br === yr;
}
function selectNode(lr, ar, cr) {
  var ur = lr.doc.resolve(ar.before(cr - 3));
  return lr.setSelection(new distExports$3.NodeSelection(ur));
}
function getTargetRowInfo(lr, ar, cr) {
  var ur, fr, dr;
  return lr === "up" ? (ur = cr.startRowIdx, fr = 0, dr = -1) : (ur = cr.endRowIdx, fr = ar.totalColumnCount - 1, dr = ar.getCellInfo(ur, fr).nodeSize + 1), { targetRowIdx: ur, insertColIdx: fr, nodeSize: dr };
}
function getRowRanges(lr, ar, cr) {
  var ur = lr.getCellInfo(ar, 0).offset, fr = lr.getCellInfo(ar, cr - 1), dr = fr.offset, hr = fr.nodeSize;
  return { from: ur, to: dr + hr };
}
var Table = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("table")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["table", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addTable = function() {
      return function(cr) {
        return cr === void 0 && (cr = { rowCount: 2, columnCount: 1, data: [] }), function(ur, fr) {
          var dr = cr.rowCount, hr = cr.columnCount, gr = cr.data, vr = ur.schema, mr = ur.selection, br = ur.tr, yr = mr.from, kr = mr.to, Tr = mr.$from, _r = yr === kr;
          if (_r && !isInTableNode(Tr)) {
            var Er = vr.nodes, xr = Er.tableHead, Cr = Er.tableBody, Ar = gr == null ? void 0 : gr.slice(0, hr), Lr = gr == null ? void 0 : gr.slice(hr, gr.length), Dr = createTableHeadRow(hr, vr, Ar), Nr = createTableBodyRows(dr - 1, hr, vr, Lr), Hr = vr.nodes.table.create(null, [
              xr.create(null, Dr),
              Cr.create(null, Nr)
            ]);
            return fr(br.replaceSelectionWith(Hr)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeTable = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, hr = TableOffsetMap.create(fr.$anchor);
          if (hr) {
            var gr = hr.tableStartOffset, vr = hr.tableEndOffset, mr = gr - 1, br = createTextSelection(dr.delete(mr, vr), mr);
            return ur(dr.setSelection(br)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addColumn = function(cr) {
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, hr = ur.tr, gr = ur.schema, vr = getResolvedSelection(dr), mr = vr.anchor, br = vr.head;
          if (mr && br) {
            for (var yr = TableOffsetMap.create(mr), kr = yr.getRectOffsets(mr, br), Tr = cr === "left" ? kr.startColIdx : kr.endColIdx + 1, _r = getRowAndColumnCount(kr).columnCount, Er = yr.totalRowCount, xr = 0; xr < Er; xr += 1) {
              var Cr = createDummyCells(_r, xr, gr);
              hr.insert(hr.mapping.map(yr.posAt(xr, Tr)), Cr);
            }
            return fr(hr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeColumn = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, hr = getResolvedSelection(fr), gr = hr.anchor, vr = hr.head;
          if (gr && vr) {
            var mr = TableOffsetMap.create(gr), br = mr.getRectOffsets(gr, vr), yr = mr.totalColumnCount, kr = mr.totalRowCount, Tr = getRowAndColumnCount(br).columnCount, _r = Tr === yr;
            if (_r)
              return !1;
            for (var Er = br.startColIdx, xr = br.endColIdx, Cr = dr.mapping.maps.length, Ar = 0; Ar < kr; Ar += 1)
              for (var Lr = xr; Lr >= Er; Lr -= 1) {
                var Dr = mr.getCellInfo(Ar, Lr), Nr = Dr.offset, Hr = Dr.nodeSize, $r = dr.mapping.slice(Cr).map(Nr), Wr = $r + Hr;
                dr.delete($r, Wr);
              }
            return ur(dr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addRow = function(cr) {
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, hr = ur.schema, gr = ur.tr, vr = getResolvedSelection(dr), mr = vr.anchor, br = vr.head;
          if (mr && br) {
            var yr = TableOffsetMap.create(mr), kr = yr.totalColumnCount, Tr = yr.getRectOffsets(mr, br), _r = getRowAndColumnCount(Tr).rowCount, Er = getTargetRowInfo(cr, yr, Tr), xr = Er.targetRowIdx, Cr = Er.insertColIdx, Ar = Er.nodeSize, Lr = xr === 0;
            if (!Lr) {
              for (var Dr = [], Nr = gr.mapping.map(yr.posAt(xr, Cr)) + Ar, Hr = [], $r = 0; $r < kr; $r += 1)
                Hr = Hr.concat(createDummyCells(1, xr, hr));
              for (var Wr = 0; Wr < _r; Wr += 1)
                Dr.push(hr.nodes.tableRow.create(null, Hr));
              return fr(gr.insert(Nr, Dr)), !0;
            }
          }
          return !1;
        };
      };
    }, ar.prototype.removeRow = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, hr = getResolvedSelection(fr), gr = hr.anchor, vr = hr.head;
          if (gr && vr) {
            var mr = TableOffsetMap.create(gr), br = mr.totalRowCount, yr = mr.totalColumnCount, kr = mr.getRectOffsets(gr, vr), Tr = getRowAndColumnCount(kr).rowCount, _r = kr.startRowIdx, Er = kr.endRowIdx, xr = _r === 0, Cr = Tr === br - 1;
            if (Cr || xr)
              return !1;
            for (var Ar = Er; Ar >= _r; Ar -= 1) {
              var Lr = getRowRanges(mr, Ar, yr), Dr = Lr.from, Nr = Lr.to;
              dr.delete(Dr - 1, Nr + 1);
            }
            return ur(dr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.alignColumn = function() {
      return function(cr) {
        return cr === void 0 && (cr = { align: "center" }), function(ur, fr) {
          var dr = cr.align, hr = ur.selection, gr = ur.tr, vr = getResolvedSelection(hr), mr = vr.anchor, br = vr.head;
          if (mr && br) {
            for (var yr = TableOffsetMap.create(mr), kr = yr.totalRowCount, Tr = yr.getRectOffsets(mr, br), _r = Tr.startColIdx, Er = Tr.endColIdx, xr = 0; xr < kr; xr += 1)
              for (var Cr = _r; Cr <= Er; Cr += 1)
                if (!yr.extendedRowspan(xr, Cr) && !yr.extendedColspan(xr, Cr)) {
                  var Ar = yr.getNodeAndPos(xr, Cr), Lr = Ar.node, Dr = Ar.pos, Nr = setAttrs(Lr, { align: dr });
                  gr.setNodeMarkup(Dr, null, Nr);
                }
            return fr(gr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.moveToCell = function(cr) {
      return function(ur, fr) {
        var dr = ur.selection, hr = ur.tr, gr = ur.schema, vr = getResolvedSelection(dr), mr = vr.anchor, br = vr.head;
        if (mr && br) {
          var yr = TableOffsetMap.create(mr), kr = yr.getCellIndex(mr), Tr = void 0;
          if (canBeOutOfTable(cr, yr, kr) ? Tr = addParagraphAfterTable(hr, yr, gr) : Tr = moveToCell(cr, hr, kr, yr), Tr)
            return fr(Tr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveInCell = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var hr = fr.selection, gr = fr.tr, vr = fr.doc, mr = fr.schema, br = hr.$from, yr = ur.context.view;
        if (!yr.endOfTextblock(cr))
          return !1;
        var kr = findNodeBy(br, function(Lr) {
          var Dr = Lr.type;
          return Dr.name === "tableHeadCell" || Dr.name === "tableBodyCell";
        });
        if (kr) {
          var Tr = findNodeBy(br, function(Lr) {
            var Dr = Lr.type;
            return Dr.name === "paragraph";
          }), _r = kr.depth;
          if (Tr && canMoveBetweenCells(cr, [_r, Tr.depth], br, vr)) {
            var Er = getResolvedSelection(hr).anchor, xr = TableOffsetMap.create(Er), Cr = xr.getCellIndex(Er), Ar = void 0;
            if (canSelectTableNode(cr, xr, Cr) ? Ar = selectNode(gr, br, _r) : canBeOutOfTable(cr, xr, Cr) ? cr === "up" ? Ar = addParagraphBeforeTable(gr, xr, mr) : cr === "down" && (Ar = addParagraphAfterTable(gr, xr, mr)) : Ar = moveToCell(cr, gr, Cr, xr), Ar)
              return dr(Ar), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.deleteCells = function() {
      return function(cr, ur) {
        var fr = cr.schema, dr = cr.selection, hr = cr.tr, gr = getResolvedSelection(dr), vr = gr.anchor, mr = gr.head, br = dr instanceof distExports$3.TextSelection;
        if (vr && mr && !br) {
          for (var yr = TableOffsetMap.create(vr), kr = yr.getRectOffsets(vr, mr), Tr = kr.startRowIdx, _r = kr.startColIdx, Er = kr.endRowIdx, xr = kr.endColIdx, Cr = Tr; Cr <= Er; Cr += 1)
            for (var Ar = _r; Ar <= xr; Ar += 1)
              if (!yr.extendedRowspan(Cr, Ar) && !yr.extendedColspan(Cr, Ar)) {
                var Lr = yr.getNodeAndPos(Cr, Ar), Dr = Lr.node, Nr = Lr.pos, Hr = createDummyCells(1, Cr, fr, Dr.attrs);
                hr.replaceWith(hr.mapping.map(Nr), hr.mapping.map(Nr + Dr.nodeSize), Hr);
              }
          return ur(hr), !0;
        }
        return !1;
      };
    }, ar.prototype.exitTable = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, hr = cr.schema, gr = fr.$from, vr = findNodeBy(gr, function(kr) {
          var Tr = kr.type;
          return Tr.name === "tableHeadCell" || Tr.name === "tableBodyCell";
        });
        if (vr) {
          var mr = findNodeBy(gr, function(kr) {
            var Tr = kr.type;
            return Tr.name === "paragraph";
          });
          if (mr) {
            var br = getResolvedSelection(fr).anchor, yr = TableOffsetMap.create(br);
            return ur(addParagraphAfterTable(dr, yr, hr, !0)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: cr,
        "Mod-Backspace": cr,
        Delete: cr,
        "Mod-Delete": cr,
        "Mod-Enter": this.exitTable()
      };
    }, ar;
  }(Node$2)
), TableHead = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("thead")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["thead", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(cr) {
                var ur = cr.querySelectorAll("tr"), fr = ur[0].children.length, dr = cr.getAttribute("data-raw-html");
                return fr ? __assign$1({}, dr && { rawHTML: dr }) : !1;
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["tbody", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableRow = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(cr) {
                var ur = cr.children.length, fr = cr.getAttribute("data-raw-html");
                return ur ? __assign$1({}, fr && { rawHTML: fr }) : !1;
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["tr", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableHeadCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),
          isolating: !0,
          parseDOM: [createParsedCellDOM("th")],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = createCellAttrs(ur);
            return ["th", __assign$1(__assign$1({}, fr), getCustomAttrs(ur)), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBodyCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: !0,
          parseDOM: [createParsedCellDOM("td")],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = createCellAttrs(ur);
            return ["td", fr, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Image = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          inline: !0,
          attrs: __assign$1({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "inline",
          selectable: !1,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(cr) {
                var ur = sanitizeHTML(cr, { RETURN_DOM_FRAGMENT: !0 }).firstChild, fr = ur.getAttribute("src") || "", dr = ur.getAttribute("data-raw-html"), hr = ur.getAttribute("alt");
                return __assign$1({
                  imageUrl: fr,
                  altText: hr
                }, dr && { rawHTML: dr });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "img",
              __assign$1(__assign$1({ src: escapeXml$1(ur.imageUrl) }, ur.altText && { alt: ur.altText }), getCustomAttrs(ur))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addImage = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.schema, hr = ur.tr, gr = cr, vr = gr.imageUrl, mr = gr.altText;
          if (!vr)
            return !1;
          var br = dr.nodes.image.createAndFill(__assign$1({ imageUrl: vr }, mr && { altText: mr }));
          return fr(hr.replaceSelectionWith(br).scrollIntoView()), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    }, ar;
  }(Node$2)
), ROOT_BLOCK_DEPTH = 1, ThematicBreak = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: !1,
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["div", getCustomAttrs(ur), [ur.rawHTML || "hr"]];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      var cr = this;
      return function() {
        return function(ur, fr) {
          var dr, hr = ur.selection, gr = hr.$from, vr = hr.$to;
          if (gr === vr) {
            var mr = ur.doc, br = ur.schema.nodes, yr = br.thematicBreak, kr = br.paragraph, Tr = [yr.create()], _r = gr.node(ROOT_BLOCK_DEPTH), Er = mr.child(mr.childCount - 1) === _r, xr = mr.resolve(gr.after(ROOT_BLOCK_DEPTH)), Cr = ((dr = gr.nodeAfter) === null || dr === void 0 ? void 0 : dr.type.name) === cr.name;
            return (Er || Cr) && Tr.push(kr.create()), fr(ur.tr.insert(xr.pos, Tr).scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var cr = this.hr()();
      return {
        "Mod-l": cr,
        "Mod-L": cr
      };
    }, ar;
  }(Node$2)
), Strong = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["b", "strong"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "strong", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.strong)(cr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var cr = this.bold()();
      return {
        "Mod-b": cr,
        "Mod-B": cr
      };
    }, ar;
  }(Mark)
), Emph = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["i", "em"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "em", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.emph)(cr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var cr = this.italic()();
      return {
        "Mod-i": cr,
        "Mod-I": cr
      };
    }, ar;
  }(Mark)
), Strike = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["s", "del"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "del", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.strike)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Mod-s": cr,
        "Mod-S": cr
      };
    }, ar;
  }(Mark)
), Link = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this) || this;
      return ur.linkAttributes = cr, ur;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = this;
        return {
          attrs: __assign$1({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          inclusive: !1,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(ur) {
                var fr = sanitizeHTML(ur, { RETURN_DOM_FRAGMENT: !0 }).firstChild, dr = fr.getAttribute("href") || "", hr = fr.getAttribute("title") || "", gr = fr.getAttribute("data-raw-html");
                return __assign$1({ linkUrl: dr, title: hr }, gr && { rawHTML: gr });
              }
            }
          ],
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [
              fr.rawHTML || "a",
              __assign$1(__assign$1({ href: escapeXml$1(fr.linkUrl) }, cr.linkAttributes), getCustomAttrs(fr))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLink = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = cr, hr = dr.linkUrl, gr = dr.linkText, vr = gr === void 0 ? "" : gr, mr = ur.schema, br = ur.tr, yr = ur.selection, kr = yr.empty, Tr = yr.from, _r = yr.to;
          if (Tr && _r && hr) {
            var Er = { linkUrl: hr }, xr = mr.mark("link", Er);
            if (kr && vr) {
              var Cr = createTextNode$1(mr, vr, xr);
              br.replaceRangeWith(Tr, _r, Cr);
            } else
              br.addMark(Tr, _r, xr);
            return fr(br.scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.toggleLink = function() {
      return function(cr) {
        return function(ur, fr) {
          return toggleMark$1(ur.schema.marks.link, cr)(ur, fr);
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    }, ar;
  }(Mark)
), Code = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html");
                return __assign$1({}, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [ur.rawHTML || "code", getCustomAttrs(ur)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.code)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-c": cr,
        "Shift-Mod-C": cr
      };
    }, ar;
  }(Mark)
), CustomBlock = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: !0,
          code: !0,
          defining: !0,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-custom-info");
                return { info: ur };
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["div", { "data-custom-info": ur.info || null }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          return cr != null && cr.info ? setBlockType(ur.schema.nodes.customBlock, cr)(ur, fr) : !1;
        };
      };
    }, ar;
  }(Node$2)
), FrontMatter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur, fr) {
          var dr = cr.selection.$from;
          return fr.endOfTextblock("down") && dr.node().type.name === "frontMatter" ? exitCode(cr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
), HTMLComment = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur, fr) {
          var dr = cr.selection.$from;
          return fr.endOfTextblock("down") && dr.node().type.name === "htmlComment" ? exitCode(cr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
);
function createSpecs(lr) {
  return new SpecManager([
    new Doc(),
    new Paragraph(),
    new Text(),
    new Heading(),
    new CodeBlock(),
    new BulletList(),
    new OrderedList(),
    new ListItem(),
    new BlockQuote(),
    new Table(),
    new TableHead(),
    new TableBody(),
    new TableRow(),
    new TableHeadCell(),
    new TableBodyCell(),
    new Image(),
    new ThematicBreak(),
    new Strong(),
    new Emph(),
    new Strike(),
    new Link(lr),
    new Code(),
    new CustomBlock(),
    new FrontMatter(),
    new Widget(),
    new HTMLComment()
  ]);
}
var CONTENTS_CLASS_NAME = cls("contents"), WysiwygEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr) || this, dr = ur.toDOMAdaptor, hr = ur.htmlSchemaMap, gr = hr === void 0 ? {} : hr, vr = ur.linkAttributes, mr = vr === void 0 ? {} : vr, br = ur.useCommandShortcut, yr = br === void 0 ? !0 : br, kr = ur.wwPlugins, Tr = kr === void 0 ? [] : kr, _r = ur.wwNodeViews, Er = _r === void 0 ? {} : _r;
      return fr.editorType = "wysiwyg", fr.el.classList.add("ww-mode"), fr.toDOMAdaptor = dr, fr.linkAttributes = mr, fr.extraPlugins = Tr, fr.pluginNodeViews = Er, fr.specs = fr.createSpecs(), fr.schema = fr.createSchema(gr), fr.context = fr.createContext(), fr.keymaps = fr.createKeymaps(yr), fr.view = fr.createView(), fr.commands = fr.createCommands(), fr.specs.setContext(__assign$1(__assign$1({}, fr.context), { view: fr.view })), fr.initEvent(), fr;
    }
    return ar.prototype.createSpecs = function() {
      return createSpecs(this.linkAttributes);
    }, ar.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSchema = function(cr) {
      return new distExports$5.Schema({
        nodes: __assign$1(__assign$1({}, this.specs.nodes), cr.nodes),
        marks: __assign$1(__assign$1({}, this.specs.marks), cr.marks)
      });
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        tableSelection(),
        tableContextMenu(this.eventEmitter),
        task(),
        toolbarStateHighlight(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createPluginNodeViews = function() {
      var cr = this, ur = cr.eventEmitter, fr = cr.pluginNodeViews, dr = {};
      return fr && Object.keys(fr).forEach(function(hr) {
        dr[hr] = function(gr, vr, mr) {
          return fr[hr](gr, vr, mr, ur);
        };
      }), dr;
    }, ar.prototype.createView = function() {
      var cr = this, ur = this, fr = ur.toDOMAdaptor, dr = ur.eventEmitter;
      return new distExports$4.EditorView(this.el, {
        state: this.createState(),
        attributes: {
          class: CONTENTS_CLASS_NAME
        },
        nodeViews: __assign$1({
          customBlock: function(hr, gr, vr) {
            return new CustomBlockView(hr, gr, vr, fr);
          },
          image: function(hr, gr, vr) {
            return new ImageView(hr, gr, vr, dr);
          },
          codeBlock: function(hr, gr, vr) {
            return new CodeBlockView(hr, gr, vr, dr);
          },
          widget: widgetNodeView
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(hr) {
          var gr = cr.view.state.applyTransaction(hr).state;
          cr.view.updateState(gr), cr.emitChangeEvent(hr.scrollIntoView()), cr.eventEmitter.emit("setFocusedNode", gr.selection.$from.node(1));
        },
        transformPastedHTML: changePastedHTML,
        transformPasted: function(hr) {
          return changePastedSlice(hr, cr.schema, isInTableNode(cr.view.state.selection.$from));
        },
        handlePaste: function(hr, gr, vr) {
          return pasteToTable(hr, vr);
        },
        handleKeyDown: function(hr, gr) {
          return cr.eventEmitter.emit("keydown", cr.editorType, gr), !1;
        },
        handleDOMEvents: {
          paste: function(hr, gr) {
            var vr = gr.clipboardData || window.clipboardData, mr = vr == null ? void 0 : vr.items;
            if (mr) {
              var br = toArray_1(mr).some(function(kr) {
                return kr.kind === "string" && kr.type === "text/rtf";
              });
              if (!br) {
                var yr = pasteImageOnly(mr);
                yr && (gr.preventDefault(), emitImageBlobHook(cr.eventEmitter, yr, gr.type));
              }
            }
            return !1;
          },
          keyup: function(hr, gr) {
            return cr.eventEmitter.emit("keyup", cr.editorType, gr), !1;
          },
          scroll: function() {
            return cr.eventEmitter.emit("scroll", "editor"), !0;
          }
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view, getWwCommands());
    }, ar.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.view.dom.innerHTML);
    }, ar.prototype.getModel = function() {
      return this.view.state.doc;
    }, ar.prototype.getSelection = function() {
      var cr = this.view.state.selection, ur = cr.from, fr = cr.to;
      return [ur, fr];
    }, ar.prototype.getSchema = function() {
      return this.view.state.schema;
    }, ar.prototype.replaceSelection = function(cr, ur, fr) {
      var dr = this.view.state, hr = dr.schema, gr = dr.tr, vr = cr.split(`
`), mr = vr.map(function(kr) {
        return createParagraph(hr, createNodesWithWidget(kr, hr));
      }), br = new distExports$5.Slice(distExports$5.Fragment.from(mr), 1, 1), yr = isNumber_1(ur) && isNumber_1(fr) ? gr.replaceRange(ur, fr, br) : gr.replaceSelection(br);
      this.view.dispatch(yr), this.focus();
    }, ar.prototype.deleteSelection = function(cr, ur) {
      var fr = this.view.state.tr, dr = isNumber_1(cr) && isNumber_1(ur) ? fr.deleteRange(cr, ur) : fr.deleteSelection();
      this.view.dispatch(dr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(cr, ur) {
      var fr = this.view.state, dr = fr.doc, hr = fr.selection, gr = hr.from, vr = hr.to;
      return isNumber_1(cr) && isNumber_1(ur) && (gr = cr, vr = ur), dr.textBetween(gr, vr, `
`);
    }, ar.prototype.setModel = function(cr, ur) {
      ur === void 0 && (ur = !1);
      var fr = this.view.state, dr = fr.tr, hr = fr.doc;
      this.view.dispatch(dr.replaceWith(0, hr.content.size, cr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.setSelection = function(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this.view.state.tr, dr = createTextSelection(fr, cr, ur);
      this.view.dispatch(fr.setSelection(dr).scrollIntoView());
    }, ar.prototype.addWidget = function(cr, ur, fr) {
      var dr = this.view, hr = dr.dispatch, gr = dr.state;
      hr(gr.tr.setMeta("widget", { pos: fr != null ? fr : gr.selection.to, node: cr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(cr, ur, fr) {
      var dr = this.view.state, hr = dr.tr, gr = dr.schema, vr = createNodesWithWidget(fr, gr);
      this.view.dispatch(hr.replaceWith(cr, ur, vr));
    }, ar.prototype.getRangeInfoOfNode = function(cr) {
      var ur = this.view.state, fr = ur.doc, dr = ur.selection, hr = cr ? fr.resolve(cr) : dr.$from, gr = hr.marks(), vr = hr.node(), mr = hr.start(), br = hr.end(), yr = vr.type.name;
      if (gr.length || yr === "paragraph") {
        var kr = gr[gr.length - 1], Tr = function(_r) {
          return _r.length ? includes(_r, kr) : !0;
        };
        yr = kr ? kr.type.name : "text", vr.forEach(function(_r, Er) {
          var xr = _r.isText, Cr = _r.nodeSize, Ar = _r.marks, Lr = hr.pos - mr;
          xr && Er <= Lr && Er + Cr >= Lr && Tr(Ar) && (mr = mr + Er, br = mr + Cr);
        });
      }
      return { range: [mr, br], type: yr };
    }, ar;
  }(EditorBase)
), isUndefined = isUndefined_1, isNull = isNull_1;
function isExisty$1(lr) {
  return !isUndefined(lr) && !isNull(lr);
}
var isExisty_1 = isExisty$1, isExisty = isExisty_1;
function isTruthy$1(lr) {
  return isExisty(lr) && lr !== !1;
}
var isTruthy_1 = isTruthy$1, isTruthy = isTruthy_1;
function isFalsy(lr) {
  return !isTruthy(lr);
}
var isFalsy_1 = isFalsy, eventTypeList = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
], EventEmitter = (
  /** @class */
  function() {
    function lr() {
      var ar = this;
      this.events = new Map$1(), this.eventTypes = eventTypeList.reduce(function(cr, ur) {
        return __assign$1(__assign$1({}, cr), { type: ur });
      }, {}), this.hold = !1, eventTypeList.forEach(function(cr) {
        ar.addEventType(cr);
      });
    }
    return lr.prototype.listen = function(ar, cr) {
      var ur = this.getTypeInfo(ar), fr = this.events.get(ur.type) || [];
      if (!this.hasEventType(ur.type))
        throw new Error("There is no event type " + ur.type);
      ur.namespace && (cr.namespace = ur.namespace), fr.push(cr), this.events.set(ur.type, fr);
    }, lr.prototype.emit = function(ar) {
      for (var cr = [], ur = 1; ur < arguments.length; ur++)
        cr[ur - 1] = arguments[ur];
      var fr = this.getTypeInfo(ar), dr = this.events.get(fr.type), hr = [];
      return !this.hold && dr && dr.forEach(function(gr) {
        var vr = gr.apply(void 0, cr);
        isUndefined_1(vr) || hr.push(vr);
      }), hr;
    }, lr.prototype.emitReduce = function(ar, cr) {
      for (var ur = [], fr = 2; fr < arguments.length; fr++)
        ur[fr - 2] = arguments[fr];
      var dr = this.events.get(ar);
      return !this.hold && dr && dr.forEach(function(hr) {
        var gr = hr.apply(void 0, __spreadArray$1([cr], ur));
        isFalsy_1(gr) || (cr = gr);
      }), cr;
    }, lr.prototype.getTypeInfo = function(ar) {
      var cr = ar.split(".");
      return {
        type: cr[0],
        namespace: cr[1]
      };
    }, lr.prototype.hasEventType = function(ar) {
      return !isUndefined_1(this.eventTypes[this.getTypeInfo(ar).type]);
    }, lr.prototype.addEventType = function(ar) {
      if (this.hasEventType(ar))
        throw new Error("There is already have event type " + ar);
      this.eventTypes[ar] = ar;
    }, lr.prototype.removeEventHandler = function(ar, cr) {
      var ur = this, fr = this.getTypeInfo(ar), dr = fr.type, hr = fr.namespace;
      dr && cr ? this.removeEventHandlerWithHandler(dr, cr) : dr && !hr ? this.events.delete(dr) : !dr && hr ? this.events.forEach(function(gr, vr) {
        ur.removeEventHandlerWithTypeInfo(vr, hr);
      }) : dr && hr && this.removeEventHandlerWithTypeInfo(dr, hr);
    }, lr.prototype.removeEventHandlerWithHandler = function(ar, cr) {
      var ur = this.events.get(ar);
      if (ur) {
        var fr = ur.indexOf(cr);
        ur.indexOf(cr) >= 0 && ur.splice(fr, 1);
      }
    }, lr.prototype.removeEventHandlerWithTypeInfo = function(ar, cr) {
      var ur = [], fr = this.events.get(ar);
      fr && (fr.map(function(dr) {
        return dr.namespace !== cr && ur.push(dr), null;
      }), this.events.set(ar, ur));
    }, lr.prototype.getEvents = function() {
      return this.events;
    }, lr.prototype.holdEventInvoke = function(ar) {
      this.hold = !0, ar(), this.hold = !1;
    }, lr;
  }()
), CommandManager = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      this.eventEmitter = ar, this.mdCommands = cr, this.wwCommands = ur, this.getEditorType = fr, this.initEvent();
    }
    return lr.prototype.initEvent = function() {
      var ar = this;
      this.eventEmitter.listen("command", function(cr, ur) {
        ar.exec(cr, ur);
      });
    }, lr.prototype.addCommand = function(ar, cr, ur) {
      ar === "markdown" ? this.mdCommands[cr] = ur : this.wwCommands[cr] = ur;
    }, lr.prototype.deleteCommand = function(ar, cr) {
      ar === "markdown" ? delete this.mdCommands[cr] : delete this.wwCommands[cr];
    }, lr.prototype.exec = function(ar, cr) {
      var ur = this.getEditorType();
      ur === "markdown" ? this.mdCommands[ar](cr) : this.wwCommands[ar](cr);
    }, lr;
  }()
);
function getTextWithoutTrailingNewline(lr) {
  return lr[lr.length - 1] === `
` ? lr.slice(0, lr.length - 1) : lr;
}
function isCustomHTMLInlineNode(lr, ar) {
  var cr = lr.schema, ur = ar.literal, fr = ur.match(reHTMLTag);
  if (fr) {
    var dr = fr[1], hr = fr[3], gr = (dr || hr).toLowerCase();
    return ar.type === "htmlInline" && !!(cr.marks[gr] || cr.nodes[gr]);
  }
  return !1;
}
function isInlineNode(lr) {
  var ar = lr.type;
  return includes(["text", "strong", "emph", "strike", "image", "link", "code"], ar);
}
function isSoftbreak(lr) {
  return (lr == null ? void 0 : lr.type) === "softbreak";
}
function isListNode(lr) {
  var ar = lr.type, cr = lr.literal, ur = ar === "htmlInline" && cr.match(reHTMLTag);
  if (ur) {
    var fr = ur[1], dr = ur[3], hr = fr || dr;
    if (hr)
      return includes(["ul", "ol", "li"], hr.toLowerCase());
  }
  return !1;
}
function getListItemAttrs(lr) {
  var ar = lr.literal, cr = /data-task/.test(ar), ur = /data-task-checked/.test(ar);
  return { task: cr, checked: ur };
}
function getMatchedAttributeValue(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  var ur = document.createElement("div");
  ur.innerHTML = sanitizeHTML(lr);
  var fr = ur.firstChild;
  return ar.map(function(dr) {
    return fr.getAttribute(dr) || "";
  });
}
function createConvertors(lr) {
  var ar = {};
  return Object.keys(lr).forEach(function(cr) {
    var ur = cr.split(", ");
    ur.forEach(function(fr) {
      var dr = fr.toLowerCase();
      ar[dr] = lr[cr];
    });
  }), ar;
}
var convertors = {
  "b, strong": function(lr, ar, cr) {
    var ur = lr.schema.marks.strong;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  "i, em": function(lr, ar, cr) {
    var ur = lr.schema.marks.emph;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  "s, del": function(lr, ar, cr) {
    var ur = lr.schema.marks.strike;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  code: function(lr, ar, cr) {
    var ur = lr.schema.marks.code;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  a: function(lr, ar, cr) {
    var ur = ar.literal, fr = lr.schema.marks.link;
    if (cr) {
      var dr = getMatchedAttributeValue(ur, "href")[0];
      lr.openMark(fr.create({
        linkUrl: dr,
        rawHTML: cr
      }));
    } else
      lr.closeMark(fr);
  },
  img: function(lr, ar, cr) {
    var ur = ar.literal;
    if (cr) {
      var fr = getMatchedAttributeValue(ur, "src", "alt"), dr = fr[0], hr = fr[1], gr = lr.schema.nodes.image;
      lr.addNode(gr, __assign$1({ rawHTML: cr, imageUrl: dr }, hr && { altText: hr }));
    }
  },
  hr: function(lr, ar, cr) {
    lr.addNode(lr.schema.nodes.thematicBreak, { rawHTML: cr });
  },
  br: function(lr, ar) {
    var cr = lr.schema.nodes.paragraph, ur = ar.parent, fr = ar.prev, dr = ar.next;
    (ur == null ? void 0 : ur.type) === "paragraph" ? (isSoftbreak(fr) && lr.openNode(cr), isSoftbreak(dr) ? lr.closeNode() : dr && (lr.closeNode(), lr.openNode(cr))) : (ur == null ? void 0 : ur.type) === "tableCell" && (fr && (isInlineNode(fr) || isCustomHTMLInlineNode(lr, fr)) && lr.closeNode(), dr && (isInlineNode(dr) || isCustomHTMLInlineNode(lr, dr)) && lr.openNode(cr));
  },
  pre: function(lr, ar, cr) {
    var ur, fr, dr = document.createElement("div");
    dr.innerHTML = ar.literal;
    var hr = (fr = (ur = dr.firstChild) === null || ur === void 0 ? void 0 : ur.firstChild) === null || fr === void 0 ? void 0 : fr.textContent;
    lr.openNode(lr.schema.nodes.codeBlock, { rawHTML: cr }), lr.addText(getTextWithoutTrailingNewline(hr)), lr.closeNode();
  },
  "ul, ol": function(lr, ar, cr) {
    if (ar.parent.type === "tableCell") {
      var ur = lr.schema.nodes, fr = ur.bulletList, dr = ur.orderedList, hr = ur.paragraph, gr = cr === "ul" ? fr : dr;
      cr ? (ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.openNode(gr, { rawHTML: cr })) : (lr.closeNode(), ar.next && !isListNode(ar.next) && lr.openNode(hr));
    }
  },
  li: function(lr, ar, cr) {
    var ur;
    if (((ur = ar.parent) === null || ur === void 0 ? void 0 : ur.type) === "tableCell") {
      var fr = lr.schema.nodes, dr = fr.listItem, hr = fr.paragraph;
      if (cr) {
        var gr = getListItemAttrs(ar);
        ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.openNode(dr, __assign$1({ rawHTML: cr }, gr)), ar.next && !isListNode(ar.next) && lr.openNode(hr);
      } else
        ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.closeNode();
    }
  }
}, htmlToWwConvertors = createConvertors(convertors);
function isBRTag(lr) {
  return lr.type === "htmlInline" && reBR.test(lr.literal);
}
function addRawHTMLAttributeToDOM(lr) {
  toArray_1(lr.childNodes).forEach(function(ar) {
    if (isElemNode(ar)) {
      var cr = ar.nodeName.toLowerCase();
      ar.setAttribute("data-raw-html", cr), ar.childNodes && addRawHTMLAttributeToDOM(ar);
    }
  });
}
var toWwConvertors = {
  text: function(lr, ar) {
    lr.addText(ar.literal || "");
  },
  paragraph: function(lr, ar, cr, ur) {
    var fr, dr = cr.entering;
    if (dr) {
      var hr = lr.schema.nodes.paragraph;
      ((fr = ar.prev) === null || fr === void 0 ? void 0 : fr.type) === "paragraph" && (lr.openNode(hr, ur), lr.closeNode()), lr.openNode(hr, ur);
    } else
      lr.closeNode();
  },
  heading: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    if (fr) {
      var dr = ar, hr = dr.level, gr = dr.headingType;
      lr.openNode(lr.schema.nodes.heading, __assign$1({ level: hr, headingType: gr }, ur));
    } else
      lr.closeNode();
  },
  codeBlock: function(lr, ar, cr) {
    var ur = lr.schema.nodes.codeBlock, fr = ar, dr = fr.info, hr = fr.literal;
    lr.openNode(ur, __assign$1({ language: dr }, cr)), lr.addText(getTextWithoutTrailingNewline(hr || "")), lr.closeNode();
  },
  list: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    if (fr) {
      var dr = lr.schema.nodes, hr = dr.bulletList, gr = dr.orderedList, vr = ar.listData, mr = vr.type, br = vr.start;
      mr === "bullet" ? lr.openNode(hr, ur) : lr.openNode(gr, __assign$1({ order: br }, ur));
    } else
      lr.closeNode();
  },
  item: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.nodes.listItem, hr = ar.listData, gr = hr.task, vr = hr.checked;
    if (fr) {
      var mr = __assign$1(__assign$1(__assign$1({}, gr && { task: gr }), vr && { checked: vr }), ur);
      lr.openNode(dr, mr);
    } else
      lr.closeNode();
  },
  blockQuote: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.blockQuote, ur) : lr.closeNode();
  },
  image: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = cr.skipChildren, hr = lr.schema.nodes.image, gr = ar, vr = gr.destination, mr = gr.firstChild;
    fr && dr && dr(), lr.addNode(hr, __assign$1(__assign$1({ imageUrl: vr }, mr && { altText: mr.literal }), ur));
  },
  thematicBreak: function(lr, ar, cr, ur) {
    lr.addNode(lr.schema.nodes.thematicBreak, ur);
  },
  strong: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.strong;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  emph: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.emph;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  link: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.link, hr = ar, gr = hr.destination, vr = hr.title;
    if (fr) {
      var mr = __assign$1({ linkUrl: gr, title: vr }, ur);
      lr.openMark(dr.create(mr));
    } else
      lr.closeMark(dr);
  },
  softbreak: function(lr, ar) {
    if (ar.parent.type === "paragraph") {
      var cr = ar.prev, ur = ar.next;
      cr && !isBRTag(cr) && lr.closeNode(), ur && !isBRTag(ur) && lr.openNode(lr.schema.nodes.paragraph);
    }
  },
  // GFM specifications node
  table: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.table, ur) : lr.closeNode();
  },
  tableHead: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableHead, ur) : lr.closeNode();
  },
  tableBody: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableBody, ur) : lr.closeNode();
  },
  tableRow: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableRow, ur) : lr.closeNode();
  },
  tableCell: function(lr, ar, cr) {
    var ur = cr.entering;
    if (!ar.ignored) {
      var fr = function(_r) {
        return _r && (isInlineNode(_r) || isCustomHTMLInlineNode(lr, _r));
      };
      if (ur) {
        var dr = lr.schema.nodes, hr = dr.tableHeadCell, gr = dr.tableBodyCell, vr = dr.paragraph, mr = ar.parent.parent, br = mr.type === "tableHead" ? hr : gr, yr = mr.parent, kr = (yr.columns[ar.startIdx] || {}).align, Tr = __assign$1({}, ar.attrs);
        kr && (Tr.align = kr), lr.openNode(br, Tr), fr(ar.firstChild) && lr.openNode(vr);
      } else
        fr(ar.lastChild) && lr.closeNode(), lr.closeNode();
    }
  },
  strike: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.strike;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  code: function(lr, ar, cr, ur) {
    var fr = lr.schema.marks.code;
    lr.openMark(fr.create(ur)), lr.addText(getTextWithoutTrailingNewline(ar.literal || "")), lr.closeMark(fr);
  },
  customBlock: function(lr, ar) {
    var cr = lr.schema.nodes, ur = cr.customBlock, fr = cr.paragraph, dr = ar, hr = dr.info, gr = dr.literal;
    lr.openNode(ur, { info: hr }), lr.addText(getTextWithoutTrailingNewline(gr || "")), lr.closeNode(), ar.next || (lr.openNode(fr), lr.closeNode());
  },
  frontMatter: function(lr, ar) {
    lr.openNode(lr.schema.nodes.frontMatter), lr.addText(ar.literal), lr.closeNode();
  },
  htmlInline: function(lr, ar) {
    var cr = ar.literal, ur = cr.match(reHTMLTag), fr = ur[1], dr = ur[3], hr = (fr || dr).toLowerCase(), gr = lr.schema.marks[hr], vr = sanitizeHTML(cr);
    if (gr != null && gr.spec.attrs.htmlInline)
      if (fr) {
        var mr = getHTMLAttrsByHTMLString(vr);
        lr.openMark(gr.create({ htmlAttrs: mr }));
      } else
        lr.closeMark(gr);
    else {
      var br = htmlToWwConvertors[hr];
      br && br(lr, ar, fr);
    }
  },
  htmlBlock: function(lr, ar) {
    var cr = ar.literal, ur = document.createElement("div"), fr = reHTMLComment.test(cr);
    if (fr)
      lr.openNode(lr.schema.nodes.htmlComment), lr.addText(ar.literal), lr.closeNode();
    else {
      var dr = cr.match(reHTMLTag), hr = dr[1], gr = dr[3], vr = (hr || gr).toLowerCase(), mr = lr.schema.nodes[vr], br = sanitizeHTML(cr);
      if (mr != null && mr.spec.attrs.htmlBlock) {
        var yr = getHTMLAttrsByHTMLString(br), kr = getChildrenHTML(ar, vr);
        lr.addNode(mr, { htmlAttrs: yr, childrenHTML: kr });
      } else
        ur.innerHTML = br, addRawHTMLAttributeToDOM(ur), lr.convertByDOMParser(ur);
    }
  },
  customInline: function(lr, ar, cr) {
    var ur = cr.entering, fr = cr.skipChildren, dr = ar, hr = dr.info, gr = dr.firstChild, vr = lr.schema;
    if (hr.indexOf("widget") !== -1 && ur) {
      var mr = getWidgetContent(ar);
      fr(), lr.addNode(vr.nodes.widget, { info: hr }, [
        vr.text(createWidgetContent(hr, mr))
      ]);
    } else {
      var br = "$$";
      ur && (br += gr ? hr + " " : hr), lr.addText(br);
    }
  }
};
function createWwConvertors(lr) {
  var ar = Object.keys(lr), cr = __assign$1({}, toWwConvertors), ur = new Renderer({
    gfm: !0,
    nodeId: !0,
    convertors: lr
  }), fr = ur.getConvertors();
  return ar.forEach(function(dr) {
    var hr = toWwConvertors[dr];
    hr && !includes(["htmlBlock", "htmlInline"], dr) && (cr[dr] = function(gr, vr, mr) {
      mr.origin = function() {
        return fr[dr](vr, mr, fr);
      };
      var br = lr[dr](vr, mr), yr;
      if (br) {
        var kr = Array.isArray(br) ? br[0] : br, Tr = kr.attributes, _r = kr.classNames;
        yr = { htmlAttrs: Tr, classNames: _r };
      }
      hr(gr, vr, mr, yr);
    });
  }), cr;
}
function mergeMarkText(lr, ar) {
  return lr.isText && ar.isText && distExports$5.Mark.sameSet(lr.marks, ar.marks) ? lr.withText(lr.text + ar.text) : !1;
}
var ToWwConvertorState = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.schema = ar, this.convertors = cr, this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }], this.marks = distExports$5.Mark.none;
    }
    return lr.prototype.top = function() {
      return last$1(this.stack);
    }, lr.prototype.push = function(ar) {
      this.stack.length && this.top().content.push(ar);
    }, lr.prototype.addText = function(ar) {
      if (ar) {
        var cr = this.top().content, ur = last$1(cr), fr = this.schema.text(ar, this.marks), dr = ur && mergeMarkText(ur, fr);
        dr ? cr[cr.length - 1] = dr : cr.push(fr);
      }
    }, lr.prototype.openMark = function(ar) {
      this.marks = ar.addToSet(this.marks);
    }, lr.prototype.closeMark = function(ar) {
      this.marks = ar.removeFromSet(this.marks);
    }, lr.prototype.addNode = function(ar, cr, ur) {
      var fr = ar.createAndFill(cr, ur, this.marks);
      return fr ? (this.push(fr), fr) : null;
    }, lr.prototype.openNode = function(ar, cr) {
      this.stack.push({ type: ar, attrs: cr, content: [] });
    }, lr.prototype.closeNode = function() {
      this.marks.length && (this.marks = distExports$5.Mark.none);
      var ar = this.stack.pop(), cr = ar.type, ur = ar.attrs, fr = ar.content;
      return this.addNode(cr, ur, fr);
    }, lr.prototype.convertByDOMParser = function(ar) {
      var cr = this, ur = distExports$5.DOMParser.fromSchema(this.schema).parse(ar);
      ur.content.forEach(function(fr) {
        return cr.push(fr);
      });
    }, lr.prototype.closeUnmatchedHTMLInline = function(ar, cr) {
      var ur;
      if (!cr && ar.type !== "htmlInline")
        for (var fr = this.stack.length - 1, dr = fr; dr >= 0; dr -= 1) {
          var hr = this.stack[dr];
          if (!((ur = hr.attrs) === null || ur === void 0) && ur.rawHTML)
            hr.content.length ? this.closeNode() : this.stack.pop();
          else
            break;
        }
    }, lr.prototype.convert = function(ar, cr) {
      for (var ur = ar.walker(), fr = ur.next(), dr = function() {
        var gr = fr.node, vr = fr.entering, mr = hr.convertors[gr.type], br = !1;
        if (mr) {
          var yr = {
            entering: vr,
            leaf: !isContainer$2(gr),
            getChildrenText: getChildrenText$1,
            options: { gfm: !0, nodeId: !1, tagFilter: !1, softbreak: `
` },
            skipChildren: function() {
              br = !0;
            }
          };
          if (hr.closeUnmatchedHTMLInline(gr, vr), mr(hr, gr, yr), (cr == null ? void 0 : cr.node) === gr) {
            var kr = hr.stack.reduce(function(Tr, _r) {
              return Tr + _r.content.reduce(function(Er, xr) {
                return Er + xr.nodeSize;
              }, 0);
            }, 0) + 1;
            cr.setMappedPos(kr);
          }
        }
        br && (ur.resumeAt(gr, !1), ur.next()), fr = ur.next();
      }, hr = this; fr; )
        dr();
    }, lr.prototype.convertNode = function(ar, cr) {
      return this.convert(ar, cr), this.stack.length ? this.closeNode() : null;
    }, lr;
  }()
);
function convertToRawHTMLHavingInlines(lr, ar, cr) {
  var ur = cr[0], fr = cr[1];
  lr.write(ur), lr.convertInline(ar), lr.write(fr);
}
function convertToRawHTMLHavingBlocks(lr, ar, cr) {
  var ur = ar.node, fr = ar.parent, dr = cr[0], hr = cr[1];
  lr.stopNewline = !0, lr.write(dr), lr.convertNode(ur), lr.write(hr), (fr == null ? void 0 : fr.type.name) === "doc" && (lr.closeBlock(ur), lr.stopNewline = !1);
}
function createTableHeadDelim(lr, ar) {
  var cr = lr.length, ur = "", fr = "";
  return ar === "left" ? (ur = ":", cr -= 1) : ar === "right" ? (fr = ":", cr -= 1) : ar === "center" && (ur = ":", fr = ":", cr -= 2), "" + ur + repeat$1("-", Math.max(cr, 3)) + fr;
}
var nodeTypeWriters = {
  text: function(lr, ar) {
    var cr, ur = ar.node, fr = (cr = ur.text) !== null && cr !== void 0 ? cr : "";
    (ur.marks || []).some(function(dr) {
      return dr.type.name === "link";
    }) ? lr.text(escapeTextForLink(fr), !1) : lr.text(fr);
  },
  paragraph: function(lr, ar) {
    var cr = ar.node, ur = ar.parent, fr = ar.index, dr = fr === void 0 ? 0 : fr;
    if (lr.stopNewline)
      lr.convertInline(cr);
    else {
      var hr = dr === 0, gr = !hr && ur.child(dr - 1), vr = gr && gr.childCount === 0, mr = dr < ur.childCount - 1 && ur.child(dr + 1), br = mr && mr.type.name === "paragraph", yr = cr.childCount === 0;
      if (yr && vr)
        lr.write(`<br>
`);
      else if (yr && !vr && !hr) {
        if ((ur == null ? void 0 : ur.type.name) === "listItem") {
          var kr = lr.getDelim();
          lr.setDelim(""), lr.write("<br>"), lr.setDelim(kr);
        }
        lr.write(`
`);
      } else
        lr.convertInline(cr), br ? lr.write(`
`) : lr.closeBlock(cr);
    }
  },
  heading: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = ur.attrs.headingType;
    dr === "atx" ? (lr.write(fr + " "), lr.convertInline(ur), lr.closeBlock(ur)) : (lr.convertInline(ur), lr.ensureNewLine(), lr.write(fr), lr.closeBlock(ur));
  },
  codeBlock: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = cr.text, hr = fr, gr = hr[0], vr = hr[1];
    lr.write(gr), lr.ensureNewLine(), lr.text(dr, !1), lr.ensureNewLine(), lr.write(vr), lr.closeBlock(ur);
  },
  blockQuote: function(lr, ar, cr) {
    var ur = ar.node, fr = ar.parent, dr = cr.delim;
    (fr == null ? void 0 : fr.type.name) === ur.type.name && lr.flushClose(1), lr.wrapBlock(dr, null, ur, function() {
      return lr.convertNode(ur);
    });
  },
  bulletList: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim;
    lr.convertList(ur, repeat$1(" ", 4), function() {
      return fr + " ";
    });
  },
  orderedList: function(lr, ar) {
    var cr = ar.node, ur = cr.attrs.order || 1;
    lr.convertList(cr, repeat$1(" ", 4), function(fr) {
      var dr = String(ur + fr);
      return dr + ". ";
    });
  },
  listItem: function(lr, ar) {
    var cr = ar.node, ur = cr.attrs, fr = ur.task, dr = ur.checked;
    fr && lr.write("[" + (dr ? "x" : " ") + "] "), lr.convertNode(cr);
  },
  image: function(lr, ar, cr) {
    var ur = cr.attrs;
    lr.write("![" + (ur == null ? void 0 : ur.altText) + "](" + (ur == null ? void 0 : ur.imageUrl) + ")");
  },
  thematicBreak: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim;
    lr.write(fr), lr.closeBlock(ur);
  },
  table: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr), lr.closeBlock(cr);
  },
  tableHead: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = ur.firstChild;
    lr.convertNode(ur);
    var hr = fr != null ? fr : "";
    !fr && dr && dr.forEach(function(gr) {
      var vr = gr.textContent, mr = gr.attrs, br = createTableHeadDelim(vr, mr.align);
      hr += "| " + br + " ";
    }), lr.write(hr + "|"), lr.ensureNewLine();
  },
  tableBody: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr);
  },
  tableRow: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr), lr.write("|"), lr.ensureNewLine();
  },
  tableHeadCell: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = fr === void 0 ? "| " : fr;
    lr.write(dr), lr.convertTableCell(ur), lr.write(" ");
  },
  tableBodyCell: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = fr === void 0 ? "| " : fr;
    lr.write(dr), lr.convertTableCell(ur), lr.write(" ");
  },
  customBlock: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = cr.text, hr = fr, gr = hr[0], vr = hr[1];
    lr.write(gr), lr.ensureNewLine(), lr.text(dr, !1), lr.ensureNewLine(), lr.write(vr), lr.closeBlock(ur);
  },
  frontMatter: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.text(fr, !1), lr.closeBlock(ur);
  },
  widget: function(lr, ar, cr) {
    var ur = cr.text;
    lr.write(ur);
  },
  html: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.write(fr), ur.attrs.htmlBlock && lr.closeBlock(ur);
  },
  htmlComment: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.write(fr), lr.closeBlock(ur);
  }
};
function write(lr, ar) {
  var cr = ar.state, ur = ar.nodeInfo, fr = ar.params, dr = fr.rawHTML;
  dr ? inArray_1(lr, ["heading", "codeBlock"]) > -1 ? convertToRawHTMLHavingInlines(cr, ur.node, dr) : inArray_1(lr, ["image", "thematicBreak"]) > -1 ? cr.write(dr) : convertToRawHTMLHavingBlocks(cr, ur, dr) : nodeTypeWriters[lr](cr, ur, fr);
}
function addBackticks(lr, ar) {
  var cr = lr.text, ur = /`+/g, fr = 0;
  if (lr.isText && cr)
    for (var dr = ur.exec(cr); dr; )
      fr = Math.max(fr, dr[0].length), dr = ur.exec(cr);
  for (var hr = fr > 0 && ar > 0 ? " `" : "`", gr = 0; gr < fr; gr += 1)
    hr += "`";
  return fr > 0 && ar < 0 && (hr += " "), hr;
}
function getPairRawHTML(lr) {
  return lr ? ["<" + lr + ">", "</" + lr + ">"] : null;
}
function getOpenRawHTML(lr) {
  return lr ? "<" + lr + ">" : null;
}
function getCloseRawHTML(lr) {
  return lr ? "</" + lr + ">" : null;
}
var toMdConvertors = {
  heading: function(lr) {
    var ar = lr.node, cr = ar.attrs, ur = cr.level, fr = repeat$1("#", ur);
    return cr.headingType === "setext" && (fr = ur === 1 ? "===" : "---"), {
      delim: fr,
      rawHTML: getPairRawHTML(cr.rawHTML)
    };
  },
  codeBlock: function(lr) {
    var ar = lr.node, cr = ar, ur = cr.attrs, fr = cr.textContent;
    return {
      delim: ["```" + (ur.language || ""), "```"],
      rawHTML: getPairRawHTML(ur.rawHTML),
      text: fr
    };
  },
  blockQuote: function(lr) {
    var ar = lr.node;
    return {
      delim: "> ",
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  bulletList: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs.rawHTML;
    return ur && (fr = fr || "ul"), {
      delim: "*",
      rawHTML: getPairRawHTML(fr)
    };
  },
  orderedList: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs.rawHTML;
    return ur && (fr = fr || "ol"), {
      rawHTML: getPairRawHTML(fr)
    };
  },
  listItem: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs, dr = fr.task, hr = fr.checked, gr = cr.attrs.rawHTML;
    ur && (gr = gr || "li");
    var vr = dr ? ' class="task-list-item' + (hr ? " checked" : "") + '"' : "", mr = dr ? " data-task" + (hr ? " data-task-checked" : "") : "";
    return {
      rawHTML: gr ? ["<" + gr + vr + mr + ">", "</" + gr + ">"] : null
    };
  },
  table: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHead: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBody: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableRow: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHeadCell: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBodyCell: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  image: function(lr) {
    var ar = lr.node, cr = ar.attrs, ur = cr.rawHTML, fr = cr.altText, dr = cr.imageUrl.replace(/&amp;/g, "&"), hr = fr ? ' alt="' + escapeXml$1(fr) + '"' : "";
    return {
      rawHTML: ur ? "<" + ur + ' src="' + escapeXml$1(dr) + '"' + hr + ">" : null,
      attrs: {
        altText: escapeTextForLink(fr || ""),
        imageUrl: dr
      }
    };
  },
  thematicBreak: function(lr) {
    var ar = lr.node;
    return {
      delim: "***",
      rawHTML: getOpenRawHTML(ar.attrs.rawHTML)
    };
  },
  customBlock: function(lr) {
    var ar = lr.node, cr = ar, ur = cr.attrs, fr = cr.textContent;
    return {
      delim: ["$$" + ur.info, "$$"],
      text: fr
    };
  },
  frontMatter: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  widget: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  strong: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "**",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  emph: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "*",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  strike: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "~~",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  link: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs, dr = fr.title, hr = fr.rawHTML, gr = fr.linkUrl.replace(/&amp;/g, "&"), vr = dr ? ' title="' + escapeXml$1(dr) + '"' : "";
    return ur ? {
      delim: "[",
      rawHTML: hr ? "<" + hr + ' href="' + escapeXml$1(gr) + '"' + vr + ">" : null
    } : {
      delim: "](" + gr + (dr ? " " + quote(escapeTextForLink(dr)) : "") + ")",
      rawHTML: getCloseRawHTML(hr)
    };
  },
  code: function(lr, ar) {
    var cr = lr.node, ur = lr.parent, fr = lr.index, dr = fr === void 0 ? 0 : fr, hr = ar.entering, gr = hr ? addBackticks(ur.child(dr), -1) : addBackticks(ur.child(dr - 1), 1), vr = hr ? getOpenRawHTML(cr.attrs.rawHTML) : getCloseRawHTML(cr.attrs.rawHTML);
    return {
      delim: gr,
      rawHTML: vr
    };
  },
  htmlComment: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  // html inline node, html block node
  html: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.type.name, dr = cr.attrs.htmlAttrs, hr = "<" + fr, gr = "</" + fr + ">";
    return Object.keys(dr).forEach(function(vr) {
      hr += " " + vr + '="' + dr[vr].replace(/"/g, "'") + '"';
    }), hr += ">", cr.attrs.htmlInline ? {
      rawHTML: ur ? hr : gr
    } : {
      text: "" + hr + cr.attrs.childrenHTML + gr
    };
  }
}, markTypeOptions = {
  strong: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  emph: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  strike: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  code: {
    escape: !1
  },
  link: null,
  html: null
};
function createNodeTypeConvertors(lr) {
  var ar = {}, cr = Object.keys(nodeTypeWriters);
  return cr.forEach(function(ur) {
    ar[ur] = function(fr, dr) {
      var hr = nodeTypeWriters[ur];
      if (hr) {
        var gr = lr[ur], vr = gr ? gr(dr, {
          inTable: fr.inTable
        }) : {};
        write(ur, { state: fr, nodeInfo: dr, params: vr });
      }
    };
  }), ar;
}
function createMarkTypeConvertors(lr) {
  var ar = {}, cr = Object.keys(markTypeOptions);
  return cr.forEach(function(ur) {
    ar[ur] = function(fr, dr) {
      var hr = markTypeOptions[ur], gr = lr[ur], vr = gr && fr && !isUndefined_1(dr), mr = vr ? gr(fr, { entering: dr }) : {};
      return __assign$1(__assign$1({}, mr), hr);
    };
  }), ar;
}
function createMdConvertors(lr) {
  var ar = Object.keys(lr);
  ar.forEach(function(fr) {
    var dr = toMdConvertors[fr], hr = lr[fr];
    dr ? toMdConvertors[fr] = function(gr, vr) {
      return vr.origin = function() {
        return dr(gr, vr);
      }, hr(gr, vr);
    } : toMdConvertors[fr] = hr, delete lr[fr];
  });
  var cr = createNodeTypeConvertors(toMdConvertors), ur = createMarkTypeConvertors(toMdConvertors);
  return {
    nodeTypeConvertors: cr,
    markTypeConvertors: ur
  };
}
var ToMdConvertorState = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = ar.nodeTypeConvertors, ur = ar.markTypeConvertors;
      this.nodeTypeConvertors = cr, this.markTypeConvertors = ur, this.delim = "", this.result = "", this.closed = !1, this.tightList = !1, this.stopNewline = !1, this.inTable = !1;
    }
    return lr.prototype.getMarkConvertor = function(ar) {
      var cr = ar.attrs.htmlInline ? "html" : ar.type.name;
      return this.markTypeConvertors[cr];
    }, lr.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    }, lr.prototype.markText = function(ar, cr, ur, fr) {
      var dr = this.getMarkConvertor(ar);
      if (dr) {
        var hr = dr({ node: ar, parent: ur, index: fr }, cr), gr = hr.delim, vr = hr.rawHTML;
        return vr || gr;
      }
      return "";
    }, lr.prototype.setDelim = function(ar) {
      this.delim = ar;
    }, lr.prototype.getDelim = function() {
      return this.delim;
    }, lr.prototype.flushClose = function(ar) {
      if (!this.stopNewline && this.closed) {
        if (this.isInBlank() || (this.result += `
`), ar || (ar = 2), ar > 1) {
          var cr = this.delim, ur = /\s+$/.exec(cr);
          ur && (cr = cr.slice(0, cr.length - ur[0].length));
          for (var fr = 1; fr < ar; fr += 1)
            this.result += cr + `
`;
        }
        this.closed = !1;
      }
    }, lr.prototype.wrapBlock = function(ar, cr, ur, fr) {
      var dr = this.getDelim();
      this.write(cr || ar), this.setDelim(this.getDelim() + ar), fr(), this.setDelim(dr), this.closeBlock(ur);
    }, lr.prototype.ensureNewLine = function() {
      this.isInBlank() || (this.result += `
`);
    }, lr.prototype.write = function(ar) {
      ar === void 0 && (ar = ""), this.flushClose(), this.delim && this.isInBlank() && (this.result += this.delim), ar && (this.result += ar);
    }, lr.prototype.closeBlock = function(ar) {
      this.closed = ar;
    }, lr.prototype.text = function(ar, cr) {
      cr === void 0 && (cr = !0);
      for (var ur = ar.split(`
`), fr = 0; fr < ur.length; fr += 1)
        this.write(), this.result += cr ? escape$1(ur[fr]) : ur[fr], fr !== ur.length - 1 && (this.result += `
`);
    }, lr.prototype.convertBlock = function(ar, cr, ur) {
      var fr = ar.type.name, dr = this.nodeTypeConvertors[fr], hr = { node: ar, parent: cr, index: ur };
      ar.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, hr) : dr && dr(this, hr);
    }, lr.prototype.convertInline = function(ar) {
      var cr = this, ur = [], fr = "", dr = function(hr, gr, vr) {
        var mr = hr ? hr.marks : [], br = fr;
        fr = "";
        var yr = hr && hr.isText && mr.some(function(oi) {
          var Jr = cr.getMarkConvertor(oi), Yr = Jr && Jr();
          return Yr && Yr.removedEnclosingWhitespace;
        });
        if (yr && hr && hr.text) {
          var kr = /^(\s*)(.*?)(\s*)$/m.exec(hr.text), Tr = kr[1], _r = kr[2], Er = kr[3];
          br += Tr, fr = Er, (Tr || Er) && (hr = _r ? hr.withText(_r) : null, hr || (mr = ur));
        }
        for (var xr = mr.length && last$1(mr), Cr = xr && cr.getMarkConvertor(xr), Ar = Cr && Cr(), Lr = Ar && Ar.escape === !1, Dr = mr.length - (Lr ? 1 : 0), Nr = 0; Nr < Dr; Nr += 1) {
          var _r = mr[Nr];
          if (Ar && !Ar.mixable)
            break;
          for (var Hr = 0; Hr < ur.length; Hr += 1) {
            var $r = ur[Hr];
            if (Ar && !Ar.mixable)
              break;
            if (_r.eq($r)) {
              Nr > Hr ? mr = mr.slice(0, Hr).concat(_r).concat(mr.slice(Hr, Nr)).concat(mr.slice(Nr + 1, Dr)) : Hr > Nr && (mr = mr.slice(0, Nr).concat(mr.slice(Nr + 1, Hr)).concat(_r).concat(mr.slice(Hr, Dr)));
              break;
            }
          }
        }
        for (var Wr = 0; Wr < Math.min(ur.length, Dr) && mr[Wr].eq(ur[Wr]); )
          Wr += 1;
        for (; Wr < ur.length; ) {
          var Zr = ur.pop();
          Zr && cr.text(cr.markText(Zr, !1, ar, vr), !1);
        }
        if (br && cr.text(br), hr) {
          for (; ur.length < Dr; ) {
            var _r = mr[ur.length];
            ur.push(_r), cr.text(cr.markText(_r, !0, ar, vr), !1);
          }
          Lr && hr.isText ? cr.text(cr.markText(xr, !0, ar, vr) + hr.text + cr.markText(xr, !1, ar, vr + 1), !1) : cr.convertBlock(hr, ar, vr);
        }
      };
      ar.forEach(dr), dr(null, null, ar.childCount);
    }, lr.prototype.convertList = function(ar, cr, ur) {
      var fr = this, dr;
      this.closed && this.closed.type === ar.type ? this.flushClose(3) : this.tightList && this.flushClose(1);
      var hr = (dr = ar.attrs.tight) !== null && dr !== void 0 ? dr : !0, gr = this.tightList;
      this.tightList = hr, ar.forEach(function(vr, mr, br) {
        br && hr && fr.flushClose(1), fr.wrapBlock(cr, ur(br), ar, function() {
          return fr.convertBlock(vr, ar, br);
        });
      }), this.tightList = gr;
    }, lr.prototype.convertTableCell = function(ar) {
      var cr = this;
      this.stopNewline = !0, this.inTable = !0, ar.forEach(function(ur, fr, dr) {
        if (includes(["bulletList", "orderedList"], ur.type.name))
          cr.convertBlock(ur, ar, dr), cr.closed = !1;
        else if (cr.convertInline(ur), dr < ar.childCount - 1) {
          var hr = ar.child(dr + 1);
          hr.type.name === "paragraph" && cr.write("<br>");
        }
      }), this.stopNewline = !1, this.inTable = !1;
    }, lr.prototype.convertNode = function(ar, cr) {
      var ur = this;
      return ar.forEach(function(fr, dr, hr) {
        if (ur.convertBlock(fr, ar, hr), (cr == null ? void 0 : cr.node) === fr) {
          var gr = ur.result.split(`
`);
          cr.setMappedPos([gr.length, last$1(gr).length + 1]);
        }
      }), this.result;
    }, lr;
  }()
), Convertor = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.setMappedPos = function(hr) {
        dr.mappedPosWhenConverting = hr;
      }, this.schema = ar, this.eventEmitter = fr, this.focusedNode = null, this.mappedPosWhenConverting = null, this.toWwConvertors = createWwConvertors(ur), this.toMdConvertors = createMdConvertors(cr || {}), this.eventEmitter.listen("setFocusedNode", function(hr) {
        return dr.focusedNode = hr;
      });
    }
    return lr.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    }, lr.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    }, lr.prototype.toWysiwygModel = function(ar) {
      var cr = new ToWwConvertorState(this.schema, this.toWwConvertors);
      return cr.convertNode(ar, this.getInfoForPosSync());
    }, lr.prototype.toMarkdownText = function(ar) {
      var cr = new ToMdConvertorState(this.toMdConvertors), ur = cr.convertNode(ar, this.getInfoForPosSync());
      return ur = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", ur), ur;
    }, lr;
  }()
);
function execPlugin(lr) {
  var ar = lr.plugin, cr = lr.eventEmitter, ur = lr.usageStatistics, fr = lr.instance, dr = { Plugin: distExports$3.Plugin, PluginKey: distExports$3.PluginKey, Selection: distExports$3.Selection, TextSelection: distExports$3.TextSelection }, hr = { Decoration: distExports$4.Decoration, DecorationSet: distExports$4.DecorationSet }, gr = { Fragment: distExports$5.Fragment }, vr = { InputRule: distExports$1.InputRule, inputRules: distExports$1.inputRules, undoInputRule: distExports$1.undoInputRule }, mr = { keymap: distExports$2.keymap }, br = {
    eventEmitter: cr,
    usageStatistics: ur,
    instance: fr,
    pmState: dr,
    pmView: hr,
    pmModel: gr,
    pmRules: vr,
    pmKeymap: mr,
    i18n
  };
  if (isArray_1(ar)) {
    var yr = ar[0], kr = ar[1], Tr = kr === void 0 ? {} : kr;
    return yr(br, Tr);
  }
  return ar(br);
}
function getPluginInfo(lr) {
  var ar = lr.plugins, cr = lr.eventEmitter, ur = lr.usageStatistics, fr = lr.instance;
  return cr.listen("mixinTableOffsetMapPrototype", mixinTableOffsetMapPrototype), (ar != null ? ar : []).reduce(function(dr, hr) {
    var gr = execPlugin({
      plugin: hr,
      eventEmitter: cr,
      usageStatistics: ur,
      instance: fr
    });
    if (!gr)
      throw new Error("The return value of the executed plugin is empty.");
    var vr = gr.markdownParsers, mr = gr.toHTMLRenderers, br = gr.toMarkdownRenderers, yr = gr.markdownPlugins, kr = gr.wysiwygPlugins, Tr = gr.wysiwygNodeViews, _r = gr.markdownCommands, Er = gr.wysiwygCommands, xr = gr.toolbarItems;
    return mr && (dr.toHTMLRenderers = deepMergedCopy(dr.toHTMLRenderers, mr)), br && (dr.toMarkdownRenderers = deepMergedCopy(dr.toMarkdownRenderers, br)), yr && (dr.mdPlugins = dr.mdPlugins.concat(yr)), kr && (dr.wwPlugins = dr.wwPlugins.concat(kr)), Tr && (dr.wwNodeViews = __assign$1(__assign$1({}, dr.wwNodeViews), Tr)), _r && (dr.mdCommands = __assign$1(__assign$1({}, dr.mdCommands), _r)), Er && (dr.wwCommands = __assign$1(__assign$1({}, dr.wwCommands), Er)), xr && (dr.toolbarItems = dr.toolbarItems.concat(xr)), vr && (dr.markdownParsers = __assign$1(__assign$1({}, dr.markdownParsers), vr)), dr;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var TASK_ATTR_NAME = "data-task", DISABLED_TASK_ATTR_NAME = "data-task-disabled", TASK_CHECKED_CLASS_NAME = "checked";
function registerHTMLTagToWhitelist(lr) {
  ["htmlBlock", "htmlInline"].forEach(function(ar) {
    lr[ar] && Object.keys(lr[ar]).forEach(function(cr) {
      return registerTagWhitelistIfPossible(cr);
    });
  });
}
var ToastUIEditorViewer = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = this;
      this.options = extend_1({
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        usageStatistics: !0,
        theme: "light"
      }, ar), this.eventEmitter = new EventEmitter();
      var ur = sanitizeLinkAttribute(this.options.linkAttributes), fr = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      }) || {}, dr = fr.toHTMLRenderers, hr = fr.markdownParsers, gr = this.options, vr = gr.customHTMLRenderer, mr = gr.extendedAutolinks, br = gr.referenceDefinition, yr = gr.frontMatter, kr = gr.customHTMLSanitizer, Tr = {
        linkAttributes: ur,
        customHTMLRenderer: __assign$1(__assign$1({}, dr), vr),
        extendedAutolinks: mr,
        referenceDefinition: br,
        frontMatter: yr,
        sanitizer: kr || sanitizeHTML
      };
      registerHTMLTagToWhitelist(Tr.customHTMLRenderer), this.options.events && forEachOwnProperties_1(this.options.events, function(Lr, Dr) {
        cr.on(Dr, Lr);
      });
      var _r = this.options, Er = _r.el, xr = _r.initialValue, Cr = _r.theme, Ar = Er.innerHTML;
      Cr !== "light" && Er.classList.add(cls(Cr)), Er.innerHTML = "", this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: mr,
        referenceDefinition: br,
        disallowDeepHeading: !0,
        frontMatter: yr,
        customParser: hr
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, Tr), { isViewer: !0 })), on_1(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), xr ? this.setMarkdown(xr) : Ar && this.preview.setHTML(Ar), Er.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
    }
    return lr.prototype.toggleTask = function(ar) {
      var cr = ar.target, ur = getComputedStyle(cr, ":before");
      !cr.hasAttribute(DISABLED_TASK_ATTR_NAME) && cr.hasAttribute(TASK_ATTR_NAME) && isPositionInBox(ur, ar.offsetX, ar.offsetY) && (toggleClass(cr, TASK_CHECKED_CLASS_NAME), this.eventEmitter.emit("change", {
        source: "viewer",
        date: ar
      }));
    }, lr.prototype.setMarkdown = function(ar) {
      var cr = this.toastMark.getLineTexts(), ur = cr.length, fr = last$1(cr), dr = [ur, fr.length + 1], hr = this.toastMark.editMarkdown([1, 1], dr, ar || "");
      this.eventEmitter.emit("updatePreview", hr);
    }, lr.prototype.on = function(ar, cr) {
      this.eventEmitter.listen(ar, cr);
    }, lr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.addHook = function(ar, cr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, cr);
    }, lr.prototype.destroy = function() {
      off_1(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
    }, lr.prototype.isViewer = function() {
      return !0;
    }, lr.prototype.isMarkdownMode = function() {
      return !1;
    }, lr.prototype.isWysiwygMode = function() {
      return !1;
    }, lr;
  }()
);
function isPmNode(lr) {
  return lr instanceof distExports$5.Node;
}
function isContainer(lr) {
  var ar = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return includes(ar, lr);
}
function createMdLikeNode(lr) {
  var ar = lr.attrs, cr = lr.type, ur = cr.name, fr = {
    type: ur,
    wysiwygNode: !0,
    literal: !isContainer(ur) && isPmNode(lr) ? lr.textContent : null
  }, dr = {
    heading: { level: ar.level },
    link: { destination: ar.linkUrl, title: ar.title },
    image: { destination: ar.imageUrl },
    codeBlock: { info: ar.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: ar.order } },
    listItem: { type: "item", listData: { task: ar.task, checked: ar.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: ar.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: ar.align },
    customBlock: { info: ar.info }
  }, hr = dr[ur], gr = __assign$1(__assign$1({}, fr), hr), vr = lr.attrs, mr = vr.htmlAttrs, br = vr.childrenHTML;
  return mr ? __assign$1(__assign$1({}, gr), { attrs: mr, childrenHTML: br }) : gr;
}
var tokenToDOMNode = {
  openTag: function(lr, ar) {
    var cr = lr, ur = cr.tagName, fr = cr.classNames, dr = cr.attributes, hr = document.createElement(ur), gr = {};
    fr && (hr.className = fr.join(" ")), dr && (gr = __assign$1(__assign$1({}, gr), dr)), setAttributes(gr, hr), ar.push(hr);
  },
  closeTag: function(lr, ar) {
    if (ar.length > 1) {
      var cr = ar.pop();
      last$1(ar).appendChild(cr);
    }
  },
  html: function(lr, ar) {
    last$1(ar).insertAdjacentHTML("beforeend", lr.content);
  },
  text: function(lr, ar) {
    var cr = document.createTextNode(lr.content);
    last$1(ar).appendChild(cr);
  }
}, WwToDOMAdaptor = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = getHTMLRenderConvertors(ar, cr), fr = __assign$1(__assign$1({}, cr.htmlBlock), cr.htmlInline);
      this.customConvertorKeys = Object.keys(cr).concat(Object.keys(fr)), this.renderer = new Renderer({
        gfm: !0,
        convertors: __assign$1(__assign$1({}, ur), fr)
      }), this.convertors = this.renderer.getConvertors();
    }
    return lr.prototype.generateTokens = function(ar) {
      var cr = createMdLikeNode(ar), ur = {
        entering: !0,
        leaf: isPmNode(ar) ? ar.isLeaf : !1,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return isPmNode(ar) ? ar.textContent : "";
        },
        skipChildren: function() {
          return !1;
        }
      }, fr = this.convertors[ar.type.name], dr = fr(cr, ur, this.convertors), hr = isArray_1(dr) ? dr : [dr];
      return (isContainer(ar.type.name) || ar.attrs.htmlInline) && (ur.entering = !1, hr.push({ type: "text", content: isPmNode(ar) ? ar.textContent : "" }), hr = hr.concat(fr(cr, ur, this.convertors))), hr;
    }, lr.prototype.toDOMNode = function(ar) {
      var cr = this.generateTokens(ar), ur = [];
      return cr.forEach(function(fr) {
        return tokenToDOMNode[fr.type](fr, ur);
      }), ur[0];
    }, lr.prototype.getToDOMNode = function(ar) {
      return includes(this.customConvertorKeys, ar) ? this.toDOMNode.bind(this) : null;
    }, lr;
  }()
), ANIMATION_TIME = 100, SCROLL_BLOCKING_RESET_DELAY = 15, currentTimeoutId = null, releaseTimer = null;
function run(lr, ar) {
  var cr = ar.syncScrollTop, ur = ar.releaseEventBlock;
  releaseTimer && clearTimeout(releaseTimer), cr(lr), releaseTimer = setTimeout(function() {
    ur();
  }, SCROLL_BLOCKING_RESET_DELAY);
}
function animate(lr, ar, cr) {
  var ur = ar - lr, fr = Date.now(), dr = function() {
    var hr = Date.now(), gr = (hr - fr) / ANIMATION_TIME, vr;
    currentTimeoutId && clearTimeout(currentTimeoutId), gr < 1 ? (vr = lr + ur * Math.cos((1 - gr) * Math.PI / 2), run(Math.ceil(vr), cr), currentTimeoutId = setTimeout(dr, 1)) : (run(ar, cr), currentTimeoutId = null);
  };
  dr();
}
var EDITOR_BOTTOM_PADDING = 18, ScrollSync = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      this.latestEditorScrollTop = null, this.latestPreviewScrollTop = null, this.blockedScroll = null, this.active = !0, this.timer = null;
      var fr = cr.previewContent, dr = cr.el;
      this.previewRoot = fr, this.previewEl = dr, this.mdEditor = ar, this.editorView = ar.view, this.toastMark = ar.getToastMark(), this.eventEmitter = ur, this.addScrollSyncEvent();
    }
    return lr.prototype.addScrollSyncEvent = function() {
      var ar = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        ar.clearTimer(), ar.timer = setTimeout(function() {
          ar.syncPreviewScrollTop(!0);
        }, 200);
      }), this.eventEmitter.listen("scroll", function(cr, ur) {
        ar.active && (cr === "editor" && ar.blockedScroll !== "editor" ? ar.syncPreviewScrollTop() : cr === "preview" && ar.blockedScroll !== "preview" && ar.syncEditorScrollTop(ur));
      }), this.eventEmitter.listen("toggleScrollSync", function(cr) {
        ar.active = cr;
      });
    }, lr.prototype.getMdNodeAtPos = function(ar, cr) {
      var ur = ar.content.findIndex(cr.pos), fr = ur.index;
      return this.toastMark.findFirstNodeAtLine(fr + 1);
    }, lr.prototype.getScrollTopByCaretPos = function() {
      var ar = this.mdEditor.getSelection(), cr = this.toastMark.findFirstNodeAtLine(ar[0][0]), ur = this.previewEl.clientHeight, fr = getParentNodeObj(this.previewRoot, cr).el, dr = getTotalOffsetTop(fr, this.previewRoot) || fr.offsetTop, hr = fr.clientHeight, gr = dr + hr - ur * 0.5;
      this.latestEditorScrollTop = null;
      var vr = fr.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return vr < ur ? null : gr;
    }, lr.prototype.syncPreviewScrollTop = function(ar) {
      ar === void 0 && (ar = !1);
      var cr = this, ur = cr.editorView, fr = cr.previewEl, dr = cr.previewRoot, hr = ur.dom.getBoundingClientRect(), gr = hr.left, vr = hr.top, mr = ur.posAtCoords({ left: gr, top: vr }), br = ur.state.doc, yr = this.getMdNodeAtPos(br, mr);
      if (!(!yr || isHTMLNode(yr))) {
        var kr = fr.scrollTop, Tr = ur.dom, _r = Tr.scrollTop, Er = Tr.scrollHeight, xr = Tr.clientHeight, Cr = Tr.children, Ar = Er - _r <= xr + EDITOR_BOTTOM_PADDING, Lr = Ar ? fr.scrollHeight : 0;
        if (_r && !Ar) {
          if (ar) {
            var Dr = this.getScrollTopByCaretPos();
            if (!Dr)
              return;
            Lr = Dr;
          } else {
            var Nr = getParentNodeObj(this.previewRoot, yr), Hr = Nr.el, $r = Nr.mdNode, Wr = getEditorRangeHeightInfo(br, $r, Cr), Zr = Wr.height, oi = Wr.rect, Jr = getTotalOffsetTop(Hr, dr) || Hr.offsetTop, Yr = Hr.clientHeight, li = vr > oi.top ? Math.min((vr - oi.top) / Zr, 1) : 0;
            Lr = Jr + Yr * li;
          }
          Lr = this.getResolvedScrollTop("editor", _r, Lr, kr), this.latestEditorScrollTop = _r;
        }
        Lr !== kr && this.run("editor", Lr, kr);
      }
    }, lr.prototype.syncEditorScrollTop = function(ar) {
      var cr = this, ur = cr.toastMark, fr = cr.editorView, dr = cr.previewRoot, hr = cr.previewEl, gr = fr.dom, vr = fr.state, mr = hr.scrollTop, br = hr.clientHeight, yr = hr.scrollHeight, kr = yr - mr <= br, Tr = gr.scrollTop, _r = kr ? gr.scrollHeight : 0;
      if (mr && ar && !kr) {
        if (ar = findAncestorHavingId(ar, dr), !ar.getAttribute("data-nodeid"))
          return;
        var Er = gr.children, xr = Number(ar.getAttribute("data-nodeid")), Cr = getParentNodeObj(this.previewRoot, ur.findNodeById(xr)), Ar = Cr.mdNode, Lr = Cr.el, Dr = getMdStartLine(Ar);
        _r = Er[Dr - 1].offsetTop;
        var Nr = getEditorRangeHeightInfo(vr.doc, Ar, Er).height, Hr = getAndSaveOffsetInfo(Lr, dr, xr), $r = Hr.nodeHeight, Wr = Hr.offsetTop;
        _r += getAdditionalPos(mr, Wr, $r, Nr), _r = this.getResolvedScrollTop("preview", mr, _r, Tr), this.latestPreviewScrollTop = mr;
      }
      _r !== Tr && this.run("preview", _r, Tr);
    }, lr.prototype.getResolvedScrollTop = function(ar, cr, ur, fr) {
      var dr = ar === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      return dr === null ? ur : dr < cr ? Math.max(ur, fr) : Math.min(ur, fr);
    }, lr.prototype.run = function(ar, cr, ur) {
      var fr = this, dr;
      ar === "editor" ? (dr = this.previewEl, this.blockedScroll = "preview") : (dr = this.editorView.dom, this.blockedScroll = "editor");
      var hr = {
        syncScrollTop: function(gr) {
          return dr.scrollTop = gr;
        },
        releaseEventBlock: function() {
          return fr.blockedScroll = null;
        }
      };
      animate(ur, cr, hr);
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.destroy = function() {
      this.clearTimer(), this.eventEmitter.removeEventHandler("scroll"), this.eventEmitter.removeEventHandler("afterPreviewRender");
    }, lr;
  }()
), queryMap = {
  getPopupInitialValues: function(lr, ar) {
    var cr = ar.popupName;
    return cr === "link" ? { linkText: lr.getSelectedText() } : {};
  }
};
function buildQuery(lr) {
  lr.eventEmitter.listen("query", function(ar, cr) {
    return queryMap[ar](lr, cr);
  });
}
var ToastUIEditorCore = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = this;
      this.initialHTML = ar.el.innerHTML, ar.el.innerHTML = "", this.options = extend_1({
        previewStyle: "tab",
        previewHighlight: !0,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: !0,
        usageStatistics: !0,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: !1,
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        widgetRules: [],
        theme: "light",
        autofocus: !0
      }, ar);
      var ur = this.options, fr = ur.customHTMLRenderer, dr = ur.extendedAutolinks, hr = ur.referenceDefinition, gr = ur.frontMatter, vr = ur.customMarkdownRenderer, mr = ur.useCommandShortcut, br = ur.initialEditType, yr = ur.widgetRules, kr = ur.customHTMLSanitizer;
      this.mode = br || "markdown", this.mdPreviewStyle = this.options.previewStyle, this.i18n = i18n, this.i18n.setCode(this.options.language), this.eventEmitter = new EventEmitter(), setWidgetRules(yr);
      var Tr = sanitizeLinkAttribute(this.options.linkAttributes);
      this.pluginInfo = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      });
      var _r = this.pluginInfo, Er = _r.toHTMLRenderers, xr = _r.toMarkdownRenderers, Cr = _r.mdPlugins, Ar = _r.wwPlugins, Lr = _r.wwNodeViews, Dr = _r.mdCommands, Nr = _r.wwCommands, Hr = _r.markdownParsers, $r = {
        linkAttributes: Tr,
        customHTMLRenderer: deepMergedCopy(Er, fr),
        extendedAutolinks: dr,
        referenceDefinition: hr,
        frontMatter: gr,
        sanitizer: kr || sanitizeHTML
      }, Wr = new WwToDOMAdaptor(Tr, $r.customHTMLRenderer), Zr = createHTMLSchemaMap($r.customHTMLRenderer, $r.sanitizer, Wr);
      this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: dr,
        referenceDefinition: hr,
        disallowDeepHeading: !0,
        frontMatter: gr,
        customParser: Hr
      }), this.mdEditor = new MdEditor(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut: mr,
        mdPlugins: Cr
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, $r), { isViewer: !1, highlight: this.options.previewHighlight })), this.wwEditor = new WysiwygEditor(this.eventEmitter, {
        toDOMAdaptor: Wr,
        useCommandShortcut: mr,
        htmlSchemaMap: Zr,
        linkAttributes: Tr,
        wwPlugins: Ar,
        wwNodeViews: Lr
      }), this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, xr), vr), getHTMLRenderConvertors(Tr, $r.customHTMLRenderer), this.eventEmitter), this.setMinHeight(this.options.minHeight), this.setHeight(this.options.height), this.setMarkdown(this.options.initialValue, !1), this.options.placeholder && this.setPlaceholder(this.options.placeholder), this.options.initialValue || this.setHTML(this.initialHTML, !1), this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return cr.mode;
      }), this.options.usageStatistics && sendHostName(), this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter), this.addInitEvent(), this.addInitCommand(Dr, Nr), buildQuery(this), this.options.hooks && forEachOwnProperties_1(this.options.hooks, function(oi, Jr) {
        return cr.addHook(Jr, oi);
      }), this.options.events && forEachOwnProperties_1(this.options.events, function(oi, Jr) {
        return cr.on(Jr, oi);
      }), this.eventEmitter.emit("load", this), this.moveCursorToStart(this.options.autofocus);
    }
    return lr.prototype.addInitEvent = function() {
      var ar = this;
      this.on("needChangeMode", this.changeMode.bind(this)), this.on("loadUI", function() {
        if (ar.height !== "auto") {
          var cr = Math.min(parseInt(ar.minHeight, 10), parseInt(ar.height, 10) - 75) + "px";
          ar.setMinHeight(cr);
        }
      }), addDefaultImageBlobHook(this.eventEmitter);
    }, lr.prototype.addInitCommand = function(ar, cr) {
      var ur = this, fr = function(dr, hr) {
        Object.keys(hr).forEach(function(gr) {
          ur.addCommand(dr, gr, hr[gr]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(dr) {
        return ur.eventEmitter.emit("toggleScrollSync", dr.active), !0;
      }), fr("markdown", ar), fr("wysiwyg", cr);
    }, lr.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    }, lr.factory = function(ar) {
      return ar.viewer ? new ToastUIEditorViewer(ar) : new lr(ar);
    }, lr.setLanguage = function(ar, cr) {
      i18n.setLanguage(ar, cr);
    }, lr.prototype.changePreviewStyle = function(ar) {
      this.mdPreviewStyle !== ar && (this.mdPreviewStyle = ar, this.eventEmitter.emit("changePreviewStyle", ar));
    }, lr.prototype.exec = function(ar, cr) {
      this.commandManager.exec(ar, cr);
    }, lr.prototype.addCommand = function(ar, cr, ur) {
      var fr = this, dr = function(hr) {
        hr === void 0 && (hr = {});
        var gr = (ar === "markdown" ? fr.mdEditor : fr.wwEditor).view;
        ur(hr, gr.state, gr.dispatch, gr);
      };
      this.commandManager.addCommand(ar, cr, dr);
    }, lr.prototype.on = function(ar, cr) {
      this.eventEmitter.listen(ar, cr);
    }, lr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.addHook = function(ar, cr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, cr);
    }, lr.prototype.removeHook = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    }, lr.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    }, lr.prototype.moveCursorToEnd = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToEnd(ar);
    }, lr.prototype.moveCursorToStart = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToStart(ar);
    }, lr.prototype.setMarkdown = function(ar, cr) {
      if (ar === void 0 && (ar = ""), cr === void 0 && (cr = !0), this.mdEditor.setMarkdown(ar, cr), this.isWysiwygMode()) {
        var ur = this.toastMark.getRootNode(), fr = this.convertor.toWysiwygModel(ur);
        this.wwEditor.setModel(fr, cr);
      }
    }, lr.prototype.setHTML = function(ar, cr) {
      ar === void 0 && (ar = ""), cr === void 0 && (cr = !0);
      var ur = document.createElement("div");
      ur.innerHTML = replaceBRWithEmptyBlock(ar);
      var fr = distExports$5.DOMParser.fromSchema(this.wwEditor.schema).parse(ur);
      this.isMarkdownMode() ? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(fr), cr) : this.wwEditor.setModel(fr, cr);
    }, lr.prototype.getMarkdown = function() {
      return this.isMarkdownMode() ? this.mdEditor.getMarkdown() : this.convertor.toMarkdownText(this.wwEditor.getModel());
    }, lr.prototype.getHTML = function() {
      var ar = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (ar.isMarkdownMode()) {
          var fr = ar.toastMark.getRootNode(), dr = ar.convertor.toWysiwygModel(fr);
          ar.wwEditor.setModel(dr);
        }
      });
      var cr = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);
      if (this.placeholder) {
        var ur = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return cr.replace(ur, "");
      }
      return cr;
    }, lr.prototype.insertText = function(ar) {
      this.getCurrentModeEditor().replaceSelection(ar);
    }, lr.prototype.setSelection = function(ar, cr) {
      this.getCurrentModeEditor().setSelection(ar, cr);
    }, lr.prototype.replaceSelection = function(ar, cr, ur) {
      this.getCurrentModeEditor().replaceSelection(ar, cr, ur);
    }, lr.prototype.deleteSelection = function(ar, cr) {
      this.getCurrentModeEditor().deleteSelection(ar, cr);
    }, lr.prototype.getSelectedText = function(ar, cr) {
      return this.getCurrentModeEditor().getSelectedText(ar, cr);
    }, lr.prototype.getRangeInfoOfNode = function(ar) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(ar);
    }, lr.prototype.addWidget = function(ar, cr, ur) {
      this.getCurrentModeEditor().addWidget(ar, cr, ur);
    }, lr.prototype.replaceWithWidget = function(ar, cr, ur) {
      this.getCurrentModeEditor().replaceWithWidget(ar, cr, ur);
    }, lr.prototype.setHeight = function(ar) {
      var cr = this.options.el;
      isString_1(ar) && (ar === "auto" ? addClass_1(cr, "auto-height") : removeClass_1(cr, "auto-height"), this.setMinHeight(this.getMinHeight())), css_1(cr, { height: ar }), this.height = ar;
    }, lr.prototype.getHeight = function() {
      return this.height;
    }, lr.prototype.setMinHeight = function(ar) {
      if (ar !== this.minHeight) {
        var cr = this.height || this.options.height;
        cr !== "auto" && this.options.el.querySelector("." + cls("main")) && (ar = Math.min(parseInt(ar, 10), parseInt(cr, 10) - 75) + "px");
        var ur = parseInt(ar, 10);
        this.minHeight = ar, this.wwEditor.setMinHeight(ur), this.mdEditor.setMinHeight(ur), this.preview.setMinHeight(ur);
      }
    }, lr.prototype.getMinHeight = function() {
      return this.minHeight;
    }, lr.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    }, lr.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    }, lr.prototype.isViewer = function() {
      return !1;
    }, lr.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    }, lr.prototype.changeMode = function(ar, cr) {
      if (this.mode !== ar) {
        if (this.mode = ar, this.isWysiwygMode()) {
          var ur = this.toastMark.getRootNode(), fr = this.convertor.toWysiwygModel(ur);
          this.wwEditor.setModel(fr);
        } else {
          var fr = this.wwEditor.getModel();
          this.mdEditor.setMarkdown(this.convertor.toMarkdownText(fr), !cr);
        }
        if (this.eventEmitter.emit("removePopupWidget"), this.eventEmitter.emit("changeMode", ar), !cr) {
          var dr = this.convertor.getMappedPos();
          this.focus(), this.isWysiwygMode() && isNumber_1(dr) ? this.wwEditor.setSelection(dr) : Array.isArray(dr) && this.mdEditor.setSelection(dr);
        }
      }
    }, lr.prototype.destroy = function() {
      var ar = this;
      this.wwEditor.destroy(), this.mdEditor.destroy(), this.preview.destroy(), this.scrollSync.destroy(), this.eventEmitter.emit("destroy"), this.eventEmitter.getEvents().forEach(function(cr, ur) {
        return ar.off(ur);
      });
    }, lr.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    }, lr.prototype.show = function() {
      this.eventEmitter.emit("show");
    }, lr.prototype.setScrollTop = function(ar) {
      this.getCurrentModeEditor().setScrollTop(ar);
    }, lr.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    }, lr.prototype.reset = function() {
      this.wwEditor.setModel([]), this.mdEditor.setMarkdown("");
    }, lr.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    }, lr.prototype.setPlaceholder = function(ar) {
      this.placeholder = ar, this.mdEditor.setPlaceholder(ar), this.wwEditor.setPlaceholder(ar);
    }, lr.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    }, lr.prototype.convertPosToMatchEditorMode = function(ar, cr, ur) {
      var fr, dr;
      cr === void 0 && (cr = ar), ur === void 0 && (ur = this.mode);
      var hr = this.mdEditor.view.state.doc, gr = Array.isArray(ar), vr = Array.isArray(cr), mr = ar, br = cr;
      if (gr !== vr)
        throw new Error("Types of arguments must be same");
      return ur === "markdown" && !gr && !vr ? (fr = getEditorToMdPos(hr, ar, cr), mr = fr[0], br = fr[1]) : ur === "wysiwyg" && gr && vr && (dr = getMdToEditorPos(hr, ar, cr), mr = dr[0], br = dr[1]), [mr, br];
    }, lr;
  }()
);
function html$1$2(lr) {
  for (var ar, cr, ur = arguments, fr = 1, dr = "", hr = "", gr = [0], vr = function(br) {
    fr === 1 && (br || (dr = dr.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? gr.push(br ? ur[br] : dr) : fr === 3 && (br || dr) ? (gr[1] = br ? ur[br] : dr, fr = 2) : fr === 2 && dr === "..." && br ? gr[2] = assign(gr[2] || {}, ur[br]) : fr === 2 && dr && !br ? (gr[2] = gr[2] || {})[dr] = !0 : fr >= 5 && (fr === 5 ? ((gr[2] = gr[2] || {})[cr] = br ? dr ? dr + ur[br] : ur[br] : dr, fr = 6) : (br || dr) && (gr[2][cr] += br ? dr + ur[br] : dr)), dr = "";
  }, mr = 0; mr < lr.length; mr++) {
    mr && (fr === 1 && vr(), vr(mr));
    for (let br = 0; br < lr[mr].length; br++)
      ar = lr[mr][br], fr === 1 ? ar === "<" ? (vr(), gr = [gr, "", null], fr = 3) : dr += ar : fr === 4 ? dr === "--" && ar === ">" ? (fr = 1, dr = "") : dr = ar + dr[0] : hr ? ar === hr ? hr = "" : dr += ar : ar === '"' || ar === "'" ? hr = ar : ar === ">" ? (vr(), fr = 1) : fr && (ar === "=" ? (fr = 5, cr = dr, dr = "") : ar === "/" && (fr < 5 || lr[mr][br + 1] === ">") ? (vr(), fr === 3 && (gr = gr[0]), fr = gr, (gr = gr[0]).push(this.apply(null, fr.slice(1))), fr = 0) : ar === " " || ar === "	" || ar === `
` || ar === "\r" ? (vr(), fr = 2) : dr += ar), fr === 3 && dr === "!--" && (fr = 4, gr = gr[0]);
  }
  return vr(), gr.length > 2 ? gr.slice(1) : gr[1];
}
function isBoolean(lr) {
  return typeof lr == "boolean" || lr instanceof Boolean;
}
var isBoolean_1 = isBoolean, VNodeWalker = (
  /** @class */
  function() {
    function lr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return lr.prototype.walk = function() {
      var ar = this, cr = ar.entering, ur = ar.current;
      return ur ? (cr ? ur.firstChild ? (this.current = ur.firstChild, this.entering = !0) : this.entering = !1 : ur === this.root ? this.current = null : ur.next ? (this.current = ur.next, this.entering = !0) : (this.current = ur.parent, this.entering = !1), { vnode: ur, entering: cr }) : null;
    }, lr;
  }()
), VNode = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      this.parent = null, this.old = null, this.firstChild = null, this.next = null, this.skip = !1, this.type = ar, this.props = cr, this.children = ur, this.props.children = ur, cr.ref && (this.ref = cr.ref, delete cr.ref), cr.key && (this.key = cr.key, delete cr.key);
    }
    return lr.prototype.walker = function() {
      return new VNodeWalker(this);
    }, lr.removalNodes = [], lr;
  }()
);
function createTextNode(lr) {
  return new VNode("TEXT_NODE", { nodeValue: lr }, []);
}
function excludeUnnecessaryChild(lr, ar) {
  var cr = lr;
  isBoolean_1(lr) || lr == null ? cr = null : (isString_1(lr) || isNumber_1(lr)) && (cr = createTextNode(String(lr))), cr && ar.push(cr);
}
function h(lr, ar) {
  for (var cr = [], ur = 2; ur < arguments.length; ur++)
    cr[ur - 2] = arguments[ur];
  var fr = [];
  return cr.forEach(function(dr) {
    Array.isArray(dr) ? dr.forEach(function(hr) {
      excludeUnnecessaryChild(hr, fr);
    }) : excludeUnnecessaryChild(dr, fr);
  }), new VNode(lr, ar || {}, fr);
}
var html$3 = html$1$2.bind(h);
function isObject(lr) {
  return lr === Object(lr);
}
var isObject_1 = isObject;
function createNode(lr) {
  var ar;
  return lr.type === "TEXT_NODE" ? ar = document.createTextNode(lr.props.nodeValue) : (ar = document.createElement(lr.type), setProps(ar, {}, lr.props)), ar;
}
function removeNode(lr, ar) {
  lr.node ? ar.removeChild(lr.node) : removeNode(lr.firstChild, ar);
}
function innerDiff(lr, ar, cr) {
  Object.keys(ar).forEach(function(ur) {
    if (/^on/.test(ur)) {
      if (!cr[ur] || ar[ur] !== cr[ur]) {
        var fr = ur.slice(2).toLowerCase();
        lr.removeEventListener(fr, ar[ur]);
      }
    } else
      ur !== "children" && !cr[ur] && !isTextNode(lr) && lr.removeAttribute(ur);
  }), setProps(lr, ar, cr, function(ur) {
    return !shallowEqual(ar[ur], cr[ur]);
  });
}
var reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setProps(lr, ar, cr, ur) {
  Object.keys(cr).forEach(function(fr) {
    if (!ur || ur(fr))
      if (/^on/.test(fr)) {
        var dr = fr.slice(2).toLowerCase();
        lr.addEventListener(dr, cr[fr]);
      } else
        fr === "nodeValue" ? lr[fr] = cr[fr] : fr === "style" && isObject_1(cr[fr]) ? setStyleProps(lr, ar[fr], cr[fr]) : fr !== "children" && (cr[fr] === !1 ? lr.removeAttribute(fr) : lr.setAttribute(fr, cr[fr]));
  });
}
function setStyleProps(lr, ar, cr) {
  ar && Object.keys(ar).forEach(function(ur) {
    lr.style[ur] = "";
  }), Object.keys(cr).forEach(function(ur) {
    var fr = cr[ur];
    lr.style[ur] = isNumber_1(fr) && !reNonDimension.test(ur) ? fr + "px" : fr;
  });
}
function commit(lr) {
  if (VNode.removalNodes.forEach(function(dr) {
    return diff(dr);
  }), lr) {
    for (var ar = void 0, cr = lr.walker(); ar = cr.walk(); )
      if (lr = ar.vnode, ar.entering)
        diff(lr);
      else if (isFunction_1(lr.type)) {
        var ur = lr.component;
        if (!lr.old && ur.mounted && ur.mounted(), lr.old && ur.updated) {
          var fr = ur.prevProps || {};
          ur.updated(fr);
        }
      }
  }
}
function getParentNode(lr) {
  for (var ar = lr.parent; !ar.node; )
    ar = ar.parent;
  return ar.node;
}
function diff(lr) {
  if (!(!lr || !lr.parent)) {
    if (lr.node) {
      var ar = getParentNode(lr);
      lr.effect === "A" ? ar.appendChild(lr.node) : lr.effect === "U" && innerDiff(lr.node, lr.old.props, lr.props);
    }
    if (lr.effect === "D") {
      for (var cr = void 0, ur = lr.walker(); cr = ur.walk(); )
        if (lr = cr.vnode, !cr.entering)
          if (isFunction_1(lr.type)) {
            var fr = lr.component;
            fr.beforeDestroy && fr.beforeDestroy();
          } else {
            var ar = getParentNode(lr);
            removeNode(lr, ar);
          }
    }
    lr.ref && (lr.component ? lr.ref(lr.component) : lr.node && lr.ref(lr.node));
  }
}
function createComponent(lr, ar) {
  var cr = ar.props, ur = ar.component;
  return ur ? (ur.prevProps = ur.props, ur.props = ar.props, ur) : new lr(cr);
}
function buildVNode(lr) {
  for (var ar = lr; lr && !lr.skip; ) {
    if (isFunction_1(lr.type)) {
      var cr = createComponent(lr.type, lr);
      cr.vnode = lr, lr.component = cr, lr.props.children = lr.children = [cr.render()], buildChildrenVNode(lr);
    } else
      lr.node || (lr.node = createNode(lr)), buildChildrenVNode(lr);
    if (lr.firstChild)
      lr = lr.firstChild;
    else {
      for (; lr && lr.parent && !lr.next && (lr = lr.parent, lr !== ar); )
        ;
      lr = lr.next;
    }
  }
}
function isSameType(lr, ar) {
  return lr && ar && ar.type === lr.type && (!ar.key || ar.key === lr.key);
}
function buildChildrenVNode(lr) {
  var ar = lr.children, cr = lr.old ? lr.old.firstChild : null, ur = null;
  ar.forEach(function(dr, hr) {
    var gr = isSameType(cr, dr);
    gr && (dr.old = cr, dr.parent = lr, dr.node = cr.node, dr.component = cr.component, dr.effect = "U"), dr && !gr && (dr.old = null, dr.parent = lr, dr.node = null, dr.effect = "A"), cr && !gr && (VNode.removalNodes.push(cr), cr.effect = "D"), cr && (cr = cr.next), hr === 0 ? lr.firstChild = dr : dr && (ur.next = dr), ur = dr;
  });
  var fr = last$1(ar);
  if (!ar.length)
    for (; cr; )
      VNode.removalNodes.push(cr), cr.effect = "D", cr = cr.next;
  for (; cr && fr; )
    cr && fr.old !== cr && (VNode.removalNodes.push(cr), cr.effect = "D", cr = cr.next);
}
function destroy(lr) {
  lr.effect = "D", VNode.removalNodes = [lr], commit(), VNode.removalNodes = [];
}
function rerender(lr) {
  var ar = lr.vnode;
  ar.effect = "U", ar.old = ar, ar.next && (ar.next.skip = !0), VNode.removalNodes = [], buildVNode(ar), commit(ar), ar.next && (ar.next.skip = !1);
}
function render(lr, ar) {
  var cr = new VNode(lr.tagName.toLowerCase(), {}, [ar]);
  return cr.node = lr, VNode.removalNodes = [], buildVNode(cr), commit(cr), function() {
    return destroy(cr.firstChild);
  };
}
var Component = (
  /** @class */
  function() {
    function lr(ar) {
      this.props = ar, this.state = {}, this.refs = {};
    }
    return lr.prototype.setState = function(ar) {
      var cr = __assign$1(__assign$1({}, this.state), ar);
      shallowEqual(this.state, cr) || (this.state = cr, rerender(this));
    }, lr;
  }()
), Switch = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.state = {
        hide: !1
      }, ur;
    }
    return ar.prototype.show = function() {
      this.setState({ hide: !1 });
    }, ar.prototype.hide = function() {
      this.setState({ hide: !0 });
    }, ar.prototype.render = function() {
      var cr = this.props, ur = cr.editorType, fr = cr.eventEmitter;
      return html$3(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([`
      <div class="`, '" style="display: ', `">
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style="display: ',
        `">
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("mode-switch"), this.state.hide ? "none" : "block", ur === "markdown" ? " active" : "", function() {
        fr.emit("needChangeMode", "markdown");
      }, i18n.get("Markdown"), ur === "wysiwyg" ? " active" : "", function() {
        fr.emit("needChangeMode", "wysiwyg");
      }, i18n.get("WYSIWYG"));
    }, ar;
  }(Component)
), templateObject_1$h;
function debounce$1(lr, ar) {
  var cr, ur;
  ar = ar || 0;
  function fr() {
    ur = Array.prototype.slice.call(arguments), window.clearTimeout(cr), cr = window.setTimeout(function() {
      lr.apply(null, ur);
    }, ar);
  }
  return fr;
}
var debounce_1 = debounce$1, debounce = debounce_1;
function throttle$1(lr, ar) {
  var cr, ur = !0, fr = function(br) {
    lr.apply(null, br), cr = null;
  }, dr, hr, gr;
  ar = ar || 0, dr = debounce(fr, ar);
  function vr() {
    if (gr = Array.prototype.slice.call(arguments), ur) {
      fr(gr), ur = !1;
      return;
    }
    hr = Number(/* @__PURE__ */ new Date()), cr = cr || hr, dr(gr), hr - cr >= ar && fr(gr);
  }
  function mr() {
    ur = !0, cr = null;
  }
  return vr.reset = mr, vr;
}
var throttle_1 = throttle$1, MapShim = function() {
  if (typeof Map != "undefined")
    return Map;
  function lr(ar, cr) {
    var ur = -1;
    return ar.some(function(fr, dr) {
      return fr[0] === cr ? (ur = dr, !0) : !1;
    }), ur;
  }
  return (
    /** @class */
    function() {
      function ar() {
        this.__entries__ = [];
      }
      return Object.defineProperty(ar.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), ar.prototype.get = function(cr) {
        var ur = lr(this.__entries__, cr), fr = this.__entries__[ur];
        return fr && fr[1];
      }, ar.prototype.set = function(cr, ur) {
        var fr = lr(this.__entries__, cr);
        ~fr ? this.__entries__[fr][1] = ur : this.__entries__.push([cr, ur]);
      }, ar.prototype.delete = function(cr) {
        var ur = this.__entries__, fr = lr(ur, cr);
        ~fr && ur.splice(fr, 1);
      }, ar.prototype.has = function(cr) {
        return !!~lr(this.__entries__, cr);
      }, ar.prototype.clear = function() {
        this.__entries__.splice(0);
      }, ar.prototype.forEach = function(cr, ur) {
        ur === void 0 && (ur = null);
        for (var fr = 0, dr = this.__entries__; fr < dr.length; fr++) {
          var hr = dr[fr];
          cr.call(ur, hr[1], hr[0]);
        }
      }, ar;
    }()
  );
}(), isBrowser = typeof window != "undefined" && typeof document != "undefined" && window.document === document, global$1 = function() {
  return typeof global != "undefined" && global.Math === Math ? global : typeof self != "undefined" && self.Math === Math ? self : typeof window != "undefined" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(lr) {
    return setTimeout(function() {
      return lr(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle(lr, ar) {
  var cr = !1, ur = !1, fr = 0;
  function dr() {
    cr && (cr = !1, lr()), ur && gr();
  }
  function hr() {
    requestAnimationFrame$1(dr);
  }
  function gr() {
    var vr = Date.now();
    if (cr) {
      if (vr - fr < trailingTimeout)
        return;
      ur = !0;
    } else
      cr = !0, ur = !1, setTimeout(hr, ar);
    fr = vr;
  }
  return gr;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver != "undefined", ResizeObserverController = (
  /** @class */
  function() {
    function lr() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    return lr.prototype.addObserver = function(ar) {
      ~this.observers_.indexOf(ar) || this.observers_.push(ar), this.connected_ || this.connect_();
    }, lr.prototype.removeObserver = function(ar) {
      var cr = this.observers_, ur = cr.indexOf(ar);
      ~ur && cr.splice(ur, 1), !cr.length && this.connected_ && this.disconnect_();
    }, lr.prototype.refresh = function() {
      var ar = this.updateObservers_();
      ar && this.refresh();
    }, lr.prototype.updateObservers_ = function() {
      var ar = this.observers_.filter(function(cr) {
        return cr.gatherActive(), cr.hasActive();
      });
      return ar.forEach(function(cr) {
        return cr.broadcastActive();
      }), ar.length > 0;
    }, lr.prototype.connect_ = function() {
      !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, lr.prototype.disconnect_ = function() {
      !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, lr.prototype.onTransitionEnd_ = function(ar) {
      var cr = ar.propertyName, ur = cr === void 0 ? "" : cr, fr = transitionKeys.some(function(dr) {
        return !!~ur.indexOf(dr);
      });
      fr && this.refresh();
    }, lr.getInstance = function() {
      return this.instance_ || (this.instance_ = new lr()), this.instance_;
    }, lr.instance_ = null, lr;
  }()
), defineConfigurable = function(lr, ar) {
  for (var cr = 0, ur = Object.keys(ar); cr < ur.length; cr++) {
    var fr = ur[cr];
    Object.defineProperty(lr, fr, {
      value: ar[fr],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return lr;
}, getWindowOf = function(lr) {
  var ar = lr && lr.ownerDocument && lr.ownerDocument.defaultView;
  return ar || global$1;
}, emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(lr) {
  return parseFloat(lr) || 0;
}
function getBordersSize(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  return ar.reduce(function(ur, fr) {
    var dr = lr["border-" + fr + "-width"];
    return ur + toFloat(dr);
  }, 0);
}
function getPaddings(lr) {
  for (var ar = ["top", "right", "bottom", "left"], cr = {}, ur = 0, fr = ar; ur < fr.length; ur++) {
    var dr = fr[ur], hr = lr["padding-" + dr];
    cr[dr] = toFloat(hr);
  }
  return cr;
}
function getSVGContentRect(lr) {
  var ar = lr.getBBox();
  return createRectInit(0, 0, ar.width, ar.height);
}
function getHTMLElementContentRect(lr) {
  var ar = lr.clientWidth, cr = lr.clientHeight;
  if (!ar && !cr)
    return emptyRect;
  var ur = getWindowOf(lr).getComputedStyle(lr), fr = getPaddings(ur), dr = fr.left + fr.right, hr = fr.top + fr.bottom, gr = toFloat(ur.width), vr = toFloat(ur.height);
  if (ur.boxSizing === "border-box" && (Math.round(gr + dr) !== ar && (gr -= getBordersSize(ur, "left", "right") + dr), Math.round(vr + hr) !== cr && (vr -= getBordersSize(ur, "top", "bottom") + hr)), !isDocumentElement(lr)) {
    var mr = Math.round(gr + dr) - ar, br = Math.round(vr + hr) - cr;
    Math.abs(mr) !== 1 && (gr -= mr), Math.abs(br) !== 1 && (vr -= br);
  }
  return createRectInit(fr.left, fr.top, gr, vr);
}
var isSVGGraphicsElement = function() {
  return typeof SVGGraphicsElement != "undefined" ? function(lr) {
    return lr instanceof getWindowOf(lr).SVGGraphicsElement;
  } : function(lr) {
    return lr instanceof getWindowOf(lr).SVGElement && typeof lr.getBBox == "function";
  };
}();
function isDocumentElement(lr) {
  return lr === getWindowOf(lr).document.documentElement;
}
function getContentRect(lr) {
  return isBrowser ? isSVGGraphicsElement(lr) ? getSVGContentRect(lr) : getHTMLElementContentRect(lr) : emptyRect;
}
function createReadOnlyRect(lr) {
  var ar = lr.x, cr = lr.y, ur = lr.width, fr = lr.height, dr = typeof DOMRectReadOnly != "undefined" ? DOMRectReadOnly : Object, hr = Object.create(dr.prototype);
  return defineConfigurable(hr, {
    x: ar,
    y: cr,
    width: ur,
    height: fr,
    top: cr,
    right: ar + ur,
    bottom: fr + cr,
    left: ar
  }), hr;
}
function createRectInit(lr, ar, cr, ur) {
  return { x: lr, y: ar, width: cr, height: ur };
}
var ResizeObservation = (
  /** @class */
  function() {
    function lr(ar) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = ar;
    }
    return lr.prototype.isActive = function() {
      var ar = getContentRect(this.target);
      return this.contentRect_ = ar, ar.width !== this.broadcastWidth || ar.height !== this.broadcastHeight;
    }, lr.prototype.broadcastRect = function() {
      var ar = this.contentRect_;
      return this.broadcastWidth = ar.width, this.broadcastHeight = ar.height, ar;
    }, lr;
  }()
), ResizeObserverEntry = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = createReadOnlyRect(cr);
      defineConfigurable(this, { target: ar, contentRect: ur });
    }
    return lr;
  }()
), ResizeObserverSPI = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof ar != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = ar, this.controller_ = cr, this.callbackCtx_ = ur;
    }
    return lr.prototype.observe = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var cr = this.observations_;
        cr.has(ar) || (cr.set(ar, new ResizeObservation(ar)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, lr.prototype.unobserve = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var cr = this.observations_;
        cr.has(ar) && (cr.delete(ar), cr.size || this.controller_.removeObserver(this));
      }
    }, lr.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, lr.prototype.gatherActive = function() {
      var ar = this;
      this.clearActive(), this.observations_.forEach(function(cr) {
        cr.isActive() && ar.activeObservations_.push(cr);
      });
    }, lr.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var ar = this.callbackCtx_, cr = this.activeObservations_.map(function(ur) {
          return new ResizeObserverEntry(ur.target, ur.broadcastRect());
        });
        this.callback_.call(ar, cr, ar), this.clearActive();
      }
    }, lr.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, lr.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, lr;
  }()
), observers = typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver = (
  /** @class */
  function() {
    function lr(ar) {
      if (!(this instanceof lr))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var cr = ResizeObserverController.getInstance(), ur = new ResizeObserverSPI(ar, cr, this);
      observers.set(this, ur);
    }
    return lr;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(lr) {
  ResizeObserver.prototype[lr] = function() {
    var ar;
    return (ar = observers.get(this))[lr].apply(ar, arguments);
  };
});
var index = function() {
  return typeof global$1.ResizeObserver != "undefined" ? global$1.ResizeObserver : ResizeObserver;
}(), HeadingPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.execCommand = function(cr) {
      var ur = closest(cr.target, "li");
      this.props.execCommand("heading", {
        level: Number(ur.getAttribute("data-level"))
      });
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([`
      <ul
        onClick=`, `
        aria-role="menu"
        aria-label="`, `"
      >
        `, `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`, `</div>
        </li>
      </ul>
    `], [
        `
      <ul
        onClick=`,
        `
        aria-role="menu"
        aria-label="`,
        `"
      >
        `,
        `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
        `</div>
        </li>
      </ul>
    `
      ])), function(ur) {
        return cr.execCommand(ur);
      }, i18n.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(ur) {
        return html$3(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `], [`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `])), ur, "h" + ur, i18n.get("Heading"), ur);
      }), i18n.get("Paragraph"));
    }, ar;
  }(Component)
), templateObject_1$g, templateObject_2$8, Tabs = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.toggleTab = function(cr, ur) {
      this.props.onClick(cr, ur);
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([`
      <div class="`, `" aria-role="tabpanel">
        `, `
      </div>
    `], [
        `
      <div class="`,
        `" aria-role="tabpanel">
        `,
        `
      </div>
    `
      ])), cls("tabs"), this.props.tabs.map(function(ur) {
        var fr = ur.name, dr = ur.text, hr = cr.props.activeTab === fr;
        return html$3(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `], [`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `])), hr ? " active" : "", function(gr) {
          return cr.toggleTab(gr, fr);
        }, i18n.get(dr), hr ? "true" : "false", hr ? "0" : "-1", i18n.get(dr));
      }));
    }, ar;
  }(Component)
), templateObject_1$f, templateObject_2$7, TYPE_UI = "ui", ImagePopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.initialize = function(fr) {
        fr === void 0 && (fr = "file");
        var dr = ur.refs.url;
        dr.value = "", ur.refs.altText.value = "", ur.refs.file.value = "", removeClass_1(dr, "wrong"), ur.setState({ activeTab: fr, file: null, fileNameElClassName: "" });
      }, ur.execCommand = function() {
        ur.state.activeTab === "file" ? ur.emitAddImageBlob() : ur.emitAddImage();
      }, ur.toggleTab = function(fr, dr) {
        dr !== ur.state.activeTab && ur.initialize(dr);
      }, ur.showFileSelectBox = function() {
        ur.refs.file.click();
      }, ur.changeFile = function(fr) {
        var dr = fr.target.files;
        dr != null && dr.length && ur.setState({ file: dr[0] });
      }, ur.state = { activeTab: "file", file: null, fileNameElClassName: "" }, ur.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ], ur;
    }
    return ar.prototype.emitAddImageBlob = function() {
      var cr = this, ur = this.refs.file.files, fr = this.refs.altText, dr = " wrong";
      if (ur != null && ur.length) {
        dr = "";
        var hr = ur.item(0), gr = function(vr, mr) {
          return cr.props.execCommand("addImage", { imageUrl: vr, altText: mr || fr.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", hr, gr, TYPE_UI);
      }
      this.setState({ fileNameElClassName: dr });
    }, ar.prototype.emitAddImage = function() {
      var cr = this.refs.url, ur = this.refs.altText, fr = cr.value, dr = ur.value || "image";
      if (removeClass_1(cr, "wrong"), !fr.length) {
        addClass_1(cr, "wrong");
        return;
      }
      fr && this.props.execCommand("addImage", { imageUrl: fr, altText: dr });
    }, ar.prototype.preventSelectStart = function(cr) {
      cr.preventDefault();
    }, ar.prototype.updated = function() {
      this.props.show || this.initialize();
    }, ar.prototype.render = function() {
      var cr = this, ur = this.state, fr = ur.activeTab, dr = ur.file, hr = ur.fileNameElClassName;
      return html$3(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert image"), Tabs, this.tabs, fr, this.toggleTab, fr === "url" ? "block" : "none", i18n.get("Image URL"), function(gr) {
        return cr.refs.url = gr;
      }, fr === "file" ? "block" : "none", i18n.get("Select image file"), cls("file-name"), dr ? " has-file" : hr, this.showFileSelectBox, this.preventSelectStart, dr ? dr.name : i18n.get("No file"), cls("file-select-button"), this.showFileSelectBox, i18n.get("Choose a file"), this.changeFile, function(gr) {
        return cr.refs.file = gr;
      }, i18n.get("Description"), function(gr) {
        return cr.refs.altText = gr;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$e, LinkPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.execCommand = function() {
        var ur = cr.refs.url, fr = cr.refs.text;
        if (removeClass_1(ur, "wrong"), removeClass_1(fr, "wrong"), ur.value.length < 1) {
          addClass_1(ur, "wrong");
          return;
        }
        var dr = isUndefined_1(cr.props.initialValues.linkUrl);
        if (dr && fr.value.length < 1) {
          addClass_1(fr, "wrong");
          return;
        }
        cr.props.execCommand("addLink", {
          linkUrl: ur.value,
          linkText: fr.value
        });
      }, cr;
    }
    return ar.prototype.initialize = function() {
      var cr = this.props.initialValues, ur = cr.linkUrl, fr = cr.linkText, dr = this.refs.url, hr = this.refs.text;
      removeClass_1(dr, "wrong"), removeClass_1(hr, "wrong", "disabled"), hr.removeAttribute("disabled"), ur && (addClass_1(hr, "disabled"), hr.setAttribute("disabled", "disabled")), dr.value = ur || "", hr.value = fr || "";
    }, ar.prototype.mounted = function() {
      this.initialize();
    }, ar.prototype.updated = function(cr) {
      !cr.show && this.props.show && this.initialize();
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert link"), i18n.get("URL"), function(ur) {
        return cr.refs.url = ur;
      }, i18n.get("Link text"), function(ur) {
        return cr.refs.text = ur;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$d, CELL_WIDTH = 20, CELL_HEIGHT = 20, MIN_ROW_INDEX = 5, MAX_ROW_INDEX = 14, MIN_COL_INDEX = 5, MAX_COL_INDEX = 9, MIN_ROW_SELECTION_INDEX = 1, MIN_COL_SELECTION_INDEX = 1, BORDER_WIDTH = 1, TablePopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.extendSelectionRange = function(fr) {
        var dr = fr.pageX, hr = fr.pageY, gr = dr - ur.offsetRect.left, vr = hr - ur.offsetRect.top, mr = ur.getSelectionRangeByOffset(gr, vr);
        ur.setState(__assign$1({}, mr));
      }, ur.execCommand = function() {
        ur.props.execCommand("addTable", {
          rowCount: ur.state.rowIdx + 1,
          columnCount: ur.state.colIdx + 1
        });
      }, ur.state = {
        rowIdx: -1,
        colIdx: -1
      }, ur;
    }
    return ar.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    }, ar.prototype.getBoundByRange = function(cr, ur) {
      return {
        width: (cr + 1) * CELL_WIDTH,
        height: (ur + 1) * CELL_HEIGHT
      };
    }, ar.prototype.getRangeByOffset = function(cr, ur) {
      return {
        colIdx: Math.floor(cr / CELL_WIDTH),
        rowIdx: Math.floor(ur / CELL_HEIGHT)
      };
    }, ar.prototype.getTableRange = function() {
      var cr = this.state, ur = cr.colIdx, fr = cr.rowIdx, dr = Math.max(ur, MIN_COL_INDEX), hr = Math.max(fr, MIN_ROW_INDEX);
      return ur >= MIN_COL_INDEX && dr < MAX_COL_INDEX && (dr += 1), fr >= MIN_ROW_INDEX && hr < MAX_ROW_INDEX && (hr += 1), { colIdx: dr + 1, rowIdx: hr + 1 };
    }, ar.prototype.getSelectionAreaBound = function() {
      var cr = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), ur = cr.width, fr = cr.height;
      return !ur && !fr ? { display: "none" } : { width: ur - BORDER_WIDTH, height: fr - BORDER_WIDTH, display: "block" };
    }, ar.prototype.getSelectionRangeByOffset = function(cr, ur) {
      var fr = this.getRangeByOffset(cr, ur);
      return fr.rowIdx = Math.min(Math.max(fr.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX), fr.colIdx = Math.min(Math.max(fr.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX), fr;
    }, ar.prototype.updated = function() {
      if (!this.props.show)
        this.setState({ colIdx: -1, rowIdx: -1 });
      else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var cr = this.refs.tableEl.getBoundingClientRect(), ur = cr.left, fr = cr.top;
        this.offsetRect = {
          left: window.pageXOffset + ur,
          top: window.pageYOffset + fr
        };
      }
    }, ar.prototype.createTableArea = function(cr) {
      for (var ur = cr.colIdx, fr = cr.rowIdx, dr = [], hr = 0; hr < fr; hr += 1) {
        for (var gr = [], vr = 0; vr < ur; vr += 1) {
          var mr = "" + cls("table-cell") + (hr > 0 ? "" : " header");
          gr.push(html$3(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(['<div class="', '"></div>'], ['<div class="', '"></div>'])), mr));
        }
        dr.push(html$3(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table-row"), gr));
      }
      return html$3(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table"), dr);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.getTableRange(), fr = this.getSelectionAreaBound();
      return html$3(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `], [`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `])), i18n.get("Insert table"), cls("table-selection"), function(dr) {
        return cr.refs.tableEl = dr;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(ur), cls("table-selection-layer"), fr, cls("table-description"), this.getDescription());
    }, ar;
  }(Component)
), templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1, CustomPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    }, ar.prototype.updated = function(cr) {
      this.refs.el.replaceChild(this.props.body, cr.body);
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(ur) {
        return cr.refs.el = ur;
      });
    }, ar;
  }(Component)
), templateObject_1$b;
function createToolbarItemInfo(lr) {
  return isString_1(lr) ? createDefaultToolbarItemInfo(lr) : lr;
}
function createScrollSyncToolbarItem() {
  var lr = document.createElement("label"), ar = document.createElement("input"), cr = document.createElement("span");
  lr.className = "scroll-sync active", ar.type = "checkbox", ar.checked = !0, cr.className = "switch";
  var ur = function(fr) {
    return ar.addEventListener("change", function(dr) {
      var hr = dr.target.checked;
      hr ? addClass_1(lr, "active") : removeClass_1(lr, "active"), fr("toggleScrollSync", { active: hr });
    });
  };
  return lr.appendChild(ar), lr.appendChild(cr), {
    name: "scrollSync",
    el: lr,
    onMounted: ur
  };
}
function createDefaultToolbarItemInfo(lr) {
  var ar;
  switch (lr) {
    case "heading":
      ar = {
        name: "heading",
        className: "heading",
        tooltip: i18n.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      ar = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: i18n.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      ar = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: i18n.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      ar = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: i18n.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      ar = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: i18n.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      ar = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: i18n.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      ar = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: i18n.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      ar = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: i18n.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      ar = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: i18n.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      ar = {
        name: "table",
        className: "table",
        tooltip: i18n.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      ar = {
        name: "image",
        className: "image",
        tooltip: i18n.get("Insert image")
      };
      break;
    case "link":
      ar = {
        name: "link",
        className: "link",
        tooltip: i18n.get("Insert link")
      };
      break;
    case "code":
      ar = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: i18n.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      ar = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: i18n.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      ar = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: i18n.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      ar = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: i18n.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      ar = createScrollSyncToolbarItem();
      break;
    case "more":
      ar = {
        name: "more",
        className: "more",
        tooltip: i18n.get("More")
      };
      break;
  }
  return ar.name !== "scrollSync" && (ar.className += " " + cls("toolbar-icons")), ar;
}
function createPopupInfo(lr, ar) {
  var cr = ar.el, ur = ar.pos, fr = ar.popup, dr = ar.initialValues;
  switch (lr) {
    case "heading":
      return {
        render: function(hr) {
          return html$3(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, hr);
        },
        className: cls("popup-add-heading"),
        fromEl: cr,
        pos: ur
      };
    case "link":
      return {
        render: function(hr) {
          return html$3(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, hr);
        },
        className: cls("popup-add-link"),
        fromEl: cr,
        pos: ur,
        initialValues: dr
      };
    case "image":
      return {
        render: function(hr) {
          return html$3(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, hr);
        },
        className: cls("popup-add-image"),
        fromEl: cr,
        pos: ur
      };
    case "table":
      return {
        render: function(hr) {
          return html$3(templateObject_4 || (templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, hr);
        },
        className: cls("popup-add-table"),
        fromEl: cr,
        pos: ur
      };
    case "customPopupBody":
      return fr ? __assign$1({ render: function(hr) {
        return html$3(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, hr, fr.body);
      }, fromEl: cr, pos: ur }, fr) : null;
    default:
      return null;
  }
}
function setGroupState(lr) {
  lr.hidden = lr.length === lr.filter(function(ar) {
    return ar.hidden;
  }).length;
}
function groupToolbarItems(lr, ar) {
  var cr = function(ur) {
    return ur.hidden = ur.name === "scrollSync" && ar, ur;
  };
  return lr.reduce(function(ur, fr) {
    ur.push(fr.map(function(hr) {
      return cr(createToolbarItemInfo(hr));
    }));
    var dr = ur[(ur.length || 1) - 1];
    return dr && setGroupState(dr), ur;
  }, []);
}
function toggleScrollSync(lr, ar) {
  lr.forEach(function(cr) {
    cr.forEach(function(ur) {
      return ur.hidden = ur.name === "scrollSync" && ar;
    }), setGroupState(cr);
  });
}
var templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5, MARGIN_FROM_RIGHT_SIDE = 20, Popup = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.handleMousedown = function(ur) {
        !closest(ur.target, "." + cls("popup")) && !closest(ur.target, cr.props.info.fromEl) && cr.props.hidePopup();
      }, cr;
    }
    return ar.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown), this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    }, ar.prototype.updated = function(cr) {
      var ur = this.props, fr = ur.show, dr = ur.info;
      if (fr && dr.pos && cr.show !== fr) {
        var hr = __assign$1({}, dr.pos), gr = this.refs.el.offsetWidth, vr = closest(this.refs.el, "." + cls("toolbar")), mr = vr.offsetWidth;
        hr.left + gr >= mr && (hr.left = mr - gr - MARGIN_FROM_RIGHT_SIDE), shallowEqual(this.state.popupPos, hr) || this.setState({ popupPos: hr });
      }
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.info, dr = ur.show, hr = ur.hidePopup, gr = ur.eventEmitter, vr = ur.execCommand, mr = fr || {}, br = mr.className, yr = br === void 0 ? "" : br, kr = mr.style, Tr = mr.render, _r = mr.initialValues, Er = _r === void 0 ? {} : _r, xr = __assign$1(__assign$1({ display: dr ? "block" : "none" }, kr), this.state.popupPos);
      return html$3(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `], [`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `])), cls("popup"), yr, xr, function(Cr) {
        return cr.refs.el = Cr;
      }, cls("popup-body"), Tr && Tr({ eventEmitter: gr, show: dr, hidePopup: hr, execCommand: vr, initialValues: Er }));
    }, ar;
  }(Component)
), templateObject_1$9, TOOLTIP_INDENT = 6;
function connectHOC(lr) {
  return (
    /** @class */
    function(ar) {
      __extends$1(cr, ar);
      function cr(ur) {
        var fr = ar.call(this, ur) || this;
        return fr.showTooltip = function(dr) {
          var hr = fr.props.item.tooltip;
          if (!fr.props.disabled && hr) {
            var gr = fr.getBound(dr), vr = gr.left + TOOLTIP_INDENT + "px", mr = gr.top + TOOLTIP_INDENT + "px";
            css_1(fr.props.tooltipRef.current, { display: "block", left: vr, top: mr }), fr.props.tooltipRef.current.querySelector(".text").textContent = hr;
          }
        }, fr.hideTooltip = function() {
          css_1(fr.props.tooltipRef.current, "display", "none");
        }, fr.state = { active: !1, disabled: ur.disabled }, fr.addEvent(), fr;
      }
      return cr.prototype.addEvent = function() {
        var ur = this, fr = this.props, dr = fr.item, hr = fr.eventEmitter;
        dr.state && hr.listen("changeToolbarState", function(gr) {
          var vr, mr = gr.toolbarState, br = (vr = mr[dr.state]) !== null && vr !== void 0 ? vr : {}, yr = br.active, kr = br.disabled;
          ur.setState({ active: !!yr, disabled: kr != null ? kr : ur.props.disabled });
        });
      }, cr.prototype.getBound = function(ur) {
        var fr = getTotalOffset(ur, closest(ur, "." + cls("toolbar"))), dr = fr.offsetLeft, hr = fr.offsetTop;
        return { left: dr, top: ur.offsetHeight + hr };
      }, cr.prototype.render = function() {
        return html$3(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `], [`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `])), lr, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      }, cr;
    }(Component)
  );
}
var templateObject_1$8, DEFAULT_WIDTH = 80, ToolbarButtonComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.showTooltip = function() {
        cr.props.showTooltip(cr.refs.el);
      }, cr.execCommand = function() {
        var ur = cr.props, fr = ur.item, dr = ur.execCommand, hr = ur.setPopupInfo, gr = ur.getBound, vr = ur.eventEmitter, mr = fr.command, br = fr.name, yr = fr.popup;
        if (mr)
          dr(mr);
        else {
          var kr = yr ? "customPopupBody" : br, Tr = vr.emit("query", "getPopupInitialValues", { popupName: kr })[0], _r = createPopupInfo(kr, {
            el: cr.refs.el,
            pos: gr(cr.refs.el),
            popup: yr,
            initialValues: Tr
          });
          _r && hr(_r);
        }
      }, cr;
    }
    return ar.prototype.mounted = function() {
      this.setItemWidth();
    }, ar.prototype.updated = function(cr) {
      cr.item.name !== this.props.item.name && this.setItemWidth();
    }, ar.prototype.setItemWidth = function() {
      var cr = this.props, ur = cr.setItemWidth, fr = cr.item;
      ur && ur(fr.name, getOuterWidth(this.refs.el) + (fr.hidden ? DEFAULT_WIDTH : 0));
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.hideTooltip, dr = ur.disabled, hr = ur.item, gr = ur.active, vr = __assign$1({ display: hr.hidden ? "none" : null }, hr.style), mr = "" + (hr.className || "") + (gr ? " active" : "");
      return html$3(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `], [`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `])), function(br) {
        return cr.refs.el = br;
      }, vr, mr, this.execCommand, this.showTooltip, fr, !!dr, hr.text || hr.tooltip || "", hr.text || "");
    }, ar;
  }(Component)
), ToolbarButton = connectHOC(ToolbarButtonComp), templateObject_1$7, CustomToolbarItemComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.showTooltip = function() {
        cr.props.showTooltip(cr.refs.el);
      }, cr.showPopup = function() {
        var ur = createPopupInfo("customPopupBody", {
          el: cr.refs.el,
          pos: cr.props.getBound(cr.refs.el),
          popup: cr.props.item.popup
        });
        ur && cr.props.setPopupInfo(ur);
      }, cr;
    }
    return ar.prototype.mounted = function() {
      var cr = this.props, ur = cr.setItemWidth, fr = cr.item;
      this.refs.el.appendChild(fr.el), ur && ur(fr.name, getOuterWidth(this.refs.el)), fr.onMounted && fr.onMounted(this.props.execCommand);
    }, ar.prototype.updated = function(cr) {
      var ur, fr = this.props, dr = fr.item, hr = fr.active, gr = fr.disabled;
      (cr.active !== hr || cr.disabled !== gr) && ((ur = dr.onUpdated) === null || ur === void 0 || ur.call(dr, { active: hr, disabled: gr }));
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.disabled, dr = ur.item, hr = { display: dr.hidden ? "none" : "inline-block" }, gr = function(vr) {
        return fr ? null : vr;
      };
      return html$3(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `], [`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `])), function(vr) {
        return cr.refs.el = vr;
      }, hr, cls("toolbar-item-wrapper"), gr(this.showPopup), gr(this.showTooltip), gr(this.props.hideTooltip));
    }, ar;
  }(Component)
), CustomToolbarItem = connectHOC(CustomToolbarItemComp), templateObject_1$6, ToolbarGroup = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.group, dr = ur.hiddenDivider, hr = fr.hidden ? { display: "none" } : null, gr = dr ? { display: "none" } : null;
      return html$3(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        `, `
        <div class="`, '" style=', `></div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        `,
        `
        <div class="`,
        '" style=',
        `></div>
      </div>
    `
      ])), cls("toolbar-group"), hr, fr.map(function(vr) {
        var mr = vr.el ? CustomToolbarItem : ToolbarButton;
        return html$3(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), mr, vr.name, cr.props, vr);
      }), cls("toolbar-divider"), gr);
    }, ar;
  }(Component)
), templateObject_1$5, templateObject_2$4, POPUP_INDENT = 4, DropdownToolbarButtonComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.handleClickDocument = function(fr) {
        var dr = fr.target;
        !closest(dr, "." + cls("dropdown-toolbar")) && !closest(dr, ".more") && ur.setState({ showDropdown: !1, dropdownPos: null });
      }, ur.showTooltip = function() {
        ur.props.showTooltip(ur.refs.el);
      }, ur.state = { showDropdown: !1, dropdownPos: null }, ur;
    }
    return ar.prototype.getBound = function() {
      var cr = this.props.getBound(this.refs.el);
      return cr.top += POPUP_INDENT, __assign$1(__assign$1({}, cr), { left: null, right: 10 });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.updated = function() {
      this.state.showDropdown && !this.state.dropdownPos && this.setState({ dropdownPos: this.getBound() });
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.state, fr = ur.showDropdown, dr = ur.dropdownPos, hr = this.props, gr = hr.disabled, vr = hr.item, mr = hr.items, br = hr.hideTooltip, yr = mr.filter(function(_r) {
        return !_r.hidden;
      }), kr = yr.length ? null : { display: "none" }, Tr = fr ? null : { display: "none" };
      return html$3(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        <button
          ref=`, `
          type="button"
          class=`, `
          onClick=`, `
          onMouseover=`, `
          onMouseout=`, `
          disabled=`, `
        ></button>
        <div
          class="`, `"
          style=`, `
          ref=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        <button
          ref=`,
        `
          type="button"
          class=`,
        `
          onClick=`,
        `
          onMouseover=`,
        `
          onMouseout=`,
        `
          disabled=`,
        `
        ></button>
        <div
          class="`,
        `"
          style=`,
        `
          ref=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("toolbar-group"), kr, function(_r) {
        return cr.refs.el = _r;
      }, vr.className, function() {
        return cr.setState({ showDropdown: !0 });
      }, this.showTooltip, br, gr, cls("dropdown-toolbar"), __assign$1(__assign$1({}, Tr), dr), function(_r) {
        return cr.refs.dropdownEl = _r;
      }, yr.length ? yr.map(function(_r, Er) {
        var xr;
        return html$3(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([`
                  <`, `
                    group=`, `
                    hiddenDivider=`, `
                    ...`, `
                  />
                `], [
          `
                  <`,
          `
                    group=`,
          `
                    hiddenDivider=`,
          `
                    ...`,
          `
                  />
                `
        ])), ToolbarGroup, _r, Er === yr.length - 1 || ((xr = yr[Er + 1]) === null || xr === void 0 ? void 0 : xr.hidden), cr.props);
      }) : null);
    }, ar;
  }(Component)
), DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp), templateObject_1$4, templateObject_2$3, INLINE_PADDING = 50, Toolbar = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.toggleTab = function(fr, dr) {
        var hr = ur.props.eventEmitter;
        if (ur.state.activeTab !== dr) {
          var gr = dr === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          hr.emit(gr), ur.setState({ activeTab: dr });
        }
      }, ur.setItemWidth = function(fr, dr) {
        ur.itemWidthMap[fr] = dr;
      }, ur.setPopupInfo = function(fr) {
        ur.setState({ showPopup: !0, popupInfo: fr });
      }, ur.openPopup = function(fr, dr) {
        dr === void 0 && (dr = {});
        var hr = ur.refs.el.querySelector("." + cls("toolbar-group") + " ." + fr);
        if (hr) {
          var gr = getTotalOffset(hr, closest(hr, "." + cls("toolbar"))), vr = gr.offsetLeft, mr = gr.offsetTop, br = createPopupInfo(fr, {
            el: hr,
            pos: { left: vr, top: hr.offsetHeight + mr },
            initialValues: dr
          });
          br && ur.setPopupInfo(br);
        }
      }, ur.hidePopup = function() {
        ur.state.showPopup && ur.setState({ showPopup: !1 });
      }, ur.execCommand = function(fr, dr) {
        var hr = ur.props.eventEmitter;
        hr.emit("command", fr, dr), ur.hidePopup();
      }, ur.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ], ur.itemWidthMap = {}, ur.initialItems = groupToolbarItems(cr.toolbarItems || [], ur.hiddenScrollSync()), ur.state = {
        items: ur.initialItems,
        dropdownItems: [],
        showPopup: !1,
        popupInfo: {},
        activeTab: "write"
      }, ur.tooltipRef = { current: null }, ur.resizeObserver = new index(function() {
        return ur.handleResize();
      }), ur.addEvent(), ur;
    }
    return ar.prototype.insertToolbarItem = function(cr, ur) {
      var fr = cr.groupIndex, dr = cr.itemIndex, hr = this.initialItems[fr];
      ur = createToolbarItemInfo(ur), hr ? hr.splice(dr, 0, ur) : this.initialItems.push([ur]), this.setState(this.classifyToolbarItems());
    }, ar.prototype.removeToolbarItem = function(cr) {
      var ur = this;
      forEachArray_1(this.initialItems, function(fr) {
        var dr = !1;
        return forEachArray_1(fr, function(hr, gr) {
          return hr.name === cr ? (dr = !0, fr.splice(gr, 1), ur.setState(ur.classifyToolbarItems()), !1) : !0;
        }), !dr;
      });
    }, ar.prototype.addEvent = function() {
      var cr = this, ur = this.props.eventEmitter;
      this.handleResize = throttle_1(function() {
        cr.setState({ items: cr.initialItems, dropdownItems: [] }), cr.setState(cr.classifyToolbarItems());
      }, 200), ur.listen("openPopup", this.openPopup);
    }, ar.prototype.appendTooltipToRoot = function() {
      var cr = '<div class="' + cls("tooltip") + `" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`;
      this.tooltipRef.current = createElementWith(cr, this.refs.el);
    }, ar.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    }, ar.prototype.movePrevItemToDropdownToolbar = function(cr, ur, fr, dr) {
      var hr = function(vr) {
        var mr = vr.pop();
        mr && dr.push(mr);
      };
      if (cr > 1)
        hr(fr);
      else {
        var gr = last$1(ur);
        gr && hr(gr);
      }
    }, ar.prototype.classifyToolbarItems = function() {
      var cr = this, ur = 0, fr = this.refs.el.clientWidth, dr = this.refs.el.querySelector("." + cls("toolbar-divider")), hr = dr ? getOuterWidth(dr) : 0, gr = [], vr = [], mr = !1;
      return this.initialItems.forEach(function(br, yr) {
        var kr = [], Tr = [];
        br.forEach(function(_r, Er) {
          _r.hidden || (ur += cr.itemWidthMap[_r.name], ur > fr - INLINE_PADDING ? (mr || (cr.movePrevItemToDropdownToolbar(Er, gr, kr, Tr), mr = !0), Tr.push(_r)) : kr.push(_r));
        }), kr.length && (setGroupState(kr), gr.push(kr)), Tr.length && (setGroupState(Tr), vr.push(Tr)), yr < cr.state.items.length - 1 && (ur += hr);
      }), { items: gr, dropdownItems: vr };
    }, ar.prototype.mounted = function() {
      this.props.previewStyle === "tab" && this.props.eventEmitter.emit("changePreviewTabWrite", !0), this.setState(this.classifyToolbarItems()), this.appendTooltipToRoot(), this.resizeObserver.observe(this.refs.el);
    }, ar.prototype.updated = function(cr) {
      var ur = this.props, fr = ur.editorType, dr = ur.previewStyle, hr = ur.eventEmitter, gr = dr !== cr.previewStyle, vr = fr !== cr.editorType;
      if (gr || vr) {
        toggleScrollSync(this.initialItems, this.hiddenScrollSync());
        var mr = this.classifyToolbarItems();
        (gr || dr === "tab" && fr === "markdown") && (hr.emit("changePreviewTabWrite"), mr.activeTab = "write"), this.setState(mr);
      }
    }, ar.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize), this.resizeObserver.disconnect(), removeNode$1(this.tooltipRef.current);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.previewStyle, dr = ur.eventEmitter, hr = ur.editorType, gr = this.state, vr = gr.popupInfo, mr = gr.showPopup, br = gr.activeTab, yr = gr.items, kr = gr.dropdownItems, Tr = {
        eventEmitter: dr,
        tooltipRef: this.tooltipRef,
        disabled: hr === "markdown" && fr === "tab" && br === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      }, _r = fr === "tab" ? { borderTopLeftRadius: 0 } : null;
      return html$3(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([`
      <div class="`, `">
        <div
          class="`, `"
          style="display: `, `"
        >
          <`, " tabs=", " activeTab=", " onClick=", ` />
        </div>
        <div
          class="`, `"
          ref=`, `
          style=`, `
        >
          `, `
          <`, `
            item=`, `
            items=`, `
            ...`, `
          />
        </div>
        <`, `
          info=`, `
          show=`, `
          eventEmitter=`, `
          hidePopup=`, `
          execCommand=`, `
        />
      </div>
    `], [
        `
      <div class="`,
        `">
        <div
          class="`,
        `"
          style="display: `,
        `"
        >
          <`,
        " tabs=",
        " activeTab=",
        " onClick=",
        ` />
        </div>
        <div
          class="`,
        `"
          ref=`,
        `
          style=`,
        `
        >
          `,
        `
          <`,
        `
            item=`,
        `
            items=`,
        `
            ...`,
        `
          />
        </div>
        <`,
        `
          info=`,
        `
          show=`,
        `
          eventEmitter=`,
        `
          hidePopup=`,
        `
          execCommand=`,
        `
        />
      </div>
    `
      ])), cls("toolbar"), cls("md-tab-container"), hr === "wysiwyg" || fr === "vertical" ? "none" : "block", Tabs, this.tabs, br, this.toggleTab, cls("defaultUI-toolbar"), function(Er) {
        return cr.refs.el = Er;
      }, _r, yr.map(function(Er, xr) {
        var Cr;
        return html$3(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `], [`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `])), ToolbarGroup, Er, xr === yr.length - 1 || ((Cr = yr[xr + 1]) === null || Cr === void 0 ? void 0 : Cr.hidden), cr.setItemWidth, Tr);
      }), DropdownToolbarButton, createToolbarItemInfo("more"), kr, Tr, Popup, vr, mr, dr, this.hidePopup, this.execCommand);
    }, ar;
  }(Component)
), templateObject_1$3, templateObject_2$2, ContextMenu = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.handleClickDocument = function(fr) {
        closest(fr.target, "." + cls("context-menu")) || ur.setState({ pos: null });
      }, ur.state = {
        pos: null,
        menuGroups: []
      }, ur.addEvent(), ur;
    }
    return ar.prototype.addEvent = function() {
      var cr = this;
      this.props.eventEmitter.listen("contextmenu", function(ur) {
        var fr = ur.pos, dr = ur.menuGroups;
        cr.setState({ pos: fr, menuGroups: dr });
      });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.getMenuGroupElements = function() {
      var cr = this, ur = this.state, fr = ur.pos, dr = ur.menuGroups;
      return fr ? dr.reduce(function(hr, gr) {
        var vr = [];
        return gr.forEach(function(mr) {
          var br = mr.label, yr = mr.className, kr = yr === void 0 ? !1 : yr, Tr = mr.disabled, _r = mr.onClick, Er = function() {
            Tr || (_r(), cr.setState({ pos: null }));
          };
          vr.push(html$3(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `], [`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `])), Er, Tr ? " disabled" : "", kr, br));
        }), hr.push(html$3(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([`<ul class="menu-group">
              `, `
            </ul>`], [`<ul class="menu-group">
              `, `
            </ul>`])), vr)), hr;
      }, []) : [];
    }, ar.prototype.render = function() {
      var cr = __assign$1({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return html$3(templateObject_3 || (templateObject_3 = __makeTemplateObject(['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`], ['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`])), cls("context-menu"), cr, this.getMenuGroupElements());
    }, ar;
  }(Component)
), templateObject_1$2, templateObject_2$1, templateObject_3, Layout = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      ur.changeMode = function(hr) {
        hr !== ur.state.editorType && ur.setState({ editorType: hr });
      }, ur.changePreviewStyle = function(hr) {
        hr !== ur.state.previewStyle && ur.setState({ previewStyle: hr });
      }, ur.hide = function() {
        ur.setState({ hide: !0 });
      }, ur.show = function() {
        ur.setState({ hide: !1 });
      };
      var fr = cr.editorType, dr = cr.previewStyle;
      return ur.state = {
        editorType: fr,
        previewStyle: dr,
        hide: !1
      }, ur.addEvent(), ur;
    }
    return ar.prototype.mounted = function() {
      var cr = this.props.slots, ur = cr.wwEditor, fr = cr.mdEditor, dr = cr.mdPreview;
      this.refs.wwContainer.appendChild(ur), this.refs.mdContainer.insertAdjacentElement("afterbegin", fr), this.refs.mdContainer.appendChild(dr);
    }, ar.prototype.insertToolbarItem = function(cr, ur) {
      this.toolbar.insertToolbarItem(cr, ur);
    }, ar.prototype.removeToolbarItem = function(cr) {
      this.toolbar.removeToolbarItem(cr);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.eventEmitter, dr = ur.hideModeSwitch, hr = ur.toolbarItems, gr = ur.theme, vr = this.state, mr = vr.hide, br = vr.previewStyle, yr = vr.editorType, kr = mr ? " hidden" : "", Tr = cls(yr === "markdown" ? "md-mode" : "ww-mode"), _r = cls("md") + "-" + br + "-style", Er = cls([gr !== "light", gr + " "]);
      return html$3(templateObject_2 || (templateObject_2 = __makeTemplateObject([`
      <div
        class="`, "", "", `"
        ref=`, `
      >
        <`, `
          ref=`, `
          eventEmitter=`, `
          previewStyle=`, `
          toolbarItems=`, `
          editorType=`, `
        />
        <div
          class="`, " ", `"
          ref=`, `
        >
          <div class="`, `">
            <div
              class="`, " ", `"
              ref=`, `
            >
              <div class="`, `"></div>
            </div>
            <div
              class="`, `"
              ref=`, `
            />
          </div>
        </div>
        `, `
        <`, " eventEmitter=", ` />
      </div>
    `], [
        `
      <div
        class="`,
        "",
        "",
        `"
        ref=`,
        `
      >
        <`,
        `
          ref=`,
        `
          eventEmitter=`,
        `
          previewStyle=`,
        `
          toolbarItems=`,
        `
          editorType=`,
        `
        />
        <div
          class="`,
        " ",
        `"
          ref=`,
        `
        >
          <div class="`,
        `">
            <div
              class="`,
        " ",
        `"
              ref=`,
        `
            >
              <div class="`,
        `"></div>
            </div>
            <div
              class="`,
        `"
              ref=`,
        `
            />
          </div>
        </div>
        `,
        `
        <`,
        " eventEmitter=",
        ` />
      </div>
    `
      ])), Er, cls("defaultUI"), kr, function(xr) {
        return cr.refs.el = xr;
      }, Toolbar, function(xr) {
        return cr.toolbar = xr;
      }, fr, br, hr, yr, cls("main"), Tr, function(xr) {
        return cr.refs.editorSection = xr;
      }, cls("main-container"), cls("md-container"), _r, function(xr) {
        return cr.refs.mdContainer = xr;
      }, cls("md-splitter"), cls("ww-container"), function(xr) {
        return cr.refs.wwContainer = xr;
      }, !dr && html$3(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, fr, yr), ContextMenu, fr);
    }, ar.prototype.addEvent = function() {
      var cr = this.props.eventEmitter;
      cr.listen("hide", this.hide), cr.listen("show", this.show), cr.listen("changeMode", this.changeMode), cr.listen("changePreviewStyle", this.changePreviewStyle);
    }, ar;
  }(Component)
), templateObject_1$1, templateObject_2, ToastUIEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur, fr = lr.call(this, cr) || this, dr, hr = render(fr.options.el, html$3(templateObject_1 || (templateObject_1 = __makeTemplateObject([`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `], [`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `])), Layout, function(gr) {
        return dr = gr;
      }, fr.eventEmitter, fr.getEditorElements(), fr.options.hideModeSwitch, fr.options.toolbarItems, fr.options.previewStyle, fr.options.initialEditType, fr.options.theme));
      return fr.setMinHeight(fr.options.minHeight), fr.setHeight(fr.options.height), fr.defaultUI = {
        insertToolbarItem: dr.insertToolbarItem.bind(dr),
        removeToolbarItem: dr.removeToolbarItem.bind(dr),
        destroy: hr
      }, (ur = fr.pluginInfo.toolbarItems) === null || ur === void 0 || ur.forEach(function(gr) {
        var vr = gr.groupIndex, mr = gr.itemIndex, br = gr.item;
        fr.defaultUI.insertToolbarItem({ groupIndex: vr, itemIndex: mr }, br);
      }), fr.eventEmitter.emit("loadUI", fr), fr;
    }
    return ar.factory = function(cr) {
      return cr.viewer ? new ToastUIEditorViewer(cr) : new ar(cr);
    }, ar.prototype.insertToolbarItem = function(cr, ur) {
      this.defaultUI.insertToolbarItem(cr, ur);
    }, ar.prototype.removeToolbarItem = function(cr) {
      this.defaultUI.removeToolbarItem(cr);
    }, ar.prototype.destroy = function() {
      lr.prototype.destroy.call(this), this.defaultUI.destroy();
    }, ar;
  }(ToastUIEditorCore)
), templateObject_1;
ToastUIEditorCore.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});
const css$1 = `/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */.ProseMirror{position:relative;word-wrap:break-word;white-space:pre-wrap;white-space:break-spaces;-webkit-font-variant-ligatures:none;font-variant-ligatures:none;-webkit-font-feature-settings:"liga" 0;font-feature-settings:"liga" 0}.ProseMirror pre{white-space:pre-wrap}.ProseMirror li{position:relative}.ProseMirror-hideselection *::selection{background:transparent}.ProseMirror-hideselection *::-moz-selection{background:transparent}.ProseMirror-hideselection{caret-color:transparent}.ProseMirror-selectednode{outline:2px solid #8cf}li.ProseMirror-selectednode{outline:none}li.ProseMirror-selectednode:after{content:"";position:absolute;inset:-2px -2px -2px -32px;border:2px solid #8cf;pointer-events:none}img.ProseMirror-separator{display:inline!important;border:none!important;margin:0!important}.auto-height,.auto-height .toastui-editor-defaultUI{height:auto}.auto-height .toastui-editor-md-container{position:relative}:not(.auto-height)>.toastui-editor-defaultUI,:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-direction:column;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{-ms-flex:1;-webkit-box-flex:1;flex:1}.toastui-editor-md-container:after,.toastui-editor-defaultUI-toolbar:after{content:"";display:block;height:0;clear:both}.toastui-editor-main{min-height:0px;position:relative;height:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-md-container{display:none;overflow:hidden;height:100%}.toastui-editor-md-container .toastui-editor{line-height:1.5;position:relative}.toastui-editor-md-container .toastui-editor,.toastui-editor-md-container .toastui-editor-md-preview{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;height:inherit}.toastui-editor-md-container .toastui-editor-md-preview{overflow:auto;padding:0 25px;height:100%}.toastui-editor-md-container .toastui-editor-md-preview>p:first-child{margin-top:0!important}.toastui-editor-md-container .toastui-editor-md-preview .toastui-editor-contents{padding-top:8px}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor,.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-md-preview{width:100%;display:none}.toastui-editor-main .toastui-editor-md-tab-style>.active{display:block}.toastui-editor-main .toastui-editor-md-vertical-style>.toastui-editor-tabs{display:none}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-tabs{display:block}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor,.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-preview{width:50%}.toastui-editor-main .toastui-editor-md-splitter{display:none;height:100%;width:1px;background-color:#ebedf2;position:absolute;left:50%}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-splitter{display:block}.toastui-editor-ww-container{display:none;overflow:hidden;height:inherit;background-color:#fff}.auto-height .toastui-editor-main-container{position:relative}.toastui-editor-main-container{position:absolute;line-height:1;color:#222;width:100%;height:inherit}.toastui-editor-ww-container>.toastui-editor{height:inherit;position:relative;width:100%}.toastui-editor-ww-container .toastui-editor-contents{overflow:auto;-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:16px 25px 0;height:inherit}.toastui-editor-ww-container .toastui-editor-contents p{margin:0}.toastui-editor-md-mode .toastui-editor-md-container,.toastui-editor-ww-mode .toastui-editor-ww-container{display:block;z-index:20}.toastui-editor-md-mode .toastui-editor-md-vertical-style{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-main.hidden,.toastui-editor-defaultUI.hidden{display:none}.toastui-editor-defaultUI .ProseMirror{padding:18px 25px}.toastui-editor-defaultUI{position:relative;border:1px solid #dadde6;height:100%;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;border-radius:4px}.toastui-editor-defaultUI button{color:#333;height:28px;font-size:13px;cursor:pointer;border:none;border-radius:2px}.toastui-editor-defaultUI .toastui-editor-ok-button{min-width:63px;height:32px;background-color:#00a9ff;color:#fff;outline-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-ok-button:hover{background-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-close-button{min-width:63px;height:32px;background-color:#f7f9fc;border:1px solid #dadde6;margin-right:5px;outline-color:#cbcfdb}.toastui-editor-defaultUI .toastui-editor-close-button:hover{border-color:#cbcfdb}.toastui-editor-mode-switch{background-color:#fff;border-top:1px solid #dadde6;font-size:12px;text-align:right;height:28px;padding-right:10px;border-radius:0 0 3px 3px}.toastui-editor-mode-switch .tab-item{display:inline-block;width:96px;height:24px;line-height:24px;text-align:center;background:#f7f9fc;color:#969aa5;margin-top:-1px;margin-right:-1px;cursor:pointer;border:1px solid #dadde6;border-radius:0 0 4px 4px;font-weight:500;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-mode-switch .tab-item.active{border-top:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-defaultUI .toastui-editor-md-tab-container{float:left;height:45px;font-size:13px;background:#f7f9fc;border-bottom:1px solid #ebedf2;border-top-left-radius:3px}.toastui-editor-md-tab-container .toastui-editor-tabs{margin-left:15px;height:100%}.toastui-editor-md-tab-container .tab-item{display:inline-block;width:70px;height:33px;line-height:33px;font-size:12px;font-weight:500;text-align:center;background:#eaedf1;color:#969aa5;cursor:pointer;border:1px solid #dadde6;border-radius:4px 4px 0 0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:13px}.toastui-editor-md-tab-container .tab-item.active{border-bottom:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-md-tab-container .tab-item:last-child{margin-left:-1px}.toastui-editor-defaultUI-toolbar{display:-ms-flexbox;display:-webkit-box;display:flex;padding:0 25px;height:45px;background-color:#f7f9fc;border-bottom:1px solid #ebedf2;border-radius:3px 3px 0 0}.toastui-editor-toolbar{height:46px;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-toolbar-divider{display:inline-block;width:1px;height:18px;background-color:#e1e3e9;margin:14px 12px}.toastui-editor-toolbar-group{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-defaultUI-toolbar button{-webkit-box-sizing:border-box;box-sizing:border-box;cursor:pointer;width:32px;height:32px;padding:0;border-radius:3px;margin:7px 5px;border:1px solid #f7f9fc}.toastui-editor-defaultUI-toolbar button:not(:disabled):hover{border:1px solid #e4e7ee;background-color:#fff}.toastui-editor-defaultUI-toolbar .scroll-sync{display:inline-block;position:relative;width:70px;height:10px;text-align:center;line-height:10px;color:#81858f;cursor:pointer}.toastui-editor-defaultUI-toolbar .scroll-sync:before{content:"Scroll";position:absolute;left:0;font-size:14px}.toastui-editor-defaultUI-toolbar .scroll-sync.active:before{color:#00a9ff}.toastui-editor-defaultUI-toolbar .scroll-sync input{opacity:0;width:0;height:0}.toastui-editor-defaultUI-toolbar .switch{position:absolute;inset:0 0 0 45px;background-color:#d6d8de;-webkit-transition:.4s;transition:.4s;border-radius:50px}.toastui-editor-defaultUI-toolbar input:checked+.switch{background-color:#acddfa}.toastui-editor-defaultUI-toolbar .switch:before{position:absolute;content:"";height:14px;width:14px;left:0;bottom:-2px;background-color:#94979f;-webkit-transition:.4s;transition:.4s;border-radius:50%}.toastui-editor-defaultUI-toolbar input:checked+.switch:before{background-color:#00a9ff;-webkit-transform:translateX(12px);transform:translate(12px)}.toastui-editor-dropdown-toolbar .scroll-sync{margin:0 5px}.toastui-editor-dropdown-toolbar{position:absolute;height:46px;z-index:30;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;background-color:#f7f9fc;display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-toolbar-item-wrapper{margin:7px 5px;height:32px;line-height:32px}.toastui-editor-popup{width:400px;margin-right:auto;background:#fff;z-index:30;position:absolute;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6}.toastui-editor-popup-body{padding:15px;font-size:12px}.toastui-editor-popup-body label{font-weight:600;color:#555;display:block;margin:20px 0 5px}.toastui-editor-popup-body .toastui-editor-button-container{text-align:right;margin-top:20px}.toastui-editor-popup-body input[type=text]{width:calc(100% - 26px);height:30px;padding:0 12px;border-radius:2px;border:1px solid #e1e3e9;color:#333}.toastui-editor-popup-body input[type=text]:focus{outline:1px solid #00a9ff;border-color:transparent}.toastui-editor-popup-body input[type=text].disabled{background-color:#f7f9fc;border-color:#e1e3e9;color:#969aa5}.toastui-editor-popup-body input[type=file]{opacity:0;border:none;width:1px;height:1px;position:absolute;top:0;left:0}.toastui-editor-popup-body input.wrong,.toastui-editor-popup-body span.wrong{border-color:#fa2828}.toastui-editor-popup-add-link .toastui-editor-popup-body,.toastui-editor-popup-add-image .toastui-editor-popup-body{padding:0 20px 20px}.toastui-editor-popup-add-image .toastui-editor-tabs{margin:5px 0 10px}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item{display:inline-block;width:60px;height:40px;line-height:40px;border-bottom:1px solid #dadde6;color:#333;font-size:13px;font-weight:600;text-align:center;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item:hover{border-bottom:1px solid #cbcfdb}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item.active{color:#00a9ff;border-bottom:2px solid #00a9ff}.toastui-editor-popup-add-image .toastui-editor-file-name{width:58%;display:inline-block;border-radius:2px;border:1px solid #e1e3e9;color:#dadde6;height:30px;line-height:30px;padding:0 12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:pointer}.toastui-editor-popup-add-image .toastui-editor-file-name.has-file{color:#333}.toastui-editor-popup-add-image .toastui-editor-file-select-button{width:33%;margin-left:5px;height:32px;border-radius:2px;border:1px solid #dadde6;background-color:#f7f9fc;vertical-align:top}.toastui-editor-popup-add-image .toastui-editor-file-select-button:hover{border-color:#cbcfdb}.toastui-editor-popup-add-table{width:auto}.toastui-editor-popup-add-table .toastui-editor-table-selection{position:relative}.toastui-editor-popup-add-table .toastui-editor-table-cell{display:table-cell;width:20px;height:20px;border:1px solid #e1e3e9;background:#fff;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-table .toastui-editor-table-cell.header{background:#f7f9fc}.toastui-editor-popup-add-table .toastui-editor-table-row{display:table-row}.toastui-editor-popup-add-table .toastui-editor-table{display:table;border-collapse:collapse}.toastui-editor-popup-add-table .toastui-editor-table-selection-layer{position:absolute;top:0;left:0;border:1px solid #00a9ff;background:rgba(0,169,255,.1);z-index:30}.toastui-editor-popup-add-table .toastui-editor-table-description{margin:5px 0 0;text-align:center;color:#333}.toastui-editor-popup-add-heading{width:auto}.toastui-editor-popup-add-heading .toastui-editor-popup-body{padding:0}.toastui-editor-popup-add-heading h1,.toastui-editor-popup-add-heading h2,.toastui-editor-popup-add-heading h3,.toastui-editor-popup-add-heading h4,.toastui-editor-popup-add-heading h5,.toastui-editor-popup-add-heading h6,.toastui-editor-popup-add-heading ul,.toastui-editor-popup-add-heading p{padding:0;margin:0}.toastui-editor-popup-add-heading ul{padding:5px 0;list-style:none}.toastui-editor-popup-add-heading ul li{padding:4px 12px;cursor:pointer}.toastui-editor-popup-add-heading ul li:hover{background-color:#dff4ff}.toastui-editor-popup-add-heading h1{font-size:24px}.toastui-editor-popup-add-heading h2{font-size:22px}.toastui-editor-popup-add-heading h3{font-size:20px}.toastui-editor-popup-add-heading h4{font-size:18px}.toastui-editor-popup-add-heading h5{font-size:16px}.toastui-editor-popup-add-heading h6{font-size:14px}.toastui-editor-context-menu{position:absolute;width:auto;min-width:197px;color:#333;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;z-index:30;padding:5px 0;background-color:#fff}.toastui-editor-context-menu .menu-group{list-style:none;border-bottom:1px solid #ebedf2;padding:0;margin:0;font-size:13px}.toastui-editor-context-menu .menu-group:last-child{border-bottom:none!important}.toastui-editor-context-menu .menu-item{height:32px;line-height:32px;padding:0 14px;cursor:pointer}.toastui-editor-context-menu span{display:inline-block}.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px;content:"";width:20px;height:20px;display:inline-block;vertical-align:middle;margin-right:10px}.toastui-editor-context-menu .add-row-up:before{background-position:3px -104px}.toastui-editor-context-menu .add-row-down:before{background-position:-19px -104px}.toastui-editor-context-menu .remove-row:before{background-position:-41px -104px}.toastui-editor-context-menu .add-column-left:before{background-position:-63px -104px}.toastui-editor-context-menu .add-column-right:before{background-position:-85px -104px}.toastui-editor-context-menu .remove-column:before{background-position:-111px -104px}.toastui-editor-context-menu .align-column-left:before{background-position:-129px -104px}.toastui-editor-context-menu .align-column-center:before{background-position:-151px -104px}.toastui-editor-context-menu .align-column-right:before{background-position:-173px -104px}.toastui-editor-context-menu .remove-table:before{background-position:-197px -104px}.toastui-editor-context-menu .disabled span:before{opacity:.3}.toastui-editor-context-menu li:not(.disabled):hover{background-color:#dff4ff}.toastui-editor-context-menu li.disabled{color:#c9ccd5}.toastui-editor-tooltip{position:absolute;background-color:#444;z-index:40;padding:4px 7px;font-size:12px;border-radius:3px;color:#fff;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif}.toastui-editor-tooltip .arrow{content:"";display:inline-block;width:10px;height:10px;background-color:#444;-webkit-transform:rotate(45deg);transform:rotate(45deg);position:absolute;top:-3px;left:6px;z-index:-1}.toastui-editor-toolbar-icons{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px}@media only screen and (-webkit-min-device-pixel-ratio: 2),only screen and (min-device-pixel-ratio: 2),only screen and (min-resolution: 192dpi),only screen and (min-resolution: 2dppx){.toastui-editor-toolbar-icons,.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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P0A9dgflJJi2Szl5led4F57jlvpECs/6vuTjuhR3dAo961VP9UoRby5eaGBuxz2Zy/3pyiWBlJEiA/s5FHaEnU170tGmBChvV5O1/Zske9dQ3upqiLdbfuL3hTpvY+q8m3ELRkrj1xLs36Md8A17jhOutYwTnYufJw89tLmvbxmhJagIVEmgaoW0yvjlXQREQASakkA77LJL42wfGmdpGiktpZBagaFRfQqNsDNGSykNldFTUQ6+3ZQFWEJlRsA6pVmzZjML1sks0hoiosy9vMoqq2wVjg7VEMNQkHbLTzEI7tOqdCoeTd1nn7dK2tjwf2F5Gsro3cVhdS4CItCcBKSQNud9kVQiIAIikIqAjZLSQNu8lGeujZiyW8pvs7mHI6W2tb/tlF28jigvcRfSmLUpw+doZDQvxM0Xb40zpbLKiE03nWtLiOpVRp1A7ZYfl6+4yTPqo5hO4nndFPt4fi+OHTv2Qb5x/Y+4P9lFQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAQ6mYDfyZlX3kVABESgnQgc/WRhlf5F3j6Dvjdw6UT/mnbKm/IiAiIgAiIgAiLQngSkkLbnfVWuREAEOohA7+OFsc8v8w4peN43yfZGlnW/y9t/9kT/2g7CoKyKgAiIgAiIgAi0IIGeFpRZIouACIhA3QSOm1fY4A3f28MiWqXg/fyCyf7CuiMdhQiOmFc4YOEy7zsk/fZhyRe89ww7b8GTI+YXthv0vBO9gjcZ8TdoUBYWer43r8vzzpk1yb+vQWkqmVEmcPQjhY36+rzv0amzI6I0qqy5XC9kdGDumDHeSRdv5T/n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vaXiGC338PM8x9WSftjWO6CWsArTOAKhollR2UwjEc9wdYeNvhHCevQvqneamUs5jzhd3GlMemI2KtUTUyq89dBYDwAArSK8cWt+zbJmtNII6bA8tdAI6TC5wxP7rtbACm97tkR/K+ssVude9DBm+gqV+JM9a3q/rfW7Vklpya19CNCr94HCAFOk3LRd33u1u8vbhSlgLfWJFJ71famHrqt0Z6ivplBf17v2qFIymV1n07LtaITNJW+jus8B3NjU09sxzQZqmWVeETWcACNtV1PespspVUcOKG/XMLpUV0O83fITx3nEo4WNB1d4N+O2Rdw9yc7z+z1GRr/RrCOjSTInuTHq+3naNz3U4dcnXZebCLQDAeo+HSIgAiLQeQTaYZfdI+YV9qGhUrGR0moKqZVGlG2bxnzGaCmloTJ6Ksrotzvv6eisHFunNGvWHiHX64xyzl8eO8bbKhwdqlmUdstPMYjgqwH/9I6mQ/F4OhKYzTvi+F82kzjtksn+3SOuyEEERKApCUghbcrbIqFEQAREIB0BGyXF5+ZlfCdN2S3jvXku2UgpCveJNDxtp+xh64hylNKm/s1jaPYcjYzmSLnJoq5lplSGWVhIY2yuLSGqVxl1MrVbfly+4qZtXnT0Q96kPs/btKvgjUc5fbHH9x6cMdG39Ws6REAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERAACviiIgAiIgAgMJ7DPPvvshMuNoeueN9xww5zhPnQmAiIgAiIgAiIgAiKQBYGeLCJRHCIgAiLQTgR839++UCiMtzyZHUMKaTvd4AzzctBBB627bNmydxDl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UvksxkDZi5yw9xKm1xzi5RjlMLe10HTi3YPCeTZ1ZPD5F2TYieT/wnPzFPb+vr6+zTDdxmA2a0Yjo3aDdIiACIiACIhADgS6ysRpa5gadTQyrUblqSHp0GgyZTTYwCghwWBNqflJuNZop2rucTV+S+Wjmjiq8VsqvbzdU8tIebDNVtxuusEGRjTArcPi2piQ+9Eg3yN2LqsI1EMgdflMmwhK4ADldgr+o3JLXRaN+DMD5GyU1prXQjMKfarF4eQhbp/fppy/FzOujM4kHU3TdaBkioAIiIAIiEDGBEoqpLaGibQyb2QkyD8qa8Ro7Ng60cX2C+0JojW/E0qF7aAbrRslL2faLyb57qGfmFPjrVWUp0zKQ6PTy5toFfmx0ZzbkMfKdqCMWqMdt+LG/XN8f/E3dch9axjWpgW33QGvtqgfKtyYzO5hNeWzgkzDLlu55XcEv1eHXchgLTRxFsJnYwfsd/GL775rQ7j2fHwGpfgorg1bX1oki05FQAREQAREQAREoHMJMBp2s02Rsx/2MxwJs8fctcuuA9MhJpuxbMrvU8XZtZEfysZetkau+JrORaDZCFBex1OP/drVZUXmNfGRzHpl57lYm867iTw32y5atGi9euNTeBEQAREQAREQgXQEgo+Dp/MqX81IgAbUm2iUXYBs8+nJvyguIw2sYzifRO/+cYwEBN8AiV+XXQREQASalYApo9Rh5dZCm+jX2rTe+Ohms+ZHcomACIiACIiACIiACIiACIiACLQIAUZDvx4fEaXz7SwbEcXtmrg7SuueLZIliSkCIiACIiACIpBAoOQa0gS/chIBERABERCBhhBg1LMRa6EbkhclIgIiIAIiIAIiIAIiIAIiIAIi0GIEtBa6xW6YxBUBERABERABERABERABERABERABERABERABERCBViHw/wHIAHUN1iL6RwAAAABJRU5ErkJggg==) no-repeat;background-size:466px 146px}}.toastui-editor-toolbar-icons{background-position-y:3px}.toastui-editor-toolbar-icons:disabled{opacity:.3}.toastui-editor-toolbar-icons.heading{background-position-x:3px}.toastui-editor-toolbar-icons.bold{background-position-x:-23px}.toastui-editor-toolbar-icons.italic{background-position-x:-49px}.toastui-editor-toolbar-icons.strike{background-position-x:-75px}.toastui-editor-toolbar-icons.hrline{background-position-x:-101px}.toastui-editor-toolbar-icons.quote{background-position-x:-127px}.toastui-editor-toolbar-icons.bullet-list{background-position-x:-153px}.toastui-editor-toolbar-icons.ordered-list{background-position-x:-179px}.toastui-editor-toolbar-icons.task-list{background-position-x:-205px}.toastui-editor-toolbar-icons.indent{background-position-x:-231px}.toastui-editor-toolbar-icons.outdent{background-position-x:-257px}.toastui-editor-toolbar-icons.table{background-position-x:-283px}.toastui-editor-toolbar-icons.image{background-position-x:-309px}.toastui-editor-toolbar-icons.link{background-position-x:-334px}.toastui-editor-toolbar-icons.code{background-position-x:-361px}.toastui-editor-toolbar-icons.codeblock{background-position-x:-388px}.toastui-editor-toolbar-icons.more{background-position-x:-412px}.toastui-editor-toolbar-icons:not(:disabled).active{background-position-y:-23px}@media only screen and (max-width: 480px){.toastui-editor-popup{max-width:300px;margin-left:-150px}.toastui-editor-dropdown-toolbar{max-width:none}}.ProseMirror{font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;color:#222;font-size:13px;overflow-y:auto;overflow-X:hidden;height:calc(100% - 36px)}.ProseMirror .placeholder{color:#999}.ProseMirror:focus{outline:none}.ProseMirror-selectednode{outline:none}table.ProseMirror-selectednode,.html-block.ProseMirror-selectednode{border-radius:2px;outline:2px solid #00a9ff}.toastui-editor-contents{margin:0;padding:0;font-size:13px;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;z-index:20}.toastui-editor-contents *:not(table){line-height:160%;-webkit-box-sizing:content-box;box-sizing:content-box}.toastui-editor-contents i,.toastui-editor-contents cite,.toastui-editor-contents em,.toastui-editor-contents var,.toastui-editor-contents address,.toastui-editor-contents dfn{font-style:italic}.toastui-editor-contents strong{font-weight:700}.toastui-editor-contents p{margin:10px 0;color:#222}.toastui-editor-contents>h1:first-of-type,.toastui-editor-contents>div>div:first-of-type h1{margin-top:14px}.toastui-editor-contents h1,.toastui-editor-contents h2,.toastui-editor-contents h3,.toastui-editor-contents h4,.toastui-editor-contents h5,.toastui-editor-contents h6{font-weight:700;color:#222}.toastui-editor-contents h1{font-size:24px;line-height:28px;border-bottom:3px double #999;margin:52px 0 15px;padding-bottom:7px}.toastui-editor-contents h2{font-size:22px;line-height:23px;border-bottom:1px solid #dbdbdb;margin:20px 0 13px;padding-bottom:7px}.toastui-editor-contents h3{font-size:20px;margin:18px 0 2px}.toastui-editor-contents h4{font-size:18px;margin:10px 0 2px}.toastui-editor-contents h3,.toastui-editor-contents h4{line-height:18px}.toastui-editor-contents h5{font-size:16px}.toastui-editor-contents h6{font-size:14px}.toastui-editor-contents h5,.toastui-editor-contents h6{line-height:17px;margin:9px 0 -4px}.toastui-editor-contents del{color:#999}.toastui-editor-contents blockquote{margin:14px 0;border-left:4px solid #e5e5e5;padding:0 16px;color:#999}.toastui-editor-contents blockquote p,.toastui-editor-contents blockquote ul,.toastui-editor-contents blockquote ol{color:#999}.toastui-editor-contents blockquote>:first-child{margin-top:0}.toastui-editor-contents blockquote>:last-child{margin-bottom:0}.toastui-editor-contents pre,.toastui-editor-contents code{font-family:Consolas,Courier,Apple SD 산돌고딕 Neo,-apple-system,Lucida Grande,Apple SD Gothic Neo,맑은 고딕,Malgun Gothic,Segoe UI,돋움,dotum,sans-serif;border:0;border-radius:0}.toastui-editor-contents pre{margin:2px 0 8px;padding:18px;background-color:#f4f7f8}.toastui-editor-contents code{color:#c1798b;background-color:#f9f2f4;padding:2px 3px;letter-spacing:-.3px;border-radius:2px}.toastui-editor-contents pre code{padding:0;color:inherit;white-space:pre-wrap;background-color:transparent}.toastui-editor-contents img{margin:4px 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box;vertical-align:top;max-width:100%}.toastui-editor-contents table{border:1px solid rgba(0,0,0,.1);margin:12px 0 14px;color:#222;width:auto;border-collapse:collapse;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-contents table th,.toastui-editor-contents table td{border:1px solid rgba(0,0,0,.1);padding:5px 14px 5px 12px;height:32px}.toastui-editor-contents table th{background-color:#555;font-weight:300;color:#fff;padding-top:6px}.toastui-editor-contents th p{margin:0;color:#fff}.toastui-editor-contents td p{margin:0;padding:0 2px}.toastui-editor-contents td.toastui-editor-cell-selected{background-color:#d8dfec}.toastui-editor-contents th.toastui-editor-cell-selected{background-color:#908f8f}.toastui-editor-contents ul,.toastui-editor-contents menu,.toastui-editor-contents ol,.toastui-editor-contents dir{display:block;list-style-type:none;padding-left:24px;margin:6px 0 10px;color:#222}.toastui-editor-contents ol{list-style-type:none;counter-reset:li}.toastui-editor-contents ol>li{counter-increment:li}.toastui-editor-contents ul>li:before,.toastui-editor-contents ol>li:before{display:inline-block;position:absolute}.toastui-editor-contents ul>li:before{content:"";margin-top:6px;margin-left:-17px;width:5px;height:5px;border-radius:50%;background-color:#ccc}.toastui-editor-contents ol>li:before{content:"." counter(li);margin-left:-28px;width:24px;text-align:right;direction:rtl;color:#aaa}.toastui-editor-contents ul ul,.toastui-editor-contents ul ol,.toastui-editor-contents ol ol,.toastui-editor-contents ol ul{margin-top:0!important;margin-bottom:0!important}.toastui-editor-contents ul li,.toastui-editor-contents ol li{position:relative}.toastui-editor-contents ul p,.toastui-editor-contents ol p{margin:0}.toastui-editor-contents hr{border-top:1px solid #eee;margin:16px 0}.toastui-editor-contents a{text-decoration:underline;color:#4b96e6}.toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-contents .image-link{position:relative}.toastui-editor-contents .image-link:hover:before{content:"";position:absolute;width:30px;height:30px;right:0;border-radius:50%;border:1px solid #c9ccd5;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiM1NTUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAwIC00NTgxKSB0cmFuc2xhdGUoOTk1IDQ1NzYpIHRyYW5zbGF0ZSg1IDUpIHNjYWxlKDEgLTEpIHJvdGF0ZSg0NSAzNy4yOTMgMCkiLz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzI2IDQuOTM0bDEuODIyLjAwMmMxLjQ4NyAwIDIuNjkzIDEuMjI4IDIuNjkzIDIuNzQ0di4xOTJjMCAxLjUxNS0xLjIwNiAyLjc0NC0yLjY5MyAyLjc0NGgtMy44NDVjLTEuNDg3IDAtMi42OTItMS4yMjktMi42OTItMi43NDRWNy42OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMDAgLTQ1ODEpIHRyYW5zbGF0ZSg5OTUgNDU3NikgdHJhbnNsYXRlKDUgNSkgc2NhbGUoMSAtMSkgcm90YXRlKDQ1IDMwLjk5NiAwKSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K) no-repeat;background-position:center;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;cursor:pointer}.toastui-editor-contents .task-list-item{border:0;list-style:none;padding-left:24px;margin-left:-24px}.toastui-editor-contents .task-list-item:before{background-repeat:no-repeat;background-size:18px 18px;background-position:center;content:"";margin-left:0;margin-top:0;border-radius:2px;height:18px;width:18px;position:absolute;left:0;top:1px;cursor:pointer;background:transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQ0NDIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMjk2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMDQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==)}.toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-custom-block .toastui-editor-custom-block-editor{background:#f9f7fd;color:#452d6b;border:solid 1px #dbd4ea}.toastui-editor-custom-block .toastui-editor-custom-block-view{position:relative;padding:9px 13px 8px 12px}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{border:solid 1px #dbd4ea;border-radius:2px}.toastui-editor-custom-block .toastui-editor-custom-block-view .tool{position:absolute;right:10px;top:7px;display:none}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view .tool{display:block}.toastui-editor-custom-block-view button{vertical-align:middle;width:15px;height:15px;margin-left:8px;padding:3px;border:solid 1px #cccccc;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:center;background-size:30px 30px}.toastui-editor-custom-block-view .info{font-size:13px;font-weight:700;color:#5200d0;vertical-align:middle}.toastui-editor-contents .toastui-editor-ww-code-block{position:relative}.toastui-editor-contents .toastui-editor-ww-code-block:after{content:attr(data-language);position:absolute;display:inline-block;top:10px;right:10px;height:24px;padding:3px 35px 0 10px;font-weight:700;font-size:13px;color:#333;background:#e5e9ea url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:right;border-radius:2px;background-size:30px 30px;cursor:pointer}.toastui-editor-ww-code-block-language{position:fixed;display:inline-block;width:100px;height:27px;right:35px;border:1px solid #ccc;border-radius:2px;background-color:#fff;z-index:30}.toastui-editor-ww-code-block-language input{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:0 10px;height:100%;width:100%;background-color:transparent;border:none;outline:none}.toastui-editor-contents-placeholder:before{content:attr(data-placeholder);color:gray;line-height:160%;position:absolute}.toastui-editor-md-preview .toastui-editor-contents h1{min-height:28px}.toastui-editor-md-preview .toastui-editor-contents h2{min-height:23px}.toastui-editor-md-preview .toastui-editor-contents blockquote{min-height:20px}.toastui-editor-md-preview .toastui-editor-contents li{min-height:22px}.toastui-editor-pseudo-clipboard{position:fixed;opacity:0;width:0;height:0;left:-1000px;top:-1000px;z-index:-1}.toastui-editor-contents .toastui-editor-md-preview-highlight{position:relative;z-index:0}.toastui-editor-contents .toastui-editor-md-preview-highlight:after{content:"";background-color:#fff58380;border-radius:4px;z-index:-1;position:absolute;inset:-4px}.toastui-editor-contents h1.toastui-editor-md-preview-highlight:after,.toastui-editor-contents h2.toastui-editor-md-preview-highlight:after{bottom:0}.toastui-editor-contents td.toastui-editor-md-preview-highlight:after,.toastui-editor-contents th.toastui-editor-md-preview-highlight:after{display:none}.toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fff58380}.toastui-editor-contents th.toastui-editor-md-preview-highlight{color:#222}.toastui-editor-md-heading1{font-size:24px}.toastui-editor-md-heading2{font-size:22px}.toastui-editor-md-heading3{font-size:20px}.toastui-editor-md-heading4{font-size:18px}.toastui-editor-md-heading5{font-size:16px}.toastui-editor-md-heading6{font-size:14px}.toastui-editor-md-heading.toastui-editor-md-delimiter.setext{line-height:15px}.toastui-editor-md-strong,.toastui-editor-md-heading,.toastui-editor-md-list-item-style,.toastui-editor-md-list-item .toastui-editor-md-meta{font-weight:700}.toastui-editor-md-emph{font-style:italic}.toastui-editor-md-strike{text-decoration:line-through}.toastui-editor-md-strike.toastui-editor-md-delimiter{text-decoration:none}.toastui-editor-md-delimiter,.toastui-editor-md-thematic-break,.toastui-editor-md-link,.toastui-editor-md-table,.toastui-editor-md-block-quote{color:#ccc}.toastui-editor-md-code.toastui-editor-md-delimiter{color:#aaa}.toastui-editor-md-meta,.toastui-editor-md-html,.toastui-editor-md-link.toastui-editor-md-link-url.toastui-editor-md-marked-text{color:#999}.toastui-editor-md-block-quote .toastui-editor-md-marked-text,.toastui-editor-md-list-item .toastui-editor-md-meta{color:#555}.toastui-editor-md-table .toastui-editor-md-table-cell{color:#222}.toastui-editor-md-link.toastui-editor-md-link-desc.toastui-editor-md-marked-text,.toastui-editor-md-list-item-style.toastui-editor-md-list-item-odd{color:#4b96e6}.toastui-editor-md-list-item-style.toastui-editor-md-list-item-even{color:#cb4848}.toastui-editor-md-code.toastui-editor-md-marked-text{color:#c1798b}.toastui-editor-md-code{background-color:#f3e5e980;padding:2px 0;letter-spacing:-.3px}.toastui-editor-md-code.toastui-editor-md-start{padding-left:2px;border-top-left-radius:2px;border-bottom-left-radius:2px}.toastui-editor-md-code.toastui-editor-md-end{padding-right:2px;border-top-right-radius:2px;border-bottom-right-radius:2px}.toastui-editor-md-code-block-line-background{background-color:#f5f7f8}.toastui-editor-md-code-block-line-background.start,.toastui-editor-md-custom-block-line-background.start{margin-top:2px}.toastui-editor-md-code,.toastui-editor-md-code-block{font-family:Consolas,Courier,Lucida Grande,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif}.toastui-editor-md-custom-block{color:#452d6b}.toastui-editor-md-custom-block-line-background{background-color:#f9f7fd}.toastui-editor-md-custom-block .toastui-editor-md-delimiter{color:#b8b3c0}.toastui-editor-md-custom-block .toastui-editor-md-meta{color:#5200d0}
`, dark = `@charset "UTF-8";.toastui-editor-dark.toastui-editor-defaultUI{border-color:#494c56;color:#eee}.toastui-editor-dark .toastui-editor-md-container,.toastui-editor-dark .toastui-editor-ww-container{background-color:#121212}.toastui-editor-dark .toastui-editor-defaultUI-toolbar{background-color:#232428;border-bottom-color:#303238}.toastui-editor-dark .toastui-editor-toolbar-icons{background-position-y:-49px;border-color:#232428}.toastui-editor-dark .toastui-editor-toolbar-icons:not(:disabled):hover{background-color:#36383f;border-color:#36383f}.toastui-editor-dark .toastui-editor-toolbar-divider{background-color:#303238}.toastui-editor-dark .toastui-editor-tooltip,.toastui-editor-dark .toastui-editor-tooltip .arrow{background-color:#535662}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .scroll-sync:before{color:#8f939f}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .scroll-sync.active:before{color:#67ccff}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .switch{background-color:#2b4455}.toastui-editor-dark .toastui-editor-defaultUI-toolbar input:checked+.switch{background-color:#2b4455}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .switch:before{background-color:#8f939f}.toastui-editor-dark .toastui-editor-defaultUI-toolbar input:checked+.switch:before{background-color:#67ccff}.toastui-editor-dark .toastui-editor-main .toastui-editor-md-splitter{background-color:#303238}.toastui-editor-dark .toastui-editor-mode-switch{border-top-color:#393b42;background-color:#121212}.toastui-editor-dark .toastui-editor-mode-switch .tab-item{border-color:#393b42;background-color:#232428;color:#757a86}.toastui-editor-dark .toastui-editor-mode-switch .tab-item.active{border-top-color:#121212;background-color:#121212;color:#eee}.toastui-editor-dark .toastui-editor-popup,.toastui-editor-dark .toastui-editor-context-menu{background-color:#121212;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border-color:#494c56}.toastui-editor-dark .toastui-editor-popup-add-heading ul li:hover{background-color:#36383f}.toastui-editor-dark .toastui-editor-popup-body label{color:#9a9da3}.toastui-editor-dark .toastui-editor-popup-body input[type=text]{background-color:transparent;color:#eee;border-color:#303238}.toastui-editor-dark .toastui-editor-popup-body input[type=text]:focus{outline-color:#67ccff}.toastui-editor-dark .toastui-editor-popup-body input[type=text].disabled{color:#969aa5;border-color:#303238;background-color:#30323866}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item{border-bottom-color:#292e37;color:#eee}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item:hover{border-bottom-color:#3c424d}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item.active{color:#67ccff;border-bottom-color:#67ccff}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-name{border-color:#303238;color:#eee}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-select-button{border-color:#303238;background-color:#232428;color:#eee}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-select-button:hover{border-color:#494c56}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-close-button{color:#eee;border-color:#303238;background-color:#232428}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-close-button:hover{border-color:#494c56}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-ok-button{color:#121212;background-color:#67ccff}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-ok-button:hover{color:#121212;background-color:#32baff}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-cell{border-color:#303238;background-color:#121212}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-cell.header{border-color:#303238;background-color:#232428}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-selection-layer{border-color:#67ccff66;background-color:#67ccff1a}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-description{color:#eee}.toastui-editor-dark .toastui-editor-md-tab-container{background-color:#232428;border-bottom-color:#303238}.toastui-editor-dark .toastui-editor-md-tab-container .tab-item{border-color:#393b42;background-color:#2d2f34;color:#757a86}.toastui-editor-dark .toastui-editor-md-tab-container .tab-item.active{border-bottom-color:#121212;background-color:#121212;color:#eee}.toastui-editor-dark .toastui-editor-context-menu .menu-group{border-bottom-color:#303238;color:#eee}.toastui-editor-dark .toastui-editor-context-menu .menu-item span:before{background-position-y:-126px}.toastui-editor-dark .toastui-editor-context-menu li:not(.disabled):hover{background-color:#36383f}.toastui-editor-dark .toastui-editor-context-menu li.disabled{color:#969aa5}.toastui-editor-dark .toastui-editor-dropdown-toolbar{border-color:#494c56;background-color:#232428}.toastui-editor-dark .ProseMirror,.toastui-editor-dark .toastui-editor-contents p,.toastui-editor-dark .toastui-editor-contents h1,.toastui-editor-dark .toastui-editor-contents h2,.toastui-editor-dark .toastui-editor-contents h3,.toastui-editor-dark .toastui-editor-contents h4,.toastui-editor-dark .toastui-editor-contents h5,.toastui-editor-dark .toastui-editor-contents h6{color:#fff}.toastui-editor-dark .toastui-editor-contents h1,.toastui-editor-dark .toastui-editor-contents h2{border-color:#fff}.toastui-editor-dark .toastui-editor-contents del{color:#777980}.toastui-editor-dark .toastui-editor-contents blockquote{border-color:#303135}.toastui-editor-dark .toastui-editor-contents blockquote p,.toastui-editor-dark .toastui-editor-contents blockquote ul,.toastui-editor-dark .toastui-editor-contents blockquote ol{color:#777980}.toastui-editor-dark .toastui-editor-contents pre{background-color:#232428}.toastui-editor-dark .toastui-editor-contents pre code{background-color:transparent;color:#fff}.toastui-editor-dark .toastui-editor-contents code{color:#c1798b;background-color:#35262a}.toastui-editor-dark .toastui-editor-contents div{color:#fff}.toastui-editor-dark .toastui-editor-ww-code-block-language{border-color:#303238;background-color:#121212}.toastui-editor-dark .toastui-editor-ww-code-block-language input{color:#fff}.toastui-editor-dark .toastui-editor-contents .toastui-editor-ww-code-block:after{background-color:#232428;border:1px solid #393b42;color:#eee;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6I2ZmZjt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==)}.toastui-editor-dark .toastui-editor-contents .toastui-editor-custom-block-editor{background:#392d31;color:#fff;border-color:#327491}.toastui-editor-dark .toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{color:#fff;border-color:#327491}.toastui-editor-dark .toastui-editor-custom-block-view button{background-color:#232428;border-color:#393b42;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6I2ZmZjt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==)}.toastui-editor-dark .toastui-editor-custom-block-view button:hover{background-color:#232428;border-color:#595c68}.toastui-editor-dark .toastui-editor-custom-block-view .info{color:#65acca}.toastui-editor-dark .toastui-editor-contents table,.toastui-editor-dark .toastui-editor-contents table th,.toastui-editor-dark .toastui-editor-contents table td{border-color:#303238}.toastui-editor-dark .toastui-editor-contents table th{background-color:#3a3c42}.toastui-editor-dark .toastui-editor-contents table td,.toastui-editor-dark .toastui-editor-contents table td p{color:#fff}.toastui-editor-dark .toastui-editor-contents td.toastui-editor-cell-selected{background-color:#67ccff80}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-cell-selected{background-color:#67ccff4d}.toastui-editor-dark table.ProseMirror-selectednode,.toastui-editor-dark .html-block.ProseMirror-selectednode{outline-color:#67ccff}.toastui-editor-dark .toastui-editor-contents ul,.toastui-editor-dark .toastui-editor-contents menu,.toastui-editor-dark .toastui-editor-contents ol,.toastui-editor-dark .toastui-editor-contents dir{color:#55575f}.toastui-editor-dark .toastui-editor-contents ul>li:before{background-color:#55575f}.toastui-editor-dark .toastui-editor-contents hr{border-color:#55575f}.toastui-editor-dark .toastui-editor-contents a{color:#4b96e6}.toastui-editor-dark .toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-dark .toastui-editor-contents .image-link:hover:before{border-color:#393b42;background-color:#232428;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiNFRUUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDQ1IC0xNzQzKSB0cmFuc2xhdGUoMTA0MCAxNzM4KSB0cmFuc2xhdGUoNSA1KSBzY2FsZSgxIC0xKSByb3RhdGUoNDUgMzcuMjkzIDApIi8+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEyLjMyNiA0LjkzNGwxLjgyMi4wMDJjMS40ODcgMCAyLjY5MyAxLjIyOCAyLjY5MyAyLjc0NHYuMTkyYzAgMS41MTUtMS4yMDYgMi43NDQtMi42OTMgMi43NDRoLTMuODQ1Yy0xLjQ4NyAwLTIuNjkyLTEuMjI5LTIuNjkyLTIuNzQ0VjcuNjgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDQ1IC0xNzQzKSB0cmFuc2xhdGUoMTA0MCAxNzM4KSB0cmFuc2xhdGUoNSA1KSBzY2FsZSgxIC0xKSByb3RhdGUoNDUgMzAuOTk2IDApIi8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPgo=);-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014}.toastui-editor-dark .toastui-editor-contents .task-list-item:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgc3Ryb2tlPSIjNTU1NzVGIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMzE2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMjQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==);background-color:transparent}.toastui-editor-dark .toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-dark .toastui-editor-md-delimiter,.toastui-editor-dark .toastui-editor-md-code.toastui-editor-md-delimiter,.toastui-editor-dark .toastui-editor-md-thematic-break,.toastui-editor-dark .toastui-editor-md-link,.toastui-editor-dark .toastui-editor-md-table,.toastui-editor-dark .toastui-editor-md-block-quote,.toastui-editor-dark .toastui-editor-md-meta,.toastui-editor-dark .toastui-editor-md-html{color:#55575f}.toastui-editor-dark .toastui-editor-md-link.toastui-editor-md-link-url.toastui-editor-md-marked-text{color:#777980}.toastui-editor-dark .toastui-editor-md-block-quote .toastui-editor-md-marked-text,.toastui-editor-dark .toastui-editor-md-list-item .toastui-editor-md-meta{color:#b3b5bc}.toastui-editor-dark .toastui-editor-md-link.toastui-editor-md-link-desc.toastui-editor-md-marked-text,.toastui-editor-dark .toastui-editor-md-list-item-style.toastui-editor-md-list-item-odd{color:#4b96e6}.toastui-editor-dark .toastui-editor-md-list-item-style.toastui-editor-md-list-item-even{color:#ef6767}.toastui-editor-dark .toastui-editor-md-table .toastui-editor-md-table-cell{color:#fff}.toastui-editor-dark .toastui-editor-md-code.toastui-editor-md-marked-text{color:#c1798b}.toastui-editor-dark .toastui-editor-md-code{background-color:#35262a}.toastui-editor-dark .toastui-editor-md-code-block-line-background{background-color:#232428}.toastui-editor-dark .toastui-editor-md-code-block .toastui-editor-md-meta{color:#aaa}.toastui-editor-dark .toastui-editor-md-custom-block{color:#fff}.toastui-editor-dark .toastui-editor-md-custom-block-line-background{background-color:#392d31}.toastui-editor-dark .toastui-editor-md-custom-block .toastui-editor-md-delimiter{color:#327491}.toastui-editor-dark .toastui-editor-md-custom-block .toastui-editor-md-meta{color:#65acca}.toastui-editor-dark .toastui-editor-contents .toastui-editor-md-preview-highlight:after{background-color:#fffac180}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-dark .toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fffac180}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight{color:#fff}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-dark .toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fffac140}.toastui-editor-dark .toastui-editor-contents .toastui-editor-md-preview-highlight:after{background-color:#fffac140}
`;
var dist = {}, api = {}, streamUploader = {}, upload = {}, sjcl = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(lr) {
  var ar = { cipher: {}, hash: {}, keyexchange: {}, mode: {}, misc: {}, codec: {}, exception: { corrupt: function(_r) {
    this.toString = function() {
      return "CORRUPT: " + this.message;
    }, this.message = _r;
  }, invalid: function(_r) {
    this.toString = function() {
      return "INVALID: " + this.message;
    }, this.message = _r;
  }, bug: function(_r) {
    this.toString = function() {
      return "BUG: " + this.message;
    }, this.message = _r;
  }, notReady: function(_r) {
    this.toString = function() {
      return "NOT READY: " + this.message;
    }, this.message = _r;
  } } };
  ar.cipher.aes = function(_r) {
    this.s[0][0][0] || this.O();
    var Er, xr, Cr, Ar, Lr = this.s[0][4], Dr = this.s[1];
    Er = _r.length;
    var Nr = 1;
    if (Er !== 4 && Er !== 6 && Er !== 8)
      throw new ar.exception.invalid("invalid aes key size");
    for (this.b = [Cr = _r.slice(0), Ar = []], _r = Er; _r < 4 * Er + 28; _r++)
      xr = Cr[_r - 1], (_r % Er === 0 || Er === 8 && _r % Er === 4) && (xr = Lr[xr >>> 24] << 24 ^ Lr[xr >> 16 & 255] << 16 ^ Lr[xr >> 8 & 255] << 8 ^ Lr[xr & 255], _r % Er === 0 && (xr = xr << 8 ^ xr >>> 24 ^ Nr << 24, Nr = Nr << 1 ^ 283 * (Nr >> 7))), Cr[_r] = Cr[_r - Er] ^ xr;
    for (Er = 0; _r; Er++, _r--)
      xr = Cr[Er & 3 ? _r : _r - 4], Ar[Er] = 4 >= _r || 4 > Er ? xr : Dr[0][Lr[xr >>> 24]] ^ Dr[1][Lr[xr >> 16 & 255]] ^ Dr[2][Lr[xr >> 8 & 255]] ^ Dr[3][Lr[xr & 255]];
  }, ar.cipher.aes.prototype = { encrypt: function(_r) {
    return cr(this, _r, 0);
  }, decrypt: function(_r) {
    return cr(this, _r, 1);
  }, s: [[[], [], [], [], []], [[], [], [], [], []]], O: function() {
    var _r = this.s[0], Er = this.s[1], xr = _r[4], Cr = Er[4], Ar, Lr, Dr, Nr = [], Hr = [], $r, Wr, Zr, oi;
    for (Ar = 0; 256 > Ar; Ar++)
      Hr[(Nr[Ar] = Ar << 1 ^ 283 * (Ar >> 7)) ^ Ar] = Ar;
    for (Lr = Dr = 0; !xr[Lr]; Lr ^= $r || 1, Dr = Hr[Dr] || 1)
      for (Zr = Dr ^ Dr << 1 ^ Dr << 2 ^ Dr << 3 ^ Dr << 4, Zr = Zr >> 8 ^ Zr & 255 ^ 99, xr[Lr] = Zr, Cr[Zr] = Lr, Wr = Nr[Ar = Nr[$r = Nr[Lr]]], oi = 16843009 * Wr ^ 65537 * Ar ^ 257 * $r ^ 16843008 * Lr, Wr = 257 * Nr[Zr] ^ 16843008 * Zr, Ar = 0; 4 > Ar; Ar++)
        _r[Ar][Lr] = Wr = Wr << 24 ^ Wr >>> 8, Er[Ar][Zr] = oi = oi << 24 ^ oi >>> 8;
    for (Ar = 0; 5 > Ar; Ar++)
      _r[Ar] = _r[Ar].slice(0), Er[Ar] = Er[Ar].slice(0);
  } };
  function cr(_r, Er, xr) {
    if (Er.length !== 4)
      throw new ar.exception.invalid("invalid aes block size");
    var Cr = _r.b[xr], Ar = Er[0] ^ Cr[0], Lr = Er[xr ? 3 : 1] ^ Cr[1], Dr = Er[2] ^ Cr[2];
    Er = Er[xr ? 1 : 3] ^ Cr[3];
    var Nr, Hr, $r, Wr = Cr.length / 4 - 2, Zr, oi = 4, Jr = [0, 0, 0, 0];
    Nr = _r.s[xr], _r = Nr[0];
    var Yr = Nr[1], li = Nr[2], Si = Nr[3], ci = Nr[4];
    for (Zr = 0; Zr < Wr; Zr++)
      Nr = _r[Ar >>> 24] ^ Yr[Lr >> 16 & 255] ^ li[Dr >> 8 & 255] ^ Si[Er & 255] ^ Cr[oi], Hr = _r[Lr >>> 24] ^ Yr[Dr >> 16 & 255] ^ li[Er >> 8 & 255] ^ Si[Ar & 255] ^ Cr[oi + 1], $r = _r[Dr >>> 24] ^ Yr[Er >> 16 & 255] ^ li[Ar >> 8 & 255] ^ Si[Lr & 255] ^ Cr[oi + 2], Er = _r[Er >>> 24] ^ Yr[Ar >> 16 & 255] ^ li[Lr >> 8 & 255] ^ Si[Dr & 255] ^ Cr[oi + 3], oi += 4, Ar = Nr, Lr = Hr, Dr = $r;
    for (Zr = 0; 4 > Zr; Zr++)
      Jr[xr ? 3 & -Zr : Zr] = ci[Ar >>> 24] << 24 ^ ci[Lr >> 16 & 255] << 16 ^ ci[Dr >> 8 & 255] << 8 ^ ci[Er & 255] ^ Cr[oi++], Nr = Ar, Ar = Lr, Lr = Dr, Dr = Er, Er = Nr;
    return Jr;
  }
  ar.bitArray = { bitSlice: function(_r, Er, xr) {
    return _r = ar.bitArray.$(_r.slice(Er / 32), 32 - (Er & 31)).slice(1), xr === void 0 ? _r : ar.bitArray.clamp(_r, xr - Er);
  }, extract: function(_r, Er, xr) {
    var Cr = Math.floor(-Er - xr & 31);
    return ((Er + xr - 1 ^ Er) & -32 ? _r[Er / 32 | 0] << 32 - Cr ^ _r[Er / 32 + 1 | 0] >>> Cr : _r[Er / 32 | 0] >>> Cr) & (1 << xr) - 1;
  }, concat: function(_r, Er) {
    if (_r.length === 0 || Er.length === 0)
      return _r.concat(Er);
    var xr = _r[_r.length - 1], Cr = ar.bitArray.getPartial(xr);
    return Cr === 32 ? _r.concat(Er) : ar.bitArray.$(Er, Cr, xr | 0, _r.slice(0, _r.length - 1));
  }, bitLength: function(_r) {
    var Er = _r.length;
    return Er === 0 ? 0 : 32 * (Er - 1) + ar.bitArray.getPartial(_r[Er - 1]);
  }, clamp: function(_r, Er) {
    if (32 * _r.length < Er)
      return _r;
    _r = _r.slice(0, Math.ceil(Er / 32));
    var xr = _r.length;
    return Er = Er & 31, 0 < xr && Er && (_r[xr - 1] = ar.bitArray.partial(Er, _r[xr - 1] & 2147483648 >> Er - 1, 1)), _r;
  }, partial: function(_r, Er, xr) {
    return _r === 32 ? Er : (xr ? Er | 0 : Er << 32 - _r) + 1099511627776 * _r;
  }, getPartial: function(_r) {
    return Math.round(_r / 1099511627776) || 32;
  }, equal: function(_r, Er) {
    if (ar.bitArray.bitLength(_r) !== ar.bitArray.bitLength(Er))
      return !1;
    var xr = 0, Cr;
    for (Cr = 0; Cr < _r.length; Cr++)
      xr |= _r[Cr] ^ Er[Cr];
    return xr === 0;
  }, $: function(_r, Er, xr, Cr) {
    var Ar;
    for (Ar = 0, Cr === void 0 && (Cr = []); 32 <= Er; Er -= 32)
      Cr.push(xr), xr = 0;
    if (Er === 0)
      return Cr.concat(_r);
    for (Ar = 0; Ar < _r.length; Ar++)
      Cr.push(xr | _r[Ar] >>> Er), xr = _r[Ar] << 32 - Er;
    return Ar = _r.length ? _r[_r.length - 1] : 0, _r = ar.bitArray.getPartial(Ar), Cr.push(ar.bitArray.partial(Er + _r & 31, 32 < Er + _r ? xr : Cr.pop(), 1)), Cr;
  }, i: function(_r, Er) {
    return [_r[0] ^ Er[0], _r[1] ^ Er[1], _r[2] ^ Er[2], _r[3] ^ Er[3]];
  }, byteswapM: function(_r) {
    var Er, xr;
    for (Er = 0; Er < _r.length; ++Er)
      xr = _r[Er], _r[Er] = xr >>> 24 | xr >>> 8 & 65280 | (xr & 65280) << 8 | xr << 24;
    return _r;
  } }, ar.codec.utf8String = { fromBits: function(_r) {
    var Er = "", xr = ar.bitArray.bitLength(_r), Cr, Ar;
    for (Cr = 0; Cr < xr / 8; Cr++)
      !(Cr & 3) && (Ar = _r[Cr / 4]), Er += String.fromCharCode(Ar >>> 8 >>> 8 >>> 8), Ar <<= 8;
    return decodeURIComponent(escape(Er));
  }, toBits: function(_r) {
    _r = unescape(encodeURIComponent(_r));
    var Er = [], xr, Cr = 0;
    for (xr = 0; xr < _r.length; xr++)
      Cr = Cr << 8 | _r.charCodeAt(xr), (xr & 3) === 3 && (Er.push(Cr), Cr = 0);
    return xr & 3 && Er.push(ar.bitArray.partial(8 * (xr & 3), Cr)), Er;
  } }, ar.codec.hex = { fromBits: function(_r) {
    var Er = "", xr;
    for (xr = 0; xr < _r.length; xr++)
      Er += ((_r[xr] | 0) + 263882790666240).toString(16).substr(4);
    return Er.substr(0, ar.bitArray.bitLength(_r) / 4);
  }, toBits: function(_r) {
    var Er, xr = [], Cr;
    for (_r = _r.replace(/\s|0x/g, ""), Cr = _r.length, _r = _r + "00000000", Er = 0; Er < _r.length; Er += 8)
      xr.push(parseInt(_r.substr(Er, 8), 16) ^ 0);
    return ar.bitArray.clamp(xr, 4 * Cr);
  } }, ar.codec.base32 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", X: "0123456789ABCDEFGHIJKLMNOPQRSTUV", BITS: 32, BASE: 5, REMAINING: 27, fromBits: function(_r, Er, xr) {
    var Cr = ar.codec.base32.BASE, Ar = ar.codec.base32.REMAINING, Lr = "", Dr = 0, Nr = ar.codec.base32.B, Hr = 0, $r = ar.bitArray.bitLength(_r);
    for (xr && (Nr = ar.codec.base32.X), xr = 0; Lr.length * Cr < $r; )
      Lr += Nr.charAt((Hr ^ _r[xr] >>> Dr) >>> Ar), Dr < Cr ? (Hr = _r[xr] << Cr - Dr, Dr += Ar, xr++) : (Hr <<= Cr, Dr -= Cr);
    for (; Lr.length & 7 && !Er; )
      Lr += "=";
    return Lr;
  }, toBits: function(_r, Er) {
    _r = _r.replace(/\s|=/g, "").toUpperCase();
    var xr = ar.codec.base32.BITS, Cr = ar.codec.base32.BASE, Ar = ar.codec.base32.REMAINING, Lr = [], Dr, Nr = 0, Hr = ar.codec.base32.B, $r = 0, Wr, Zr = "base32";
    for (Er && (Hr = ar.codec.base32.X, Zr = "base32hex"), Dr = 0; Dr < _r.length; Dr++) {
      if (Wr = Hr.indexOf(_r.charAt(Dr)), 0 > Wr) {
        if (!Er)
          try {
            return ar.codec.base32hex.toBits(_r);
          } catch (oi) {
          }
        throw new ar.exception.invalid("this isn't " + Zr + "!");
      }
      Nr > Ar ? (Nr -= Ar, Lr.push($r ^ Wr >>> Nr), $r = Wr << xr - Nr) : (Nr += Cr, $r ^= Wr << xr - Nr);
    }
    return Nr & 56 && Lr.push(ar.bitArray.partial(Nr & 56, $r, 1)), Lr;
  } }, ar.codec.base32hex = { fromBits: function(_r, Er) {
    return ar.codec.base32.fromBits(_r, Er, 1);
  }, toBits: function(_r) {
    return ar.codec.base32.toBits(_r, 1);
  } }, ar.codec.base64 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fromBits: function(_r, Er, xr) {
    var Cr = "", Ar = 0, Lr = ar.codec.base64.B, Dr = 0, Nr = ar.bitArray.bitLength(_r);
    for (xr && (Lr = Lr.substr(0, 62) + "-_"), xr = 0; 6 * Cr.length < Nr; )
      Cr += Lr.charAt((Dr ^ _r[xr] >>> Ar) >>> 26), 6 > Ar ? (Dr = _r[xr] << 6 - Ar, Ar += 26, xr++) : (Dr <<= 6, Ar -= 6);
    for (; Cr.length & 3 && !Er; )
      Cr += "=";
    return Cr;
  }, toBits: function(_r, Er) {
    _r = _r.replace(/\s|=/g, "");
    var xr = [], Cr, Ar = 0, Lr = ar.codec.base64.B, Dr = 0, Nr;
    for (Er && (Lr = Lr.substr(0, 62) + "-_"), Cr = 0; Cr < _r.length; Cr++) {
      if (Nr = Lr.indexOf(_r.charAt(Cr)), 0 > Nr)
        throw new ar.exception.invalid("this isn't base64!");
      26 < Ar ? (Ar -= 26, xr.push(Dr ^ Nr >>> Ar), Dr = Nr << 32 - Ar) : (Ar += 6, Dr ^= Nr << 32 - Ar);
    }
    return Ar & 56 && xr.push(ar.bitArray.partial(Ar & 56, Dr, 1)), xr;
  } }, ar.codec.base64url = { fromBits: function(_r) {
    return ar.codec.base64.fromBits(_r, 1, 1);
  }, toBits: function(_r) {
    return ar.codec.base64.toBits(_r, 1);
  } }, ar.hash.sha256 = function(_r) {
    this.b[0] || this.O(), _r ? (this.F = _r.F.slice(0), this.A = _r.A.slice(0), this.l = _r.l) : this.reset();
  }, ar.hash.sha256.hash = function(_r) {
    return new ar.hash.sha256().update(_r).finalize();
  }, ar.hash.sha256.prototype = { blockSize: 512, reset: function() {
    return this.F = this.Y.slice(0), this.A = [], this.l = 0, this;
  }, update: function(_r) {
    typeof _r == "string" && (_r = ar.codec.utf8String.toBits(_r));
    var Er, xr = this.A = ar.bitArray.concat(this.A, _r);
    if (Er = this.l, _r = this.l = Er + ar.bitArray.bitLength(_r), 9007199254740991 < _r)
      throw new ar.exception.invalid("Cannot hash more than 2^53 - 1 bits");
    if (typeof Uint32Array != "undefined") {
      var Cr = new Uint32Array(xr), Ar = 0;
      for (Er = 512 + Er - (512 + Er & 511); Er <= _r; Er += 512)
        ur(this, Cr.subarray(
          16 * Ar,
          16 * (Ar + 1)
        )), Ar += 1;
      xr.splice(0, 16 * Ar);
    } else
      for (Er = 512 + Er - (512 + Er & 511); Er <= _r; Er += 512)
        ur(this, xr.splice(0, 16));
    return this;
  }, finalize: function() {
    var _r, xr = this.A, Er = this.F, xr = ar.bitArray.concat(xr, [ar.bitArray.partial(1, 1)]);
    for (_r = xr.length + 2; _r & 15; _r++)
      xr.push(0);
    for (xr.push(Math.floor(this.l / 4294967296)), xr.push(this.l | 0); xr.length; )
      ur(this, xr.splice(0, 16));
    return this.reset(), Er;
  }, Y: [], b: [], O: function() {
    function _r(Lr) {
      return 4294967296 * (Lr - Math.floor(Lr)) | 0;
    }
    for (var Er = 0, xr = 2, Cr, Ar; 64 > Er; xr++) {
      for (Ar = !0, Cr = 2; Cr * Cr <= xr; Cr++)
        if (xr % Cr === 0) {
          Ar = !1;
          break;
        }
      Ar && (8 > Er && (this.Y[Er] = _r(Math.pow(xr, 0.5))), this.b[Er] = _r(Math.pow(xr, 1 / 3)), Er++);
    }
  } };
  function ur(_r, Er) {
    var xr, Cr, Ar, Lr = _r.F, Dr = _r.b, Nr = Lr[0], Hr = Lr[1], $r = Lr[2], Wr = Lr[3], Zr = Lr[4], oi = Lr[5], Jr = Lr[6], Yr = Lr[7];
    for (xr = 0; 64 > xr; xr++)
      16 > xr ? Cr = Er[xr] : (Cr = Er[xr + 1 & 15], Ar = Er[xr + 14 & 15], Cr = Er[xr & 15] = (Cr >>> 7 ^ Cr >>> 18 ^ Cr >>> 3 ^ Cr << 25 ^ Cr << 14) + (Ar >>> 17 ^ Ar >>> 19 ^ Ar >>> 10 ^ Ar << 15 ^ Ar << 13) + Er[xr & 15] + Er[xr + 9 & 15] | 0), Cr = Cr + Yr + (Zr >>> 6 ^ Zr >>> 11 ^ Zr >>> 25 ^ Zr << 26 ^ Zr << 21 ^ Zr << 7) + (Jr ^ Zr & (oi ^ Jr)) + Dr[xr], Yr = Jr, Jr = oi, oi = Zr, Zr = Wr + Cr | 0, Wr = $r, $r = Hr, Hr = Nr, Nr = Cr + (Hr & $r ^ Wr & (Hr ^ $r)) + (Hr >>> 2 ^ Hr >>> 13 ^ Hr >>> 22 ^ Hr << 30 ^ Hr << 19 ^ Hr << 10) | 0;
    Lr[0] = Lr[0] + Nr | 0, Lr[1] = Lr[1] + Hr | 0, Lr[2] = Lr[2] + $r | 0, Lr[3] = Lr[3] + Wr | 0, Lr[4] = Lr[4] + Zr | 0, Lr[5] = Lr[5] + oi | 0, Lr[6] = Lr[6] + Jr | 0, Lr[7] = Lr[7] + Yr | 0;
  }
  ar.mode.ccm = { name: "ccm", G: [], listenProgress: function(_r) {
    ar.mode.ccm.G.push(_r);
  }, unListenProgress: function(_r) {
    _r = ar.mode.ccm.G.indexOf(_r), -1 < _r && ar.mode.ccm.G.splice(_r, 1);
  }, fa: function(_r) {
    var Er = ar.mode.ccm.G.slice(), xr;
    for (xr = 0; xr < Er.length; xr += 1)
      Er[xr](_r);
  }, encrypt: function(_r, Er, xr, Cr, Ar) {
    var Lr, Dr = Er.slice(0), Nr = ar.bitArray, Hr = Nr.bitLength(xr) / 8, $r = Nr.bitLength(Dr) / 8;
    if (Ar = Ar || 64, Cr = Cr || [], 7 > Hr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Lr = 2; 4 > Lr && $r >>> 8 * Lr; Lr++)
      ;
    return Lr < 15 - Hr && (Lr = 15 - Hr), xr = Nr.clamp(
      xr,
      8 * (15 - Lr)
    ), Er = ar.mode.ccm.V(_r, Er, xr, Cr, Ar, Lr), Dr = ar.mode.ccm.C(_r, Dr, xr, Er, Ar, Lr), Nr.concat(Dr.data, Dr.tag);
  }, decrypt: function(_r, Er, xr, Cr, Ar) {
    Ar = Ar || 64, Cr = Cr || [];
    var Lr = ar.bitArray, Dr = Lr.bitLength(xr) / 8, $r = Lr.bitLength(Er), Nr = Lr.clamp(Er, $r - Ar), Hr = Lr.bitSlice(Er, $r - Ar), $r = ($r - Ar) / 8;
    if (7 > Dr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Er = 2; 4 > Er && $r >>> 8 * Er; Er++)
      ;
    if (Er < 15 - Dr && (Er = 15 - Dr), xr = Lr.clamp(xr, 8 * (15 - Er)), Nr = ar.mode.ccm.C(_r, Nr, xr, Hr, Ar, Er), _r = ar.mode.ccm.V(_r, Nr.data, xr, Cr, Ar, Er), !Lr.equal(Nr.tag, _r))
      throw new ar.exception.corrupt("ccm: tag doesn't match");
    return Nr.data;
  }, na: function(_r, Er, xr, Cr, Ar, Lr) {
    var Dr = [], Nr = ar.bitArray, Hr = Nr.i;
    if (Cr = [Nr.partial(8, (Er.length ? 64 : 0) | Cr - 2 << 2 | Lr - 1)], Cr = Nr.concat(Cr, xr), Cr[3] |= Ar, Cr = _r.encrypt(Cr), Er.length)
      for (xr = Nr.bitLength(Er) / 8, 65279 >= xr ? Dr = [Nr.partial(16, xr)] : 4294967295 >= xr && (Dr = Nr.concat([Nr.partial(16, 65534)], [xr])), Dr = Nr.concat(Dr, Er), Er = 0; Er < Dr.length; Er += 4)
        Cr = _r.encrypt(Hr(Cr, Dr.slice(Er, Er + 4).concat([0, 0, 0])));
    return Cr;
  }, V: function(_r, Er, xr, Cr, Ar, Lr) {
    var Dr = ar.bitArray, Nr = Dr.i;
    if (Ar /= 8, Ar % 2 || 4 > Ar || 16 < Ar)
      throw new ar.exception.invalid("ccm: invalid tag length");
    if (4294967295 < Cr.length || 4294967295 < Er.length)
      throw new ar.exception.bug("ccm: can't deal with 4GiB or more data");
    for (xr = ar.mode.ccm.na(_r, Cr, xr, Ar, Dr.bitLength(Er) / 8, Lr), Cr = 0; Cr < Er.length; Cr += 4)
      xr = _r.encrypt(Nr(xr, Er.slice(Cr, Cr + 4).concat([0, 0, 0])));
    return Dr.clamp(xr, 8 * Ar);
  }, C: function(_r, Er, xr, Cr, Ar, Lr) {
    var Dr, Nr = ar.bitArray;
    Dr = Nr.i;
    var Hr = Er.length, $r = Nr.bitLength(Er), Wr = Hr / 50, Zr = Wr;
    if (xr = Nr.concat([Nr.partial(8, Lr - 1)], xr).concat([0, 0, 0]).slice(0, 4), Cr = Nr.bitSlice(Dr(Cr, _r.encrypt(xr)), 0, Ar), !Hr)
      return { tag: Cr, data: [] };
    for (Dr = 0; Dr < Hr; Dr += 4)
      Dr > Wr && (ar.mode.ccm.fa(Dr / Hr), Wr += Zr), xr[3]++, Ar = _r.encrypt(xr), Er[Dr] ^= Ar[0], Er[Dr + 1] ^= Ar[1], Er[Dr + 2] ^= Ar[2], Er[Dr + 3] ^= Ar[3];
    return { tag: Cr, data: Nr.clamp(Er, $r) };
  } }, ar.mode.ocb2 = { name: "ocb2", encrypt: function(_r, Er, xr, Cr, Ar, Lr) {
    if (ar.bitArray.bitLength(xr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    var Dr, Nr = ar.mode.ocb2.S, Hr = ar.bitArray, $r = Hr.i, Wr = [0, 0, 0, 0];
    xr = Nr(_r.encrypt(xr));
    var Zr, oi = [];
    for (Cr = Cr || [], Ar = Ar || 64, Dr = 0; Dr + 4 < Er.length; Dr += 4)
      Zr = Er.slice(Dr, Dr + 4), Wr = $r(Wr, Zr), oi = oi.concat($r(xr, _r.encrypt($r(xr, Zr)))), xr = Nr(xr);
    return Zr = Er.slice(Dr), Er = Hr.bitLength(Zr), Dr = _r.encrypt($r(xr, [0, 0, 0, Er])), Zr = Hr.clamp($r(Zr.concat([0, 0, 0]), Dr), Er), Wr = $r(Wr, $r(Zr.concat([0, 0, 0]), Dr)), Wr = _r.encrypt($r(Wr, $r(xr, Nr(xr)))), Cr.length && (Wr = $r(Wr, Lr ? Cr : ar.mode.ocb2.pmac(_r, Cr))), oi.concat(Hr.concat(Zr, Hr.clamp(Wr, Ar)));
  }, decrypt: function(_r, Er, xr, Cr, Ar, Lr) {
    if (ar.bitArray.bitLength(xr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    Ar = Ar || 64;
    var Dr = ar.mode.ocb2.S, Nr = ar.bitArray, Hr = Nr.i, $r = [0, 0, 0, 0], Wr = Dr(_r.encrypt(xr)), Zr, oi, Jr = ar.bitArray.bitLength(Er) - Ar, Yr = [];
    for (Cr = Cr || [], xr = 0; xr + 4 < Jr / 32; xr += 4)
      Zr = Hr(Wr, _r.decrypt(Hr(Wr, Er.slice(xr, xr + 4)))), $r = Hr($r, Zr), Yr = Yr.concat(Zr), Wr = Dr(Wr);
    if (oi = Jr - 32 * xr, Zr = _r.encrypt(Hr(Wr, [0, 0, 0, oi])), Zr = Hr(Zr, Nr.clamp(Er.slice(xr), oi).concat([
      0,
      0,
      0
    ])), $r = Hr($r, Zr), $r = _r.encrypt(Hr($r, Hr(Wr, Dr(Wr)))), Cr.length && ($r = Hr($r, Lr ? Cr : ar.mode.ocb2.pmac(_r, Cr))), !Nr.equal(Nr.clamp($r, Ar), Nr.bitSlice(Er, Jr)))
      throw new ar.exception.corrupt("ocb: tag doesn't match");
    return Yr.concat(Nr.clamp(Zr, oi));
  }, pmac: function(_r, Er) {
    var xr, Cr = ar.mode.ocb2.S, Ar = ar.bitArray, Lr = Ar.i, Dr = [0, 0, 0, 0], Nr = _r.encrypt([0, 0, 0, 0]), Nr = Lr(Nr, Cr(Cr(Nr)));
    for (xr = 0; xr + 4 < Er.length; xr += 4)
      Nr = Cr(Nr), Dr = Lr(Dr, _r.encrypt(Lr(Nr, Er.slice(xr, xr + 4))));
    return xr = Er.slice(xr), 128 > Ar.bitLength(xr) && (Nr = Lr(Nr, Cr(Nr)), xr = Ar.concat(xr, [-2147483648, 0, 0, 0])), Dr = Lr(Dr, xr), _r.encrypt(Lr(Cr(Lr(Nr, Cr(Nr))), Dr));
  }, S: function(_r) {
    return [_r[0] << 1 ^ _r[1] >>> 31, _r[1] << 1 ^ _r[2] >>> 31, _r[2] << 1 ^ _r[3] >>> 31, _r[3] << 1 ^ 135 * (_r[0] >>> 31)];
  } }, ar.mode.gcm = { name: "gcm", encrypt: function(_r, Er, xr, Cr, Ar) {
    var Lr = Er.slice(0);
    return Er = ar.bitArray, Cr = Cr || [], _r = ar.mode.gcm.C(!0, _r, Lr, Cr, xr, Ar || 128), Er.concat(_r.data, _r.tag);
  }, decrypt: function(_r, Er, xr, Cr, Ar) {
    var Lr = Er.slice(0), Dr = ar.bitArray, Nr = Dr.bitLength(Lr);
    if (Ar = Ar || 128, Cr = Cr || [], Ar <= Nr ? (Er = Dr.bitSlice(Lr, Nr - Ar), Lr = Dr.bitSlice(Lr, 0, Nr - Ar)) : (Er = Lr, Lr = []), _r = ar.mode.gcm.C(!1, _r, Lr, Cr, xr, Ar), !Dr.equal(_r.tag, Er))
      throw new ar.exception.corrupt("gcm: tag doesn't match");
    return _r.data;
  }, ka: function(_r, Er) {
    var xr, Cr, Ar, Lr, Dr, Nr = ar.bitArray.i;
    for (Ar = [
      0,
      0,
      0,
      0
    ], Lr = Er.slice(0), xr = 0; 128 > xr; xr++) {
      for ((Cr = (_r[Math.floor(xr / 32)] & 1 << 31 - xr % 32) !== 0) && (Ar = Nr(Ar, Lr)), Dr = (Lr[3] & 1) !== 0, Cr = 3; 0 < Cr; Cr--)
        Lr[Cr] = Lr[Cr] >>> 1 | (Lr[Cr - 1] & 1) << 31;
      Lr[0] >>>= 1, Dr && (Lr[0] ^= -520093696);
    }
    return Ar;
  }, j: function(_r, Er, xr) {
    var Cr, Ar = xr.length;
    for (Er = Er.slice(0), Cr = 0; Cr < Ar; Cr += 4)
      Er[0] ^= 4294967295 & xr[Cr], Er[1] ^= 4294967295 & xr[Cr + 1], Er[2] ^= 4294967295 & xr[Cr + 2], Er[3] ^= 4294967295 & xr[Cr + 3], Er = ar.mode.gcm.ka(Er, _r);
    return Er;
  }, C: function(_r, Er, xr, Cr, Ar, Lr) {
    var Dr, Nr, Hr, $r, Wr, Zr, oi, Jr, Yr = ar.bitArray;
    for (Zr = xr.length, oi = Yr.bitLength(xr), Jr = Yr.bitLength(Cr), Nr = Yr.bitLength(Ar), Dr = Er.encrypt([0, 0, 0, 0]), Nr === 96 ? (Ar = Ar.slice(0), Ar = Yr.concat(Ar, [1])) : (Ar = ar.mode.gcm.j(Dr, [0, 0, 0, 0], Ar), Ar = ar.mode.gcm.j(Dr, Ar, [0, 0, Math.floor(Nr / 4294967296), Nr & 4294967295])), Nr = ar.mode.gcm.j(Dr, [0, 0, 0, 0], Cr), Wr = Ar.slice(0), Cr = Nr.slice(0), _r || (Cr = ar.mode.gcm.j(Dr, Nr, xr)), $r = 0; $r < Zr; $r += 4)
      Wr[3]++, Hr = Er.encrypt(Wr), xr[$r] ^= Hr[0], xr[$r + 1] ^= Hr[1], xr[$r + 2] ^= Hr[2], xr[$r + 3] ^= Hr[3];
    return xr = Yr.clamp(xr, oi), _r && (Cr = ar.mode.gcm.j(Dr, Nr, xr)), _r = [Math.floor(Jr / 4294967296), Jr & 4294967295, Math.floor(oi / 4294967296), oi & 4294967295], Cr = ar.mode.gcm.j(Dr, Cr, _r), Hr = Er.encrypt(Ar), Cr[0] ^= Hr[0], Cr[1] ^= Hr[1], Cr[2] ^= Hr[2], Cr[3] ^= Hr[3], { tag: Yr.bitSlice(Cr, 0, Lr), data: xr };
  } }, ar.misc.hmac = function(_r, Er) {
    this.W = Er = Er || ar.hash.sha256;
    var xr = [[], []], Cr, Ar = Er.prototype.blockSize / 32;
    for (this.w = [new Er(), new Er()], _r.length > Ar && (_r = Er.hash(_r)), Cr = 0; Cr < Ar; Cr++)
      xr[0][Cr] = _r[Cr] ^ 909522486, xr[1][Cr] = _r[Cr] ^ 1549556828;
    this.w[0].update(xr[0]), this.w[1].update(xr[1]), this.R = new Er(this.w[0]);
  }, ar.misc.hmac.prototype.encrypt = ar.misc.hmac.prototype.mac = function(_r) {
    if (this.aa)
      throw new ar.exception.invalid("encrypt on already updated hmac called!");
    return this.update(_r), this.digest(_r);
  }, ar.misc.hmac.prototype.reset = function() {
    this.R = new this.W(this.w[0]), this.aa = !1;
  }, ar.misc.hmac.prototype.update = function(_r) {
    this.aa = !0, this.R.update(_r);
  }, ar.misc.hmac.prototype.digest = function() {
    var _r = this.R.finalize(), _r = new this.W(this.w[1]).update(_r).finalize();
    return this.reset(), _r;
  }, ar.misc.pbkdf2 = function(_r, Er, xr, Cr, Ar) {
    if (xr = xr || 1e4, 0 > Cr || 0 > xr)
      throw new ar.exception.invalid("invalid params to pbkdf2");
    typeof _r == "string" && (_r = ar.codec.utf8String.toBits(_r)), typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er)), Ar = Ar || ar.misc.hmac, _r = new Ar(_r);
    var Lr, Dr, Nr, Hr, $r = [], Wr = ar.bitArray;
    for (Hr = 1; 32 * $r.length < (Cr || 1); Hr++) {
      for (Ar = Lr = _r.encrypt(Wr.concat(Er, [Hr])), Dr = 1; Dr < xr; Dr++)
        for (Lr = _r.encrypt(Lr), Nr = 0; Nr < Lr.length; Nr++)
          Ar[Nr] ^= Lr[Nr];
      $r = $r.concat(Ar);
    }
    return Cr && ($r = Wr.clamp($r, Cr)), $r;
  }, ar.prng = function(_r) {
    this.c = [new ar.hash.sha256()], this.m = [0], this.P = 0, this.H = {}, this.N = 0, this.U = {}, this.Z = this.f = this.o = this.ha = 0, this.b = [0, 0, 0, 0, 0, 0, 0, 0], this.h = [0, 0, 0, 0], this.L = void 0, this.M = _r, this.D = !1, this.K = { progress: {}, seeded: {} }, this.u = this.ga = 0, this.I = 1, this.J = 2, this.ca = 65536, this.T = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024], this.da = 3e4, this.ba = 80;
  }, ar.prng.prototype = {
    randomWords: function(_r, Er) {
      var xr = [], Cr;
      Cr = this.isReady(Er);
      var Ar;
      if (Cr === this.u)
        throw new ar.exception.notReady("generator isn't seeded");
      if (Cr & this.J) {
        Cr = !(Cr & this.I), Ar = [];
        var Lr = 0, Dr;
        for (this.Z = Ar[0] = (/* @__PURE__ */ new Date()).valueOf() + this.da, Dr = 0; 16 > Dr; Dr++)
          Ar.push(4294967296 * Math.random() | 0);
        for (Dr = 0; Dr < this.c.length && (Ar = Ar.concat(this.c[Dr].finalize()), Lr += this.m[Dr], this.m[Dr] = 0, Cr || !(this.P & 1 << Dr)); Dr++)
          ;
        for (this.P >= 1 << this.c.length && (this.c.push(new ar.hash.sha256()), this.m.push(0)), this.f -= Lr, Lr > this.o && (this.o = Lr), this.P++, this.b = ar.hash.sha256.hash(this.b.concat(Ar)), this.L = new ar.cipher.aes(this.b), Cr = 0; 4 > Cr && (this.h[Cr] = this.h[Cr] + 1 | 0, !this.h[Cr]); Cr++)
          ;
      }
      for (Cr = 0; Cr < _r; Cr += 4)
        (Cr + 1) % this.ca === 0 && hr(this), Ar = gr(this), xr.push(Ar[0], Ar[1], Ar[2], Ar[3]);
      return hr(this), xr.slice(0, _r);
    },
    setDefaultParanoia: function(_r, Er) {
      if (_r === 0 && Er !== "Setting paranoia=0 will ruin your security; use it only for testing")
        throw new ar.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
      this.M = _r;
    },
    addEntropy: function(_r, Er, xr) {
      xr = xr || "user";
      var Cr, Ar, Lr = (/* @__PURE__ */ new Date()).valueOf(), Dr = this.H[xr], Nr = this.isReady(), Hr = 0;
      switch (Cr = this.U[xr], Cr === void 0 && (Cr = this.U[xr] = this.ha++), Dr === void 0 && (Dr = this.H[xr] = 0), this.H[xr] = (this.H[xr] + 1) % this.c.length, typeof _r) {
        case "number":
          Er === void 0 && (Er = 1), this.c[Dr].update([Cr, this.N++, 1, Er, Lr, 1, _r | 0]);
          break;
        case "object":
          if (xr = Object.prototype.toString.call(_r), xr === "[object Uint32Array]") {
            for (Ar = [], xr = 0; xr < _r.length; xr++)
              Ar.push(_r[xr]);
            _r = Ar;
          } else
            for (xr !== "[object Array]" && (Hr = 1), xr = 0; xr < _r.length && !Hr; xr++)
              typeof _r[xr] != "number" && (Hr = 1);
          if (!Hr) {
            if (Er === void 0)
              for (xr = Er = 0; xr < _r.length; xr++)
                for (Ar = _r[xr]; 0 < Ar; )
                  Er++, Ar = Ar >>> 1;
            this.c[Dr].update([Cr, this.N++, 2, Er, Lr, _r.length].concat(_r));
          }
          break;
        case "string":
          Er === void 0 && (Er = _r.length), this.c[Dr].update([Cr, this.N++, 3, Er, Lr, _r.length]), this.c[Dr].update(_r);
          break;
        default:
          Hr = 1;
      }
      if (Hr)
        throw new ar.exception.bug("random: addEntropy only supports number, array of numbers or string");
      this.m[Dr] += Er, this.f += Er, Nr === this.u && (this.isReady() !== this.u && fr("seeded", Math.max(this.o, this.f)), fr("progress", this.getProgress()));
    },
    isReady: function(_r) {
      return _r = this.T[_r !== void 0 ? _r : this.M], this.o && this.o >= _r ? this.m[0] > this.ba && (/* @__PURE__ */ new Date()).valueOf() > this.Z ? this.J | this.I : this.I : this.f >= _r ? this.J | this.u : this.u;
    },
    getProgress: function(_r) {
      return _r = this.T[_r || this.M], this.o >= _r || this.f > _r ? 1 : this.f / _r;
    },
    startCollectors: function() {
      if (!this.D) {
        if (this.a = { loadTimeCollector: vr(this, this.ma), mouseCollector: vr(this, this.oa), keyboardCollector: vr(this, this.la), accelerometerCollector: vr(this, this.ea), touchCollector: vr(this, this.qa) }, window.addEventListener)
          window.addEventListener(
            "load",
            this.a.loadTimeCollector,
            !1
          ), window.addEventListener("mousemove", this.a.mouseCollector, !1), window.addEventListener("keypress", this.a.keyboardCollector, !1), window.addEventListener("devicemotion", this.a.accelerometerCollector, !1), window.addEventListener("touchmove", this.a.touchCollector, !1);
        else if (document.attachEvent)
          document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector);
        else
          throw new ar.exception.bug("can't attach event");
        this.D = !0;
      }
    },
    stopCollectors: function() {
      this.D && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, !1), window.removeEventListener("mousemove", this.a.mouseCollector, !1), window.removeEventListener("keypress", this.a.keyboardCollector, !1), window.removeEventListener("devicemotion", this.a.accelerometerCollector, !1), window.removeEventListener("touchmove", this.a.touchCollector, !1)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent(
        "onmousemove",
        this.a.mouseCollector
      ), document.detachEvent("keypress", this.a.keyboardCollector)), this.D = !1);
    },
    addEventListener: function(_r, Er) {
      this.K[_r][this.ga++] = Er;
    },
    removeEventListener: function(_r, Er) {
      var xr, Cr, Ar = this.K[_r], Lr = [];
      for (Cr in Ar)
        Ar.hasOwnProperty(Cr) && Ar[Cr] === Er && Lr.push(Cr);
      for (xr = 0; xr < Lr.length; xr++)
        Cr = Lr[xr], delete Ar[Cr];
    },
    la: function() {
      dr(this, 1);
    },
    oa: function(_r) {
      var Er, xr;
      try {
        Er = _r.x || _r.clientX || _r.offsetX || 0, xr = _r.y || _r.clientY || _r.offsetY || 0;
      } catch (Cr) {
        xr = Er = 0;
      }
      Er != 0 && xr != 0 && this.addEntropy([Er, xr], 2, "mouse"), dr(this, 0);
    },
    qa: function(_r) {
      _r = _r.touches[0] || _r.changedTouches[0], this.addEntropy([_r.pageX || _r.clientX, _r.pageY || _r.clientY], 1, "touch"), dr(this, 0);
    },
    ma: function() {
      dr(this, 2);
    },
    ea: function(_r) {
      if (_r = _r.accelerationIncludingGravity.x || _r.accelerationIncludingGravity.y || _r.accelerationIncludingGravity.z, window.orientation) {
        var Er = window.orientation;
        typeof Er == "number" && this.addEntropy(Er, 1, "accelerometer");
      }
      _r && this.addEntropy(_r, 2, "accelerometer"), dr(this, 0);
    }
  };
  function fr(_r, Er) {
    var xr, Cr = ar.random.K[_r], Ar = [];
    for (xr in Cr)
      Cr.hasOwnProperty(xr) && Ar.push(Cr[xr]);
    for (xr = 0; xr < Ar.length; xr++)
      Ar[xr](Er);
  }
  function dr(_r, Er) {
    typeof window != "undefined" && window.performance && typeof window.performance.now == "function" ? _r.addEntropy(window.performance.now(), Er, "loadtime") : _r.addEntropy((/* @__PURE__ */ new Date()).valueOf(), Er, "loadtime");
  }
  function hr(_r) {
    _r.b = gr(_r).concat(gr(_r)), _r.L = new ar.cipher.aes(_r.b);
  }
  function gr(_r) {
    for (var Er = 0; 4 > Er && (_r.h[Er] = _r.h[Er] + 1 | 0, !_r.h[Er]); Er++)
      ;
    return _r.L.encrypt(_r.h);
  }
  function vr(_r, Er) {
    return function() {
      Er.apply(_r, arguments);
    };
  }
  ar.random = new ar.prng(6);
  e:
    try {
      var mr, br, yr, kr;
      if (kr = lr.exports) {
        var Tr;
        try {
          Tr = require$$0;
        } catch (_r) {
          Tr = null;
        }
        kr = br = Tr;
      }
      if (kr && br.randomBytes)
        mr = br.randomBytes(128), mr = new Uint32Array(new Uint8Array(mr).buffer), ar.random.addEntropy(mr, 1024, "crypto['randomBytes']");
      else if (typeof window != "undefined" && typeof Uint32Array != "undefined") {
        if (yr = new Uint32Array(32), window.crypto && window.crypto.getRandomValues)
          window.crypto.getRandomValues(yr);
        else if (window.msCrypto && window.msCrypto.getRandomValues)
          window.msCrypto.getRandomValues(yr);
        else
          break e;
        ar.random.addEntropy(yr, 1024, "crypto['getRandomValues']");
      }
    } catch (_r) {
      typeof window != "undefined" && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(_r));
    }
  ar.json = { defaults: { v: 1, iter: 1e4, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes" }, ja: function(_r, Er, xr, Cr) {
    xr = xr || {}, Cr = Cr || {};
    var Ar = ar.json, Lr = Ar.g({ iv: ar.random.randomWords(4, 0) }, Ar.defaults), Dr;
    if (Ar.g(Lr, xr), xr = Lr.adata, typeof Lr.salt == "string" && (Lr.salt = ar.codec.base64.toBits(Lr.salt)), typeof Lr.iv == "string" && (Lr.iv = ar.codec.base64.toBits(Lr.iv)), !ar.mode[Lr.mode] || !ar.cipher[Lr.cipher] || typeof _r == "string" && 100 >= Lr.iter || Lr.ts !== 64 && Lr.ts !== 96 && Lr.ts !== 128 || Lr.ks !== 128 && Lr.ks !== 192 && Lr.ks !== 256 || 2 > Lr.iv.length || 4 < Lr.iv.length)
      throw new ar.exception.invalid("json encrypt: invalid parameters");
    return typeof _r == "string" ? (Dr = ar.misc.cachedPbkdf2(_r, Lr), _r = Dr.key.slice(0, Lr.ks / 32), Lr.salt = Dr.salt) : ar.ecc && _r instanceof ar.ecc.elGamal.publicKey && (Dr = _r.kem(), Lr.kemtag = Dr.tag, _r = Dr.key.slice(0, Lr.ks / 32)), typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er)), typeof xr == "string" && (Lr.adata = xr = ar.codec.utf8String.toBits(xr)), Dr = new ar.cipher[Lr.cipher](_r), Ar.g(Cr, Lr), Cr.key = _r, Lr.ct = Lr.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Er instanceof ArrayBuffer ? ar.arrayBuffer.ccm.encrypt(Dr, Er, Lr.iv, xr, Lr.ts) : ar.mode[Lr.mode].encrypt(Dr, Er, Lr.iv, xr, Lr.ts), Lr;
  }, encrypt: function(_r, Er, xr, Cr) {
    var Ar = ar.json, Lr = Ar.ja.apply(Ar, arguments);
    return Ar.encode(Lr);
  }, ia: function(_r, Er, xr, Cr) {
    xr = xr || {}, Cr = Cr || {};
    var Ar = ar.json;
    Er = Ar.g(Ar.g(Ar.g({}, Ar.defaults), Er), xr, !0);
    var Lr, Dr;
    if (Lr = Er.adata, typeof Er.salt == "string" && (Er.salt = ar.codec.base64.toBits(Er.salt)), typeof Er.iv == "string" && (Er.iv = ar.codec.base64.toBits(Er.iv)), !ar.mode[Er.mode] || !ar.cipher[Er.cipher] || typeof _r == "string" && 100 >= Er.iter || Er.ts !== 64 && Er.ts !== 96 && Er.ts !== 128 || Er.ks !== 128 && Er.ks !== 192 && Er.ks !== 256 || !Er.iv || 2 > Er.iv.length || 4 < Er.iv.length)
      throw new ar.exception.invalid("json decrypt: invalid parameters");
    return typeof _r == "string" ? (Dr = ar.misc.cachedPbkdf2(_r, Er), _r = Dr.key.slice(0, Er.ks / 32), Er.salt = Dr.salt) : ar.ecc && _r instanceof ar.ecc.elGamal.secretKey && (_r = _r.unkem(ar.codec.base64.toBits(Er.kemtag)).slice(0, Er.ks / 32)), typeof Lr == "string" && (Lr = ar.codec.utf8String.toBits(Lr)), Dr = new ar.cipher[Er.cipher](_r), Lr = Er.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Er.ct instanceof ArrayBuffer ? ar.arrayBuffer.ccm.decrypt(Dr, Er.ct, Er.iv, Er.tag, Lr, Er.ts) : ar.mode[Er.mode].decrypt(Dr, Er.ct, Er.iv, Lr, Er.ts), Ar.g(Cr, Er), Cr.key = _r, xr.raw === 1 ? Lr : ar.codec.utf8String.fromBits(Lr);
  }, decrypt: function(_r, Er, xr, Cr) {
    var Ar = ar.json;
    return Ar.ia(_r, Ar.decode(Er), xr, Cr);
  }, encode: function(_r) {
    var Er, xr = "{", Cr = "";
    for (Er in _r)
      if (_r.hasOwnProperty(Er)) {
        if (!Er.match(/^[a-z0-9]+$/i))
          throw new ar.exception.invalid("json encode: invalid property name");
        switch (xr += Cr + '"' + Er + '":', Cr = ",", typeof _r[Er]) {
          case "number":
          case "boolean":
            xr += _r[Er];
            break;
          case "string":
            xr += '"' + escape(_r[Er]) + '"';
            break;
          case "object":
            xr += '"' + ar.codec.base64.fromBits(_r[Er], 0) + '"';
            break;
          default:
            throw new ar.exception.bug("json encode: unsupported type");
        }
      }
    return xr + "}";
  }, decode: function(_r) {
    if (_r = _r.replace(/\s/g, ""), !_r.match(/^\{.*\}$/))
      throw new ar.exception.invalid("json decode: this isn't json!");
    _r = _r.replace(/^\{|\}$/g, "").split(/,/);
    var Er = {}, xr, Cr;
    for (xr = 0; xr < _r.length; xr++) {
      if (!(Cr = _r[xr].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))
        throw new ar.exception.invalid("json decode: this isn't json!");
      Cr[3] != null ? Er[Cr[2]] = parseInt(Cr[3], 10) : Cr[4] != null ? Er[Cr[2]] = Cr[2].match(/^(ct|adata|salt|iv)$/) ? ar.codec.base64.toBits(Cr[4]) : unescape(Cr[4]) : Cr[5] != null && (Er[Cr[2]] = Cr[5] === "true");
    }
    return Er;
  }, g: function(_r, Er, xr) {
    if (_r === void 0 && (_r = {}), Er === void 0)
      return _r;
    for (var Cr in Er)
      if (Er.hasOwnProperty(Cr)) {
        if (xr && _r[Cr] !== void 0 && _r[Cr] !== Er[Cr])
          throw new ar.exception.invalid("required parameter overridden");
        _r[Cr] = Er[Cr];
      }
    return _r;
  }, sa: function(_r, Er) {
    var xr = {}, Cr;
    for (Cr in _r)
      _r.hasOwnProperty(Cr) && _r[Cr] !== Er[Cr] && (xr[Cr] = _r[Cr]);
    return xr;
  }, ra: function(_r, Er) {
    var xr = {}, Cr;
    for (Cr = 0; Cr < Er.length; Cr++)
      _r[Er[Cr]] !== void 0 && (xr[Er[Cr]] = _r[Er[Cr]]);
    return xr;
  } }, ar.encrypt = ar.json.encrypt, ar.decrypt = ar.json.decrypt, ar.misc.pa = {}, ar.misc.cachedPbkdf2 = function(_r, Er) {
    var xr = ar.misc.pa, Cr;
    return Er = Er || {}, Cr = Er.iter || 1e3, xr = xr[_r] = xr[_r] || {}, Cr = xr[Cr] = xr[Cr] || { firstSalt: Er.salt && Er.salt.length ? Er.salt.slice(0) : ar.random.randomWords(2, 0) }, xr = Er.salt === void 0 ? Cr.firstSalt : Er.salt, Cr[xr] = Cr[xr] || ar.misc.pbkdf2(_r, xr, Er.iter), { key: Cr[xr].slice(0), salt: xr.slice(0) };
  }, lr.exports && (lr.exports = ar);
})(sjcl);
var sjclExports = sjcl.exports, codecBytes = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(codecBytes, "__esModule", { value: !0 });
codecBytes.sjclcodec = void 0;
const sjcl_1$1 = __importDefault$1(sjclExports);
codecBytes.sjclcodec = {
  /** Convert from a bitArray to an array of bytes. */
  fromBits: function(lr) {
    var ar = [], cr = sjcl_1$1.default.bitArray.bitLength(lr), ur, fr;
    for (ur = 0; ur < cr / 8; ur++)
      ur & 3 || (fr = lr[ur / 4]), ar.push(fr >>> 24), fr <<= 8;
    return ar;
  },
  /** Convert from an array of bytes to a bitArray. */
  /** @return {bitArray} */
  toBits: function(lr) {
    var ar = [], cr, ur = 0;
    for (cr = 0; cr < lr.length; cr++)
      ur = ur << 8 | lr[cr], (cr & 3) === 3 && (ar.push(ur), ur = 0);
    return cr & 3 && ar.push(sjcl_1$1.default.bitArray.partial(8 * (cr & 3), ur)), ar;
  }
};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: !0 });
utils.buf2hex = void 0;
function buf2hex(lr) {
  return [...new Uint8Array(lr)].map((ar) => ar.toString(16).padStart(2, "0")).join("");
}
utils.buf2hex = buf2hex;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(hr) {
    return hr && hr.__esModule ? hr : { default: hr };
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.VoidUploader = lr.UploadState = void 0;
  const cr = ar(sjclExports), ur = codecBytes, fr = utils;
  (function(hr) {
    hr[hr.NotStarted = 0] = "NotStarted", hr[hr.Starting = 1] = "Starting", hr[hr.Hashing = 2] = "Hashing", hr[hr.Uploading = 3] = "Uploading", hr[hr.Done = 4] = "Done", hr[hr.Failed = 5] = "Failed", hr[hr.Challenge = 6] = "Challenge";
  })(lr.UploadState || (lr.UploadState = {}));
  class dr {
    constructor(gr, vr, mr, br, yr, kr, Tr) {
      Wi(this, "uri");
      Wi(this, "file");
      Wi(this, "auth");
      Wi(this, "maxChunkSize");
      Wi(this, "onStateChange");
      Wi(this, "onProgress");
      Wi(this, "onProxyChallenge");
      this.uri = gr, this.file = vr, this.onStateChange = mr, this.onProgress = br, this.onProxyChallenge = yr, this.auth = kr, this.maxChunkSize = Tr != null ? Tr : Number.MAX_VALUE;
    }
    /**
     * SHA-256 hash the entire blob
     * @param file
     * @protected
     */
    async digest(gr) {
      var yr;
      const mr = new cr.default.hash.sha256();
      let br = 0;
      for (let kr = 0; kr < Math.ceil(gr.size / 1048576); kr++) {
        const Tr = kr * 1048576, Er = await gr.slice(Tr, Tr + 1048576).arrayBuffer();
        mr.update(ur.sjclcodec.toBits(new Uint8Array(Er))), (yr = this.onProgress) == null || yr.call(this, br += Er.byteLength);
      }
      return (0, fr.buf2hex)(ur.sjclcodec.fromBits(mr.finalize()));
    }
  }
  lr.VoidUploader = dr;
})(upload);
var streamEncryption = {}, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(streamEncryption, "__esModule", { value: !0 });
streamEncryption.StreamEncryption = void 0;
const codecBytes_1 = codecBytes, sjcl_1 = __importDefault(sjclExports), utils_1 = utils;
var Qo, Ps, Hs, Nl, ls;
class StreamEncryption {
  constructor(ar, cr, ur) {
    Zo(this, Qo, void 0);
    Zo(this, Ps, void 0);
    Zo(this, Hs, void 0);
    Zo(this, Nl, void 0);
    Zo(this, ls, void 0);
    var fr, dr;
    if (!ar && !cr && (ar = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(16))), cr = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(12)))), typeof ar == "string" && typeof cr == "string")
      ar = sjcl_1.default.codec.hex.toBits(ar), cr = sjcl_1.default.codec.hex.toBits(cr);
    else if (!Array.isArray(ar) || !Array.isArray(cr))
      throw "Key and IV must be hex string or bitArray";
    typeof ur == "string" && (ur = JSON.parse(ur)), ss(this, Qo, (fr = ur == null ? void 0 : ur.ts) != null ? fr : 128), ss(this, Ps, (dr = ur == null ? void 0 : ur.cs) != null ? dr : 1024 * 1024 * 10), ss(this, Hs, new sjcl_1.default.cipher.aes(ar)), ss(this, Nl, ar), ss(this, ls, cr), console.log(`ts=${Ya(this, Qo)}, cs=${Ya(this, Ps)}, key=${ar}, iv=${Ya(this, ls)}`);
  }
  /**
   * Return formatted encryption key
   */
  getKey() {
    return `${sjcl_1.default.codec.hex.fromBits(Ya(this, Nl))}:${sjcl_1.default.codec.hex.fromBits(Ya(this, ls))}`;
  }
  /**
   * Get encryption params
   */
  getParams() {
    return {
      ts: Ya(this, Qo),
      cs: Ya(this, Ps)
    };
  }
  /**
   * Get encryption TransformStream
   */
  getEncryptionTransform() {
    return this._getCryptoStream(0);
  }
  /**
   * Get decryption TransformStream
   */
  getDecryptionTransform() {
    return this._getCryptoStream(1);
  }
  _getCryptoStream(ar) {
    let cr = 0, ur = new Uint8Array(Ya(this, Ps) + (ar === 1 ? Ya(this, Qo) / 8 : 0));
    return new TransformStream({
      transform: async (fr, dr) => {
        fr = await fr;
        try {
          let hr = Math.min(fr.byteLength, ur.byteLength - cr);
          if (ur.set(fr.slice(0, hr), cr), cr += hr, cr === ur.byteLength) {
            let gr = codecBytes_1.sjclcodec.toBits(ur), vr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(Ya(this, Hs), gr, Ya(this, ls), [], Ya(this, Qo)) : sjcl_1.default.mode.gcm.decrypt(Ya(this, Hs), gr, Ya(this, ls), [], Ya(this, Qo)));
            dr.enqueue(new Uint8Array(vr)), cr = fr.byteLength - hr, ur.set(fr.slice(hr));
          }
        } catch (hr) {
          throw console.error(hr), hr;
        }
      },
      flush: (fr) => {
        let dr = ur.slice(0, cr), hr = codecBytes_1.sjclcodec.toBits(dr), gr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(Ya(this, Hs), hr, Ya(this, ls), [], Ya(this, Qo)) : sjcl_1.default.mode.gcm.decrypt(Ya(this, Hs), hr, Ya(this, ls), [], Ya(this, Qo)));
        fr.enqueue(new Uint8Array(gr));
      }
    }, {
      highWaterMark: Ya(this, Ps)
    });
  }
}
Qo = new WeakMap(), Ps = new WeakMap(), Hs = new WeakMap(), Nl = new WeakMap(), ls = new WeakMap();
streamEncryption.StreamEncryption = StreamEncryption;
Object.defineProperty(streamUploader, "__esModule", { value: !0 });
streamUploader.StreamUploader = void 0;
const upload_1$1 = upload, stream_encryption_1 = streamEncryption;
var cs;
class StreamUploader extends upload_1$1.VoidUploader {
  constructor() {
    super(...arguments);
    Zo(this, cs, void 0);
  }
  static canUse() {
    const cr = globalThis.navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    return (cr ? parseInt(cr[2], 10) : 0) >= 105 && "getRandomValues" in globalThis.crypto && globalThis.location.protocol === "https:";
  }
  canEncrypt() {
    return !0;
  }
  setEncryption(cr) {
    cr ? ss(this, cs, new stream_encryption_1.StreamEncryption(void 0, void 0, void 0)) : ss(this, cs, void 0);
  }
  getEncryptionKey() {
    var cr;
    return (cr = Ya(this, cs)) == null ? void 0 : cr.getKey();
  }
  async upload(cr) {
    var br;
    (br = this.onStateChange) == null || br.call(this, upload_1$1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    let fr = 0;
    const dr = 1024 * 1024, hr = new ReadableStream({
      start: async () => {
        var yr;
        (yr = this.onStateChange) == null || yr.call(this, upload_1$1.UploadState.Uploading);
      },
      pull: async (yr) => {
        var Tr, _r;
        const kr = await this.readChunk(fr, (Tr = yr.desiredSize) != null ? Tr : dr);
        if (kr.byteLength === 0) {
          yr.close();
          return;
        }
        (_r = this.onProgress) == null || _r.call(this, fr + kr.byteLength), fr += kr.byteLength, yr.enqueue(kr);
      },
      cancel: (yr) => {
        console.log(yr);
      },
      type: "bytes"
    }, {
      highWaterMark: dr
    }), gr = `${this.uri}/upload`, vr = {
      "Content-Type": "application/octet-stream",
      "V-Content-Type": this.file.type ? this.file.type : "application/octet-stream",
      "V-Filename": "name" in this.file ? this.file.name : "",
      "V-Full-Digest": ur
    };
    Ya(this, cs) && (vr["V-EncryptionParams"] = JSON.stringify(Ya(this, cs).getParams())), this.auth && (vr.Authorization = await this.auth(gr, "POST"));
    const mr = await fetch(gr, {
      method: "POST",
      mode: "cors",
      body: Ya(this, cs) ? hr.pipeThrough(Ya(this, cs).getEncryptionTransform()) : hr,
      headers: {
        ...vr,
        ...cr
      },
      // @ts-ignore New stream spec
      duplex: "half"
    });
    if (mr.ok)
      return await mr.json();
    throw new Error("Unknown error");
  }
  async readChunk(cr, ur) {
    if (cr > this.file.size)
      return new Uint8Array(0);
    const fr = Math.min(cr + ur, this.file.size), hr = await this.file.slice(cr, fr, this.file.type).arrayBuffer();
    return new Uint8Array(hr);
  }
}
cs = new WeakMap();
streamUploader.StreamUploader = StreamUploader;
var xhrUploader = {};
Object.defineProperty(xhrUploader, "__esModule", { value: !0 });
xhrUploader.XHRUploader = void 0;
const upload_1 = upload;
var xc, yd, Ol, Gu;
class XHRUploader extends upload_1.VoidUploader {
  constructor() {
    super(...arguments);
    Zo(this, xc);
    /**
     * Upload a segment of the file
     * @param segment
     * @param fullDigest Full file hash
     * @param id
     * @param editSecret
     * @param part Segment number
     * @param partOf Total number of segments
     * @param headers
     */
    Zo(this, Ol);
  }
  canEncrypt() {
    return !1;
  }
  setEncryption() {
  }
  getEncryptionKey() {
  }
  async upload(cr) {
    var fr;
    (fr = this.onStateChange) == null || fr.call(this, upload_1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    return this.file.size > this.maxChunkSize ? await go(this, xc, yd).call(this, ur, this.maxChunkSize, cr) : await go(this, Ol, Gu).call(this, this.file, ur, void 0, void 0, 1, 1, cr);
  }
}
xc = new WeakSet(), yd = async function(cr, ur, fr) {
  var gr, vr, mr;
  let dr = null;
  const hr = Math.ceil(this.file.size / ur);
  for (let br = 0; br < hr; br++) {
    const yr = br * ur, kr = this.file.slice(yr, yr + ur, this.file.type);
    if (dr = await go(this, Ol, Gu).call(this, kr, cr, (gr = dr == null ? void 0 : dr.file) == null ? void 0 : gr.id, (mr = (vr = dr == null ? void 0 : dr.file) == null ? void 0 : vr.metadata) == null ? void 0 : mr.editSecret, br + 1, hr, fr), !dr.ok)
      break;
  }
  return dr;
}, Ol = new WeakSet(), Gu = async function(cr, ur, fr, dr, hr, gr, vr) {
  var yr;
  (yr = this.onStateChange) == null || yr.call(this, upload_1.UploadState.Uploading);
  const mr = fr ? `${this.uri}/upload/${fr}` : `${this.uri}/upload`, br = this.auth ? await this.auth(mr, "POST") : void 0;
  return await new Promise((kr, Tr) => {
    try {
      const _r = new XMLHttpRequest();
      if (_r.onreadystatechange = () => {
        var Er, xr;
        if (_r.readyState === XMLHttpRequest.DONE && _r.status === 200) {
          const Cr = JSON.parse(_r.responseText);
          kr(Cr);
        } else if (_r.readyState === XMLHttpRequest.DONE && _r.status === 403) {
          const Cr = _r.getResponseHeader("content-type");
          (Cr == null ? void 0 : Cr.toLowerCase().trim().indexOf("text/html")) === 0 && ((Er = this.onProxyChallenge) == null || Er.call(this, _r.response), (xr = this.onStateChange) == null || xr.call(this, upload_1.UploadState.Challenge), Tr(new Error("CF Challenge")));
        }
      }, _r.upload.onprogress = (Er) => {
        var xr;
        Er instanceof ProgressEvent && ((xr = this.onProgress) == null || xr.call(this, Er.loaded));
      }, _r.open("POST", mr), _r.setRequestHeader("Content-Type", "application/octet-stream"), _r.setRequestHeader("V-Content-Type", this.file.type ? this.file.type : "application/octet-stream"), _r.setRequestHeader("V-Filename", "name" in this.file ? this.file.name : ""), _r.setRequestHeader("V-Full-Digest", ur), _r.setRequestHeader("V-Segment", `${hr}/${gr}`), br && (_r.withCredentials = !0, _r.setRequestHeader("Authorization", br)), dr && _r.setRequestHeader("V-EditSecret", dr), vr)
        for (const [Er, xr] of Object.entries(vr))
          _r.setRequestHeader(Er, xr);
      _r.send(cr);
    } catch (_r) {
      Tr(_r);
    }
  });
};
xhrUploader.XHRUploader = XHRUploader;
var hasRequiredApi;
function requireApi() {
  var fr, dr, hr, wo;
  if (hasRequiredApi)
    return api;
  hasRequiredApi = 1, Object.defineProperty(api, "__esModule", { value: !0 }), api.VoidApi = void 0;
  const lr = requireDist(), ar = streamUploader, cr = xhrUploader;
  class ur {
    constructor(mr, br) {
      Zo(this, hr);
      Zo(this, fr, void 0);
      Zo(this, dr, void 0);
      ss(this, fr, mr), ss(this, dr, br);
    }
    /**
     * Get uploader for uploading files
     */
    getUploader(mr, br, yr, kr, Tr) {
      return ar.StreamUploader.canUse() ? new ar.StreamUploader(Ya(this, fr), mr, br, yr, kr, Ya(this, dr), Tr) : new cr.XHRUploader(Ya(this, fr), mr, br, yr, kr, Ya(this, dr), Tr);
    }
    /**
     * General site information
     */
    info() {
      return go(this, hr, wo).call(this, "GET", "/info");
    }
    fileInfo(mr) {
      return go(this, hr, wo).call(this, "GET", `/upload/${mr}`);
    }
    setPaymentConfig(mr, br) {
      return go(this, hr, wo).call(this, "POST", `/upload/${mr}/payment`, br);
    }
    createOrder(mr) {
      return go(this, hr, wo).call(this, "GET", `/upload/${mr}/payment`);
    }
    getOrder(mr, br) {
      return go(this, hr, wo).call(this, "GET", `/upload/${mr}/payment/${br}`);
    }
    login(mr, br, yr) {
      return go(this, hr, wo).call(this, "POST", "/auth/login", {
        username: mr,
        password: br,
        captcha: yr
      });
    }
    register(mr, br, yr) {
      return go(this, hr, wo).call(this, "POST", "/auth/register", {
        username: mr,
        password: br,
        captcha: yr
      });
    }
    getUser(mr) {
      return go(this, hr, wo).call(this, "GET", `/user/${mr}`);
    }
    updateUser(mr) {
      return go(this, hr, wo).call(this, "POST", `/user/${mr.id}`, mr);
    }
    listUserFiles(mr, br) {
      return go(this, hr, wo).call(this, "POST", `/user/${mr}/files`, br);
    }
    submitVerifyCode(mr, br) {
      return go(this, hr, wo).call(this, "POST", `/user/${mr}/verify`, { code: br });
    }
    sendNewCode(mr) {
      return go(this, hr, wo).call(this, "GET", `/user/${mr}/verify`);
    }
    updateFileMetadata(mr, br) {
      return go(this, hr, wo).call(this, "POST", `/upload/${mr}/meta`, br);
    }
    listApiKeys() {
      return go(this, hr, wo).call(this, "GET", "/auth/api-key");
    }
    createApiKey(mr) {
      return go(this, hr, wo).call(this, "POST", "/auth/api-key", mr);
    }
    adminListFiles(mr) {
      return go(this, hr, wo).call(this, "POST", "/admin/file", mr);
    }
    adminDeleteFile(mr) {
      return go(this, hr, wo).call(this, "DELETE", `/admin/file/${mr}`);
    }
    adminUserList(mr) {
      return go(this, hr, wo).call(this, "POST", "/admin/users", mr);
    }
    adminUpdateUser(mr) {
      return go(this, hr, wo).call(this, "POST", "/admin/update-user", mr);
    }
  }
  return fr = new WeakMap(), dr = new WeakMap(), hr = new WeakSet(), wo = async function(mr, br, yr) {
    const kr = `${Ya(this, fr)}${br}`, Tr = {
      Accept: "application/json"
    };
    Ya(this, dr) && (Tr.Authorization = await Ya(this, dr).call(this, kr, mr)), yr && (Tr["Content-Type"] = "application/json");
    const _r = await fetch(kr, {
      method: mr,
      headers: Tr,
      mode: "cors",
      body: yr ? JSON.stringify(yr) : void 0
    }), Er = await _r.text();
    if (_r.ok)
      return Er ? JSON.parse(Er) : {};
    throw new lr.ApiError(_r.status, Er);
  }, api.VoidApi = ur, api;
}
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(lr) {
    Object.defineProperty(lr, "__esModule", { value: !0 }), lr.PageSortOrder = lr.PagedSortBy = lr.PaymentOrderState = lr.PaymentServices = lr.PaymentCurrencies = lr.ApiError = lr.StreamEncryption = lr.UploadState = lr.VoidApi = void 0;
    var ar = requireApi();
    Object.defineProperty(lr, "VoidApi", { enumerable: !0, get: function() {
      return ar.VoidApi;
    } });
    var cr = upload;
    Object.defineProperty(lr, "UploadState", { enumerable: !0, get: function() {
      return cr.UploadState;
    } });
    var ur = streamEncryption;
    Object.defineProperty(lr, "StreamEncryption", { enumerable: !0, get: function() {
      return ur.StreamEncryption;
    } });
    class fr extends Error {
      constructor(gr, vr) {
        super(vr);
        Wi(this, "statusCode");
        this.statusCode = gr;
      }
    }
    lr.ApiError = fr, function(dr) {
      dr[dr.BTC = 0] = "BTC", dr[dr.USD = 1] = "USD", dr[dr.EUR = 2] = "EUR", dr[dr.GBP = 3] = "GBP";
    }(lr.PaymentCurrencies || (lr.PaymentCurrencies = {})), function(dr) {
      dr[dr.None = 0] = "None", dr[dr.Strike = 1] = "Strike";
    }(lr.PaymentServices || (lr.PaymentServices = {})), function(dr) {
      dr[dr.Unpaid = 0] = "Unpaid", dr[dr.Paid = 1] = "Paid", dr[dr.Expired = 2] = "Expired";
    }(lr.PaymentOrderState || (lr.PaymentOrderState = {})), function(dr) {
      dr[dr.Name = 0] = "Name", dr[dr.Date = 1] = "Date", dr[dr.Size = 2] = "Size", dr[dr.Id = 3] = "Id";
    }(lr.PagedSortBy || (lr.PagedSortBy = {})), function(dr) {
      dr[dr.Asc = 0] = "Asc", dr[dr.Dsc = 1] = "Dsc";
    }(lr.PageSortOrder || (lr.PageSortOrder = {}));
  }(dist)), dist;
}
var distExports = requireDist();
function create_fragment$i(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("style"), cr = space(), ur = element("style"), fr = space(), dr = element("div");
    },
    m(hr, gr) {
      insert(hr, ar, gr), ar.innerHTML = css$1, insert(hr, cr, gr), insert(hr, ur, gr), ur.innerHTML = dark, insert(hr, fr, gr), insert(hr, dr, gr), lr[6](dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(hr) {
      hr && (detach(ar), detach(cr), detach(ur), detach(fr), detach(dr)), lr[6](null);
    }
  };
}
const FILE_EXT_REGEX$1 = /\.([\w]{1,7})$/i;
function instance$9(lr, ar, cr) {
  let ur, fr, dr;
  component_subscribe(lr, theme, (Ar) => cr(5, ur = Ar)), component_subscribe(lr, ndkStore, (Ar) => cr(7, fr = Ar)), component_subscribe(lr, localStore, (Ar) => cr(8, dr = Ar));
  let { opinionContent: hr } = ar, { fileArray: gr } = ar, vr, mr, br = !1;
  const yr = uploadUrl, kr = new distExports.VoidApi(yr), Tr = (Ar) => {
    const Lr = /(?<!\]\()https?:\/\/\S*\.(jpg|jpeg|png|gif|svg|webp)(?!\))/g;
    return Ar.replace(Lr, (Dr) => Dr.startsWith("![](") ? Dr : `![](${Dr})`);
  }, _r = async (Ar) => {
    var Hr, $r, Wr, Zr, oi, Jr;
    const Lr = dr.pk;
    Lr ? !fr.signer && await privkeyLogin(Lr) : !fr.signer && await NDKlogin();
    const Nr = await kr.getUploader(Ar).upload({ "V-Strip-Metadata": "true" });
    if (Nr.ok) {
      let Yr = Ar.name.match(FILE_EXT_REGEX$1);
      (($r = (Hr = Nr.file) == null ? void 0 : Hr.metadata) == null ? void 0 : $r.mimeType) === "image/webp" && (Yr = ["", "webp"]);
      const li = (Jr = (Zr = (Wr = Nr.file) == null ? void 0 : Wr.metadata) == null ? void 0 : Zr.url) != null ? Jr : `${yr}/d/${(oi = Nr.file) == null ? void 0 : oi.id}${Yr ? `.${Yr[1]}` : ""}`;
      return cr(2, gr = [...gr, { files: Ar, url: li }]), li;
    }
    return "";
  };
  function Er() {
    cr(3, mr = new ToastUIEditor({
      el: vr,
      height: "auto",
      initialEditType: "markdown",
      previewStyle: "tab",
      theme: ur,
      initialValue: hr,
      autofocus: !0,
      events: {
        change() {
          xr();
        }
      },
      hooks: {
        addImageBlobHook: async (Ar, Lr) => {
          const Dr = await _r(Ar);
          Dr && Lr(Dr, "image");
        }
      },
      extendedAutolinks: !0
    }));
  }
  const xr = () => {
    cr(4, br = !0), cr(1, hr = mr.getMarkdown());
  };
  onMount(() => {
    cr(1, hr = hr.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), Er(), mr.getMarkdown();
  });
  function Cr(Ar) {
    binding_callbacks[Ar ? "unshift" : "push"](() => {
      vr = Ar, cr(0, vr);
    });
  }
  return lr.$$set = (Ar) => {
    "opinionContent" in Ar && cr(1, hr = Ar.opinionContent), "fileArray" in Ar && cr(2, gr = Ar.fileArray);
  }, lr.$$.update = () => {
    if (lr.$$.dirty & /*editor, isInternalUpdate, opinionContent*/
    26) {
      if (mr && !br) {
        const Ar = mr.getMarkdown();
        hr !== Ar && (cr(1, hr = Tr(hr)), mr.setMarkdown(hr));
      }
      cr(4, br = !1);
    }
    lr.$$.dirty & /*$theme, editor*/
    40 && ur && mr != null && (mr.destroy(), Er());
  }, [
    vr,
    hr,
    gr,
    mr,
    br,
    ur,
    Cr
  ];
}
class Editor_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$9, create_fragment$i, safe_not_equal, { opinionContent: 1, fileArray: 2 });
  }
  get opinionContent() {
    return this.$$.ctx[1];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
}
create_custom_element(Editor_1, { opinionContent: {}, fileArray: {} }, [], [], !0);
function create_fragment$h(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 17.7917L8.79169 16.6917C4.50002 12.8 1.66669 10.225 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5C16.3167 2.5 18.3334 4.50833 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917Z"), attr(ur, "fill", "#cbcccc"), attr(cr, "opacity", "0.5"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class LikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$h, safe_not_equal, {});
  }
}
create_custom_element(LikeButton, {}, [], [], !0);
function create_fragment$g(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M10 18.35L8.55 17.03C3.4 12.36 0 9.27 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0C17.58 0 20 2.41 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35Z"), attr(cr, "fill", "#73777A"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class LikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$g, safe_not_equal, {});
  }
}
create_custom_element(LikedButton, {}, [], [], !0);
function create_fragment$f(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "fill-rule", "evenodd"), attr(ur, "clip-rule", "evenodd"), attr(ur, "d", "M13.75 2.5C14.5376 2.5 15.2734 2.68911 15.9151 3.02568L5.40369 13.5371C3.07255 11.2282 1.66669 9.29634 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5ZM8.79169 16.6917C7.98933 15.9641 7.23794 15.2825 6.54651 14.6347L17.1749 4.00627C17.8982 4.81336 18.3334 5.88721 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917L8.79169 16.6917Z"), attr(ur, "fill", "#cbcccc"), attr(cr, "opacity", "0.5"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class DislikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$f, safe_not_equal, {});
  }
}
create_custom_element(DislikeButton, {}, [], [], !0);
function create_fragment$e(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M14.5 0C15.4451 0 16.3281 0.226936 17.0981 0.630818L4.48441 13.2445C1.68704 10.4738 0 8.15561 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0ZM8.55 17.03C7.58717 16.1569 6.68551 15.339 5.85579 14.5616L18.6099 1.80753C19.4778 2.77603 20 4.06465 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35L8.55 17.03Z"), attr(cr, "fill", "#73777A"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class DislikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$e, safe_not_equal, {});
  }
}
create_custom_element(DislikedButton, {}, [], [], !0);
function create_fragment$d(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 4L3 10L10 16V12.5C10 12.5 14.802 11.9579 17.2115 14.3323C17.2115 7.91272 10 7.5 10 7.5V4Z"), set_style(ur, "fill", "#cbcccc"), set_style(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class ReplyButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$d, safe_not_equal, {});
  }
}
create_custom_element(ReplyButton, {}, [], [], !0);
function create_fragment$c(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("circle"), fr = svg_element("circle"), dr = svg_element("circle"), attr(ur, "cx", "3.66669"), attr(ur, "cy", "9.6665"), attr(ur, "r", "2.5"), attr(ur, "fill", "#73777A"), attr(fr, "cx", "10.66669"), attr(fr, "cy", "9.6665"), attr(fr, "r", "2.5"), attr(fr, "fill", "#73777A"), attr(dr, "cx", "17.6667"), attr(dr, "cy", "9.6665"), attr(dr, "r", "2.5"), attr(dr, "fill", "#73777A"), attr(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(hr) {
      hr && detach(ar);
    }
  };
}
class OptionButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$c, safe_not_equal, {});
  }
}
create_custom_element(OptionButton, {}, [], [], !0);
function create_fragment$b(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("rect"), ur = svg_element("path"), attr(cr, "y", "0.5"), attr(cr, "width", "106"), attr(cr, "height", "17"), attr(cr, "rx", "3"), attr(cr, "fill", "#F7931A"), attr(ur, "d", "M9.1985 10.07L8.3075 7.703C8.2355 7.52 8.162 7.2875 8.087 7.0055C8.054 7.1465 8.018 7.277 7.979 7.397C7.94 7.514 7.904 7.6175 7.871 7.7075L6.98 10.07H9.1985ZM11.192 12.5H10.3775C10.2845 12.5 10.2095 12.4775 10.1525 12.4325C10.0955 12.3845 10.052 12.326 10.022 12.257L9.482 10.826H6.692L6.152 12.257C6.128 12.317 6.086 12.3725 6.026 12.4235C5.966 12.4745 5.891 12.5 5.801 12.5H4.9865L7.556 6.02H8.6225L11.192 12.5ZM13.9642 9.323C14.1982 9.323 14.4037 9.293 14.5807 9.233C14.7607 9.173 14.9092 9.089 15.0262 8.981C15.1462 8.87 15.2362 8.7365 15.2962 8.5805C15.3562 8.4245 15.3862 8.2505 15.3862 8.0585C15.3862 7.8695 15.3562 7.7 15.2962 7.55C15.2392 7.4 15.1522 7.2725 15.0352 7.1675C14.9182 7.0625 14.7697 6.983 14.5897 6.929C14.4127 6.872 14.2042 6.8435 13.9642 6.8435H13.0012V9.323H13.9642ZM13.9642 6.02C14.3872 6.02 14.7532 6.0695 15.0622 6.1685C15.3742 6.2675 15.6307 6.407 15.8317 6.587C16.0357 6.764 16.1872 6.9785 16.2862 7.2305C16.3852 7.4795 16.4347 7.7555 16.4347 8.0585C16.4347 8.3675 16.3822 8.651 16.2772 8.909C16.1722 9.164 16.0162 9.3845 15.8092 9.5705C15.6022 9.7535 15.3442 9.8975 15.0352 10.0025C14.7292 10.1045 14.3722 10.1555 13.9642 10.1555H13.0012V12.5H11.9482V6.02H13.9642ZM19.4574 9.323C19.6914 9.323 19.8969 9.293 20.0739 9.233C20.2539 9.173 20.4024 9.089 20.5194 8.981C20.6394 8.87 20.7294 8.7365 20.7894 8.5805C20.8494 8.4245 20.8794 8.2505 20.8794 8.0585C20.8794 7.8695 20.8494 7.7 20.7894 7.55C20.7324 7.4 20.6454 7.2725 20.5284 7.1675C20.4114 7.0625 20.2629 6.983 20.0829 6.929C19.9059 6.872 19.6974 6.8435 19.4574 6.8435H18.4944V9.323H19.4574ZM19.4574 6.02C19.8804 6.02 20.2464 6.0695 20.5554 6.1685C20.8674 6.2675 21.1239 6.407 21.3249 6.587C21.5289 6.764 21.6804 6.9785 21.7794 7.2305C21.8784 7.4795 21.9279 7.7555 21.9279 8.0585C21.9279 8.3675 21.8754 8.651 21.7704 8.909C21.6654 9.164 21.5094 9.3845 21.3024 9.5705C21.0954 9.7535 20.8374 9.8975 20.5284 10.0025C20.2224 10.1045 19.8654 10.1555 19.4574 10.1555H18.4944V12.5H17.4414V6.02H19.4574ZM24.8155 9.125C25.0555 9.125 25.2655 9.0965 25.4455 9.0395C25.6255 8.9795 25.7755 8.897 25.8955 8.792C26.0155 8.687 26.1055 8.5625 26.1655 8.4185C26.2255 8.2715 26.2555 8.1095 26.2555 7.9325C26.2555 7.5785 26.1385 7.3085 25.9045 7.1225C25.6705 6.9365 25.3165 6.8435 24.8425 6.8435H23.9875V9.125H24.8155ZM27.8665 12.5H26.926C26.74 12.5 26.605 12.428 26.521 12.284L25.009 10.1015C24.958 10.0265 24.9025 9.9725 24.8425 9.9395C24.7825 9.9065 24.6925 9.89 24.5725 9.89H23.9875V12.5H22.9345V6.02H24.8425C25.2685 6.02 25.6345 6.0635 25.9405 6.1505C26.2495 6.2375 26.503 6.362 26.701 6.524C26.899 6.683 27.0445 6.875 27.1375 7.1C27.2335 7.325 27.2815 7.5755 27.2815 7.8515C27.2815 8.0765 27.247 8.2865 27.178 8.4815C27.112 8.6765 27.0145 8.8535 26.8855 9.0125C26.7595 9.1715 26.6035 9.3095 26.4175 9.4265C26.2315 9.5435 26.02 9.635 25.783 9.701C25.912 9.779 26.023 9.8885 26.116 10.0295L27.8665 12.5ZM34.6568 9.26C34.6568 9.74 34.5788 10.1825 34.4228 10.5875C34.2668 10.9925 34.0463 11.342 33.7613 11.636C33.4793 11.927 33.1388 12.155 32.7398 12.32C32.3438 12.485 31.9028 12.5675 31.4168 12.5675C30.9338 12.5675 30.4928 12.485 30.0938 12.32C29.6978 12.155 29.3573 11.927 29.0723 11.636C28.7873 11.342 28.5668 10.9925 28.4108 10.5875C28.2548 10.1825 28.1768 9.74 28.1768 9.26C28.1768 8.78 28.2548 8.3375 28.4108 7.9325C28.5668 7.5275 28.7873 7.178 29.0723 6.884C29.3573 6.59 29.6978 6.3605 30.0938 6.1955C30.4928 6.0305 30.9338 5.948 31.4168 5.948C31.9028 5.948 32.3438 6.0305 32.7398 6.1955C33.1388 6.3605 33.4793 6.59 33.7613 6.884C34.0463 7.178 34.2668 7.5275 34.4228 7.9325C34.5788 8.3375 34.6568 8.78 34.6568 9.26ZM33.5813 9.26C33.5813 8.888 33.5303 8.5535 33.4283 8.2565C33.3293 7.9595 33.1853 7.7075 32.9963 7.5005C32.8103 7.2935 32.5838 7.1345 32.3168 7.0235C32.0498 6.9125 31.7498 6.857 31.4168 6.857C31.0868 6.857 30.7883 6.9125 30.5213 7.0235C30.2543 7.1345 30.0263 7.2935 29.8373 7.5005C29.6483 7.7075 29.5028 7.9595 29.4008 8.2565C29.2988 8.5535 29.2478 8.888 29.2478 9.26C29.2478 9.635 29.2988 9.971 29.4008 10.268C29.5028 10.565 29.6483 10.817 29.8373 11.024C30.0263 11.228 30.2543 11.3855 30.5213 11.4965C30.7883 11.6045 31.0868 11.6585 31.4168 11.6585C31.7498 11.6585 32.0498 11.6045 32.3168 11.4965C32.5838 11.3855 32.8103 11.228 32.9963 11.024C33.1853 10.817 33.3293 10.565 33.4283 10.268C33.5303 9.971 33.5813 9.635 33.5813 9.26ZM41.0309 6.02L38.4029 12.5H37.4534L34.8254 6.02H35.6669C35.7599 6.02 35.8349 6.044 35.8919 6.092C35.9489 6.137 35.9924 6.194 36.0224 6.263L37.6919 10.4885C37.7819 10.7255 37.8644 10.9985 37.9394 11.3075C37.9724 11.1545 38.0069 11.009 38.0429 10.871C38.0819 10.733 38.1239 10.6055 38.1689 10.4885L39.8339 6.263C39.8579 6.203 39.8999 6.1475 39.9599 6.0965C40.0199 6.0455 40.0949 6.02 40.1849 6.02H41.0309ZM45.8326 11.6495L45.8281 12.5H41.7871V6.02H45.8281V6.8705H42.8446V8.8235H45.2296V9.647H42.8446V11.6495H45.8326ZM52.6606 9.26C52.6606 9.74 52.5826 10.1795 52.4266 10.5785C52.2706 10.9745 52.0501 11.315 51.7651 11.6C51.4831 11.885 51.1426 12.107 50.7436 12.266C50.3476 12.422 49.9066 12.5 49.4206 12.5H46.9726V6.02H49.4206C49.9066 6.02 50.3476 6.0995 50.7436 6.2585C51.1426 6.4145 51.4831 6.635 51.7651 6.92C52.0501 7.205 52.2706 7.547 52.4266 7.946C52.5826 8.342 52.6606 8.78 52.6606 9.26ZM51.5851 9.26C51.5851 8.888 51.5341 8.5535 51.4321 8.2565C51.3331 7.9595 51.1891 7.709 51.0001 7.505C50.8141 7.301 50.5876 7.145 50.3206 7.037C50.0536 6.926 49.7536 6.8705 49.4206 6.8705H48.0301V11.6495H49.4206C49.7536 11.6495 50.0536 11.5955 50.3206 11.4875C50.5876 11.3795 50.8141 11.2235 51.0001 11.0195C51.1891 10.8125 51.3331 10.562 51.4321 10.268C51.5341 9.971 51.5851 9.635 51.5851 9.26ZM57.9415 9.125C58.1815 9.125 58.3915 9.0965 58.5715 9.0395C58.7515 8.9795 58.9015 8.897 59.0215 8.792C59.1415 8.687 59.2315 8.5625 59.2915 8.4185C59.3515 8.2715 59.3815 8.1095 59.3815 7.9325C59.3815 7.5785 59.2645 7.3085 59.0305 7.1225C58.7965 6.9365 58.4425 6.8435 57.9685 6.8435H57.1135V9.125H57.9415ZM60.9925 12.5H60.052C59.866 12.5 59.731 12.428 59.647 12.284L58.135 10.1015C58.084 10.0265 58.0285 9.9725 57.9685 9.9395C57.9085 9.9065 57.8185 9.89 57.6985 9.89H57.1135V12.5H56.0605V6.02H57.9685C58.3945 6.02 58.7605 6.0635 59.0665 6.1505C59.3755 6.2375 59.629 6.362 59.827 6.524C60.025 6.683 60.1705 6.875 60.2635 7.1C60.3595 7.325 60.4075 7.5755 60.4075 7.8515C60.4075 8.0765 60.373 8.2865 60.304 8.4815C60.238 8.6765 60.1405 8.8535 60.0115 9.0125C59.8855 9.1715 59.7295 9.3095 59.5435 9.4265C59.3575 9.5435 59.146 9.635 58.909 9.701C59.038 9.779 59.149 9.8885 59.242 10.0295L60.9925 12.5ZM65.8189 11.6495L65.8144 12.5H61.7734V6.02H65.8144V6.8705H62.8309V8.8235H65.2159V9.647H62.8309V11.6495H65.8189ZM72.3815 6.02L69.7535 12.5H68.804L66.176 6.02H67.0175C67.1105 6.02 67.1855 6.044 67.2425 6.092C67.2995 6.137 67.343 6.194 67.373 6.263L69.0425 10.4885C69.1325 10.7255 69.215 10.9985 69.29 11.3075C69.323 11.1545 69.3575 11.009 69.3935 10.871C69.4325 10.733 69.4745 10.6055 69.5195 10.4885L71.1845 6.263C71.2085 6.203 71.2505 6.1475 71.3105 6.0965C71.3705 6.0455 71.4455 6.02 71.5355 6.02H72.3815ZM74.1952 12.5H73.1377V6.02H74.1952V12.5ZM79.7759 11.6495L79.7714 12.5H75.7304V6.02H79.7714V6.8705H76.7879V8.8235H79.1729V9.647H76.7879V11.6495H79.7759ZM89.4345 6.02L87.4185 12.5H86.469L84.948 7.847C84.93 7.796 84.912 7.7405 84.894 7.6805C84.879 7.6205 84.864 7.556 84.849 7.487C84.834 7.556 84.8175 7.6205 84.7995 7.6805C84.7845 7.7405 84.768 7.796 84.75 7.847L83.2155 12.5H82.266L80.25 6.02H81.132C81.222 6.02 81.297 6.0425 81.357 6.0875C81.42 6.1295 81.462 6.188 81.483 6.263L82.698 10.4165C82.722 10.5065 82.7445 10.604 82.7655 10.709C82.7865 10.814 82.8075 10.9235 82.8285 11.0375C82.8495 10.9235 82.872 10.814 82.896 10.709C82.923 10.601 82.9515 10.5035 82.9815 10.4165L84.372 6.263C84.393 6.203 84.435 6.1475 84.498 6.0965C84.561 6.0455 84.636 6.02 84.723 6.02H85.029C85.122 6.02 85.197 6.044 85.254 6.092C85.311 6.137 85.3545 6.194 85.3845 6.263L86.7705 10.4165C86.8005 10.5035 86.8275 10.598 86.8515 10.7C86.8785 10.799 86.9025 10.904 86.9235 11.015C86.9445 10.904 86.964 10.799 86.982 10.7C87.003 10.598 87.0255 10.5035 87.0495 10.4165L88.26 6.263C88.278 6.197 88.3185 6.14 88.3815 6.092C88.4475 6.044 88.524 6.02 88.611 6.02H89.4345ZM94.357 11.6495L94.3525 12.5H90.3115V6.02H94.3525V6.8705H91.369V8.8235H93.754V9.647H91.369V11.6495H94.357ZM97.378 9.125C97.618 9.125 97.828 9.0965 98.008 9.0395C98.188 8.9795 98.338 8.897 98.458 8.792C98.578 8.687 98.668 8.5625 98.728 8.4185C98.788 8.2715 98.818 8.1095 98.818 7.9325C98.818 7.5785 98.701 7.3085 98.467 7.1225C98.233 6.9365 97.879 6.8435 97.405 6.8435H96.55V9.125H97.378ZM100.429 12.5H99.4885C99.3025 12.5 99.1675 12.428 99.0835 12.284L97.5715 10.1015C97.5205 10.0265 97.465 9.9725 97.405 9.9395C97.345 9.9065 97.255 9.89 97.135 9.89H96.55V12.5H95.497V6.02H97.405C97.831 6.02 98.197 6.0635 98.503 6.1505C98.812 6.2375 99.0655 6.362 99.2635 6.524C99.4615 6.683 99.607 6.875 99.7 7.1C99.796 7.325 99.844 7.5755 99.844 7.8515C99.844 8.0765 99.8095 8.2865 99.7405 8.4815C99.6745 8.6765 99.577 8.8535 99.448 9.0125C99.322 9.1715 99.166 9.3095 98.98 9.4265C98.794 9.5435 98.5825 9.635 98.3455 9.701C98.4745 9.779 98.5855 9.8885 98.6785 10.0295L100.429 12.5Z"), attr(ur, "fill", "white"), attr(ar, "width", "106"), attr(ar, "height", "18"), attr(ar, "viewBox", "0 0 106 18"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class ApprovedBadge extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$b, safe_not_equal, {});
  }
}
create_custom_element(ApprovedBadge, {}, [], [], !0);
function add_css$8(lr) {
  append_styles(lr, "svelte-1qh4vd6", ".preview-container.svelte-1qh4vd6{position:relative;width:150px;height:150px;border-radius:10px;overflow:hidden;box-shadow:0 4px 8px rgba(0, 0, 0, 0.1)}.preview-image.svelte-1qh4vd6{width:100%;height:100%;display:block;border-radius:10px}.delete-button.svelte-1qh4vd6{position:absolute;top:10px;right:10px;background-color:transparent;border:none;border-radius:50%;color:white;cursor:pointer}");
}
function create_if_block$2(lr) {
  let ar, cr, ur, fr, dr, hr;
  return {
    c() {
      ar = element("img"), ur = space(), fr = element("button"), fr.textContent = "X", attr(ar, "class", "preview-image svelte-1qh4vd6"), src_url_equal(ar.src, cr = /*dataUrl*/
      lr[0]) || attr(ar, "src", cr), attr(ar, "alt", "Uploaded file preview"), attr(fr, "class", "delete-button svelte-1qh4vd6");
    },
    m(gr, vr) {
      insert(gr, ar, vr), insert(gr, ur, vr), insert(gr, fr, vr), dr || (hr = listen(
        fr,
        "click",
        /*handleDelete*/
        lr[1]
      ), dr = !0);
    },
    p(gr, vr) {
      vr & /*dataUrl*/
      1 && !src_url_equal(ar.src, cr = /*dataUrl*/
      gr[0]) && attr(ar, "src", cr);
    },
    d(gr) {
      gr && (detach(ar), detach(ur), detach(fr)), dr = !1, hr();
    }
  };
}
function create_fragment$a(lr) {
  let ar, cr = (
    /*dataUrl*/
    lr[0] && create_if_block$2(lr)
  );
  return {
    c() {
      ar = element("div"), cr && cr.c(), attr(ar, "class", "preview-container svelte-1qh4vd6");
    },
    m(ur, fr) {
      insert(ur, ar, fr), cr && cr.m(ar, null);
    },
    p(ur, [fr]) {
      /*dataUrl*/
      ur[0] ? cr ? cr.p(ur, fr) : (cr = create_if_block$2(ur), cr.c(), cr.m(ar, null)) : cr && (cr.d(1), cr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), cr && cr.d();
    }
  };
}
function instance$8(lr, ar, cr) {
  let { file: ur } = ar, { onDelete: fr } = ar, dr = "";
  const hr = new FileReader();
  hr.onload = (vr) => {
    var mr;
    typeof ((mr = vr == null ? void 0 : vr.target) == null ? void 0 : mr.result) == "string" && cr(0, dr = vr.target.result);
  }, ur && hr.readAsDataURL(ur);
  const gr = () => {
    fr(ur);
  };
  return lr.$$set = (vr) => {
    "file" in vr && cr(2, ur = vr.file), "onDelete" in vr && cr(3, fr = vr.onDelete);
  }, [dr, gr, ur, fr];
}
class FilePreview extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$8, create_fragment$a, safe_not_equal, { file: 2, onDelete: 3 }, add_css$8);
  }
  get file() {
    return this.$$.ctx[2];
  }
  set file(ar) {
    this.$$set({ file: ar }), flush();
  }
  get onDelete() {
    return this.$$.ctx[3];
  }
  set onDelete(ar) {
    this.$$set({ onDelete: ar }), flush();
  }
}
create_custom_element(FilePreview, { file: {}, onDelete: {} }, [], [], !0);
function create_fragment$9(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "d", "M455.111 284.444H512v682.667h-56.889z"), attr(cr, "fill", "#73777A"), attr(ur, "d", "M113.778 113.778h739.555v682.666H625.778v56.89h284.444V56.888H56.89v796.444h284.444v-56.889H113.778z"), attr(ur, "fill", "#73777A"), attr(fr, "d", "M284.444 415.289l39.823 39.822L483.556 307.2l159.288 147.911 39.823-39.822-199.111-187.733z"), attr(fr, "fill", "#73777A"), set_style(ar, "width", "50"), set_style(ar, "height", "30"), set_style(ar, "fill", "currentColor"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "version", "1.1"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, hr) {
      insert(dr, ar, hr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class UploadButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$9, safe_not_equal, {});
  }
}
create_custom_element(UploadButton, {}, [], [], !0);
function add_css$7(lr) {
  append_styles(lr, "svelte-y5sskm", ".file-input.svelte-y5sskm{display:none}.upload-button.svelte-y5sskm{background:none;border:none;background-color:transparent;cursor:pointer}");
}
function create_fragment$8(lr) {
  let ar, cr, ur, fr, dr, hr, gr;
  return fr = new UploadButton({}), {
    c() {
      ar = element("input"), cr = space(), ur = element("button"), create_component(fr.$$.fragment), attr(ar, "type", "file"), attr(ar, "class", "file-input svelte-y5sskm"), attr(ar, "accept", "image/*"), attr(ur, "class", "upload-button svelte-y5sskm");
    },
    m(vr, mr) {
      insert(vr, ar, mr), lr[4](ar), insert(vr, cr, mr), insert(vr, ur, mr), mount_component(fr, ur, null), dr = !0, hr || (gr = [
        listen(
          ar,
          "change",
          /*handleChange*/
          lr[1]
        ),
        listen(ur, "click", prevent_default(
          /*click_handler*/
          lr[5]
        ))
      ], hr = !0);
    },
    p: noop$1,
    i(vr) {
      dr || (transition_in(fr.$$.fragment, vr), dr = !0);
    },
    o(vr) {
      transition_out(fr.$$.fragment, vr), dr = !1;
    },
    d(vr) {
      vr && (detach(ar), detach(cr), detach(ur)), lr[4](null), destroy_component(fr), hr = !1, run_all(gr);
    }
  };
}
const FILE_EXT_REGEX = /\.([\w]{1,7})$/i;
function instance$7(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkStore, (_r) => cr(6, ur = _r)), component_subscribe(lr, localStore, (_r) => cr(7, fr = _r));
  let dr, hr, { fileArray: gr = [] } = ar, { opinionContent: vr } = ar;
  const mr = uploadUrl, br = new distExports.VoidApi(mr), yr = async (_r) => {
    var xr, Cr, Ar, Lr, Dr, Nr;
    const Er = _r.target;
    if (!Er.files) {
      console.info("Files array is empty");
      return;
    }
    for (hr of Er.files) {
      const Hr = fr.pk;
      Hr ? !ur.signer && await privkeyLogin(Hr) : !ur.signer && await NDKlogin();
      const Wr = await br.getUploader(hr).upload({ "V-Strip-Metadata": "true" });
      if (Wr.ok) {
        let Zr = hr.name.match(FILE_EXT_REGEX);
        ((Cr = (xr = Wr.file) == null ? void 0 : xr.metadata) == null ? void 0 : Cr.mimeType) === "image/webp" && (Zr = ["", "webp"]);
        const oi = (Nr = (Lr = (Ar = Wr.file) == null ? void 0 : Ar.metadata) == null ? void 0 : Lr.url) != null ? Nr : `${mr}/d/${(Dr = Wr.file) == null ? void 0 : Dr.id}${Zr ? `.${Zr[1]}` : ""}`;
        cr(2, gr = [...gr, { files: hr, url: oi }]), cr(3, vr = vr + " " + oi);
      }
    }
  };
  function kr(_r) {
    binding_callbacks[_r ? "unshift" : "push"](() => {
      dr = _r, cr(0, dr);
    });
  }
  const Tr = () => dr.click();
  return lr.$$set = (_r) => {
    "fileArray" in _r && cr(2, gr = _r.fileArray), "opinionContent" in _r && cr(3, vr = _r.opinionContent);
  }, [
    dr,
    yr,
    gr,
    vr,
    kr,
    Tr
  ];
}
class Upload extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$7, create_fragment$8, safe_not_equal, { fileArray: 2, opinionContent: 3 }, add_css$7);
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[3];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(Upload, { fileArray: {}, opinionContent: {} }, [], [], !0);
function create_fragment$7(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", `M967.111 227.556H739.556V56.889H284.444v170.667H56.89v56.888h113.778v682.667h682.666V284.444h113.778v-56.888zM341.333 113.778h341.334v113.778H341.333V113.778z m455.111 796.444H227.556V284.444h568.888v625.778z
    M398.222 341.333h56.89v512h-56.89z m170.667 0h56.889v512h-56.89z`), attr(ur, "fill", "#73777A"), attr(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class DeleteButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$7, safe_not_equal, {});
  }
}
create_custom_element(DeleteButton, {}, [], [], !0);
function add_css$6(lr) {
  append_styles(lr, "svelte-1nsksb0", ".card-button.svelte-1nsksb0.svelte-1nsksb0{display:inline-flex;align-items:center;gap:2px}.card-button.svelte-1nsksb0 button.svelte-1nsksb0{background:none;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}");
}
function create_fragment$6(lr) {
  let ar, cr, ur, fr, dr, hr;
  return ur = new DeleteButton({}), {
    c() {
      ar = element("div"), cr = element("button"), create_component(ur.$$.fragment), attr(cr, "class", "svelte-1nsksb0"), attr(ar, "class", "card-button svelte-1nsksb0");
    },
    m(gr, vr) {
      insert(gr, ar, vr), append(ar, cr), mount_component(ur, cr, null), fr = !0, dr || (hr = listen(
        cr,
        "click",
        /*click_handler*/
        lr[4]
      ), dr = !0);
    },
    p: noop$1,
    i(gr) {
      fr || (transition_in(ur.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_component(ur), dr = !1, hr();
    }
  };
}
function instance$6(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkStore, (br) => cr(5, ur = br)), component_subscribe(lr, localStore, (br) => cr(6, fr = br));
  let { eventID: dr } = ar, { isDeleted: hr } = ar, { count: gr } = ar;
  async function vr(br) {
    try {
      const yr = fr.pk;
      yr ? !ur.signer && await privkeyLogin(yr) : !ur.signer && await NDKlogin();
      const kr = await ur.fetchEvent({ ids: [br] });
      await db.events.delete(br), await (kr == null ? void 0 : kr.delete()), cr(2, hr = !0), cr(3, gr = gr == 0 ? 0 : gr - 1);
    } catch (yr) {
      console.log("Error: ", yr);
    }
  }
  const mr = () => vr(dr);
  return lr.$$set = (br) => {
    "eventID" in br && cr(0, dr = br.eventID), "isDeleted" in br && cr(2, hr = br.isDeleted), "count" in br && cr(3, gr = br.count);
  }, [dr, vr, hr, gr, mr];
}
class DeleteEventData extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$6, create_fragment$6, safe_not_equal, { eventID: 0, isDeleted: 2, count: 3 }, add_css$6);
  }
  get eventID() {
    return this.$$.ctx[0];
  }
  set eventID(ar) {
    this.$$set({ eventID: ar }), flush();
  }
  get isDeleted() {
    return this.$$.ctx[2];
  }
  set isDeleted(ar) {
    this.$$set({ isDeleted: ar }), flush();
  }
  get count() {
    return this.$$.ctx[3];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
}
create_custom_element(DeleteEventData, { eventID: {}, isDeleted: {}, count: {} }, [], [], !0);
function add_css$5(lr) {
  append_styles(lr, "svelte-1819t8t", `.textarea-style.svelte-1819t8t{width:100%;min-height:200px;background-color:#f8f8f8;color:#333;border:1px solid #ccc;border-radius:4px;padding:10px;font-family:'Arial', sans-serif;font-size:16px;line-height:1.5;resize:vertical;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);transition:border-color 0.3s,
			box-shadow 0.3s}.dark.svelte-1819t8t{background-color:black;color:white}`);
}
function create_fragment$5(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("textarea"), attr(ar, "class", "textarea-style svelte-1819t8t"), ar.value = "", toggle_class(
        ar,
        "dark",
        /*$theme*/
        lr[1] === "dark"
      );
    },
    m(hr, gr) {
      insert(hr, ar, gr), lr[4](ar), ur = !0, fr || (dr = listen(
        ar,
        "input",
        /*updateContent*/
        lr[2]
      ), fr = !0);
    },
    p(hr, [gr]) {
      (!ur || gr & /*$theme*/
      2) && toggle_class(
        ar,
        "dark",
        /*$theme*/
        hr[1] === "dark"
      );
    },
    i(hr) {
      ur || (hr && add_render_callback(() => {
        ur && (cr || (cr = create_bidirectional_transition(ar, slide, {}, !0)), cr.run(1));
      }), ur = !0);
    },
    o(hr) {
      hr && (cr || (cr = create_bidirectional_transition(ar, slide, {}, !1)), cr.run(0)), ur = !1;
    },
    d(hr) {
      hr && detach(ar), lr[4](null), hr && cr && cr.end(), fr = !1, dr();
    }
  };
}
function instance$5(lr, ar, cr) {
  let ur;
  component_subscribe(lr, theme, (vr) => cr(1, ur = vr));
  let fr, { opinionContent: dr } = ar;
  const hr = () => {
    cr(3, dr = fr.value);
  };
  onMount(() => {
    cr(0, fr.value = dr, fr);
  });
  function gr(vr) {
    binding_callbacks[vr ? "unshift" : "push"](() => {
      fr = vr, cr(0, fr), cr(3, dr);
    });
  }
  return lr.$$set = (vr) => {
    "opinionContent" in vr && cr(3, dr = vr.opinionContent);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*textarea, opinionContent*/
    9 && fr && cr(0, fr.value = dr, fr);
  }, [fr, ur, hr, dr, gr];
}
class TextArea extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$5, create_fragment$5, safe_not_equal, { opinionContent: 3 }, add_css$5);
  }
  get opinionContent() {
    return this.$$.ctx[3];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(TextArea, { opinionContent: {} }, [], [], !0);
/*! @license DOMPurify 3.0.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.8/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object, {
  apply,
  construct
} = typeof Reflect != "undefined" && Reflect;
freeze || (freeze = function(ar) {
  return ar;
});
seal || (seal = function(ar) {
  return ar;
});
apply || (apply = function(ar, cr, ur) {
  return ar.apply(cr, ur);
});
construct || (construct = function(ar, cr) {
  return new ar(...cr);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(lr) {
  return function(ar) {
    for (var cr = arguments.length, ur = new Array(cr > 1 ? cr - 1 : 0), fr = 1; fr < cr; fr++)
      ur[fr - 1] = arguments[fr];
    return apply(lr, ar, ur);
  };
}
function unconstruct(lr) {
  return function() {
    for (var ar = arguments.length, cr = new Array(ar), ur = 0; ur < ar; ur++)
      cr[ur] = arguments[ur];
    return construct(lr, cr);
  };
}
function addToSet(lr, ar) {
  let cr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(lr, null);
  let ur = ar.length;
  for (; ur--; ) {
    let fr = ar[ur];
    if (typeof fr == "string") {
      const dr = cr(fr);
      dr !== fr && (isFrozen(ar) || (ar[ur] = dr), fr = dr);
    }
    lr[fr] = !0;
  }
  return lr;
}
function cleanArray(lr) {
  for (let ar = 0; ar < lr.length; ar++)
    getOwnPropertyDescriptor(lr, ar) === void 0 && (lr[ar] = null);
  return lr;
}
function clone(lr) {
  const ar = create(null);
  for (const [cr, ur] of entries(lr))
    getOwnPropertyDescriptor(lr, cr) !== void 0 && (Array.isArray(ur) ? ar[cr] = cleanArray(ur) : ur && typeof ur == "object" && ur.constructor === Object ? ar[cr] = clone(ur) : ar[cr] = ur);
  return ar;
}
function lookupGetter(lr, ar) {
  for (; lr !== null; ) {
    const ur = getOwnPropertyDescriptor(lr, ar);
    if (ur) {
      if (ur.get)
        return unapply(ur.get);
      if (typeof ur.value == "function")
        return unapply(ur.value);
    }
    lr = getPrototypeOf(lr);
  }
  function cr(ur) {
    return console.warn("fallback value for", ur), null;
  }
  return cr;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = function lr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy = function lr(ar, cr) {
  if (typeof ar != "object" || typeof ar.createPolicy != "function")
    return null;
  let ur = null;
  const fr = "data-tt-policy-suffix";
  cr && cr.hasAttribute(fr) && (ur = cr.getAttribute(fr));
  const dr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(dr, {
      createHTML(hr) {
        return hr;
      },
      createScriptURL(hr) {
        return hr;
      }
    });
  } catch (hr) {
    return console.warn("TrustedTypes policy " + dr + " could not be created."), null;
  }
};
function createDOMPurify() {
  let lr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const ar = (Br) => createDOMPurify(Br);
  if (ar.version = "3.0.8", ar.removed = [], !lr || !lr.document || lr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  let {
    document: cr
  } = lr;
  const ur = cr, fr = ur.currentScript, {
    DocumentFragment: dr,
    HTMLTemplateElement: hr,
    Node: gr,
    Element: vr,
    NodeFilter: mr,
    NamedNodeMap: br = lr.NamedNodeMap || lr.MozNamedAttrMap,
    HTMLFormElement: yr,
    DOMParser: kr,
    trustedTypes: Tr
  } = lr, _r = vr.prototype, Er = lookupGetter(_r, "cloneNode"), xr = lookupGetter(_r, "nextSibling"), Cr = lookupGetter(_r, "childNodes"), Ar = lookupGetter(_r, "parentNode");
  if (typeof hr == "function") {
    const Br = cr.createElement("template");
    Br.content && Br.content.ownerDocument && (cr = Br.content.ownerDocument);
  }
  let Lr, Dr = "";
  const {
    implementation: Nr,
    createNodeIterator: Hr,
    createDocumentFragment: $r,
    getElementsByTagName: Wr
  } = cr, {
    importNode: Zr
  } = ur;
  let oi = {};
  ar.isSupported = typeof entries == "function" && typeof Ar == "function" && Nr && Nr.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Jr,
    ERB_EXPR: Yr,
    TMPLIT_EXPR: li,
    DATA_ATTR: Si,
    ARIA_ATTR: ci,
    IS_SCRIPT_OR_DATA: hi,
    ATTR_WHITESPACE: Ei
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: di
  } = EXPRESSIONS, gi = null;
  const Li = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ui = null;
  const wi = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let Ui = Object.seal(create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), yi = null, Vi = null, Oi = !0, Mi = !0, Ii = !1, mi = !0, _i = !1, Ci = !1, Ki = !1, Ni = !1, ia = !1, ea = !1, la = !1, ma = !0, Ba = !1;
  const Fa = "user-content-";
  let Ia = !0, Hi = !1, oa = {}, Gi = null;
  const ha = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Ua = null;
  const eo = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let ua = null;
  const va = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ta = "http://www.w3.org/1998/Math/MathML", Aa = "http://www.w3.org/2000/svg", Oa = "http://www.w3.org/1999/xhtml";
  let Xa = Oa, Ka = !1, Pa = null;
  const Da = addToSet({}, [Ta, Aa, Oa], stringToString);
  let Ha = null;
  const $a = ["application/xhtml+xml", "text/html"], Yi = "text/html";
  let Zi = null, ka = null;
  const zi = cr.createElement("form"), Ji = function(zr) {
    return zr instanceof RegExp || zr instanceof Function;
  }, za = function() {
    let zr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ka && ka === zr)) {
      if ((!zr || typeof zr != "object") && (zr = {}), zr = clone(zr), Ha = // eslint-disable-next-line unicorn/prefer-includes
      $a.indexOf(zr.PARSER_MEDIA_TYPE) === -1 ? Yi : zr.PARSER_MEDIA_TYPE, Zi = Ha === "application/xhtml+xml" ? stringToString : stringToLowerCase, gi = "ALLOWED_TAGS" in zr ? addToSet({}, zr.ALLOWED_TAGS, Zi) : Li, ui = "ALLOWED_ATTR" in zr ? addToSet({}, zr.ALLOWED_ATTR, Zi) : wi, Pa = "ALLOWED_NAMESPACES" in zr ? addToSet({}, zr.ALLOWED_NAMESPACES, stringToString) : Da, ua = "ADD_URI_SAFE_ATTR" in zr ? addToSet(
        clone(va),
        // eslint-disable-line indent
        zr.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Zi
        // eslint-disable-line indent
      ) : va, Ua = "ADD_DATA_URI_TAGS" in zr ? addToSet(
        clone(eo),
        // eslint-disable-line indent
        zr.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Zi
        // eslint-disable-line indent
      ) : eo, Gi = "FORBID_CONTENTS" in zr ? addToSet({}, zr.FORBID_CONTENTS, Zi) : ha, yi = "FORBID_TAGS" in zr ? addToSet({}, zr.FORBID_TAGS, Zi) : {}, Vi = "FORBID_ATTR" in zr ? addToSet({}, zr.FORBID_ATTR, Zi) : {}, oa = "USE_PROFILES" in zr ? zr.USE_PROFILES : !1, Oi = zr.ALLOW_ARIA_ATTR !== !1, Mi = zr.ALLOW_DATA_ATTR !== !1, Ii = zr.ALLOW_UNKNOWN_PROTOCOLS || !1, mi = zr.ALLOW_SELF_CLOSE_IN_ATTR !== !1, _i = zr.SAFE_FOR_TEMPLATES || !1, Ci = zr.WHOLE_DOCUMENT || !1, ia = zr.RETURN_DOM || !1, ea = zr.RETURN_DOM_FRAGMENT || !1, la = zr.RETURN_TRUSTED_TYPE || !1, Ni = zr.FORCE_BODY || !1, ma = zr.SANITIZE_DOM !== !1, Ba = zr.SANITIZE_NAMED_PROPS || !1, Ia = zr.KEEP_CONTENT !== !1, Hi = zr.IN_PLACE || !1, di = zr.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, Xa = zr.NAMESPACE || Oa, Ui = zr.CUSTOM_ELEMENT_HANDLING || {}, zr.CUSTOM_ELEMENT_HANDLING && Ji(zr.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ui.tagNameCheck = zr.CUSTOM_ELEMENT_HANDLING.tagNameCheck), zr.CUSTOM_ELEMENT_HANDLING && Ji(zr.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ui.attributeNameCheck = zr.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), zr.CUSTOM_ELEMENT_HANDLING && typeof zr.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ui.allowCustomizedBuiltInElements = zr.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), _i && (Mi = !1), ea && (ia = !0), oa && (gi = addToSet({}, text), ui = [], oa.html === !0 && (addToSet(gi, html$1), addToSet(ui, html)), oa.svg === !0 && (addToSet(gi, svg$1), addToSet(ui, svg), addToSet(ui, xml)), oa.svgFilters === !0 && (addToSet(gi, svgFilters), addToSet(ui, svg), addToSet(ui, xml)), oa.mathMl === !0 && (addToSet(gi, mathMl$1), addToSet(ui, mathMl), addToSet(ui, xml))), zr.ADD_TAGS && (gi === Li && (gi = clone(gi)), addToSet(gi, zr.ADD_TAGS, Zi)), zr.ADD_ATTR && (ui === wi && (ui = clone(ui)), addToSet(ui, zr.ADD_ATTR, Zi)), zr.ADD_URI_SAFE_ATTR && addToSet(ua, zr.ADD_URI_SAFE_ATTR, Zi), zr.FORBID_CONTENTS && (Gi === ha && (Gi = clone(Gi)), addToSet(Gi, zr.FORBID_CONTENTS, Zi)), Ia && (gi["#text"] = !0), Ci && addToSet(gi, ["html", "head", "body"]), gi.table && (addToSet(gi, ["tbody"]), delete yi.tbody), zr.TRUSTED_TYPES_POLICY) {
        if (typeof zr.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof zr.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        Lr = zr.TRUSTED_TYPES_POLICY, Dr = Lr.createHTML("");
      } else
        Lr === void 0 && (Lr = _createTrustedTypesPolicy(Tr, fr)), Lr !== null && typeof Dr == "string" && (Dr = Lr.createHTML(""));
      freeze && freeze(zr), ka = zr;
    }
  }, Va = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), Ca = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]), ja = addToSet({}, ["title", "style", "font", "a", "script"]), ao = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), Wa = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), po = function(zr) {
    let Xr = Ar(zr);
    (!Xr || !Xr.tagName) && (Xr = {
      namespaceURI: Xa,
      tagName: "template"
    });
    const ai = stringToLowerCase(zr.tagName), vi = stringToLowerCase(Xr.tagName);
    return Pa[zr.namespaceURI] ? zr.namespaceURI === Aa ? Xr.namespaceURI === Oa ? ai === "svg" : Xr.namespaceURI === Ta ? ai === "svg" && (vi === "annotation-xml" || Va[vi]) : !!ao[ai] : zr.namespaceURI === Ta ? Xr.namespaceURI === Oa ? ai === "math" : Xr.namespaceURI === Aa ? ai === "math" && Ca[vi] : !!Wa[ai] : zr.namespaceURI === Oa ? Xr.namespaceURI === Aa && !Ca[vi] || Xr.namespaceURI === Ta && !Va[vi] ? !1 : !Wa[ai] && (ja[ai] || !ao[ai]) : !!(Ha === "application/xhtml+xml" && Pa[zr.namespaceURI]) : !1;
  }, to = function(zr) {
    arrayPush(ar.removed, {
      element: zr
    });
    try {
      zr.parentNode.removeChild(zr);
    } catch (Xr) {
      zr.remove();
    }
  }, oo = function(zr, Xr) {
    try {
      arrayPush(ar.removed, {
        attribute: Xr.getAttributeNode(zr),
        from: Xr
      });
    } catch (ai) {
      arrayPush(ar.removed, {
        attribute: null,
        from: Xr
      });
    }
    if (Xr.removeAttribute(zr), zr === "is" && !ui[zr])
      if (ia || ea)
        try {
          to(Xr);
        } catch (ai) {
        }
      else
        try {
          Xr.setAttribute(zr, "");
        } catch (ai) {
        }
  }, uo = function(zr) {
    let Xr = null, ai = null;
    if (Ni)
      zr = "<remove></remove>" + zr;
    else {
      const Fi = stringMatch(zr, /^[\r\n\t ]+/);
      ai = Fi && Fi[0];
    }
    Ha === "application/xhtml+xml" && Xa === Oa && (zr = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + zr + "</body></html>");
    const vi = Lr ? Lr.createHTML(zr) : zr;
    if (Xa === Oa)
      try {
        Xr = new kr().parseFromString(vi, Ha);
      } catch (Fi) {
      }
    if (!Xr || !Xr.documentElement) {
      Xr = Nr.createDocument(Xa, "template", null);
      try {
        Xr.documentElement.innerHTML = Ka ? Dr : vi;
      } catch (Fi) {
      }
    }
    const Ti = Xr.body || Xr.documentElement;
    return zr && ai && Ti.insertBefore(cr.createTextNode(ai), Ti.childNodes[0] || null), Xa === Oa ? Wr.call(Xr, Ci ? "html" : "body")[0] : Ci ? Xr.documentElement : Ti;
  }, Io = function(zr) {
    return Hr.call(
      zr.ownerDocument || zr,
      zr,
      // eslint-disable-next-line no-bitwise
      mr.SHOW_ELEMENT | mr.SHOW_COMMENT | mr.SHOW_TEXT,
      null
    );
  }, Lo = function(zr) {
    return zr instanceof yr && (typeof zr.nodeName != "string" || typeof zr.textContent != "string" || typeof zr.removeChild != "function" || !(zr.attributes instanceof br) || typeof zr.removeAttribute != "function" || typeof zr.setAttribute != "function" || typeof zr.namespaceURI != "string" || typeof zr.insertBefore != "function" || typeof zr.hasChildNodes != "function");
  }, Eo = function(zr) {
    return typeof gr == "function" && zr instanceof gr;
  }, lo = function(zr, Xr, ai) {
    oi[zr] && arrayForEach(oi[zr], (vi) => {
      vi.call(ar, Xr, ai, ka);
    });
  }, ya = function(zr) {
    let Xr = null;
    if (lo("beforeSanitizeElements", zr, null), Lo(zr))
      return to(zr), !0;
    const ai = Zi(zr.nodeName);
    if (lo("uponSanitizeElement", zr, {
      tagName: ai,
      allowedTags: gi
    }), zr.hasChildNodes() && !Eo(zr.firstElementChild) && regExpTest(/<[/\w]/g, zr.innerHTML) && regExpTest(/<[/\w]/g, zr.textContent))
      return to(zr), !0;
    if (!gi[ai] || yi[ai]) {
      if (!yi[ai] && sa(ai) && (Ui.tagNameCheck instanceof RegExp && regExpTest(Ui.tagNameCheck, ai) || Ui.tagNameCheck instanceof Function && Ui.tagNameCheck(ai)))
        return !1;
      if (Ia && !Gi[ai]) {
        const vi = Ar(zr) || zr.parentNode, Ti = Cr(zr) || zr.childNodes;
        if (Ti && vi) {
          const Fi = Ti.length;
          for (let ra = Fi - 1; ra >= 0; --ra)
            vi.insertBefore(Er(Ti[ra], !0), xr(zr));
        }
      }
      return to(zr), !0;
    }
    return zr instanceof vr && !po(zr) || (ai === "noscript" || ai === "noembed" || ai === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, zr.innerHTML) ? (to(zr), !0) : (_i && zr.nodeType === 3 && (Xr = zr.textContent, arrayForEach([Jr, Yr, li], (vi) => {
      Xr = stringReplace(Xr, vi, " ");
    }), zr.textContent !== Xr && (arrayPush(ar.removed, {
      element: zr.cloneNode()
    }), zr.textContent = Xr)), lo("afterSanitizeElements", zr, null), !1);
  }, qi = function(zr, Xr, ai) {
    if (ma && (Xr === "id" || Xr === "name") && (ai in cr || ai in zi))
      return !1;
    if (!(Mi && !Vi[Xr] && regExpTest(Si, Xr))) {
      if (!(Oi && regExpTest(ci, Xr))) {
        if (!ui[Xr] || Vi[Xr]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(sa(zr) && (Ui.tagNameCheck instanceof RegExp && regExpTest(Ui.tagNameCheck, zr) || Ui.tagNameCheck instanceof Function && Ui.tagNameCheck(zr)) && (Ui.attributeNameCheck instanceof RegExp && regExpTest(Ui.attributeNameCheck, Xr) || Ui.attributeNameCheck instanceof Function && Ui.attributeNameCheck(Xr)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Xr === "is" && Ui.allowCustomizedBuiltInElements && (Ui.tagNameCheck instanceof RegExp && regExpTest(Ui.tagNameCheck, ai) || Ui.tagNameCheck instanceof Function && Ui.tagNameCheck(ai)))
          )
            return !1;
        } else if (!ua[Xr]) {
          if (!regExpTest(di, stringReplace(ai, Ei, ""))) {
            if (!((Xr === "src" || Xr === "xlink:href" || Xr === "href") && zr !== "script" && stringIndexOf(ai, "data:") === 0 && Ua[zr])) {
              if (!(Ii && !regExpTest(hi, stringReplace(ai, Ei, "")))) {
                if (ai)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, sa = function(zr) {
    return zr.indexOf("-") > 0;
  }, si = function(zr) {
    lo("beforeSanitizeAttributes", zr, null);
    const {
      attributes: Xr
    } = zr;
    if (!Xr)
      return;
    const ai = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: ui
    };
    let vi = Xr.length;
    for (; vi--; ) {
      const Ti = Xr[vi], {
        name: Fi,
        namespaceURI: ra,
        value: pa
      } = Ti, ca = Zi(Fi);
      let da = Fi === "value" ? pa : stringTrim(pa);
      if (ai.attrName = ca, ai.attrValue = da, ai.keepAttr = !0, ai.forceKeepAttr = void 0, lo("uponSanitizeAttribute", zr, ai), da = ai.attrValue, ai.forceKeepAttr || (oo(Fi, zr), !ai.keepAttr))
        continue;
      if (!mi && regExpTest(/\/>/i, da)) {
        oo(Fi, zr);
        continue;
      }
      _i && arrayForEach([Jr, Yr, li], (co) => {
        da = stringReplace(da, co, " ");
      });
      const qa = Zi(zr.nodeName);
      if (qi(qa, ca, da)) {
        if (Ba && (ca === "id" || ca === "name") && (oo(Fi, zr), da = Fa + da), Lr && typeof Tr == "object" && typeof Tr.getAttributeType == "function" && !ra)
          switch (Tr.getAttributeType(qa, ca)) {
            case "TrustedHTML": {
              da = Lr.createHTML(da);
              break;
            }
            case "TrustedScriptURL": {
              da = Lr.createScriptURL(da);
              break;
            }
          }
        try {
          ra ? zr.setAttributeNS(ra, Fi, da) : zr.setAttribute(Fi, da), arrayPop(ar.removed);
        } catch (co) {
        }
      }
    }
    lo("afterSanitizeAttributes", zr, null);
  }, Qr = function Br(zr) {
    let Xr = null;
    const ai = Io(zr);
    for (lo("beforeSanitizeShadowDOM", zr, null); Xr = ai.nextNode(); )
      lo("uponSanitizeShadowNode", Xr, null), !ya(Xr) && (Xr.content instanceof dr && Br(Xr.content), si(Xr));
    lo("afterSanitizeShadowDOM", zr, null);
  };
  return ar.sanitize = function(Br) {
    let zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Xr = null, ai = null, vi = null, Ti = null;
    if (Ka = !Br, Ka && (Br = "<!-->"), typeof Br != "string" && !Eo(Br))
      if (typeof Br.toString == "function") {
        if (Br = Br.toString(), typeof Br != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!ar.isSupported)
      return Br;
    if (Ki || za(zr), ar.removed = [], typeof Br == "string" && (Hi = !1), Hi) {
      if (Br.nodeName) {
        const pa = Zi(Br.nodeName);
        if (!gi[pa] || yi[pa])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Br instanceof gr)
      Xr = uo("<!---->"), ai = Xr.ownerDocument.importNode(Br, !0), ai.nodeType === 1 && ai.nodeName === "BODY" || ai.nodeName === "HTML" ? Xr = ai : Xr.appendChild(ai);
    else {
      if (!ia && !_i && !Ci && // eslint-disable-next-line unicorn/prefer-includes
      Br.indexOf("<") === -1)
        return Lr && la ? Lr.createHTML(Br) : Br;
      if (Xr = uo(Br), !Xr)
        return ia ? null : la ? Dr : "";
    }
    Xr && Ni && to(Xr.firstChild);
    const Fi = Io(Hi ? Br : Xr);
    for (; vi = Fi.nextNode(); )
      ya(vi) || (vi.content instanceof dr && Qr(vi.content), si(vi));
    if (Hi)
      return Br;
    if (ia) {
      if (ea)
        for (Ti = $r.call(Xr.ownerDocument); Xr.firstChild; )
          Ti.appendChild(Xr.firstChild);
      else
        Ti = Xr;
      return (ui.shadowroot || ui.shadowrootmode) && (Ti = Zr.call(ur, Ti, !0)), Ti;
    }
    let ra = Ci ? Xr.outerHTML : Xr.innerHTML;
    return Ci && gi["!doctype"] && Xr.ownerDocument && Xr.ownerDocument.doctype && Xr.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, Xr.ownerDocument.doctype.name) && (ra = "<!DOCTYPE " + Xr.ownerDocument.doctype.name + `>
` + ra), _i && arrayForEach([Jr, Yr, li], (pa) => {
      ra = stringReplace(ra, pa, " ");
    }), Lr && la ? Lr.createHTML(ra) : ra;
  }, ar.setConfig = function() {
    let Br = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    za(Br), Ki = !0;
  }, ar.clearConfig = function() {
    ka = null, Ki = !1;
  }, ar.isValidAttribute = function(Br, zr, Xr) {
    ka || za({});
    const ai = Zi(Br), vi = Zi(zr);
    return qi(ai, vi, Xr);
  }, ar.addHook = function(Br, zr) {
    typeof zr == "function" && (oi[Br] = oi[Br] || [], arrayPush(oi[Br], zr));
  }, ar.removeHook = function(Br) {
    if (oi[Br])
      return arrayPop(oi[Br]);
  }, ar.removeHooks = function(Br) {
    oi[Br] && (oi[Br] = []);
  }, ar.removeAllHooks = function() {
    oi = {};
  }, ar;
}
var purify = createDOMPurify();
function add_css$4(lr) {
  append_styles(lr, "svelte-1nu4fbe", ".tooltip1.svelte-1nu4fbe.svelte-1nu4fbe{position:relative;display:inline-block;cursor:pointer}.tooltip1.svelte-1nu4fbe .tooltip1text.svelte-1nu4fbe{visibility:hidden;width:max-content;background-color:#3e8b0a;color:#fff;text-align:center;border-radius:4px;padding:8px;position:absolute;z-index:1;bottom:calc(100% + 8px);left:100%;transform:translateX(-50%);opacity:0;transition:opacity 0.3s, transform 0.3s;box-shadow:0 2px 4px rgba(0, 0, 0, 0.2)}.tooltip1.svelte-1nu4fbe:hover .tooltip1text.svelte-1nu4fbe,.tooltip1.svelte-1nu4fbe:focus-within .tooltip1text.svelte-1nu4fbe{visibility:visible;opacity:1;transform:translateX(-50%) translateY(-8px)}");
}
const get_tooltip1Text_slot_changes = (lr) => ({}), get_tooltip1Text_slot_context = (lr) => ({});
function create_fragment$4(lr) {
  let ar, cr, ur, fr, dr, hr;
  const gr = (
    /*#slots*/
    lr[2].default
  ), vr = create_slot(
    gr,
    lr,
    /*$$scope*/
    lr[1],
    null
  ), mr = (
    /*#slots*/
    lr[2].tooltip1Text
  ), br = create_slot(
    mr,
    lr,
    /*$$scope*/
    lr[1],
    get_tooltip1Text_slot_context
  );
  return {
    c() {
      ar = element("div"), vr && vr.c(), cr = space(), ur = element("span"), br && br.c(), attr(ur, "class", "tooltip1text svelte-1nu4fbe"), attr(ar, "class", "tooltip1 svelte-1nu4fbe"), attr(ar, "role", "tooltip1");
    },
    m(yr, kr) {
      insert(yr, ar, kr), vr && vr.m(ar, null), append(ar, cr), append(ar, ur), br && br.m(ur, null), fr = !0, dr || (hr = [
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[3]
        ),
        listen(
          ar,
          "mouseout",
          /*mouseout_handler*/
          lr[4]
        ),
        listen(
          ar,
          "focusin",
          /*focusin_handler*/
          lr[5]
        ),
        listen(
          ar,
          "focusout",
          /*focusout_handler*/
          lr[6]
        )
      ], dr = !0);
    },
    p(yr, [kr]) {
      vr && vr.p && (!fr || kr & /*$$scope*/
      2) && update_slot_base(
        vr,
        gr,
        yr,
        /*$$scope*/
        yr[1],
        fr ? get_slot_changes(
          gr,
          /*$$scope*/
          yr[1],
          kr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          yr[1]
        ),
        null
      ), br && br.p && (!fr || kr & /*$$scope*/
      2) && update_slot_base(
        br,
        mr,
        yr,
        /*$$scope*/
        yr[1],
        fr ? get_slot_changes(
          mr,
          /*$$scope*/
          yr[1],
          kr,
          get_tooltip1Text_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          yr[1]
        ),
        get_tooltip1Text_slot_context
      );
    },
    i(yr) {
      fr || (transition_in(vr, yr), transition_in(br, yr), fr = !0);
    },
    o(yr) {
      transition_out(vr, yr), transition_out(br, yr), fr = !1;
    },
    d(yr) {
      yr && detach(ar), vr && vr.d(yr), br && br.d(yr), dr = !1, run_all(hr);
    }
  };
}
function instance$4(lr, ar, cr) {
  let { $$slots: ur = {}, $$scope: fr } = ar, dr = !1;
  const hr = () => cr(0, dr = !0), gr = () => cr(0, dr = !1), vr = () => cr(0, dr = !0), mr = () => cr(0, dr = !1);
  return lr.$$set = (br) => {
    "$$scope" in br && cr(1, fr = br.$$scope);
  }, [
    dr,
    fr,
    ur,
    hr,
    gr,
    vr,
    mr
  ];
}
class Tooltip extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$4, create_fragment$4, safe_not_equal, {}, add_css$4);
  }
}
create_custom_element(Tooltip, {}, ["default", "tooltip1Text"], [], !0);
var toastuiEditorViewer = { exports: {} };
/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function(lr, ar) {
  (function(ur, fr) {
    lr.exports = fr(requireDist$1(), requireDist$2(), requireDist$5(), requireDist$4(), requireDist$3());
  })(self, function(cr, ur, fr, dr, hr) {
    return (
      /******/
      function() {
        var gr = {
          /***/
          368: (
            /***/
            function(yr) {
              /*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
              (function(kr, Tr) {
                yr.exports = Tr();
              })(this, function() {
                function kr(ua) {
                  if (Array.isArray(ua)) {
                    for (var va = 0, Ta = Array(ua.length); va < ua.length; va++)
                      Ta[va] = ua[va];
                    return Ta;
                  } else
                    return Array.from(ua);
                }
                var Tr = Object.hasOwnProperty, _r = Object.setPrototypeOf, Er = Object.isFrozen, xr = Object.getPrototypeOf, Cr = Object.getOwnPropertyDescriptor, Ar = Object.freeze, Lr = Object.seal, Dr = Object.create, Nr = typeof Reflect != "undefined" && Reflect, Hr = Nr.apply, $r = Nr.construct;
                Hr || (Hr = function(va, Ta, Aa) {
                  return va.apply(Ta, Aa);
                }), Ar || (Ar = function(va) {
                  return va;
                }), Lr || (Lr = function(va) {
                  return va;
                }), $r || ($r = function(va, Ta) {
                  return new (Function.prototype.bind.apply(va, [null].concat(kr(Ta))))();
                });
                var Wr = di(Array.prototype.forEach), Zr = di(Array.prototype.pop), oi = di(Array.prototype.push), Jr = di(String.prototype.toLowerCase), Yr = di(String.prototype.match), li = di(String.prototype.replace), Si = di(String.prototype.indexOf), ci = di(String.prototype.trim), hi = di(RegExp.prototype.test), Ei = gi(TypeError);
                function di(ua) {
                  return function(va) {
                    for (var Ta = arguments.length, Aa = Array(Ta > 1 ? Ta - 1 : 0), Oa = 1; Oa < Ta; Oa++)
                      Aa[Oa - 1] = arguments[Oa];
                    return Hr(ua, va, Aa);
                  };
                }
                function gi(ua) {
                  return function() {
                    for (var va = arguments.length, Ta = Array(va), Aa = 0; Aa < va; Aa++)
                      Ta[Aa] = arguments[Aa];
                    return $r(ua, Ta);
                  };
                }
                function Li(ua, va) {
                  _r && _r(ua, null);
                  for (var Ta = va.length; Ta--; ) {
                    var Aa = va[Ta];
                    if (typeof Aa == "string") {
                      var Oa = Jr(Aa);
                      Oa !== Aa && (Er(va) || (va[Ta] = Oa), Aa = Oa);
                    }
                    ua[Aa] = !0;
                  }
                  return ua;
                }
                function ui(ua) {
                  var va = Dr(null), Ta = void 0;
                  for (Ta in ua)
                    Hr(Tr, ua, [Ta]) && (va[Ta] = ua[Ta]);
                  return va;
                }
                function wi(ua, va) {
                  for (; ua !== null; ) {
                    var Ta = Cr(ua, va);
                    if (Ta) {
                      if (Ta.get)
                        return di(Ta.get);
                      if (typeof Ta.value == "function")
                        return di(Ta.value);
                    }
                    ua = xr(ua);
                  }
                  function Aa(Oa) {
                    return console.warn("fallback value for", Oa), null;
                  }
                  return Aa;
                }
                var Ui = Ar(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), yi = Ar(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Vi = Ar(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Oi = Ar(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Mi = Ar(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), Ii = Ar(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), mi = Ar(["#text"]), _i = Ar(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Ci = Ar(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Ki = Ar(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ni = Ar(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), ia = Lr(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ea = Lr(/<%[\s\S]*|[\s\S]*%>/gm), la = Lr(/^data-[\-\w.\u00B7-\uFFFF]/), ma = Lr(/^aria-[\-\w]+$/), Ba = Lr(
                  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
                  // eslint-disable-line no-useless-escape
                ), Fa = Lr(/^(?:\w+script|data):/i), Ia = Lr(
                  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
                  // eslint-disable-line no-control-regex
                ), Hi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ua) {
                  return typeof ua;
                } : function(ua) {
                  return ua && typeof Symbol == "function" && ua.constructor === Symbol && ua !== Symbol.prototype ? "symbol" : typeof ua;
                };
                function oa(ua) {
                  if (Array.isArray(ua)) {
                    for (var va = 0, Ta = Array(ua.length); va < ua.length; va++)
                      Ta[va] = ua[va];
                    return Ta;
                  } else
                    return Array.from(ua);
                }
                var Gi = function() {
                  return typeof window == "undefined" ? null : window;
                }, ha = function(va, Ta) {
                  if ((typeof va == "undefined" ? "undefined" : Hi(va)) !== "object" || typeof va.createPolicy != "function")
                    return null;
                  var Aa = null, Oa = "data-tt-policy-suffix";
                  Ta.currentScript && Ta.currentScript.hasAttribute(Oa) && (Aa = Ta.currentScript.getAttribute(Oa));
                  var Xa = "dompurify" + (Aa ? "#" + Aa : "");
                  try {
                    return va.createPolicy(Xa, {
                      createHTML: function(Pa) {
                        return Pa;
                      }
                    });
                  } catch (Ka) {
                    return console.warn("TrustedTypes policy " + Xa + " could not be created."), null;
                  }
                };
                function Ua() {
                  var ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Gi(), va = function($i) {
                    return Ua($i);
                  };
                  if (va.version = "2.3.3", va.removed = [], !ua || !ua.document || ua.document.nodeType !== 9)
                    return va.isSupported = !1, va;
                  var Ta = ua.document, Aa = ua.document, Oa = ua.DocumentFragment, Xa = ua.HTMLTemplateElement, Ka = ua.Node, Pa = ua.Element, Da = ua.NodeFilter, Ha = ua.NamedNodeMap, $a = Ha === void 0 ? ua.NamedNodeMap || ua.MozNamedAttrMap : Ha, Yi = ua.Text, Zi = ua.Comment, ka = ua.DOMParser, zi = ua.trustedTypes, Ji = Pa.prototype, za = wi(Ji, "cloneNode"), Va = wi(Ji, "nextSibling"), Ca = wi(Ji, "childNodes"), ja = wi(Ji, "parentNode");
                  if (typeof Xa == "function") {
                    var ao = Aa.createElement("template");
                    ao.content && ao.content.ownerDocument && (Aa = ao.content.ownerDocument);
                  }
                  var Wa = ha(zi, Ta), po = Wa && fs ? Wa.createHTML("") : "", to = Aa, oo = to.implementation, uo = to.createNodeIterator, Io = to.createDocumentFragment, Lo = to.getElementsByTagName, Eo = Ta.importNode, lo = {};
                  try {
                    lo = ui(Aa).documentMode ? Aa.documentMode : {};
                  } catch (Ma) {
                  }
                  var ya = {};
                  va.isSupported = typeof ja == "function" && oo && typeof oo.createHTMLDocument != "undefined" && lo !== 9;
                  var qi = ia, sa = ea, si = la, Qr = ma, Br = Fa, zr = Ia, Xr = Ba, ai = null, vi = Li({}, [].concat(oa(Ui), oa(yi), oa(Vi), oa(Mi), oa(mi))), Ti = null, Fi = Li({}, [].concat(oa(_i), oa(Ci), oa(Ki), oa(Ni))), ra = null, pa = null, ca = !0, da = !0, qa = !1, co = !1, yo = !1, Mo = !1, Oo = !1, Do = !1, us = !1, Bo = !0, fs = !1, Us = !0, ds = !0, es = !1, ts = {}, rs = null, zs = Li({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), qs = null, Ss = Li({}, ["audio", "video", "img", "source", "image", "track"]), Is = null, Fs = Li({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), js = "http://www.w3.org/1998/Math/MathML", hs = "http://www.w3.org/2000/svg", xo = "http://www.w3.org/1999/xhtml", ps = xo, ns = !1, Po = void 0, is = ["application/xhtml+xml", "text/html"], kl = "text/html", as = void 0, Xo = null, _l = Aa.createElement("form"), $s = function($i) {
                    Xo && Xo === $i || ((!$i || (typeof $i == "undefined" ? "undefined" : Hi($i)) !== "object") && ($i = {}), $i = ui($i), ai = "ALLOWED_TAGS" in $i ? Li({}, $i.ALLOWED_TAGS) : vi, Ti = "ALLOWED_ATTR" in $i ? Li({}, $i.ALLOWED_ATTR) : Fi, Is = "ADD_URI_SAFE_ATTR" in $i ? Li(ui(Fs), $i.ADD_URI_SAFE_ATTR) : Fs, qs = "ADD_DATA_URI_TAGS" in $i ? Li(ui(Ss), $i.ADD_DATA_URI_TAGS) : Ss, rs = "FORBID_CONTENTS" in $i ? Li({}, $i.FORBID_CONTENTS) : zs, ra = "FORBID_TAGS" in $i ? Li({}, $i.FORBID_TAGS) : {}, pa = "FORBID_ATTR" in $i ? Li({}, $i.FORBID_ATTR) : {}, ts = "USE_PROFILES" in $i ? $i.USE_PROFILES : !1, ca = $i.ALLOW_ARIA_ATTR !== !1, da = $i.ALLOW_DATA_ATTR !== !1, qa = $i.ALLOW_UNKNOWN_PROTOCOLS || !1, co = $i.SAFE_FOR_TEMPLATES || !1, yo = $i.WHOLE_DOCUMENT || !1, Do = $i.RETURN_DOM || !1, us = $i.RETURN_DOM_FRAGMENT || !1, Bo = $i.RETURN_DOM_IMPORT !== !1, fs = $i.RETURN_TRUSTED_TYPE || !1, Oo = $i.FORCE_BODY || !1, Us = $i.SANITIZE_DOM !== !1, ds = $i.KEEP_CONTENT !== !1, es = $i.IN_PLACE || !1, Xr = $i.ALLOWED_URI_REGEXP || Xr, ps = $i.NAMESPACE || xo, Po = // eslint-disable-next-line unicorn/prefer-includes
                    is.indexOf($i.PARSER_MEDIA_TYPE) === -1 ? Po = kl : Po = $i.PARSER_MEDIA_TYPE, as = Po === "application/xhtml+xml" ? function(ga) {
                      return ga;
                    } : Jr, co && (da = !1), us && (Do = !0), ts && (ai = Li({}, [].concat(oa(mi))), Ti = [], ts.html === !0 && (Li(ai, Ui), Li(Ti, _i)), ts.svg === !0 && (Li(ai, yi), Li(Ti, Ci), Li(Ti, Ni)), ts.svgFilters === !0 && (Li(ai, Vi), Li(Ti, Ci), Li(Ti, Ni)), ts.mathMl === !0 && (Li(ai, Mi), Li(Ti, Ki), Li(Ti, Ni))), $i.ADD_TAGS && (ai === vi && (ai = ui(ai)), Li(ai, $i.ADD_TAGS)), $i.ADD_ATTR && (Ti === Fi && (Ti = ui(Ti)), Li(Ti, $i.ADD_ATTR)), $i.ADD_URI_SAFE_ATTR && Li(Is, $i.ADD_URI_SAFE_ATTR), $i.FORBID_CONTENTS && (rs === zs && (rs = ui(rs)), Li(rs, $i.FORBID_CONTENTS)), ds && (ai["#text"] = !0), yo && Li(ai, ["html", "head", "body"]), ai.table && (Li(ai, ["tbody"]), delete ra.tbody), Ar && Ar($i), Xo = $i);
                  }, Ls = Li({}, ["mi", "mo", "mn", "ms", "mtext"]), Vs = Li({}, ["foreignobject", "desc", "title", "annotation-xml"]), gs = Li({}, yi);
                  Li(gs, Vi), Li(gs, Oi);
                  var Ms = Li({}, Mi);
                  Li(Ms, Ii);
                  var ol = function($i) {
                    var ga = ja($i);
                    (!ga || !ga.tagName) && (ga = {
                      namespaceURI: xo,
                      tagName: "template"
                    });
                    var Sa = Jr($i.tagName), ro = Jr(ga.tagName);
                    if ($i.namespaceURI === hs)
                      return ga.namespaceURI === xo ? Sa === "svg" : ga.namespaceURI === js ? Sa === "svg" && (ro === "annotation-xml" || Ls[ro]) : !!gs[Sa];
                    if ($i.namespaceURI === js)
                      return ga.namespaceURI === xo ? Sa === "math" : ga.namespaceURI === hs ? Sa === "math" && Vs[ro] : !!Ms[Sa];
                    if ($i.namespaceURI === xo) {
                      if (ga.namespaceURI === hs && !Vs[ro] || ga.namespaceURI === js && !Ls[ro])
                        return !1;
                      var ko = Li({}, ["title", "style", "font", "a", "script"]);
                      return !Ms[Sa] && (ko[Sa] || !gs[Sa]);
                    }
                    return !1;
                  }, Ho = function($i) {
                    oi(va.removed, { element: $i });
                    try {
                      $i.parentNode.removeChild($i);
                    } catch (ga) {
                      try {
                        $i.outerHTML = po;
                      } catch (Sa) {
                        $i.remove();
                      }
                    }
                  }, sl = function($i, ga) {
                    try {
                      oi(va.removed, {
                        attribute: ga.getAttributeNode($i),
                        from: ga
                      });
                    } catch (Sa) {
                      oi(va.removed, {
                        attribute: null,
                        from: ga
                      });
                    }
                    if (ga.removeAttribute($i), $i === "is" && !Ti[$i])
                      if (Do || us)
                        try {
                          Ho(ga);
                        } catch (Sa) {
                        }
                      else
                        try {
                          ga.setAttribute($i, "");
                        } catch (Sa) {
                        }
                  }, cl = function($i) {
                    var ga = void 0, Sa = void 0;
                    if (Oo)
                      $i = "<remove></remove>" + $i;
                    else {
                      var ro = Yr($i, /^[\r\n\t ]+/);
                      Sa = ro && ro[0];
                    }
                    Po === "application/xhtml+xml" && ($i = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + $i + "</body></html>");
                    var ko = Wa ? Wa.createHTML($i) : $i;
                    if (ps === xo)
                      try {
                        ga = new ka().parseFromString(ko, Po);
                      } catch (Qa) {
                      }
                    if (!ga || !ga.documentElement) {
                      ga = oo.createDocument(ps, "template", null);
                      try {
                        ga.documentElement.innerHTML = ns ? "" : ko;
                      } catch (Qa) {
                      }
                    }
                    var _o = ga.body || ga.documentElement;
                    return $i && Sa && _o.insertBefore(Aa.createTextNode(Sa), _o.childNodes[0] || null), ps === xo ? Lo.call(ga, yo ? "html" : "body")[0] : yo ? ga.documentElement : _o;
                  }, Rs = function($i) {
                    return uo.call($i.ownerDocument || $i, $i, Da.SHOW_ELEMENT | Da.SHOW_COMMENT | Da.SHOW_TEXT, null, !1);
                  }, Ks = function($i) {
                    return $i instanceof Yi || $i instanceof Zi ? !1 : typeof $i.nodeName != "string" || typeof $i.textContent != "string" || typeof $i.removeChild != "function" || !($i.attributes instanceof $a) || typeof $i.removeAttribute != "function" || typeof $i.setAttribute != "function" || typeof $i.namespaceURI != "string" || typeof $i.insertBefore != "function";
                  }, vs = function($i) {
                    return (typeof Ka == "undefined" ? "undefined" : Hi(Ka)) === "object" ? $i instanceof Ka : $i && (typeof $i == "undefined" ? "undefined" : Hi($i)) === "object" && typeof $i.nodeType == "number" && typeof $i.nodeName == "string";
                  }, Uo = function($i, ga, Sa) {
                    ya[$i] && Wr(ya[$i], function(ro) {
                      ro.call(va, ga, Sa, Xo);
                    });
                  }, Gs = function($i) {
                    var ga = void 0;
                    if (Uo("beforeSanitizeElements", $i, null), Ks($i) || Yr($i.nodeName, /[\u0080-\uFFFF]/))
                      return Ho($i), !0;
                    var Sa = as($i.nodeName);
                    if (Uo("uponSanitizeElement", $i, {
                      tagName: Sa,
                      allowedTags: ai
                    }), !vs($i.firstElementChild) && (!vs($i.content) || !vs($i.content.firstElementChild)) && hi(/<[/\w]/g, $i.innerHTML) && hi(/<[/\w]/g, $i.textContent) || Sa === "select" && hi(/<template/i, $i.innerHTML))
                      return Ho($i), !0;
                    if (!ai[Sa] || ra[Sa]) {
                      if (ds && !rs[Sa]) {
                        var ro = ja($i) || $i.parentNode, ko = Ca($i) || $i.childNodes;
                        if (ko && ro)
                          for (var _o = ko.length, Qa = _o - 1; Qa >= 0; --Qa)
                            ro.insertBefore(za(ko[Qa], !0), Va($i));
                      }
                      return Ho($i), !0;
                    }
                    return $i instanceof Pa && !ol($i) || (Sa === "noscript" || Sa === "noembed") && hi(/<\/no(script|embed)/i, $i.innerHTML) ? (Ho($i), !0) : (co && $i.nodeType === 3 && (ga = $i.textContent, ga = li(ga, qi, " "), ga = li(ga, sa, " "), $i.textContent !== ga && (oi(va.removed, { element: $i.cloneNode() }), $i.textContent = ga)), Uo("afterSanitizeElements", $i, null), !1);
                  }, Ws = function($i, ga, Sa) {
                    if (Us && (ga === "id" || ga === "name") && (Sa in Aa || Sa in _l))
                      return !1;
                    if (!(da && !pa[ga] && hi(si, ga))) {
                      if (!(ca && hi(Qr, ga))) {
                        if (!Ti[ga] || pa[ga])
                          return !1;
                        if (!Is[ga]) {
                          if (!hi(Xr, li(Sa, zr, ""))) {
                            if (!((ga === "src" || ga === "xlink:href" || ga === "href") && $i !== "script" && Si(Sa, "data:") === 0 && qs[$i])) {
                              if (!(qa && !hi(Br, li(Sa, zr, "")))) {
                                if (Sa)
                                  return !1;
                              }
                            }
                          }
                        }
                      }
                    }
                    return !0;
                  }, Zs = function($i) {
                    var ga = void 0, Sa = void 0, ro = void 0, ko = void 0;
                    Uo("beforeSanitizeAttributes", $i, null);
                    var _o = $i.attributes;
                    if (_o) {
                      var Qa = {
                        attrName: "",
                        attrValue: "",
                        keepAttr: !0,
                        allowedAttributes: Ti
                      };
                      for (ko = _o.length; ko--; ) {
                        ga = _o[ko];
                        var fo = ga, bs = fo.name, ul = fo.namespaceURI;
                        if (Sa = ci(ga.value), ro = as(bs), Qa.attrName = ro, Qa.attrValue = Sa, Qa.keepAttr = !0, Qa.forceKeepAttr = void 0, Uo("uponSanitizeAttribute", $i, Qa), Sa = Qa.attrValue, !Qa.forceKeepAttr && (sl(bs, $i), !!Qa.keepAttr)) {
                          if (hi(/\/>/i, Sa)) {
                            sl(bs, $i);
                            continue;
                          }
                          co && (Sa = li(Sa, qi, " "), Sa = li(Sa, sa, " "));
                          var wl = as($i.nodeName);
                          if (Ws(wl, ro, Sa))
                            try {
                              ul ? $i.setAttributeNS(ul, bs, Sa) : $i.setAttribute(bs, Sa), Zr(va.removed);
                            } catch (Jo) {
                            }
                        }
                      }
                      Uo("afterSanitizeAttributes", $i, null);
                    }
                  }, Xs = function Ma($i) {
                    var ga = void 0, Sa = Rs($i);
                    for (Uo("beforeSanitizeShadowDOM", $i, null); ga = Sa.nextNode(); )
                      Uo("uponSanitizeShadowNode", ga, null), !Gs(ga) && (ga.content instanceof Oa && Ma(ga.content), Zs(ga));
                    Uo("afterSanitizeShadowDOM", $i, null);
                  };
                  return va.sanitize = function(Ma, $i) {
                    var ga = void 0, Sa = void 0, ro = void 0, ko = void 0, _o = void 0;
                    if (ns = !Ma, ns && (Ma = "<!-->"), typeof Ma != "string" && !vs(Ma)) {
                      if (typeof Ma.toString != "function")
                        throw Ei("toString is not a function");
                      if (Ma = Ma.toString(), typeof Ma != "string")
                        throw Ei("dirty is not a string, aborting");
                    }
                    if (!va.isSupported) {
                      if (Hi(ua.toStaticHTML) === "object" || typeof ua.toStaticHTML == "function") {
                        if (typeof Ma == "string")
                          return ua.toStaticHTML(Ma);
                        if (vs(Ma))
                          return ua.toStaticHTML(Ma.outerHTML);
                      }
                      return Ma;
                    }
                    if (Mo || $s($i), va.removed = [], typeof Ma == "string" && (es = !1), !es)
                      if (Ma instanceof Ka)
                        ga = cl("<!---->"), Sa = ga.ownerDocument.importNode(Ma, !0), Sa.nodeType === 1 && Sa.nodeName === "BODY" || Sa.nodeName === "HTML" ? ga = Sa : ga.appendChild(Sa);
                      else {
                        if (!Do && !co && !yo && // eslint-disable-next-line unicorn/prefer-includes
                        Ma.indexOf("<") === -1)
                          return Wa && fs ? Wa.createHTML(Ma) : Ma;
                        if (ga = cl(Ma), !ga)
                          return Do ? null : po;
                      }
                    ga && Oo && Ho(ga.firstChild);
                    for (var Qa = Rs(es ? Ma : ga); ro = Qa.nextNode(); )
                      ro.nodeType === 3 && ro === ko || Gs(ro) || (ro.content instanceof Oa && Xs(ro.content), Zs(ro), ko = ro);
                    if (ko = null, es)
                      return Ma;
                    if (Do) {
                      if (us)
                        for (_o = Io.call(ga.ownerDocument); ga.firstChild; )
                          _o.appendChild(ga.firstChild);
                      else
                        _o = ga;
                      return Bo && (_o = Eo.call(Ta, _o, !0)), _o;
                    }
                    var fo = yo ? ga.outerHTML : ga.innerHTML;
                    return co && (fo = li(fo, qi, " "), fo = li(fo, sa, " ")), Wa && fs ? Wa.createHTML(fo) : fo;
                  }, va.setConfig = function(Ma) {
                    $s(Ma), Mo = !0;
                  }, va.clearConfig = function() {
                    Xo = null, Mo = !1;
                  }, va.isValidAttribute = function(Ma, $i, ga) {
                    Xo || $s({});
                    var Sa = as(Ma), ro = as($i);
                    return Ws(Sa, ro, ga);
                  }, va.addHook = function(Ma, $i) {
                    typeof $i == "function" && (ya[Ma] = ya[Ma] || [], oi(ya[Ma], $i));
                  }, va.removeHook = function(Ma) {
                    ya[Ma] && Zr(ya[Ma]);
                  }, va.removeHooks = function(Ma) {
                    ya[Ma] && (ya[Ma] = []);
                  }, va.removeAllHooks = function() {
                    ya = {};
                  }, va;
                }
                var eo = Ua();
                return eo;
              });
            }
          ),
          /***/
          928: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(322);
              function Er(xr, Cr, Ar) {
                var Lr, Dr;
                if (Ar = Ar || 0, !_r(Cr))
                  return -1;
                if (Array.prototype.indexOf)
                  return Array.prototype.indexOf.call(Cr, xr, Ar);
                for (Dr = Cr.length, Lr = Ar; Ar >= 0 && Lr < Dr; Lr += 1)
                  if (Cr[Lr] === xr)
                    return Lr;
                return -1;
              }
              yr.exports = Er;
            }
          ),
          /***/
          690: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(322), Er = Tr(893), xr = Tr(956);
              function Cr(Ar, Lr, Dr) {
                _r(Ar) ? Er(Ar, Lr, Dr) : xr(Ar, Lr, Dr);
              }
              yr.exports = Cr;
            }
          ),
          /***/
          893: (
            /***/
            function(yr) {
              function kr(Tr, _r, Er) {
                var xr = 0, Cr = Tr.length;
                for (Er = Er || null; xr < Cr && _r.call(Er, Tr[xr], xr, Tr) !== !1; xr += 1)
                  ;
              }
              yr.exports = kr;
            }
          ),
          /***/
          956: (
            /***/
            function(yr) {
              function kr(Tr, _r, Er) {
                var xr;
                Er = Er || null;
                for (xr in Tr)
                  if (Tr.hasOwnProperty(xr) && _r.call(Er, Tr[xr], xr, Tr) === !1)
                    break;
              }
              yr.exports = kr;
            }
          ),
          /***/
          990: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(893);
              function Er(xr) {
                var Cr;
                try {
                  Cr = Array.prototype.slice.call(xr);
                } catch (Ar) {
                  Cr = [], _r(xr, function(Lr) {
                    Cr.push(Lr);
                  });
                }
                return Cr;
              }
              yr.exports = Er;
            }
          ),
          /***/
          755: (
            /***/
            function(yr) {
              var kr = "_feEventKey";
              function Tr(_r, Er) {
                var xr = _r[kr], Cr;
                return xr || (xr = _r[kr] = {}), Cr = xr[Er], Cr || (Cr = xr[Er] = []), Cr;
              }
              yr.exports = Tr;
            }
          ),
          /***/
          349: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(758), Er = Tr(690), xr = Tr(755);
              function Cr(Dr, Nr, Hr) {
                if (_r(Nr)) {
                  Er(Nr.split(/\s+/g), function($r) {
                    Ar(Dr, $r, Hr);
                  });
                  return;
                }
                Er(Nr, function($r, Wr) {
                  Ar(Dr, Wr, $r);
                });
              }
              function Ar(Dr, Nr, Hr) {
                var $r = xr(Dr, Nr), Wr;
                Hr ? (Er($r, function(Zr, oi) {
                  return Hr === Zr.handler ? (Lr(Dr, Nr, Zr.wrappedHandler), Wr = oi, !1) : !0;
                }), $r.splice(Wr, 1)) : (Er($r, function(Zr) {
                  Lr(Dr, Nr, Zr.wrappedHandler);
                }), $r.splice(0, $r.length));
              }
              function Lr(Dr, Nr, Hr) {
                "removeEventListener" in Dr ? Dr.removeEventListener(Nr, Hr) : "detachEvent" in Dr && Dr.detachEvent("on" + Nr, Hr);
              }
              yr.exports = Cr;
            }
          ),
          /***/
          348: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(758), Er = Tr(690), xr = Tr(755);
              function Cr(Dr, Nr, Hr, $r) {
                if (_r(Nr)) {
                  Er(Nr.split(/\s+/g), function(Wr) {
                    Ar(Dr, Wr, Hr, $r);
                  });
                  return;
                }
                Er(Nr, function(Wr, Zr) {
                  Ar(Dr, Zr, Wr, Hr);
                });
              }
              function Ar(Dr, Nr, Hr, $r) {
                function Wr(Zr) {
                  Hr.call($r || Dr, Zr || window.event);
                }
                "addEventListener" in Dr ? Dr.addEventListener(Nr, Wr) : "attachEvent" in Dr && Dr.attachEvent("on" + Nr, Wr), Lr(Dr, Nr, Hr, Wr);
              }
              function Lr(Dr, Nr, Hr, $r) {
                var Wr = xr(Dr, Nr), Zr = !1;
                Er(Wr, function(oi) {
                  return oi.handler === Hr ? (Zr = !0, !1) : !0;
                }), Zr || Wr.push({
                  handler: Hr,
                  wrappedHandler: $r
                });
              }
              yr.exports = Cr;
            }
          ),
          /***/
          24: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(322), Er = Tr(929);
              function xr(Cr, Ar) {
                if (Ar = _r(Ar) ? Ar.join(" ") : Ar, Ar = Ar.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), Er(Cr.className.baseVal)) {
                  Cr.className = Ar;
                  return;
                }
                Cr.className.baseVal = Ar;
              }
              yr.exports = xr;
            }
          ),
          /***/
          204: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(690), Er = Tr(928), xr = Tr(902), Cr = Tr(24);
              function Ar(Lr) {
                var Dr = Array.prototype.slice.call(arguments, 1), Nr = Lr.classList, Hr = [], $r;
                if (Nr) {
                  _r(Dr, function(Wr) {
                    Lr.classList.add(Wr);
                  });
                  return;
                }
                $r = xr(Lr), $r && (Dr = [].concat($r.split(/\s+/), Dr)), _r(Dr, function(Wr) {
                  Er(Wr, Hr) < 0 && Hr.push(Wr);
                }), Cr(Lr, Hr);
              }
              yr.exports = Ar;
            }
          ),
          /***/
          522: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(758), Er = Tr(690);
              function xr(Cr, Ar, Lr) {
                var Dr = Cr.style;
                if (_r(Ar)) {
                  Dr[Ar] = Lr;
                  return;
                }
                Er(Ar, function(Nr, Hr) {
                  Dr[Hr] = Nr;
                });
              }
              yr.exports = xr;
            }
          ),
          /***/
          902: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(929);
              function Er(xr) {
                return !xr || !xr.className ? "" : _r(xr.className.baseVal) ? xr.className : xr.className.baseVal;
              }
              yr.exports = Er;
            }
          ),
          /***/
          714: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(928), Er = Tr(902);
              function xr(Cr, Ar) {
                var Lr;
                return Cr.classList ? Cr.classList.contains(Ar) : (Lr = Er(Cr).split(/\s+/), _r(Ar, Lr) > -1);
              }
              yr.exports = xr;
            }
          ),
          /***/
          471: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(928), Er = Tr(990), xr = Element.prototype, Cr = xr.matches || xr.webkitMatchesSelector || xr.mozMatchesSelector || xr.msMatchesSelector || function(Lr) {
                var Dr = this.document || this.ownerDocument;
                return _r(this, Er(Dr.querySelectorAll(Lr))) > -1;
              };
              function Ar(Lr, Dr) {
                return Cr.call(Lr, Dr);
              }
              yr.exports = Ar;
            }
          ),
          /***/
          462: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(893), Er = Tr(928), xr = Tr(902), Cr = Tr(24);
              function Ar(Lr) {
                var Dr = Array.prototype.slice.call(arguments, 1), Nr = Lr.classList, Hr, $r;
                if (Nr) {
                  _r(Dr, function(Wr) {
                    Nr.remove(Wr);
                  });
                  return;
                }
                Hr = xr(Lr).split(/\s+/), $r = [], _r(Hr, function(Wr) {
                  Er(Wr, Dr) < 0 && $r.push(Wr);
                }), Cr(Lr, $r);
              }
              yr.exports = Ar;
            }
          ),
          /***/
          969: (
            /***/
            function(yr) {
              function kr(Tr, _r) {
                var Er = Object.prototype.hasOwnProperty, xr, Cr, Ar, Lr;
                for (Ar = 1, Lr = arguments.length; Ar < Lr; Ar += 1) {
                  xr = arguments[Ar];
                  for (Cr in xr)
                    Er.call(xr, Cr) && (Tr[Cr] = xr[Cr]);
                }
                return Tr;
              }
              yr.exports = kr;
            }
          ),
          /***/
          254: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(956);
              function Er(xr, Cr) {
                var Ar = document.createElement("img"), Lr = "";
                return _r(Cr, function(Dr, Nr) {
                  Lr += "&" + Nr + "=" + Dr;
                }), Lr = Lr.substring(1), Ar.src = xr + "?" + Lr, Ar.style.display = "none", document.body.appendChild(Ar), document.body.removeChild(Ar), Ar;
              }
              yr.exports = Er;
            }
          ),
          /***/
          391: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(929), Er = Tr(254), xr = 7 * 24 * 60 * 60 * 1e3;
              function Cr(Lr) {
                var Dr = (/* @__PURE__ */ new Date()).getTime();
                return Dr - Lr > xr;
              }
              function Ar(Lr, Dr) {
                var Nr = "https://www.google-analytics.com/collect", Hr = location.hostname, $r = "event", Wr = "use", Zr = "TOAST UI " + Lr + " for " + Hr + ": Statistics", oi = window.localStorage.getItem(Zr);
                !_r(window.tui) && window.tui.usageStatistics === !1 || oi && !Cr(oi) || (window.localStorage.setItem(Zr, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
                  (document.readyState === "interactive" || document.readyState === "complete") && Er(Nr, {
                    v: 1,
                    t: $r,
                    tid: Dr,
                    cid: Hr,
                    dp: Hr,
                    dh: Lr,
                    el: Lr,
                    ec: Wr
                  });
                }, 1e3));
              }
              yr.exports = Ar;
            }
          ),
          /***/
          322: (
            /***/
            function(yr) {
              function kr(Tr) {
                return Tr instanceof Array;
              }
              yr.exports = kr;
            }
          ),
          /***/
          65: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(929), Er = Tr(934);
              function xr(Cr) {
                return !_r(Cr) && !Er(Cr);
              }
              yr.exports = xr;
            }
          ),
          /***/
          404: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(790);
              function Er(xr) {
                return !_r(xr);
              }
              yr.exports = Er;
            }
          ),
          /***/
          294: (
            /***/
            function(yr) {
              function kr(Tr) {
                return Tr instanceof Function;
              }
              yr.exports = kr;
            }
          ),
          /***/
          934: (
            /***/
            function(yr) {
              function kr(Tr) {
                return Tr === null;
              }
              yr.exports = kr;
            }
          ),
          /***/
          758: (
            /***/
            function(yr) {
              function kr(Tr) {
                return typeof Tr == "string" || Tr instanceof String;
              }
              yr.exports = kr;
            }
          ),
          /***/
          790: (
            /***/
            function(yr, kr, Tr) {
              var _r = Tr(65);
              function Er(xr) {
                return _r(xr) && xr !== !1;
              }
              yr.exports = Er;
            }
          ),
          /***/
          929: (
            /***/
            function(yr) {
              function kr(Tr) {
                return Tr === void 0;
              }
              yr.exports = kr;
            }
          ),
          /***/
          479: (
            /***/
            function(yr) {
              yr.exports = cr;
            }
          ),
          /***/
          481: (
            /***/
            function(yr) {
              yr.exports = ur;
            }
          ),
          /***/
          43: (
            /***/
            function(yr) {
              yr.exports = fr;
            }
          ),
          /***/
          814: (
            /***/
            function(yr) {
              yr.exports = dr;
            }
          ),
          /***/
          311: (
            /***/
            function(yr) {
              yr.exports = hr;
            }
          )
          /******/
        }, vr = {};
        function mr(yr) {
          var kr = vr[yr];
          if (kr !== void 0)
            return kr.exports;
          var Tr = vr[yr] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return gr[yr].call(Tr.exports, Tr, Tr.exports, mr), Tr.exports;
        }
        (function() {
          mr.n = function(yr) {
            var kr = yr && yr.__esModule ? (
              /******/
              function() {
                return yr.default;
              }
            ) : (
              /******/
              function() {
                return yr;
              }
            );
            return mr.d(kr, { a: kr }), kr;
          };
        })(), function() {
          mr.d = function(yr, kr) {
            for (var Tr in kr)
              mr.o(kr, Tr) && !mr.o(yr, Tr) && Object.defineProperty(yr, Tr, { enumerable: !0, get: kr[Tr] });
          };
        }(), function() {
          mr.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (yr) {
              if (typeof window == "object")
                return window;
            }
          }();
        }(), function() {
          mr.o = function(yr, kr) {
            return Object.prototype.hasOwnProperty.call(yr, kr);
          };
        }();
        var br = {};
        return function() {
          mr.d(br, {
            default: function() {
              return (
                /* binding */
                Sj
              );
            }
          });
          var yr = function() {
            return yr = Object.assign || function(Mr) {
              for (var Fr, Gr = 1, ri = arguments.length; Gr < ri; Gr++) {
                Fr = arguments[Gr];
                for (var bi in Fr)
                  Object.prototype.hasOwnProperty.call(Fr, bi) && (Mr[bi] = Fr[bi]);
              }
              return Mr;
            }, yr.apply(this, arguments);
          };
          function kr(Rr, Mr, Fr) {
            if (Fr || arguments.length === 2)
              for (var Gr = 0, ri = Mr.length, bi; Gr < ri; Gr++)
                (bi || !(Gr in Mr)) && (bi || (bi = Array.prototype.slice.call(Mr, 0, Gr)), bi[Gr] = Mr[Gr]);
            return Rr.concat(bi || Array.prototype.slice.call(Mr));
          }
          /*! *****************************************************************************
          	Copyright (c) Microsoft Corporation.
          
          	Permission to use, copy, modify, and/or distribute this software for any
          	purpose with or without fee is hereby granted.
          
          	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          	PERFORMANCE OF THIS SOFTWARE.
          	***************************************************************************** */
          var Tr = function(Rr, Mr) {
            return Tr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Fr, Gr) {
              Fr.__proto__ = Gr;
            } || function(Fr, Gr) {
              for (var ri in Gr)
                Object.prototype.hasOwnProperty.call(Gr, ri) && (Fr[ri] = Gr[ri]);
            }, Tr(Rr, Mr);
          };
          function _r(Rr, Mr) {
            if (typeof Mr != "function" && Mr !== null)
              throw new TypeError("Class extends value " + String(Mr) + " is not a constructor or null");
            Tr(Rr, Mr);
            function Fr() {
              this.constructor = Rr;
            }
            Rr.prototype = Mr === null ? Object.create(Mr) : (Fr.prototype = Mr.prototype, new Fr());
          }
          var Er = function() {
            return Er = Object.assign || function(Mr) {
              for (var Fr, Gr = 1, ri = arguments.length; Gr < ri; Gr++) {
                Fr = arguments[Gr];
                for (var bi in Fr)
                  Object.prototype.hasOwnProperty.call(Fr, bi) && (Mr[bi] = Fr[bi]);
              }
              return Mr;
            }, Er.apply(this, arguments);
          };
          function xr(Rr, Mr, Fr) {
            if (Fr || arguments.length === 2)
              for (var Gr = 0, ri = Mr.length, bi; Gr < ri; Gr++)
                (bi || !(Gr in Mr)) && (bi || (bi = Array.prototype.slice.call(Mr, 0, Gr)), bi[Gr] = Mr[Gr]);
            return Rr.concat(bi || Array.prototype.slice.call(Mr));
          }
          var Cr = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof mr.g != "undefined" ? mr.g : typeof self != "undefined" ? self : {}, Ar = {};
          function Lr(Rr) {
            var Mr, Fr, Gr = Ar[Rr];
            if (Gr)
              return Gr;
            for (Gr = Ar[Rr] = [], Mr = 0; Mr < 128; Mr++)
              Fr = String.fromCharCode(Mr), /^[0-9a-z]$/i.test(Fr) ? Gr.push(Fr) : Gr.push("%" + ("0" + Mr.toString(16).toUpperCase()).slice(-2));
            for (Mr = 0; Mr < Rr.length; Mr++)
              Gr[Rr.charCodeAt(Mr)] = Rr[Mr];
            return Gr;
          }
          function Dr(Rr, Mr, Fr) {
            var Gr, ri, bi, Ai, Di, ta = "";
            for (typeof Mr != "string" && (Fr = Mr, Mr = Dr.defaultChars), typeof Fr == "undefined" && (Fr = !0), Di = Lr(Mr), Gr = 0, ri = Rr.length; Gr < ri; Gr++) {
              if (bi = Rr.charCodeAt(Gr), Fr && bi === 37 && Gr + 2 < ri && /^[0-9a-f]{2}$/i.test(Rr.slice(Gr + 1, Gr + 3))) {
                ta += Rr.slice(Gr, Gr + 3), Gr += 2;
                continue;
              }
              if (bi < 128) {
                ta += Di[bi];
                continue;
              }
              if (bi >= 55296 && bi <= 57343) {
                if (bi >= 55296 && bi <= 56319 && Gr + 1 < ri && (Ai = Rr.charCodeAt(Gr + 1), Ai >= 56320 && Ai <= 57343)) {
                  ta += encodeURIComponent(Rr[Gr] + Rr[Gr + 1]), Gr++;
                  continue;
                }
                ta += "%EF%BF%BD";
                continue;
              }
              ta += encodeURIComponent(Rr[Gr]);
            }
            return ta;
          }
          Dr.defaultChars = ";/?:@&=+$,-_.!~*'()#", Dr.componentChars = "-_.!~*'()";
          var Nr = Dr, Hr = {}, $r = {}, Wr = "Á", Zr = "á", oi = "Ă", Jr = "ă", Yr = "∾", li = "∿", Si = "∾̳", ci = "Â", hi = "â", Ei = "´", di = "А", gi = "а", Li = "Æ", ui = "æ", wi = "⁡", Ui = "𝔄", yi = "𝔞", Vi = "À", Oi = "à", Mi = "ℵ", Ii = "ℵ", mi = "Α", _i = "α", Ci = "Ā", Ki = "ā", Ni = "⨿", ia = "&", ea = "&", la = "⩕", ma = "⩓", Ba = "∧", Fa = "⩜", Ia = "⩘", Hi = "⩚", oa = "∠", Gi = "⦤", ha = "∠", Ua = "⦨", eo = "⦩", ua = "⦪", va = "⦫", Ta = "⦬", Aa = "⦭", Oa = "⦮", Xa = "⦯", Ka = "∡", Pa = "∟", Da = "⊾", Ha = "⦝", $a = "∢", Yi = "Å", Zi = "⍼", ka = "Ą", zi = "ą", Ji = "𝔸", za = "𝕒", Va = "⩯", Ca = "≈", ja = "⩰", ao = "≊", Wa = "≋", po = "'", to = "⁡", oo = "≈", uo = "≊", Io = "Å", Lo = "å", Eo = "𝒜", lo = "𝒶", ya = "≔", qi = "*", sa = "≈", si = "≍", Qr = "Ã", Br = "ã", zr = "Ä", Xr = "ä", ai = "∳", vi = "⨑", Ti = "≌", Fi = "϶", ra = "‵", pa = "∽", ca = "⋍", da = "∖", qa = "⫧", co = "⊽", yo = "⌅", Mo = "⌆", Oo = "⌅", Do = "⎵", us = "⎶", Bo = "≌", fs = "Б", Us = "б", ds = "„", es = "∵", ts = "∵", rs = "∵", zs = "⦰", qs = "϶", Ss = "ℬ", Is = "ℬ", Fs = "Β", js = "β", hs = "ℶ", xo = "≬", ps = "𝔅", ns = "𝔟", Po = "⋂", is = "◯", kl = "⋃", as = "⨀", Xo = "⨁", _l = "⨂", $s = "⨆", Ls = "★", Vs = "▽", gs = "△", Ms = "⨄", ol = "⋁", Ho = "⋀", sl = "⤍", cl = "⧫", Rs = "▪", Ks = "▴", vs = "▾", Uo = "◂", Gs = "▸", Ws = "␣", Zs = "▒", Xs = "░", Ma = "▓", $i = "█", ga = "=⃥", Sa = "≡⃥", ro = "⫭", ko = "⌐", _o = "𝔹", Qa = "𝕓", fo = "⊥", bs = "⊥", ul = "⋈", wl = "⧉", Jo = "┐", Cc = "╕", El = "╖", xl = "╗", Tc = "┌", Ac = "╒", fl = "╓", Ic = "╔", Cl = "─", Ns = "═", Lc = "┬", Mc = "╤", Rc = "╥", Nc = "╦", Oc = "┴", Dc = "╧", Tl = "╨", Dl = "╩", Bc = "⊟", Bl = "⊞", Pc = "⊠", Pl = "┘", Hl = "╛", Hc = "╜", Js = "╝", Uc = "└", Ys = "╘", zc = "╙", qc = "╚", Qs = "│", Ul = "║", zl = "┼", ql = "╪", Fl = "╫", tl = "╬", jl = "┤", rl = "╡", Fc = "╢", ys = "╣", Os = "├", ks = "╞", zo = "╟", Ao = "╠", $l = "‵", jc = "˘", Vl = "˘", $c = "¦", Gl = "𝒷", Wl = "ℬ", dl = "⁏", _s = "∽", Al = "⋍", Zl = "⧅", Sl = "\\", Vc = "⟈", Kc = "•", Gc = "•", Wc = "≎", Xl = "⪮", Jl = "≏", Zc = "≎", Xc = "≏", Jc = "Ć", Yc = "ć", Qc = "⩄", eu = "⩉", Yl = "⩋", tu = "∩", ru = "⋒", Il = "⩇", iu = "⩀", Ql = "ⅅ", au = "∩︀", ou = "⁁", su = "ˇ", lu = "ℭ", ec = "⩍", tc = "Č", rc = "č", cu = "Ç", nc = "ç", uu = "Ĉ", oc = "ĉ", Sr = "∰", qr = "⩌", Ir = "⩐", Ur = "Ċ", jr = "ċ", Vr = "¸", ei = "¸", ti = "⦲", fi = "¢", ki = "·", Ri = "·", ji = "𝔠", Bi = "ℭ", Qi = "Ч", na = "ч", Ea = "✓", La = "✓", fa = "Χ", so = "χ", Za = "ˆ", no = "≗", Ga = "↺", Ja = "↻", ho = "⊛", No = "⊚", qo = "⊝", Co = "⊙", Ko = "®", Ro = "Ⓢ", Ds = "⊖", Go = "⊕", Bs = "⊗", Fo = "○", vo = "⧃", lc = "≗", fu = "⨐", hl = "⫯", ws = "⧂", cc = "∲", uc = "”", kd = "’", _d = "♣", wd = "♣", Ed = ":", xd = "∷", Cd = "⩴", Td = "≔", Ad = "≔", Sd = ",", Ld = "@", Md = "∁", Rd = "∘", Nd = "∁", Od = "ℂ", Dd = "≅", Bd = "⩭", Pd = "≡", Hd = "∮", Ud = "∯", zd = "∮", qd = "𝕔", Fd = "ℂ", jd = "∐", $d = "∐", Vd = "©", Kd = "©", Gd = "℗", Wd = "∳", Zd = "↵", Xd = "✗", Jd = "⨯", Yd = "𝒞", Qd = "𝒸", eh = "⫏", th = "⫑", rh = "⫐", nh = "⫒", ih = "⋯", ah = "⤸", oh = "⤵", sh = "⋞", lh = "⋟", ch = "↶", uh = "⤽", fh = "⩈", dh = "⩆", hh = "≍", ph = "∪", gh = "⋓", vh = "⩊", mh = "⊍", bh = "⩅", yh = "∪︀", kh = "↷", _h = "⤼", wh = "⋞", Eh = "⋟", xh = "⋎", Ch = "⋏", Th = "¤", Ah = "↶", Sh = "↷", Ih = "⋎", Lh = "⋏", Mh = "∲", Rh = "∱", Nh = "⌭", Oh = "†", Dh = "‡", Bh = "ℸ", Ph = "↓", Hh = "↡", Uh = "⇓", zh = "‐", qh = "⫤", Fh = "⊣", jh = "⤏", $h = "˝", Vh = "Ď", Kh = "ď", Gh = "Д", Wh = "д", Zh = "‡", Xh = "⇊", Jh = "ⅅ", Yh = "ⅆ", Qh = "⤑", ep = "⩷", tp = "°", rp = "∇", np = "Δ", ip = "δ", op = "⦱", sp = "⥿", lp = "𝔇", cp = "𝔡", up = "⥥", fp = "⇃", dp = "⇂", hp = "´", pp = "˙", gp = "˝", vp = "`", bp = "˜", yp = "⋄", kp = "⋄", _p = "⋄", Ep = "♦", xp = "♦", Cp = "¨", Tp = "ⅆ", Ap = "ϝ", Sp = "⋲", Ip = "÷", Lp = "÷", Mp = "⋇", Rp = "⋇", Np = "Ђ", Op = "ђ", Dp = "⌞", Bp = "⌍", Pp = "$", Hp = "𝔻", Up = "𝕕", zp = "¨", qp = "˙", jp = "⃜", $p = "≐", Vp = "≑", Kp = "≐", Gp = "∸", Wp = "∔", Zp = "⊡", Xp = "⌆", Jp = "∯", Yp = "¨", Qp = "⇓", tg = "⇐", rg = "⇔", ng = "⫤", ig = "⟸", ag = "⟺", og = "⟹", sg = "⇒", cg = "⊨", ug = "⇑", fg = "⇕", dg = "∥", hg = "⤓", pg = "↓", vg = "↓", mg = "⇓", bg = "⇵", yg = "̑", kg = "⇊", _g = "⇃", wg = "⇂", Eg = "⥐", xg = "⥞", Cg = "⥖", Tg = "↽", Ag = "⥟", Sg = "⥗", Ig = "⇁", Lg = "↧", Mg = "⊤", Rg = "⤐", Ng = "⌟", Og = "⌌", Dg = "𝒟", Bg = "𝒹", Pg = "Ѕ", Hg = "ѕ", Ug = "⧶", zg = "Đ", qg = "đ", Fg = "⋱", jg = "▿", $g = "▾", Vg = "⇵", Kg = "⥯", Wg = "⦦", Zg = "Џ", Xg = "џ", Jg = "⟿", Yg = "É", Qg = "é", ev = "⩮", tv = "Ě", rv = "ě", nv = "Ê", iv = "ê", av = "≖", ov = "≕", sv = "Э", lv = "э", cv = "⩷", uv = "Ė", fv = "ė", dv = "≑", hv = "ⅇ", pv = "≒", gv = "𝔈", vv = "𝔢", mv = "⪚", bv = "È", yv = "è", kv = "⪖", _v = "⪘", wv = "⪙", Ev = "∈", xv = "⏧", Cv = "ℓ", Tv = "⪕", Av = "⪗", Sv = "Ē", Iv = "ē", Lv = "∅", Mv = "∅", Rv = "◻", Nv = "∅", Ov = "▫", Dv = " ", Bv = " ", Pv = " ", Hv = "Ŋ", Uv = "ŋ", zv = " ", qv = "Ę", Fv = "ę", jv = "𝔼", $v = "𝕖", Vv = "⋕", Kv = "⧣", Gv = "⩱", Wv = "ε", Zv = "Ε", Xv = "ε", Jv = "ϵ", Yv = "≖", Qv = "≕", em = "≂", tm = "⪖", rm = "⪕", nm = "⩵", im = "=", am = "≂", om = "≟", sm = "⇌", lm = "≡", cm = "⩸", um = "⧥", fm = "⥱", dm = "≓", hm = "ℯ", gm = "ℰ", vm = "≐", mm = "⩳", bm = "≂", ym = "Η", km = "η", _m = "Ð", wm = "ð", Em = "Ë", xm = "ë", Cm = "€", Tm = "!", Am = "∃", Sm = "∃", Lm = "ℰ", Mm = "ⅇ", Rm = "ⅇ", Nm = "≒", Om = "Ф", Dm = "ф", Bm = "♀", Pm = "ﬃ", Hm = "ﬀ", Um = "ﬄ", zm = "𝔉", qm = "𝔣", Fm = "ﬁ", jm = "◼", $m = "▪", Vm = "fj", Km = "♭", Gm = "ﬂ", Wm = "▱", Zm = "ƒ", Xm = "𝔽", Jm = "𝕗", Ym = "∀", Qm = "∀", eb = "⋔", tb = "⫙", rb = "ℱ", nb = "⨍", ib = "½", ab = "⅓", ob = "¼", sb = "⅕", lb = "⅙", cb = "⅛", ub = "⅔", fb = "⅖", hb = "¾", pb = "⅗", gb = "⅜", vb = "⅘", mb = "⅚", bb = "⅝", yb = "⅞", kb = "⁄", _b = "⌢", wb = "𝒻", Eb = "ℱ", xb = "ǵ", Cb = "Γ", Tb = "γ", Ab = "Ϝ", Sb = "ϝ", Ib = "⪆", Lb = "Ğ", Mb = "ğ", Rb = "Ģ", Nb = "Ĝ", Ob = "ĝ", Db = "Г", Bb = "г", Pb = "Ġ", Hb = "ġ", Ub = "≥", zb = "≧", qb = "⪌", Fb = "⋛", jb = "≥", $b = "≧", Vb = "⩾", Kb = "⪩", Gb = "⩾", Wb = "⪀", Zb = "⪂", Xb = "⪄", Jb = "⋛︀", Yb = "⪔", Qb = "𝔊", e1 = "𝔤", t1 = "≫", r1 = "⋙", n1 = "⋙", i1 = "ℷ", a1 = "Ѓ", o1 = "ѓ", s1 = "⪥", l1 = "≷", c1 = "⪒", u1 = "⪤", f1 = "⪊", d1 = "⪊", h1 = "⪈", p1 = "≩", g1 = "⪈", v1 = "≩", m1 = "⋧", b1 = "𝔾", y1 = "𝕘", k1 = "`", _1 = "≥", w1 = "⋛", E1 = "≧", x1 = "⪢", C1 = "≷", T1 = "⩾", A1 = "≳", S1 = "𝒢", I1 = "ℊ", L1 = "≳", M1 = "⪎", R1 = "⪐", N1 = "⪧", O1 = "⩺", D1 = ">", B1 = ">", P1 = "≫", H1 = "⋗", U1 = "⦕", z1 = "⩼", q1 = "⪆", F1 = "⥸", j1 = "⋗", $1 = "⋛", V1 = "⪌", K1 = "≷", G1 = "≳", W1 = "≩︀", Z1 = "≩︀", X1 = "ˇ", J1 = " ", Y1 = "½", Q1 = "ℋ", ey = "Ъ", ty = "ъ", ry = "⥈", ny = "↔", iy = "⇔", ay = "↭", oy = "^", sy = "ℏ", ly = "Ĥ", cy = "ĥ", uy = "♥", fy = "♥", dy = "…", hy = "⊹", py = "𝔥", gy = "ℌ", vy = "ℋ", my = "⤥", by = "⤦", yy = "⇿", ky = "∻", _y = "↩", wy = "↪", Ey = "𝕙", xy = "ℍ", Cy = "―", Ty = "─", Ay = "𝒽", Sy = "ℋ", Iy = "ℏ", Ly = "Ħ", My = "ħ", Ry = "≎", Ny = "≏", Oy = "⁃", Dy = "‐", By = "Í", Py = "í", Hy = "⁣", Uy = "Î", zy = "î", qy = "И", Fy = "и", jy = "İ", $y = "Е", Vy = "е", Ky = "¡", Gy = "⇔", Wy = "𝔦", Zy = "ℑ", Xy = "Ì", Jy = "ì", Yy = "ⅈ", Qy = "⨌", e0 = "∭", t0 = "⧜", r0 = "℩", n0 = "Ĳ", i0 = "ĳ", a0 = "Ī", o0 = "ī", s0 = "ℑ", l0 = "ⅈ", c0 = "ℐ", u0 = "ℑ", f0 = "ı", d0 = "ℑ", h0 = "⊷", p0 = "Ƶ", g0 = "⇒", v0 = "℅", m0 = "∞", b0 = "⧝", y0 = "ı", k0 = "⊺", _0 = "∫", w0 = "∬", E0 = "ℤ", x0 = "∫", C0 = "⊺", T0 = "⋂", A0 = "⨗", S0 = "⨼", I0 = "⁣", L0 = "⁢", M0 = "Ё", R0 = "ё", N0 = "Į", O0 = "į", D0 = "𝕀", B0 = "𝕚", P0 = "Ι", H0 = "ι", U0 = "⨼", z0 = "¿", q0 = "𝒾", F0 = "ℐ", j0 = "∈", $0 = "⋵", V0 = "⋹", K0 = "⋴", G0 = "⋳", W0 = "∈", Z0 = "⁢", X0 = "Ĩ", J0 = "ĩ", Y0 = "І", Q0 = "і", ek = "Ï", tk = "ï", rk = "Ĵ", nk = "ĵ", ik = "Й", ak = "й", ok = "𝔍", sk = "𝔧", lk = "ȷ", ck = "𝕁", uk = "𝕛", fk = "𝒥", dk = "𝒿", hk = "Ј", pk = "ј", gk = "Є", vk = "є", mk = "Κ", bk = "κ", yk = "ϰ", kk = "Ķ", _k = "ķ", wk = "К", Ek = "к", xk = "𝔎", Ck = "𝔨", Tk = "ĸ", Ak = "Х", Sk = "х", Ik = "Ќ", Lk = "ќ", Mk = "𝕂", Rk = "𝕜", Nk = "𝒦", Ok = "𝓀", Dk = "⇚", Bk = "Ĺ", Pk = "ĺ", Hk = "⦴", Uk = "ℒ", zk = "Λ", qk = "λ", Fk = "⟨", jk = "⟪", $k = "⦑", Vk = "⟨", Kk = "⪅", Gk = "ℒ", Wk = "«", Zk = "⇤", Xk = "⤟", Jk = "←", Yk = "↞", Qk = "⇐", e_ = "⤝", t_ = "↩", r_ = "↫", n_ = "⤹", i_ = "⥳", a_ = "↢", o_ = "⤙", s_ = "⤛", l_ = "⪫", c_ = "⪭", u_ = "⪭︀", f_ = "⤌", d_ = "⤎", h_ = "❲", p_ = "{", g_ = "[", v_ = "⦋", m_ = "⦏", b_ = "⦍", y_ = "Ľ", k_ = "ľ", __ = "Ļ", w_ = "ļ", E_ = "⌈", x_ = "{", C_ = "Л", T_ = "л", A_ = "⤶", S_ = "“", I_ = "„", L_ = "⥧", M_ = "⥋", R_ = "↲", N_ = "≤", O_ = "≦", D_ = "⟨", B_ = "⇤", P_ = "←", H_ = "←", U_ = "⇐", z_ = "⇆", q_ = "↢", F_ = "⌈", j_ = "⟦", $_ = "⥡", V_ = "⥙", K_ = "⇃", G_ = "⌊", W_ = "↽", Z_ = "↼", X_ = "⇇", J_ = "↔", Y_ = "↔", Q_ = "⇔", ew = "⇆", tw = "⇋", rw = "↭", nw = "⥎", iw = "↤", aw = "⊣", ow = "⥚", sw = "⋋", lw = "⧏", cw = "⊲", uw = "⊴", fw = "⥑", dw = "⥠", hw = "⥘", pw = "↿", gw = "⥒", vw = "↼", mw = "⪋", bw = "⋚", yw = "≤", kw = "≦", _w = "⩽", ww = "⪨", Ew = "⩽", xw = "⩿", Cw = "⪁", Tw = "⪃", Aw = "⋚︀", Sw = "⪓", Iw = "⪅", Lw = "⋖", Mw = "⋚", Rw = "⪋", Nw = "⋚", Ow = "≦", Dw = "≶", Bw = "≶", Pw = "⪡", Hw = "≲", Uw = "⩽", zw = "≲", qw = "⥼", Fw = "⌊", jw = "𝔏", $w = "𝔩", Vw = "≶", Kw = "⪑", Gw = "⥢", Ww = "↽", Zw = "↼", Xw = "⥪", Jw = "▄", Yw = "Љ", Qw = "љ", e2 = "⇇", t2 = "≪", r2 = "⋘", n2 = "⌞", i2 = "⇚", a2 = "⥫", o2 = "◺", s2 = "Ŀ", l2 = "ŀ", c2 = "⎰", u2 = "⎰", f2 = "⪉", d2 = "⪉", h2 = "⪇", p2 = "≨", g2 = "⪇", m2 = "≨", b2 = "⋦", y2 = "⟬", k2 = "⇽", _2 = "⟦", w2 = "⟵", E2 = "⟵", x2 = "⟸", C2 = "⟷", T2 = "⟷", A2 = "⟺", S2 = "⟼", I2 = "⟶", L2 = "⟶", M2 = "⟹", R2 = "↫", N2 = "↬", O2 = "⦅", D2 = "𝕃", B2 = "𝕝", P2 = "⨭", H2 = "⨴", U2 = "∗", z2 = "_", q2 = "↙", F2 = "↘", j2 = "◊", $2 = "◊", V2 = "⧫", K2 = "(", G2 = "⦓", W2 = "⇆", Z2 = "⌟", X2 = "⇋", J2 = "⥭", Y2 = "‎", Q2 = "⊿", eE = "‹", tE = "𝓁", rE = "ℒ", nE = "↰", iE = "↰", aE = "≲", oE = "⪍", sE = "⪏", cE = "[", uE = "‘", fE = "‚", dE = "Ł", hE = "ł", pE = "⪦", vE = "⩹", mE = "<", bE = "<", yE = "≪", kE = "⋖", _E = "⋋", wE = "⋉", EE = "⥶", xE = "⩻", CE = "◃", TE = "⊴", AE = "◂", SE = "⦖", IE = "⥊", LE = "⥦", ME = "≨︀", RE = "≨︀", NE = "¯", OE = "♂", DE = "✠", BE = "✠", PE = "↦", HE = "↦", UE = "↧", zE = "↤", qE = "↥", FE = "▮", jE = "⨩", $E = "М", VE = "м", KE = "—", GE = "∺", WE = "∡", ZE = " ", XE = "ℳ", JE = "𝔐", YE = "𝔪", QE = "℧", ex = "µ", tx = "*", nx = "⫰", ix = "∣", ax = "·", ox = "⊟", sx = "−", lx = "∸", cx = "⨪", ux = "∓", fx = "⫛", dx = "…", hx = "∓", px = "⊧", gx = "𝕄", vx = "𝕞", mx = "∓", bx = "𝓂", yx = "ℳ", kx = "∾", _x = "Μ", wx = "μ", Ex = "⊸", xx = "⊸", Cx = "∇", Tx = "Ń", Ax = "ń", Sx = "∠⃒", Ix = "≉", Lx = "⩰̸", Mx = "≋̸", Rx = "ŉ", Nx = "≉", Ox = "♮", Dx = "ℕ", Bx = "♮", Px = " ", Hx = "≎̸", Ux = "≏̸", zx = "⩃", qx = "Ň", Fx = "ň", jx = "Ņ", $x = "ņ", Vx = "≇", Kx = "⩭̸", Gx = "⩂", Wx = "Н", Zx = "н", Xx = "–", Jx = "⤤", Yx = "↗", Qx = "⇗", eC = "↗", tC = "≠", rC = "≐̸", nC = "​", iC = "​", aC = "​", oC = "​", sC = "≢", lC = "⤨", cC = "≂̸", uC = "≫", fC = "≪", dC = `
`, hC = "∄", pC = "∄", gC = "𝔑", vC = "𝔫", mC = "≧̸", bC = "≱", yC = "≱", kC = "≧̸", _C = "⩾̸", wC = "⩾̸", EC = "⋙̸", xC = "≵", CC = "≫⃒", TC = "≯", AC = "≯", SC = "≫̸", IC = "↮", LC = "⇎", MC = "⫲", RC = "∋", NC = "⋼", OC = "⋺", DC = "∋", BC = "Њ", PC = "њ", HC = "↚", UC = "⇍", zC = "‥", qC = "≦̸", FC = "≰", jC = "↚", $C = "⇍", VC = "↮", KC = "⇎", GC = "≰", WC = "≦̸", ZC = "⩽̸", XC = "⩽̸", JC = "≮", YC = "⋘̸", QC = "≴", eT = "≪⃒", tT = "≮", rT = "⋪", nT = "⋬", iT = "≪̸", aT = "∤", oT = "⁠", sT = " ", lT = "𝕟", cT = "ℕ", uT = "⫬", fT = "¬", dT = "≢", hT = "≭", pT = "∦", gT = "∉", vT = "≠", mT = "≂̸", bT = "∄", yT = "≯", kT = "≱", _T = "≧̸", wT = "≫̸", ET = "≹", xT = "⩾̸", CT = "≵", TT = "≎̸", AT = "≏̸", ST = "∉", IT = "⋵̸", MT = "⋹̸", RT = "∉", NT = "⋷", OT = "⋶", DT = "⧏̸", BT = "⋪", PT = "⋬", HT = "≮", UT = "≰", zT = "≸", qT = "≪̸", FT = "⩽̸", jT = "≴", $T = "⪢̸", VT = "⪡̸", KT = "∌", WT = "∌", ZT = "⋾", XT = "⋽", JT = "⊀", YT = "⪯̸", QT = "⋠", e3 = "∌", t3 = "⧐̸", r3 = "⋫", n3 = "⋭", i3 = "⊏̸", a3 = "⋢", o3 = "⊐̸", s3 = "⋣", l3 = "⊂⃒", c3 = "⊈", u3 = "⊁", f3 = "⪰̸", d3 = "⋡", h3 = "≿̸", p3 = "⊃⃒", g3 = "⊉", v3 = "≁", m3 = "≄", b3 = "≇", y3 = "≉", k3 = "∤", _3 = "∦", w3 = "∦", E3 = "⫽⃥", x3 = "∂̸", C3 = "⨔", T3 = "⊀", A3 = "⋠", S3 = "⊀", I3 = "⪯̸", L3 = "⪯̸", M3 = "⤳̸", R3 = "↛", N3 = "⇏", O3 = "↝̸", D3 = "↛", B3 = "⇏", P3 = "⋫", H3 = "⋭", U3 = "⊁", z3 = "⋡", q3 = "⪰̸", F3 = "𝒩", j3 = "𝓃", $3 = "∤", V3 = "∦", K3 = "≁", G3 = "≄", W3 = "≄", Z3 = "∤", X3 = "∦", J3 = "⋢", Y3 = "⋣", Q3 = "⊄", eA = "⫅̸", tA = "⊈", rA = "⊂⃒", nA = "⊈", iA = "⫅̸", aA = "⊁", oA = "⪰̸", sA = "⊅", lA = "⫆̸", cA = "⊉", uA = "⊃⃒", fA = "⊉", dA = "⫆̸", hA = "≹", pA = "Ñ", gA = "ñ", vA = "≸", mA = "⋪", bA = "⋬", yA = "⋫", kA = "⋭", _A = "Ν", wA = "ν", EA = "#", xA = "№", CA = " ", TA = "≍⃒", AA = "⊬", SA = "⊭", IA = "⊮", LA = "⊯", MA = "≥⃒", RA = ">⃒", NA = "⤄", OA = "⧞", DA = "⤂", BA = "≤⃒", PA = "<⃒", HA = "⊴⃒", UA = "⤃", zA = "⊵⃒", qA = "∼⃒", FA = "⤣", jA = "↖", $A = "⇖", VA = "↖", KA = "⤧", GA = "Ó", WA = "ó", ZA = "⊛", XA = "Ô", JA = "ô", YA = "⊚", QA = "О", eS = "о", tS = "⊝", rS = "Ő", nS = "ő", iS = "⨸", aS = "⊙", sS = "⦼", lS = "Œ", cS = "œ", uS = "⦿", fS = "𝔒", dS = "𝔬", hS = "˛", pS = "Ò", gS = "ò", vS = "⧁", mS = "⦵", bS = "Ω", yS = "∮", kS = "↺", _S = "⦾", wS = "⦻", ES = "‾", xS = "⧀", CS = "Ō", TS = "ō", AS = "Ω", SS = "ω", IS = "Ο", LS = "ο", MS = "⦶", RS = "⊖", NS = "𝕆", OS = "𝕠", DS = "⦷", BS = "“", PS = "‘", HS = "⦹", US = "⊕", zS = "↻", qS = "⩔", FS = "∨", jS = "⩝", $S = "ℴ", VS = "ℴ", KS = "ª", GS = "º", WS = "⊶", ZS = "⩖", XS = "⩗", YS = "⩛", QS = "Ⓢ", e5 = "𝒪", t5 = "ℴ", r5 = "Ø", n5 = "ø", i5 = "⊘", a5 = "Õ", o5 = "õ", s5 = "⨶", l5 = "⨷", c5 = "⊗", u5 = "Ö", f5 = "ö", d5 = "⌽", h5 = "‾", p5 = "⏞", g5 = "⎴", v5 = "⏜", m5 = "¶", b5 = "∥", y5 = "∥", k5 = "⫳", _5 = "⫽", w5 = "∂", E5 = "∂", x5 = "П", C5 = "п", T5 = "%", A5 = ".", S5 = "‰", I5 = "⊥", L5 = "‱", M5 = "𝔓", R5 = "𝔭", N5 = "Φ", O5 = "φ", D5 = "ϕ", B5 = "ℳ", P5 = "☎", H5 = "Π", U5 = "π", z5 = "⋔", q5 = "ϖ", F5 = "ℏ", j5 = "ℎ", $5 = "ℏ", V5 = "⨣", K5 = "⊞", G5 = "⨢", W5 = "+", Z5 = "∔", X5 = "⨥", J5 = "⩲", Y5 = "±", Q5 = "±", eI = "⨦", tI = "⨧", rI = "±", nI = "ℌ", iI = "⨕", aI = "𝕡", oI = "ℙ", sI = "£", lI = "⪷", cI = "⪻", uI = "≺", fI = "≼", dI = "⪷", hI = "≺", pI = "≼", gI = "≺", vI = "⪯", mI = "≼", bI = "≾", yI = "⪯", kI = "⪹", _I = "⪵", wI = "⋨", EI = "⪯", xI = "⪳", CI = "≾", TI = "′", AI = "″", SI = "ℙ", II = "⪹", LI = "⪵", MI = "⋨", RI = "∏", NI = "∏", OI = "⌮", DI = "⌒", BI = "⌓", PI = "∝", HI = "∝", UI = "∷", zI = "∝", qI = "≾", FI = "⊰", jI = "𝒫", $I = "𝓅", VI = "Ψ", KI = "ψ", GI = " ", WI = "𝔔", ZI = "𝔮", XI = "⨌", JI = "𝕢", YI = "ℚ", QI = "⁗", eL = "𝒬", tL = "𝓆", rL = "ℍ", nL = "⨖", iL = "?", aL = "≟", oL = '"', sL = '"', lL = "⇛", cL = "∽̱", uL = "Ŕ", fL = "ŕ", dL = "√", hL = "⦳", pL = "⟩", gL = "⟫", vL = "⦒", mL = "⦥", bL = "⟩", yL = "»", kL = "⥵", _L = "⇥", wL = "⤠", EL = "⤳", xL = "→", CL = "↠", TL = "⇒", AL = "⤞", SL = "↪", IL = "↬", LL = "⥅", ML = "⥴", RL = "⤖", NL = "↣", OL = "↝", DL = "⤚", BL = "⤜", PL = "∶", HL = "ℚ", UL = "⤍", zL = "⤏", qL = "⤐", FL = "❳", jL = "}", $L = "]", VL = "⦌", KL = "⦎", GL = "⦐", WL = "Ř", ZL = "ř", XL = "Ŗ", JL = "ŗ", YL = "⌉", QL = "}", e4 = "Р", t4 = "р", r4 = "⤷", n4 = "⥩", i4 = "”", a4 = "”", o4 = "↳", s4 = "ℜ", l4 = "ℛ", c4 = "ℜ", u4 = "ℝ", f4 = "ℜ", d4 = "▭", h4 = "®", p4 = "®", g4 = "∋", v4 = "⇋", m4 = "⥯", b4 = "⥽", y4 = "⌋", k4 = "𝔯", _4 = "ℜ", w4 = "⥤", E4 = "⇁", x4 = "⇀", C4 = "⥬", T4 = "Ρ", A4 = "ρ", S4 = "ϱ", I4 = "⟩", L4 = "⇥", M4 = "→", R4 = "→", N4 = "⇒", O4 = "⇄", D4 = "↣", B4 = "⌉", P4 = "⟧", H4 = "⥝", U4 = "⥕", z4 = "⇂", q4 = "⌋", F4 = "⇁", j4 = "⇀", $4 = "⇄", V4 = "⇌", K4 = "⇉", G4 = "↝", W4 = "↦", Z4 = "⊢", X4 = "⥛", J4 = "⋌", Y4 = "⧐", Q4 = "⊳", eM = "⊵", tM = "⥏", rM = "⥜", nM = "⥔", iM = "↾", aM = "⥓", oM = "⇀", sM = "˚", lM = "≓", cM = "⇄", uM = "⇌", fM = "‏", dM = "⎱", hM = "⎱", pM = "⫮", gM = "⟭", vM = "⇾", mM = "⟧", bM = "⦆", yM = "𝕣", kM = "ℝ", _M = "⨮", wM = "⨵", EM = "⥰", xM = ")", CM = "⦔", TM = "⨒", AM = "⇉", SM = "⇛", IM = "›", LM = "𝓇", MM = "ℛ", RM = "↱", NM = "↱", OM = "]", DM = "’", BM = "’", PM = "⋌", HM = "⋊", UM = "▹", zM = "⊵", qM = "▸", FM = "⧎", jM = "⧴", $M = "⥨", VM = "℞", KM = "Ś", GM = "ś", WM = "‚", ZM = "⪸", XM = "Š", JM = "š", YM = "⪼", QM = "≻", eR = "≽", tR = "⪰", rR = "⪴", nR = "Ş", iR = "ş", aR = "Ŝ", oR = "ŝ", sR = "⪺", lR = "⪶", cR = "⋩", uR = "⨓", fR = "≿", dR = "С", hR = "с", pR = "⊡", gR = "⋅", vR = "⩦", mR = "⤥", bR = "↘", yR = "⇘", kR = "↘", _R = "§", wR = ";", ER = "⤩", xR = "∖", CR = "∖", TR = "✶", AR = "𝔖", SR = "𝔰", IR = "⌢", LR = "♯", MR = "Щ", RR = "щ", NR = "Ш", OR = "ш", DR = "↓", BR = "←", PR = "∣", HR = "∥", UR = "→", zR = "↑", qR = "­", FR = "Σ", jR = "σ", $R = "ς", VR = "ς", KR = "∼", GR = "⩪", WR = "≃", ZR = "≃", XR = "⪞", JR = "⪠", YR = "⪝", QR = "⪟", eN = "≆", tN = "⨤", rN = "⥲", nN = "←", iN = "∘", aN = "∖", oN = "⨳", sN = "⧤", lN = "∣", cN = "⌣", uN = "⪪", fN = "⪬", dN = "⪬︀", hN = "Ь", pN = "ь", gN = "⌿", vN = "⧄", mN = "/", bN = "𝕊", yN = "𝕤", kN = "♠", _N = "♠", wN = "∥", EN = "⊓", xN = "⊓︀", CN = "⊔", TN = "⊔︀", AN = "√", SN = "⊏", IN = "⊑", LN = "⊏", MN = "⊑", RN = "⊐", NN = "⊒", ON = "⊐", DN = "⊒", BN = "□", PN = "□", HN = "⊓", UN = "⊏", zN = "⊑", qN = "⊐", FN = "⊒", jN = "⊔", $N = "▪", VN = "□", KN = "▪", GN = "→", WN = "𝒮", ZN = "𝓈", XN = "∖", JN = "⌣", YN = "⋆", QN = "⋆", e8 = "☆", t8 = "★", r8 = "ϵ", n8 = "ϕ", i8 = "¯", a8 = "⊂", o8 = "⋐", s8 = "⪽", l8 = "⫅", c8 = "⊆", u8 = "⫃", f8 = "⫁", d8 = "⫋", h8 = "⊊", p8 = "⪿", g8 = "⥹", v8 = "⊂", m8 = "⋐", b8 = "⊆", y8 = "⫅", k8 = "⊆", _8 = "⊊", w8 = "⫋", E8 = "⫇", x8 = "⫕", C8 = "⫓", T8 = "⪸", A8 = "≻", S8 = "≽", I8 = "≻", L8 = "⪰", M8 = "≽", R8 = "≿", N8 = "⪰", O8 = "⪺", D8 = "⪶", B8 = "⋩", P8 = "≿", H8 = "∋", U8 = "∑", z8 = "∑", q8 = "♪", F8 = "¹", j8 = "²", $8 = "³", V8 = "⊃", K8 = "⋑", G8 = "⪾", W8 = "⫘", Z8 = "⫆", X8 = "⊇", J8 = "⫄", Y8 = "⊃", Q8 = "⊇", eO = "⟉", tO = "⫗", rO = "⥻", nO = "⫂", iO = "⫌", aO = "⊋", oO = "⫀", sO = "⊃", lO = "⋑", cO = "⊇", uO = "⫆", fO = "⊋", dO = "⫌", hO = "⫈", pO = "⫔", gO = "⫖", vO = "⤦", mO = "↙", bO = "⇙", yO = "↙", kO = "⤪", _O = "ß", wO = "	", EO = "⌖", xO = "Τ", CO = "τ", TO = "⎴", AO = "Ť", SO = "ť", IO = "Ţ", LO = "ţ", MO = "Т", RO = "т", NO = "⃛", OO = "⌕", DO = "𝔗", BO = "𝔱", PO = "∴", HO = "∴", UO = "∴", zO = "Θ", qO = "θ", FO = "ϑ", jO = "ϑ", $O = "≈", VO = "∼", KO = "  ", GO = " ", WO = " ", ZO = "≈", XO = "∼", JO = "Þ", YO = "þ", QO = "˜", e6 = "∼", t6 = "≃", r6 = "≅", n6 = "≈", i6 = "⨱", a6 = "⊠", o6 = "×", s6 = "⨰", l6 = "∭", c6 = "⤨", u6 = "⌶", f6 = "⫱", d6 = "⊤", h6 = "𝕋", p6 = "𝕥", g6 = "⫚", v6 = "⤩", m6 = "‴", b6 = "™", y6 = "™", k6 = "▵", _6 = "▿", w6 = "◃", E6 = "⊴", x6 = "≜", C6 = "▹", T6 = "⊵", A6 = "◬", S6 = "≜", I6 = "⨺", L6 = "⃛", M6 = "⨹", R6 = "⧍", N6 = "⨻", O6 = "⏢", D6 = "𝒯", B6 = "𝓉", P6 = "Ц", H6 = "ц", U6 = "Ћ", z6 = "ћ", q6 = "Ŧ", F6 = "ŧ", j6 = "≬", $6 = "↞", V6 = "↠", K6 = "Ú", G6 = "ú", W6 = "↑", Z6 = "↟", X6 = "⇑", J6 = "⥉", Y6 = "Ў", Q6 = "ў", eD = "Ŭ", tD = "ŭ", rD = "Û", nD = "û", iD = "У", aD = "у", oD = "⇅", sD = "Ű", lD = "ű", cD = "⥮", uD = "⥾", fD = "𝔘", dD = "𝔲", hD = "Ù", pD = "ù", gD = "⥣", vD = "↿", mD = "↾", bD = "▀", yD = "⌜", kD = "⌜", _D = "⌏", wD = "◸", ED = "Ū", xD = "ū", CD = "¨", TD = "_", AD = "⏟", SD = "⎵", ID = "⏝", LD = "⋃", MD = "⊎", RD = "Ų", ND = "ų", OD = "𝕌", BD = "𝕦", PD = "⤒", HD = "↑", UD = "↑", zD = "⇑", qD = "⇅", FD = "↕", jD = "↕", $D = "⇕", VD = "⥮", KD = "↿", GD = "↾", WD = "⊎", ZD = "↖", XD = "↗", JD = "υ", YD = "ϒ", QD = "ϒ", eB = "Υ", tB = "υ", rB = "↥", nB = "⊥", iB = "⇈", aB = "⌝", oB = "⌝", sB = "⌎", lB = "Ů", cB = "ů", uB = "◹", fB = "𝒰", dB = "𝓊", hB = "⋰", pB = "Ũ", gB = "ũ", vB = "▵", mB = "▴", bB = "⇈", yB = "Ü", kB = "ü", _B = "⦧", wB = "⦜", EB = "ϵ", xB = "ϰ", CB = "∅", TB = "ϕ", AB = "ϖ", SB = "∝", IB = "↕", LB = "⇕", MB = "ϱ", RB = "ς", NB = "⊊︀", OB = "⫋︀", DB = "⊋︀", BB = "⫌︀", PB = "ϑ", HB = "⊲", UB = "⊳", zB = "⫨", qB = "⫫", FB = "⫩", jB = "В", $B = "в", VB = "⊢", KB = "⊨", GB = "⊩", WB = "⊫", ZB = "⫦", XB = "⊻", JB = "∨", YB = "⋁", QB = "≚", eP = "⋮", tP = "|", rP = "‖", nP = "|", iP = "‖", aP = "∣", oP = "|", sP = "❘", lP = "≀", cP = " ", uP = "𝔙", fP = "𝔳", dP = "⊲", hP = "⊂⃒", pP = "⊃⃒", gP = "𝕍", vP = "𝕧", mP = "∝", bP = "⊳", yP = "𝒱", kP = "𝓋", _P = "⫋︀", wP = "⊊︀", EP = "⫌︀", xP = "⊋︀", CP = "⊪", TP = "⦚", AP = "Ŵ", SP = "ŵ", IP = "⩟", LP = "∧", MP = "⋀", RP = "≙", NP = "℘", OP = "𝔚", DP = "𝔴", BP = "𝕎", PP = "𝕨", HP = "℘", UP = "≀", zP = "≀", qP = "𝒲", FP = "𝓌", jP = "⋂", $P = "◯", VP = "⋃", KP = "▽", GP = "𝔛", WP = "𝔵", ZP = "⟷", XP = "⟺", JP = "Ξ", YP = "ξ", QP = "⟵", e7 = "⟸", t7 = "⟼", r7 = "⋻", n7 = "⨀", i7 = "𝕏", a7 = "𝕩", o7 = "⨁", s7 = "⨂", l7 = "⟶", c7 = "⟹", u7 = "𝒳", f7 = "𝓍", d7 = "⨆", h7 = "⨄", p7 = "△", g7 = "⋁", v7 = "⋀", m7 = "Ý", b7 = "ý", y7 = "Я", k7 = "я", _7 = "Ŷ", w7 = "ŷ", E7 = "Ы", x7 = "ы", C7 = "¥", T7 = "𝔜", A7 = "𝔶", S7 = "Ї", I7 = "ї", L7 = "𝕐", M7 = "𝕪", R7 = "𝒴", N7 = "𝓎", O7 = "Ю", D7 = "ю", B7 = "ÿ", P7 = "Ÿ", H7 = "Ź", U7 = "ź", z7 = "Ž", q7 = "ž", F7 = "З", j7 = "з", $7 = "Ż", V7 = "ż", K7 = "ℨ", G7 = "​", W7 = "Ζ", Z7 = "ζ", X7 = "𝔷", J7 = "ℨ", Y7 = "Ж", Q7 = "ж", e9 = "⇝", t9 = "𝕫", r9 = "ℤ", n9 = "𝒵", i9 = "𝓏", a9 = "‍", o9 = "‌", Wu = {
            Aacute: Wr,
            aacute: Zr,
            Abreve: oi,
            abreve: Jr,
            ac: Yr,
            acd: li,
            acE: Si,
            Acirc: ci,
            acirc: hi,
            acute: Ei,
            Acy: di,
            acy: gi,
            AElig: Li,
            aelig: ui,
            af: wi,
            Afr: Ui,
            afr: yi,
            Agrave: Vi,
            agrave: Oi,
            alefsym: Mi,
            aleph: Ii,
            Alpha: mi,
            alpha: _i,
            Amacr: Ci,
            amacr: Ki,
            amalg: Ni,
            amp: ia,
            AMP: ea,
            andand: la,
            And: ma,
            and: Ba,
            andd: Fa,
            andslope: Ia,
            andv: Hi,
            ang: oa,
            ange: Gi,
            angle: ha,
            angmsdaa: Ua,
            angmsdab: eo,
            angmsdac: ua,
            angmsdad: va,
            angmsdae: Ta,
            angmsdaf: Aa,
            angmsdag: Oa,
            angmsdah: Xa,
            angmsd: Ka,
            angrt: Pa,
            angrtvb: Da,
            angrtvbd: Ha,
            angsph: $a,
            angst: Yi,
            angzarr: Zi,
            Aogon: ka,
            aogon: zi,
            Aopf: Ji,
            aopf: za,
            apacir: Va,
            ap: Ca,
            apE: ja,
            ape: ao,
            apid: Wa,
            apos: po,
            ApplyFunction: to,
            approx: oo,
            approxeq: uo,
            Aring: Io,
            aring: Lo,
            Ascr: Eo,
            ascr: lo,
            Assign: ya,
            ast: qi,
            asymp: sa,
            asympeq: si,
            Atilde: Qr,
            atilde: Br,
            Auml: zr,
            auml: Xr,
            awconint: ai,
            awint: vi,
            backcong: Ti,
            backepsilon: Fi,
            backprime: ra,
            backsim: pa,
            backsimeq: ca,
            Backslash: da,
            Barv: qa,
            barvee: co,
            barwed: yo,
            Barwed: Mo,
            barwedge: Oo,
            bbrk: Do,
            bbrktbrk: us,
            bcong: Bo,
            Bcy: fs,
            bcy: Us,
            bdquo: ds,
            becaus: es,
            because: ts,
            Because: rs,
            bemptyv: zs,
            bepsi: qs,
            bernou: Ss,
            Bernoullis: Is,
            Beta: Fs,
            beta: js,
            beth: hs,
            between: xo,
            Bfr: ps,
            bfr: ns,
            bigcap: Po,
            bigcirc: is,
            bigcup: kl,
            bigodot: as,
            bigoplus: Xo,
            bigotimes: _l,
            bigsqcup: $s,
            bigstar: Ls,
            bigtriangledown: Vs,
            bigtriangleup: gs,
            biguplus: Ms,
            bigvee: ol,
            bigwedge: Ho,
            bkarow: sl,
            blacklozenge: cl,
            blacksquare: Rs,
            blacktriangle: Ks,
            blacktriangledown: vs,
            blacktriangleleft: Uo,
            blacktriangleright: Gs,
            blank: Ws,
            blk12: Zs,
            blk14: Xs,
            blk34: Ma,
            block: $i,
            bne: ga,
            bnequiv: Sa,
            bNot: ro,
            bnot: ko,
            Bopf: _o,
            bopf: Qa,
            bot: fo,
            bottom: bs,
            bowtie: ul,
            boxbox: wl,
            boxdl: Jo,
            boxdL: Cc,
            boxDl: El,
            boxDL: xl,
            boxdr: Tc,
            boxdR: Ac,
            boxDr: fl,
            boxDR: Ic,
            boxh: Cl,
            boxH: Ns,
            boxhd: Lc,
            boxHd: Mc,
            boxhD: Rc,
            boxHD: Nc,
            boxhu: Oc,
            boxHu: Dc,
            boxhU: Tl,
            boxHU: Dl,
            boxminus: Bc,
            boxplus: Bl,
            boxtimes: Pc,
            boxul: Pl,
            boxuL: Hl,
            boxUl: Hc,
            boxUL: Js,
            boxur: Uc,
            boxuR: Ys,
            boxUr: zc,
            boxUR: qc,
            boxv: Qs,
            boxV: Ul,
            boxvh: zl,
            boxvH: ql,
            boxVh: Fl,
            boxVH: tl,
            boxvl: jl,
            boxvL: rl,
            boxVl: Fc,
            boxVL: ys,
            boxvr: Os,
            boxvR: ks,
            boxVr: zo,
            boxVR: Ao,
            bprime: $l,
            breve: jc,
            Breve: Vl,
            brvbar: $c,
            bscr: Gl,
            Bscr: Wl,
            bsemi: dl,
            bsim: _s,
            bsime: Al,
            bsolb: Zl,
            bsol: Sl,
            bsolhsub: Vc,
            bull: Kc,
            bullet: Gc,
            bump: Wc,
            bumpE: Xl,
            bumpe: Jl,
            Bumpeq: Zc,
            bumpeq: Xc,
            Cacute: Jc,
            cacute: Yc,
            capand: Qc,
            capbrcup: eu,
            capcap: Yl,
            cap: tu,
            Cap: ru,
            capcup: Il,
            capdot: iu,
            CapitalDifferentialD: Ql,
            caps: au,
            caret: ou,
            caron: su,
            Cayleys: lu,
            ccaps: ec,
            Ccaron: tc,
            ccaron: rc,
            Ccedil: cu,
            ccedil: nc,
            Ccirc: uu,
            ccirc: oc,
            Cconint: Sr,
            ccups: qr,
            ccupssm: Ir,
            Cdot: Ur,
            cdot: jr,
            cedil: Vr,
            Cedilla: ei,
            cemptyv: ti,
            cent: fi,
            centerdot: ki,
            CenterDot: Ri,
            cfr: ji,
            Cfr: Bi,
            CHcy: Qi,
            chcy: na,
            check: Ea,
            checkmark: La,
            Chi: fa,
            chi: so,
            circ: Za,
            circeq: no,
            circlearrowleft: Ga,
            circlearrowright: Ja,
            circledast: ho,
            circledcirc: No,
            circleddash: qo,
            CircleDot: Co,
            circledR: Ko,
            circledS: Ro,
            CircleMinus: Ds,
            CirclePlus: Go,
            CircleTimes: Bs,
            cir: Fo,
            cirE: vo,
            cire: lc,
            cirfnint: fu,
            cirmid: hl,
            cirscir: ws,
            ClockwiseContourIntegral: cc,
            CloseCurlyDoubleQuote: uc,
            CloseCurlyQuote: kd,
            clubs: _d,
            clubsuit: wd,
            colon: Ed,
            Colon: xd,
            Colone: Cd,
            colone: Td,
            coloneq: Ad,
            comma: Sd,
            commat: Ld,
            comp: Md,
            compfn: Rd,
            complement: Nd,
            complexes: Od,
            cong: Dd,
            congdot: Bd,
            Congruent: Pd,
            conint: Hd,
            Conint: Ud,
            ContourIntegral: zd,
            copf: qd,
            Copf: Fd,
            coprod: jd,
            Coproduct: $d,
            copy: Vd,
            COPY: Kd,
            copysr: Gd,
            CounterClockwiseContourIntegral: Wd,
            crarr: Zd,
            cross: Xd,
            Cross: Jd,
            Cscr: Yd,
            cscr: Qd,
            csub: eh,
            csube: th,
            csup: rh,
            csupe: nh,
            ctdot: ih,
            cudarrl: ah,
            cudarrr: oh,
            cuepr: sh,
            cuesc: lh,
            cularr: ch,
            cularrp: uh,
            cupbrcap: fh,
            cupcap: dh,
            CupCap: hh,
            cup: ph,
            Cup: gh,
            cupcup: vh,
            cupdot: mh,
            cupor: bh,
            cups: yh,
            curarr: kh,
            curarrm: _h,
            curlyeqprec: wh,
            curlyeqsucc: Eh,
            curlyvee: xh,
            curlywedge: Ch,
            curren: Th,
            curvearrowleft: Ah,
            curvearrowright: Sh,
            cuvee: Ih,
            cuwed: Lh,
            cwconint: Mh,
            cwint: Rh,
            cylcty: Nh,
            dagger: Oh,
            Dagger: Dh,
            daleth: Bh,
            darr: Ph,
            Darr: Hh,
            dArr: Uh,
            dash: zh,
            Dashv: qh,
            dashv: Fh,
            dbkarow: jh,
            dblac: $h,
            Dcaron: Vh,
            dcaron: Kh,
            Dcy: Gh,
            dcy: Wh,
            ddagger: Zh,
            ddarr: Xh,
            DD: Jh,
            dd: Yh,
            DDotrahd: Qh,
            ddotseq: ep,
            deg: tp,
            Del: rp,
            Delta: np,
            delta: ip,
            demptyv: op,
            dfisht: sp,
            Dfr: lp,
            dfr: cp,
            dHar: up,
            dharl: fp,
            dharr: dp,
            DiacriticalAcute: hp,
            DiacriticalDot: pp,
            DiacriticalDoubleAcute: gp,
            DiacriticalGrave: vp,
            DiacriticalTilde: bp,
            diam: yp,
            diamond: kp,
            Diamond: _p,
            diamondsuit: Ep,
            diams: xp,
            die: Cp,
            DifferentialD: Tp,
            digamma: Ap,
            disin: Sp,
            div: Ip,
            divide: Lp,
            divideontimes: Mp,
            divonx: Rp,
            DJcy: Np,
            djcy: Op,
            dlcorn: Dp,
            dlcrop: Bp,
            dollar: Pp,
            Dopf: Hp,
            dopf: Up,
            Dot: zp,
            dot: qp,
            DotDot: jp,
            doteq: $p,
            doteqdot: Vp,
            DotEqual: Kp,
            dotminus: Gp,
            dotplus: Wp,
            dotsquare: Zp,
            doublebarwedge: Xp,
            DoubleContourIntegral: Jp,
            DoubleDot: Yp,
            DoubleDownArrow: Qp,
            DoubleLeftArrow: tg,
            DoubleLeftRightArrow: rg,
            DoubleLeftTee: ng,
            DoubleLongLeftArrow: ig,
            DoubleLongLeftRightArrow: ag,
            DoubleLongRightArrow: og,
            DoubleRightArrow: sg,
            DoubleRightTee: cg,
            DoubleUpArrow: ug,
            DoubleUpDownArrow: fg,
            DoubleVerticalBar: dg,
            DownArrowBar: hg,
            downarrow: pg,
            DownArrow: vg,
            Downarrow: mg,
            DownArrowUpArrow: bg,
            DownBreve: yg,
            downdownarrows: kg,
            downharpoonleft: _g,
            downharpoonright: wg,
            DownLeftRightVector: Eg,
            DownLeftTeeVector: xg,
            DownLeftVectorBar: Cg,
            DownLeftVector: Tg,
            DownRightTeeVector: Ag,
            DownRightVectorBar: Sg,
            DownRightVector: Ig,
            DownTeeArrow: Lg,
            DownTee: Mg,
            drbkarow: Rg,
            drcorn: Ng,
            drcrop: Og,
            Dscr: Dg,
            dscr: Bg,
            DScy: Pg,
            dscy: Hg,
            dsol: Ug,
            Dstrok: zg,
            dstrok: qg,
            dtdot: Fg,
            dtri: jg,
            dtrif: $g,
            duarr: Vg,
            duhar: Kg,
            dwangle: Wg,
            DZcy: Zg,
            dzcy: Xg,
            dzigrarr: Jg,
            Eacute: Yg,
            eacute: Qg,
            easter: ev,
            Ecaron: tv,
            ecaron: rv,
            Ecirc: nv,
            ecirc: iv,
            ecir: av,
            ecolon: ov,
            Ecy: sv,
            ecy: lv,
            eDDot: cv,
            Edot: uv,
            edot: fv,
            eDot: dv,
            ee: hv,
            efDot: pv,
            Efr: gv,
            efr: vv,
            eg: mv,
            Egrave: bv,
            egrave: yv,
            egs: kv,
            egsdot: _v,
            el: wv,
            Element: Ev,
            elinters: xv,
            ell: Cv,
            els: Tv,
            elsdot: Av,
            Emacr: Sv,
            emacr: Iv,
            empty: Lv,
            emptyset: Mv,
            EmptySmallSquare: Rv,
            emptyv: Nv,
            EmptyVerySmallSquare: Ov,
            emsp13: Dv,
            emsp14: Bv,
            emsp: Pv,
            ENG: Hv,
            eng: Uv,
            ensp: zv,
            Eogon: qv,
            eogon: Fv,
            Eopf: jv,
            eopf: $v,
            epar: Vv,
            eparsl: Kv,
            eplus: Gv,
            epsi: Wv,
            Epsilon: Zv,
            epsilon: Xv,
            epsiv: Jv,
            eqcirc: Yv,
            eqcolon: Qv,
            eqsim: em,
            eqslantgtr: tm,
            eqslantless: rm,
            Equal: nm,
            equals: im,
            EqualTilde: am,
            equest: om,
            Equilibrium: sm,
            equiv: lm,
            equivDD: cm,
            eqvparsl: um,
            erarr: fm,
            erDot: dm,
            escr: hm,
            Escr: gm,
            esdot: vm,
            Esim: mm,
            esim: bm,
            Eta: ym,
            eta: km,
            ETH: _m,
            eth: wm,
            Euml: Em,
            euml: xm,
            euro: Cm,
            excl: Tm,
            exist: Am,
            Exists: Sm,
            expectation: Lm,
            exponentiale: Mm,
            ExponentialE: Rm,
            fallingdotseq: Nm,
            Fcy: Om,
            fcy: Dm,
            female: Bm,
            ffilig: Pm,
            fflig: Hm,
            ffllig: Um,
            Ffr: zm,
            ffr: qm,
            filig: Fm,
            FilledSmallSquare: jm,
            FilledVerySmallSquare: $m,
            fjlig: Vm,
            flat: Km,
            fllig: Gm,
            fltns: Wm,
            fnof: Zm,
            Fopf: Xm,
            fopf: Jm,
            forall: Ym,
            ForAll: Qm,
            fork: eb,
            forkv: tb,
            Fouriertrf: rb,
            fpartint: nb,
            frac12: ib,
            frac13: ab,
            frac14: ob,
            frac15: sb,
            frac16: lb,
            frac18: cb,
            frac23: ub,
            frac25: fb,
            frac34: hb,
            frac35: pb,
            frac38: gb,
            frac45: vb,
            frac56: mb,
            frac58: bb,
            frac78: yb,
            frasl: kb,
            frown: _b,
            fscr: wb,
            Fscr: Eb,
            gacute: xb,
            Gamma: Cb,
            gamma: Tb,
            Gammad: Ab,
            gammad: Sb,
            gap: Ib,
            Gbreve: Lb,
            gbreve: Mb,
            Gcedil: Rb,
            Gcirc: Nb,
            gcirc: Ob,
            Gcy: Db,
            gcy: Bb,
            Gdot: Pb,
            gdot: Hb,
            ge: Ub,
            gE: zb,
            gEl: qb,
            gel: Fb,
            geq: jb,
            geqq: $b,
            geqslant: Vb,
            gescc: Kb,
            ges: Gb,
            gesdot: Wb,
            gesdoto: Zb,
            gesdotol: Xb,
            gesl: Jb,
            gesles: Yb,
            Gfr: Qb,
            gfr: e1,
            gg: t1,
            Gg: r1,
            ggg: n1,
            gimel: i1,
            GJcy: a1,
            gjcy: o1,
            gla: s1,
            gl: l1,
            glE: c1,
            glj: u1,
            gnap: f1,
            gnapprox: d1,
            gne: h1,
            gnE: p1,
            gneq: g1,
            gneqq: v1,
            gnsim: m1,
            Gopf: b1,
            gopf: y1,
            grave: k1,
            GreaterEqual: _1,
            GreaterEqualLess: w1,
            GreaterFullEqual: E1,
            GreaterGreater: x1,
            GreaterLess: C1,
            GreaterSlantEqual: T1,
            GreaterTilde: A1,
            Gscr: S1,
            gscr: I1,
            gsim: L1,
            gsime: M1,
            gsiml: R1,
            gtcc: N1,
            gtcir: O1,
            gt: D1,
            GT: B1,
            Gt: P1,
            gtdot: H1,
            gtlPar: U1,
            gtquest: z1,
            gtrapprox: q1,
            gtrarr: F1,
            gtrdot: j1,
            gtreqless: $1,
            gtreqqless: V1,
            gtrless: K1,
            gtrsim: G1,
            gvertneqq: W1,
            gvnE: Z1,
            Hacek: X1,
            hairsp: J1,
            half: Y1,
            hamilt: Q1,
            HARDcy: ey,
            hardcy: ty,
            harrcir: ry,
            harr: ny,
            hArr: iy,
            harrw: ay,
            Hat: oy,
            hbar: sy,
            Hcirc: ly,
            hcirc: cy,
            hearts: uy,
            heartsuit: fy,
            hellip: dy,
            hercon: hy,
            hfr: py,
            Hfr: gy,
            HilbertSpace: vy,
            hksearow: my,
            hkswarow: by,
            hoarr: yy,
            homtht: ky,
            hookleftarrow: _y,
            hookrightarrow: wy,
            hopf: Ey,
            Hopf: xy,
            horbar: Cy,
            HorizontalLine: Ty,
            hscr: Ay,
            Hscr: Sy,
            hslash: Iy,
            Hstrok: Ly,
            hstrok: My,
            HumpDownHump: Ry,
            HumpEqual: Ny,
            hybull: Oy,
            hyphen: Dy,
            Iacute: By,
            iacute: Py,
            ic: Hy,
            Icirc: Uy,
            icirc: zy,
            Icy: qy,
            icy: Fy,
            Idot: jy,
            IEcy: $y,
            iecy: Vy,
            iexcl: Ky,
            iff: Gy,
            ifr: Wy,
            Ifr: Zy,
            Igrave: Xy,
            igrave: Jy,
            ii: Yy,
            iiiint: Qy,
            iiint: e0,
            iinfin: t0,
            iiota: r0,
            IJlig: n0,
            ijlig: i0,
            Imacr: a0,
            imacr: o0,
            image: s0,
            ImaginaryI: l0,
            imagline: c0,
            imagpart: u0,
            imath: f0,
            Im: d0,
            imof: h0,
            imped: p0,
            Implies: g0,
            incare: v0,
            in: "∈",
            infin: m0,
            infintie: b0,
            inodot: y0,
            intcal: k0,
            int: _0,
            Int: w0,
            integers: E0,
            Integral: x0,
            intercal: C0,
            Intersection: T0,
            intlarhk: A0,
            intprod: S0,
            InvisibleComma: I0,
            InvisibleTimes: L0,
            IOcy: M0,
            iocy: R0,
            Iogon: N0,
            iogon: O0,
            Iopf: D0,
            iopf: B0,
            Iota: P0,
            iota: H0,
            iprod: U0,
            iquest: z0,
            iscr: q0,
            Iscr: F0,
            isin: j0,
            isindot: $0,
            isinE: V0,
            isins: K0,
            isinsv: G0,
            isinv: W0,
            it: Z0,
            Itilde: X0,
            itilde: J0,
            Iukcy: Y0,
            iukcy: Q0,
            Iuml: ek,
            iuml: tk,
            Jcirc: rk,
            jcirc: nk,
            Jcy: ik,
            jcy: ak,
            Jfr: ok,
            jfr: sk,
            jmath: lk,
            Jopf: ck,
            jopf: uk,
            Jscr: fk,
            jscr: dk,
            Jsercy: hk,
            jsercy: pk,
            Jukcy: gk,
            jukcy: vk,
            Kappa: mk,
            kappa: bk,
            kappav: yk,
            Kcedil: kk,
            kcedil: _k,
            Kcy: wk,
            kcy: Ek,
            Kfr: xk,
            kfr: Ck,
            kgreen: Tk,
            KHcy: Ak,
            khcy: Sk,
            KJcy: Ik,
            kjcy: Lk,
            Kopf: Mk,
            kopf: Rk,
            Kscr: Nk,
            kscr: Ok,
            lAarr: Dk,
            Lacute: Bk,
            lacute: Pk,
            laemptyv: Hk,
            lagran: Uk,
            Lambda: zk,
            lambda: qk,
            lang: Fk,
            Lang: jk,
            langd: $k,
            langle: Vk,
            lap: Kk,
            Laplacetrf: Gk,
            laquo: Wk,
            larrb: Zk,
            larrbfs: Xk,
            larr: Jk,
            Larr: Yk,
            lArr: Qk,
            larrfs: e_,
            larrhk: t_,
            larrlp: r_,
            larrpl: n_,
            larrsim: i_,
            larrtl: a_,
            latail: o_,
            lAtail: s_,
            lat: l_,
            late: c_,
            lates: u_,
            lbarr: f_,
            lBarr: d_,
            lbbrk: h_,
            lbrace: p_,
            lbrack: g_,
            lbrke: v_,
            lbrksld: m_,
            lbrkslu: b_,
            Lcaron: y_,
            lcaron: k_,
            Lcedil: __,
            lcedil: w_,
            lceil: E_,
            lcub: x_,
            Lcy: C_,
            lcy: T_,
            ldca: A_,
            ldquo: S_,
            ldquor: I_,
            ldrdhar: L_,
            ldrushar: M_,
            ldsh: R_,
            le: N_,
            lE: O_,
            LeftAngleBracket: D_,
            LeftArrowBar: B_,
            leftarrow: P_,
            LeftArrow: H_,
            Leftarrow: U_,
            LeftArrowRightArrow: z_,
            leftarrowtail: q_,
            LeftCeiling: F_,
            LeftDoubleBracket: j_,
            LeftDownTeeVector: $_,
            LeftDownVectorBar: V_,
            LeftDownVector: K_,
            LeftFloor: G_,
            leftharpoondown: W_,
            leftharpoonup: Z_,
            leftleftarrows: X_,
            leftrightarrow: J_,
            LeftRightArrow: Y_,
            Leftrightarrow: Q_,
            leftrightarrows: ew,
            leftrightharpoons: tw,
            leftrightsquigarrow: rw,
            LeftRightVector: nw,
            LeftTeeArrow: iw,
            LeftTee: aw,
            LeftTeeVector: ow,
            leftthreetimes: sw,
            LeftTriangleBar: lw,
            LeftTriangle: cw,
            LeftTriangleEqual: uw,
            LeftUpDownVector: fw,
            LeftUpTeeVector: dw,
            LeftUpVectorBar: hw,
            LeftUpVector: pw,
            LeftVectorBar: gw,
            LeftVector: vw,
            lEg: mw,
            leg: bw,
            leq: yw,
            leqq: kw,
            leqslant: _w,
            lescc: ww,
            les: Ew,
            lesdot: xw,
            lesdoto: Cw,
            lesdotor: Tw,
            lesg: Aw,
            lesges: Sw,
            lessapprox: Iw,
            lessdot: Lw,
            lesseqgtr: Mw,
            lesseqqgtr: Rw,
            LessEqualGreater: Nw,
            LessFullEqual: Ow,
            LessGreater: Dw,
            lessgtr: Bw,
            LessLess: Pw,
            lesssim: Hw,
            LessSlantEqual: Uw,
            LessTilde: zw,
            lfisht: qw,
            lfloor: Fw,
            Lfr: jw,
            lfr: $w,
            lg: Vw,
            lgE: Kw,
            lHar: Gw,
            lhard: Ww,
            lharu: Zw,
            lharul: Xw,
            lhblk: Jw,
            LJcy: Yw,
            ljcy: Qw,
            llarr: e2,
            ll: t2,
            Ll: r2,
            llcorner: n2,
            Lleftarrow: i2,
            llhard: a2,
            lltri: o2,
            Lmidot: s2,
            lmidot: l2,
            lmoustache: c2,
            lmoust: u2,
            lnap: f2,
            lnapprox: d2,
            lne: h2,
            lnE: p2,
            lneq: g2,
            lneqq: m2,
            lnsim: b2,
            loang: y2,
            loarr: k2,
            lobrk: _2,
            longleftarrow: w2,
            LongLeftArrow: E2,
            Longleftarrow: x2,
            longleftrightarrow: C2,
            LongLeftRightArrow: T2,
            Longleftrightarrow: A2,
            longmapsto: S2,
            longrightarrow: I2,
            LongRightArrow: L2,
            Longrightarrow: M2,
            looparrowleft: R2,
            looparrowright: N2,
            lopar: O2,
            Lopf: D2,
            lopf: B2,
            loplus: P2,
            lotimes: H2,
            lowast: U2,
            lowbar: z2,
            LowerLeftArrow: q2,
            LowerRightArrow: F2,
            loz: j2,
            lozenge: $2,
            lozf: V2,
            lpar: K2,
            lparlt: G2,
            lrarr: W2,
            lrcorner: Z2,
            lrhar: X2,
            lrhard: J2,
            lrm: Y2,
            lrtri: Q2,
            lsaquo: eE,
            lscr: tE,
            Lscr: rE,
            lsh: nE,
            Lsh: iE,
            lsim: aE,
            lsime: oE,
            lsimg: sE,
            lsqb: cE,
            lsquo: uE,
            lsquor: fE,
            Lstrok: dE,
            lstrok: hE,
            ltcc: pE,
            ltcir: vE,
            lt: mE,
            LT: bE,
            Lt: yE,
            ltdot: kE,
            lthree: _E,
            ltimes: wE,
            ltlarr: EE,
            ltquest: xE,
            ltri: CE,
            ltrie: TE,
            ltrif: AE,
            ltrPar: SE,
            lurdshar: IE,
            luruhar: LE,
            lvertneqq: ME,
            lvnE: RE,
            macr: NE,
            male: OE,
            malt: DE,
            maltese: BE,
            Map: "⤅",
            map: PE,
            mapsto: HE,
            mapstodown: UE,
            mapstoleft: zE,
            mapstoup: qE,
            marker: FE,
            mcomma: jE,
            Mcy: $E,
            mcy: VE,
            mdash: KE,
            mDDot: GE,
            measuredangle: WE,
            MediumSpace: ZE,
            Mellintrf: XE,
            Mfr: JE,
            mfr: YE,
            mho: QE,
            micro: ex,
            midast: tx,
            midcir: nx,
            mid: ix,
            middot: ax,
            minusb: ox,
            minus: sx,
            minusd: lx,
            minusdu: cx,
            MinusPlus: ux,
            mlcp: fx,
            mldr: dx,
            mnplus: hx,
            models: px,
            Mopf: gx,
            mopf: vx,
            mp: mx,
            mscr: bx,
            Mscr: yx,
            mstpos: kx,
            Mu: _x,
            mu: wx,
            multimap: Ex,
            mumap: xx,
            nabla: Cx,
            Nacute: Tx,
            nacute: Ax,
            nang: Sx,
            nap: Ix,
            napE: Lx,
            napid: Mx,
            napos: Rx,
            napprox: Nx,
            natural: Ox,
            naturals: Dx,
            natur: Bx,
            nbsp: Px,
            nbump: Hx,
            nbumpe: Ux,
            ncap: zx,
            Ncaron: qx,
            ncaron: Fx,
            Ncedil: jx,
            ncedil: $x,
            ncong: Vx,
            ncongdot: Kx,
            ncup: Gx,
            Ncy: Wx,
            ncy: Zx,
            ndash: Xx,
            nearhk: Jx,
            nearr: Yx,
            neArr: Qx,
            nearrow: eC,
            ne: tC,
            nedot: rC,
            NegativeMediumSpace: nC,
            NegativeThickSpace: iC,
            NegativeThinSpace: aC,
            NegativeVeryThinSpace: oC,
            nequiv: sC,
            nesear: lC,
            nesim: cC,
            NestedGreaterGreater: uC,
            NestedLessLess: fC,
            NewLine: dC,
            nexist: hC,
            nexists: pC,
            Nfr: gC,
            nfr: vC,
            ngE: mC,
            nge: bC,
            ngeq: yC,
            ngeqq: kC,
            ngeqslant: _C,
            nges: wC,
            nGg: EC,
            ngsim: xC,
            nGt: CC,
            ngt: TC,
            ngtr: AC,
            nGtv: SC,
            nharr: IC,
            nhArr: LC,
            nhpar: MC,
            ni: RC,
            nis: NC,
            nisd: OC,
            niv: DC,
            NJcy: BC,
            njcy: PC,
            nlarr: HC,
            nlArr: UC,
            nldr: zC,
            nlE: qC,
            nle: FC,
            nleftarrow: jC,
            nLeftarrow: $C,
            nleftrightarrow: VC,
            nLeftrightarrow: KC,
            nleq: GC,
            nleqq: WC,
            nleqslant: ZC,
            nles: XC,
            nless: JC,
            nLl: YC,
            nlsim: QC,
            nLt: eT,
            nlt: tT,
            nltri: rT,
            nltrie: nT,
            nLtv: iT,
            nmid: aT,
            NoBreak: oT,
            NonBreakingSpace: sT,
            nopf: lT,
            Nopf: cT,
            Not: uT,
            not: fT,
            NotCongruent: dT,
            NotCupCap: hT,
            NotDoubleVerticalBar: pT,
            NotElement: gT,
            NotEqual: vT,
            NotEqualTilde: mT,
            NotExists: bT,
            NotGreater: yT,
            NotGreaterEqual: kT,
            NotGreaterFullEqual: _T,
            NotGreaterGreater: wT,
            NotGreaterLess: ET,
            NotGreaterSlantEqual: xT,
            NotGreaterTilde: CT,
            NotHumpDownHump: TT,
            NotHumpEqual: AT,
            notin: ST,
            notindot: IT,
            notinE: MT,
            notinva: RT,
            notinvb: NT,
            notinvc: OT,
            NotLeftTriangleBar: DT,
            NotLeftTriangle: BT,
            NotLeftTriangleEqual: PT,
            NotLess: HT,
            NotLessEqual: UT,
            NotLessGreater: zT,
            NotLessLess: qT,
            NotLessSlantEqual: FT,
            NotLessTilde: jT,
            NotNestedGreaterGreater: $T,
            NotNestedLessLess: VT,
            notni: KT,
            notniva: WT,
            notnivb: ZT,
            notnivc: XT,
            NotPrecedes: JT,
            NotPrecedesEqual: YT,
            NotPrecedesSlantEqual: QT,
            NotReverseElement: e3,
            NotRightTriangleBar: t3,
            NotRightTriangle: r3,
            NotRightTriangleEqual: n3,
            NotSquareSubset: i3,
            NotSquareSubsetEqual: a3,
            NotSquareSuperset: o3,
            NotSquareSupersetEqual: s3,
            NotSubset: l3,
            NotSubsetEqual: c3,
            NotSucceeds: u3,
            NotSucceedsEqual: f3,
            NotSucceedsSlantEqual: d3,
            NotSucceedsTilde: h3,
            NotSuperset: p3,
            NotSupersetEqual: g3,
            NotTilde: v3,
            NotTildeEqual: m3,
            NotTildeFullEqual: b3,
            NotTildeTilde: y3,
            NotVerticalBar: k3,
            nparallel: _3,
            npar: w3,
            nparsl: E3,
            npart: x3,
            npolint: C3,
            npr: T3,
            nprcue: A3,
            nprec: S3,
            npreceq: I3,
            npre: L3,
            nrarrc: M3,
            nrarr: R3,
            nrArr: N3,
            nrarrw: O3,
            nrightarrow: D3,
            nRightarrow: B3,
            nrtri: P3,
            nrtrie: H3,
            nsc: U3,
            nsccue: z3,
            nsce: q3,
            Nscr: F3,
            nscr: j3,
            nshortmid: $3,
            nshortparallel: V3,
            nsim: K3,
            nsime: G3,
            nsimeq: W3,
            nsmid: Z3,
            nspar: X3,
            nsqsube: J3,
            nsqsupe: Y3,
            nsub: Q3,
            nsubE: eA,
            nsube: tA,
            nsubset: rA,
            nsubseteq: nA,
            nsubseteqq: iA,
            nsucc: aA,
            nsucceq: oA,
            nsup: sA,
            nsupE: lA,
            nsupe: cA,
            nsupset: uA,
            nsupseteq: fA,
            nsupseteqq: dA,
            ntgl: hA,
            Ntilde: pA,
            ntilde: gA,
            ntlg: vA,
            ntriangleleft: mA,
            ntrianglelefteq: bA,
            ntriangleright: yA,
            ntrianglerighteq: kA,
            Nu: _A,
            nu: wA,
            num: EA,
            numero: xA,
            numsp: CA,
            nvap: TA,
            nvdash: AA,
            nvDash: SA,
            nVdash: IA,
            nVDash: LA,
            nvge: MA,
            nvgt: RA,
            nvHarr: NA,
            nvinfin: OA,
            nvlArr: DA,
            nvle: BA,
            nvlt: PA,
            nvltrie: HA,
            nvrArr: UA,
            nvrtrie: zA,
            nvsim: qA,
            nwarhk: FA,
            nwarr: jA,
            nwArr: $A,
            nwarrow: VA,
            nwnear: KA,
            Oacute: GA,
            oacute: WA,
            oast: ZA,
            Ocirc: XA,
            ocirc: JA,
            ocir: YA,
            Ocy: QA,
            ocy: eS,
            odash: tS,
            Odblac: rS,
            odblac: nS,
            odiv: iS,
            odot: aS,
            odsold: sS,
            OElig: lS,
            oelig: cS,
            ofcir: uS,
            Ofr: fS,
            ofr: dS,
            ogon: hS,
            Ograve: pS,
            ograve: gS,
            ogt: vS,
            ohbar: mS,
            ohm: bS,
            oint: yS,
            olarr: kS,
            olcir: _S,
            olcross: wS,
            oline: ES,
            olt: xS,
            Omacr: CS,
            omacr: TS,
            Omega: AS,
            omega: SS,
            Omicron: IS,
            omicron: LS,
            omid: MS,
            ominus: RS,
            Oopf: NS,
            oopf: OS,
            opar: DS,
            OpenCurlyDoubleQuote: BS,
            OpenCurlyQuote: PS,
            operp: HS,
            oplus: US,
            orarr: zS,
            Or: qS,
            or: FS,
            ord: jS,
            order: $S,
            orderof: VS,
            ordf: KS,
            ordm: GS,
            origof: WS,
            oror: ZS,
            orslope: XS,
            orv: YS,
            oS: QS,
            Oscr: e5,
            oscr: t5,
            Oslash: r5,
            oslash: n5,
            osol: i5,
            Otilde: a5,
            otilde: o5,
            otimesas: s5,
            Otimes: l5,
            otimes: c5,
            Ouml: u5,
            ouml: f5,
            ovbar: d5,
            OverBar: h5,
            OverBrace: p5,
            OverBracket: g5,
            OverParenthesis: v5,
            para: m5,
            parallel: b5,
            par: y5,
            parsim: k5,
            parsl: _5,
            part: w5,
            PartialD: E5,
            Pcy: x5,
            pcy: C5,
            percnt: T5,
            period: A5,
            permil: S5,
            perp: I5,
            pertenk: L5,
            Pfr: M5,
            pfr: R5,
            Phi: N5,
            phi: O5,
            phiv: D5,
            phmmat: B5,
            phone: P5,
            Pi: H5,
            pi: U5,
            pitchfork: z5,
            piv: q5,
            planck: F5,
            planckh: j5,
            plankv: $5,
            plusacir: V5,
            plusb: K5,
            pluscir: G5,
            plus: W5,
            plusdo: Z5,
            plusdu: X5,
            pluse: J5,
            PlusMinus: Y5,
            plusmn: Q5,
            plussim: eI,
            plustwo: tI,
            pm: rI,
            Poincareplane: nI,
            pointint: iI,
            popf: aI,
            Popf: oI,
            pound: sI,
            prap: lI,
            Pr: cI,
            pr: uI,
            prcue: fI,
            precapprox: dI,
            prec: hI,
            preccurlyeq: pI,
            Precedes: gI,
            PrecedesEqual: vI,
            PrecedesSlantEqual: mI,
            PrecedesTilde: bI,
            preceq: yI,
            precnapprox: kI,
            precneqq: _I,
            precnsim: wI,
            pre: EI,
            prE: xI,
            precsim: CI,
            prime: TI,
            Prime: AI,
            primes: SI,
            prnap: II,
            prnE: LI,
            prnsim: MI,
            prod: RI,
            Product: NI,
            profalar: OI,
            profline: DI,
            profsurf: BI,
            prop: PI,
            Proportional: HI,
            Proportion: UI,
            propto: zI,
            prsim: qI,
            prurel: FI,
            Pscr: jI,
            pscr: $I,
            Psi: VI,
            psi: KI,
            puncsp: GI,
            Qfr: WI,
            qfr: ZI,
            qint: XI,
            qopf: JI,
            Qopf: YI,
            qprime: QI,
            Qscr: eL,
            qscr: tL,
            quaternions: rL,
            quatint: nL,
            quest: iL,
            questeq: aL,
            quot: oL,
            QUOT: sL,
            rAarr: lL,
            race: cL,
            Racute: uL,
            racute: fL,
            radic: dL,
            raemptyv: hL,
            rang: pL,
            Rang: gL,
            rangd: vL,
            range: mL,
            rangle: bL,
            raquo: yL,
            rarrap: kL,
            rarrb: _L,
            rarrbfs: wL,
            rarrc: EL,
            rarr: xL,
            Rarr: CL,
            rArr: TL,
            rarrfs: AL,
            rarrhk: SL,
            rarrlp: IL,
            rarrpl: LL,
            rarrsim: ML,
            Rarrtl: RL,
            rarrtl: NL,
            rarrw: OL,
            ratail: DL,
            rAtail: BL,
            ratio: PL,
            rationals: HL,
            rbarr: UL,
            rBarr: zL,
            RBarr: qL,
            rbbrk: FL,
            rbrace: jL,
            rbrack: $L,
            rbrke: VL,
            rbrksld: KL,
            rbrkslu: GL,
            Rcaron: WL,
            rcaron: ZL,
            Rcedil: XL,
            rcedil: JL,
            rceil: YL,
            rcub: QL,
            Rcy: e4,
            rcy: t4,
            rdca: r4,
            rdldhar: n4,
            rdquo: i4,
            rdquor: a4,
            rdsh: o4,
            real: s4,
            realine: l4,
            realpart: c4,
            reals: u4,
            Re: f4,
            rect: d4,
            reg: h4,
            REG: p4,
            ReverseElement: g4,
            ReverseEquilibrium: v4,
            ReverseUpEquilibrium: m4,
            rfisht: b4,
            rfloor: y4,
            rfr: k4,
            Rfr: _4,
            rHar: w4,
            rhard: E4,
            rharu: x4,
            rharul: C4,
            Rho: T4,
            rho: A4,
            rhov: S4,
            RightAngleBracket: I4,
            RightArrowBar: L4,
            rightarrow: M4,
            RightArrow: R4,
            Rightarrow: N4,
            RightArrowLeftArrow: O4,
            rightarrowtail: D4,
            RightCeiling: B4,
            RightDoubleBracket: P4,
            RightDownTeeVector: H4,
            RightDownVectorBar: U4,
            RightDownVector: z4,
            RightFloor: q4,
            rightharpoondown: F4,
            rightharpoonup: j4,
            rightleftarrows: $4,
            rightleftharpoons: V4,
            rightrightarrows: K4,
            rightsquigarrow: G4,
            RightTeeArrow: W4,
            RightTee: Z4,
            RightTeeVector: X4,
            rightthreetimes: J4,
            RightTriangleBar: Y4,
            RightTriangle: Q4,
            RightTriangleEqual: eM,
            RightUpDownVector: tM,
            RightUpTeeVector: rM,
            RightUpVectorBar: nM,
            RightUpVector: iM,
            RightVectorBar: aM,
            RightVector: oM,
            ring: sM,
            risingdotseq: lM,
            rlarr: cM,
            rlhar: uM,
            rlm: fM,
            rmoustache: dM,
            rmoust: hM,
            rnmid: pM,
            roang: gM,
            roarr: vM,
            robrk: mM,
            ropar: bM,
            ropf: yM,
            Ropf: kM,
            roplus: _M,
            rotimes: wM,
            RoundImplies: EM,
            rpar: xM,
            rpargt: CM,
            rppolint: TM,
            rrarr: AM,
            Rrightarrow: SM,
            rsaquo: IM,
            rscr: LM,
            Rscr: MM,
            rsh: RM,
            Rsh: NM,
            rsqb: OM,
            rsquo: DM,
            rsquor: BM,
            rthree: PM,
            rtimes: HM,
            rtri: UM,
            rtrie: zM,
            rtrif: qM,
            rtriltri: FM,
            RuleDelayed: jM,
            ruluhar: $M,
            rx: VM,
            Sacute: KM,
            sacute: GM,
            sbquo: WM,
            scap: ZM,
            Scaron: XM,
            scaron: JM,
            Sc: YM,
            sc: QM,
            sccue: eR,
            sce: tR,
            scE: rR,
            Scedil: nR,
            scedil: iR,
            Scirc: aR,
            scirc: oR,
            scnap: sR,
            scnE: lR,
            scnsim: cR,
            scpolint: uR,
            scsim: fR,
            Scy: dR,
            scy: hR,
            sdotb: pR,
            sdot: gR,
            sdote: vR,
            searhk: mR,
            searr: bR,
            seArr: yR,
            searrow: kR,
            sect: _R,
            semi: wR,
            seswar: ER,
            setminus: xR,
            setmn: CR,
            sext: TR,
            Sfr: AR,
            sfr: SR,
            sfrown: IR,
            sharp: LR,
            SHCHcy: MR,
            shchcy: RR,
            SHcy: NR,
            shcy: OR,
            ShortDownArrow: DR,
            ShortLeftArrow: BR,
            shortmid: PR,
            shortparallel: HR,
            ShortRightArrow: UR,
            ShortUpArrow: zR,
            shy: qR,
            Sigma: FR,
            sigma: jR,
            sigmaf: $R,
            sigmav: VR,
            sim: KR,
            simdot: GR,
            sime: WR,
            simeq: ZR,
            simg: XR,
            simgE: JR,
            siml: YR,
            simlE: QR,
            simne: eN,
            simplus: tN,
            simrarr: rN,
            slarr: nN,
            SmallCircle: iN,
            smallsetminus: aN,
            smashp: oN,
            smeparsl: sN,
            smid: lN,
            smile: cN,
            smt: uN,
            smte: fN,
            smtes: dN,
            SOFTcy: hN,
            softcy: pN,
            solbar: gN,
            solb: vN,
            sol: mN,
            Sopf: bN,
            sopf: yN,
            spades: kN,
            spadesuit: _N,
            spar: wN,
            sqcap: EN,
            sqcaps: xN,
            sqcup: CN,
            sqcups: TN,
            Sqrt: AN,
            sqsub: SN,
            sqsube: IN,
            sqsubset: LN,
            sqsubseteq: MN,
            sqsup: RN,
            sqsupe: NN,
            sqsupset: ON,
            sqsupseteq: DN,
            square: BN,
            Square: PN,
            SquareIntersection: HN,
            SquareSubset: UN,
            SquareSubsetEqual: zN,
            SquareSuperset: qN,
            SquareSupersetEqual: FN,
            SquareUnion: jN,
            squarf: $N,
            squ: VN,
            squf: KN,
            srarr: GN,
            Sscr: WN,
            sscr: ZN,
            ssetmn: XN,
            ssmile: JN,
            sstarf: YN,
            Star: QN,
            star: e8,
            starf: t8,
            straightepsilon: r8,
            straightphi: n8,
            strns: i8,
            sub: a8,
            Sub: o8,
            subdot: s8,
            subE: l8,
            sube: c8,
            subedot: u8,
            submult: f8,
            subnE: d8,
            subne: h8,
            subplus: p8,
            subrarr: g8,
            subset: v8,
            Subset: m8,
            subseteq: b8,
            subseteqq: y8,
            SubsetEqual: k8,
            subsetneq: _8,
            subsetneqq: w8,
            subsim: E8,
            subsub: x8,
            subsup: C8,
            succapprox: T8,
            succ: A8,
            succcurlyeq: S8,
            Succeeds: I8,
            SucceedsEqual: L8,
            SucceedsSlantEqual: M8,
            SucceedsTilde: R8,
            succeq: N8,
            succnapprox: O8,
            succneqq: D8,
            succnsim: B8,
            succsim: P8,
            SuchThat: H8,
            sum: U8,
            Sum: z8,
            sung: q8,
            sup1: F8,
            sup2: j8,
            sup3: $8,
            sup: V8,
            Sup: K8,
            supdot: G8,
            supdsub: W8,
            supE: Z8,
            supe: X8,
            supedot: J8,
            Superset: Y8,
            SupersetEqual: Q8,
            suphsol: eO,
            suphsub: tO,
            suplarr: rO,
            supmult: nO,
            supnE: iO,
            supne: aO,
            supplus: oO,
            supset: sO,
            Supset: lO,
            supseteq: cO,
            supseteqq: uO,
            supsetneq: fO,
            supsetneqq: dO,
            supsim: hO,
            supsub: pO,
            supsup: gO,
            swarhk: vO,
            swarr: mO,
            swArr: bO,
            swarrow: yO,
            swnwar: kO,
            szlig: _O,
            Tab: wO,
            target: EO,
            Tau: xO,
            tau: CO,
            tbrk: TO,
            Tcaron: AO,
            tcaron: SO,
            Tcedil: IO,
            tcedil: LO,
            Tcy: MO,
            tcy: RO,
            tdot: NO,
            telrec: OO,
            Tfr: DO,
            tfr: BO,
            there4: PO,
            therefore: HO,
            Therefore: UO,
            Theta: zO,
            theta: qO,
            thetasym: FO,
            thetav: jO,
            thickapprox: $O,
            thicksim: VO,
            ThickSpace: KO,
            ThinSpace: GO,
            thinsp: WO,
            thkap: ZO,
            thksim: XO,
            THORN: JO,
            thorn: YO,
            tilde: QO,
            Tilde: e6,
            TildeEqual: t6,
            TildeFullEqual: r6,
            TildeTilde: n6,
            timesbar: i6,
            timesb: a6,
            times: o6,
            timesd: s6,
            tint: l6,
            toea: c6,
            topbot: u6,
            topcir: f6,
            top: d6,
            Topf: h6,
            topf: p6,
            topfork: g6,
            tosa: v6,
            tprime: m6,
            trade: b6,
            TRADE: y6,
            triangle: k6,
            triangledown: _6,
            triangleleft: w6,
            trianglelefteq: E6,
            triangleq: x6,
            triangleright: C6,
            trianglerighteq: T6,
            tridot: A6,
            trie: S6,
            triminus: I6,
            TripleDot: L6,
            triplus: M6,
            trisb: R6,
            tritime: N6,
            trpezium: O6,
            Tscr: D6,
            tscr: B6,
            TScy: P6,
            tscy: H6,
            TSHcy: U6,
            tshcy: z6,
            Tstrok: q6,
            tstrok: F6,
            twixt: j6,
            twoheadleftarrow: $6,
            twoheadrightarrow: V6,
            Uacute: K6,
            uacute: G6,
            uarr: W6,
            Uarr: Z6,
            uArr: X6,
            Uarrocir: J6,
            Ubrcy: Y6,
            ubrcy: Q6,
            Ubreve: eD,
            ubreve: tD,
            Ucirc: rD,
            ucirc: nD,
            Ucy: iD,
            ucy: aD,
            udarr: oD,
            Udblac: sD,
            udblac: lD,
            udhar: cD,
            ufisht: uD,
            Ufr: fD,
            ufr: dD,
            Ugrave: hD,
            ugrave: pD,
            uHar: gD,
            uharl: vD,
            uharr: mD,
            uhblk: bD,
            ulcorn: yD,
            ulcorner: kD,
            ulcrop: _D,
            ultri: wD,
            Umacr: ED,
            umacr: xD,
            uml: CD,
            UnderBar: TD,
            UnderBrace: AD,
            UnderBracket: SD,
            UnderParenthesis: ID,
            Union: LD,
            UnionPlus: MD,
            Uogon: RD,
            uogon: ND,
            Uopf: OD,
            uopf: BD,
            UpArrowBar: PD,
            uparrow: HD,
            UpArrow: UD,
            Uparrow: zD,
            UpArrowDownArrow: qD,
            updownarrow: FD,
            UpDownArrow: jD,
            Updownarrow: $D,
            UpEquilibrium: VD,
            upharpoonleft: KD,
            upharpoonright: GD,
            uplus: WD,
            UpperLeftArrow: ZD,
            UpperRightArrow: XD,
            upsi: JD,
            Upsi: YD,
            upsih: QD,
            Upsilon: eB,
            upsilon: tB,
            UpTeeArrow: rB,
            UpTee: nB,
            upuparrows: iB,
            urcorn: aB,
            urcorner: oB,
            urcrop: sB,
            Uring: lB,
            uring: cB,
            urtri: uB,
            Uscr: fB,
            uscr: dB,
            utdot: hB,
            Utilde: pB,
            utilde: gB,
            utri: vB,
            utrif: mB,
            uuarr: bB,
            Uuml: yB,
            uuml: kB,
            uwangle: _B,
            vangrt: wB,
            varepsilon: EB,
            varkappa: xB,
            varnothing: CB,
            varphi: TB,
            varpi: AB,
            varpropto: SB,
            varr: IB,
            vArr: LB,
            varrho: MB,
            varsigma: RB,
            varsubsetneq: NB,
            varsubsetneqq: OB,
            varsupsetneq: DB,
            varsupsetneqq: BB,
            vartheta: PB,
            vartriangleleft: HB,
            vartriangleright: UB,
            vBar: zB,
            Vbar: qB,
            vBarv: FB,
            Vcy: jB,
            vcy: $B,
            vdash: VB,
            vDash: KB,
            Vdash: GB,
            VDash: WB,
            Vdashl: ZB,
            veebar: XB,
            vee: JB,
            Vee: YB,
            veeeq: QB,
            vellip: eP,
            verbar: tP,
            Verbar: rP,
            vert: nP,
            Vert: iP,
            VerticalBar: aP,
            VerticalLine: oP,
            VerticalSeparator: sP,
            VerticalTilde: lP,
            VeryThinSpace: cP,
            Vfr: uP,
            vfr: fP,
            vltri: dP,
            vnsub: hP,
            vnsup: pP,
            Vopf: gP,
            vopf: vP,
            vprop: mP,
            vrtri: bP,
            Vscr: yP,
            vscr: kP,
            vsubnE: _P,
            vsubne: wP,
            vsupnE: EP,
            vsupne: xP,
            Vvdash: CP,
            vzigzag: TP,
            Wcirc: AP,
            wcirc: SP,
            wedbar: IP,
            wedge: LP,
            Wedge: MP,
            wedgeq: RP,
            weierp: NP,
            Wfr: OP,
            wfr: DP,
            Wopf: BP,
            wopf: PP,
            wp: HP,
            wr: UP,
            wreath: zP,
            Wscr: qP,
            wscr: FP,
            xcap: jP,
            xcirc: $P,
            xcup: VP,
            xdtri: KP,
            Xfr: GP,
            xfr: WP,
            xharr: ZP,
            xhArr: XP,
            Xi: JP,
            xi: YP,
            xlarr: QP,
            xlArr: e7,
            xmap: t7,
            xnis: r7,
            xodot: n7,
            Xopf: i7,
            xopf: a7,
            xoplus: o7,
            xotime: s7,
            xrarr: l7,
            xrArr: c7,
            Xscr: u7,
            xscr: f7,
            xsqcup: d7,
            xuplus: h7,
            xutri: p7,
            xvee: g7,
            xwedge: v7,
            Yacute: m7,
            yacute: b7,
            YAcy: y7,
            yacy: k7,
            Ycirc: _7,
            ycirc: w7,
            Ycy: E7,
            ycy: x7,
            yen: C7,
            Yfr: T7,
            yfr: A7,
            YIcy: S7,
            yicy: I7,
            Yopf: L7,
            yopf: M7,
            Yscr: R7,
            yscr: N7,
            YUcy: O7,
            yucy: D7,
            yuml: B7,
            Yuml: P7,
            Zacute: H7,
            zacute: U7,
            Zcaron: z7,
            zcaron: q7,
            Zcy: F7,
            zcy: j7,
            Zdot: $7,
            zdot: V7,
            zeetrf: K7,
            ZeroWidthSpace: G7,
            Zeta: W7,
            zeta: Z7,
            zfr: X7,
            Zfr: J7,
            ZHcy: Y7,
            zhcy: Q7,
            zigrarr: e9,
            zopf: t9,
            Zopf: r9,
            Zscr: n9,
            zscr: i9,
            zwj: a9,
            zwnj: o9
          }, s9 = "Á", l9 = "á", c9 = "Â", u9 = "â", f9 = "´", d9 = "Æ", h9 = "æ", p9 = "À", g9 = "à", v9 = "&", m9 = "&", b9 = "Å", y9 = "å", k9 = "Ã", _9 = "ã", w9 = "Ä", E9 = "ä", x9 = "¦", C9 = "Ç", T9 = "ç", A9 = "¸", S9 = "¢", I9 = "©", L9 = "©", M9 = "¤", R9 = "°", N9 = "÷", O9 = "É", D9 = "é", B9 = "Ê", P9 = "ê", H9 = "È", U9 = "è", z9 = "Ð", q9 = "ð", F9 = "Ë", j9 = "ë", $9 = "½", V9 = "¼", K9 = "¾", G9 = ">", W9 = ">", Z9 = "Í", X9 = "í", J9 = "Î", Y9 = "î", Q9 = "¡", eH = "Ì", tH = "ì", rH = "¿", nH = "Ï", iH = "ï", aH = "«", oH = "<", sH = "<", lH = "¯", cH = "µ", uH = "·", fH = " ", dH = "¬", hH = "Ñ", pH = "ñ", gH = "Ó", vH = "ó", mH = "Ô", bH = "ô", yH = "Ò", kH = "ò", _H = "ª", wH = "º", EH = "Ø", xH = "ø", CH = "Õ", TH = "õ", AH = "Ö", SH = "ö", IH = "¶", LH = "±", MH = "£", RH = '"', NH = '"', OH = "»", DH = "®", BH = "®", PH = "§", HH = "­", UH = "¹", zH = "²", qH = "³", FH = "ß", jH = "Þ", $H = "þ", VH = "×", KH = "Ú", GH = "ú", WH = "Û", ZH = "û", XH = "Ù", JH = "ù", YH = "¨", QH = "Ü", eU = "ü", tU = "Ý", rU = "ý", nU = "¥", iU = "ÿ", aU = {
            Aacute: s9,
            aacute: l9,
            Acirc: c9,
            acirc: u9,
            acute: f9,
            AElig: d9,
            aelig: h9,
            Agrave: p9,
            agrave: g9,
            amp: v9,
            AMP: m9,
            Aring: b9,
            aring: y9,
            Atilde: k9,
            atilde: _9,
            Auml: w9,
            auml: E9,
            brvbar: x9,
            Ccedil: C9,
            ccedil: T9,
            cedil: A9,
            cent: S9,
            copy: I9,
            COPY: L9,
            curren: M9,
            deg: R9,
            divide: N9,
            Eacute: O9,
            eacute: D9,
            Ecirc: B9,
            ecirc: P9,
            Egrave: H9,
            egrave: U9,
            ETH: z9,
            eth: q9,
            Euml: F9,
            euml: j9,
            frac12: $9,
            frac14: V9,
            frac34: K9,
            gt: G9,
            GT: W9,
            Iacute: Z9,
            iacute: X9,
            Icirc: J9,
            icirc: Y9,
            iexcl: Q9,
            Igrave: eH,
            igrave: tH,
            iquest: rH,
            Iuml: nH,
            iuml: iH,
            laquo: aH,
            lt: oH,
            LT: sH,
            macr: lH,
            micro: cH,
            middot: uH,
            nbsp: fH,
            not: dH,
            Ntilde: hH,
            ntilde: pH,
            Oacute: gH,
            oacute: vH,
            Ocirc: mH,
            ocirc: bH,
            Ograve: yH,
            ograve: kH,
            ordf: _H,
            ordm: wH,
            Oslash: EH,
            oslash: xH,
            Otilde: CH,
            otilde: TH,
            Ouml: AH,
            ouml: SH,
            para: IH,
            plusmn: LH,
            pound: MH,
            quot: RH,
            QUOT: NH,
            raquo: OH,
            reg: DH,
            REG: BH,
            sect: PH,
            shy: HH,
            sup1: UH,
            sup2: zH,
            sup3: qH,
            szlig: FH,
            THORN: jH,
            thorn: $H,
            times: VH,
            Uacute: KH,
            uacute: GH,
            Ucirc: WH,
            ucirc: ZH,
            Ugrave: XH,
            ugrave: JH,
            uml: YH,
            Uuml: QH,
            uuml: eU,
            Yacute: tU,
            yacute: rU,
            yen: nU,
            yuml: iU
          }, oU = "&", sU = "'", lU = ">", cU = "<", uU = '"', Zu = {
            amp: oU,
            apos: sU,
            gt: lU,
            lt: cU,
            quot: uU
          }, du = {}, fU = {
            0: 65533,
            128: 8364,
            130: 8218,
            131: 402,
            132: 8222,
            133: 8230,
            134: 8224,
            135: 8225,
            136: 710,
            137: 8240,
            138: 352,
            139: 8249,
            140: 338,
            142: 381,
            145: 8216,
            146: 8217,
            147: 8220,
            148: 8221,
            149: 8226,
            150: 8211,
            151: 8212,
            152: 732,
            153: 8482,
            154: 353,
            155: 8250,
            156: 339,
            158: 382,
            159: 376
          }, dU = Cr && Cr.__importDefault || function(Rr) {
            return Rr && Rr.__esModule ? Rr : { default: Rr };
          };
          Object.defineProperty(du, "__esModule", { value: !0 });
          var Xu = dU(fU), hU = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.fromCodePoint || function(Rr) {
              var Mr = "";
              return Rr > 65535 && (Rr -= 65536, Mr += String.fromCharCode(Rr >>> 10 & 1023 | 55296), Rr = 56320 | Rr & 1023), Mr += String.fromCharCode(Rr), Mr;
            }
          );
          function pU(Rr) {
            return Rr >= 55296 && Rr <= 57343 || Rr > 1114111 ? "�" : (Rr in Xu.default && (Rr = Xu.default[Rr]), hU(Rr));
          }
          du.default = pU;
          var fc = Cr && Cr.__importDefault || function(Rr) {
            return Rr && Rr.__esModule ? Rr : { default: Rr };
          };
          Object.defineProperty($r, "__esModule", { value: !0 }), $r.decodeHTML = $r.decodeHTMLStrict = $r.decodeXML = void 0;
          var hu = fc(Wu), gU = fc(aU), vU = fc(Zu), Ju = fc(du), mU = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
          $r.decodeXML = Yu(vU.default), $r.decodeHTMLStrict = Yu(hu.default);
          function Yu(Rr) {
            var Mr = ef(Rr);
            return function(Fr) {
              return String(Fr).replace(mU, Mr);
            };
          }
          var Qu = function(Rr, Mr) {
            return Rr < Mr ? 1 : -1;
          };
          $r.decodeHTML = function() {
            for (var Rr = Object.keys(gU.default).sort(Qu), Mr = Object.keys(hu.default).sort(Qu), Fr = 0, Gr = 0; Fr < Mr.length; Fr++)
              Rr[Gr] === Mr[Fr] ? (Mr[Fr] += ";?", Gr++) : Mr[Fr] += ";";
            var ri = new RegExp("&(?:" + Mr.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), bi = ef(hu.default);
            function Ai(Di) {
              return Di.substr(-1) !== ";" && (Di += ";"), bi(Di);
            }
            return function(Di) {
              return String(Di).replace(ri, Ai);
            };
          }();
          function ef(Rr) {
            return function(Fr) {
              if (Fr.charAt(1) === "#") {
                var Gr = Fr.charAt(2);
                return Gr === "X" || Gr === "x" ? Ju.default(parseInt(Fr.substr(3), 16)) : Ju.default(parseInt(Fr.substr(2), 10));
              }
              return Rr[Fr.slice(1, -1)] || Fr;
            };
          }
          var jo = {}, tf = Cr && Cr.__importDefault || function(Rr) {
            return Rr && Rr.__esModule ? Rr : { default: Rr };
          };
          Object.defineProperty(jo, "__esModule", { value: !0 }), jo.escapeUTF8 = jo.escape = jo.encodeNonAsciiHTML = jo.encodeHTML = jo.encodeXML = void 0;
          var bU = tf(Zu), rf = of(bU.default), nf = sf(rf);
          jo.encodeXML = uf(rf);
          var yU = tf(Wu), pu = of(yU.default), kU = sf(pu);
          jo.encodeHTML = wU(pu, kU), jo.encodeNonAsciiHTML = uf(pu);
          function of(Rr) {
            return Object.keys(Rr).sort().reduce(function(Mr, Fr) {
              return Mr[Rr[Fr]] = "&" + Fr + ";", Mr;
            }, {});
          }
          function sf(Rr) {
            for (var Mr = [], Fr = [], Gr = 0, ri = Object.keys(Rr); Gr < ri.length; Gr++) {
              var bi = ri[Gr];
              bi.length === 1 ? Mr.push("\\" + bi) : Fr.push(bi);
            }
            Mr.sort();
            for (var Ai = 0; Ai < Mr.length - 1; Ai++) {
              for (var Di = Ai; Di < Mr.length - 1 && Mr[Di].charCodeAt(1) + 1 === Mr[Di + 1].charCodeAt(1); )
                Di += 1;
              var ta = 1 + Di - Ai;
              ta < 3 || Mr.splice(Ai, ta, Mr[Ai] + "-" + Mr[Di]);
            }
            return Fr.unshift("[" + Mr.join("") + "]"), new RegExp(Fr.join("|"), "g");
          }
          var lf = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, _U = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.prototype.codePointAt != null ? (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              function(Rr) {
                return Rr.codePointAt(0);
              }
            ) : (
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              function(Rr) {
                return (Rr.charCodeAt(0) - 55296) * 1024 + Rr.charCodeAt(1) - 56320 + 65536;
              }
            )
          );
          function dc(Rr) {
            return "&#x" + (Rr.length > 1 ? _U(Rr) : Rr.charCodeAt(0)).toString(16).toUpperCase() + ";";
          }
          function wU(Rr, Mr) {
            return function(Fr) {
              return Fr.replace(Mr, function(Gr) {
                return Rr[Gr];
              }).replace(lf, dc);
            };
          }
          var cf = new RegExp(nf.source + "|" + lf.source, "g");
          function EU(Rr) {
            return Rr.replace(cf, dc);
          }
          jo.escape = EU;
          function xU(Rr) {
            return Rr.replace(nf, dc);
          }
          jo.escapeUTF8 = xU;
          function uf(Rr) {
            return function(Mr) {
              return Mr.replace(cf, function(Fr) {
                return Rr[Fr] || dc(Fr);
              });
            };
          }
          (function(Rr) {
            Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.decodeXMLStrict = Rr.decodeHTML5Strict = Rr.decodeHTML4Strict = Rr.decodeHTML5 = Rr.decodeHTML4 = Rr.decodeHTMLStrict = Rr.decodeHTML = Rr.decodeXML = Rr.encodeHTML5 = Rr.encodeHTML4 = Rr.escapeUTF8 = Rr.escape = Rr.encodeNonAsciiHTML = Rr.encodeHTML = Rr.encodeXML = Rr.encode = Rr.decodeStrict = Rr.decode = void 0;
            var Mr = $r, Fr = jo;
            function Gr(ta, aa) {
              return (!aa || aa <= 0 ? Mr.decodeXML : Mr.decodeHTML)(ta);
            }
            Rr.decode = Gr;
            function ri(ta, aa) {
              return (!aa || aa <= 0 ? Mr.decodeXML : Mr.decodeHTMLStrict)(ta);
            }
            Rr.decodeStrict = ri;
            function bi(ta, aa) {
              return (!aa || aa <= 0 ? Fr.encodeXML : Fr.encodeHTML)(ta);
            }
            Rr.encode = bi;
            var Ai = jo;
            Object.defineProperty(Rr, "encodeXML", { enumerable: !0, get: function() {
              return Ai.encodeXML;
            } }), Object.defineProperty(Rr, "encodeHTML", { enumerable: !0, get: function() {
              return Ai.encodeHTML;
            } }), Object.defineProperty(Rr, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
              return Ai.encodeNonAsciiHTML;
            } }), Object.defineProperty(Rr, "escape", { enumerable: !0, get: function() {
              return Ai.escape;
            } }), Object.defineProperty(Rr, "escapeUTF8", { enumerable: !0, get: function() {
              return Ai.escapeUTF8;
            } }), Object.defineProperty(Rr, "encodeHTML4", { enumerable: !0, get: function() {
              return Ai.encodeHTML;
            } }), Object.defineProperty(Rr, "encodeHTML5", { enumerable: !0, get: function() {
              return Ai.encodeHTML;
            } });
            var Di = $r;
            Object.defineProperty(Rr, "decodeXML", { enumerable: !0, get: function() {
              return Di.decodeXML;
            } }), Object.defineProperty(Rr, "decodeHTML", { enumerable: !0, get: function() {
              return Di.decodeHTML;
            } }), Object.defineProperty(Rr, "decodeHTMLStrict", { enumerable: !0, get: function() {
              return Di.decodeHTMLStrict;
            } }), Object.defineProperty(Rr, "decodeHTML4", { enumerable: !0, get: function() {
              return Di.decodeHTML;
            } }), Object.defineProperty(Rr, "decodeHTML5", { enumerable: !0, get: function() {
              return Di.decodeHTML;
            } }), Object.defineProperty(Rr, "decodeHTML4Strict", { enumerable: !0, get: function() {
              return Di.decodeHTMLStrict;
            } }), Object.defineProperty(Rr, "decodeHTML5Strict", { enumerable: !0, get: function() {
              return Di.decodeHTMLStrict;
            } }), Object.defineProperty(Rr, "decodeXMLStrict", { enumerable: !0, get: function() {
              return Di.decodeXML;
            } });
          })(Hr);
          var ff = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", CU = 92, TU = /[\\&]/, gu = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", AU = new RegExp("\\\\" + gu + "|" + ff, "gi"), SU = '[&<>"]', df = new RegExp(SU, "g"), IU = function(Rr) {
            return Rr.charCodeAt(0) === CU ? Rr.charAt(1) : Hr.decodeHTML(Rr);
          };
          function Ml(Rr) {
            return TU.test(Rr) ? Rr.replace(AU, IU) : Rr;
          }
          function hc(Rr) {
            try {
              return Nr(Rr);
            } catch (Mr) {
              return Rr;
            }
          }
          function LU(Rr) {
            switch (Rr) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              default:
                return Rr;
            }
          }
          function pl(Rr) {
            return df.test(Rr) ? Rr.replace(df, LU) : Rr;
          }
          function vu(Rr, Mr) {
            for (var Fr = [], Gr = 0; Gr < Mr; Gr++)
              Fr.push(Rr);
            return Fr.join("");
          }
          function hf(Rr) {
            return Rr ? !/[^ \t]+/.test(Rr) : !0;
          }
          var MU = (
            /** @class */
            function() {
              function Rr(Mr) {
                this.current = Mr, this.root = Mr, this.entering = !0;
              }
              return Rr.prototype.next = function() {
                var Mr = this.current, Fr = this.entering;
                if (Mr === null)
                  return null;
                var Gr = bu(Mr);
                return Fr && Gr ? Mr.firstChild ? (this.current = Mr.firstChild, this.entering = !0) : this.entering = !1 : Mr === this.root ? this.current = null : Mr.next === null ? (this.current = Mr.parent, this.entering = !1) : (this.current = Mr.next, this.entering = !0), { entering: Fr, node: Mr };
              }, Rr.prototype.resumeAt = function(Mr, Fr) {
                this.current = Mr, this.entering = Fr === !0;
              }, Rr;
            }()
          );
          function bu(Rr) {
            switch (Rr.type) {
              case "document":
              case "blockQuote":
              case "list":
              case "item":
              case "paragraph":
              case "heading":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "table":
              case "tableHead":
              case "tableBody":
              case "tableRow":
              case "tableCell":
              case "tableDelimRow":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          var RU = 1, pc = {};
          function NU(Rr) {
            return pc[Rr];
          }
          function yu(Rr) {
            delete pc[Rr];
          }
          function OU() {
            pc = {};
          }
          var Rl = (
            /** @class */
            function() {
              function Rr(Mr, Fr) {
                this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, Mr === "document" ? this.id = -1 : this.id = RU++, this.type = Mr, this.sourcepos = Fr, pc[this.id] = this;
              }
              return Rr.prototype.isContainer = function() {
                return bu(this);
              }, Rr.prototype.unlink = function() {
                this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
              }, Rr.prototype.replaceWith = function(Mr) {
                this.insertBefore(Mr), this.unlink();
              }, Rr.prototype.insertAfter = function(Mr) {
                Mr.unlink(), Mr.next = this.next, Mr.next && (Mr.next.prev = Mr), Mr.prev = this, this.next = Mr, this.parent && (Mr.parent = this.parent, Mr.next || (Mr.parent.lastChild = Mr));
              }, Rr.prototype.insertBefore = function(Mr) {
                Mr.unlink(), Mr.prev = this.prev, Mr.prev && (Mr.prev.next = Mr), Mr.next = this, this.prev = Mr, Mr.parent = this.parent, Mr.prev || (Mr.parent.firstChild = Mr);
              }, Rr.prototype.appendChild = function(Mr) {
                Mr.unlink(), Mr.parent = this, this.lastChild ? (this.lastChild.next = Mr, Mr.prev = this.lastChild, this.lastChild = Mr) : (this.firstChild = Mr, this.lastChild = Mr);
              }, Rr.prototype.prependChild = function(Mr) {
                Mr.unlink(), Mr.parent = this, this.firstChild ? (this.firstChild.prev = Mr, Mr.next = this.firstChild, this.firstChild = Mr) : (this.firstChild = Mr, this.lastChild = Mr);
              }, Rr.prototype.walker = function() {
                return new MU(this);
              }, Rr;
            }()
          ), Es = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr(Fr, Gr) {
                var ri = Rr.call(this, Fr, Gr) || this;
                return ri.open = !0, ri.lineOffsets = null, ri.stringContent = null, ri.lastLineBlank = !1, ri.lastLineChecked = !1, ri.type = Fr, ri;
              }
              return Mr;
            }(Rl)
          ), DU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.listData = null, Fr;
              }
              return Mr;
            }(Es)
          ), BU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.level = 0, Fr.headingType = "atx", Fr;
              }
              return Mr;
            }(Es)
          ), PU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.isFenced = !1, Fr.fenceChar = null, Fr.fenceLength = 0, Fr.fenceOffset = -1, Fr.info = null, Fr.infoPadding = 0, Fr;
              }
              return Mr;
            }(Es)
          ), HU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.columns = [], Fr;
              }
              return Mr;
            }(Es)
          ), UU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.startIdx = 0, Fr.endIdx = 0, Fr.paddingLeft = 0, Fr.paddingRight = 0, Fr.ignored = !1, Fr;
              }
              return Mr;
            }(Es)
          ), zU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.title = "", Fr.dest = "", Fr.label = "", Fr;
              }
              return Mr;
            }(Es)
          ), qU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.syntaxLength = 0, Fr.offset = -1, Fr.info = "", Fr;
              }
              return Mr;
            }(Es)
          ), FU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.htmlBlockType = -1, Fr;
              }
              return Mr;
            }(Es)
          ), jU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.destination = null, Fr.title = null, Fr.extendedAutolink = !1, Fr;
              }
              return Mr;
            }(Rl)
          ), $U = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.tickCount = 0, Fr;
              }
              return Mr;
            }(Rl)
          ), VU = (
            /** @class */
            function(Rr) {
              _r(Mr, Rr);
              function Mr() {
                var Fr = Rr !== null && Rr.apply(this, arguments) || this;
                return Fr.info = "", Fr;
              }
              return Mr;
            }(Rl)
          );
          function mo(Rr, Mr) {
            switch (Rr) {
              case "heading":
                return new BU(Rr, Mr);
              case "list":
              case "item":
                return new DU(Rr, Mr);
              case "link":
              case "image":
                return new jU(Rr, Mr);
              case "codeBlock":
                return new PU(Rr, Mr);
              case "htmlBlock":
                return new FU(Rr, Mr);
              case "table":
                return new HU(Rr, Mr);
              case "tableCell":
                return new UU(Rr, Mr);
              case "document":
              case "paragraph":
              case "blockQuote":
              case "thematicBreak":
              case "tableRow":
              case "tableBody":
              case "tableHead":
              case "frontMatter":
                return new Es(Rr, Mr);
              case "code":
                return new $U(Rr, Mr);
              case "refDef":
                return new zU(Rr, Mr);
              case "customBlock":
                return new qU(Rr, Mr);
              case "customInline":
                return new VU(Rr, Mr);
              default:
                return new Rl(Rr, Mr);
            }
          }
          function pf(Rr) {
            return Rr.type === "codeBlock";
          }
          function KU(Rr) {
            return Rr.type === "htmlBlock";
          }
          function GU(Rr) {
            return Rr.type === "heading";
          }
          function gf(Rr) {
            return Rr.type === "list";
          }
          function WU(Rr) {
            return Rr.type === "table";
          }
          function vl(Rr) {
            return Rr.type === "refDef";
          }
          function vf(Rr) {
            return Rr.type === "customBlock";
          }
          function ZU(Rr) {
            return Rr.type === "customInline";
          }
          function To(Rr, Mr) {
            var Fr = mo("text", Mr);
            return Fr.literal = Rr, Fr;
          }
          var mf = "[A-Za-z][A-Za-z0-9-]*", XU = "[a-zA-Z_:][a-zA-Z0-9:._-]*", JU = "[^\"'=<>`\\x00-\\x20]+", YU = "'[^']*'", QU = '"[^"]*"', ez = "(?:" + JU + "|" + YU + "|" + QU + ")", tz = "(?:\\s*=\\s*" + ez + ")", rz = "(?:\\s+" + XU + tz + "?)", bf = "<" + mf + rz + "*\\s*/?>", yf = "</" + mf + "\\s*[>]", nz = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", iz = "[<][?].*?[?][>]", az = "<![A-Z]+\\s+[^>]*>", oz = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", sz = "(?:" + bf + "|" + yf + "|" + nz + "|" + iz + "|" + az + "|" + oz + ")", lz = new RegExp("^" + sz, "i");
          /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
          var ku;
          if (String.fromCodePoint)
            ku = function(Rr) {
              try {
                return String.fromCodePoint(Rr);
              } catch (Mr) {
                if (Mr instanceof RangeError)
                  return String.fromCharCode(65533);
                throw Mr;
              }
            };
          else {
            var cz = String.fromCharCode, uz = Math.floor;
            ku = function() {
              for (var Rr = [], Mr = 0; Mr < arguments.length; Mr++)
                Rr[Mr] = arguments[Mr];
              var Fr = 16384, Gr = [], ri, bi, Ai = -1, Di = Rr.length;
              if (!Di)
                return "";
              for (var ta = ""; ++Ai < Di; ) {
                var aa = Number(Rr[Ai]);
                if (!isFinite(aa) || // `NaN`, `+Infinity`, or `-Infinity`
                aa < 0 || // not a valid Unicode code point
                aa > 1114111 || // not a valid Unicode code point
                uz(aa) !== aa)
                  return String.fromCharCode(65533);
                aa <= 65535 ? Gr.push(aa) : (aa -= 65536, ri = (aa >> 10) + 55296, bi = aa % 1024 + 56320, Gr.push(ri, bi)), (Ai + 1 === Di || Gr.length > Fr) && (ta += cz.apply(void 0, Gr), Gr.length = 0);
              }
              return ta;
            };
          }
          var _u = ku, fz = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", dz = "[^<\\s]*[^<?!.,:*_?~\\s]", hz = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
          function pz(Rr) {
            var Mr = /\)+$/.exec(Rr);
            if (Mr) {
              for (var Fr = 0, Gr = 0, ri = Rr; Gr < ri.length; Gr++) {
                var bi = ri[Gr];
                bi === "(" ? Fr < 0 ? Fr = 1 : Fr += 1 : bi === ")" && (Fr -= 1);
              }
              if (Fr < 0) {
                var Ai = Math.min(-Fr, Mr[0].length);
                return Rr.substring(0, Rr.length - Ai);
              }
            }
            return Rr;
          }
          function gz(Rr) {
            return Rr.replace(/&[A-Za-z0-9]+;$/, "");
          }
          function vz(Rr) {
            for (var Mr = new RegExp(hz, "g"), Fr = [], Gr; Gr = Mr.exec(Rr); ) {
              var ri = Gr[0];
              /[_-]+$/.test(ri) || Fr.push({
                text: ri,
                range: [Gr.index, Gr.index + ri.length - 1],
                url: "mailto:" + ri
              });
            }
            return Fr;
          }
          function mz(Rr) {
            for (var Mr = new RegExp("(www|https?://)." + fz + dz, "g"), Fr = [], Gr; Gr = Mr.exec(Rr); ) {
              var ri = gz(pz(Gr[0])), bi = Gr[1] === "www" ? "http://" : "";
              Fr.push({
                text: ri,
                range: [Gr.index, Gr.index + ri.length - 1],
                url: "" + bi + ri
              });
            }
            return Fr;
          }
          function bz(Rr) {
            return xr(xr([], mz(Rr)), vz(Rr)).sort(function(Mr, Fr) {
              return Mr.range[0] - Fr.range[0];
            });
          }
          function yz(Rr, Mr) {
            typeof Mr == "boolean" && (Mr = bz);
            for (var Fr, Gr = function() {
              var ri = Fr.entering, bi = Fr.node;
              if (ri && bi.type === "text" && bi.parent.type !== "link") {
                var Ai = bi.literal, Di = Mr(Ai);
                if (!Di || !Di.length)
                  return "continue";
                for (var ta = 0, aa = bi.sourcepos[0], wa = aa[0], xa = aa[1], ba = function(As, Ij) {
                  return [
                    [wa, xa + As],
                    [wa, xa + Ij]
                  ];
                }, Na = [], Ra = 0, io = Di; Ra < io.length; Ra++) {
                  var bo = io[Ra], So = bo.range, xs = bo.url, Wo = bo.text;
                  So[0] > ta && Na.push(To(Ai.substring(ta, So[0]), ba(ta, So[0] - 1)));
                  var Vo = mo("link", ba.apply(void 0, So));
                  Vo.appendChild(To(Wo, ba.apply(void 0, So))), Vo.destination = xs, Vo.extendedAutolink = !0, Na.push(Vo), ta = So[1] + 1;
                }
                ta < Ai.length && Na.push(To(Ai.substring(ta), ba(ta, Ai.length - 1)));
                for (var Yo = 0, Cs = Na; Yo < Cs.length; Yo++) {
                  var Ts = Cs[Yo];
                  bi.insertBefore(Ts);
                }
                bi.unlink();
              }
            }; Fr = Rr.next(); )
              Gr();
          }
          function gc(Rr) {
            return Rr[Rr.length - 1];
          }
          function kf(Rr) {
            return Rr.slice(1, Rr.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
          }
          function vc(Rr, Mr) {
            Object.keys(Rr).forEach(function(Fr) {
              Mr(Fr, Rr[Fr]);
            });
          }
          function kz(Rr) {
            for (var Mr = [], Fr = 1; Fr < arguments.length; Fr++)
              Mr[Fr - 1] = arguments[Fr];
            var Gr = Er({}, Rr);
            return Mr.forEach(function(ri) {
              delete Gr[ri];
            }), Gr;
          }
          function ml(Rr) {
            return !Object.keys(Rr).length;
          }
          function _z(Rr) {
            Object.keys(Rr).forEach(function(Mr) {
              delete Rr[Mr];
            });
          }
          var wu = 10, Eu = 42, mc = 95, wz = 96, _f = 91, Ez = 93, bc = 126, wf = 60, xz = 33, Ef = 92, Cz = 38, xf = 40, xu = 41, Tz = 58, nl = 39, il = 34, al = 36, Cu = "\\\\" + gu, Cf = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), Az = new RegExp('^(?:"(' + Cu + '|[^"\\x00])*"|' + ("'(" + Cu + "|[^'\\x00])*'") + "|" + ("\\((" + Cu + "|[^()\\x00])*\\))")), Sz = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, Tf = new RegExp("^" + gu), Iz = new RegExp("^" + ff, "i"), Lz = /`+/, Mz = /^`+/, Rz = /\.\.\./g, Nz = /--+/g, Oz = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, Dz = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, Bz = /^ *(?:\n *)?/, Tu = /^[ \t\n\x0b\x0c\x0d]/, Af = /^\s/, Pz = / *$/, Hz = /^ */, Sf = /^ *(?:\n|$)/, Uz = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, zz = /^[^\n`\[\]\\!<&*_'"~$]+/m, qz = (
            /** @class */
            function() {
              function Rr(Mr) {
                this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = Mr;
              }
              return Rr.prototype.sourcepos = function(Mr, Fr) {
                var Gr = this.linePosOffset + this.lineOffsets[this.lineIdx], ri = this.lineStartNum + this.lineIdx, bi = [ri, Mr + Gr];
                return typeof Fr == "number" ? [bi, [ri, Fr + Gr]] : bi;
              }, Rr.prototype.nextLine = function() {
                this.lineIdx += 1, this.linePosOffset = -this.pos;
              }, Rr.prototype.match = function(Mr) {
                var Fr = Mr.exec(this.subject.slice(this.pos));
                return Fr === null ? null : (this.pos += Fr.index + Fr[0].length, Fr[0]);
              }, Rr.prototype.peek = function() {
                return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
              }, Rr.prototype.spnl = function() {
                return this.match(Bz), !0;
              }, Rr.prototype.parseBackticks = function(Mr) {
                var Fr = this.pos + 1, Gr = this.match(Mz);
                if (Gr === null)
                  return !1;
                for (var ri = this.pos, bi; (bi = this.match(Lz)) !== null; )
                  if (bi === Gr) {
                    var Ai = this.subject.slice(ri, this.pos - Gr.length), Di = this.sourcepos(Fr, this.pos), ta = Ai.split(`
`);
                    if (ta.length > 1) {
                      var aa = gc(ta);
                      this.lineIdx += ta.length - 1, this.linePosOffset = -(this.pos - aa.length - Gr.length), Di[1] = this.sourcepos(this.pos), Ai = ta.join(" ");
                    }
                    var wa = mo("code", Di);
                    return Ai.length > 0 && Ai.match(/[^ ]/) !== null && Ai[0] == " " && Ai[Ai.length - 1] == " " ? wa.literal = Ai.slice(1, Ai.length - 1) : wa.literal = Ai, wa.tickCount = Gr.length, Mr.appendChild(wa), !0;
                  }
                return this.pos = ri, Mr.appendChild(To(Gr, this.sourcepos(Fr, this.pos - 1))), !0;
              }, Rr.prototype.parseBackslash = function(Mr) {
                var Fr = this.subject, Gr;
                this.pos += 1;
                var ri = this.pos;
                return this.peek() === wu ? (this.pos += 1, Gr = mo("linebreak", this.sourcepos(this.pos - 1, this.pos)), Mr.appendChild(Gr), this.nextLine()) : Tf.test(Fr.charAt(this.pos)) ? (Mr.appendChild(To(Fr.charAt(this.pos), this.sourcepos(ri, this.pos))), this.pos += 1) : Mr.appendChild(To("\\", this.sourcepos(ri, ri))), !0;
              }, Rr.prototype.parseAutolink = function(Mr) {
                var Fr, Gr, ri, bi = this.pos + 1;
                return (Fr = this.match(Oz)) ? (Gr = Fr.slice(1, Fr.length - 1), ri = mo("link", this.sourcepos(bi, this.pos)), ri.destination = hc("mailto:" + Gr), ri.title = "", ri.appendChild(To(Gr, this.sourcepos(bi + 1, this.pos - 1))), Mr.appendChild(ri), !0) : (Fr = this.match(Dz)) ? (Gr = Fr.slice(1, Fr.length - 1), ri = mo("link", this.sourcepos(bi, this.pos)), ri.destination = hc(Gr), ri.title = "", ri.appendChild(To(Gr, this.sourcepos(bi + 1, this.pos - 1))), Mr.appendChild(ri), !0) : !1;
              }, Rr.prototype.parseHtmlTag = function(Mr) {
                var Fr = this.pos + 1, Gr = this.match(lz);
                if (Gr === null)
                  return !1;
                var ri = mo("htmlInline", this.sourcepos(Fr, this.pos));
                return ri.literal = Gr, Mr.appendChild(ri), !0;
              }, Rr.prototype.scanDelims = function(Mr) {
                var Fr = 0, Gr = this.pos;
                if (Mr === nl || Mr === il)
                  Fr++, this.pos++;
                else
                  for (; this.peek() === Mr; )
                    Fr++, this.pos++;
                if (Fr === 0 || Fr < 2 && (Mr === bc || Mr === al))
                  return this.pos = Gr, null;
                var ri = Gr === 0 ? `
` : this.subject.charAt(Gr - 1), bi = this.peek(), Ai;
                bi === -1 ? Ai = `
` : Ai = _u(bi);
                var Di = Af.test(Ai), ta = Cf.test(Ai), aa = Af.test(ri), wa = Cf.test(ri), xa = !Di && (!ta || aa || wa), ba = !aa && (!wa || Di || ta), Na, Ra;
                return Mr === mc ? (Na = xa && (!ba || wa), Ra = ba && (!xa || ta)) : Mr === nl || Mr === il ? (Na = xa && !ba, Ra = ba) : Mr === al ? (Na = !Di, Ra = !aa) : (Na = xa, Ra = ba), this.pos = Gr, { numdelims: Fr, canOpen: Na, canClose: Ra };
              }, Rr.prototype.handleDelim = function(Mr, Fr) {
                var Gr = this.scanDelims(Mr);
                if (!Gr)
                  return !1;
                var ri = Gr.numdelims, bi = this.pos + 1, Ai;
                this.pos += ri, Mr === nl ? Ai = "’" : Mr === il ? Ai = "“" : Ai = this.subject.slice(bi - 1, this.pos);
                var Di = To(Ai, this.sourcepos(bi, this.pos));
                return Fr.appendChild(Di), (Gr.canOpen || Gr.canClose) && (this.options.smart || Mr !== nl && Mr !== il) && (this.delimiters = {
                  cc: Mr,
                  numdelims: ri,
                  origdelims: ri,
                  node: Di,
                  previous: this.delimiters,
                  next: null,
                  canOpen: Gr.canOpen,
                  canClose: Gr.canClose
                }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
              }, Rr.prototype.removeDelimiter = function(Mr) {
                Mr.previous !== null && (Mr.previous.next = Mr.next), Mr.next === null ? this.delimiters = Mr.previous : Mr.next.previous = Mr.previous;
              }, Rr.prototype.removeDelimitersBetween = function(Mr, Fr) {
                Mr.next !== Fr && (Mr.next = Fr, Fr.previous = Mr);
              }, Rr.prototype.processEmphasis = function(Mr) {
                var Fr, Gr, ri, bi, Ai, Di, ta, aa = !1, wa = (Fr = {}, Fr[mc] = [Mr, Mr, Mr], Fr[Eu] = [Mr, Mr, Mr], Fr[nl] = [Mr], Fr[il] = [Mr], Fr[bc] = [Mr], Fr[al] = [Mr], Fr);
                for (ri = this.delimiters; ri !== null && ri.previous !== Mr; )
                  ri = ri.previous;
                for (; ri !== null; ) {
                  var xa = ri.cc, ba = xa === mc || xa === Eu;
                  if (!ri.canClose)
                    ri = ri.next;
                  else {
                    for (Gr = ri.previous, ta = !1; Gr !== null && Gr !== Mr && Gr !== wa[xa][ba ? ri.origdelims % 3 : 0]; ) {
                      if (aa = ba && (ri.canOpen || Gr.canClose) && ri.origdelims % 3 !== 0 && (Gr.origdelims + ri.origdelims) % 3 === 0, Gr.cc === ri.cc && Gr.canOpen && !aa) {
                        ta = !0;
                        break;
                      }
                      Gr = Gr.previous;
                    }
                    if (bi = ri, ba || xa === bc || xa === al) {
                      if (!ta)
                        ri = ri.next;
                      else if (Gr) {
                        var Na = ri.numdelims >= 2 && Gr.numdelims >= 2 ? 2 : 1, Ra = ba ? 0 : 1;
                        Ai = Gr.node, Di = ri.node;
                        var io = ba ? Na === 1 ? "emph" : "strong" : "strike";
                        xa === al && (io = "customInline");
                        var bo = mo(io), So = Ai.sourcepos[1], xs = Di.sourcepos[0];
                        bo.sourcepos = [
                          [So[0], So[1] - Na + 1],
                          [xs[0], xs[1] + Na - 1]
                        ], Ai.sourcepos[1][1] -= Na, Di.sourcepos[0][1] += Na, Ai.literal = Ai.literal.slice(Na), Di.literal = Di.literal.slice(Na), Gr.numdelims -= Na, ri.numdelims -= Na;
                        for (var Wo = Ai.next, Vo = void 0; Wo && Wo !== Di; )
                          Vo = Wo.next, Wo.unlink(), bo.appendChild(Wo), Wo = Vo;
                        if (xa === al) {
                          var Yo = bo.firstChild, Cs = Yo.literal || "", Ts = Cs.split(/\s/)[0];
                          bo.info = Ts, Cs.length <= Ts.length ? Yo.unlink() : (Yo.sourcepos[0][1] += Ts.length, Yo.literal = Cs.replace(Ts + " ", ""));
                        }
                        if (Ai.insertAfter(bo), this.removeDelimitersBetween(Gr, ri), Gr.numdelims <= Ra && (Gr.numdelims === 0 && Ai.unlink(), this.removeDelimiter(Gr)), ri.numdelims <= Ra) {
                          ri.numdelims === 0 && Di.unlink();
                          var As = ri.next;
                          this.removeDelimiter(ri), ri = As;
                        }
                      }
                    } else
                      xa === nl ? (ri.node.literal = "’", ta && (Gr.node.literal = "‘"), ri = ri.next) : xa === il && (ri.node.literal = "”", ta && (Gr.node.literal = "“"), ri = ri.next);
                    ta || (wa[xa][ba ? bi.origdelims % 3 : 0] = bi.previous, bi.canOpen || this.removeDelimiter(bi));
                  }
                }
                for (; this.delimiters !== null && this.delimiters !== Mr; )
                  this.removeDelimiter(this.delimiters);
              }, Rr.prototype.parseLinkTitle = function() {
                var Mr = this.match(Az);
                return Mr === null ? null : Ml(Mr.substr(1, Mr.length - 2));
              }, Rr.prototype.parseLinkDestination = function() {
                var Mr = this.match(Sz);
                if (Mr === null) {
                  if (this.peek() === wf)
                    return null;
                  for (var Fr = this.pos, Gr = 0, ri = void 0; (ri = this.peek()) !== -1; )
                    if (ri === Ef && Tf.test(this.subject.charAt(this.pos + 1)))
                      this.pos += 1, this.peek() !== -1 && (this.pos += 1);
                    else if (ri === xf)
                      this.pos += 1, Gr += 1;
                    else if (ri === xu) {
                      if (Gr < 1)
                        break;
                      this.pos += 1, Gr -= 1;
                    } else {
                      if (Tu.exec(_u(ri)) !== null)
                        break;
                      this.pos += 1;
                    }
                  return this.pos === Fr && ri !== xu || Gr !== 0 ? null : (Mr = this.subject.substr(Fr, this.pos - Fr), hc(Ml(Mr)));
                }
                return hc(Ml(Mr.substr(1, Mr.length - 2)));
              }, Rr.prototype.parseLinkLabel = function() {
                var Mr = this.match(Uz);
                return Mr === null || Mr.length > 1001 ? 0 : Mr.length;
              }, Rr.prototype.parseOpenBracket = function(Mr) {
                var Fr = this.pos;
                this.pos += 1;
                var Gr = To("[", this.sourcepos(this.pos, this.pos));
                return Mr.appendChild(Gr), this.addBracket(Gr, Fr, !1), !0;
              }, Rr.prototype.parseBang = function(Mr) {
                var Fr = this.pos;
                if (this.pos += 1, this.peek() === _f) {
                  this.pos += 1;
                  var Gr = To("![", this.sourcepos(this.pos - 1, this.pos));
                  Mr.appendChild(Gr), this.addBracket(Gr, Fr + 1, !0);
                } else {
                  var Gr = To("!", this.sourcepos(this.pos, this.pos));
                  Mr.appendChild(Gr);
                }
                return !0;
              }, Rr.prototype.parseCloseBracket = function(Mr) {
                var Fr = null, Gr = null, ri = !1;
                this.pos += 1;
                var bi = this.pos, Ai = this.brackets;
                if (Ai === null)
                  return Mr.appendChild(To("]", this.sourcepos(bi, bi))), !0;
                if (!Ai.active)
                  return Mr.appendChild(To("]", this.sourcepos(bi, bi))), this.removeBracket(), !0;
                var Di = Ai.image, ta = this.pos;
                this.peek() === xf && (this.pos++, this.spnl() && (Fr = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
                (Tu.test(this.subject.charAt(this.pos - 1)) && (Gr = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === xu ? (this.pos += 1, ri = !0) : this.pos = ta);
                var aa = "";
                if (!ri) {
                  var wa = this.pos, xa = this.parseLinkLabel();
                  if (xa > 2 ? aa = this.subject.slice(wa, wa + xa) : Ai.bracketAfter || (aa = this.subject.slice(Ai.index, bi)), xa === 0 && (this.pos = ta), aa) {
                    aa = kf(aa);
                    var ba = this.refMap[aa];
                    ba && (Fr = ba.destination, Gr = ba.title, ri = !0);
                  }
                }
                if (ri) {
                  var Na = mo(Di ? "image" : "link");
                  Na.destination = Fr, Na.title = Gr || "", Na.sourcepos = [Ai.startpos, this.sourcepos(this.pos)];
                  for (var Ra = Ai.node.next, io = void 0; Ra; )
                    io = Ra.next, Ra.unlink(), Na.appendChild(Ra), Ra = io;
                  if (Mr.appendChild(Na), this.processEmphasis(Ai.previousDelimiter), this.removeBracket(), Ai.node.unlink(), !Di)
                    for (Ai = this.brackets; Ai !== null; )
                      Ai.image || (Ai.active = !1), Ai = Ai.previous;
                  return this.options.referenceDefinition && (this.refLinkCandidateMap[Mr.id] = { node: Mr, refLabel: aa }), !0;
                }
                return this.removeBracket(), this.pos = bi, Mr.appendChild(To("]", this.sourcepos(bi, bi))), this.options.referenceDefinition && (this.refLinkCandidateMap[Mr.id] = { node: Mr, refLabel: aa }), !0;
              }, Rr.prototype.addBracket = function(Mr, Fr, Gr) {
                this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
                  node: Mr,
                  startpos: this.sourcepos(Fr + (Gr ? 0 : 1)),
                  previous: this.brackets,
                  previousDelimiter: this.delimiters,
                  index: Fr,
                  image: Gr,
                  active: !0
                };
              }, Rr.prototype.removeBracket = function() {
                this.brackets && (this.brackets = this.brackets.previous);
              }, Rr.prototype.parseEntity = function(Mr) {
                var Fr, Gr = this.pos + 1;
                return (Fr = this.match(Iz)) ? (Mr.appendChild(To(Hr.decodeHTML(Fr), this.sourcepos(Gr, this.pos))), !0) : !1;
              }, Rr.prototype.parseString = function(Mr) {
                var Fr, Gr = this.pos + 1;
                if (Fr = this.match(zz)) {
                  if (this.options.smart) {
                    var ri = Fr.replace(Rz, "…").replace(Nz, function(Ai) {
                      var Di = 0, ta = 0;
                      return Ai.length % 3 === 0 ? ta = Ai.length / 3 : Ai.length % 2 === 0 ? Di = Ai.length / 2 : Ai.length % 3 === 2 ? (Di = 1, ta = (Ai.length - 2) / 3) : (Di = 2, ta = (Ai.length - 4) / 3), vu("—", ta) + vu("–", Di);
                    });
                    Mr.appendChild(To(ri, this.sourcepos(Gr, this.pos)));
                  } else {
                    var bi = To(Fr, this.sourcepos(Gr, this.pos));
                    Mr.appendChild(bi);
                  }
                  return !0;
                }
                return !1;
              }, Rr.prototype.parseNewline = function(Mr) {
                this.pos += 1;
                var Fr = Mr.lastChild;
                if (Fr && Fr.type === "text" && Fr.literal[Fr.literal.length - 1] === " ") {
                  var Gr = Fr.literal[Fr.literal.length - 2] === " ", ri = Fr.literal.length;
                  Fr.literal = Fr.literal.replace(Pz, "");
                  var bi = ri - Fr.literal.length;
                  Fr.sourcepos[1][1] -= bi, Mr.appendChild(mo(Gr ? "linebreak" : "softbreak", this.sourcepos(this.pos - bi, this.pos)));
                } else
                  Mr.appendChild(mo("softbreak", this.sourcepos(this.pos, this.pos)));
                return this.nextLine(), this.match(Hz), !0;
              }, Rr.prototype.parseReference = function(Mr, Fr) {
                if (!this.options.referenceDefinition)
                  return 0;
                this.subject = Mr.stringContent, this.pos = 0;
                var Gr = null, ri = this.pos, bi = this.parseLinkLabel();
                if (bi === 0)
                  return 0;
                var Ai = this.subject.substr(0, bi);
                if (this.peek() === Tz)
                  this.pos++;
                else
                  return this.pos = ri, 0;
                this.spnl();
                var Di = this.parseLinkDestination();
                if (Di === null)
                  return this.pos = ri, 0;
                var ta = this.pos;
                this.spnl(), this.pos !== ta && (Gr = this.parseLinkTitle()), Gr === null && (Gr = "", this.pos = ta);
                var aa = !0;
                if (this.match(Sf) === null && (Gr === "" ? aa = !1 : (Gr = "", this.pos = ta, aa = this.match(Sf) !== null)), !aa)
                  return this.pos = ri, 0;
                var wa = kf(Ai);
                if (wa === "")
                  return this.pos = ri, 0;
                var xa = this.getReferenceDefSourcepos(Mr);
                Mr.sourcepos[0][0] = xa[1][0] + 1;
                var ba = mo("refDef", xa);
                return ba.title = Gr, ba.dest = Di, ba.label = wa, Mr.insertBefore(ba), Fr[wa] ? this.refDefCandidateMap[ba.id] = ba : Fr[wa] = Ou(ba), this.pos - ri;
              }, Rr.prototype.mergeTextNodes = function(Mr) {
                for (var Fr, Gr = []; Fr = Mr.next(); ) {
                  var ri = Fr.entering, bi = Fr.node;
                  if (ri && bi.type === "text")
                    Gr.push(bi);
                  else if (Gr.length === 1)
                    Gr = [];
                  else if (Gr.length > 1) {
                    var Ai = Gr[0], Di = Gr[Gr.length - 1];
                    Ai.sourcepos && Di.sourcepos && (Ai.sourcepos[1] = Di.sourcepos[1]), Ai.next = Di.next, Ai.next && (Ai.next.prev = Ai);
                    for (var ta = 1; ta < Gr.length; ta += 1)
                      Ai.literal += Gr[ta].literal, Gr[ta].unlink();
                    Gr = [];
                  }
                }
              }, Rr.prototype.getReferenceDefSourcepos = function(Mr) {
                for (var Fr = Mr.stringContent.split(/\n|\r\n/), Gr = !1, ri = 0, bi = { line: 0, ch: 0 }, Ai = 0; Ai < Fr.length; Ai += 1) {
                  var Di = Fr[Ai];
                  if (Tu.test(Di))
                    break;
                  if (/\:/.test(Di) && ri === 0) {
                    if (Gr)
                      break;
                    var ta = Di.indexOf(":") === Di.length - 1 ? Ai + 1 : Ai;
                    bi = { line: ta, ch: Fr[ta].length }, Gr = !0;
                  }
                  var aa = Di.match(/'|"/g);
                  if (aa && (ri += aa.length), ri === 2) {
                    bi = { line: Ai, ch: Di.length };
                    break;
                  }
                }
                return [
                  [Mr.sourcepos[0][0], Mr.sourcepos[0][1]],
                  [Mr.sourcepos[0][0] + bi.line, bi.ch]
                ];
              }, Rr.prototype.parseInline = function(Mr) {
                var Fr, Gr = !1, ri = this.peek();
                if (ri === -1)
                  return !1;
                switch (ri) {
                  case wu:
                    Gr = this.parseNewline(Mr);
                    break;
                  case Ef:
                    Gr = this.parseBackslash(Mr);
                    break;
                  case wz:
                    Gr = this.parseBackticks(Mr);
                    break;
                  case Eu:
                  case mc:
                  case bc:
                  case al:
                    Gr = this.handleDelim(ri, Mr);
                    break;
                  case nl:
                  case il:
                    Gr = !!(!((Fr = this.options) === null || Fr === void 0) && Fr.smart) && this.handleDelim(ri, Mr);
                    break;
                  case _f:
                    Gr = this.parseOpenBracket(Mr);
                    break;
                  case xz:
                    Gr = this.parseBang(Mr);
                    break;
                  case Ez:
                    Gr = this.parseCloseBracket(Mr);
                    break;
                  case wf:
                    Gr = this.parseAutolink(Mr) || this.parseHtmlTag(Mr);
                    break;
                  case Cz:
                    Mr.disabledEntityParse || (Gr = this.parseEntity(Mr));
                    break;
                  default:
                    Gr = this.parseString(Mr);
                    break;
                }
                return Gr || (this.pos += 1, Mr.appendChild(To(_u(ri), this.sourcepos(this.pos, this.pos + 1)))), !0;
              }, Rr.prototype.parse = function(Mr) {
                for (this.subject = Mr.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = Mr.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = Mr.sourcepos[0][0], GU(Mr) && (this.lineOffsets[0] += Mr.level + 1); this.parseInline(Mr); )
                  ;
                Mr.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(Mr.walker());
                var Fr = this.options, Gr = Fr.extendedAutolinks, ri = Fr.customParser;
                if (Gr && yz(Mr.walker(), Gr), ri && Mr.firstChild)
                  for (var bi, Ai = Mr.firstChild.walker(); bi = Ai.next(); ) {
                    var Di = bi.node, ta = bi.entering;
                    ri[Di.type] && ri[Di.type](Di, { entering: ta, options: this.options });
                  }
              }, Rr;
            }()
          ), Fz = /^\[([ \txX])\][ \t]+/;
          function jz(Rr, Mr) {
            if (Mr.firstChild && Mr.firstChild.type === "paragraph") {
              var Fr = Mr.firstChild, Gr = Fr.stringContent.match(Fz);
              if (Gr) {
                var ri = Gr[0].length;
                Fr.stringContent = Fr.stringContent.substring(ri - 1), Fr.sourcepos[0][1] += ri, Fr.lineOffsets[0] += ri, Mr.listData.task = !0, Mr.listData.checked = /[xX]/.test(Gr[1]);
              }
            }
          }
          var $z = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr === "tableHead" || Rr === "tableBody";
            },
            acceptsLines: !1
          }, Vz = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr === "tableRow";
            },
            acceptsLines: !1
          }, Kz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr === "tableRow" || Rr === "tableDelimRow";
            },
            acceptsLines: !1
          }, Gz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr === "tableDelimCell";
            },
            acceptsLines: !1
          }, Wz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, Zz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr === "tableCell";
            },
            acceptsLines: !1
          }, Xz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, yc = 4, If = 9, Lf = 62, Jz = 60, Mf = 32, Rf = 91, Nf = /[^ \t\f\v\r\n]/, Yz = /^(?:`{3,}|~{3,})(?= *$)/;
          function Of(Rr) {
            for (var Mr = Rr; Mr; ) {
              if (Mr.lastLineBlank)
                return !0;
              var Fr = Mr.type;
              if (!Mr.lastLineChecked && (Fr === "list" || Fr === "item"))
                Mr.lastLineChecked = !0, Mr = Mr.lastChild;
              else {
                Mr.lastLineChecked = !0;
                break;
              }
            }
            return !1;
          }
          function $o(Rr, Mr) {
            return Mr < Rr.length ? Rr.charCodeAt(Mr) : -1;
          }
          function Df(Rr) {
            return !Nf.test(Rr);
          }
          function bl(Rr) {
            return Rr === Mf || Rr === If;
          }
          var Qz = /^\$\$$/, eq = {
            continue: function(Rr, Mr) {
              var Fr = Rr.currentLine, Gr = Fr.match(Qz);
              if (Gr)
                return Rr.lastLineLength = Gr[0].length, Rr.finalize(Mr, Rr.lineNumber), 2;
              for (var ri = Mr.offset; ri > 0 && bl($o(Fr, Rr.offset)); )
                Rr.advanceOffset(1, !0), ri--;
              return 0;
            },
            finalize: function(Rr, Mr) {
              if (Mr.stringContent !== null) {
                var Fr = Mr.stringContent, Gr = Fr.indexOf(`
`), ri = Fr.slice(0, Gr), bi = Fr.slice(Gr + 1), Ai = ri.match(/^(\s*)(.*)/);
                Mr.info = Ml(Ai[2].trim()), Mr.literal = bi, Mr.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, Bf = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, tq = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr !== "item";
            },
            acceptsLines: !1
          }, rq = {
            continue: function() {
              return 0;
            },
            finalize: function(Rr, Mr) {
              for (var Fr = Mr.firstChild; Fr; ) {
                if (Of(Fr) && Fr.next) {
                  Mr.listData.tight = !1;
                  break;
                }
                for (var Gr = Fr.firstChild; Gr; ) {
                  if (Of(Gr) && (Fr.next || Gr.next)) {
                    Mr.listData.tight = !1;
                    break;
                  }
                  Gr = Gr.next;
                }
                Fr = Fr.next;
              }
            },
            canContain: function(Rr) {
              return Rr === "item";
            },
            acceptsLines: !1
          }, nq = {
            continue: function(Rr) {
              var Mr = Rr.currentLine;
              if (!Rr.indented && $o(Mr, Rr.nextNonspace) === Lf)
                Rr.advanceNextNonspace(), Rr.advanceOffset(1, !1), bl($o(Mr, Rr.offset)) && Rr.advanceOffset(1, !0);
              else
                return 1;
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Rr) {
              return Rr !== "item";
            },
            acceptsLines: !1
          }, iq = {
            continue: function(Rr, Mr) {
              if (Rr.blank) {
                if (Mr.firstChild === null)
                  return 1;
                Rr.advanceNextNonspace();
              } else if (Rr.indent >= Mr.listData.markerOffset + Mr.listData.padding)
                Rr.advanceOffset(Mr.listData.markerOffset + Mr.listData.padding, !0);
              else
                return 1;
              return 0;
            },
            finalize: jz,
            canContain: function(Rr) {
              return Rr !== "item";
            },
            acceptsLines: !1
          }, aq = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, oq = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, sq = {
            continue: function(Rr, Mr) {
              var Fr = Rr.currentLine, Gr = Rr.indent;
              if (Mr.isFenced) {
                var ri = Gr <= 3 && Fr.charAt(Rr.nextNonspace) === Mr.fenceChar && Fr.slice(Rr.nextNonspace).match(Yz);
                if (ri && ri[0].length >= Mr.fenceLength)
                  return Rr.lastLineLength = Rr.offset + Gr + ri[0].length, Rr.finalize(Mr, Rr.lineNumber), 2;
                for (var bi = Mr.fenceOffset; bi > 0 && bl($o(Fr, Rr.offset)); )
                  Rr.advanceOffset(1, !0), bi--;
              } else if (Gr >= yc)
                Rr.advanceOffset(yc, !0);
              else if (Rr.blank)
                Rr.advanceNextNonspace();
              else
                return 1;
              return 0;
            },
            finalize: function(Rr, Mr) {
              var Fr;
              if (Mr.stringContent !== null) {
                if (Mr.isFenced) {
                  var Gr = Mr.stringContent, ri = Gr.indexOf(`
`), bi = Gr.slice(0, ri), Ai = Gr.slice(ri + 1), Di = bi.match(/^(\s*)(.*)/);
                  Mr.infoPadding = Di[1].length, Mr.info = Ml(Di[2].trim()), Mr.literal = Ai;
                } else
                  Mr.literal = (Fr = Mr.stringContent) === null || Fr === void 0 ? void 0 : Fr.replace(/(\n *)+$/, `
`);
                Mr.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, lq = {
            continue: function(Rr, Mr) {
              return Rr.blank && (Mr.htmlBlockType === 6 || Mr.htmlBlockType === 7) ? 1 : 0;
            },
            finalize: function(Rr, Mr) {
              var Fr;
              Mr.literal = ((Fr = Mr.stringContent) === null || Fr === void 0 ? void 0 : Fr.replace(/(\n *)+$/, "")) || null, Mr.stringContent = null;
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, cq = {
            continue: function(Rr) {
              return Rr.blank ? 1 : 0;
            },
            finalize: function(Rr, Mr) {
              if (Mr.stringContent !== null) {
                for (var Fr, Gr = !1; $o(Mr.stringContent, 0) === Rf && (Fr = Rr.inlineParser.parseReference(Mr, Rr.refMap)); )
                  Mr.stringContent = Mr.stringContent.slice(Fr), Gr = !0;
                Gr && Df(Mr.stringContent) && Mr.unlink();
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, uq = Bf, fq = Bf, yl = {
            document: tq,
            list: rq,
            blockQuote: nq,
            item: iq,
            heading: aq,
            thematicBreak: oq,
            codeBlock: sq,
            htmlBlock: lq,
            paragraph: cq,
            table: $z,
            tableBody: Vz,
            tableHead: Kz,
            tableRow: Zz,
            tableCell: Xz,
            tableDelimRow: Gz,
            tableDelimCell: Wz,
            refDef: uq,
            customBlock: eq,
            frontMatter: fq
          };
          function Au(Rr) {
            for (var Mr = 0, Fr = 0, Gr = [], ri = 0; ri < Rr.length; ri += 1)
              if (Rr[ri] === "|" && Rr[ri - 1] !== "\\") {
                var bi = Rr.substring(Mr, ri);
                Mr === 0 && hf(bi) ? Fr = ri + 1 : Gr.push(bi), Mr = ri + 1;
              }
            if (Mr < Rr.length) {
              var bi = Rr.substring(Mr, Rr.length);
              hf(bi) || Gr.push(bi);
            }
            return [Fr, Gr];
          }
          function Su(Rr, Mr, Fr, Gr) {
            for (var ri = [], bi = 0, Ai = Mr; bi < Ai.length; bi++) {
              var Di = Ai[bi], ta = Di.match(/^[ \t]+/), aa = ta ? ta[0].length : 0, wa = void 0, xa = void 0;
              if (aa === Di.length)
                aa = 0, wa = 0, xa = "";
              else {
                var ba = Di.match(/[ \t]+$/);
                wa = ba ? ba[0].length : 0, xa = Di.slice(aa, Di.length - wa);
              }
              var Na = Gr + aa, Ra = mo(Rr, [
                [Fr, Gr],
                [Fr, Gr + Di.length - 1]
              ]);
              Ra.stringContent = xa.replace(/\\\|/g, "|"), Ra.startIdx = ri.length, Ra.endIdx = ri.length, Ra.lineOffsets = [Na - 1], Ra.paddingLeft = aa, Ra.paddingRight = wa, ri.push(Ra), Gr += Di.length + 1;
            }
            return ri;
          }
          function dq(Rr) {
            var Mr = null, Fr = Rr.stringContent, Gr = Fr[0], ri = Fr[Fr.length - 1];
            return ri === ":" ? Mr = Gr === ":" ? "center" : "right" : Gr === ":" && (Mr = "left"), { align: Mr };
          }
          var hq = function(Rr, Mr) {
            var Fr = Mr.stringContent;
            if (Mr.type === "paragraph" && !Rr.indented && !Rr.blank) {
              var Gr = Fr.length - 1, ri = Fr.lastIndexOf(`
`, Gr - 1) + 1, bi = Fr.slice(ri, Gr), Ai = Rr.currentLine.slice(Rr.nextNonspace), Di = Au(bi), ta = Di[0], aa = Di[1], wa = Au(Ai), xa = wa[0], ba = wa[1], Na = /^[ \t]*:?-+:?[ \t]*$/;
              if (
                // not checking if the number of header cells and delimiter cells are the same
                // to consider the case of merged-column (via plugin)
                !aa.length || !ba.length || ba.some(function(As) {
                  return !Na.test(As);
                }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
                ba.length === 1 && Ai.indexOf("|") !== 0
              )
                return 0;
              var Ra = Mr.lineOffsets, io = Rr.lineNumber - 1, bo = gc(Ra) + 1, So = mo("table", [
                [io, bo],
                [Rr.lineNumber, Rr.offset]
              ]);
              if (So.columns = ba.map(function() {
                return { align: null };
              }), Mr.insertAfter(So), Ra.length === 1)
                Mr.unlink();
              else {
                Mr.stringContent = Fr.slice(0, ri);
                var xs = Fr.lastIndexOf(`
`, ri - 2) + 1, Wo = ri - xs - 1;
                Rr.lastLineLength = Ra[Ra.length - 2] + Wo, Rr.finalize(Mr, io - 1);
              }
              Rr.advanceOffset(Rr.currentLine.length - Rr.offset, !1);
              var Vo = mo("tableHead", [
                [io, bo],
                [Rr.lineNumber, Rr.offset]
              ]);
              So.appendChild(Vo);
              var Yo = mo("tableRow", [
                [io, bo],
                [io, bo + bi.length - 1]
              ]), Cs = mo("tableDelimRow", [
                [Rr.lineNumber, Rr.nextNonspace + 1],
                [Rr.lineNumber, Rr.offset]
              ]);
              Vo.appendChild(Yo), Vo.appendChild(Cs), Su("tableCell", aa, io, bo + ta).forEach(function(As) {
                Yo.appendChild(As);
              });
              var Ts = Su("tableDelimCell", ba, Rr.lineNumber, Rr.nextNonspace + 1 + xa);
              return Ts.forEach(function(As) {
                Cs.appendChild(As);
              }), So.columns = Ts.map(dq), Rr.tip = So, 2;
            }
            return 0;
          }, pq = function(Rr, Mr) {
            if (Mr.type !== "table" && Mr.type !== "tableBody" || !Rr.blank && Rr.currentLine.indexOf("|") === -1)
              return 0;
            if (Rr.advanceOffset(Rr.currentLine.length - Rr.offset, !1), Rr.blank) {
              var Fr = Mr;
              return Mr.type === "tableBody" && (Fr = Mr.parent, Rr.finalize(Mr, Rr.lineNumber - 1)), Rr.finalize(Fr, Rr.lineNumber - 1), 0;
            }
            var Gr = Mr;
            Mr.type === "table" && (Gr = Rr.addChild("tableBody", Rr.nextNonspace), Gr.stringContent = null);
            var ri = mo("tableRow", [
              [Rr.lineNumber, Rr.nextNonspace + 1],
              [Rr.lineNumber, Rr.currentLine.length]
            ]);
            Gr.appendChild(ri);
            var bi = Gr.parent, Ai = Rr.currentLine.slice(Rr.nextNonspace), Di = Au(Ai), ta = Di[0], aa = Di[1];
            return Su("tableCell", aa, Rr.lineNumber, Rr.nextNonspace + 1 + ta).forEach(function(wa, xa) {
              xa >= bi.columns.length && (wa.ignored = !0), ri.appendChild(wa);
            }), 2;
          }, gq = /^(\$\$)(\s*[a-zA-Z])+/, vq = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, mq = function(Rr) {
            var Mr;
            if (!Rr.indented && !vq.test(Rr.currentLine) && (Mr = Rr.currentLine.match(gq))) {
              var Fr = Mr[1].length;
              Rr.closeUnmatchedBlocks();
              var Gr = Rr.addChild("customBlock", Rr.nextNonspace);
              return Gr.syntaxLength = Fr, Gr.offset = Rr.indent, Rr.advanceNextNonspace(), Rr.advanceOffset(Fr, !1), 2;
            }
            return 0;
          }, bq = /^`{3,}(?!.*`)|^~{3,}/, yq = [
            /./,
            /^<(?:script|pre|style)(?:\s|>|$)/i,
            /^<!--/,
            /^<[?]/,
            /^<![A-Z]/,
            /^<!\[CDATA\[/,
            /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
            new RegExp("^(?:" + bf + "|" + yf + ")\\s*$", "i")
          ], kq = /^(?:=+|-+)[ \t]*$/, _q = /^#{1,6}(?:[ \t]+|$)/, wq = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, Pf = /^[*+-]/, Hf = /^(\d{1,9})([.)])/;
          function Eq(Rr, Mr) {
            var Fr = Rr.currentLine.slice(Rr.nextNonspace), Gr, ri, bi = {
              type: "bullet",
              tight: !0,
              bulletChar: "",
              start: 0,
              delimiter: "",
              padding: 0,
              markerOffset: Rr.indent,
              // GFM: Task List Item
              task: !1,
              checked: !1
            };
            if (Rr.indent >= 4)
              return null;
            if (Gr = Fr.match(Pf))
              bi.type = "bullet", bi.bulletChar = Gr[0][0];
            else if ((Gr = Fr.match(Hf)) && (Mr.type !== "paragraph" || Gr[1] === "1"))
              bi.type = "ordered", bi.start = parseInt(Gr[1], 10), bi.delimiter = Gr[2];
            else
              return null;
            if (ri = $o(Rr.currentLine, Rr.nextNonspace + Gr[0].length), !(ri === -1 || ri === If || ri === Mf) || Mr.type === "paragraph" && !Rr.currentLine.slice(Rr.nextNonspace + Gr[0].length).match(Nf))
              return null;
            Rr.advanceNextNonspace(), Rr.advanceOffset(Gr[0].length, !0);
            var Ai = Rr.column, Di = Rr.offset;
            do
              Rr.advanceOffset(1, !0), ri = $o(Rr.currentLine, Rr.offset);
            while (Rr.column - Ai < 5 && bl(ri));
            var ta = $o(Rr.currentLine, Rr.offset) === -1, aa = Rr.column - Ai;
            return aa >= 5 || aa < 1 || ta ? (bi.padding = Gr[0].length + 1, Rr.column = Ai, Rr.offset = Di, bl($o(Rr.currentLine, Rr.offset)) && Rr.advanceOffset(1, !0)) : bi.padding = Gr[0].length + aa, bi;
          }
          function xq(Rr, Mr) {
            return Rr.type === Mr.type && Rr.delimiter === Mr.delimiter && Rr.bulletChar === Mr.bulletChar;
          }
          function Uf(Rr, Mr) {
            return Rr.options.disallowDeepHeading && (Mr.type === "blockQuote" || Mr.type === "item");
          }
          var Cq = function(Rr) {
            return !Rr.indented && $o(Rr.currentLine, Rr.nextNonspace) === Lf ? (Rr.advanceNextNonspace(), Rr.advanceOffset(1, !1), bl($o(Rr.currentLine, Rr.offset)) && Rr.advanceOffset(1, !0), Rr.closeUnmatchedBlocks(), Rr.addChild("blockQuote", Rr.nextNonspace), 1) : 0;
          }, Tq = function(Rr, Mr) {
            var Fr;
            if (!Rr.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !Uf(Rr, Mr) && (Fr = Rr.currentLine.slice(Rr.nextNonspace).match(_q))) {
              Rr.advanceNextNonspace(), Rr.advanceOffset(Fr[0].length, !1), Rr.closeUnmatchedBlocks();
              var Gr = Rr.addChild("heading", Rr.nextNonspace);
              return Gr.level = Fr[0].trim().length, Gr.headingType = "atx", Gr.stringContent = Rr.currentLine.slice(Rr.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), Rr.advanceOffset(Rr.currentLine.length - Rr.offset), 2;
            }
            return 0;
          }, Aq = function(Rr) {
            var Mr;
            if (!Rr.indented && (Mr = Rr.currentLine.slice(Rr.nextNonspace).match(bq))) {
              var Fr = Mr[0].length;
              Rr.closeUnmatchedBlocks();
              var Gr = Rr.addChild("codeBlock", Rr.nextNonspace);
              return Gr.isFenced = !0, Gr.fenceLength = Fr, Gr.fenceChar = Mr[0][0], Gr.fenceOffset = Rr.indent, Rr.advanceNextNonspace(), Rr.advanceOffset(Fr, !1), 2;
            }
            return 0;
          }, Sq = function(Rr, Mr) {
            if (!Rr.indented && $o(Rr.currentLine, Rr.nextNonspace) === Jz) {
              var Fr = Rr.currentLine.slice(Rr.nextNonspace), Gr = Rr.options.disallowedHtmlBlockTags, ri = void 0;
              for (ri = 1; ri <= 7; ri++) {
                var bi = Fr.match(yq[ri]);
                if (bi) {
                  if (ri === 7) {
                    if (Mr.type === "paragraph")
                      return 0;
                    if (Gr.length > 0) {
                      var Ai = new RegExp("</?(?:" + Gr.join("|") + ")", "i");
                      if (Ai.test(bi[0]))
                        return 0;
                    }
                  }
                  Rr.closeUnmatchedBlocks();
                  var Di = Rr.addChild("htmlBlock", Rr.offset);
                  return Di.htmlBlockType = ri, 2;
                }
              }
            }
            return 0;
          }, Iq = function(Rr, Mr) {
            var Fr;
            if (Mr.stringContent !== null && !Rr.indented && Mr.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !Uf(Rr, Mr.parent) && (Fr = Rr.currentLine.slice(Rr.nextNonspace).match(kq))) {
              Rr.closeUnmatchedBlocks();
              for (var Gr = void 0; $o(Mr.stringContent, 0) === Rf && (Gr = Rr.inlineParser.parseReference(Mr, Rr.refMap)); )
                Mr.stringContent = Mr.stringContent.slice(Gr);
              if (Mr.stringContent.length > 0) {
                var ri = mo("heading", Mr.sourcepos);
                return ri.level = Fr[0][0] === "=" ? 1 : 2, ri.headingType = "setext", ri.stringContent = Mr.stringContent, Mr.insertAfter(ri), Mr.unlink(), Rr.tip = ri, Rr.advanceOffset(Rr.currentLine.length - Rr.offset, !1), 2;
              }
              return 0;
            }
            return 0;
          }, Lq = function(Rr) {
            return !Rr.indented && wq.test(Rr.currentLine.slice(Rr.nextNonspace)) ? (Rr.closeUnmatchedBlocks(), Rr.addChild("thematicBreak", Rr.nextNonspace), Rr.advanceOffset(Rr.currentLine.length - Rr.offset, !1), 2) : 0;
          }, Mq = function(Rr, Mr) {
            var Fr, Gr = Mr;
            return (!Rr.indented || Mr.type === "list") && (Fr = Eq(Rr, Gr)) ? (Rr.closeUnmatchedBlocks(), (Rr.tip.type !== "list" || !xq(Gr.listData, Fr)) && (Gr = Rr.addChild("list", Rr.nextNonspace), Gr.listData = Fr), Gr = Rr.addChild("item", Rr.nextNonspace), Gr.listData = Fr, 1) : 0;
          }, Rq = function(Rr) {
            return Rr.indented && Rr.tip.type !== "paragraph" && !Rr.blank ? (Rr.advanceOffset(yc, !0), Rr.closeUnmatchedBlocks(), Rr.addChild("codeBlock", Rr.offset), 2) : 0;
          }, Iu = [
            Cq,
            Tq,
            Aq,
            Sq,
            Iq,
            Lq,
            Mq,
            Rq,
            hq,
            pq,
            mq
          ], zf = /^(-{3}|\+{3}|;{3})$/, Nq = function(Rr, Mr) {
            var Fr = Rr.currentLine, Gr = Rr.lineNumber, ri = Rr.indented;
            if (Gr === 1 && !ri && Mr.type === "document" && zf.test(Fr)) {
              Rr.closeUnmatchedBlocks();
              var bi = Rr.addChild("frontMatter", Rr.nextNonspace);
              return bi.stringContent = Fr, Rr.advanceNextNonspace(), Rr.advanceOffset(Fr.length, !1), 2;
            }
            return 0;
          }, Oq = {
            continue: function(Rr, Mr) {
              var Fr = Rr.currentLine, Gr = Fr.match(zf);
              return Mr.type === "frontMatter" && Gr ? (Mr.stringContent += Fr, Rr.lastLineLength = Gr[0].length, Rr.finalize(Mr, Rr.lineNumber), 2) : 0;
            },
            finalize: function(Rr, Mr) {
              Mr.stringContent !== null && (Mr.literal = Mr.stringContent, Mr.stringContent = null);
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, Dq = [
            /./,
            /<\/(?:script|pre|style)>/i,
            /-->/,
            /\?>/,
            />/,
            /\]\]>/
          ], Bq = /^[#`~*+_=<>0-9-;$]/, Pq = /\r\n|\n|\r/;
          function Lu() {
            return mo("document", [
              [1, 1],
              [0, 0]
            ]);
          }
          var Hq = {
            smart: !1,
            tagFilter: !1,
            extendedAutolinks: !1,
            disallowedHtmlBlockTags: [],
            referenceDefinition: !1,
            disallowDeepHeading: !1,
            customParser: null,
            frontMatter: !1
          }, Uq = (
            /** @class */
            function() {
              function Rr(Mr) {
                this.options = Er(Er({}, Hq), Mr), this.doc = Lu(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (yl.frontMatter = Oq, Iu.unshift(Nq)), this.inlineParser = new qz(this.options);
              }
              return Rr.prototype.advanceOffset = function(Mr, Fr) {
                Fr === void 0 && (Fr = !1);
                for (var Gr = this.currentLine, ri, bi, Ai; Mr > 0 && (Ai = Gr[this.offset]); )
                  Ai === "	" ? (ri = 4 - this.column % 4, Fr ? (this.partiallyConsumedTab = ri > Mr, bi = ri > Mr ? Mr : ri, this.column += bi, this.offset += this.partiallyConsumedTab ? 0 : 1, Mr -= bi) : (this.partiallyConsumedTab = !1, this.column += ri, this.offset += 1, Mr -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, Mr -= 1);
              }, Rr.prototype.advanceNextNonspace = function() {
                this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
              }, Rr.prototype.findNextNonspace = function() {
                for (var Mr = this.currentLine, Fr = this.offset, Gr = this.column, ri; (ri = Mr.charAt(Fr)) !== ""; )
                  if (ri === " ")
                    Fr++, Gr++;
                  else if (ri === "	")
                    Fr++, Gr += 4 - Gr % 4;
                  else
                    break;
                this.blank = ri === `
` || ri === "\r" || ri === "", this.nextNonspace = Fr, this.nextNonspaceColumn = Gr, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= yc;
              }, Rr.prototype.addLine = function() {
                if (this.partiallyConsumedTab) {
                  this.offset += 1;
                  var Mr = 4 - this.column % 4;
                  this.tip.stringContent += vu(" ", Mr);
                }
                this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
              }, Rr.prototype.addChild = function(Mr, Fr) {
                for (; !yl[this.tip.type].canContain(Mr); )
                  this.finalize(this.tip, this.lineNumber - 1);
                var Gr = Fr + 1, ri = mo(Mr, [
                  [this.lineNumber, Gr],
                  [0, 0]
                ]);
                return ri.stringContent = "", this.tip.appendChild(ri), this.tip = ri, ri;
              }, Rr.prototype.closeUnmatchedBlocks = function() {
                if (!this.allClosed) {
                  for (; this.oldtip !== this.lastMatchedContainer; ) {
                    var Mr = this.oldtip.parent;
                    this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = Mr;
                  }
                  this.allClosed = !0;
                }
              }, Rr.prototype.finalize = function(Mr, Fr) {
                var Gr = Mr.parent;
                Mr.open = !1, Mr.sourcepos[1] = [Fr, this.lastLineLength], yl[Mr.type].finalize(this, Mr), this.tip = Gr;
              }, Rr.prototype.processInlines = function(Mr) {
                var Fr, Gr = this.options.customParser, ri = Mr.walker();
                for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; Fr = ri.next(); ) {
                  var bi = Fr.node, Ai = Fr.entering, Di = bi.type;
                  Gr && Gr[Di] && Gr[Di](bi, { entering: Ai, options: this.options }), !Ai && (Di === "paragraph" || Di === "heading" || Di === "tableCell" && !bi.ignored) && this.inlineParser.parse(bi);
                }
              }, Rr.prototype.incorporateLine = function(Mr) {
                var Fr = this.doc;
                this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, Mr.indexOf("\0") !== -1 && (Mr = Mr.replace(/\0/g, "�")), this.currentLine = Mr;
                for (var Gr = !0, ri; (ri = Fr.lastChild) && ri.open; ) {
                  switch (Fr = ri, this.findNextNonspace(), yl[Fr.type].continue(this, Fr)) {
                    case 0:
                      break;
                    case 1:
                      Gr = !1;
                      break;
                    case 2:
                      this.lastLineLength = Mr.length;
                      return;
                    default:
                      throw new Error("continue returned illegal value, must be 0, 1, or 2");
                  }
                  if (!Gr) {
                    Fr = Fr.parent;
                    break;
                  }
                }
                this.allClosed = Fr === this.oldtip, this.lastMatchedContainer = Fr;
                for (var bi = Fr.type !== "paragraph" && yl[Fr.type].acceptsLines, Ai = Iu.length; !bi; ) {
                  if (this.findNextNonspace(), Fr.type !== "table" && Fr.type !== "tableBody" && Fr.type !== "paragraph" && !this.indented && !Bq.test(Mr.slice(this.nextNonspace))) {
                    this.advanceNextNonspace();
                    break;
                  }
                  for (var Di = 0; Di < Ai; ) {
                    var ta = Iu[Di](this, Fr);
                    if (ta === 1) {
                      Fr = this.tip;
                      break;
                    } else if (ta === 2) {
                      Fr = this.tip, bi = !0;
                      break;
                    } else
                      Di++;
                  }
                  if (Di === Ai) {
                    this.advanceNextNonspace();
                    break;
                  }
                }
                if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
                  this.addLine();
                else {
                  this.closeUnmatchedBlocks(), this.blank && Fr.lastChild && (Fr.lastChild.lastLineBlank = !0);
                  for (var aa = Fr.type, wa = this.blank && !(aa === "blockQuote" || pf(Fr) && Fr.isFenced || aa === "item" && !Fr.firstChild && Fr.sourcepos[0][0] === this.lineNumber), xa = Fr; xa; )
                    xa.lastLineBlank = wa, xa = xa.parent;
                  yl[aa].acceptsLines ? (this.addLine(), KU(Fr) && Fr.htmlBlockType >= 1 && Fr.htmlBlockType <= 5 && Dq[Fr.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = Mr.length, this.finalize(Fr, this.lineNumber))) : this.offset < Mr.length && !this.blank && (Fr = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
                }
                this.lastLineLength = Mr.length;
              }, Rr.prototype.parse = function(Mr, Fr) {
                this.doc = Lu(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                var Gr = Mr.split(Pq), ri = Gr.length;
                this.lines = Fr || Gr, this.options.referenceDefinition && this.clearRefMaps(), Mr.charCodeAt(Mr.length - 1) === wu && (ri -= 1);
                for (var bi = 0; bi < ri; bi++)
                  this.incorporateLine(Gr[bi]);
                for (; this.tip; )
                  this.finalize(this.tip, ri);
                return this.processInlines(this.doc), this.doc;
              }, Rr.prototype.partialParseStart = function(Mr, Fr) {
                this.doc = Lu(), this.tip = this.doc, this.lineNumber = Mr - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                for (var Gr = Fr.length, ri = 0; ri < Gr; ri++)
                  this.incorporateLine(Fr[ri]);
                return this.doc;
              }, Rr.prototype.partialParseExtends = function(Mr) {
                for (var Fr = 0; Fr < Mr.length; Fr++)
                  this.incorporateLine(Mr[Fr]);
              }, Rr.prototype.partialParseFinish = function() {
                for (; this.tip; )
                  this.finalize(this.tip, this.lineNumber);
                this.processInlines(this.doc);
              }, Rr.prototype.setRefMaps = function(Mr, Fr, Gr) {
                this.refMap = Mr, this.refLinkCandidateMap = Fr, this.refDefCandidateMap = Gr;
              }, Rr.prototype.clearRefMaps = function() {
                [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(Mr) {
                  _z(Mr);
                });
              }, Rr;
            }()
          );
          function qf(Rr, Mr) {
            return Rr[0] < Mr[0] ? 1 : Rr[0] > Mr[0] ? -1 : Rr[1] < Mr[1] ? 1 : Rr[1] > Mr[1] ? -1 : 0;
          }
          function zq(Rr, Mr) {
            var Fr = Rr[0], Gr = Rr[1];
            return qf(Gr, Mr) === 1 ? 1 : qf(Fr, Mr) === -1 ? -1 : 0;
          }
          function qq(Rr, Mr) {
            if (!(Rr.parent !== Mr.parent || Rr === Mr)) {
              for (var Fr = Rr.next; Fr && Fr !== Mr; ) {
                for (var Gr = Fr.next, ri = 0, bi = ["parent", "prev", "next"]; ri < bi.length; ri++) {
                  var Ai = bi[ri];
                  Fr[Ai] && (yu(Fr[Ai].id), Fr[Ai] = null);
                }
                Fr = Gr;
              }
              Rr.next = Mr.next, Mr.next ? Mr.next.prev = Rr : Rr.parent.lastChild = Rr;
            }
          }
          function Fq(Rr) {
            for (var Mr = [], Fr = Rr.firstChild; Fr; )
              Mr.push(Fr), Fr = Fr.next;
            return Mr;
          }
          function Ff(Rr, Mr) {
            for (var Fr = 0, Gr = Mr; Fr < Gr.length; Fr++) {
              var ri = Gr[Fr];
              Rr.insertBefore(ri);
            }
          }
          function jq(Rr, Mr) {
            for (var Fr = Mr.length - 1; Fr >= 0; Fr -= 1)
              Rr.prependChild(Mr[Fr]);
          }
          function $q(Rr, Mr) {
            if (!(!Rr || !Rr.parent || Mr === 0)) {
              var Fr = Rr.parent.walker();
              Fr.resumeAt(Rr, !0);
              for (var Gr; Gr = Fr.next(); ) {
                var ri = Gr.node, bi = Gr.entering;
                bi && (ri.sourcepos[0][0] += Mr, ri.sourcepos[1][0] += Mr);
              }
            }
          }
          function jf(Rr, Mr) {
            var Fr = Rr[0], Gr = Rr[1];
            return Gr[0] < Mr ? 1 : Fr[0] > Mr ? -1 : 0;
          }
          function kc(Rr, Mr) {
            for (var Fr = Rr.firstChild; Fr; ) {
              var Gr = jf(Fr.sourcepos, Mr);
              if (Gr === 0)
                return Fr;
              if (Gr === -1)
                return Fr.prev || Fr;
              Fr = Fr.next;
            }
            return Rr.lastChild;
          }
          function Vq(Rr) {
            for (; Rr.lastChild; )
              Rr = Rr.lastChild;
            return Rr;
          }
          function Kq(Rr) {
            for (; Rr.parent && Rr.parent.type !== "document" && Rr.parent.sourcepos[0][0] === Rr.sourcepos[0][0]; )
              Rr = Rr.parent;
            return Rr;
          }
          function Gq(Rr, Mr) {
            for (var Fr = Rr.firstChild, Gr = null; Fr; ) {
              var ri = jf(Fr.sourcepos, Mr);
              if (ri === 0) {
                if (Fr.sourcepos[0][0] === Mr || !Fr.firstChild)
                  return Fr;
                Gr = Fr, Fr = Fr.firstChild;
              } else {
                if (ri === -1)
                  break;
                Gr = Fr, Fr = Fr.next;
              }
            }
            return Gr ? Kq(Vq(Gr)) : null;
          }
          function Wq(Rr, Mr) {
            for (var Fr = Rr, Gr = null; Fr; ) {
              var ri = zq(Fr.sourcepos, Mr);
              if (ri === 0)
                if (Fr.firstChild)
                  Gr = Fr, Fr = Fr.firstChild;
                else
                  return Fr;
              else {
                if (ri === -1)
                  return Gr;
                if (Fr.next)
                  Fr = Fr.next;
                else
                  return Gr;
              }
            }
            return Fr;
          }
          function $f(Rr) {
            return NU(Rr) || null;
          }
          function Ru(Rr, Mr, Fr) {
            if (Fr === void 0 && (Fr = null), Mr)
              for (var Gr = Mr.walker(); Mr && Mr !== Fr; ) {
                Rr(Mr);
                var ri = Gr.next();
                if (ri)
                  Mr = ri.node;
                else
                  break;
              }
          }
          function Zq(Rr) {
            var Mr = $f(Rr);
            if (!Mr)
              return !0;
            for (; Mr && Mr.type !== "document"; ) {
              if (!Mr.parent && !Mr.prev && !Mr.next)
                return !0;
              Mr = Mr.parent;
            }
            return !1;
          }
          var Vf = /\r\n|\n|\r/;
          function Xq(Rr) {
            var Mr = Rr.match(/^[ \t]+/);
            if (Mr && (Mr[0].length >= 2 || /\t/.test(Mr[0])))
              return !0;
            var Fr = Mr ? Rr.slice(Mr.length) : Rr;
            return Pf.test(Fr) || Hf.test(Fr);
          }
          function Jq(Rr) {
            return !Df(Rr) && Rr.indexOf("|") !== -1;
          }
          function Ou(Rr) {
            var Mr = Rr.id, Fr = Rr.title, Gr = Rr.sourcepos, ri = Rr.dest;
            return {
              id: Mr,
              title: Fr,
              sourcepos: Gr,
              unlinked: !1,
              destination: ri
            };
          }
          var Yq = (
            /** @class */
            function() {
              function Rr(Mr, Fr) {
                this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(Fr != null && Fr.referenceDefinition), this.parser = new Uq(Fr), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, Mr = Mr || "", this.lineTexts = Mr.split(Vf), this.root = this.parser.parse(Mr, this.lineTexts);
              }
              return Rr.prototype.updateLineTexts = function(Mr, Fr, Gr) {
                var ri, bi = Mr[0], Ai = Mr[1], Di = Fr[0], ta = Fr[1], aa = Gr.split(Vf), wa = aa.length, xa = this.lineTexts[bi - 1], ba = this.lineTexts[Di - 1];
                aa[0] = xa.slice(0, Ai - 1) + aa[0], aa[wa - 1] = aa[wa - 1] + ba.slice(ta - 1);
                var Na = Di - bi + 1;
                return (ri = this.lineTexts).splice.apply(ri, xr([bi - 1, Na], aa)), wa - Na;
              }, Rr.prototype.updateRootNodeState = function() {
                if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
                  this.root.lastLineBlank = !0, this.root.sourcepos = [
                    [1, 1],
                    [1, 0]
                  ];
                  return;
                }
                this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
                for (var Mr = this.lineTexts, Fr = Mr.length - 1; Mr[Fr] === ""; )
                  Fr -= 1;
                Mr.length - 2 > Fr && (Fr += 1), this.root.sourcepos[1] = [Fr + 1, Mr[Fr].length];
              }, Rr.prototype.replaceRangeNodes = function(Mr, Fr, Gr) {
                Mr ? (Ff(Mr, Gr), qq(Mr, Fr), [Mr.id, Fr.id].forEach(function(ri) {
                  return yu(ri);
                }), Mr.unlink()) : Fr ? (Ff(Fr, Gr), yu(Fr.id), Fr.unlink()) : jq(this.root, Gr);
              }, Rr.prototype.getNodeRange = function(Mr, Fr) {
                var Gr = kc(this.root, Mr[0]), ri = kc(this.root, Fr[0]);
                return ri && ri.next && Fr[0] + 1 === ri.next.sourcepos[0][0] && (ri = ri.next), [Gr, ri];
              }, Rr.prototype.trigger = function(Mr, Fr) {
                this.eventHandlerMap[Mr].forEach(function(Gr) {
                  Gr(Fr);
                });
              }, Rr.prototype.extendEndLine = function(Mr) {
                for (; this.lineTexts[Mr] === ""; )
                  Mr += 1;
                return Mr;
              }, Rr.prototype.parseRange = function(Mr, Fr, Gr, ri) {
                Mr && Mr.prev && (gf(Mr.prev) && Xq(this.lineTexts[Gr - 1]) || WU(Mr.prev) && Jq(this.lineTexts[Gr - 1])) && (Mr = Mr.prev, Gr = Mr.sourcepos[0][0]);
                for (var bi = this.lineTexts.slice(Gr - 1, ri), Ai = this.parser.partialParseStart(Gr, bi), Di = Fr ? Fr.next : this.root.firstChild, ta = Ai.lastChild, aa = ta && pf(ta) && ta.open, wa = ta && vf(ta) && ta.open, xa = ta && gf(ta); (aa || wa) && Di || xa && Di && (Di.type === "list" || Di.sourcepos[0][1] >= 2); ) {
                  var ba = this.extendEndLine(Di.sourcepos[1][0]);
                  this.parser.partialParseExtends(this.lineTexts.slice(ri, ba)), Mr || (Mr = Fr), Fr = Di, ri = ba, Di = Di.next;
                }
                this.parser.partialParseFinish();
                var Na = Fq(Ai);
                return { newNodes: Na, extStartNode: Mr, extEndNode: Fr };
              }, Rr.prototype.getRemovedNodeRange = function(Mr, Fr) {
                return !Mr || Mr && vl(Mr) || Fr && vl(Fr) ? null : {
                  id: [Mr.id, Fr.id],
                  line: [Mr.sourcepos[0][0] - 1, Fr.sourcepos[1][0] - 1]
                };
              }, Rr.prototype.markDeletedRefMap = function(Mr, Fr) {
                var Gr = this;
                if (!ml(this.refMap)) {
                  var ri = function(bi) {
                    if (vl(bi)) {
                      var Ai = Gr.refMap[bi.label];
                      Ai && bi.id === Ai.id && (Ai.unlinked = !0);
                    }
                  };
                  Mr && Ru(ri, Mr.parent, Fr), Fr && Ru(ri, Fr);
                }
              }, Rr.prototype.replaceWithNewRefDefState = function(Mr) {
                var Fr = this;
                if (!ml(this.refMap)) {
                  var Gr = function(ri) {
                    if (vl(ri)) {
                      var bi = ri.label, Ai = Fr.refMap[bi];
                      (!Ai || Ai.unlinked) && (Fr.refMap[bi] = Ou(ri));
                    }
                  };
                  Mr.forEach(function(ri) {
                    Ru(Gr, ri);
                  });
                }
              }, Rr.prototype.replaceWithRefDefCandidate = function() {
                var Mr = this;
                ml(this.refDefCandidateMap) || vc(this.refDefCandidateMap, function(Fr, Gr) {
                  var ri = Gr.label, bi = Gr.sourcepos, Ai = Mr.refMap[ri];
                  (!Ai || Ai.unlinked || Ai.sourcepos[0][0] > bi[0][0]) && (Mr.refMap[ri] = Ou(Gr));
                });
              }, Rr.prototype.getRangeWithRefDef = function(Mr, Fr, Gr, ri, bi) {
                if (this.referenceDefinition && !ml(this.refMap)) {
                  var Ai = kc(this.root, Mr - 1), Di = kc(this.root, Fr + 1);
                  Ai && vl(Ai) && Ai !== Gr && Ai !== ri && (Gr = Ai, Mr = Gr.sourcepos[0][0]), Di && vl(Di) && Di !== Gr && Di !== ri && (ri = Di, Fr = this.extendEndLine(ri.sourcepos[1][0] + bi));
                }
                return [Gr, ri, Mr, Fr];
              }, Rr.prototype.parse = function(Mr, Fr, Gr) {
                Gr === void 0 && (Gr = 0);
                var ri = this.getNodeRange(Mr, Fr), bi = ri[0], Ai = ri[1], Di = bi ? Math.min(bi.sourcepos[0][0], Mr[0]) : Mr[0], ta = this.extendEndLine((Ai ? Math.max(Ai.sourcepos[1][0], Fr[0]) : Fr[0]) + Gr), aa = this.parseRange.apply(this, this.getRangeWithRefDef(Di, ta, bi, Ai, Gr)), wa = aa.newNodes, xa = aa.extStartNode, ba = aa.extEndNode, Na = this.getRemovedNodeRange(xa, ba), Ra = ba ? ba.next : this.root.firstChild;
                return this.referenceDefinition ? (this.markDeletedRefMap(xa, ba), this.replaceRangeNodes(xa, ba, wa), this.replaceWithNewRefDefState(wa)) : this.replaceRangeNodes(xa, ba, wa), { nodes: wa, removedNodeRange: Na, nextNode: Ra };
              }, Rr.prototype.parseRefLink = function() {
                var Mr = this, Fr = [];
                return ml(this.refMap) || vc(this.refMap, function(Gr, ri) {
                  ri.unlinked && delete Mr.refMap[Gr], vc(Mr.refLinkCandidateMap, function(bi, Ai) {
                    var Di = Ai.node, ta = Ai.refLabel;
                    ta === Gr && Fr.push(Mr.parse(Di.sourcepos[0], Di.sourcepos[1]));
                  });
                }), Fr;
              }, Rr.prototype.removeUnlinkedCandidate = function() {
                ml(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(Mr) {
                  vc(Mr, function(Fr) {
                    Zq(Fr) && delete Mr[Fr];
                  });
                });
              }, Rr.prototype.editMarkdown = function(Mr, Fr, Gr) {
                var ri = this.updateLineTexts(Mr, Fr, Gr), bi = this.parse(Mr, Fr, ri), Ai = kz(bi, "nextNode");
                $q(bi.nextNode, ri), this.updateRootNodeState();
                var Di = [Ai];
                return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), Di = Di.concat(this.parseRefLink())), this.trigger("change", Di), Di;
              }, Rr.prototype.getLineTexts = function() {
                return this.lineTexts;
              }, Rr.prototype.getRootNode = function() {
                return this.root;
              }, Rr.prototype.findNodeAtPosition = function(Mr) {
                var Fr = Wq(this.root, Mr);
                return !Fr || Fr === this.root ? null : Fr;
              }, Rr.prototype.findFirstNodeAtLine = function(Mr) {
                return Gq(this.root, Mr);
              }, Rr.prototype.on = function(Mr, Fr) {
                this.eventHandlerMap[Mr].push(Fr);
              }, Rr.prototype.off = function(Mr, Fr) {
                var Gr = this.eventHandlerMap[Mr], ri = Gr.indexOf(Fr);
                Gr.splice(ri, 1);
              }, Rr.prototype.findNodeById = function(Mr) {
                return $f(Mr);
              }, Rr.prototype.removeAllNode = function() {
                OU();
              }, Rr;
            }()
          ), Qq = [
            "title",
            "textarea",
            "style",
            "xmp",
            "iframe",
            "noembed",
            "noframes",
            "script",
            "plaintext"
          ], Kf = new RegExp("<(/?(?:" + Qq.join("|") + ")[^>]*>)", "ig");
          function Gf(Rr) {
            return Kf.test(Rr) ? Rr.replace(Kf, function(Mr, Fr) {
              return "&lt;" + Fr;
            }) : Rr;
          }
          var Wf = {
            heading: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "h" + Rr.level,
                outerNewLine: !0
              };
            },
            text: function(Rr) {
              return {
                type: "text",
                content: Rr.literal
              };
            },
            softbreak: function(Rr, Mr) {
              var Fr = Mr.options;
              return {
                type: "html",
                content: Fr.softbreak
              };
            },
            linebreak: function() {
              return {
                type: "html",
                content: `<br />
`
              };
            },
            emph: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "em"
              };
            },
            strong: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "strong"
              };
            },
            paragraph: function(Rr, Mr) {
              var Fr, Gr = Mr.entering, ri = (Fr = Rr.parent) === null || Fr === void 0 ? void 0 : Fr.parent;
              return ri && ri.type === "list" && ri.listData.tight ? null : {
                type: Gr ? "openTag" : "closeTag",
                tagName: "p",
                outerNewLine: !0
              };
            },
            thematicBreak: function() {
              return {
                type: "openTag",
                tagName: "hr",
                outerNewLine: !0,
                selfClose: !0
              };
            },
            blockQuote: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "blockquote",
                outerNewLine: !0,
                innerNewLine: !0
              };
            },
            list: function(Rr, Mr) {
              var Fr = Mr.entering, Gr = Rr.listData, ri = Gr.type, bi = Gr.start, Ai = ri === "bullet" ? "ul" : "ol", Di = {};
              return Ai === "ol" && bi !== null && bi !== 1 && (Di.start = bi.toString()), {
                type: Fr ? "openTag" : "closeTag",
                tagName: Ai,
                attributes: Di,
                outerNewLine: !0
              };
            },
            item: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            htmlInline: function(Rr, Mr) {
              var Fr = Mr.options, Gr = Fr.tagFilter ? Gf(Rr.literal) : Rr.literal;
              return { type: "html", content: Gr };
            },
            htmlBlock: function(Rr, Mr) {
              var Fr = Mr.options, Gr = Fr.tagFilter ? Gf(Rr.literal) : Rr.literal;
              return Fr.nodeId ? [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "html", content: Gr },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ] : { type: "html", content: Gr, outerNewLine: !0 };
            },
            code: function(Rr) {
              return [
                { type: "openTag", tagName: "code" },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(Rr) {
              var Mr = Rr.info, Fr = Mr ? Mr.split(/\s+/) : [], Gr = [];
              return Fr.length > 0 && Fr[0].length > 0 && Gr.push("language-" + pl(Fr[0])), [
                { type: "openTag", tagName: "pre", outerNewLine: !0 },
                { type: "openTag", tagName: "code", classNames: Gr },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre", outerNewLine: !0 }
              ];
            },
            link: function(Rr, Mr) {
              var Fr = Mr.entering;
              if (Fr) {
                var Gr = Rr, ri = Gr.title, bi = Gr.destination;
                return {
                  type: "openTag",
                  tagName: "a",
                  attributes: Er({ href: pl(bi) }, ri && { title: pl(ri) })
                };
              }
              return { type: "closeTag", tagName: "a" };
            },
            image: function(Rr, Mr) {
              var Fr = Mr.getChildrenText, Gr = Mr.skipChildren, ri = Rr, bi = ri.title, Ai = ri.destination;
              return Gr(), {
                type: "openTag",
                tagName: "img",
                selfClose: !0,
                attributes: Er({ src: pl(Ai), alt: Fr(Rr) }, bi && { title: pl(bi) })
              };
            },
            customBlock: function(Rr, Mr, Fr) {
              var Gr = Rr.info.trim().toLowerCase(), ri = Fr[Gr];
              if (ri)
                try {
                  return ri(Rr, Mr);
                } catch (bi) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + Gr + " block node was parsed in markdown renderer: " + bi);
                }
              return [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            frontMatter: function(Rr) {
              return [
                {
                  type: "openTag",
                  tagName: "div",
                  outerNewLine: !0,
                  // Because front matter is metadata, it should not be render.
                  attributes: { style: "white-space: pre; display: none;" }
                },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            customInline: function(Rr, Mr, Fr) {
              var Gr = Rr, ri = Gr.info, bi = Gr.firstChild, Ai = ri.trim().toLowerCase(), Di = Fr[Ai], ta = Mr.entering;
              if (Di)
                try {
                  return Di(Rr, Mr);
                } catch (aa) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + Ai + " inline node was parsed in markdown renderer: " + aa);
                }
              return ta ? [
                { type: "openTag", tagName: "span" },
                { type: "text", content: "$$" + ri + (bi ? " " : "") }
              ] : [
                { type: "text", content: "$$" },
                { type: "closeTag", tagName: "span" }
              ];
            }
          }, Zf = {
            strike: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "del"
              };
            },
            item: function(Rr, Mr) {
              var Fr = Mr.entering, Gr = Rr.listData, ri = Gr.checked, bi = Gr.task;
              if (Fr) {
                var Ai = {
                  type: "openTag",
                  tagName: "li",
                  outerNewLine: !0
                };
                return bi ? [
                  Ai,
                  {
                    type: "openTag",
                    tagName: "input",
                    selfClose: !0,
                    attributes: Er(Er({}, ri && { checked: "" }), { disabled: "", type: "checkbox" })
                  },
                  {
                    type: "text",
                    content: " "
                  }
                ] : Ai;
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            table: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "table",
                outerNewLine: !0
              };
            },
            tableHead: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "thead",
                outerNewLine: !0
              };
            },
            tableBody: function(Rr, Mr) {
              var Fr = Mr.entering;
              return {
                type: Fr ? "openTag" : "closeTag",
                tagName: "tbody",
                outerNewLine: !0
              };
            },
            tableRow: function(Rr, Mr) {
              var Fr = Mr.entering;
              if (Fr)
                return {
                  type: "openTag",
                  tagName: "tr",
                  outerNewLine: !0
                };
              var Gr = [];
              if (Rr.lastChild)
                for (var ri = Rr.parent.parent.columns.length, bi = Rr.lastChild.endIdx, Ai = bi + 1; Ai < ri; Ai += 1)
                  Gr.push({
                    type: "openTag",
                    tagName: "td",
                    outerNewLine: !0
                  }, {
                    type: "closeTag",
                    tagName: "td",
                    outerNewLine: !0
                  });
              return Gr.push({
                type: "closeTag",
                tagName: "tr",
                outerNewLine: !0
              }), Gr;
            },
            tableCell: function(Rr, Mr) {
              var Fr = Mr.entering;
              if (Rr.ignored)
                return {
                  type: "text",
                  content: ""
                };
              var Gr = Rr.parent.parent, ri = Gr.type === "tableHead" ? "th" : "td", bi = Gr.parent, Ai = bi.columns[Rr.startIdx], Di = Ai != null && Ai.align ? { align: Ai.align } : null;
              return Fr ? Er({ type: "openTag", tagName: ri, outerNewLine: !0 }, Di && { attributes: Di }) : {
                type: "closeTag",
                tagName: ri,
                outerNewLine: !0
              };
            }
          }, eF = {
            softbreak: `
`,
            gfm: !1,
            tagFilter: !1,
            nodeId: !1
          };
          function tF(Rr) {
            for (var Mr = [], Fr = Rr.walker(), Gr = null; Gr = Fr.next(); ) {
              var ri = Gr.node;
              ri.type === "text" && Mr.push(ri.literal);
            }
            return Mr.join("");
          }
          var rF = (
            /** @class */
            function() {
              function Rr(Mr) {
                this.buffer = [], this.options = Er(Er({}, eF), Mr), this.convertors = this.createConvertors(), delete this.options.convertors;
              }
              return Rr.prototype.createConvertors = function() {
                var Mr = Er({}, Wf);
                if (this.options.gfm && (Mr = Er(Er({}, Mr), Zf)), this.options.convertors) {
                  var Fr = this.options.convertors, Gr = Object.keys(Fr), ri = Er(Er({}, Wf), Zf);
                  Gr.forEach(function(bi) {
                    var Ai = Mr[bi], Di = Fr[bi], ta = Object.keys(ri).indexOf(bi) === -1 ? bi.toLowerCase() : bi;
                    Ai ? Mr[ta] = function(aa, wa, xa) {
                      return wa.origin = function() {
                        return Ai(aa, wa, xa);
                      }, Di(aa, wa);
                    } : Mr[ta] = Di;
                  });
                }
                return Mr;
              }, Rr.prototype.getConvertors = function() {
                return this.convertors;
              }, Rr.prototype.getOptions = function() {
                return this.options;
              }, Rr.prototype.render = function(Mr) {
                var Fr = this;
                this.buffer = [];
                for (var Gr = Mr.walker(), ri = null, bi = function() {
                  var Di = ri.node, ta = ri.entering, aa = Ai.convertors[Di.type];
                  if (!aa)
                    return "continue";
                  var wa = !1, xa = {
                    entering: ta,
                    leaf: !bu(Di),
                    options: Ai.options,
                    getChildrenText: tF,
                    skipChildren: function() {
                      wa = !0;
                    }
                  }, ba = vf(Di) || ZU(Di) ? aa(Di, xa, Ai.convertors) : aa(Di, xa);
                  if (ba) {
                    var Na = Array.isArray(ba) ? ba : [ba];
                    Na.forEach(function(Ra, io) {
                      Ra.type === "openTag" && Fr.options.nodeId && io === 0 && (Ra.attributes || (Ra.attributes = {}), Ra.attributes["data-nodeid"] = String(Di.id)), Fr.renderHTMLNode(Ra);
                    }), wa && (Gr.resumeAt(Di, !1), Gr.next());
                  }
                }, Ai = this; ri = Gr.next(); )
                  bi();
                return this.addNewLine(), this.buffer.join("");
              }, Rr.prototype.renderHTMLNode = function(Mr) {
                switch (Mr.type) {
                  case "openTag":
                  case "closeTag":
                    this.renderElementNode(Mr);
                    break;
                  case "text":
                    this.renderTextNode(Mr);
                    break;
                  case "html":
                    this.renderRawHtmlNode(Mr);
                    break;
                }
              }, Rr.prototype.generateOpenTagString = function(Mr) {
                var Fr = this, Gr = Mr.tagName, ri = Mr.classNames, bi = Mr.attributes;
                this.buffer.push("<" + Gr), ri && ri.length > 0 && this.buffer.push(' class="' + ri.join(" ") + '"'), bi && Object.keys(bi).forEach(function(Ai) {
                  var Di = bi[Ai];
                  Fr.buffer.push(" " + Ai + '="' + Di + '"');
                }), Mr.selfClose && this.buffer.push(" /"), this.buffer.push(">");
              }, Rr.prototype.generateCloseTagString = function(Mr) {
                var Fr = Mr.tagName;
                this.buffer.push("</" + Fr + ">");
              }, Rr.prototype.addNewLine = function() {
                this.buffer.length && gc(gc(this.buffer)) !== `
` && this.buffer.push(`
`);
              }, Rr.prototype.addOuterNewLine = function(Mr) {
                Mr.outerNewLine && this.addNewLine();
              }, Rr.prototype.addInnerNewLine = function(Mr) {
                Mr.innerNewLine && this.addNewLine();
              }, Rr.prototype.renderTextNode = function(Mr) {
                this.buffer.push(pl(Mr.content));
              }, Rr.prototype.renderRawHtmlNode = function(Mr) {
                this.addOuterNewLine(Mr), this.buffer.push(Mr.content), this.addOuterNewLine(Mr);
              }, Rr.prototype.renderElementNode = function(Mr) {
                Mr.type === "openTag" ? (this.addOuterNewLine(Mr), this.generateOpenTagString(Mr), Mr.selfClose ? this.addOuterNewLine(Mr) : this.addInnerNewLine(Mr)) : (this.addInnerNewLine(Mr), this.generateCloseTagString(Mr), this.addOuterNewLine(Mr));
              }, Rr;
            }()
          ), nF = mr(956), iF = /* @__PURE__ */ mr.n(nF), aF = mr(969), Xf = /* @__PURE__ */ mr.n(aF), oF = mr(348), Jf = /* @__PURE__ */ mr.n(oF), sF = mr(349), Yf = /* @__PURE__ */ mr.n(sF), lF = mr(204), Qf = /* @__PURE__ */ mr.n(lF), cF = mr(462), Du = /* @__PURE__ */ mr.n(cF), uF = mr(522), ed = /* @__PURE__ */ mr.n(uF), fF = mr(990), dF = /* @__PURE__ */ mr.n(fF), hF = mr(322), pF = /* @__PURE__ */ mr.n(hF), gF = mr(758), vF = /* @__PURE__ */ mr.n(gF), mF = mr(929), _c = /* @__PURE__ */ mr.n(mF), bF = mr(714), yF = /* @__PURE__ */ mr.n(bF);
          mr(471);
          var td = "[A-Za-z][A-Za-z0-9-]*", kF = "[a-zA-Z_:][a-zA-Z0-9:._-]*", _F = "[^\"'=<>`\\x00-\\x20]+", wF = "'[^']*'", EF = '"[^"]*"', xF = "(?:" + _F + "|" + wF + "|" + EF + ")", CF = "(?:\\s*=\\s*" + xF + ")", rd = "(?:\\s+" + kF + CF + "?)", TF = "<(" + td + ")(" + rd + ")*\\s*/?>", AF = "</(" + td + ")\\s*[>]", SF = "(?:" + TF + "|" + AF + ")", nd = new RegExp("^" + SF, "i");
          mr(934), mr(391);
          function Bu(Rr, Mr) {
            return Rr.indexOf(Mr) !== -1;
          }
          var IF = ["rel", "target", "hreflang", "type"];
          function LF(Rr) {
            if (!Rr)
              return null;
            var Mr = {};
            return IF.forEach(function(Fr) {
              _c()(Rr[Fr]) || (Mr[Fr] = Rr[Fr]);
            }), Mr;
          }
          function MF(Rr) {
            return Rr[Rr.length - 1];
          }
          function Pu(Rr) {
            return typeof Rr == "object" && Rr !== null;
          }
          function Hu(Rr, Mr) {
            var Fr = yr({}, Rr);
            return Rr && Mr && Object.keys(Mr).forEach(function(Gr) {
              Pu(Fr[Gr]) ? Array.isArray(Mr[Gr]) ? Fr[Gr] = Uu(Mr[Gr]) : Fr.hasOwnProperty(Gr) ? Fr[Gr] = Hu(Fr[Gr], Mr[Gr]) : Fr[Gr] = zu(Mr[Gr]) : Fr[Gr] = Mr[Gr];
            }), Fr;
          }
          function Uu(Rr) {
            return Rr.map(function(Mr) {
              return Pu(Mr) ? Array.isArray(Mr) ? Uu(Mr) : zu(Mr) : Mr;
            });
          }
          function zu(Rr) {
            var Mr = Object.keys(Rr);
            return Mr.length ? Mr.reduce(function(Fr, Gr) {
              return Pu(Rr[Gr]) ? Fr[Gr] = Array.isArray(Rr[Gr]) ? Uu(Rr[Gr]) : zu(Rr[Gr]) : Fr[Gr] = Rr[Gr], Fr;
            }, {}) : Rr;
          }
          function id(Rr, Mr) {
            return Mr === void 0 && (Mr = {}), Object.keys(Mr).forEach(function(Fr) {
              Rr.hasOwnProperty(Fr) && typeof Rr[Fr] == "object" ? Array.isArray(Mr[Fr]) ? Rr[Fr] = Mr[Fr] : id(Rr[Fr], Mr[Fr]) : Rr[Fr] = Mr[Fr];
            }), Rr;
          }
          function ad(Rr, Mr) {
            return Rr > Mr ? [Mr, Rr] : [Rr, Mr];
          }
          function RF(Rr, Mr, Fr) {
            var Gr = parseInt(Rr.left, 10), ri = parseInt(Rr.top, 10), bi = parseInt(Rr.width, 10) + parseInt(Rr.paddingLeft, 10) + parseInt(Rr.paddingRight, 10), Ai = parseInt(Rr.height, 10) + parseInt(Rr.paddingTop, 10) + parseInt(Rr.paddingBottom, 10);
            return Mr >= Gr && Mr <= Gr + bi && Fr >= ri && Fr <= ri + Ai;
          }
          var NF = "toastui-editor-";
          function wc() {
            for (var Rr = [], Mr = 0; Mr < arguments.length; Mr++)
              Rr[Mr] = arguments[Mr];
            for (var Fr = [], Gr = 0, ri = Rr; Gr < ri.length; Gr++) {
              var bi = ri[Gr], Ai = void 0;
              Array.isArray(bi) ? Ai = bi[0] ? bi[1] : null : Ai = bi, Ai && Fr.push("" + NF + Ai);
            }
            return Fr.join(" ");
          }
          function od(Rr) {
            Rr.parentNode && Rr.parentNode.removeChild(Rr);
          }
          function sd(Rr, Mr, Fr) {
            _c()(Fr) && (Fr = !yF()(Rr, Mr));
            var Gr = Fr ? Qf() : Du();
            Gr(Rr, Mr);
          }
          function OF(Rr, Mr) {
            var Fr = document.createElement("div");
            vF()(Rr) ? Fr.innerHTML = Rr : Fr.appendChild(Rr);
            var Gr = Fr.firstChild;
            return Mr && Mr.appendChild(Gr), Gr;
          }
          function DF(Rr) {
            var Mr = /<img class="ProseMirror-separator" alt="">/g, Fr = / class="ProseMirror-trailingBreak"/g, Gr = Rr;
            return Gr = Gr.replace(Mr, ""), Gr = Gr.replace(Fr, ""), Gr;
          }
          var BF = mr(294), ld = /* @__PURE__ */ mr.n(BF);
          function PF(Rr) {
            return Rr.sourcepos[0][1];
          }
          function HF(Rr) {
            switch (Rr.type) {
              case "code":
              case "text":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "htmlInline":
              case "linebreak":
              case "softbreak":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          function UF(Rr, Mr, Fr) {
            for (Fr === void 0 && (Fr = !0), Rr = Fr ? Rr : Rr.parent; Rr && Rr.type !== "document"; ) {
              if (Mr(Rr))
                return Rr;
              Rr = Rr.parent;
            }
            return null;
          }
          function zF(Rr) {
            var Mr = Rr.firstChild.literal;
            switch (Rr.type) {
              case "emph":
                return "*" + Mr + "*";
              case "strong":
                return "**" + Mr + "**";
              case "strike":
                return "~~" + Mr + "~~";
              case "code":
                return "`" + Mr + "`";
              case "link":
              case "image":
                var Fr = Rr, Gr = Fr.destination, ri = Fr.title, bi = Rr.type === "link" ? "" : "!";
                return bi + "[" + Mr + "](" + Gr + (ri ? ' "' + ri + '"' : "") + ")";
              default:
                return null;
            }
          }
          var qF = {}, cd = /\$\$widget\d+\s/;
          function ud(Rr) {
            var Mr = Rr.search(cd);
            if (Mr !== -1) {
              var Fr = Rr.substring(Mr), Gr = Fr.replace(cd, "").replace("$$", "");
              Rr = Rr.substring(0, Mr), Rr += ud(Gr);
            }
            return Rr;
          }
          function FF(Rr, Mr) {
            var Fr = qF[Rr], Gr = Fr.rule, ri = Fr.toDOM, bi = ud(Mr).match(Gr);
            return bi && (Mr = bi[0]), ri(Mr);
          }
          function jF(Rr) {
            for (var Mr, Fr = "", Gr = Rr.walker(); Mr = Gr.next(); ) {
              var ri = Mr.node, bi = Mr.entering;
              bi && (ri !== Rr && ri.type !== "text" ? (Fr += zF(ri), Gr.resumeAt(Rr, !1), Gr.next()) : ri.type === "text" && (Fr += ri.literal));
            }
            return Fr;
          }
          var $F = mr(368), VF = /* @__PURE__ */ mr.n($F), KF = ["iframe", "embed"], fd = [];
          function GF(Rr) {
            Bu(KF, Rr) && fd.push(Rr.toLowerCase());
          }
          function WF(Rr, Mr) {
            return VF().sanitize(Rr, yr({ ADD_TAGS: fd, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
              "input",
              "script",
              "textarea",
              "form",
              "button",
              "select",
              "meta",
              "style",
              "link",
              "title",
              "object",
              "base"
            ] }, Mr));
          }
          function ZF(Rr, Mr) {
            return Rr.literal.replace(new RegExp("(<\\s*" + Mr + "[^>]*>)|(</" + Mr + "\\s*[>])", "ig"), "").trim();
          }
          function XF(Rr) {
            Rr = Rr.match(nd)[0];
            var Mr = Rr.match(new RegExp(rd, "g"));
            return Mr ? Mr.reduce(function(Fr, Gr) {
              var ri = Gr.trim().split("="), bi = ri[0], Ai = ri.slice(1);
              return Ai.length && (Fr[bi] = Ai.join("=").replace(/'|"/g, "").trim()), Fr;
            }, {}) : {};
          }
          var JF = /^\s*<\s*\//, YF = {
            paragraph: function(Rr, Mr) {
              var Fr = Mr.entering, Gr = Mr.origin, ri = Mr.options;
              return ri.nodeId ? {
                type: Fr ? "openTag" : "closeTag",
                outerNewLine: !0,
                tagName: "p"
              } : Gr();
            },
            softbreak: function(Rr) {
              var Mr = Rr.prev && Rr.prev.type === "htmlInline", Fr = Mr && /<br ?\/?>/.test(Rr.prev.literal), Gr = Fr ? `
` : `<br>
`;
              return { type: "html", content: Gr };
            },
            item: function(Rr, Mr) {
              var Fr = Mr.entering;
              if (Fr) {
                var Gr = {}, ri = [];
                return Rr.listData.task && (Gr["data-task"] = "", ri.push("task-list-item"), Rr.listData.checked && (ri.push("checked"), Gr["data-task-checked"] = "")), {
                  type: "openTag",
                  tagName: "li",
                  classNames: ri,
                  attributes: Gr,
                  outerNewLine: !0
                };
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            code: function(Rr) {
              var Mr = { "data-backticks": String(Rr.tickCount) };
              return [
                { type: "openTag", tagName: "code", attributes: Mr },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(Rr) {
              var Mr = Rr, Fr = Mr.fenceLength, Gr = Mr.info, ri = Gr ? Gr.split(/\s+/) : [], bi = [], Ai = {};
              if (Fr > 3 && (Ai["data-backticks"] = Fr), ri.length > 0 && ri[0].length > 0) {
                var Di = ri[0];
                bi.push("lang-" + Di), Ai["data-language"] = Di;
              }
              return [
                { type: "openTag", tagName: "pre", classNames: bi },
                { type: "openTag", tagName: "code", attributes: Ai },
                { type: "text", content: Rr.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre" }
              ];
            },
            customInline: function(Rr, Mr) {
              var Fr = Mr.origin, Gr = Mr.entering, ri = Mr.skipChildren, bi = Rr.info;
              if (bi.indexOf("widget") !== -1 && Gr) {
                ri();
                var Ai = jF(Rr), Di = FF(bi, Ai).outerHTML;
                return [
                  { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
                  { type: "html", content: Di },
                  { type: "closeTag", tagName: "span" }
                ];
              }
              return Fr();
            }
          };
          function QF(Rr, Mr) {
            var Fr = yr({}, YF);
            return Rr && (Fr.link = function(Gr, ri) {
              var bi = ri.entering, Ai = ri.origin, Di = Ai();
              return bi && (Di.attributes = yr(yr({}, Di.attributes), Rr)), Di;
            }), Mr && Object.keys(Mr).forEach(function(Gr) {
              var ri = Fr[Gr], bi = Mr[Gr];
              ri && ld()(bi) ? Fr[Gr] = function(Ai, Di) {
                var ta = yr({}, Di);
                return ta.origin = function() {
                  return ri(Ai, Di);
                }, bi(Ai, ta);
              } : Bu(["htmlBlock", "htmlInline"], Gr) && !ld()(bi) ? Fr[Gr] = function(Ai, Di) {
                var ta = Ai.literal.match(nd);
                if (ta) {
                  var aa = ta[0], wa = ta[1], xa = ta[3], ba = (wa || xa).toLowerCase(), Na = bi[ba], Ra = ZF(Ai, ba);
                  if (Na) {
                    var io = yr({}, Ai);
                    return io.attrs = XF(aa), io.childrenHTML = Ra, io.type = ba, Di.entering = !JF.test(Ai.literal), Na(io, Di);
                  }
                }
                return Di.origin();
              } : Fr[Gr] = bi;
            }), Fr;
          }
          var ej = ["UL", "OL", "BLOCKQUOTE"];
          function tj(Rr, Mr) {
            for (var Fr = 0; Rr && Rr !== Mr && (Bu(ej, Rr.tagName) || (Fr += Rr.offsetTop), Rr.offsetParent !== Mr.offsetParent); )
              Rr = Rr.parentElement;
            return Fr;
          }
          function rj(Rr, Mr) {
            for (var Fr = Mr, Gr = null; Fr; ) {
              var ri = Fr.firstElementChild;
              if (!ri)
                break;
              var bi = hd(ri, Rr, tj(Fr, Mr));
              Gr = Fr, Fr = bi;
            }
            var Ai = Fr || Gr;
            return Ai === Mr ? null : Ai;
          }
          function hd(Rr, Mr, Fr) {
            return Rr && Mr > Fr + Rr.offsetTop ? hd(Rr.nextElementSibling, Mr, Fr) || Rr : null;
          }
          var nj = {};
          function qu(Rr) {
            Rr && (delete nj[Number(Rr.getAttribute("data-nodeid"))], dF()(Rr.children).forEach(function(Mr) {
              qu(Mr);
            }));
          }
          var Fu = wc("md-preview-highlight");
          function ij(Rr, Mr) {
            for (var Fr = Rr.firstChild; Fr && Fr.next && !(PF(Fr.next) > Mr + 1); )
              Fr = Fr.next;
            return Fr;
          }
          var aj = (
            /** @class */
            function() {
              function Rr(Mr, Fr) {
                var Gr = document.createElement("div");
                this.el = Gr, this.eventEmitter = Mr, this.isViewer = !!Fr.isViewer, this.el.className = wc("md-preview");
                var ri = Fr.linkAttributes, bi = Fr.customHTMLRenderer, Ai = Fr.sanitizer, Di = Fr.highlight, ta = Di === void 0 ? !1 : Di;
                this.renderer = new rF({
                  gfm: !0,
                  nodeId: !0,
                  convertors: QF(ri, bi)
                }), this.cursorNodeId = null, this.sanitizer = Ai, this.initEvent(ta), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
              }
              return Rr.prototype.initContentSection = function() {
                this.previewContent = OF('<div class="' + wc("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
              }, Rr.prototype.toggleActive = function(Mr) {
                sd(this.el, "active", Mr);
              }, Rr.prototype.initEvent = function(Mr) {
                var Fr = this;
                this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (Mr && (this.eventEmitter.listen("changeToolbarState", function(Gr) {
                  var ri = Gr.mdNode, bi = Gr.cursorPos;
                  Fr.updateCursorNode(ri, bi);
                }), this.eventEmitter.listen("blur", function() {
                  Fr.removeHighlight();
                })), Jf()(this.el, "scroll", function(Gr) {
                  Fr.eventEmitter.emit("scroll", "preview", rj(Gr.target.scrollTop, Fr.previewContent));
                }), this.eventEmitter.listen("changePreviewTabPreview", function() {
                  return Fr.toggleActive(!0);
                }), this.eventEmitter.listen("changePreviewTabWrite", function() {
                  return Fr.toggleActive(!1);
                }));
              }, Rr.prototype.removeHighlight = function() {
                if (this.cursorNodeId) {
                  var Mr = this.getElementByNodeId(this.cursorNodeId);
                  Mr && Du()(Mr, Fu);
                }
              }, Rr.prototype.updateCursorNode = function(Mr, Fr) {
                Mr && (Mr = UF(Mr, function(Ai) {
                  return !HF(Ai);
                }), Mr.type === "tableRow" ? Mr = ij(Mr, Fr[1]) : Mr.type === "tableBody" && (Mr = null));
                var Gr = Mr ? Mr.id : null;
                if (this.cursorNodeId !== Gr) {
                  var ri = this.getElementByNodeId(this.cursorNodeId), bi = this.getElementByNodeId(Gr);
                  ri && Du()(ri, Fu), bi && Qf()(bi, Fu), this.cursorNodeId = Gr;
                }
              }, Rr.prototype.getElementByNodeId = function(Mr) {
                return Mr ? this.previewContent.querySelector('[data-nodeid="' + Mr + '"]') : null;
              }, Rr.prototype.update = function(Mr) {
                var Fr = this;
                Mr.forEach(function(Gr) {
                  return Fr.replaceRangeNodes(Gr);
                }), this.eventEmitter.emit("afterPreviewRender", this);
              }, Rr.prototype.replaceRangeNodes = function(Mr) {
                var Fr = this, Gr = Mr.nodes, ri = Mr.removedNodeRange, bi = this.previewContent, Ai = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(Gr.map(function(Ra) {
                  return Fr.renderer.render(Ra);
                }).join("")));
                if (!ri)
                  bi.insertAdjacentHTML("afterbegin", Ai);
                else {
                  var Di = ri.id, ta = Di[0], aa = Di[1], wa = this.getElementByNodeId(ta), xa = this.getElementByNodeId(aa);
                  if (wa) {
                    wa.insertAdjacentHTML("beforebegin", Ai);
                    for (var ba = wa; ba && ba !== xa; ) {
                      var Na = ba.nextElementSibling;
                      od(ba), qu(ba), ba = Na;
                    }
                    ba != null && ba.parentNode && (od(ba), qu(ba));
                  }
                }
              }, Rr.prototype.getRenderer = function() {
                return this.renderer;
              }, Rr.prototype.destroy = function() {
                Yf()(this.el, "scroll"), this.el = null;
              }, Rr.prototype.getElement = function() {
                return this.el;
              }, Rr.prototype.getHTML = function() {
                return DF(this.previewContent.innerHTML);
              }, Rr.prototype.setHTML = function(Mr) {
                this.previewContent.innerHTML = Mr;
              }, Rr.prototype.setHeight = function(Mr) {
                ed()(this.el, { height: Mr + "px" });
              }, Rr.prototype.setMinHeight = function(Mr) {
                ed()(this.el, { minHeight: Mr + "px" });
              }, Rr;
            }()
          ), oj = aj, Ec = mr(814), ju = mr(479), pd = mr(311), sj = mr(481), lj = mr(43), cj = mr(928), uj = /* @__PURE__ */ mr.n(cj), fj = (
            /** @class */
            function() {
              function Rr() {
                this.keys = [], this.values = [];
              }
              return Rr.prototype.getKeyIndex = function(Mr) {
                return uj()(Mr, this.keys);
              }, Rr.prototype.get = function(Mr) {
                return this.values[this.getKeyIndex(Mr)];
              }, Rr.prototype.set = function(Mr, Fr) {
                var Gr = this.getKeyIndex(Mr);
                return Gr > -1 ? this.values[Gr] = Fr : (this.keys.push(Mr), this.values.push(Fr)), this;
              }, Rr.prototype.has = function(Mr) {
                return this.getKeyIndex(Mr) > -1;
              }, Rr.prototype.delete = function(Mr) {
                var Fr = this.getKeyIndex(Mr);
                return Fr > -1 ? (this.keys.splice(Fr, 1), this.values.splice(Fr, 1), !0) : !1;
              }, Rr.prototype.forEach = function(Mr, Fr) {
                var Gr = this;
                Fr === void 0 && (Fr = this), this.values.forEach(function(ri, bi) {
                  ri && Gr.keys[bi] && Mr.call(Fr, ri, Gr.keys[bi], Gr);
                });
              }, Rr.prototype.clear = function() {
                this.keys = [], this.values = [];
              }, Rr;
            }()
          ), gd = fj, $u = "en-US", dj = (
            /** @class */
            function() {
              function Rr() {
                this.code = $u, this.langs = new gd();
              }
              return Rr.prototype.setCode = function(Mr) {
                this.code = Mr || $u;
              }, Rr.prototype.setLanguage = function(Mr, Fr) {
                var Gr = this;
                Mr = [].concat(Mr), Mr.forEach(function(ri) {
                  if (!Gr.langs.has(ri))
                    Gr.langs.set(ri, Fr);
                  else {
                    var bi = Gr.langs.get(ri);
                    Gr.langs.set(ri, Xf()(bi, Fr));
                  }
                });
              }, Rr.prototype.get = function(Mr, Fr) {
                Fr || (Fr = this.code);
                var Gr = this.langs.get(Fr);
                Gr || (Gr = this.langs.get($u));
                var ri = Gr[Mr];
                if (!ri)
                  throw new Error('There is no text key "' + Mr + '" in ' + Fr);
                return ri;
              }, Rr;
            }()
          ), hj = new dj();
          function pj(Rr, Mr) {
            for (var Fr = Rr.depth; Fr; ) {
              var Gr = Rr.node(Fr);
              if (Mr(Gr, Fr))
                return {
                  node: Gr,
                  depth: Fr,
                  offset: Fr > 0 ? Rr.before(Fr) : 0
                };
              Fr -= 1;
            }
            return null;
          }
          var vd = /* @__PURE__ */ new Map(), md = (
            /** @class */
            function() {
              function Rr(Mr, Fr, Gr, ri) {
                this.table = Mr, this.tableRows = Fr, this.tableStartPos = Gr, this.rowInfo = ri;
              }
              return Rr.create = function(Mr) {
                var Fr = pj(Mr, function(Ra) {
                  var io = Ra.type;
                  return io.name === "table";
                });
                if (Fr) {
                  var Gr = Fr.node, ri = Fr.depth, bi = Fr.offset, Ai = vd.get(Gr);
                  if ((Ai == null ? void 0 : Ai.tableStartPos) === bi + 1)
                    return Ai;
                  var Di = [], ta = Mr.start(ri), aa = Gr.child(0), wa = Gr.child(1), xa = Vu(aa, ta), ba = Vu(wa, ta + aa.nodeSize);
                  aa.forEach(function(Ra) {
                    return Di.push(Ra);
                  }), wa.forEach(function(Ra) {
                    return Di.push(Ra);
                  });
                  var Na = new Rr(Gr, Di, ta, xa.concat(ba));
                  return vd.set(Gr, Na), Na;
                }
                return null;
              }, Object.defineProperty(Rr.prototype, "totalRowCount", {
                get: function() {
                  return this.rowInfo.length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Rr.prototype, "totalColumnCount", {
                get: function() {
                  return this.rowInfo[0].length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Rr.prototype, "tableStartOffset", {
                get: function() {
                  return this.tableStartPos;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Rr.prototype, "tableEndOffset", {
                get: function() {
                  return this.tableStartPos + this.table.nodeSize - 1;
                },
                enumerable: !1,
                configurable: !0
              }), Rr.prototype.getCellInfo = function(Mr, Fr) {
                return this.rowInfo[Mr][Fr];
              }, Rr.prototype.posAt = function(Mr, Fr) {
                for (var Gr = 0, ri = this.tableStartPos; ; Gr += 1) {
                  var bi = ri + this.tableRows[Gr].nodeSize;
                  if (Gr === Mr) {
                    for (var Ai = Fr; Ai < this.totalColumnCount && this.rowInfo[Gr][Ai].offset < ri; )
                      Ai += 1;
                    return Ai === this.totalColumnCount ? bi : this.rowInfo[Gr][Ai].offset;
                  }
                  ri = bi;
                }
              }, Rr.prototype.getNodeAndPos = function(Mr, Fr) {
                var Gr = this.rowInfo[Mr][Fr];
                return {
                  node: this.table.nodeAt(Gr.offset - this.tableStartOffset),
                  pos: Gr.offset
                };
              }, Rr.prototype.extendedRowspan = function(Mr, Fr) {
                return !1;
              }, Rr.prototype.extendedColspan = function(Mr, Fr) {
                return !1;
              }, Rr.prototype.getRowspanCount = function(Mr, Fr) {
                return 0;
              }, Rr.prototype.getColspanCount = function(Mr, Fr) {
                return 0;
              }, Rr.prototype.decreaseColspanCount = function(Mr, Fr) {
                return 0;
              }, Rr.prototype.decreaseRowspanCount = function(Mr, Fr) {
                return 0;
              }, Rr.prototype.getColspanStartInfo = function(Mr, Fr) {
                return null;
              }, Rr.prototype.getRowspanStartInfo = function(Mr, Fr) {
                return null;
              }, Rr.prototype.getCellStartOffset = function(Mr, Fr) {
                var Gr = this.rowInfo[Mr][Fr].offset;
                return this.extendedRowspan(Mr, Fr) ? this.posAt(Mr, Fr) : Gr;
              }, Rr.prototype.getCellEndOffset = function(Mr, Fr) {
                var Gr = this.rowInfo[Mr][Fr], ri = Gr.offset, bi = Gr.nodeSize;
                return this.extendedRowspan(Mr, Fr) ? this.posAt(Mr, Fr) : ri + bi;
              }, Rr.prototype.getCellIndex = function(Mr) {
                for (var Fr = 0; Fr < this.totalRowCount; Fr += 1)
                  for (var Gr = this.rowInfo[Fr], ri = 0; ri < this.totalColumnCount; ri += 1)
                    if (Gr[ri].offset + 1 > Mr.pos)
                      return [Fr, ri];
                return [0, 0];
              }, Rr.prototype.getRectOffsets = function(Mr, Fr) {
                var Gr, ri, bi;
                Fr === void 0 && (Fr = Mr), Mr.pos > Fr.pos && (Gr = [Fr, Mr], Mr = Gr[0], Fr = Gr[1]);
                var Ai = this.getCellIndex(Mr), Di = Ai[0], ta = Ai[1], aa = this.getCellIndex(Fr), wa = aa[0], xa = aa[1];
                return ri = ad(Di, wa), Di = ri[0], wa = ri[1], bi = ad(ta, xa), ta = bi[0], xa = bi[1], this.getSpannedOffsets({ startRowIdx: Di, startColIdx: ta, endRowIdx: wa, endColIdx: xa });
              }, Rr.prototype.getSpannedOffsets = function(Mr) {
                return Mr;
              }, Rr;
            }()
          ), Vu = function(Rr, Mr) {
            var Fr = [];
            return Rr.forEach(function(Gr, ri) {
              var bi = { rowspanMap: {}, colspanMap: {}, length: 0 };
              Gr.forEach(function(Ai, Di) {
                for (var ta = Ai.nodeSize, aa = 0; bi[aa]; )
                  aa += 1;
                bi[aa] = {
                  // 2 is the sum of the front and back positions of the tag
                  offset: Mr + ri + Di + 2,
                  nodeSize: ta
                }, bi.length += 1;
              }), Fr.push(bi);
            }), Fr;
          };
          function gj(Rr, Mr) {
            return id(md.prototype, Rr), Vu = Mr, md;
          }
          function vj(Rr) {
            var Mr = Rr.plugin, Fr = Rr.eventEmitter, Gr = Rr.usageStatistics, ri = Rr.instance, bi = { Plugin: Ec.Plugin, PluginKey: Ec.PluginKey, Selection: Ec.Selection, TextSelection: Ec.TextSelection }, Ai = { Decoration: pd.Decoration, DecorationSet: pd.DecorationSet }, Di = { Fragment: lj.Fragment }, ta = { InputRule: ju.InputRule, inputRules: ju.inputRules, undoInputRule: ju.undoInputRule }, aa = { keymap: sj.keymap }, wa = {
              eventEmitter: Fr,
              usageStatistics: Gr,
              instance: ri,
              pmState: bi,
              pmView: Ai,
              pmModel: Di,
              pmRules: ta,
              pmKeymap: aa,
              i18n: hj
            };
            if (pF()(Mr)) {
              var xa = Mr[0], ba = Mr[1], Na = ba === void 0 ? {} : ba;
              return xa(wa, Na);
            }
            return Mr(wa);
          }
          function mj(Rr) {
            var Mr = Rr.plugins, Fr = Rr.eventEmitter, Gr = Rr.usageStatistics, ri = Rr.instance;
            return Fr.listen("mixinTableOffsetMapPrototype", gj), (Mr != null ? Mr : []).reduce(function(bi, Ai) {
              var Di = vj({
                plugin: Ai,
                eventEmitter: Fr,
                usageStatistics: Gr,
                instance: ri
              });
              if (!Di)
                throw new Error("The return value of the executed plugin is empty.");
              var ta = Di.markdownParsers, aa = Di.toHTMLRenderers, wa = Di.toMarkdownRenderers, xa = Di.markdownPlugins, ba = Di.wysiwygPlugins, Na = Di.wysiwygNodeViews, Ra = Di.markdownCommands, io = Di.wysiwygCommands, bo = Di.toolbarItems;
              return aa && (bi.toHTMLRenderers = Hu(bi.toHTMLRenderers, aa)), wa && (bi.toMarkdownRenderers = Hu(bi.toMarkdownRenderers, wa)), xa && (bi.mdPlugins = bi.mdPlugins.concat(xa)), ba && (bi.wwPlugins = bi.wwPlugins.concat(ba)), Na && (bi.wwNodeViews = yr(yr({}, bi.wwNodeViews), Na)), Ra && (bi.mdCommands = yr(yr({}, bi.mdCommands), Ra)), io && (bi.wwCommands = yr(yr({}, bi.wwCommands), io)), bo && (bi.toolbarItems = bi.toolbarItems.concat(bo)), ta && (bi.markdownParsers = yr(yr({}, bi.markdownParsers), ta)), bi;
            }, {
              toHTMLRenderers: {},
              toMarkdownRenderers: {},
              mdPlugins: [],
              wwPlugins: [],
              wwNodeViews: {},
              mdCommands: {},
              wwCommands: {},
              toolbarItems: [],
              markdownParsers: {}
            });
          }
          var bj = mr(404), yj = /* @__PURE__ */ mr.n(bj), bd = [
            "afterPreviewRender",
            "updatePreview",
            "changeMode",
            "needChangeMode",
            "command",
            "changePreviewStyle",
            "changePreviewTabPreview",
            "changePreviewTabWrite",
            "scroll",
            "contextmenu",
            "show",
            "hide",
            "changeLanguage",
            "changeToolbarState",
            "toggleScrollSync",
            "mixinTableOffsetMapPrototype",
            "setFocusedNode",
            "removePopupWidget",
            "query",
            // provide event for user
            "openPopup",
            "closePopup",
            "addImageBlobHook",
            "beforePreviewRender",
            "beforeConvertWysiwygToMarkdown",
            "load",
            "loadUI",
            "change",
            "caretChange",
            "destroy",
            "focus",
            "blur",
            "keydown",
            "keyup"
          ], kj = (
            /** @class */
            function() {
              function Rr() {
                var Mr = this;
                this.events = new gd(), this.eventTypes = bd.reduce(function(Fr, Gr) {
                  return yr(yr({}, Fr), { type: Gr });
                }, {}), this.hold = !1, bd.forEach(function(Fr) {
                  Mr.addEventType(Fr);
                });
              }
              return Rr.prototype.listen = function(Mr, Fr) {
                var Gr = this.getTypeInfo(Mr), ri = this.events.get(Gr.type) || [];
                if (!this.hasEventType(Gr.type))
                  throw new Error("There is no event type " + Gr.type);
                Gr.namespace && (Fr.namespace = Gr.namespace), ri.push(Fr), this.events.set(Gr.type, ri);
              }, Rr.prototype.emit = function(Mr) {
                for (var Fr = [], Gr = 1; Gr < arguments.length; Gr++)
                  Fr[Gr - 1] = arguments[Gr];
                var ri = this.getTypeInfo(Mr), bi = this.events.get(ri.type), Ai = [];
                return !this.hold && bi && bi.forEach(function(Di) {
                  var ta = Di.apply(void 0, Fr);
                  _c()(ta) || Ai.push(ta);
                }), Ai;
              }, Rr.prototype.emitReduce = function(Mr, Fr) {
                for (var Gr = [], ri = 2; ri < arguments.length; ri++)
                  Gr[ri - 2] = arguments[ri];
                var bi = this.events.get(Mr);
                return !this.hold && bi && bi.forEach(function(Ai) {
                  var Di = Ai.apply(void 0, kr([Fr], Gr));
                  yj()(Di) || (Fr = Di);
                }), Fr;
              }, Rr.prototype.getTypeInfo = function(Mr) {
                var Fr = Mr.split(".");
                return {
                  type: Fr[0],
                  namespace: Fr[1]
                };
              }, Rr.prototype.hasEventType = function(Mr) {
                return !_c()(this.eventTypes[this.getTypeInfo(Mr).type]);
              }, Rr.prototype.addEventType = function(Mr) {
                if (this.hasEventType(Mr))
                  throw new Error("There is already have event type " + Mr);
                this.eventTypes[Mr] = Mr;
              }, Rr.prototype.removeEventHandler = function(Mr, Fr) {
                var Gr = this, ri = this.getTypeInfo(Mr), bi = ri.type, Ai = ri.namespace;
                bi && Fr ? this.removeEventHandlerWithHandler(bi, Fr) : bi && !Ai ? this.events.delete(bi) : !bi && Ai ? this.events.forEach(function(Di, ta) {
                  Gr.removeEventHandlerWithTypeInfo(ta, Ai);
                }) : bi && Ai && this.removeEventHandlerWithTypeInfo(bi, Ai);
              }, Rr.prototype.removeEventHandlerWithHandler = function(Mr, Fr) {
                var Gr = this.events.get(Mr);
                if (Gr) {
                  var ri = Gr.indexOf(Fr);
                  Gr.indexOf(Fr) >= 0 && Gr.splice(ri, 1);
                }
              }, Rr.prototype.removeEventHandlerWithTypeInfo = function(Mr, Fr) {
                var Gr = [], ri = this.events.get(Mr);
                ri && (ri.map(function(bi) {
                  return bi.namespace !== Fr && Gr.push(bi), null;
                }), this.events.set(Mr, Gr));
              }, Rr.prototype.getEvents = function() {
                return this.events;
              }, Rr.prototype.holdEventInvoke = function(Mr) {
                this.hold = !0, Mr(), this.hold = !1;
              }, Rr;
            }()
          ), _j = kj, wj = "data-task", Ej = "data-task-disabled", xj = "checked";
          function Cj(Rr) {
            ["htmlBlock", "htmlInline"].forEach(function(Mr) {
              Rr[Mr] && Object.keys(Rr[Mr]).forEach(function(Fr) {
                return GF(Fr);
              });
            });
          }
          var Tj = (
            /** @class */
            function() {
              function Rr(Mr) {
                var Fr = this;
                this.options = Xf()({
                  linkAttributes: null,
                  extendedAutolinks: !1,
                  customHTMLRenderer: null,
                  referenceDefinition: !1,
                  customHTMLSanitizer: null,
                  frontMatter: !1,
                  usageStatistics: !0,
                  theme: "light"
                }, Mr), this.eventEmitter = new _j();
                var Gr = LF(this.options.linkAttributes), ri = mj({
                  plugins: this.options.plugins,
                  eventEmitter: this.eventEmitter,
                  usageStatistics: this.options.usageStatistics,
                  instance: this
                }) || {}, bi = ri.toHTMLRenderers, Ai = ri.markdownParsers, Di = this.options, ta = Di.customHTMLRenderer, aa = Di.extendedAutolinks, wa = Di.referenceDefinition, xa = Di.frontMatter, ba = Di.customHTMLSanitizer, Na = {
                  linkAttributes: Gr,
                  customHTMLRenderer: yr(yr({}, bi), ta),
                  extendedAutolinks: aa,
                  referenceDefinition: wa,
                  frontMatter: xa,
                  sanitizer: ba || WF
                };
                Cj(Na.customHTMLRenderer), this.options.events && iF()(this.options.events, function(Wo, Vo) {
                  Fr.on(Vo, Wo);
                });
                var Ra = this.options, io = Ra.el, bo = Ra.initialValue, So = Ra.theme, xs = io.innerHTML;
                So !== "light" && io.classList.add(wc(So)), io.innerHTML = "", this.toastMark = new Yq("", {
                  disallowedHtmlBlockTags: ["br", "img"],
                  extendedAutolinks: aa,
                  referenceDefinition: wa,
                  disallowDeepHeading: !0,
                  frontMatter: xa,
                  customParser: Ai
                }), this.preview = new oj(this.eventEmitter, yr(yr({}, Na), { isViewer: !0 })), Jf()(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), bo ? this.setMarkdown(bo) : xs && this.preview.setHTML(xs), io.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
              }
              return Rr.prototype.toggleTask = function(Mr) {
                var Fr = Mr.target, Gr = getComputedStyle(Fr, ":before");
                !Fr.hasAttribute(Ej) && Fr.hasAttribute(wj) && RF(Gr, Mr.offsetX, Mr.offsetY) && (sd(Fr, xj), this.eventEmitter.emit("change", {
                  source: "viewer",
                  date: Mr
                }));
              }, Rr.prototype.setMarkdown = function(Mr) {
                var Fr = this.toastMark.getLineTexts(), Gr = Fr.length, ri = MF(Fr), bi = [Gr, ri.length + 1], Ai = this.toastMark.editMarkdown([1, 1], bi, Mr || "");
                this.eventEmitter.emit("updatePreview", Ai);
              }, Rr.prototype.on = function(Mr, Fr) {
                this.eventEmitter.listen(Mr, Fr);
              }, Rr.prototype.off = function(Mr) {
                this.eventEmitter.removeEventHandler(Mr);
              }, Rr.prototype.addHook = function(Mr, Fr) {
                this.eventEmitter.removeEventHandler(Mr), this.eventEmitter.listen(Mr, Fr);
              }, Rr.prototype.destroy = function() {
                Yf()(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
              }, Rr.prototype.isViewer = function() {
                return !0;
              }, Rr.prototype.isMarkdownMode = function() {
                return !1;
              }, Rr.prototype.isWysiwygMode = function() {
                return !1;
              }, Rr;
            }()
          ), Aj = Tj, Sj = Aj;
        }(), br = br.default, br;
      }()
    );
  });
})(toastuiEditorViewer);
var toastuiEditorViewerExports = toastuiEditorViewer.exports;
const Viewer = /* @__PURE__ */ getDefaultExportFromCjs(toastuiEditorViewerExports), css = `/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */.ProseMirror{font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;color:#222;font-size:13px;overflow-y:auto;overflow-X:hidden;height:calc(100% - 36px)}.ProseMirror .placeholder{color:#999}.ProseMirror:focus{outline:none}.ProseMirror-selectednode{outline:none}table.ProseMirror-selectednode,.html-block.ProseMirror-selectednode{border-radius:2px;outline:2px solid #00a9ff}.toastui-editor-contents{margin:0;padding:0;font-size:13px;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;z-index:20}.toastui-editor-contents *:not(table){line-height:160%;-webkit-box-sizing:content-box;box-sizing:content-box}.toastui-editor-contents i,.toastui-editor-contents cite,.toastui-editor-contents em,.toastui-editor-contents var,.toastui-editor-contents address,.toastui-editor-contents dfn{font-style:italic}.toastui-editor-contents strong{font-weight:700}.toastui-editor-contents p{margin:10px 0;color:#222}.toastui-editor-contents>h1:first-of-type,.toastui-editor-contents>div>div:first-of-type h1{margin-top:14px}.toastui-editor-contents h1,.toastui-editor-contents h2,.toastui-editor-contents h3,.toastui-editor-contents h4,.toastui-editor-contents h5,.toastui-editor-contents h6{font-weight:700;color:#222}.toastui-editor-contents h1{font-size:24px;line-height:28px;border-bottom:3px double #999;margin:52px 0 15px;padding-bottom:7px}.toastui-editor-contents h2{font-size:22px;line-height:23px;border-bottom:1px solid #dbdbdb;margin:20px 0 13px;padding-bottom:7px}.toastui-editor-contents h3{font-size:20px;margin:18px 0 2px}.toastui-editor-contents h4{font-size:18px;margin:10px 0 2px}.toastui-editor-contents h3,.toastui-editor-contents h4{line-height:18px}.toastui-editor-contents h5{font-size:16px}.toastui-editor-contents h6{font-size:14px}.toastui-editor-contents h5,.toastui-editor-contents h6{line-height:17px;margin:9px 0 -4px}.toastui-editor-contents del{color:#999}.toastui-editor-contents blockquote{margin:14px 0;border-left:4px solid #e5e5e5;padding:0 16px;color:#999}.toastui-editor-contents blockquote p,.toastui-editor-contents blockquote ul,.toastui-editor-contents blockquote ol{color:#999}.toastui-editor-contents blockquote>:first-child{margin-top:0}.toastui-editor-contents blockquote>:last-child{margin-bottom:0}.toastui-editor-contents pre,.toastui-editor-contents code{font-family:Consolas,Courier,Apple SD 산돌고딕 Neo,-apple-system,Lucida Grande,Apple SD Gothic Neo,맑은 고딕,Malgun Gothic,Segoe UI,돋움,dotum,sans-serif;border:0;border-radius:0}.toastui-editor-contents pre{margin:2px 0 8px;padding:18px;background-color:#f4f7f8}.toastui-editor-contents code{color:#c1798b;background-color:#f9f2f4;padding:2px 3px;letter-spacing:-.3px;border-radius:2px}.toastui-editor-contents pre code{padding:0;color:inherit;white-space:pre-wrap;background-color:transparent}.toastui-editor-contents img{margin:4px 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box;vertical-align:top;max-width:100%}.toastui-editor-contents table{border:1px solid rgba(0,0,0,.1);margin:12px 0 14px;color:#222;width:auto;border-collapse:collapse;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-contents table th,.toastui-editor-contents table td{border:1px solid rgba(0,0,0,.1);padding:5px 14px 5px 12px;height:32px}.toastui-editor-contents table th{background-color:#555;font-weight:300;color:#fff;padding-top:6px}.toastui-editor-contents th p{margin:0;color:#fff}.toastui-editor-contents td p{margin:0;padding:0 2px}.toastui-editor-contents td.toastui-editor-cell-selected{background-color:#d8dfec}.toastui-editor-contents th.toastui-editor-cell-selected{background-color:#908f8f}.toastui-editor-contents ul,.toastui-editor-contents menu,.toastui-editor-contents ol,.toastui-editor-contents dir{display:block;list-style-type:none;padding-left:24px;margin:6px 0 10px;color:#222}.toastui-editor-contents ol{list-style-type:none;counter-reset:li}.toastui-editor-contents ol>li{counter-increment:li}.toastui-editor-contents ul>li:before,.toastui-editor-contents ol>li:before{display:inline-block;position:absolute}.toastui-editor-contents ul>li:before{content:"";margin-top:6px;margin-left:-17px;width:5px;height:5px;border-radius:50%;background-color:#ccc}.toastui-editor-contents ol>li:before{content:"." counter(li);margin-left:-28px;width:24px;text-align:right;direction:rtl;color:#aaa}.toastui-editor-contents ul ul,.toastui-editor-contents ul ol,.toastui-editor-contents ol ol,.toastui-editor-contents ol ul{margin-top:0!important;margin-bottom:0!important}.toastui-editor-contents ul li,.toastui-editor-contents ol li{position:relative}.toastui-editor-contents ul p,.toastui-editor-contents ol p{margin:0}.toastui-editor-contents hr{border-top:1px solid #eee;margin:16px 0}.toastui-editor-contents a{text-decoration:underline;color:#4b96e6}.toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-contents .image-link{position:relative}.toastui-editor-contents .image-link:hover:before{content:"";position:absolute;width:30px;height:30px;right:0;border-radius:50%;border:1px solid #c9ccd5;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiM1NTUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAwIC00NTgxKSB0cmFuc2xhdGUoOTk1IDQ1NzYpIHRyYW5zbGF0ZSg1IDUpIHNjYWxlKDEgLTEpIHJvdGF0ZSg0NSAzNy4yOTMgMCkiLz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzI2IDQuOTM0bDEuODIyLjAwMmMxLjQ4NyAwIDIuNjkzIDEuMjI4IDIuNjkzIDIuNzQ0di4xOTJjMCAxLjUxNS0xLjIwNiAyLjc0NC0yLjY5MyAyLjc0NGgtMy44NDVjLTEuNDg3IDAtMi42OTItMS4yMjktMi42OTItMi43NDRWNy42OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMDAgLTQ1ODEpIHRyYW5zbGF0ZSg5OTUgNDU3NikgdHJhbnNsYXRlKDUgNSkgc2NhbGUoMSAtMSkgcm90YXRlKDQ1IDMwLjk5NiAwKSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K) no-repeat;background-position:center;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;cursor:pointer}.toastui-editor-contents .task-list-item{border:0;list-style:none;padding-left:24px;margin-left:-24px}.toastui-editor-contents .task-list-item:before{background-repeat:no-repeat;background-size:18px 18px;background-position:center;content:"";margin-left:0;margin-top:0;border-radius:2px;height:18px;width:18px;position:absolute;left:0;top:1px;cursor:pointer;background:transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQ0NDIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMjk2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMDQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==)}.toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-custom-block .toastui-editor-custom-block-editor{background:#f9f7fd;color:#452d6b;border:solid 1px #dbd4ea}.toastui-editor-custom-block .toastui-editor-custom-block-view{position:relative;padding:9px 13px 8px 12px}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{border:solid 1px #dbd4ea;border-radius:2px}.toastui-editor-custom-block .toastui-editor-custom-block-view .tool{position:absolute;right:10px;top:7px;display:none}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view .tool{display:block}.toastui-editor-custom-block-view button{vertical-align:middle;width:15px;height:15px;margin-left:8px;padding:3px;border:solid 1px #cccccc;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:center;background-size:30px 30px}.toastui-editor-custom-block-view .info{font-size:13px;font-weight:700;color:#5200d0;vertical-align:middle}.toastui-editor-contents .toastui-editor-ww-code-block{position:relative}.toastui-editor-contents .toastui-editor-ww-code-block:after{content:attr(data-language);position:absolute;display:inline-block;top:10px;right:10px;height:24px;padding:3px 35px 0 10px;font-weight:700;font-size:13px;color:#333;background:#e5e9ea url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:right;border-radius:2px;background-size:30px 30px;cursor:pointer}.toastui-editor-ww-code-block-language{position:fixed;display:inline-block;width:100px;height:27px;right:35px;border:1px solid #ccc;border-radius:2px;background-color:#fff;z-index:30}.toastui-editor-ww-code-block-language input{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:0 10px;height:100%;width:100%;background-color:transparent;border:none;outline:none}.toastui-editor-contents-placeholder:before{content:attr(data-placeholder);color:gray;line-height:160%;position:absolute}.toastui-editor-md-preview .toastui-editor-contents h1{min-height:28px}.toastui-editor-md-preview .toastui-editor-contents h2{min-height:23px}.toastui-editor-md-preview .toastui-editor-contents blockquote{min-height:20px}.toastui-editor-md-preview .toastui-editor-contents li{min-height:22px}.toastui-editor-pseudo-clipboard{position:fixed;opacity:0;width:0;height:0;left:-1000px;top:-1000px;z-index:-1}
`;
function add_css$3(lr) {
  append_styles(lr, "svelte-769iua", ".hidden.svelte-769iua{display:none}");
}
function create_fragment$3(lr) {
  let ar, cr, ur, fr, dr, hr, gr;
  return {
    c() {
      ar = element("style"), cr = space(), ur = element("style"), fr = space(), dr = element("div"), hr = space(), gr = element("div"), attr(dr, "class", "svelte-769iua"), toggle_class(
        dr,
        "hidden",
        /*$theme*/
        lr[0] === "dark"
      ), attr(gr, "class", "svelte-769iua"), toggle_class(
        gr,
        "hidden",
        /*$theme*/
        lr[0] === "light"
      );
    },
    m(vr, mr) {
      insert(vr, ar, mr), ar.innerHTML = css, insert(vr, cr, mr), insert(vr, ur, mr), ur.innerHTML = dark, insert(vr, fr, mr), insert(vr, dr, mr), lr[6](dr), insert(vr, hr, mr), insert(vr, gr, mr), lr[7](gr);
    },
    p(vr, [mr]) {
      mr & /*$theme*/
      1 && toggle_class(
        dr,
        "hidden",
        /*$theme*/
        vr[0] === "dark"
      ), mr & /*$theme*/
      1 && toggle_class(
        gr,
        "hidden",
        /*$theme*/
        vr[0] === "light"
      );
    },
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && (detach(ar), detach(cr), detach(ur), detach(fr), detach(dr), detach(hr), detach(gr)), lr[6](null), lr[7](null);
    }
  };
}
function instance$3(lr, ar, cr) {
  let ur;
  component_subscribe(lr, theme, (kr) => cr(0, ur = kr));
  let fr, dr, hr, gr, { content: vr } = ar;
  function mr() {
    cr(4, hr = new Viewer({
      el: fr,
      theme: "light",
      initialValue: vr
    })), cr(5, gr = new Viewer({
      el: dr,
      theme: "dark",
      initialValue: vr
    }));
  }
  onMount(() => {
    mr();
  });
  function br(kr) {
    binding_callbacks[kr ? "unshift" : "push"](() => {
      fr = kr, cr(1, fr);
    });
  }
  function yr(kr) {
    binding_callbacks[kr ? "unshift" : "push"](() => {
      dr = kr, cr(2, dr);
    });
  }
  return lr.$$set = (kr) => {
    "content" in kr && cr(3, vr = kr.content);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*$theme, viewer, viewerDark, content*/
    57 && ur && hr && gr && vr && (hr.destroy(), gr.destroy(), mr());
  }, [
    ur,
    fr,
    dr,
    vr,
    hr,
    gr,
    br,
    yr
  ];
}
class ContentView extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$3, create_fragment$3, safe_not_equal, { content: 3 }, add_css$3);
  }
  get content() {
    return this.$$.ctx[3];
  }
  set content(ar) {
    this.$$set({ content: ar }), flush();
  }
}
create_custom_element(ContentView, { content: {} }, [], [], !0);
function add_css$2(lr) {
  append_styles(lr, "svelte-cgkjwk", ".opinion-container.svelte-cgkjwk{border:1px solid #e0e0e0;border-radius:8px;padding:16px;margin-bottom:16px;background-color:var(--neutral-6, white);color:var(--neutral-0, black);font-family:'Barlow', sans-serif}.opinion-top.svelte-cgkjwk{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.pubkey.svelte-cgkjwk{display:flex;align-items:center;gap:10px;font-size:16px;font-weight:500}.profile-header.svelte-cgkjwk{display:flex;align-items:center;gap:0.5rem;color:var(--neutral-0, black);font-size:18px}.profile-image.svelte-cgkjwk{border-radius:50%;width:40px;height:40px;object-fit:cover}.date.svelte-cgkjwk{color:var(--neutral-0, black);font-size:14px}.content.svelte-cgkjwk{padding:1rem;color:var(--neutral-0, black);margin-bottom:16px;overflow-y:auto;max-height:300px}.content.show-full.svelte-cgkjwk{max-height:max-content;overflow:visible}.read-more.svelte-cgkjwk{color:#3e8b0a;cursor:pointer;display:block}.loader.svelte-cgkjwk{display:flex;justify-content:center;align-items:center;margin:2rem 0}.reply-section.svelte-cgkjwk{padding:1rem}.reply-file-preview.svelte-cgkjwk{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}.reply-footer.svelte-cgkjwk{display:flex;align-content:center}.reply-button.svelte-cgkjwk{padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem;background-color:#3e8b0a;color:white}.card-button.svelte-cgkjwk{display:inline-flex;align-items:center;gap:2px}.option-button.svelte-cgkjwk{background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}#allReply.svelte-cgkjwk{background:none;border:none;cursor:pointer;display:flex;align-items:center;font-size:medium;padding:8px;color:var(--neutral-0, black)}#replyButton.svelte-cgkjwk{background:none;background-color:transparent;border:none;cursor:pointer}.reactionButton.svelte-cgkjwk{background:none;background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}.reactionDiv.svelte-cgkjwk{display:flex;gap:2rem}.dark.svelte-cgkjwk{background-color:#434343;color:white}.selected.svelte-cgkjwk{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center;background-color:#3e8b0a;color:white}.deselected.svelte-cgkjwk{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center}.postButton.svelte-cgkjwk{color:#ffffff;background-color:#3e8b0a;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}.opinion-container.mine.svelte-cgkjwk{background-color:var(--neutral-6,#faefd9)}#filePreview.svelte-cgkjwk{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}");
}
function get_each_context$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[3] = ar[cr], ur;
}
function get_each_context_1$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[73] = ar[cr], ur;
}
function get_each_context_2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[73] = ar[cr], ur;
}
function create_if_block$1(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_1$1, create_else_block_5], hr = [];
  function gr(vr, mr) {
    return !/*loading*/
    vr[19] && /*expertOpinions*/
    vr[13] ? 0 : 1;
  }
  return ar = gr(lr), cr = hr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = empty$1();
    },
    m(vr, mr) {
      hr[ar].m(vr, mr), insert(vr, ur, mr), fr = !0;
    },
    p(vr, mr) {
      let br = ar;
      ar = gr(vr), ar === br ? hr[ar].p(vr, mr) : (group_outros(), transition_out(hr[br], 1, 1, () => {
        hr[br] = null;
      }), check_outros(), cr = hr[ar], cr ? cr.p(vr, mr) : (cr = hr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), hr[ar].d(vr);
    }
  };
}
function create_else_block_5(lr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "Loading...", attr(ar, "class", "loader svelte-cgkjwk");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_1$1(lr) {
  var Zi, ka;
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr = (
    /*trustedAuthors*/
    lr[10].includes(
      /*event*/
      lr[3].pubkey
    )
  ), kr, Tr, _r, Er, xr, Cr, Ar, Lr, Dr, Nr, Hr, $r, Wr, Zr, oi, Jr, Yr, li = (
    /*likeCount*/
    (lr[14] || 0) + ""
  ), Si, ci, hi, Ei, di, gi, Li, ui, wi = (
    /*dislikeCount*/
    (lr[15] || 0) + ""
  ), Ui, yi, Vi, Oi, Mi, Ii, mi, _i, Ci, Ki, Ni, ia, ea, la, ma;
  const Ba = [create_if_block_14, create_if_block_15, create_if_block_16], Fa = [];
  function Ia(zi, Ji) {
    var za, Va;
    return Ji[0] & /*event, editLvl*/
    12 && (dr = null), Ji[0] & /*event, editLvl*/
    12 && (hr = null), dr == null && (dr = /*event*/
    ((za = zi[3].tags.find(func)) == null ? void 0 : za[1]) === "-1" && /*editLvl*/
    zi[2] === 1), dr ? 0 : (hr == null && (hr = /*event*/
    ((Va = zi[3].tags.find(func_1)) == null ? void 0 : Va[1]) === "0" && /*editLvl*/
    zi[2] === 1), hr ? 1 : (
      /*editLvl*/
      zi[2] === 1 ? 2 : -1
    ));
  }
  ~(gr = Ia(lr, [-1, -1, -1])) && (vr = Fa[gr] = Ba[gr](lr));
  function Hi(zi, Ji) {
    return (
      /*profiles*/
      zi[4][
        /*event*/
        zi[3].pubkey
      ] ? create_if_block_13 : create_else_block_4
    );
  }
  let oa = Hi(lr), Gi = oa(lr), ha = yr && create_if_block_12(), Ua = (
    /*published_at*/
    lr[24] && /*published_at*/
    lr[24] < /*created_at*/
    lr[25] && create_if_block_11()
  );
  const eo = [create_if_block_8, create_else_block_3], ua = [];
  function va(zi, Ji) {
    return (
      /*edit*/
      zi[16] ? 1 : 0
    );
  }
  Lr = va(lr), Dr = ua[Lr] = eo[Lr](lr);
  const Ta = [create_if_block_7$1, create_else_block_1$1], Aa = [];
  function Oa(zi, Ji) {
    return (
      /*liked*/
      zi[20] === !0 ? 0 : 1
    );
  }
  Zr = Oa(lr), oi = Aa[Zr] = Ta[Zr](lr);
  const Xa = [create_if_block_6$1, create_else_block$1], Ka = [];
  function Pa(zi, Ji) {
    return (
      /*disliked*/
      zi[21] === !0 ? 0 : 1
    );
  }
  di = Pa(lr), gi = Ka[di] = Xa[di](lr), Oi = new Tooltip({
    props: {
      $$slots: {
        tooltip1Text: [create_tooltip1Text_slot_1],
        default: [create_default_slot_1]
      },
      $$scope: { ctx: lr }
    }
  }), Ii = new Tooltip({
    props: {
      $$slots: {
        tooltip1Text: [create_tooltip1Text_slot],
        default: [create_default_slot]
      },
      $$scope: { ctx: lr }
    }
  });
  let Da = (
    /*$ndkUser*/
    ((Zi = lr[29]) == null ? void 0 : Zi.pubkey) === /*event*/
    lr[3].pubkey && create_if_block_5$1(lr)
  ), Ha = (
    /*$ndkUser*/
    ((ka = lr[29]) == null ? void 0 : ka.pubkey) === /*event*/
    lr[3].pubkey && /*editLvl*/
    lr[2] == 1 && create_if_block_4$1(lr)
  ), $a = (
    /*reply*/
    lr[17] && create_if_block_3$1(lr)
  ), Yi = (
    /*replyContent*/
    lr[18] && create_if_block_2$1(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("div"), fr = element("div"), vr && vr.c(), mr = space(), Gi.c(), br = space(), ha && ha.c(), kr = space(), Tr = element("p"), Ua && Ua.c(), _r = space(), Er = element("a"), xr = text$3(
        /*relativeTime*/
        lr[23]
      ), Ar = space(), Dr.c(), Nr = space(), Hr = element("div"), $r = element("div"), Wr = element("button"), oi.c(), Jr = space(), Yr = element("span"), Si = text$3(li), ci = space(), hi = element("div"), Ei = element("button"), gi.c(), Li = space(), ui = element("span"), Ui = text$3(wi), yi = space(), Vi = element("div"), create_component(Oi.$$.fragment), Mi = space(), create_component(Ii.$$.fragment), mi = space(), Da && Da.c(), _i = space(), Ha && Ha.c(), Ci = space(), $a && $a.c(), Ki = space(), Yi && Yi.c(), attr(ur, "class", "pubkey svelte-cgkjwk"), attr(Er, "href", Cr = "https://njump.me/" + /*event*/
      lr[3].id), attr(Er, "target", "_blank"), attr(Tr, "class", "date svelte-cgkjwk"), attr(cr, "class", "opinion-top svelte-cgkjwk"), attr(Wr, "class", "reactionButton svelte-cgkjwk"), attr($r, "class", "card-button svelte-cgkjwk"), attr(Ei, "class", "reactionButton svelte-cgkjwk"), attr(hi, "class", "card-button svelte-cgkjwk"), attr(Vi, "class", "card-button svelte-cgkjwk"), attr(Hr, "class", "reactionDiv svelte-cgkjwk"), attr(ar, "class", Ni = "opinion-container " + /*isMine*/
      (lr[7] ? "mine" : "") + " svelte-cgkjwk");
    },
    m(zi, Ji) {
      insert(zi, ar, Ji), append(ar, cr), append(cr, ur), append(ur, fr), ~gr && Fa[gr].m(fr, null), append(ur, mr), Gi.m(ur, null), append(ur, br), ha && ha.m(ur, null), append(cr, kr), append(cr, Tr), Ua && Ua.m(Tr, null), append(Tr, _r), append(Tr, Er), append(Er, xr), append(ar, Ar), ua[Lr].m(ar, null), append(ar, Nr), append(ar, Hr), append(Hr, $r), append($r, Wr), Aa[Zr].m(Wr, null), append($r, Jr), append($r, Yr), append(Yr, Si), append(Hr, ci), append(Hr, hi), append(hi, Ei), Ka[di].m(Ei, null), append(hi, Li), append(hi, ui), append(ui, Ui), append(Hr, yi), append(Hr, Vi), mount_component(Oi, Vi, null), append(Vi, Mi), mount_component(Ii, Vi, null), append(Hr, mi), Da && Da.m(Hr, null), append(Hr, _i), Ha && Ha.m(Hr, null), append(ar, Ci), $a && $a.m(ar, null), append(ar, Ki), Yi && Yi.m(ar, null), ea = !0, la || (ma = [
        listen(
          Wr,
          "click",
          /*click_handler_3*/
          lr[49]
        ),
        listen(
          Ei,
          "click",
          /*click_handler_4*/
          lr[50]
        )
      ], la = !0);
    },
    p(zi, Ji) {
      var po, to;
      let za = gr;
      gr = Ia(zi, Ji), gr !== za && (vr && (group_outros(), transition_out(Fa[za], 1, 1, () => {
        Fa[za] = null;
      }), check_outros()), ~gr ? (vr = Fa[gr], vr || (vr = Fa[gr] = Ba[gr](zi), vr.c()), transition_in(vr, 1), vr.m(fr, null)) : vr = null), oa === (oa = Hi(zi)) && Gi ? Gi.p(zi, Ji) : (Gi.d(1), Gi = oa(zi), Gi && (Gi.c(), Gi.m(ur, br))), Ji[0] & /*trustedAuthors, event*/
      1032 && (yr = /*trustedAuthors*/
      zi[10].includes(
        /*event*/
        zi[3].pubkey
      )), yr ? ha ? Ji[0] & /*trustedAuthors, event*/
      1032 && transition_in(ha, 1) : (ha = create_if_block_12(), ha.c(), transition_in(ha, 1), ha.m(ur, null)) : ha && (group_outros(), transition_out(ha, 1, 1, () => {
        ha = null;
      }), check_outros()), /*published_at*/
      zi[24] && /*published_at*/
      zi[24] < /*created_at*/
      zi[25] ? Ua || (Ua = create_if_block_11(), Ua.c(), Ua.m(Tr, _r)) : Ua && (Ua.d(1), Ua = null), (!ea || Ji[0] & /*relativeTime*/
      8388608) && set_data(
        xr,
        /*relativeTime*/
        zi[23]
      ), (!ea || Ji[0] & /*event*/
      8 && Cr !== (Cr = "https://njump.me/" + /*event*/
      zi[3].id)) && attr(Er, "href", Cr);
      let Va = Lr;
      Lr = va(zi), Lr === Va ? ua[Lr].p(zi, Ji) : (group_outros(), transition_out(ua[Va], 1, 1, () => {
        ua[Va] = null;
      }), check_outros(), Dr = ua[Lr], Dr ? Dr.p(zi, Ji) : (Dr = ua[Lr] = eo[Lr](zi), Dr.c()), transition_in(Dr, 1), Dr.m(ar, Nr));
      let Ca = Zr;
      Zr = Oa(zi), Zr !== Ca && (group_outros(), transition_out(Aa[Ca], 1, 1, () => {
        Aa[Ca] = null;
      }), check_outros(), oi = Aa[Zr], oi || (oi = Aa[Zr] = Ta[Zr](zi), oi.c()), transition_in(oi, 1), oi.m(Wr, null)), (!ea || Ji[0] & /*likeCount*/
      16384) && li !== (li = /*likeCount*/
      (zi[14] || 0) + "") && set_data(Si, li);
      let ja = di;
      di = Pa(zi), di !== ja && (group_outros(), transition_out(Ka[ja], 1, 1, () => {
        Ka[ja] = null;
      }), check_outros(), gi = Ka[di], gi || (gi = Ka[di] = Xa[di](zi), gi.c()), transition_in(gi, 1), gi.m(Ei, null)), (!ea || Ji[0] & /*dislikeCount*/
      32768) && wi !== (wi = /*dislikeCount*/
      (zi[15] || 0) + "") && set_data(Ui, wi);
      const ao = {};
      Ji[0] & /*$localStore, reply, edit, opinionContent, replyContent*/
      1074200608 | Ji[2] & /*$$scope*/
      65536 && (ao.$$scope = { dirty: Ji, ctx: zi }), Oi.$set(ao);
      const Wa = {};
      Ji[0] & /*replyContent, replyEvents*/
      266240 | Ji[2] & /*$$scope*/
      65536 && (Wa.$$scope = { dirty: Ji, ctx: zi }), Ii.$set(Wa), /*$ndkUser*/
      ((po = zi[29]) == null ? void 0 : po.pubkey) === /*event*/
      zi[3].pubkey ? Da ? (Da.p(zi, Ji), Ji[0] & /*$ndkUser, event*/
      536870920 && transition_in(Da, 1)) : (Da = create_if_block_5$1(zi), Da.c(), transition_in(Da, 1), Da.m(Hr, _i)) : Da && (group_outros(), transition_out(Da, 1, 1, () => {
        Da = null;
      }), check_outros()), /*$ndkUser*/
      ((to = zi[29]) == null ? void 0 : to.pubkey) === /*event*/
      zi[3].pubkey && /*editLvl*/
      zi[2] == 1 ? Ha ? (Ha.p(zi, Ji), Ji[0] & /*$ndkUser, event, editLvl*/
      536870924 && transition_in(Ha, 1)) : (Ha = create_if_block_4$1(zi), Ha.c(), transition_in(Ha, 1), Ha.m(Hr, null)) : Ha && (group_outros(), transition_out(Ha, 1, 1, () => {
        Ha = null;
      }), check_outros()), /*reply*/
      zi[17] ? $a ? ($a.p(zi, Ji), Ji[0] & /*reply*/
      131072 && transition_in($a, 1)) : ($a = create_if_block_3$1(zi), $a.c(), transition_in($a, 1), $a.m(ar, Ki)) : $a && (group_outros(), transition_out($a, 1, 1, () => {
        $a = null;
      }), check_outros()), /*replyContent*/
      zi[18] ? Yi ? (Yi.p(zi, Ji), Ji[0] & /*replyContent*/
      262144 && transition_in(Yi, 1)) : (Yi = create_if_block_2$1(zi), Yi.c(), transition_in(Yi, 1), Yi.m(ar, null)) : Yi && (group_outros(), transition_out(Yi, 1, 1, () => {
        Yi = null;
      }), check_outros()), (!ea || Ji[0] & /*isMine*/
      128 && Ni !== (Ni = "opinion-container " + /*isMine*/
      (zi[7] ? "mine" : "") + " svelte-cgkjwk")) && attr(ar, "class", Ni);
    },
    i(zi) {
      ea || (transition_in(vr), transition_in(ha), transition_in(Dr), transition_in(oi), transition_in(gi), transition_in(Oi.$$.fragment, zi), transition_in(Ii.$$.fragment, zi), transition_in(Da), transition_in(Ha), transition_in($a), transition_in(Yi), zi && add_render_callback(() => {
        ea && (ia || (ia = create_bidirectional_transition(ar, slide, {}, !0)), ia.run(1));
      }), ea = !0);
    },
    o(zi) {
      transition_out(vr), transition_out(ha), transition_out(Dr), transition_out(oi), transition_out(gi), transition_out(Oi.$$.fragment, zi), transition_out(Ii.$$.fragment, zi), transition_out(Da), transition_out(Ha), transition_out($a), transition_out(Yi), zi && (ia || (ia = create_bidirectional_transition(ar, slide, {}, !1)), ia.run(0)), ea = !1;
    },
    d(zi) {
      zi && detach(ar), ~gr && Fa[gr].d(), Gi.d(), ha && ha.d(), Ua && Ua.d(), ua[Lr].d(), Aa[Zr].d(), Ka[di].d(), destroy_component(Oi), destroy_component(Ii), Da && Da.d(), Ha && Ha.d(), $a && $a.d(), Yi && Yi.d(), zi && ia && ia.end(), la = !1, run_all(ma);
    }
  };
}
function create_if_block_16(lr) {
  let ar, cr;
  return ar = new Positive({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_15(lr) {
  let ar, cr;
  return ar = new Neutral({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_14(lr) {
  let ar, cr;
  return ar = new Negative({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block_4(lr) {
  let ar, cr, ur, fr, dr, hr = convertNostrPubKeyToBech32(
    /*event*/
    lr[3].pubkey
  ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
    /*event*/
    lr[3].pubkey
  ).slice(-4), gr;
  return {
    c() {
      ar = element("div"), cr = element("img"), fr = space(), dr = element("span"), gr = text$3(hr), attr(cr, "class", "profile-image svelte-cgkjwk"), src_url_equal(cr.src, ur = profileImageUrl + /*event*/
      lr[3].pubkey) || attr(cr, "src", ur), attr(cr, "alt", "Profile"), attr(ar, "class", "profile-header svelte-cgkjwk");
    },
    m(vr, mr) {
      insert(vr, ar, mr), append(ar, cr), append(ar, fr), append(ar, dr), append(dr, gr);
    },
    p(vr, mr) {
      mr[0] & /*event*/
      8 && !src_url_equal(cr.src, ur = profileImageUrl + /*event*/
      vr[3].pubkey) && attr(cr, "src", ur), mr[0] & /*event*/
      8 && hr !== (hr = convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(-4)) && set_data(gr, hr);
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_if_block_13(lr) {
  var vr;
  let ar, cr, ur, fr, dr, hr = (
    /*profiles*/
    (((vr = lr[4][
      /*event*/
      lr[3].pubkey
    ].content) == null ? void 0 : vr.name) || convertNostrPubKeyToBech32(
      /*event*/
      lr[3].pubkey
    ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
      /*event*/
      lr[3].pubkey
    ).slice(-5)) + ""
  ), gr;
  return {
    c() {
      var mr, br;
      ar = element("div"), cr = element("img"), fr = space(), dr = element("span"), gr = text$3(hr), attr(cr, "class", "profile-image svelte-cgkjwk"), src_url_equal(cr.src, ur = /*profiles*/
      (mr = lr[4][
        /*event*/
        lr[3].pubkey
      ].content) != null && mr.image ? (
        /*profiles*/
        (br = lr[4][
          /*event*/
          lr[3].pubkey
        ].content) == null ? void 0 : br.image
      ) : profileImageUrl + /*event*/
      lr[3].pubkey) || attr(cr, "src", ur), attr(cr, "alt", "Profile Picture"), attr(ar, "class", "profile-header svelte-cgkjwk");
    },
    m(mr, br) {
      insert(mr, ar, br), append(ar, cr), append(ar, fr), append(ar, dr), append(dr, gr);
    },
    p(mr, br) {
      var yr, kr, Tr;
      br[0] & /*profiles, event*/
      24 && !src_url_equal(cr.src, ur = /*profiles*/
      (yr = mr[4][
        /*event*/
        mr[3].pubkey
      ].content) != null && yr.image ? (
        /*profiles*/
        (kr = mr[4][
          /*event*/
          mr[3].pubkey
        ].content) == null ? void 0 : kr.image
      ) : profileImageUrl + /*event*/
      mr[3].pubkey) && attr(cr, "src", ur), br[0] & /*profiles, event*/
      24 && hr !== (hr = /*profiles*/
      (((Tr = mr[4][
        /*event*/
        mr[3].pubkey
      ].content) == null ? void 0 : Tr.name) || convertNostrPubKeyToBech32(
        /*event*/
        mr[3].pubkey
      ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        mr[3].pubkey
      ).slice(-5)) + "") && set_data(gr, hr);
    },
    d(mr) {
      mr && detach(ar);
    }
  };
}
function create_if_block_12(lr) {
  let ar, cr;
  return ar = new ApprovedBadge({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_11(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Edited.");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_else_block_3(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar, Lr, Dr, Nr, Hr, $r, Wr, Zr, oi, Jr = [], Yr = /* @__PURE__ */ new Map(), li, Si, ci, hi, Ei, di, gi, Li, ui, wi, Ui, yi, Vi, Oi;
  function Mi(ea) {
    lr[40](ea);
  }
  function Ii(ea) {
    lr[41](ea);
  }
  let mi = {};
  /*fileArray*/
  lr[26] !== void 0 && (mi.fileArray = /*fileArray*/
  lr[26]), /*opinionContent*/
  lr[5] !== void 0 && (mi.opinionContent = /*opinionContent*/
  lr[5]), ur = new Editor_1({ props: mi }), binding_callbacks.push(() => bind(ur, "fileArray", Mi)), binding_callbacks.push(() => bind(ur, "opinionContent", Ii)), kr = new Positive({}), Cr = new Neutral({}), Hr = new Negative({});
  let _i = ensure_array_like(
    /*fileArray*/
    lr[26]
  );
  const Ci = (ea) => (
    /*file*/
    ea[73].url
  );
  for (let ea = 0; ea < _i.length; ea += 1) {
    let la = get_each_context_2(lr, _i, ea), ma = Ci(la);
    Yr.set(ma, Jr[ea] = create_each_block_2(ma, la));
  }
  function Ki(ea) {
    lr[46](ea);
  }
  function Ni(ea) {
    lr[47](ea);
  }
  let ia = {};
  return (
    /*fileArray*/
    lr[26] !== void 0 && (ia.fileArray = /*fileArray*/
    lr[26]), /*opinionContent*/
    lr[5] !== void 0 && (ia.opinionContent = /*opinionContent*/
    lr[5]), gi = new Upload({ props: ia }), binding_callbacks.push(() => bind(gi, "fileArray", Ki)), binding_callbacks.push(() => bind(gi, "opinionContent", Ni)), {
      c() {
        ar = element("div"), cr = element("form"), create_component(ur.$$.fragment), hr = space(), gr = element("div"), vr = element("label"), vr.textContent = "Choose your overall sentiment", mr = space(), br = element("div"), yr = element("button"), create_component(kr.$$.fragment), Tr = space(), _r = element("span"), _r.textContent = "Positive", Er = space(), xr = element("button"), create_component(Cr.$$.fragment), Ar = space(), Lr = element("span"), Lr.textContent = "Neutral", Dr = space(), Nr = element("button"), create_component(Hr.$$.fragment), $r = space(), Wr = element("span"), Wr.textContent = "Negative", Zr = space(), oi = element("div");
        for (let ea = 0; ea < Jr.length; ea += 1)
          Jr[ea].c();
        li = space(), Si = element("div"), ci = element("button"), hi = text$3("Post"), di = space(), create_component(gi.$$.fragment), attr(vr, "for", "sentiment"), set_style(vr, "font-weight", "600"), attr(yr, "class", "deselected svelte-cgkjwk"), toggle_class(
          yr,
          "dark",
          /*$theme*/
          lr[31] === "dark"
        ), toggle_class(
          yr,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "1"
        ), attr(xr, "class", "deselected svelte-cgkjwk"), toggle_class(
          xr,
          "dark",
          /*$theme*/
          lr[31] === "dark"
        ), toggle_class(
          xr,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "0"
        ), attr(Nr, "class", "deselected svelte-cgkjwk"), toggle_class(
          Nr,
          "dark",
          /*$theme*/
          lr[31] === "dark"
        ), toggle_class(
          Nr,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "-1"
        ), set_style(br, "display", "flex"), set_style(br, "gap", "0.4rem"), attr(gr, "id", "sentiment-box"), set_style(gr, "display", "flex"), set_style(gr, "flex-direction", "column"), set_style(gr, "gap", "0.3rem"), set_style(gr, "margin-bottom", "1rem"), attr(oi, "id", "filePreview"), attr(oi, "class", "svelte-cgkjwk"), attr(ci, "type", "submit"), ci.disabled = Ei = !/*$ndkUser*/
        lr[29], attr(ci, "class", "postButton svelte-cgkjwk"), set_style(Si, "display", "flex"), set_style(Si, "align-contents", "center"), attr(ar, "class", wi = "opinion-container " + /*isMine*/
        (lr[7] ? "mine" : "") + " svelte-cgkjwk");
      },
      m(ea, la) {
        insert(ea, ar, la), append(ar, cr), mount_component(ur, cr, null), append(cr, hr), append(cr, gr), append(gr, vr), append(gr, mr), append(gr, br), append(br, yr), mount_component(kr, yr, null), append(yr, Tr), append(yr, _r), append(br, Er), append(br, xr), mount_component(Cr, xr, null), append(xr, Ar), append(xr, Lr), append(br, Dr), append(br, Nr), mount_component(Hr, Nr, null), append(Nr, $r), append(Nr, Wr), append(cr, Zr), append(cr, oi);
        for (let ma = 0; ma < Jr.length; ma += 1)
          Jr[ma] && Jr[ma].m(oi, null);
        append(cr, li), append(cr, Si), append(Si, ci), append(ci, hi), append(Si, di), mount_component(gi, Si, null), yi = !0, Vi || (Oi = [
          listen(yr, "click", prevent_default(
            /*click_handler*/
            lr[42]
          )),
          listen(xr, "click", prevent_default(
            /*click_handler_1*/
            lr[43]
          )),
          listen(Nr, "click", prevent_default(
            /*click_handler_2*/
            lr[44]
          )),
          listen(cr, "submit", prevent_default(
            /*submit_handler*/
            lr[48]
          ))
        ], Vi = !0);
      },
      p(ea, la) {
        const ma = {};
        !fr && la[0] & /*fileArray*/
        67108864 && (fr = !0, ma.fileArray = /*fileArray*/
        ea[26], add_flush_callback(() => fr = !1)), !dr && la[0] & /*opinionContent*/
        32 && (dr = !0, ma.opinionContent = /*opinionContent*/
        ea[5], add_flush_callback(() => dr = !1)), ur.$set(ma), (!yi || la[1] & /*$theme*/
        1) && toggle_class(
          yr,
          "dark",
          /*$theme*/
          ea[31] === "dark"
        ), (!yi || la[0] & /*newOpinion*/
        1) && toggle_class(
          yr,
          "selected",
          /*newOpinion*/
          ea[0].sentiment === "1"
        ), (!yi || la[1] & /*$theme*/
        1) && toggle_class(
          xr,
          "dark",
          /*$theme*/
          ea[31] === "dark"
        ), (!yi || la[0] & /*newOpinion*/
        1) && toggle_class(
          xr,
          "selected",
          /*newOpinion*/
          ea[0].sentiment === "0"
        ), (!yi || la[1] & /*$theme*/
        1) && toggle_class(
          Nr,
          "dark",
          /*$theme*/
          ea[31] === "dark"
        ), (!yi || la[0] & /*newOpinion*/
        1) && toggle_class(
          Nr,
          "selected",
          /*newOpinion*/
          ea[0].sentiment === "-1"
        ), la[0] & /*fileArray*/
        67108864 | la[1] & /*deleteFile*/
        64 && (_i = ensure_array_like(
          /*fileArray*/
          ea[26]
        ), group_outros(), Jr = update_keyed_each(Jr, la, Ci, 1, ea, _i, Yr, oi, outro_and_destroy_block, create_each_block_2, null, get_each_context_2), check_outros()), (!yi || la[0] & /*$ndkUser*/
        536870912 && Ei !== (Ei = !/*$ndkUser*/
        ea[29])) && (ci.disabled = Ei);
        const Ba = {};
        !Li && la[0] & /*fileArray*/
        67108864 && (Li = !0, Ba.fileArray = /*fileArray*/
        ea[26], add_flush_callback(() => Li = !1)), !ui && la[0] & /*opinionContent*/
        32 && (ui = !0, Ba.opinionContent = /*opinionContent*/
        ea[5], add_flush_callback(() => ui = !1)), gi.$set(Ba), (!yi || la[0] & /*isMine*/
        128 && wi !== (wi = "opinion-container " + /*isMine*/
        (ea[7] ? "mine" : "") + " svelte-cgkjwk")) && attr(ar, "class", wi);
      },
      i(ea) {
        if (!yi) {
          transition_in(ur.$$.fragment, ea), transition_in(kr.$$.fragment, ea), transition_in(Cr.$$.fragment, ea), transition_in(Hr.$$.fragment, ea);
          for (let la = 0; la < _i.length; la += 1)
            transition_in(Jr[la]);
          transition_in(gi.$$.fragment, ea), ea && add_render_callback(() => {
            yi && (Ui || (Ui = create_bidirectional_transition(ar, slide, {}, !0)), Ui.run(1));
          }), yi = !0;
        }
      },
      o(ea) {
        transition_out(ur.$$.fragment, ea), transition_out(kr.$$.fragment, ea), transition_out(Cr.$$.fragment, ea), transition_out(Hr.$$.fragment, ea);
        for (let la = 0; la < Jr.length; la += 1)
          transition_out(Jr[la]);
        transition_out(gi.$$.fragment, ea), ea && (Ui || (Ui = create_bidirectional_transition(ar, slide, {}, !1)), Ui.run(0)), yi = !1;
      },
      d(ea) {
        ea && detach(ar), destroy_component(ur), destroy_component(kr), destroy_component(Cr), destroy_component(Hr);
        for (let la = 0; la < Jr.length; la += 1)
          Jr[la].d();
        destroy_component(gi), ea && Ui && Ui.end(), Vi = !1, run_all(Oi);
      }
    }
  );
}
function create_if_block_8(lr) {
  let ar, cr, ur, fr, dr, hr;
  const gr = [create_if_block_10, create_else_block_2], vr = [];
  function mr(yr, kr) {
    return (
      /*editLvl*/
      yr[2] == 1 ? 0 : 1
    );
  }
  cr = mr(lr), ur = vr[cr] = gr[cr](lr);
  let br = (
    /*showReadMore*/
    lr[28] && create_if_block_9(lr)
  );
  return {
    c() {
      ar = element("p"), ur.c(), fr = space(), br && br.c(), dr = empty$1(), attr(ar, "class", "content svelte-cgkjwk"), toggle_class(
        ar,
        "show-full",
        /*showFullText*/
        lr[22]
      );
    },
    m(yr, kr) {
      insert(yr, ar, kr), vr[cr].m(ar, null), lr[39](ar), insert(yr, fr, kr), br && br.m(yr, kr), insert(yr, dr, kr), hr = !0;
    },
    p(yr, kr) {
      let Tr = cr;
      cr = mr(yr), cr === Tr ? vr[cr].p(yr, kr) : (group_outros(), transition_out(vr[Tr], 1, 1, () => {
        vr[Tr] = null;
      }), check_outros(), ur = vr[cr], ur ? ur.p(yr, kr) : (ur = vr[cr] = gr[cr](yr), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!hr || kr[0] & /*showFullText*/
      4194304) && toggle_class(
        ar,
        "show-full",
        /*showFullText*/
        yr[22]
      ), /*showReadMore*/
      yr[28] ? br ? br.p(yr, kr) : (br = create_if_block_9(yr), br.c(), br.m(dr.parentNode, dr)) : br && (br.d(1), br = null);
    },
    i(yr) {
      hr || (transition_in(ur), hr = !0);
    },
    o(yr) {
      transition_out(ur), hr = !1;
    },
    d(yr) {
      yr && (detach(ar), detach(fr), detach(dr)), vr[cr].d(), lr[39](null), br && br.d(yr);
    }
  };
}
function create_each_block_2(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func_2*/
      ar[45](
        /*file*/
        ar[73]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[73].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(hr, gr) {
      insert(hr, cr, gr), mount_component(ur, hr, gr), fr = !0;
    },
    p(hr, gr) {
      ar = hr;
      const vr = {};
      gr[0] & /*fileArray*/
      67108864 && (vr.file = /*file*/
      ar[73].files), gr[0] & /*fileArray*/
      67108864 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(hr) {
      fr || (transition_in(ur.$$.fragment, hr), fr = !0);
    },
    o(hr) {
      transition_out(ur.$$.fragment, hr), fr = !1;
    },
    d(hr) {
      hr && detach(cr), destroy_component(ur, hr);
    }
  };
}
function create_else_block_2(lr) {
  let ar, cr;
  return {
    c() {
      ar = new HtmlTag(!1), cr = empty$1(), ar.a = cr;
    },
    m(ur, fr) {
      ar.m(
        /*processedContent*/
        lr[32],
        ur,
        fr
      ), insert(ur, cr, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && (detach(cr), ar.d());
    }
  };
}
function create_if_block_10(lr) {
  let ar, cr;
  return ar = new ContentView({
    props: { content: (
      /*processedContent*/
      lr[32]
    ) }
  }), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    p: noop$1,
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_9(lr) {
  let ar, cr = (
    /*showFullText*/
    lr[22] ? "Read Less" : "Read More"
  ), ur, fr, dr;
  return {
    c() {
      ar = element("span"), ur = text$3(cr), attr(ar, "class", "read-more svelte-cgkjwk");
    },
    m(hr, gr) {
      insert(hr, ar, gr), append(ar, ur), fr || (dr = listen(
        ar,
        "click",
        /*toggleFullText*/
        lr[33]
      ), fr = !0);
    },
    p(hr, gr) {
      gr[0] & /*showFullText*/
      4194304 && cr !== (cr = /*showFullText*/
      hr[22] ? "Read Less" : "Read More") && set_data(ur, cr);
    },
    d(hr) {
      hr && detach(ar), fr = !1, dr();
    }
  };
}
function create_else_block_1$1(lr) {
  let ar, cr;
  return ar = new LikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_7$1(lr) {
  let ar, cr;
  return ar = new LikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block$1(lr) {
  let ar, cr;
  return ar = new DislikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_6$1(lr) {
  let ar, cr;
  return ar = new DislikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_default_slot_1(lr) {
  let ar, cr, ur, fr, dr;
  return cr = new ReplyButton({}), {
    c() {
      ar = element("button"), create_component(cr.$$.fragment), attr(ar, "id", "replyButton"), attr(ar, "class", "svelte-cgkjwk");
    },
    m(hr, gr) {
      insert(hr, ar, gr), mount_component(cr, ar, null), ur = !0, fr || (dr = listen(
        ar,
        "click",
        /*click_handler_5*/
        lr[51]
      ), fr = !0);
    },
    p: noop$1,
    i(hr) {
      ur || (transition_in(cr.$$.fragment, hr), ur = !0);
    },
    o(hr) {
      transition_out(cr.$$.fragment, hr), ur = !1;
    },
    d(hr) {
      hr && detach(ar), destroy_component(cr), fr = !1, dr();
    }
  };
}
function create_tooltip1Text_slot_1(lr) {
  let ar;
  return {
    c() {
      ar = element("span"), ar.textContent = "Add Reply", attr(ar, "slot", "tooltip1Text");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_default_slot(lr) {
  let ar, cr, ur = (
    /*replyEvents*/
    lr[12].length + ""
  ), fr, dr, hr;
  return {
    c() {
      ar = element("button"), cr = element("span"), fr = text$3(ur), set_style(cr, "pointer", "cursor"), attr(ar, "id", "allReply"), attr(ar, "class", "svelte-cgkjwk");
    },
    m(gr, vr) {
      insert(gr, ar, vr), append(ar, cr), append(cr, fr), dr || (hr = listen(
        ar,
        "click",
        /*click_handler_6*/
        lr[52]
      ), dr = !0);
    },
    p(gr, vr) {
      vr[0] & /*replyEvents*/
      4096 && ur !== (ur = /*replyEvents*/
      gr[12].length + "") && set_data(fr, ur);
    },
    d(gr) {
      gr && detach(ar), dr = !1, hr();
    }
  };
}
function create_tooltip1Text_slot(lr) {
  let ar;
  return {
    c() {
      ar = element("span"), ar.textContent = "Replies", attr(ar, "slot", "tooltip1Text");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_5$1(lr) {
  let ar, cr, ur, fr;
  function dr(vr) {
    lr[53](vr);
  }
  function hr(vr) {
    lr[54](vr);
  }
  let gr = { eventID: (
    /*event*/
    lr[3].id
  ) };
  return (
    /*isDeleted*/
    lr[11] !== void 0 && (gr.isDeleted = /*isDeleted*/
    lr[11]), /*count*/
    lr[6] !== void 0 && (gr.count = /*count*/
    lr[6]), ar = new DeleteEventData({ props: gr }), binding_callbacks.push(() => bind(ar, "isDeleted", dr)), binding_callbacks.push(() => bind(ar, "count", hr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, mr) {
        mount_component(ar, vr, mr), fr = !0;
      },
      p(vr, mr) {
        const br = {};
        mr[0] & /*event*/
        8 && (br.eventID = /*event*/
        vr[3].id), !cr && mr[0] & /*isDeleted*/
        2048 && (cr = !0, br.isDeleted = /*isDeleted*/
        vr[11], add_flush_callback(() => cr = !1)), !ur && mr[0] & /*count*/
        64 && (ur = !0, br.count = /*count*/
        vr[6], add_flush_callback(() => ur = !1)), ar.$set(br);
      },
      i(vr) {
        fr || (transition_in(ar.$$.fragment, vr), fr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), fr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_4$1(lr) {
  let ar, cr, ur, fr, dr, hr;
  return ur = new OptionButton({}), {
    c() {
      ar = element("div"), cr = element("button"), create_component(ur.$$.fragment), attr(cr, "class", "option-button svelte-cgkjwk"), attr(ar, "class", "card-button svelte-cgkjwk");
    },
    m(gr, vr) {
      insert(gr, ar, vr), append(ar, cr), mount_component(ur, cr, null), fr = !0, dr || (hr = listen(
        cr,
        "click",
        /*click_handler_7*/
        lr[55]
      ), dr = !0);
    },
    p: noop$1,
    i(gr) {
      fr || (transition_in(ur.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_component(ur), dr = !1, hr();
    }
  };
}
function create_if_block_3$1(lr) {
  let ar, cr, ur, fr, dr, hr = [], gr = /* @__PURE__ */ new Map(), vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr, Ar, Lr, Dr;
  function Nr(Yr) {
    lr[56](Yr);
  }
  let Hr = {};
  /*opinionContent*/
  lr[5] !== void 0 && (Hr.opinionContent = /*opinionContent*/
  lr[5]), cr = new TextArea({ props: Hr }), binding_callbacks.push(() => bind(cr, "opinionContent", Nr));
  let $r = ensure_array_like(
    /*fileArray*/
    lr[26]
  );
  const Wr = (Yr) => (
    /*file*/
    Yr[73].url
  );
  for (let Yr = 0; Yr < $r.length; Yr += 1) {
    let li = get_each_context_1$1(lr, $r, Yr), Si = Wr(li);
    gr.set(Si, hr[Yr] = create_each_block_1$1(Si, li));
  }
  function Zr(Yr) {
    lr[59](Yr);
  }
  function oi(Yr) {
    lr[60](Yr);
  }
  let Jr = {};
  return (
    /*fileArray*/
    lr[26] !== void 0 && (Jr.fileArray = /*fileArray*/
    lr[26]), /*opinionContent*/
    lr[5] !== void 0 && (Jr.opinionContent = /*opinionContent*/
    lr[5]), _r = new Upload({ props: Jr }), binding_callbacks.push(() => bind(_r, "fileArray", Zr)), binding_callbacks.push(() => bind(_r, "opinionContent", oi)), {
      c() {
        ar = element("div"), create_component(cr.$$.fragment), fr = space(), dr = element("div");
        for (let Yr = 0; Yr < hr.length; Yr += 1)
          hr[Yr].c();
        vr = space(), mr = element("div"), br = element("button"), yr = text$3("Reply"), Tr = space(), create_component(_r.$$.fragment), attr(dr, "class", "reply-file-preview svelte-cgkjwk"), attr(br, "class", "reply-button svelte-cgkjwk"), br.disabled = kr = !/*$ndkUser*/
        lr[29], attr(mr, "class", "reply-footer svelte-cgkjwk"), attr(ar, "class", "reply-section svelte-cgkjwk");
      },
      m(Yr, li) {
        insert(Yr, ar, li), mount_component(cr, ar, null), append(ar, fr), append(ar, dr);
        for (let Si = 0; Si < hr.length; Si += 1)
          hr[Si] && hr[Si].m(dr, null);
        append(ar, vr), append(ar, mr), append(mr, br), append(br, yr), append(mr, Tr), mount_component(_r, mr, null), Ar = !0, Lr || (Dr = listen(
          br,
          "click",
          /*click_handler_8*/
          lr[58]
        ), Lr = !0);
      },
      p(Yr, li) {
        const Si = {};
        !ur && li[0] & /*opinionContent*/
        32 && (ur = !0, Si.opinionContent = /*opinionContent*/
        Yr[5], add_flush_callback(() => ur = !1)), cr.$set(Si), li[0] & /*fileArray*/
        67108864 | li[1] & /*deleteFile*/
        64 && ($r = ensure_array_like(
          /*fileArray*/
          Yr[26]
        ), group_outros(), hr = update_keyed_each(hr, li, Wr, 1, Yr, $r, gr, dr, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1), check_outros()), (!Ar || li[0] & /*$ndkUser*/
        536870912 && kr !== (kr = !/*$ndkUser*/
        Yr[29])) && (br.disabled = kr);
        const ci = {};
        !Er && li[0] & /*fileArray*/
        67108864 && (Er = !0, ci.fileArray = /*fileArray*/
        Yr[26], add_flush_callback(() => Er = !1)), !xr && li[0] & /*opinionContent*/
        32 && (xr = !0, ci.opinionContent = /*opinionContent*/
        Yr[5], add_flush_callback(() => xr = !1)), _r.$set(ci);
      },
      i(Yr) {
        if (!Ar) {
          transition_in(cr.$$.fragment, Yr);
          for (let li = 0; li < $r.length; li += 1)
            transition_in(hr[li]);
          transition_in(_r.$$.fragment, Yr), Yr && add_render_callback(() => {
            Ar && (Cr || (Cr = create_bidirectional_transition(ar, fade, {}, !0)), Cr.run(1));
          }), Ar = !0;
        }
      },
      o(Yr) {
        transition_out(cr.$$.fragment, Yr);
        for (let li = 0; li < hr.length; li += 1)
          transition_out(hr[li]);
        transition_out(_r.$$.fragment, Yr), Yr && (Cr || (Cr = create_bidirectional_transition(ar, fade, {}, !1)), Cr.run(0)), Ar = !1;
      },
      d(Yr) {
        Yr && detach(ar), destroy_component(cr);
        for (let li = 0; li < hr.length; li += 1)
          hr[li].d();
        destroy_component(_r), Yr && Cr && Cr.end(), Lr = !1, Dr();
      }
    }
  );
}
function create_each_block_1$1(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func_3*/
      ar[57](
        /*file*/
        ar[73]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[73].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(hr, gr) {
      insert(hr, cr, gr), mount_component(ur, hr, gr), fr = !0;
    },
    p(hr, gr) {
      ar = hr;
      const vr = {};
      gr[0] & /*fileArray*/
      67108864 && (vr.file = /*file*/
      ar[73].files), gr[0] & /*fileArray*/
      67108864 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(hr) {
      fr || (transition_in(ur.$$.fragment, hr), fr = !0);
    },
    o(hr) {
      transition_out(ur.$$.fragment, hr), fr = !1;
    },
    d(hr) {
      hr && detach(cr), destroy_component(ur, hr);
    }
  };
}
function create_if_block_2$1(lr) {
  let ar = [], cr = /* @__PURE__ */ new Map(), ur, fr, dr = ensure_array_like(
    /*replyEvents*/
    lr[12]
  );
  const hr = (gr) => (
    /*event*/
    gr[3].id
  );
  for (let gr = 0; gr < dr.length; gr += 1) {
    let vr = get_each_context$1(lr, dr, gr), mr = hr(vr);
    cr.set(mr, ar[gr] = create_each_block$1(mr, vr));
  }
  return {
    c() {
      for (let gr = 0; gr < ar.length; gr += 1)
        ar[gr].c();
      ur = empty$1();
    },
    m(gr, vr) {
      for (let mr = 0; mr < ar.length; mr += 1)
        ar[mr] && ar[mr].m(gr, vr);
      insert(gr, ur, vr), fr = !0;
    },
    p(gr, vr) {
      vr[0] & /*replyEvents, profiles, editLvl, subject, sentimentCount, opinionContent, newOpinion*/
      4663 && (dr = ensure_array_like(
        /*replyEvents*/
        gr[12]
      ), group_outros(), ar = update_keyed_each(ar, vr, hr, 1, gr, dr, cr, ur.parentNode, outro_and_destroy_block, create_each_block$1, ur, get_each_context$1), check_outros());
    },
    i(gr) {
      if (!fr) {
        for (let vr = 0; vr < dr.length; vr += 1)
          transition_in(ar[vr]);
        fr = !0;
      }
    },
    o(gr) {
      for (let vr = 0; vr < ar.length; vr += 1)
        transition_out(ar[vr]);
      fr = !1;
    },
    d(gr) {
      gr && detach(ur);
      for (let vr = 0; vr < ar.length; vr += 1)
        ar[vr].d(gr);
    }
  };
}
function create_each_block$1(lr, ar) {
  let cr, ur, fr, dr, hr, gr, vr;
  function mr(_r) {
    ar[61](_r);
  }
  function br(_r) {
    ar[62](_r);
  }
  function yr(_r) {
    ar[63](_r);
  }
  function kr(_r) {
    ar[64](_r);
  }
  let Tr = {
    event: (
      /*event*/
      ar[3]
    ),
    profiles: (
      /*profiles*/
      ar[4]
    ),
    editLvl: (
      /*editLvl*/
      ar[2]
    ),
    subject: (
      /*subject*/
      ar[9]
    )
  };
  return (
    /*sentimentCount*/
    ar[1] !== void 0 && (Tr.sentimentCount = /*sentimentCount*/
    ar[1]), /*opinionContent*/
    ar[5] !== void 0 && (Tr.opinionContent = /*opinionContent*/
    ar[5]), /*newOpinion*/
    ar[0] !== void 0 && (Tr.newOpinion = /*newOpinion*/
    ar[0]), /*replyEvents*/
    ar[12].length !== void 0 && (Tr.count = /*replyEvents*/
    ar[12].length), ur = new OpinionCard({ props: Tr }), binding_callbacks.push(() => bind(ur, "sentimentCount", mr)), binding_callbacks.push(() => bind(ur, "opinionContent", br)), binding_callbacks.push(() => bind(ur, "newOpinion", yr)), binding_callbacks.push(() => bind(ur, "count", kr)), {
      key: lr,
      first: null,
      c() {
        cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
      },
      m(_r, Er) {
        insert(_r, cr, Er), mount_component(ur, _r, Er), vr = !0;
      },
      p(_r, Er) {
        ar = _r;
        const xr = {};
        Er[0] & /*replyEvents*/
        4096 && (xr.event = /*event*/
        ar[3]), Er[0] & /*profiles*/
        16 && (xr.profiles = /*profiles*/
        ar[4]), Er[0] & /*editLvl*/
        4 && (xr.editLvl = /*editLvl*/
        ar[2]), Er[0] & /*subject*/
        512 && (xr.subject = /*subject*/
        ar[9]), !fr && Er[0] & /*sentimentCount*/
        2 && (fr = !0, xr.sentimentCount = /*sentimentCount*/
        ar[1], add_flush_callback(() => fr = !1)), !dr && Er[0] & /*opinionContent*/
        32 && (dr = !0, xr.opinionContent = /*opinionContent*/
        ar[5], add_flush_callback(() => dr = !1)), !hr && Er[0] & /*newOpinion*/
        1 && (hr = !0, xr.newOpinion = /*newOpinion*/
        ar[0], add_flush_callback(() => hr = !1)), !gr && Er[0] & /*replyEvents*/
        4096 && (gr = !0, xr.count = /*replyEvents*/
        ar[12].length, add_flush_callback(() => gr = !1)), ur.$set(xr);
      },
      i(_r) {
        vr || (transition_in(ur.$$.fragment, _r), vr = !0);
      },
      o(_r) {
        transition_out(ur.$$.fragment, _r), vr = !1;
      },
      d(_r) {
        _r && detach(cr), destroy_component(ur, _r);
      }
    }
  );
}
function create_fragment$2(lr) {
  let ar, cr, ur = !/*isDeleted*/
  lr[11] && create_if_block$1(lr);
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*isDeleted*/
      fr[11] ? ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros()) : ur ? (ur.p(fr, dr), dr[0] & /*isDeleted*/
      2048 && transition_in(ur, 1)) : (ur = create_if_block$1(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar));
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
let contentHeight = 300;
const func = (lr) => lr[0] === "sentiment", func_1 = (lr) => lr[0] === "sentiment";
function instance$2(lr, ar, cr) {
  let ur, fr, dr, hr;
  component_subscribe(lr, ndkStore, (Yi) => cr(68, ur = Yi)), component_subscribe(lr, ndkUser, (Yi) => cr(29, fr = Yi)), component_subscribe(lr, localStore, (Yi) => cr(30, dr = Yi)), component_subscribe(lr, theme, (Yi) => cr(31, hr = Yi));
  let { event: gr } = ar, { profiles: vr } = ar, { submit: mr = () => {
  } } = ar, { opinionContent: br } = ar, { newOpinion: yr } = ar, { sentimentCount: kr } = ar, { editLvl: Tr } = ar, { subject: _r } = ar, { count: Er } = ar, { deletedEventsArray: xr = [] } = ar, { isMine: Cr = !1 } = ar, { trustedAuthors: Ar = [] } = ar;
  br = br.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "");
  let Lr = [], Dr = [], Nr, Hr = 0, $r = 0, Wr = !1, Zr = !1, oi = !1, Jr = !0, Yr = !1, li = !1, Si = !1, ci = gr.id, hi = "", Ei, di, gi = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), Li = !1, ui = gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""), wi = ui, Ui = [], yi, Vi = !1;
  Tr === 0 && (ci = kindOpinion + ":" + gr.pubkey + ":" + _r);
  function Oi() {
    cr(22, Si = !Si), cr(28, Vi = !Vi);
  }
  function Mi(Yi) {
    cr(0, yr = { ...yr, sentiment: Yi });
  }
  async function Ii(Yi) {
    const Zi = dr.pk;
    if (Zi ? !ur.signer && await privkeyLogin(Zi) : !ur.signer && await NDKlogin(), !fr)
      return;
    let ka = Dr.findIndex((Ji) => Ji.pubkey === fr.pubkey);
    ka != -1 && Dr[ka].content === Yi && (Yi = "");
    const zi = new NDKEvent(ur);
    zi.kind = NDKKind.Reaction, zi.content = Yi, zi.tags = [["a", ci], ["p", fr.pubkey]], await zi.publish(NDKRelaySet.fromRelayUrls(gi.write, ur)), ka = Dr.findIndex((Ji) => Ji.pubkey === fr.pubkey), ka != -1 ? Dr[ka] = {
      pubkey: fr.pubkey,
      content: Yi,
      timestamp: Date.now()
    } : Dr.push({
      pubkey: fr.pubkey,
      content: Yi,
      timestamp: Date.now()
    }), cr(14, Hr = Dr.filter((Ji) => Ji.content === "+").length), cr(15, $r = Dr.filter((Ji) => Ji.content === "-").length), Yi === "+" ? (cr(20, Yr = !0), cr(21, li = !1)) : Yi === "-" ? (cr(20, Yr = !1), cr(21, li = !0)) : (cr(20, Yr = !1), cr(21, li = !1));
  }
  (async () => {
    var Va;
    cr(3, gr.content = gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""), gr), cr(13, Nr = (await Promise.resolve().then(() => main)).expertOpinions), cr(2, Tr += 1), cr(23, hi = calculateRelativeTime(gr.created_at)), cr(19, Jr = !1);
    let Yi = { kinds: [kindNotes], "#a": [ci] };
    (await ur.fetchEvents(Yi, { closeOnEose: !1 })).forEach(async (Ca) => {
      cr(12, Lr = [...Lr, { ...Ca }]);
      const ja = await fetchUserProfile(Ca.pubkey);
      ja.image || (ja.image = profileImageUrl + Ca.pubkey), ja.pubkey || (ja.pubkey = Ca.pubkey), cr(4, vr[Ca.pubkey] = { content: ja }, vr), cr(4, vr = { ...vr });
    });
    let ka = 0;
    Yi = { kinds: [kindReaction], "#a": [ci] }, (await ur.fetchEvents(Yi, { closeOnEose: !1 })).forEach((Ca) => {
      let ja = Dr.findIndex((ao) => ao.pubkey === Ca.pubkey);
      Ca.created_at && (ja != -1 ? Dr[ja].timestamp < Ca.created_at && (Dr[ja] = {
        pubkey: Ca.pubkey,
        content: Ca.content,
        timestamp: Ca.created_at
      }) : Dr.push({
        pubkey: Ca.pubkey,
        content: Ca.content,
        timestamp: Ca.created_at
      }), cr(14, Hr = Dr.filter((ao) => ao.content === "+").length), cr(15, $r = Dr.filter((ao) => ao.content === "-").length), fr != null && fr.pubkey && Ca.pubkey === fr.pubkey && ka < Ca.created_at && (ka = Ca.created_at, Ca.content === "+" ? (cr(20, Yr = !0), cr(21, li = !1)) : Ca.content === "-" ? (cr(20, Yr = !1), cr(21, li = !0)) : (cr(20, Yr = !1), cr(21, li = !1))));
    });
    let Ji = await ur.fetchEvent({ kinds: [10002], authors: [gr.pubkey] }, { closeOnEose: !0 });
    Ji && Ji.getMatchingTags("r").map((Ca) => {
      Ca.length === 3 ? Ca[2] === "write" && !gi.write.includes(Ca[1]) ? gi.write.push(Ca[1]) : Ca[2] === "read" && !gi.read.includes(Ca[1]) && gi.read.push(Ca[1]) : Ca.length === 2 && (gi.write.includes(Ca[1]) || gi.write.push(Ca[1]), gi.read.includes(Ca[1]) || gi.read.push(Ca[1]));
    });
    const za = (Va = gr.tags.filter((Ca) => Ca[0] === "published_at")[0]) == null ? void 0 : Va[1];
    za && cr(24, Ei = parseInt(za)), cr(25, di = gr.created_at);
  })();
  const _i = async () => {
    if (!fr) {
      console.error("Can't submit reply. $ndkUser is undefined");
      return;
    }
    const Yi = dr.pk;
    if (Yi ? !ur.signer && await privkeyLogin(Yi) : !ur.signer && await NDKlogin(), br === "" || !br)
      return;
    const Zi = new NDKEvent(ur);
    Zi.kind = NDKKind.Text, Zi.content = br, Zi.tags = [["a", ci], ["p", fr.pubkey]], await Zi.publish(NDKRelaySet.fromRelayUrls(gi.write, ur)), cr(12, Lr = [...Lr, { ...Zi }]), cr(5, br = "");
  };
  function Ci(Yi) {
    const Zi = Ui.filter((ka) => ka === Yi)[0].url;
    cr(5, br = br.replace(Zi, "")), cr(26, Ui = Ui.filter((ka) => ka !== Yi));
  }
  afterUpdate(() => {
    if (yi) {
      const Yi = yi.offsetHeight;
      cr(28, Vi = Yi > contentHeight);
    }
  });
  function Ki(Yi) {
    binding_callbacks[Yi ? "unshift" : "push"](() => {
      yi = Yi, cr(27, yi);
    });
  }
  function Ni(Yi) {
    Ui = Yi, cr(26, Ui);
  }
  function ia(Yi) {
    br = Yi, cr(5, br), cr(11, Li), cr(2, Tr), cr(0, yr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  const ea = () => Mi("1"), la = () => Mi("0"), ma = () => Mi("-1"), Ba = (Yi) => Ci(Yi);
  function Fa(Yi) {
    Ui = Yi, cr(26, Ui);
  }
  function Ia(Yi) {
    br = Yi, cr(5, br), cr(11, Li), cr(2, Tr), cr(0, yr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  const Hi = () => mr((Ei || Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3)).toString()), oa = () => Ii("+"), Gi = () => Ii("-"), ha = () => {
    dr.lastUserLogged && (cr(17, Zr = !Zr), cr(16, Wr = !1), cr(5, br = ""), cr(18, oi = !1));
  }, Ua = () => {
    cr(18, oi = !oi);
  };
  function eo(Yi) {
    Li = Yi, cr(11, Li);
  }
  function ua(Yi) {
    Er = Yi, cr(6, Er);
  }
  const va = () => {
    cr(16, Wr = !Wr), cr(5, br = gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), cr(0, yr = {
      content: br,
      sentiment: gr.tagValue("sentiment") || "0"
    }), cr(17, Zr = !1), cr(18, oi = !1);
  };
  function Ta(Yi) {
    br = Yi, cr(5, br), cr(11, Li), cr(2, Tr), cr(0, yr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  const Aa = (Yi) => Ci(Yi), Oa = () => {
    _i(), cr(17, Zr = !1), cr(18, oi = !1);
  };
  function Xa(Yi) {
    Ui = Yi, cr(26, Ui);
  }
  function Ka(Yi) {
    br = Yi, cr(5, br), cr(11, Li), cr(2, Tr), cr(0, yr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  function Pa(Yi) {
    kr = Yi, cr(1, kr), cr(11, Li), cr(2, Tr), cr(0, yr), cr(38, xr), cr(3, gr);
  }
  function Da(Yi) {
    br = Yi, cr(5, br), cr(11, Li), cr(2, Tr), cr(0, yr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  function Ha(Yi) {
    yr = Yi, cr(0, yr), cr(11, Li), cr(2, Tr), cr(1, kr), cr(38, xr), cr(3, gr);
  }
  function $a(Yi) {
    lr.$$.not_equal(Lr.length, Yi) && (Lr.length = Yi, cr(12, Lr));
  }
  return lr.$$set = (Yi) => {
    "event" in Yi && cr(3, gr = Yi.event), "profiles" in Yi && cr(4, vr = Yi.profiles), "submit" in Yi && cr(8, mr = Yi.submit), "opinionContent" in Yi && cr(5, br = Yi.opinionContent), "newOpinion" in Yi && cr(0, yr = Yi.newOpinion), "sentimentCount" in Yi && cr(1, kr = Yi.sentimentCount), "editLvl" in Yi && cr(2, Tr = Yi.editLvl), "subject" in Yi && cr(9, _r = Yi.subject), "count" in Yi && cr(6, Er = Yi.count), "deletedEventsArray" in Yi && cr(38, xr = Yi.deletedEventsArray), "isMine" in Yi && cr(7, Cr = Yi.isMine), "trustedAuthors" in Yi && cr(10, Ar = Yi.trustedAuthors);
  }, lr.$$.update = () => {
    if (lr.$$.dirty[0] & /*editLvl, event*/
    12 && (ui = Tr > 1 ? gr.content : purify.sanitize(gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""))), lr.$$.dirty[0] & /*isDeleted, editLvl, newOpinion, sentimentCount, event*/
    2063 | lr.$$.dirty[1] & /*deletedEventsArray*/
    128 && Li) {
      if (Tr == 1) {
        cr(7, Cr = !1);
        let Yi = yr.sentiment, Zi = kr[Yi] - 1;
        Yi === "1" ? cr(1, kr = { ...kr, 1: Zi }) : Yi === "0" ? cr(1, kr = { ...kr, 0: Zi }) : cr(1, kr = { ...kr, "-1": Zi }), cr(0, yr = { content: "", sentiment: "0" }), cr(5, br = "");
      }
      cr(38, xr = [...xr, gr]);
    }
  }, [
    yr,
    kr,
    Tr,
    gr,
    vr,
    br,
    Er,
    Cr,
    mr,
    _r,
    Ar,
    Li,
    Lr,
    Nr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Jr,
    Yr,
    li,
    Si,
    hi,
    Ei,
    di,
    Ui,
    yi,
    Vi,
    fr,
    dr,
    hr,
    wi,
    Oi,
    Mi,
    Ii,
    _i,
    Ci,
    xr,
    Ki,
    Ni,
    ia,
    ea,
    la,
    ma,
    Ba,
    Fa,
    Ia,
    Hi,
    oa,
    Gi,
    ha,
    Ua,
    eo,
    ua,
    va,
    Ta,
    Aa,
    Oa,
    Xa,
    Ka,
    Pa,
    Da,
    Ha,
    $a
  ];
}
class OpinionCard extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$2,
      create_fragment$2,
      safe_not_equal,
      {
        event: 3,
        profiles: 4,
        submit: 8,
        opinionContent: 5,
        newOpinion: 0,
        sentimentCount: 1,
        editLvl: 2,
        subject: 9,
        count: 6,
        deletedEventsArray: 38,
        isMine: 7,
        trustedAuthors: 10
      },
      add_css$2,
      [-1, -1, -1]
    );
  }
  get event() {
    return this.$$.ctx[3];
  }
  set event(ar) {
    this.$$set({ event: ar }), flush();
  }
  get profiles() {
    return this.$$.ctx[4];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get submit() {
    return this.$$.ctx[8];
  }
  set submit(ar) {
    this.$$set({ submit: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[5];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get newOpinion() {
    return this.$$.ctx[0];
  }
  set newOpinion(ar) {
    this.$$set({ newOpinion: ar }), flush();
  }
  get sentimentCount() {
    return this.$$.ctx[1];
  }
  set sentimentCount(ar) {
    this.$$set({ sentimentCount: ar }), flush();
  }
  get editLvl() {
    return this.$$.ctx[2];
  }
  set editLvl(ar) {
    this.$$set({ editLvl: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[9];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get count() {
    return this.$$.ctx[6];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
  get deletedEventsArray() {
    return this.$$.ctx[38];
  }
  set deletedEventsArray(ar) {
    this.$$set({ deletedEventsArray: ar }), flush();
  }
  get isMine() {
    return this.$$.ctx[7];
  }
  set isMine(ar) {
    this.$$set({ isMine: ar }), flush();
  }
  get trustedAuthors() {
    return this.$$.ctx[10];
  }
  set trustedAuthors(ar) {
    this.$$set({ trustedAuthors: ar }), flush();
  }
}
create_custom_element(OpinionCard, { event: {}, profiles: {}, submit: {}, opinionContent: {}, newOpinion: {}, sentimentCount: {}, editLvl: {}, subject: {}, count: {}, deletedEventsArray: {}, isMine: { type: "Boolean" }, trustedAuthors: {} }, [], [], !0);
function add_css$1(lr) {
  append_styles(lr, "svelte-1xvuwjl", ".modal-overlay.svelte-1xvuwjl{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.5);display:flex;justify-content:center;align-items:center;z-index:2}.modal.svelte-1xvuwjl{background-color:var(--neutral-6, white);color:var(--neutral-0, black);border:1px solid var(--neutral-7);padding:20px;border-radius:5px;display:flex;flex-direction:column;gap:10px}.primary-btn.svelte-1xvuwjl{color:#ffffff;background-color:#3e8b0a;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}");
}
function create_fragment$1(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r;
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("p"), ur.textContent = "Are you sure you want to display all opinions?", fr = space(), dr = element("p"), dr.innerHTML = "<center>⚠️ Viewer discretion advised.</center>", hr = space(), gr = element("button"), gr.textContent = "Agree", vr = space(), mr = element("button"), mr.textContent = "Cancel", attr(gr, "class", "primary-btn svelte-1xvuwjl"), attr(mr, "class", "primary-btn svelte-1xvuwjl"), attr(cr, "class", "modal svelte-1xvuwjl"), attr(ar, "class", "modal-overlay svelte-1xvuwjl");
    },
    m(Er, xr) {
      insert(Er, ar, xr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, hr), append(cr, gr), append(cr, vr), append(cr, mr), kr = !0, Tr || (_r = [
        listen(gr, "click", function() {
          is_function(
            /*onAgree*/
            lr[0]
          ) && lr[0].apply(this, arguments);
        }),
        listen(mr, "click", function() {
          is_function(
            /*onCancel*/
            lr[1]
          ) && lr[1].apply(this, arguments);
        })
      ], Tr = !0);
    },
    p(Er, [xr]) {
      lr = Er;
    },
    i(Er) {
      kr || (Er && add_render_callback(() => {
        kr && (br || (br = create_bidirectional_transition(cr, fly, { y: 300, duration: 500, delay: 0 }, !0)), br.run(1));
      }), Er && add_render_callback(() => {
        kr && (yr || (yr = create_bidirectional_transition(ar, fade, { duration: 1e3 }, !0)), yr.run(1));
      }), kr = !0);
    },
    o(Er) {
      Er && (br || (br = create_bidirectional_transition(cr, fly, { y: 300, duration: 500, delay: 0 }, !1)), br.run(0)), Er && (yr || (yr = create_bidirectional_transition(ar, fade, { duration: 1e3 }, !1)), yr.run(0)), kr = !1;
    },
    d(Er) {
      Er && detach(ar), Er && br && br.end(), Er && yr && yr.end(), Tr = !1, run_all(_r);
    }
  };
}
function instance$1(lr, ar, cr) {
  let { onAgree: ur = () => {
  } } = ar, { onCancel: fr = () => {
  } } = ar;
  return lr.$$set = (dr) => {
    "onAgree" in dr && cr(0, ur = dr.onAgree), "onCancel" in dr && cr(1, fr = dr.onCancel);
  }, [ur, fr];
}
class ConfirmationModal extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$1, create_fragment$1, safe_not_equal, { onAgree: 0, onCancel: 1 }, add_css$1);
  }
  get onAgree() {
    return this.$$.ctx[0];
  }
  set onAgree(ar) {
    this.$$set({ onAgree: ar }), flush();
  }
  get onCancel() {
    return this.$$.ctx[1];
  }
  set onCancel(ar) {
    this.$$set({ onCancel: ar }), flush();
  }
}
create_custom_element(ConfirmationModal, { onAgree: {}, onCancel: {} }, [], [], !0);
async function initializeApprovedAuthors() {
  const lr = (await Promise.resolve().then(() => main)).expertOpinions;
  let ar = [];
  ar = lr.trustedAuthors.map((gr) => {
    const vr = nip19_exports.decode(gr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((gr) => gr != null);
  const cr = lr.trustedBadgeAuthors.map((gr) => {
    const vr = nip19_exports.decode(gr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((gr) => gr != null), ur = lr.trustedBadges.map((gr) => {
    const vr = nip19_exports.decode(gr);
    if (vr.type == "naddr" && vr.data.kind == NDKKind.BadgeDefinition)
      return `${vr.data.kind}:${vr.data.pubkey}:${vr.data.identifier}`;
  }).filter((gr) => gr != null), fr = get_store_value(ndkStore);
  await fr.connect(), (await fr.fetchEvents({
    kinds: [NDKKind.BadgeDefinition],
    authors: cr
  })).forEach((gr) => {
    const vr = gr.tags.find((mr) => mr[0] == "d");
    vr && ur.push(`${gr.kind}:${gr.pubkey}:${vr[1]}`);
  });
  const hr = [];
  return (await fr.fetchEvents({
    kinds: [NDKKind.BadgeAward],
    "#a": ur
  })).forEach((gr) => {
    const vr = gr.tags.filter((mr) => mr[0] == "p");
    vr.length && vr.forEach((mr) => hr.push(mr[1]));
  }), ar.push(...hr), lr.trustedAuthors.push(...ar.map((gr) => nip19_exports.npubEncode(gr))), ar;
}
function add_css(lr) {
  append_styles(lr, "svelte-1q3tlz7", `:host{--border-color:#dedede;--content-text-color:#606060;--pubkey-text-color:#7c2323;--date-text-color:#808080;--description-text-color:#808080;--filter-active-color:#000000;--filter-inactive-color:#e2e1e1;--button-text-color:#ffffff;--button-background-color:#3e8b0a;--sentiment-button-background-color:#3e8b0a;font-family:Arial, sans-serif}.svelte-1q3tlz7.svelte-1q3tlz7::-webkit-scrollbar{display:none}.svelte-1q3tlz7.svelte-1q3tlz7{-ms-overflow-style:none;scrollbar-width:none}.svelte-1q3tlz7.svelte-1q3tlz7::-webkit-scrollbar{display:none}.svelte-1q3tlz7.svelte-1q3tlz7{-ms-overflow-style:none;scrollbar-width:none}.expertOpinionsHeadline.svelte-1q3tlz7.svelte-1q3tlz7{font-family:'Barlow'}.top-nav.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;justify-content:space-between;border-top:#dedede 1px solid;border-bottom:#dedede 1px solid;padding:20px 0}.nav-count.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;align-items:center}.count-container.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;flex-direction:row}.description.svelte-1q3tlz7.svelte-1q3tlz7{margin:10px 0}.blank-btn.svelte-1q3tlz7.svelte-1q3tlz7{background-color:transparent;border:none;cursor:pointer}.filter-container.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;flex-direction:row}.filter-container.svelte-1q3tlz7>.filter-active.svelte-1q3tlz7{color:#3e8b0a}.filter-btn.svelte-1q3tlz7.svelte-1q3tlz7{color:#808080}.primary-btn.svelte-1q3tlz7.svelte-1q3tlz7{color:#ffffff;background-color:#3e8b0a;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}#review-input-details-container.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;flex-direction:column;gap:0.5rem;font-family:Arial, sans-serif}.btn-standard.svelte-1q3tlz7.svelte-1q3tlz7{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;padding-right:1.5rem;display:flex;justify-content:center;align-items:center;color:#808080}.dark.svelte-1q3tlz7.svelte-1q3tlz7{background-color:#434343;color:white}.btn-standard.svelte-1q3tlz7.svelte-1q3tlz7:hover{background-color:#3e8b0a}.btn-standard.svelte-1q3tlz7.svelte-1q3tlz7:hover{color:#ffffff}#sentiment-box.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;flex-direction:column;gap:0.3rem}.selected-state.svelte-1q3tlz7.svelte-1q3tlz7{background-color:#3e8b0a;color:#ffffff}.placeholder.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;font-family:Arial, sans-serif;align-items:center;gap:0.5rem;margin-top:1rem;margin-bottom:1rem}#imageContainer.svelte-1q3tlz7.svelte-1q3tlz7{display:block;border-radius:50%;width:50px;height:50px;object-fit:cover}#filePreview.svelte-1q3tlz7.svelte-1q3tlz7{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}.unfilterWarning.svelte-1q3tlz7.svelte-1q3tlz7{padding:7px;font-family:"Barlow", Arial, Helvetica, sans-serif;color:#808080;font-size:1em}.unfilterWarning.svelte-1q3tlz7 button.svelte-1q3tlz7{background-color:transparent;border:none;cursor:pointer;margin:none;color:#808080;font-family:"Barlow", Arial, Helvetica, sans-serif;font-size:1em;text-decoration:underline;text-decoration-thickness:0.5px}.opinion-container.svelte-1q3tlz7.svelte-1q3tlz7{max-height:200rem;overflow-y:scroll;margin:1rem 0}`);
}
function get_each_context(lr, ar, cr) {
  const ur = lr.slice();
  return ur[72] = ar[cr], ur;
}
function get_each_context_1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[75] = ar[cr], ur;
}
function create_else_block(lr) {
  let ar, cr = (
    /*expertOpinions*/
    lr[7].headline.replace(
      "$$nAll$$",
      /*allEventLength*/
      lr[17].toString() || "0"
    ).replace(
      "$$nTrusted$$",
      /*filter*/
      lr[12] === "approved" ? (
        /*filteredEventLength*/
        lr[18].toString()
      ) : (
        /*allEventLength*/
        lr[17].toString()
      )
    ) + ""
  ), ur, fr, dr, hr = (
    /*expertOpinions*/
    lr[7].description + ""
  ), gr, vr, mr, br, yr, kr, Tr, _r, Er = (
    /*sentimentCount*/
    lr[11][1] + ""
  ), xr, Cr, Ar, Lr, Dr, Nr, Hr = (
    /*sentimentCount*/
    lr[11][0] + ""
  ), $r, Wr, Zr, oi, Jr, Yr, li = (
    /*sentimentCount*/
    lr[11][-1] + ""
  ), Si, ci, hi, Ei, di, gi, Li, ui, wi, Ui, yi = [], Vi = /* @__PURE__ */ new Map(), Oi, Mi, Ii, mi = /*isMine*/ lr[16] ? "Edit" : "Add", _i, Ci, Ki, Ni, ia, ea, la, ma = (
    /*filteredEventLength*/
    lr[18] < 1 && /*allEventLength*/
    lr[17] >= 1 && /*filter*/
    lr[12] === "approved" && create_if_block_7(lr)
  );
  Tr = new Positive({}), Dr = new Neutral({}), Jr = new Negative({});
  let Ba = ensure_array_like(
    /*filteredEvents*/
    lr[2]
  );
  const Fa = (Hi) => (
    /*event*/
    Hi[75].id
  );
  for (let Hi = 0; Hi < Ba.length; Hi += 1) {
    let oa = get_each_context_1(lr, Ba, Hi), Gi = Fa(oa);
    Vi.set(Gi, yi[Hi] = create_each_block_1(Gi, oa));
  }
  let Ia = (
    /*showNewOpinion*/
    lr[4] && create_if_block_2(lr)
  );
  return {
    c() {
      ar = element("h1"), ur = text$3(cr), fr = space(), dr = element("p"), gr = text$3(hr), vr = space(), ma && ma.c(), mr = space(), br = element("nav"), yr = element("div"), kr = element("span"), create_component(Tr.$$.fragment), _r = space(), xr = text$3(Er), Cr = text$3(" positive"), Ar = space(), Lr = element("span"), create_component(Dr.$$.fragment), Nr = space(), $r = text$3(Hr), Wr = text$3(" neutral"), Zr = space(), oi = element("span"), create_component(Jr.$$.fragment), Yr = space(), Si = text$3(li), ci = text$3(" negative"), hi = space(), Ei = element("div"), di = element("button"), di.textContent = "Approved", gi = space(), Li = element("button"), Li.textContent = "All opinions", wi = space(), Ui = element("div");
      for (let Hi = 0; Hi < yi.length; Hi += 1)
        yi[Hi].c();
      Mi = space(), Ii = element("button"), _i = text$3(mi), Ci = text$3(" your opinion"), Ki = space(), Ia && Ia.c(), Ni = empty$1(), attr(ar, "class", "expertOpinionsHeadline svelte-1q3tlz7"), attr(dr, "class", "description svelte-1q3tlz7"), attr(kr, "class", "nav-count svelte-1q3tlz7"), attr(Lr, "class", "nav-count svelte-1q3tlz7"), attr(oi, "class", "nav-count svelte-1q3tlz7"), attr(yr, "class", "count-container svelte-1q3tlz7"), attr(di, "class", "blank-btn filter-btn svelte-1q3tlz7"), attr(di, "aria-label", "filter by approved"), toggle_class(
        di,
        "filter-active",
        /*filter*/
        lr[12] === "approved"
      ), attr(Li, "class", "blank-btn filter-btn svelte-1q3tlz7"), attr(Li, "aria-label", "filter by all"), toggle_class(
        Li,
        "filter-active",
        /*filter*/
        lr[12] === "all"
      ), attr(Ei, "class", "filter-container svelte-1q3tlz7"), attr(br, "class", "top-nav svelte-1q3tlz7"), attr(Ui, "class", "opinion-container svelte-1q3tlz7"), attr(Ii, "class", "primary-btn svelte-1q3tlz7");
    },
    m(Hi, oa) {
      insert(Hi, ar, oa), append(ar, ur), insert(Hi, fr, oa), insert(Hi, dr, oa), append(dr, gr), insert(Hi, vr, oa), ma && ma.m(Hi, oa), insert(Hi, mr, oa), insert(Hi, br, oa), append(br, yr), append(yr, kr), mount_component(Tr, kr, null), append(kr, _r), append(kr, xr), append(kr, Cr), append(yr, Ar), append(yr, Lr), mount_component(Dr, Lr, null), append(Lr, Nr), append(Lr, $r), append(Lr, Wr), append(yr, Zr), append(yr, oi), mount_component(Jr, oi, null), append(oi, Yr), append(oi, Si), append(oi, ci), append(br, hi), append(br, Ei), append(Ei, di), append(Ei, gi), append(Ei, Li), insert(Hi, wi, oa), insert(Hi, Ui, oa);
      for (let Gi = 0; Gi < yi.length; Gi += 1)
        yi[Gi] && yi[Gi].m(Ui, null);
      insert(Hi, Mi, oa), insert(Hi, Ii, oa), append(Ii, _i), append(Ii, Ci), insert(Hi, Ki, oa), Ia && Ia.m(Hi, oa), insert(Hi, Ni, oa), ia = !0, ea || (la = [
        listen(
          di,
          "click",
          /*click_handler*/
          lr[39]
        ),
        listen(
          Li,
          "click",
          /*handleAgree*/
          lr[26]
        ),
        listen(
          Ii,
          "click",
          /*click_handler_1*/
          lr[46]
        )
      ], ea = !0);
    },
    p(Hi, oa) {
      (!ia || oa[0] & /*expertOpinions, allEventLength, filter, filteredEventLength*/
      397440) && cr !== (cr = /*expertOpinions*/
      Hi[7].headline.replace(
        "$$nAll$$",
        /*allEventLength*/
        Hi[17].toString() || "0"
      ).replace(
        "$$nTrusted$$",
        /*filter*/
        Hi[12] === "approved" ? (
          /*filteredEventLength*/
          Hi[18].toString()
        ) : (
          /*allEventLength*/
          Hi[17].toString()
        )
      ) + "") && set_data(ur, cr), (!ia || oa[0] & /*expertOpinions*/
      128) && hr !== (hr = /*expertOpinions*/
      Hi[7].description + "") && set_data(gr, hr), /*filteredEventLength*/
      Hi[18] < 1 && /*allEventLength*/
      Hi[17] >= 1 && /*filter*/
      Hi[12] === "approved" ? ma ? ma.p(Hi, oa) : (ma = create_if_block_7(Hi), ma.c(), ma.m(mr.parentNode, mr)) : ma && (ma.d(1), ma = null), (!ia || oa[0] & /*sentimentCount*/
      2048) && Er !== (Er = /*sentimentCount*/
      Hi[11][1] + "") && set_data(xr, Er), (!ia || oa[0] & /*sentimentCount*/
      2048) && Hr !== (Hr = /*sentimentCount*/
      Hi[11][0] + "") && set_data($r, Hr), (!ia || oa[0] & /*sentimentCount*/
      2048) && li !== (li = /*sentimentCount*/
      Hi[11][-1] + "") && set_data(Si, li), (!ia || oa[0] & /*filter*/
      4096) && toggle_class(
        di,
        "filter-active",
        /*filter*/
        Hi[12] === "approved"
      ), (!ia || oa[0] & /*filter*/
      4096) && toggle_class(
        Li,
        "filter-active",
        /*filter*/
        Hi[12] === "all"
      ), oa[0] & /*filteredEvents, isUserOpinion, profiles, submit, subject, sentimentCount, opinionContent, newOpinion, count, deletedEventsArray, trustedAuthors*/
      12602159 && (Ba = ensure_array_like(
        /*filteredEvents*/
        Hi[2]
      ), group_outros(), yi = update_keyed_each(yi, oa, Fa, 1, Hi, Ba, Vi, Ui, outro_and_destroy_block, create_each_block_1, null, get_each_context_1), check_outros()), (!ia || oa[0] & /*isMine*/
      65536) && mi !== (mi = /*isMine*/
      Hi[16] ? "Edit" : "Add") && set_data(_i, mi), /*showNewOpinion*/
      Hi[4] ? Ia ? (Ia.p(Hi, oa), oa[0] & /*showNewOpinion*/
      16 && transition_in(Ia, 1)) : (Ia = create_if_block_2(Hi), Ia.c(), transition_in(Ia, 1), Ia.m(Ni.parentNode, Ni)) : Ia && (group_outros(), transition_out(Ia, 1, 1, () => {
        Ia = null;
      }), check_outros());
    },
    i(Hi) {
      if (!ia) {
        transition_in(Tr.$$.fragment, Hi), transition_in(Dr.$$.fragment, Hi), transition_in(Jr.$$.fragment, Hi), Hi && add_render_callback(() => {
          ia && (ui || (ui = create_bidirectional_transition(br, fade, {}, !0)), ui.run(1));
        });
        for (let oa = 0; oa < Ba.length; oa += 1)
          transition_in(yi[oa]);
        Hi && add_render_callback(() => {
          ia && (Oi || (Oi = create_bidirectional_transition(Ui, slide, {}, !0)), Oi.run(1));
        }), transition_in(Ia), ia = !0;
      }
    },
    o(Hi) {
      transition_out(Tr.$$.fragment, Hi), transition_out(Dr.$$.fragment, Hi), transition_out(Jr.$$.fragment, Hi), Hi && (ui || (ui = create_bidirectional_transition(br, fade, {}, !1)), ui.run(0));
      for (let oa = 0; oa < yi.length; oa += 1)
        transition_out(yi[oa]);
      Hi && (Oi || (Oi = create_bidirectional_transition(Ui, slide, {}, !1)), Oi.run(0)), transition_out(Ia), ia = !1;
    },
    d(Hi) {
      Hi && (detach(ar), detach(fr), detach(dr), detach(vr), detach(mr), detach(br), detach(wi), detach(Ui), detach(Mi), detach(Ii), detach(Ki), detach(Ni)), ma && ma.d(Hi), destroy_component(Tr), destroy_component(Dr), destroy_component(Jr), Hi && ui && ui.end();
      for (let oa = 0; oa < yi.length; oa += 1)
        yi[oa].d();
      Hi && Oi && Oi.end(), Ia && Ia.d(Hi), ea = !1, run_all(la);
    }
  };
}
function create_if_block_1(lr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "loading...", set_style(ar, "display", "flex"), set_style(ar, "justify-content", "center"), set_style(ar, "align-items", "center"), set_style(ar, "margin", "2rem 0"), attr(ar, "class", "svelte-1q3tlz7");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_7(lr) {
  let ar, cr, ur, fr, dr, hr = (
    /*allEventLength*/
    lr[17] === 1 ? " of an unknown author" : "s of unknown authors"
  ), gr, vr, mr, br, yr;
  return {
    c() {
      ar = element("div"), cr = element("button"), ur = text$3("Show "), fr = text$3(
        /*allEventLength*/
        lr[17]
      ), dr = text$3(" opinion"), gr = text$3(hr), vr = text$3(`.
			`), mr = text$3("⚠️ Viewer discretion advised."), attr(cr, "aria-label", "filter by all"), attr(cr, "class", "svelte-1q3tlz7"), toggle_class(
        cr,
        "filter-active",
        /*filter*/
        lr[12] === "approved"
      ), attr(ar, "class", "unfilterWarning svelte-1q3tlz7");
    },
    m(kr, Tr) {
      insert(kr, ar, Tr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, gr), append(cr, vr), append(ar, mr), br || (yr = listen(
        cr,
        "click",
        /*handleAgree*/
        lr[26]
      ), br = !0);
    },
    p(kr, Tr) {
      Tr[0] & /*allEventLength*/
      131072 && set_data(
        fr,
        /*allEventLength*/
        kr[17]
      ), Tr[0] & /*allEventLength*/
      131072 && hr !== (hr = /*allEventLength*/
      kr[17] === 1 ? " of an unknown author" : "s of unknown authors") && set_data(gr, hr), Tr[0] & /*filter*/
      4096 && toggle_class(
        cr,
        "filter-active",
        /*filter*/
        kr[12] === "approved"
      );
    },
    d(kr) {
      kr && detach(ar), br = !1, yr();
    }
  };
}
function create_if_block_6(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr;
  function mr(xr) {
    lr[40](xr);
  }
  function br(xr) {
    lr[41](xr);
  }
  function yr(xr) {
    lr[42](xr);
  }
  function kr(xr) {
    lr[43](xr);
  }
  function Tr(xr) {
    lr[44](xr);
  }
  function _r(xr) {
    lr[45](xr);
  }
  let Er = {
    event: (
      /*event*/
      lr[75]
    ),
    isMine: (
      /*isUserOpinion*/
      lr[22](
        /*event*/
        lr[75].pubkey
      )
    ),
    profiles: (
      /*profiles*/
      lr[3]
    ),
    submit: (
      /*submit*/
      lr[23]
    ),
    editLvl,
    subject: (
      /*subject*/
      lr[0]
    )
  };
  return (
    /*sentimentCount*/
    lr[11] !== void 0 && (Er.sentimentCount = /*sentimentCount*/
    lr[11]), /*opinionContent*/
    lr[9] !== void 0 && (Er.opinionContent = /*opinionContent*/
    lr[9]), /*newOpinion*/
    lr[8] !== void 0 && (Er.newOpinion = /*newOpinion*/
    lr[8]), /*count*/
    lr[14] !== void 0 && (Er.count = /*count*/
    lr[14]), /*deletedEventsArray*/
    lr[5] !== void 0 && (Er.deletedEventsArray = /*deletedEventsArray*/
    lr[5]), /*trustedAuthors*/
    lr[1] !== void 0 && (Er.trustedAuthors = /*trustedAuthors*/
    lr[1]), ar = new OpinionCard({ props: Er }), binding_callbacks.push(() => bind(ar, "sentimentCount", mr)), binding_callbacks.push(() => bind(ar, "opinionContent", br)), binding_callbacks.push(() => bind(ar, "newOpinion", yr)), binding_callbacks.push(() => bind(ar, "count", kr)), binding_callbacks.push(() => bind(ar, "deletedEventsArray", Tr)), binding_callbacks.push(() => bind(ar, "trustedAuthors", _r)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(xr, Cr) {
        mount_component(ar, xr, Cr), vr = !0;
      },
      p(xr, Cr) {
        const Ar = {};
        Cr[0] & /*filteredEvents*/
        4 && (Ar.event = /*event*/
        xr[75]), Cr[0] & /*filteredEvents*/
        4 && (Ar.isMine = /*isUserOpinion*/
        xr[22](
          /*event*/
          xr[75].pubkey
        )), Cr[0] & /*profiles*/
        8 && (Ar.profiles = /*profiles*/
        xr[3]), Cr[0] & /*subject*/
        1 && (Ar.subject = /*subject*/
        xr[0]), !cr && Cr[0] & /*sentimentCount*/
        2048 && (cr = !0, Ar.sentimentCount = /*sentimentCount*/
        xr[11], add_flush_callback(() => cr = !1)), !ur && Cr[0] & /*opinionContent*/
        512 && (ur = !0, Ar.opinionContent = /*opinionContent*/
        xr[9], add_flush_callback(() => ur = !1)), !fr && Cr[0] & /*newOpinion*/
        256 && (fr = !0, Ar.newOpinion = /*newOpinion*/
        xr[8], add_flush_callback(() => fr = !1)), !dr && Cr[0] & /*count*/
        16384 && (dr = !0, Ar.count = /*count*/
        xr[14], add_flush_callback(() => dr = !1)), !hr && Cr[0] & /*deletedEventsArray*/
        32 && (hr = !0, Ar.deletedEventsArray = /*deletedEventsArray*/
        xr[5], add_flush_callback(() => hr = !1)), !gr && Cr[0] & /*trustedAuthors*/
        2 && (gr = !0, Ar.trustedAuthors = /*trustedAuthors*/
        xr[1], add_flush_callback(() => gr = !1)), ar.$set(Ar);
      },
      i(xr) {
        vr || (transition_in(ar.$$.fragment, xr), vr = !0);
      },
      o(xr) {
        transition_out(ar.$$.fragment, xr), vr = !1;
      },
      d(xr) {
        destroy_component(ar, xr);
      }
    }
  );
}
function create_each_block_1(lr, ar) {
  let cr, ur = (
    /*deletedEventsArray*/
    ar[5].includes(
      /*event*/
      ar[75]
    ) === !1
  ), fr, dr, hr = ur && create_if_block_6(ar);
  return {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), hr && hr.c(), fr = empty$1(), this.first = cr;
    },
    m(gr, vr) {
      insert(gr, cr, vr), hr && hr.m(gr, vr), insert(gr, fr, vr), dr = !0;
    },
    p(gr, vr) {
      ar = gr, vr[0] & /*deletedEventsArray, filteredEvents*/
      36 && (ur = /*deletedEventsArray*/
      ar[5].includes(
        /*event*/
        ar[75]
      ) === !1), ur ? hr ? (hr.p(ar, vr), vr[0] & /*deletedEventsArray, filteredEvents*/
      36 && transition_in(hr, 1)) : (hr = create_if_block_6(ar), hr.c(), transition_in(hr, 1), hr.m(fr.parentNode, fr)) : hr && (group_outros(), transition_out(hr, 1, 1, () => {
        hr = null;
      }), check_outros());
    },
    i(gr) {
      dr || (transition_in(hr), dr = !0);
    },
    o(gr) {
      transition_out(hr), dr = !1;
    },
    d(gr) {
      gr && (detach(cr), detach(fr)), hr && hr.d(gr);
    }
  };
}
function create_if_block_2(lr) {
  let ar, cr, ur = /*isMine*/ lr[16] ? "Edit" : "Add", fr, dr, hr, gr, vr = purify.sanitize(
    /*expertOpinions*/
    lr[7].newOpinionDescription
  ) + "", mr, br, yr, kr, Tr;
  const _r = [create_if_block_3, create_else_block_1], Er = [];
  function xr(Cr, Ar) {
    var Lr, Dr;
    return (
      /*$ndkUser*/
      (Lr = Cr[6]) != null && Lr.pubkey && /*profiles*/
      Cr[3][
        /*$ndkUser*/
        (Dr = Cr[6]) == null ? void 0 : Dr.pubkey
      ] ? 0 : 1
    );
  }
  return br = xr(lr), yr = Er[br] = _r[br](lr), {
    c() {
      ar = element("div"), cr = element("h3"), fr = text$3(ur), dr = text$3(" your opinion"), hr = space(), gr = element("div"), mr = space(), yr.c(), attr(cr, "class", "svelte-1q3tlz7"), attr(gr, "class", "description svelte-1q3tlz7"), attr(ar, "class", "add-opinion-init svelte-1q3tlz7");
    },
    m(Cr, Ar) {
      insert(Cr, ar, Ar), append(ar, cr), append(cr, fr), append(cr, dr), append(ar, hr), append(ar, gr), gr.innerHTML = vr, append(ar, mr), Er[br].m(ar, null), Tr = !0;
    },
    p(Cr, Ar) {
      (!Tr || Ar[0] & /*isMine*/
      65536) && ur !== (ur = /*isMine*/
      Cr[16] ? "Edit" : "Add") && set_data(fr, ur), (!Tr || Ar[0] & /*expertOpinions*/
      128) && vr !== (vr = purify.sanitize(
        /*expertOpinions*/
        Cr[7].newOpinionDescription
      ) + "") && (gr.innerHTML = vr);
      let Lr = br;
      br = xr(Cr), br === Lr ? Er[br].p(Cr, Ar) : (group_outros(), transition_out(Er[Lr], 1, 1, () => {
        Er[Lr] = null;
      }), check_outros(), yr = Er[br], yr ? yr.p(Cr, Ar) : (yr = Er[br] = _r[br](Cr), yr.c()), transition_in(yr, 1), yr.m(ar, null));
    },
    i(Cr) {
      Tr || (transition_in(yr), Cr && add_render_callback(() => {
        Tr && (kr || (kr = create_bidirectional_transition(ar, fade, {}, !0)), kr.run(1));
      }), Tr = !0);
    },
    o(Cr) {
      transition_out(yr), Cr && (kr || (kr = create_bidirectional_transition(ar, fade, {}, !1)), kr.run(0)), Tr = !1;
    },
    d(Cr) {
      Cr && detach(ar), Er[br].d(), Cr && kr && kr.end();
    }
  };
}
function create_else_block_1(lr) {
  let ar, cr, ur, fr, dr, hr, gr, vr, mr, br, yr;
  const kr = [create_if_block_4, create_if_block_5], Tr = [];
  function _r(Er, xr) {
    return (
      /*showLoginOrRegister*/
      Er[13] === "login" ? 0 : (
        /*showLoginOrRegister*/
        Er[13] === "register" ? 1 : -1
      )
    );
  }
  return ~(hr = _r(lr)) && (gr = Tr[hr] = kr[hr](lr)), {
    c() {
      ar = element("div"), cr = element("button"), cr.textContent = "Log in", ur = space(), fr = element("button"), fr.textContent = "Register", dr = space(), gr && gr.c(), attr(cr, "class", "primary-btn svelte-1q3tlz7"), attr(fr, "class", "primary-btn svelte-1q3tlz7"), attr(ar, "class", "svelte-1q3tlz7");
    },
    m(Er, xr) {
      insert(Er, ar, xr), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), ~hr && Tr[hr].m(ar, null), mr = !0, br || (yr = [
        listen(
          cr,
          "click",
          /*click_handler_5*/
          lr[56]
        ),
        listen(
          fr,
          "click",
          /*click_handler_6*/
          lr[57]
        )
      ], br = !0);
    },
    p(Er, xr) {
      let Cr = hr;
      hr = _r(Er), hr === Cr ? ~hr && Tr[hr].p(Er, xr) : (gr && (group_outros(), transition_out(Tr[Cr], 1, 1, () => {
        Tr[Cr] = null;
      }), check_outros()), ~hr ? (gr = Tr[hr], gr ? gr.p(Er, xr) : (gr = Tr[hr] = kr[hr](Er), gr.c()), transition_in(gr, 1), gr.m(ar, null)) : gr = null);
    },
    i(Er) {
      mr || (transition_in(gr), Er && add_render_callback(() => {
        mr && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !0)), vr.run(1));
      }), mr = !0);
    },
    o(Er) {
      transition_out(gr), Er && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !1)), vr.run(0)), mr = !1;
    },
    d(Er) {
      Er && detach(ar), ~hr && Tr[hr].d(), Er && vr && vr.end(), br = !1, run_all(yr);
    }
  };
}
function create_if_block_3(lr) {
  var Oa, Xa, Ka, Pa, Da, Ha, $a, Yi, Zi, ka;
  let ar, cr, ur = (
    /*$ndkUser*/
    (((Oa = lr[6]) == null ? void 0 : Oa.npub) || "0") + ""
  ), fr, dr, hr, gr, vr, mr, br, yr, kr, Tr, _r, Er, xr, Cr = (!/*profiles*/
  ((Pa = (Ka = lr[3][
    /*$ndkUser*/
    (Xa = lr[6]) == null ? void 0 : Xa.pubkey
  ]) == null ? void 0 : Ka.content) != null && Pa.name) || /*profiles*/
  (($a = (Ha = lr[3][
    /*$ndkUser*/
    (Da = lr[6]) == null ? void 0 : Da.pubkey
  ]) == null ? void 0 : Ha.content) == null ? void 0 : $a.name) == "" ? (
    /*$ndkUser*/
    lr[6].npub.slice(0, 4) + "..." + /*$ndkUser*/
    lr[6].npub.slice(-4)
  ) : (
    /*profiles*/
    (ka = (Zi = lr[3][
      /*$ndkUser*/
      (Yi = lr[6]) == null ? void 0 : Yi.pubkey
    ]) == null ? void 0 : Zi.content) == null ? void 0 : ka.name
  )) + "", Ar, Lr, Dr, Nr, Hr, $r, Wr, Zr, oi, Jr, Yr, li, Si, ci, hi, Ei, di, gi, Li, ui, wi, Ui, yi, Vi, Oi, Mi, Ii, mi = [], _i = /* @__PURE__ */ new Map(), Ci, Ki, Ni, ia, ea, la, ma, Ba, Fa, Ia, Hi, oa;
  function Gi(zi) {
    lr[47](zi);
  }
  function ha(zi) {
    lr[48](zi);
  }
  let Ua = {};
  /*fileArray*/
  lr[15] !== void 0 && (Ua.fileArray = /*fileArray*/
  lr[15]), /*opinionContent*/
  lr[9] !== void 0 && (Ua.opinionContent = /*opinionContent*/
  lr[9]), Nr = new Editor_1({ props: Ua }), binding_callbacks.push(() => bind(Nr, "fileArray", Gi)), binding_callbacks.push(() => bind(Nr, "opinionContent", ha)), Si = new Positive({}), gi = new Neutral({}), yi = new Negative({});
  let eo = ensure_array_like(
    /*fileArray*/
    lr[15]
  );
  const ua = (zi) => (
    /*file*/
    zi[72].url
  );
  for (let zi = 0; zi < eo.length; zi += 1) {
    let Ji = get_each_context(lr, eo, zi), za = ua(Ji);
    _i.set(za, mi[zi] = create_each_block(za, Ji));
  }
  function va(zi) {
    lr[53](zi);
  }
  function Ta(zi) {
    lr[54](zi);
  }
  let Aa = {};
  return (
    /*fileArray*/
    lr[15] !== void 0 && (Aa.fileArray = /*fileArray*/
    lr[15]), /*opinionContent*/
    lr[9] !== void 0 && (Aa.opinionContent = /*opinionContent*/
    lr[9]), ma = new Upload({ props: Aa }), binding_callbacks.push(() => bind(ma, "fileArray", va)), binding_callbacks.push(() => bind(ma, "opinionContent", Ta)), {
      c() {
        var zi, Ji, za;
        ar = element("p"), cr = text$3("Logged in as "), fr = text$3(ur), dr = space(), hr = element("button"), hr.textContent = "Logout", gr = space(), vr = element("h3"), vr.textContent = "Share your opinion", mr = space(), br = element("p"), br.textContent = `We use Nostr to store opinions. You can post and access your posts via a unique private
					key.`, yr = space(), kr = element("div"), Tr = element("img"), Er = space(), xr = element("span"), Ar = text$3(Cr), Lr = space(), Dr = element("form"), create_component(Nr.$$.fragment), Wr = space(), Zr = element("div"), oi = element("label"), oi.textContent = "Choose your overall sentiment", Jr = space(), Yr = element("div"), li = element("button"), create_component(Si.$$.fragment), ci = space(), hi = element("span"), hi.textContent = "Positive", Ei = space(), di = element("button"), create_component(gi.$$.fragment), Li = space(), ui = element("span"), ui.textContent = "Neutral", wi = space(), Ui = element("button"), create_component(yi.$$.fragment), Vi = space(), Oi = element("span"), Oi.textContent = "Negative", Mi = space(), Ii = element("div");
        for (let Va = 0; Va < mi.length; Va += 1)
          mi[Va].c();
        Ci = space(), Ki = element("div"), Ni = element("button"), ia = text$3("Post"), la = space(), create_component(ma.$$.fragment), attr(ar, "class", "svelte-1q3tlz7"), attr(hr, "class", "primary-btn svelte-1q3tlz7"), attr(vr, "class", "svelte-1q3tlz7"), attr(br, "class", "description svelte-1q3tlz7"), set_style(br, "margin-top", "-1rem"), attr(Tr, "id", "imageContainer"), src_url_equal(Tr.src, _r = /*profiles*/
        (za = (Ji = lr[3][
          /*$ndkUser*/
          (zi = lr[6]) == null ? void 0 : zi.pubkey
        ]) == null ? void 0 : Ji.content) == null ? void 0 : za.image) || attr(Tr, "src", _r), attr(Tr, "alt", "Miranda"), attr(Tr, "class", "svelte-1q3tlz7"), set_style(xr, "font-size", "24px"), attr(xr, "class", "svelte-1q3tlz7"), attr(kr, "class", "placeholder svelte-1q3tlz7"), attr(oi, "for", "sentiment"), set_style(oi, "font-weight", "600"), attr(oi, "class", "svelte-1q3tlz7"), attr(hi, "class", "svelte-1q3tlz7"), attr(li, "class", "btn-standard svelte-1q3tlz7"), toggle_class(
          li,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          li,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "1"
        ), attr(ui, "class", "svelte-1q3tlz7"), attr(di, "class", "btn-standard svelte-1q3tlz7"), toggle_class(
          di,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          di,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "0"
        ), attr(Oi, "class", "svelte-1q3tlz7"), attr(Ui, "class", "btn-standard svelte-1q3tlz7"), toggle_class(
          Ui,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          Ui,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "-1"
        ), set_style(Yr, "display", "flex"), set_style(Yr, "gap", "0.4rem"), attr(Yr, "class", "svelte-1q3tlz7"), attr(Zr, "id", "sentiment-box"), attr(Zr, "class", "svelte-1q3tlz7"), attr(Ii, "id", "filePreview"), attr(Ii, "class", "svelte-1q3tlz7"), attr(Ni, "class", "primary-btn svelte-1q3tlz7"), set_style(Ni, "width", "5rem"), attr(Ni, "type", "submit"), Ni.disabled = ea = !/*$ndkUser*/
        lr[6], set_style(Ki, "display", "flex"), set_style(Ki, "align-contents", "center"), attr(Ki, "class", "svelte-1q3tlz7"), attr(Dr, "id", "review-input-details-container"), attr(Dr, "class", "svelte-1q3tlz7");
      },
      m(zi, Ji) {
        insert(zi, ar, Ji), append(ar, cr), append(ar, fr), insert(zi, dr, Ji), insert(zi, hr, Ji), insert(zi, gr, Ji), insert(zi, vr, Ji), insert(zi, mr, Ji), insert(zi, br, Ji), insert(zi, yr, Ji), insert(zi, kr, Ji), append(kr, Tr), append(kr, Er), append(kr, xr), append(xr, Ar), insert(zi, Lr, Ji), insert(zi, Dr, Ji), mount_component(Nr, Dr, null), append(Dr, Wr), append(Dr, Zr), append(Zr, oi), append(Zr, Jr), append(Zr, Yr), append(Yr, li), mount_component(Si, li, null), append(li, ci), append(li, hi), append(Yr, Ei), append(Yr, di), mount_component(gi, di, null), append(di, Li), append(di, ui), append(Yr, wi), append(Yr, Ui), mount_component(yi, Ui, null), append(Ui, Vi), append(Ui, Oi), append(Dr, Mi), append(Dr, Ii);
        for (let za = 0; za < mi.length; za += 1)
          mi[za] && mi[za].m(Ii, null);
        append(Dr, Ci), append(Dr, Ki), append(Ki, Ni), append(Ni, ia), append(Ki, la), mount_component(ma, Ki, null), Ia = !0, Hi || (oa = [
          listen(
            hr,
            "click",
            /*Logout*/
            lr[25]
          ),
          listen(li, "click", prevent_default(
            /*click_handler_2*/
            lr[49]
          )),
          listen(di, "click", prevent_default(
            /*click_handler_3*/
            lr[50]
          )),
          listen(Ui, "click", prevent_default(
            /*click_handler_4*/
            lr[51]
          )),
          listen(Dr, "submit", prevent_default(
            /*submit_handler*/
            lr[55]
          ))
        ], Hi = !0);
      },
      p(zi, Ji) {
        var Ca, ja, ao, Wa, po, to, oo, uo, Io, Lo, Eo, lo, ya;
        (!Ia || Ji[0] & /*$ndkUser*/
        64) && ur !== (ur = /*$ndkUser*/
        (((Ca = zi[6]) == null ? void 0 : Ca.npub) || "0") + "") && set_data(fr, ur), (!Ia || Ji[0] & /*profiles, $ndkUser*/
        72 && !src_url_equal(Tr.src, _r = /*profiles*/
        (Wa = (ao = zi[3][
          /*$ndkUser*/
          (ja = zi[6]) == null ? void 0 : ja.pubkey
        ]) == null ? void 0 : ao.content) == null ? void 0 : Wa.image)) && attr(Tr, "src", _r), (!Ia || Ji[0] & /*profiles, $ndkUser*/
        72) && Cr !== (Cr = (!/*profiles*/
        ((oo = (to = zi[3][
          /*$ndkUser*/
          (po = zi[6]) == null ? void 0 : po.pubkey
        ]) == null ? void 0 : to.content) != null && oo.name) || /*profiles*/
        ((Lo = (Io = zi[3][
          /*$ndkUser*/
          (uo = zi[6]) == null ? void 0 : uo.pubkey
        ]) == null ? void 0 : Io.content) == null ? void 0 : Lo.name) == "" ? (
          /*$ndkUser*/
          zi[6].npub.slice(0, 4) + "..." + /*$ndkUser*/
          zi[6].npub.slice(-4)
        ) : (
          /*profiles*/
          (ya = (lo = zi[3][
            /*$ndkUser*/
            (Eo = zi[6]) == null ? void 0 : Eo.pubkey
          ]) == null ? void 0 : lo.content) == null ? void 0 : ya.name
        )) + "") && set_data(Ar, Cr);
        const za = {};
        !Hr && Ji[0] & /*fileArray*/
        32768 && (Hr = !0, za.fileArray = /*fileArray*/
        zi[15], add_flush_callback(() => Hr = !1)), !$r && Ji[0] & /*opinionContent*/
        512 && ($r = !0, za.opinionContent = /*opinionContent*/
        zi[9], add_flush_callback(() => $r = !1)), Nr.$set(za), (!Ia || Ji[0] & /*$theme*/
        1048576) && toggle_class(
          li,
          "dark",
          /*$theme*/
          zi[20] === "dark"
        ), (!Ia || Ji[0] & /*newOpinion*/
        256) && toggle_class(
          li,
          "selected-state",
          /*newOpinion*/
          zi[8].sentiment === "1"
        ), (!Ia || Ji[0] & /*$theme*/
        1048576) && toggle_class(
          di,
          "dark",
          /*$theme*/
          zi[20] === "dark"
        ), (!Ia || Ji[0] & /*newOpinion*/
        256) && toggle_class(
          di,
          "selected-state",
          /*newOpinion*/
          zi[8].sentiment === "0"
        ), (!Ia || Ji[0] & /*$theme*/
        1048576) && toggle_class(
          Ui,
          "dark",
          /*$theme*/
          zi[20] === "dark"
        ), (!Ia || Ji[0] & /*newOpinion*/
        256) && toggle_class(
          Ui,
          "selected-state",
          /*newOpinion*/
          zi[8].sentiment === "-1"
        ), Ji[0] & /*fileArray, deleteFile*/
        536903680 && (eo = ensure_array_like(
          /*fileArray*/
          zi[15]
        ), group_outros(), mi = update_keyed_each(mi, Ji, ua, 1, zi, eo, _i, Ii, outro_and_destroy_block, create_each_block, null, get_each_context), check_outros()), (!Ia || Ji[0] & /*$ndkUser*/
        64 && ea !== (ea = !/*$ndkUser*/
        zi[6])) && (Ni.disabled = ea);
        const Va = {};
        !Ba && Ji[0] & /*fileArray*/
        32768 && (Ba = !0, Va.fileArray = /*fileArray*/
        zi[15], add_flush_callback(() => Ba = !1)), !Fa && Ji[0] & /*opinionContent*/
        512 && (Fa = !0, Va.opinionContent = /*opinionContent*/
        zi[9], add_flush_callback(() => Fa = !1)), ma.$set(Va);
      },
      i(zi) {
        if (!Ia) {
          transition_in(Nr.$$.fragment, zi), transition_in(Si.$$.fragment, zi), transition_in(gi.$$.fragment, zi), transition_in(yi.$$.fragment, zi);
          for (let Ji = 0; Ji < eo.length; Ji += 1)
            transition_in(mi[Ji]);
          transition_in(ma.$$.fragment, zi), Ia = !0;
        }
      },
      o(zi) {
        transition_out(Nr.$$.fragment, zi), transition_out(Si.$$.fragment, zi), transition_out(gi.$$.fragment, zi), transition_out(yi.$$.fragment, zi);
        for (let Ji = 0; Ji < mi.length; Ji += 1)
          transition_out(mi[Ji]);
        transition_out(ma.$$.fragment, zi), Ia = !1;
      },
      d(zi) {
        zi && (detach(ar), detach(dr), detach(hr), detach(gr), detach(vr), detach(mr), detach(br), detach(yr), detach(kr), detach(Lr), detach(Dr)), destroy_component(Nr), destroy_component(Si), destroy_component(gi), destroy_component(yi);
        for (let Ji = 0; Ji < mi.length; Ji += 1)
          mi[Ji].d();
        destroy_component(ma), Hi = !1, run_all(oa);
      }
    }
  );
}
function create_if_block_5(lr) {
  let ar, cr, ur, fr;
  function dr(vr) {
    lr[61](vr);
  }
  function hr(vr) {
    lr[62](vr);
  }
  let gr = {};
  return (
    /*profiles*/
    lr[3] !== void 0 && (gr.profiles = /*profiles*/
    lr[3]), /*showNewOpinion*/
    lr[4] !== void 0 && (gr.showNewOpinion = /*showNewOpinion*/
    lr[4]), ar = new Register({ props: gr }), binding_callbacks.push(() => bind(ar, "profiles", dr)), binding_callbacks.push(() => bind(ar, "showNewOpinion", hr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, mr) {
        mount_component(ar, vr, mr), fr = !0;
      },
      p(vr, mr) {
        const br = {};
        !cr && mr[0] & /*profiles*/
        8 && (cr = !0, br.profiles = /*profiles*/
        vr[3], add_flush_callback(() => cr = !1)), !ur && mr[0] & /*showNewOpinion*/
        16 && (ur = !0, br.showNewOpinion = /*showNewOpinion*/
        vr[4], add_flush_callback(() => ur = !1)), ar.$set(br);
      },
      i(vr) {
        fr || (transition_in(ar.$$.fragment, vr), fr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), fr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_4(lr) {
  let ar, cr, ur, fr, dr;
  function hr(br) {
    lr[58](br);
  }
  function gr(br) {
    lr[59](br);
  }
  function vr(br) {
    lr[60](br);
  }
  let mr = { subject: (
    /*subject*/
    lr[0]
  ) };
  return (
    /*profiles*/
    lr[3] !== void 0 && (mr.profiles = /*profiles*/
    lr[3]), /*opinionContent*/
    lr[9] !== void 0 && (mr.opinionContent = /*opinionContent*/
    lr[9]), /*showNewOpinion*/
    lr[4] !== void 0 && (mr.showNewOpinion = /*showNewOpinion*/
    lr[4]), ar = new Login({ props: mr }), binding_callbacks.push(() => bind(ar, "profiles", hr)), binding_callbacks.push(() => bind(ar, "opinionContent", gr)), binding_callbacks.push(() => bind(ar, "showNewOpinion", vr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(br, yr) {
        mount_component(ar, br, yr), dr = !0;
      },
      p(br, yr) {
        const kr = {};
        yr[0] & /*subject*/
        1 && (kr.subject = /*subject*/
        br[0]), !cr && yr[0] & /*profiles*/
        8 && (cr = !0, kr.profiles = /*profiles*/
        br[3], add_flush_callback(() => cr = !1)), !ur && yr[0] & /*opinionContent*/
        512 && (ur = !0, kr.opinionContent = /*opinionContent*/
        br[9], add_flush_callback(() => ur = !1)), !fr && yr[0] & /*showNewOpinion*/
        16 && (fr = !0, kr.showNewOpinion = /*showNewOpinion*/
        br[4], add_flush_callback(() => fr = !1)), ar.$set(kr);
      },
      i(br) {
        dr || (transition_in(ar.$$.fragment, br), dr = !0);
      },
      o(br) {
        transition_out(ar.$$.fragment, br), dr = !1;
      },
      d(br) {
        destroy_component(ar, br);
      }
    }
  );
}
function create_each_block(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func*/
      ar[52](
        /*file*/
        ar[72]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[72].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(hr, gr) {
      insert(hr, cr, gr), mount_component(ur, hr, gr), fr = !0;
    },
    p(hr, gr) {
      ar = hr;
      const vr = {};
      gr[0] & /*fileArray*/
      32768 && (vr.file = /*file*/
      ar[72].files), gr[0] & /*fileArray*/
      32768 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(hr) {
      fr || (transition_in(ur.$$.fragment, hr), fr = !0);
    },
    o(hr) {
      transition_out(ur.$$.fragment, hr), fr = !1;
    },
    d(hr) {
      hr && detach(cr), destroy_component(ur, hr);
    }
  };
}
function create_if_block(lr) {
  let ar, cr;
  return ar = new ConfirmationModal({
    props: {
      onAgree: (
        /*agreeToShowAll*/
        lr[27]
      ),
      onCancel: (
        /*onCancel*/
        lr[28]
      )
    }
  }), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    p: noop$1,
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_fragment(lr) {
  let ar, cr, ur, fr, dr;
  const hr = [create_if_block_1, create_else_block], gr = [];
  function vr(br, yr) {
    return (
      /*loading*/
      br[10] ? 0 : 1
    );
  }
  ar = vr(lr), cr = gr[ar] = hr[ar](lr);
  let mr = (
    /*showModal*/
    lr[19] && create_if_block(lr)
  );
  return {
    c() {
      cr.c(), ur = space(), mr && mr.c(), fr = empty$1();
    },
    m(br, yr) {
      gr[ar].m(br, yr), insert(br, ur, yr), mr && mr.m(br, yr), insert(br, fr, yr), dr = !0;
    },
    p(br, yr) {
      let kr = ar;
      ar = vr(br), ar === kr ? gr[ar].p(br, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), cr = gr[ar], cr ? cr.p(br, yr) : (cr = gr[ar] = hr[ar](br), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur)), /*showModal*/
      br[19] ? mr ? (mr.p(br, yr), yr[0] & /*showModal*/
      524288 && transition_in(mr, 1)) : (mr = create_if_block(br), mr.c(), transition_in(mr, 1), mr.m(fr.parentNode, fr)) : mr && (group_outros(), transition_out(mr, 1, 1, () => {
        mr = null;
      }), check_outros());
    },
    i(br) {
      dr || (transition_in(cr), transition_in(mr), dr = !0);
    },
    o(br) {
      transition_out(cr), transition_out(mr), dr = !1;
    },
    d(br) {
      br && (detach(ur), detach(fr)), gr[ar].d(br), mr && mr.d(br);
    }
  };
}
let editLvl = 0;
function instance(lr, ar, cr) {
  let ur, fr, dr, hr, gr;
  component_subscribe(lr, ndkStore, (Zi) => cr(65, ur = Zi)), component_subscribe(lr, ndkUser, (Zi) => cr(6, fr = Zi)), component_subscribe(lr, localStore, (Zi) => cr(66, dr = Zi)), component_subscribe(lr, theme, (Zi) => cr(20, gr = Zi));
  let { subject: vr } = ar, { opinionTitle: mr } = ar, { opinionHeader: br = mr } = ar, { opinionFooter: yr = void 0 } = ar, { opinionImage: kr = void 0 } = ar, { opinionTags: Tr = "NostrOpinion" } = ar, { summary: _r = `An opinion made about ${vr} generated using nostr-opinion-plugin.` } = ar, { themeModeLocalStorageHandle: Er = "colour-scheme" } = ar, xr = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), Cr, Ar = [], Lr = [], Dr = [], Nr = {}, Hr = { content: "", sentiment: "0" }, $r = "", Wr = !0, Zr = { "-1": 0, 0: 0, 1: 0 }, oi = "approved", Jr = !1, Yr = !1, li = 0, Si = [], ci = [], hi = !1, Ei = 0, di = 0, gi = !1, Li = { kinds: [kindOpinion], "#d": [vr] };
  const ui = ur.storeSubscribe(Li, { closeOnEose: !1 });
  component_subscribe(lr, ui, (Zi) => cr(38, hr = Zi));
  function wi(Zi) {
    return fr ? fr && Zi === fr.pubkey : !1;
  }
  const Ui = setInterval(
    () => {
      theme.set(localStorage.getItem(Er) || "light");
    },
    1e3
  );
  onDestroy(() => {
    clearInterval(Ui);
  });
  const yi = async (Zi) => {
    var Va;
    const ka = dr.pk;
    if (ka ? !ur.signer && await privkeyLogin(ka) : !ur.signer && await NDKlogin(), !$r || !ur.signer)
      return;
    cr(
      8,
      Hr.content = br ? br + opinionHeaderSeparator : "",
      Hr
    ), cr(8, Hr.content += $r + opinionFooterSeparator, Hr);
    const zi = (Va = await ur.fetchEvent({
      kinds: [kindOpinion],
      authors: [fr.pubkey]
    })) == null ? void 0 : Va.tags;
    (zi == null ? void 0 : zi.length) === 3 && zi[2][1] && (Zi = zi[2][1]);
    const Ji = new NDKEvent(ur);
    Ji.kind = kindOpinion, (!Zi || !Zi.length || Zi.length === 1) && (Zi = (Math.floor(Date.now() / 1e3) + 5).toString()), Ji.tags = [
      ["d", vr],
      ["sentiment", Hr.sentiment],
      ["summary", _r],
      ["published_at", Zi]
    ], mr && Ji.tags.push(["title", mr]), kr && Ji.tags.push(["image", kr]), Tr.split(",").map((Ca) => {
      Ca == "" || !Ca || (Ji.tags.push(["t", Ca]), cr(8, Hr.content += `#${Ca} `, Hr));
    }), yr && cr(8, Hr.content += `

` + yr, Hr), Ji.content = Hr.content, Ji.publish(NDKRelaySet.fromRelayUrls(xr.write, ur)).then(() => {
      const Ca = Lr.findIndex((ja) => ja.pubkey === Ji.pubkey);
      Ca !== -1 ? cr(37, Lr[Ca] = { ...Ji }, Lr) : cr(37, Lr = [{ ...Ji }, ...Lr]), Vi();
    });
    let za = ci.filter((Ca) => Ca.pubkey != (fr == null ? void 0 : fr.pubkey));
    cr(5, ci = [...za]), cr(16, hi = !0), cr(4, Jr = !1);
  }, Vi = () => {
    cr(11, Zr = { "-1": 0, 0: 0, 1: 0 }), cr(2, Dr = Lr.filter((Zi) => {
      var zi;
      if (oi === "approved" && !Ar.includes(Zi.pubkey))
        return !1;
      const ka = (zi = Zi.tags.find((Ji) => Ji[0] === "sentiment")) == null ? void 0 : zi[1];
      return ka && !ci.includes(Zi) && cr(11, Zr[ka] += 1, Zr), !0;
    })), cr(2, Dr = Dr.sort((Zi, ka) => {
      const zi = Ar.includes(Zi.pubkey), Ji = Ar.includes(ka.pubkey);
      if (zi && !Ji)
        return -1;
      if (!zi && Ji)
        return 1;
      let za = (Zi == null ? void 0 : Zi.created_at) || 0, Va = (ka == null ? void 0 : ka.created_at) || 0;
      return za > Va ? -1 : za < Va ? 1 : 0;
    }));
  };
  async function Oi(Zi) {
    if (!fr) {
      console.info("Can't find user profile. $ndkUser is undefined");
      return;
    }
    let ka = await fetchUserProfile(Zi);
    return ka || (ka = {
      image: profileImageUrl + fr.pubkey,
      pubkey: fr.pubkey
    }), ka.image || (ka.image = profileImageUrl + Zi), ka.pubkey || (ka.pubkey = Zi), { content: ka };
  }
  (async () => {
    cr(7, Cr = (await Promise.resolve().then(() => main)).expertOpinions), themeModeLocalStorageObject.set(Er);
    try {
      cr(1, Ar = await initializeApprovedAuthors());
      const Zi = dr.lastUserLogged;
      if (cr(10, Wr = !1), Zi && window) {
        let ka = ur.getUser({ npub: Zi });
        ia();
        let zi = await ur.fetchEvent({ kinds: [10002], authors: [ka.pubkey] });
        zi && zi.getMatchingTags("r").map((Ji) => {
          xr.read.includes(Ji[1]) || (Ji.length === 3 ? Ji[2] === "write" && !xr.write.includes(Ji[1]) ? xr.write.push(Ji[1]) : Ji[2] === "read" && !xr.read.includes(Ji[1]) && xr.read.push(Ji[1]) : Ji.length === 2 && (xr.write.includes(Ji[1]) || xr.write.push(Ji[1]), xr.read.includes(Ji[1]) || xr.read.push(Ji[1])));
        }), ndkUser.set(ka), fr && cr(3, Nr[fr.pubkey] = await Oi(fr.pubkey), Nr), Lr.map((Ji) => {
          Ji.pubkey === (fr == null ? void 0 : fr.pubkey) && cr(16, hi = !0);
        });
      }
    } catch (Zi) {
      console.error(Zi);
    }
  })();
  let Ii = !1;
  const mi = () => {
    xr = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), cr(16, hi = !1), logout(), cr(9, $r = "");
  };
  localStorage.getItem("userHasAgreed") === null && localStorage.setItem("userHasAgreed", "false");
  function _i() {
    Ii ? (cr(12, oi = "all"), Vi(), cr(4, Jr = !1)) : cr(19, gi = !0);
  }
  function Ci() {
    if (cr(12, oi = "all"), Vi(), cr(4, Jr = !1), cr(19, gi = !1), Ii = !0, fr != null && fr.pubkey) {
      const Zi = `userHasAgreed_${fr.pubkey}`;
      localStorage.setItem(Zi, Ii.toString());
    }
  }
  function Ki() {
    cr(19, gi = !1);
  }
  function Ni(Zi) {
    const ka = Si.filter((zi) => zi === Zi)[0].url;
    cr(9, $r = $r.replace(ka, "")), cr(9, $r = $r.replace("![]()", "")), cr(9, $r = $r.replace("![image]()", "")), cr(15, Si = Si.filter((zi) => zi !== Zi));
  }
  const ia = async () => {
    if (fr) {
      let Zi = {
        kinds: [kindOpinion],
        "#d": [vr],
        authors: [fr.pubkey]
      };
      const ka = await ur.fetchEvent(Zi);
      let zi = {
        kinds: [kindDelete],
        "#a": [`${kindOpinion}:${fr.pubkey}:${vr}`],
        authors: [fr.pubkey]
      };
      const Ji = await ur.fetchEvent(zi);
      if ((Ji == null ? void 0 : Ji.created_at) < (ka == null ? void 0 : ka.created_at) || !Ji && ka) {
        cr(16, hi = !0);
        let za = (ka == null ? void 0 : ka.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")) || "";
        const Va = (ka == null ? void 0 : ka.tagValue("sentiment")) || "0";
        cr(8, Hr = { content: za, sentiment: Va }), cr(9, $r = za);
      } else
        Jr && (cr(16, hi = !1), cr(8, Hr = { content: "", sentiment: "0" }), cr(9, $r = ""));
    }
  }, ea = () => {
    cr(12, oi = "approved"), Vi(), cr(4, Jr = !1);
  };
  function la(Zi) {
    Zr = Zi, cr(11, Zr);
  }
  function ma(Zi) {
    $r = Zi, cr(9, $r);
  }
  function Ba(Zi) {
    Hr = Zi, cr(8, Hr);
  }
  function Fa(Zi) {
    li = Zi, cr(14, li);
  }
  function Ia(Zi) {
    ci = Zi, cr(5, ci);
  }
  function Hi(Zi) {
    Ar = Zi, cr(1, Ar);
  }
  const oa = () => cr(4, Jr = !Jr);
  function Gi(Zi) {
    Si = Zi, cr(15, Si);
  }
  function ha(Zi) {
    $r = Zi, cr(9, $r);
  }
  const Ua = () => {
    cr(8, Hr = { ...Hr, sentiment: "1" });
  }, eo = () => {
    cr(8, Hr = { ...Hr, sentiment: "0" });
  }, ua = () => {
    cr(8, Hr = { ...Hr, sentiment: "-1" });
  }, va = (Zi) => Ni(Zi);
  function Ta(Zi) {
    Si = Zi, cr(15, Si);
  }
  function Aa(Zi) {
    $r = Zi, cr(9, $r);
  }
  const Oa = () => {
    yi(" ");
  }, Xa = () => cr(13, Yr = "login"), Ka = () => cr(13, Yr = "register");
  function Pa(Zi) {
    Nr = Zi, cr(3, Nr), cr(38, hr), cr(37, Lr);
  }
  function Da(Zi) {
    $r = Zi, cr(9, $r);
  }
  function Ha(Zi) {
    Jr = Zi, cr(4, Jr);
  }
  function $a(Zi) {
    Nr = Zi, cr(3, Nr), cr(38, hr), cr(37, Lr);
  }
  function Yi(Zi) {
    Jr = Zi, cr(4, Jr);
  }
  return lr.$$set = (Zi) => {
    "subject" in Zi && cr(0, vr = Zi.subject), "opinionTitle" in Zi && cr(30, mr = Zi.opinionTitle), "opinionHeader" in Zi && cr(31, br = Zi.opinionHeader), "opinionFooter" in Zi && cr(32, yr = Zi.opinionFooter), "opinionImage" in Zi && cr(33, kr = Zi.opinionImage), "opinionTags" in Zi && cr(34, Tr = Zi.opinionTags), "summary" in Zi && cr(35, _r = Zi.summary), "themeModeLocalStorageHandle" in Zi && cr(36, Er = Zi.themeModeLocalStorageHandle);
  }, lr.$$.update = () => {
    if (lr.$$.dirty[0] & /*trustedAuthors*/
    2 && Ar && Vi(), lr.$$.dirty[0] & /*showNewOpinion*/
    16 && ia(), lr.$$.dirty[0] & /*profiles*/
    8 | lr.$$.dirty[1] & /*$sub, allEvents*/
    192 && hr.forEach(async (Zi) => {
      if (Lr.filter((zi) => zi.pubkey === Zi.pubkey).length)
        cr(37, Lr = Lr.map((zi) => zi.pubkey === Zi.pubkey ? Zi : zi));
      else {
        cr(37, Lr = [...Lr, { ...Zi }]);
        const zi = await fetchUserProfile(Zi.pubkey);
        zi.image || (zi.image = profileImageUrl + Zi.pubkey), zi.pubkey || (zi.pubkey = Zi.pubkey), cr(3, Nr[Zi.pubkey] = { content: zi }, Nr), cr(3, Nr = { ...Nr });
      }
      Vi();
    }), lr.$$.dirty[0] & /*deletedEventsArray, filteredEvents*/
    36 | lr.$$.dirty[1] & /*allEvents*/
    64 && (cr(17, Ei = Lr.filter((Zi) => !ci.includes(Zi)).length), cr(18, di = Dr.filter((Zi) => !ci.includes(Zi)).length)), lr.$$.dirty[0] & /*$ndkUser, profiles*/
    72)
      if (fr != null && fr.pubkey && Nr[fr == null ? void 0 : fr.pubkey]) {
        const Zi = `userHasAgreed_${fr.pubkey}`;
        Ii = localStorage.getItem(Zi) === "true";
      } else
        Ii = !1;
  }, [
    vr,
    Ar,
    Dr,
    Nr,
    Jr,
    ci,
    fr,
    Cr,
    Hr,
    $r,
    Wr,
    Zr,
    oi,
    Yr,
    li,
    Si,
    hi,
    Ei,
    di,
    gi,
    gr,
    ui,
    wi,
    yi,
    Vi,
    mi,
    _i,
    Ci,
    Ki,
    Ni,
    mr,
    br,
    yr,
    kr,
    Tr,
    _r,
    Er,
    Lr,
    hr,
    ea,
    la,
    ma,
    Ba,
    Fa,
    Ia,
    Hi,
    oa,
    Gi,
    ha,
    Ua,
    eo,
    ua,
    va,
    Ta,
    Aa,
    Oa,
    Xa,
    Ka,
    Pa,
    Da,
    Ha,
    $a,
    Yi
  ];
}
class App extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance,
      create_fragment,
      safe_not_equal,
      {
        subject: 0,
        opinionTitle: 30,
        opinionHeader: 31,
        opinionFooter: 32,
        opinionImage: 33,
        opinionTags: 34,
        summary: 35,
        themeModeLocalStorageHandle: 36
      },
      add_css,
      [-1, -1, -1]
    );
  }
  get subject() {
    return this.$$.ctx[0];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get opinionTitle() {
    return this.$$.ctx[30];
  }
  set opinionTitle(ar) {
    this.$$set({ opinionTitle: ar }), flush();
  }
  get opinionHeader() {
    return this.$$.ctx[31];
  }
  set opinionHeader(ar) {
    this.$$set({ opinionHeader: ar }), flush();
  }
  get opinionFooter() {
    return this.$$.ctx[32];
  }
  set opinionFooter(ar) {
    this.$$set({ opinionFooter: ar }), flush();
  }
  get opinionImage() {
    return this.$$.ctx[33];
  }
  set opinionImage(ar) {
    this.$$set({ opinionImage: ar }), flush();
  }
  get opinionTags() {
    return this.$$.ctx[34];
  }
  set opinionTags(ar) {
    this.$$set({ opinionTags: ar }), flush();
  }
  get summary() {
    return this.$$.ctx[35];
  }
  set summary(ar) {
    this.$$set({ summary: ar }), flush();
  }
  get themeModeLocalStorageHandle() {
    return this.$$.ctx[36];
  }
  set themeModeLocalStorageHandle(ar) {
    this.$$set({ themeModeLocalStorageHandle: ar }), flush();
  }
}
customElements.define("nostr-opinion", create_custom_element(App, { subject: {}, opinionTitle: {}, opinionHeader: {}, opinionFooter: {}, opinionImage: {}, opinionTags: {}, summary: {}, themeModeLocalStorageHandle: {} }, [], [], !0));
class ExpertOpinions {
  constructor() {
    Wi(this, "headline", "Community Opinions ($$nTrusted$$/$$nAll$$)");
    Wi(this, "description", "These comments are contributed by nostr users using the nostr-opinions-plugin.");
    Wi(this, "newOpinionDescription", `<p>
	Thank you for contributing your opinion. Please make sure to follow these
	simple guidelines:
</p>
<ul>
	<li>Be objective</li>
	<li>Be polite</li>
</ul>`);
    Wi(this, "trustedAuthors", []);
    Wi(this, "trustedBadgeAuthors", []);
    Wi(this, "trustedBadges", []);
  }
}
const expertOpinions = new ExpertOpinions(), main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  expertOpinions
}, Symbol.toStringTag, { value: "Module" }));
export {
  expertOpinions
};
