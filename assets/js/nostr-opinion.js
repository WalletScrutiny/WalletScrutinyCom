var Bj = Object.defineProperty;
var Pj = (lr, ar, cr) => ar in lr ? Bj(lr, ar, { enumerable: !0, configurable: !0, writable: !0, value: cr }) : lr[ar] = cr;
var ji = (lr, ar, cr) => (Pj(lr, typeof ar != "symbol" ? ar + "" : ar, cr), cr), Xu = (lr, ar, cr) => {
  if (!ar.has(lr))
    throw TypeError("Cannot " + cr);
};
var to = (lr, ar, cr) => (Xu(lr, ar, "read from private field"), cr ? cr.call(lr) : ar.get(lr)), zo = (lr, ar, cr) => {
  if (ar.has(lr))
    throw TypeError("Cannot add the same private member more than once");
  ar instanceof WeakSet ? ar.add(lr) : ar.set(lr, cr);
}, cs = (lr, ar, cr, ur) => (Xu(lr, ar, "write to private field"), ur ? ur.call(lr, cr) : ar.set(lr, cr), cr);
var go = (lr, ar, cr) => (Xu(lr, ar, "access private method"), cr);
function noop$1() {
}
const identity = (lr) => lr;
function assign$1(lr, ar) {
  for (const cr in ar)
    lr[cr] = ar[cr];
  return (
    /** @type {T & S} */
    lr
  );
}
function run$1(lr) {
  return lr();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(lr) {
  lr.forEach(run$1);
}
function is_function(lr) {
  return typeof lr == "function";
}
function safe_not_equal(lr, ar) {
  return lr != lr ? ar == ar : lr !== ar || lr && typeof lr == "object" || typeof lr == "function";
}
let src_url_equal_anchor;
function src_url_equal(lr, ar) {
  return lr === ar ? !0 : (src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = ar, lr === src_url_equal_anchor.href);
}
function is_empty(lr) {
  return Object.keys(lr).length === 0;
}
function subscribe(lr, ...ar) {
  if (lr == null) {
    for (const ur of ar)
      ur(void 0);
    return noop$1;
  }
  const cr = lr.subscribe(...ar);
  return cr.unsubscribe ? () => cr.unsubscribe() : cr;
}
function get_store_value(lr) {
  let ar;
  return subscribe(lr, (cr) => ar = cr)(), ar;
}
function component_subscribe(lr, ar, cr) {
  lr.$$.on_destroy.push(subscribe(ar, cr));
}
function create_slot(lr, ar, cr, ur) {
  if (lr) {
    const fr = get_slot_context(lr, ar, cr, ur);
    return lr[0](fr);
  }
}
function get_slot_context(lr, ar, cr, ur) {
  return lr[1] && ur ? assign$1(cr.ctx.slice(), lr[1](ur(ar))) : cr.ctx;
}
function get_slot_changes(lr, ar, cr, ur) {
  if (lr[2] && ur) {
    const fr = lr[2](ur(cr));
    if (ar.dirty === void 0)
      return fr;
    if (typeof fr == "object") {
      const dr = [], gr = Math.max(ar.dirty.length, fr.length);
      for (let mr = 0; mr < gr; mr += 1)
        dr[mr] = ar.dirty[mr] | fr[mr];
      return dr;
    }
    return ar.dirty | fr;
  }
  return ar.dirty;
}
function update_slot_base(lr, ar, cr, ur, fr, dr) {
  if (fr) {
    const gr = get_slot_context(ar, cr, ur, dr);
    lr.p(gr, fr);
  }
}
function get_all_dirty_from_scope(lr) {
  if (lr.ctx.length > 32) {
    const ar = [], cr = lr.ctx.length / 32;
    for (let ur = 0; ur < cr; ur++)
      ar[ur] = -1;
    return ar;
  }
  return -1;
}
function exclude_internal_props(lr) {
  const ar = {};
  for (const cr in lr)
    cr[0] !== "$" && (ar[cr] = lr[cr]);
  return ar;
}
function compute_rest_props(lr, ar) {
  const cr = {};
  ar = new Set(ar);
  for (const ur in lr)
    !ar.has(ur) && ur[0] !== "$" && (cr[ur] = lr[ur]);
  return cr;
}
function compute_slots(lr) {
  const ar = {};
  for (const cr in lr)
    ar[cr] = !0;
  return ar;
}
function set_store_value(lr, ar, cr) {
  return lr.set(cr), ar;
}
function action_destroyer(lr) {
  return lr && is_function(lr.destroy) ? lr.destroy : noop$1;
}
function split_css_unit(lr) {
  const ar = typeof lr == "string" && lr.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return ar ? [parseFloat(ar[1]), ar[2] || "px"] : [
    /** @type {number} */
    lr,
    "px"
  ];
}
const is_client = typeof window != "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (lr) => requestAnimationFrame(lr) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(lr) {
  tasks.forEach((ar) => {
    ar.c(lr) || (tasks.delete(ar), ar.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(lr) {
  let ar;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((cr) => {
      tasks.add(ar = { c: lr, f: cr });
    }),
    abort() {
      tasks.delete(ar);
    }
  };
}
const globals = typeof window != "undefined" ? window : typeof globalThis != "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function append(lr, ar) {
  lr.appendChild(ar);
}
function append_styles(lr, ar, cr) {
  const ur = get_root_for_style(lr);
  if (!ur.getElementById(ar)) {
    const fr = element("style");
    fr.id = ar, fr.textContent = cr, append_stylesheet(ur, fr);
  }
}
function get_root_for_style(lr) {
  if (!lr)
    return document;
  const ar = lr.getRootNode ? lr.getRootNode() : lr.ownerDocument;
  return ar && /** @type {ShadowRoot} */
  ar.host ? (
    /** @type {ShadowRoot} */
    ar
  ) : lr.ownerDocument;
}
function append_empty_stylesheet(lr) {
  const ar = element("style");
  return ar.textContent = "/* empty */", append_stylesheet(get_root_for_style(lr), ar), ar.sheet;
}
function append_stylesheet(lr, ar) {
  return append(
    /** @type {Document} */
    lr.head || lr,
    ar
  ), ar.sheet;
}
function insert(lr, ar, cr) {
  lr.insertBefore(ar, cr || null);
}
function detach(lr) {
  lr.parentNode && lr.parentNode.removeChild(lr);
}
function destroy_each(lr, ar) {
  for (let cr = 0; cr < lr.length; cr += 1)
    lr[cr] && lr[cr].d(ar);
}
function element(lr) {
  return document.createElement(lr);
}
function svg_element(lr) {
  return document.createElementNS("http://www.w3.org/2000/svg", lr);
}
function text$3(lr) {
  return document.createTextNode(lr);
}
function space() {
  return text$3(" ");
}
function empty$1() {
  return text$3("");
}
function listen(lr, ar, cr, ur) {
  return lr.addEventListener(ar, cr, ur), () => lr.removeEventListener(ar, cr, ur);
}
function prevent_default(lr) {
  return function(ar) {
    return ar.preventDefault(), lr.call(this, ar);
  };
}
function attr(lr, ar, cr) {
  cr == null ? lr.removeAttribute(ar) : lr.getAttribute(ar) !== cr && lr.setAttribute(ar, cr);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(lr, ar) {
  const cr = Object.getOwnPropertyDescriptors(lr.__proto__);
  for (const ur in ar)
    ar[ur] == null ? lr.removeAttribute(ur) : ur === "style" ? lr.style.cssText = ar[ur] : ur === "__value" ? lr.value = lr[ur] = ar[ur] : cr[ur] && cr[ur].set && always_set_through_set_attribute.indexOf(ur) === -1 ? lr[ur] = ar[ur] : attr(lr, ur, ar[ur]);
}
function init_binding_group(lr) {
  let ar;
  return {
    /* push */
    p(...cr) {
      ar = cr, ar.forEach((ur) => lr.push(ur));
    },
    /* remove */
    r() {
      ar.forEach((cr) => lr.splice(lr.indexOf(cr), 1));
    }
  };
}
function to_number(lr) {
  return lr === "" ? null : +lr;
}
function children(lr) {
  return Array.from(lr.childNodes);
}
function set_data(lr, ar) {
  ar = "" + ar, lr.data !== ar && (lr.data = /** @type {string} */
  ar);
}
function set_input_value(lr, ar) {
  lr.value = ar == null ? "" : ar;
}
function set_style(lr, ar, cr, ur) {
  cr == null ? lr.style.removeProperty(ar) : lr.style.setProperty(ar, cr, ur ? "important" : "");
}
function select_option(lr, ar, cr) {
  for (let ur = 0; ur < lr.options.length; ur += 1) {
    const fr = lr.options[ur];
    if (fr.__value === ar) {
      fr.selected = !0;
      return;
    }
  }
  (!cr || ar !== void 0) && (lr.selectedIndex = -1);
}
function select_options(lr, ar) {
  for (let cr = 0; cr < lr.options.length; cr += 1) {
    const ur = lr.options[cr];
    ur.selected = ~ar.indexOf(ur.__value);
  }
}
function select_value(lr) {
  const ar = lr.querySelector(":checked");
  return ar && ar.__value;
}
function select_multiple_value(lr) {
  return [].map.call(lr.querySelectorAll(":checked"), (ar) => ar.__value);
}
function toggle_class(lr, ar, cr) {
  lr.classList.toggle(ar, !!cr);
}
function custom_event(lr, ar, { bubbles: cr = !1, cancelable: ur = !1 } = {}) {
  return new CustomEvent(lr, { detail: ar, bubbles: cr, cancelable: ur });
}
class HtmlTag {
  constructor(ar = !1) {
    /**
     * @private
     * @default false
     */
    ji(this, "is_svg", !1);
    /** parent for creating node */
    ji(this, "e");
    /** html tag nodes */
    ji(this, "n");
    /** target */
    ji(this, "t");
    /** anchor */
    ji(this, "a");
    this.is_svg = ar, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(ar) {
    this.h(ar);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(ar, cr, ur = null) {
    this.e || (this.is_svg ? this.e = svg_element(
      /** @type {keyof SVGElementTagNameMap} */
      cr.nodeName
    ) : this.e = element(
      /** @type {keyof HTMLElementTagNameMap} */
      cr.nodeType === 11 ? "TEMPLATE" : cr.nodeName
    ), this.t = cr.tagName !== "TEMPLATE" ? cr : (
      /** @type {HTMLTemplateElement} */
      cr.content
    ), this.c(ar)), this.i(ur);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(ar) {
    this.e.innerHTML = ar, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(ar) {
    for (let cr = 0; cr < this.n.length; cr += 1)
      insert(this.t, this.n[cr], ar);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(ar) {
    this.d(), this.h(ar), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function get_custom_elements_slots(lr) {
  const ar = {};
  return lr.childNodes.forEach(
    /** @param {Element} node */
    (cr) => {
      ar[cr.slot || "default"] = !0;
    }
  ), ar;
}
function construct_svelte_component(lr, ar) {
  return new lr(ar);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash$7(lr) {
  let ar = 5381, cr = lr.length;
  for (; cr--; )
    ar = (ar << 5) - ar ^ lr.charCodeAt(cr);
  return ar >>> 0;
}
function create_style_information(lr, ar) {
  const cr = { stylesheet: append_empty_stylesheet(ar), rules: {} };
  return managed_styles.set(lr, cr), cr;
}
function create_rule(lr, ar, cr, ur, fr, dr, gr, mr = 0) {
  const vr = 16.666 / ur;
  let yr = `{
`;
  for (let Tr = 0; Tr <= 1; Tr += vr) {
    const Ar = ar + (cr - ar) * dr(Tr);
    yr += Tr * 100 + `%{${gr(Ar, 1 - Ar)}}
`;
  }
  const kr = yr + `100% {${gr(cr, 1 - cr)}}
}`, _r = `__svelte_${hash$7(kr)}_${mr}`, xr = get_root_for_style(lr), { stylesheet: Sr, rules: Er } = managed_styles.get(xr) || create_style_information(xr, lr);
  Er[_r] || (Er[_r] = !0, Sr.insertRule(`@keyframes ${_r} ${kr}`, Sr.cssRules.length));
  const Cr = lr.style.animation || "";
  return lr.style.animation = `${Cr ? `${Cr}, ` : ""}${_r} ${ur}ms linear ${fr}ms 1 both`, active += 1, _r;
}
function delete_rule(lr, ar) {
  const cr = (lr.style.animation || "").split(", "), ur = cr.filter(
    ar ? (dr) => dr.indexOf(ar) < 0 : (dr) => dr.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), fr = cr.length - ur.length;
  fr && (lr.style.animation = ur.join(", "), active -= fr, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((lr) => {
      const { ownerNode: ar } = lr.stylesheet;
      ar && detach(ar);
    }), managed_styles.clear());
  });
}
function create_animation(lr, ar, cr, ur) {
  if (!ar)
    return noop$1;
  const fr = lr.getBoundingClientRect();
  if (ar.left === fr.left && ar.right === fr.right && ar.top === fr.top && ar.bottom === fr.bottom)
    return noop$1;
  const {
    delay: dr = 0,
    duration: gr = 300,
    easing: mr = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: vr = now() + dr,
    // @ts-ignore todo:
    end: yr = vr + gr,
    tick: kr = noop$1,
    css: _r
  } = cr(lr, { from: ar, to: fr }, ur);
  let xr = !0, Sr = !1, Er;
  function Cr() {
    _r && (Er = create_rule(lr, 0, 1, gr, dr, mr, _r)), dr || (Sr = !0);
  }
  function Tr() {
    _r && delete_rule(lr, Er), xr = !1;
  }
  return loop((Ar) => {
    if (!Sr && Ar >= vr && (Sr = !0), Sr && Ar >= yr && (kr(1, 0), Tr()), !xr)
      return !1;
    if (Sr) {
      const Ir = Ar - vr, Mr = 0 + 1 * mr(Ir / gr);
      kr(Mr, 1 - Mr);
    }
    return !0;
  }), Cr(), kr(0, 1), Tr;
}
function fix_position(lr) {
  const ar = getComputedStyle(lr);
  if (ar.position !== "absolute" && ar.position !== "fixed") {
    const { width: cr, height: ur } = ar, fr = lr.getBoundingClientRect();
    lr.style.position = "absolute", lr.style.width = cr, lr.style.height = ur, add_transform(lr, fr);
  }
}
function add_transform(lr, ar) {
  const cr = lr.getBoundingClientRect();
  if (ar.left !== cr.left || ar.top !== cr.top) {
    const ur = getComputedStyle(lr), fr = ur.transform === "none" ? "" : ur.transform;
    lr.style.transform = `${fr} translate(${ar.left - cr.left}px, ${ar.top - cr.top}px)`;
  }
}
let current_component;
function set_current_component(lr) {
  current_component = lr;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(lr) {
  get_current_component().$$.on_mount.push(lr);
}
function afterUpdate(lr) {
  get_current_component().$$.after_update.push(lr);
}
function onDestroy(lr) {
  get_current_component().$$.on_destroy.push(lr);
}
function createEventDispatcher() {
  const lr = get_current_component();
  return (ar, cr, { cancelable: ur = !1 } = {}) => {
    const fr = lr.$$.callbacks[ar];
    if (fr) {
      const dr = custom_event(
        /** @type {string} */
        ar,
        cr,
        { cancelable: ur }
      );
      return fr.slice().forEach((gr) => {
        gr.call(lr, dr);
      }), !dr.defaultPrevented;
    }
    return !0;
  };
}
function setContext(lr, ar) {
  return get_current_component().$$.context.set(lr, ar), ar;
}
function getContext(lr) {
  return get_current_component().$$.context.get(lr);
}
function bubble(lr, ar) {
  const cr = lr.$$.callbacks[ar.type];
  cr && cr.slice().forEach((ur) => ur.call(this, ar));
}
const dirty_components = [], binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [], resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(lr) {
  render_callbacks.push(lr);
}
function add_flush_callback(lr) {
  flush_callbacks.push(lr);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const lr = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const ar = dirty_components[flushidx];
        flushidx++, set_current_component(ar), update(ar.$$);
      }
    } catch (ar) {
      throw dirty_components.length = 0, flushidx = 0, ar;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let ar = 0; ar < render_callbacks.length; ar += 1) {
      const cr = render_callbacks[ar];
      seen_callbacks.has(cr) || (seen_callbacks.add(cr), cr());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(lr);
}
function update(lr) {
  if (lr.fragment !== null) {
    lr.update(), run_all(lr.before_update);
    const ar = lr.dirty;
    lr.dirty = [-1], lr.fragment && lr.fragment.p(lr.ctx, ar), lr.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(lr) {
  const ar = [], cr = [];
  render_callbacks.forEach((ur) => lr.indexOf(ur) === -1 ? ar.push(ur) : cr.push(ur)), cr.forEach((ur) => ur()), render_callbacks = ar;
}
let promise;
function wait() {
  return promise || (promise = Promise.resolve(), promise.then(() => {
    promise = null;
  })), promise;
}
function dispatch(lr, ar, cr) {
  lr.dispatchEvent(custom_event(`${ar ? "intro" : "outro"}${cr}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(lr, ar) {
  lr && lr.i && (outroing.delete(lr), lr.i(ar));
}
function transition_out(lr, ar, cr, ur) {
  if (lr && lr.o) {
    if (outroing.has(lr))
      return;
    outroing.add(lr), outros.c.push(() => {
      outroing.delete(lr), ur && (cr && lr.d(1), ur());
    }), lr.o(ar);
  } else
    ur && ur();
}
const null_transition = { duration: 0 };
function create_in_transition(lr, ar, cr) {
  const ur = { direction: "in" };
  let fr = ar(lr, cr, ur), dr = !1, gr, mr, vr = 0;
  function yr() {
    gr && delete_rule(lr, gr);
  }
  function kr() {
    const {
      delay: xr = 0,
      duration: Sr = 300,
      easing: Er = identity,
      tick: Cr = noop$1,
      css: Tr
    } = fr || null_transition;
    Tr && (gr = create_rule(lr, 0, 1, Sr, xr, Er, Tr, vr++)), Cr(0, 1);
    const Ar = now() + xr, Ir = Ar + Sr;
    mr && mr.abort(), dr = !0, add_render_callback(() => dispatch(lr, !0, "start")), mr = loop((Mr) => {
      if (dr) {
        if (Mr >= Ir)
          return Cr(1, 0), dispatch(lr, !0, "end"), yr(), dr = !1;
        if (Mr >= Ar) {
          const Hr = Er((Mr - Ar) / Sr);
          Cr(Hr, 1 - Hr);
        }
      }
      return dr;
    });
  }
  let _r = !1;
  return {
    start() {
      _r || (_r = !0, delete_rule(lr), is_function(fr) ? (fr = fr(ur), wait().then(kr)) : kr());
    },
    invalidate() {
      _r = !1;
    },
    end() {
      dr && (yr(), dr = !1);
    }
  };
}
function create_out_transition(lr, ar, cr) {
  const ur = { direction: "out" };
  let fr = ar(lr, cr, ur), dr = !0, gr;
  const mr = outros;
  mr.r += 1;
  let vr;
  function yr() {
    const {
      delay: kr = 0,
      duration: _r = 300,
      easing: xr = identity,
      tick: Sr = noop$1,
      css: Er
    } = fr || null_transition;
    Er && (gr = create_rule(lr, 1, 0, _r, kr, xr, Er));
    const Cr = now() + kr, Tr = Cr + _r;
    add_render_callback(() => dispatch(lr, !1, "start")), "inert" in lr && (vr = /** @type {HTMLElement} */
    lr.inert, lr.inert = !0), loop((Ar) => {
      if (dr) {
        if (Ar >= Tr)
          return Sr(0, 1), dispatch(lr, !1, "end"), --mr.r || run_all(mr.c), !1;
        if (Ar >= Cr) {
          const Ir = xr((Ar - Cr) / _r);
          Sr(1 - Ir, Ir);
        }
      }
      return dr;
    });
  }
  return is_function(fr) ? wait().then(() => {
    fr = fr(ur), yr();
  }) : yr(), {
    end(kr) {
      kr && "inert" in lr && (lr.inert = vr), kr && fr.tick && fr.tick(1, 0), dr && (gr && delete_rule(lr, gr), dr = !1);
    }
  };
}
function create_bidirectional_transition(lr, ar, cr, ur) {
  let dr = ar(lr, cr, { direction: "both" }), gr = ur ? 0 : 1, mr = null, vr = null, yr = null, kr;
  function _r() {
    yr && delete_rule(lr, yr);
  }
  function xr(Er, Cr) {
    const Tr = (
      /** @type {Program['d']} */
      Er.b - gr
    );
    return Cr *= Math.abs(Tr), {
      a: gr,
      b: Er.b,
      d: Tr,
      duration: Cr,
      start: Er.start,
      end: Er.start + Cr,
      group: Er.group
    };
  }
  function Sr(Er) {
    const {
      delay: Cr = 0,
      duration: Tr = 300,
      easing: Ar = identity,
      tick: Ir = noop$1,
      css: Mr
    } = dr || null_transition, Hr = {
      start: now() + Cr,
      b: Er
    };
    Er || (Hr.group = outros, outros.r += 1), "inert" in lr && (Er ? kr !== void 0 && (lr.inert = kr) : (kr = /** @type {HTMLElement} */
    lr.inert, lr.inert = !0)), mr || vr ? vr = Hr : (Mr && (_r(), yr = create_rule(lr, gr, Er, Tr, Cr, Ar, Mr)), Er && Ir(0, 1), mr = xr(Hr, Tr), add_render_callback(() => dispatch(lr, Er, "start")), loop((Br) => {
      if (vr && Br > vr.start && (mr = xr(vr, Tr), vr = null, dispatch(lr, mr.b, "start"), Mr && (_r(), yr = create_rule(
        lr,
        gr,
        mr.b,
        mr.duration,
        0,
        Ar,
        dr.css
      ))), mr) {
        if (Br >= mr.end)
          Ir(gr = mr.b, 1 - gr), dispatch(lr, mr.b, "end"), vr || (mr.b ? _r() : --mr.group.r || run_all(mr.group.c)), mr = null;
        else if (Br >= mr.start) {
          const zr = Br - mr.start;
          gr = mr.a + mr.d * Ar(zr / mr.duration), Ir(gr, 1 - gr);
        }
      }
      return !!(mr || vr);
    }));
  }
  return {
    run(Er) {
      is_function(dr) ? wait().then(() => {
        dr = dr({ direction: Er ? "in" : "out" }), Sr(Er);
      }) : Sr(Er);
    },
    end() {
      _r(), mr = vr = null;
    }
  };
}
function ensure_array_like(lr) {
  return (lr == null ? void 0 : lr.length) !== void 0 ? lr : Array.from(lr);
}
function outro_and_destroy_block(lr, ar) {
  transition_out(lr, 1, 1, () => {
    ar.delete(lr.key);
  });
}
function fix_and_outro_and_destroy_block(lr, ar) {
  lr.f(), outro_and_destroy_block(lr, ar);
}
function update_keyed_each(lr, ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r) {
  let xr = lr.length, Sr = dr.length, Er = xr;
  const Cr = {};
  for (; Er--; )
    Cr[lr[Er].key] = Er;
  const Tr = [], Ar = /* @__PURE__ */ new Map(), Ir = /* @__PURE__ */ new Map(), Mr = [];
  for (Er = Sr; Er--; ) {
    const Gr = _r(fr, dr, Er), Xr = cr(Gr);
    let Jr = gr.get(Xr);
    Jr ? ur && Mr.push(() => Jr.p(Gr, ar)) : (Jr = yr(Xr, Gr), Jr.c()), Ar.set(Xr, Tr[Er] = Jr), Xr in Cr && Ir.set(Xr, Math.abs(Er - Cr[Xr]));
  }
  const Hr = /* @__PURE__ */ new Set(), Br = /* @__PURE__ */ new Set();
  function zr(Gr) {
    transition_in(Gr, 1), Gr.m(mr, kr), gr.set(Gr.key, Gr), kr = Gr.first, Sr--;
  }
  for (; xr && Sr; ) {
    const Gr = Tr[Sr - 1], Xr = lr[xr - 1], Jr = Gr.key, li = Xr.key;
    Gr === Xr ? (kr = Gr.first, xr--, Sr--) : Ar.has(li) ? !gr.has(Jr) || Hr.has(Jr) ? zr(Gr) : Br.has(li) ? xr-- : Ir.get(Jr) > Ir.get(li) ? (Br.add(Jr), zr(Gr)) : (Hr.add(li), xr--) : (vr(Xr, gr), xr--);
  }
  for (; xr--; ) {
    const Gr = lr[xr];
    Ar.has(Gr.key) || vr(Gr, gr);
  }
  for (; Sr; )
    zr(Tr[Sr - 1]);
  return run_all(Mr), Tr;
}
function get_spread_update(lr, ar) {
  const cr = {}, ur = {}, fr = { $$scope: 1 };
  let dr = lr.length;
  for (; dr--; ) {
    const gr = lr[dr], mr = ar[dr];
    if (mr) {
      for (const vr in gr)
        vr in mr || (ur[vr] = 1);
      for (const vr in mr)
        fr[vr] || (cr[vr] = mr[vr], fr[vr] = 1);
      lr[dr] = mr;
    } else
      for (const vr in gr)
        fr[vr] = 1;
  }
  for (const gr in ur)
    gr in cr || (cr[gr] = void 0);
  return cr;
}
function get_spread_object(lr) {
  return typeof lr == "object" && lr !== null ? lr : {};
}
function bind(lr, ar, cr) {
  const ur = lr.$$.props[ar];
  ur !== void 0 && (lr.$$.bound[ur] = cr, cr(lr.$$.ctx[ur]));
}
function create_component(lr) {
  lr && lr.c();
}
function mount_component(lr, ar, cr) {
  const { fragment: ur, after_update: fr } = lr.$$;
  ur && ur.m(ar, cr), add_render_callback(() => {
    const dr = lr.$$.on_mount.map(run$1).filter(is_function);
    lr.$$.on_destroy ? lr.$$.on_destroy.push(...dr) : run_all(dr), lr.$$.on_mount = [];
  }), fr.forEach(add_render_callback);
}
function destroy_component(lr, ar) {
  const cr = lr.$$;
  cr.fragment !== null && (flush_render_callbacks(cr.after_update), run_all(cr.on_destroy), cr.fragment && cr.fragment.d(ar), cr.on_destroy = cr.fragment = null, cr.ctx = []);
}
function make_dirty(lr, ar) {
  lr.$$.dirty[0] === -1 && (dirty_components.push(lr), schedule_update(), lr.$$.dirty.fill(0)), lr.$$.dirty[ar / 31 | 0] |= 1 << ar % 31;
}
function init(lr, ar, cr, ur, fr, dr, gr = null, mr = [-1]) {
  const vr = current_component;
  set_current_component(lr);
  const yr = lr.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: dr,
    update: noop$1,
    not_equal: fr,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(ar.context || (vr ? vr.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: mr,
    skip_bound: !1,
    root: ar.target || vr.$$.root
  };
  gr && gr(yr.root);
  let kr = !1;
  if (yr.ctx = cr ? cr(lr, ar.props || {}, (_r, xr, ...Sr) => {
    const Er = Sr.length ? Sr[0] : xr;
    return yr.ctx && fr(yr.ctx[_r], yr.ctx[_r] = Er) && (!yr.skip_bound && yr.bound[_r] && yr.bound[_r](Er), kr && make_dirty(lr, _r)), xr;
  }) : [], yr.update(), kr = !0, run_all(yr.before_update), yr.fragment = ur ? ur(yr.ctx) : !1, ar.target) {
    if (ar.hydrate) {
      const _r = children(ar.target);
      yr.fragment && yr.fragment.l(_r), _r.forEach(detach);
    } else
      yr.fragment && yr.fragment.c();
    ar.intro && transition_in(lr.$$.fragment), mount_component(lr, ar.target, ar.anchor), flush();
  }
  set_current_component(vr);
}
let SvelteElement;
typeof HTMLElement == "function" && (SvelteElement = class extends HTMLElement {
  constructor(ar, cr, ur) {
    super();
    /** The Svelte component constructor */
    ji(this, "$$ctor");
    /** Slots */
    ji(this, "$$s");
    /** The Svelte component instance */
    ji(this, "$$c");
    /** Whether or not the custom element is connected */
    ji(this, "$$cn", !1);
    /** Component props data */
    ji(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    ji(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    ji(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    ji(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    ji(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = ar, this.$$s = cr, ur && this.attachShadow({ mode: "open" });
  }
  addEventListener(ar, cr, ur) {
    if (this.$$l[ar] = this.$$l[ar] || [], this.$$l[ar].push(cr), this.$$c) {
      const fr = this.$$c.$on(ar, cr);
      this.$$l_u.set(cr, fr);
    }
    super.addEventListener(ar, cr, ur);
  }
  removeEventListener(ar, cr, ur) {
    if (super.removeEventListener(ar, cr, ur), this.$$c) {
      const fr = this.$$l_u.get(cr);
      fr && (fr(), this.$$l_u.delete(cr));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let ar = function(dr) {
        return () => {
          let gr;
          return {
            c: function() {
              gr = element("slot"), dr !== "default" && attr(gr, "name", dr);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(yr, kr) {
              insert(yr, gr, kr);
            },
            d: function(yr) {
              yr && detach(gr);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn)
        return;
      const cr = {}, ur = get_custom_elements_slots(this);
      for (const dr of this.$$s)
        dr in ur && (cr[dr] = [ar(dr)]);
      for (const dr of this.attributes) {
        const gr = this.$$g_p(dr.name);
        gr in this.$$d || (this.$$d[gr] = get_custom_element_value(gr, dr.value, this.$$p_d, "toProp"));
      }
      for (const dr in this.$$p_d)
        !(dr in this.$$d) && this[dr] !== void 0 && (this.$$d[dr] = this[dr], delete this[dr]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: cr,
          $$scope: {
            ctx: []
          }
        }
      });
      const fr = () => {
        this.$$r = !0;
        for (const dr in this.$$p_d)
          if (this.$$d[dr] = this.$$c.$$.ctx[this.$$c.$$.props[dr]], this.$$p_d[dr].reflect) {
            const gr = get_custom_element_value(
              dr,
              this.$$d[dr],
              this.$$p_d,
              "toAttribute"
            );
            gr == null ? this.removeAttribute(this.$$p_d[dr].attribute || dr) : this.setAttribute(this.$$p_d[dr].attribute || dr, gr);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(fr), fr();
      for (const dr in this.$$l)
        for (const gr of this.$$l[dr]) {
          const mr = this.$$c.$on(dr, gr);
          this.$$l_u.set(gr, mr);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(ar, cr, ur) {
    var fr;
    this.$$r || (ar = this.$$g_p(ar), this.$$d[ar] = get_custom_element_value(ar, ur, this.$$p_d, "toProp"), (fr = this.$$c) == null || fr.$set({ [ar]: this.$$d[ar] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(ar) {
    return Object.keys(this.$$p_d).find(
      (cr) => this.$$p_d[cr].attribute === ar || !this.$$p_d[cr].attribute && cr.toLowerCase() === ar
    ) || ar;
  }
});
function get_custom_element_value(lr, ar, cr, ur) {
  var dr;
  const fr = (dr = cr[lr]) == null ? void 0 : dr.type;
  if (ar = fr === "Boolean" && typeof ar != "boolean" ? ar != null : ar, !ur || !cr[lr])
    return ar;
  if (ur === "toAttribute")
    switch (fr) {
      case "Object":
      case "Array":
        return ar == null ? null : JSON.stringify(ar);
      case "Boolean":
        return ar ? "" : null;
      case "Number":
        return ar == null ? null : ar;
      default:
        return ar;
    }
  else
    switch (fr) {
      case "Object":
      case "Array":
        return ar && JSON.parse(ar);
      case "Boolean":
        return ar;
      case "Number":
        return ar != null ? +ar : ar;
      default:
        return ar;
    }
}
function create_custom_element(lr, ar, cr, ur, fr, dr) {
  let gr = class extends SvelteElement {
    constructor() {
      super(lr, cr, fr), this.$$p_d = ar;
    }
    static get observedAttributes() {
      return Object.keys(ar).map(
        (mr) => (ar[mr].attribute || mr).toLowerCase()
      );
    }
  };
  return Object.keys(ar).forEach((mr) => {
    Object.defineProperty(gr.prototype, mr, {
      get() {
        return this.$$c && mr in this.$$c ? this.$$c[mr] : this.$$d[mr];
      },
      set(vr) {
        var yr;
        vr = get_custom_element_value(mr, vr, ar), this.$$d[mr] = vr, (yr = this.$$c) == null || yr.$set({ [mr]: vr });
      }
    });
  }), ur.forEach((mr) => {
    Object.defineProperty(gr.prototype, mr, {
      get() {
        var vr;
        return (vr = this.$$c) == null ? void 0 : vr[mr];
      }
    });
  }), dr && (gr = dr(gr)), lr.element = /** @type {any} */
  gr, gr;
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    ji(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    ji(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(ar, cr) {
    if (!is_function(cr))
      return noop$1;
    const ur = this.$$.callbacks[ar] || (this.$$.callbacks[ar] = []);
    return ur.push(cr), () => {
      const fr = ur.indexOf(cr);
      fr !== -1 && ur.splice(fr, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(ar) {
    this.$$set && !is_empty(ar) && (this.$$.skip_bound = !0, this.$$set(ar), this.$$.skip_bound = !1);
  }
}
const PUBLIC_VERSION = "4";
typeof window != "undefined" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function readable(lr, ar) {
  return {
    subscribe: writable(lr, ar).subscribe
  };
}
function writable(lr, ar = noop$1) {
  let cr;
  const ur = /* @__PURE__ */ new Set();
  function fr(mr) {
    if (safe_not_equal(lr, mr) && (lr = mr, cr)) {
      const vr = !subscriber_queue.length;
      for (const yr of ur)
        yr[1](), subscriber_queue.push(yr, lr);
      if (vr) {
        for (let yr = 0; yr < subscriber_queue.length; yr += 2)
          subscriber_queue[yr][0](subscriber_queue[yr + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function dr(mr) {
    fr(mr(lr));
  }
  function gr(mr, vr = noop$1) {
    const yr = [mr, vr];
    return ur.add(yr), ur.size === 1 && (cr = ar(fr, dr) || noop$1), mr(lr), () => {
      ur.delete(yr), ur.size === 0 && cr && (cr(), cr = null);
    };
  }
  return { set: fr, update: dr, subscribe: gr };
}
const storeHighlightJs = writable(void 0), tocStore = writable([]), tocActiveId = writable(void 0), DRAWER_STORE_KEY = "drawerStore";
function getDrawerStore() {
  const lr = getContext(DRAWER_STORE_KEY);
  if (!lr)
    throw new Error("drawerStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const MODAL_STORE_KEY = "modalStore";
function getModalStore() {
  const lr = getContext(MODAL_STORE_KEY);
  if (!lr)
    throw new Error("modalStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const TOAST_STORE_KEY = "toastStore";
function getToastStore() {
  const lr = getContext(TOAST_STORE_KEY);
  if (!lr)
    throw new Error("toastStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return lr;
}
const stores = {};
function getStorage(lr) {
  return lr === "local" ? localStorage : sessionStorage;
}
function localStorageStore(lr, ar, cr) {
  var gr, mr;
  const ur = (gr = cr == null ? void 0 : cr.serializer) != null ? gr : JSON, fr = (mr = cr == null ? void 0 : cr.storage) != null ? mr : "local";
  function dr(vr, yr) {
    getStorage(fr).setItem(vr, ur.stringify(yr));
  }
  if (!stores[lr]) {
    const vr = writable(ar, (_r) => {
      const xr = getStorage(fr).getItem(lr);
      xr && _r(ur.parse(xr));
      {
        const Sr = (Er) => {
          Er.key === lr && _r(Er.newValue ? ur.parse(Er.newValue) : null);
        };
        return window.addEventListener("storage", Sr), () => window.removeEventListener("storage", Sr);
      }
    }), { subscribe: yr, set: kr } = vr;
    stores[lr] = {
      set(_r) {
        dr(lr, _r), kr(_r);
      },
      update(_r) {
        const xr = _r(get_store_value(vr));
        dr(lr, xr), kr(xr);
      },
      subscribe: yr
    };
  }
  return stores[lr];
}
const modeOsPrefers = localStorageStore("modeOsPrefers", !1), modeUserPrefers = localStorageStore("modeUserPrefers", void 0), modeCurrent = localStorageStore("modeCurrent", !1);
function getModeOsPrefers() {
  const lr = window.matchMedia("(prefers-color-scheme: light)").matches;
  return modeOsPrefers.set(lr), lr;
}
function setModeUserPrefers(lr) {
  modeUserPrefers.set(lr);
}
function setModeCurrent(lr) {
  const ar = document.documentElement.classList, cr = "dark";
  lr === !0 ? ar.remove(cr) : ar.add(cr), modeCurrent.set(lr);
}
function setInitialClassState() {
  const lr = document.documentElement.classList, ar = localStorage.getItem("modeUserPrefers") === "false", cr = !("modeUserPrefers" in localStorage), ur = window.matchMedia("(prefers-color-scheme: dark)").matches;
  ar || cr && ur ? lr.add("dark") : lr.remove("dark");
}
const reducedMotionQuery = "(prefers-reduced-motion: reduce)";
function prefersReducedMotion() {
  return window.matchMedia(reducedMotionQuery).matches;
}
const prefersReducedMotionStore = readable(prefersReducedMotion(), (lr) => {
  {
    const ar = (ur) => {
      lr(ur.matches);
    }, cr = window.matchMedia(reducedMotionQuery);
    return cr.addEventListener("change", ar), () => {
      cr.removeEventListener("change", ar);
    };
  }
});
function clipboard(lr, ar) {
  if (!window.isSecureContext) {
    console.error("Clipboard action failed: app not running in secure context, see: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard");
    return;
  }
  const cr = () => {
    lr.dispatchEvent(new CustomEvent("copyComplete"));
  }, ur = () => {
    if (typeof ar == "object") {
      if ("element" in ar) {
        const fr = document.querySelector(`[data-clipboard="${ar.element}"]`);
        if (!fr)
          throw new Error(`Missing HTMLElement with an attribute of [data-clipboard="${ar.element}"]`);
        copyToClipboard(fr.innerHTML, "text/html").then(cr);
        return;
      }
      if ("input" in ar) {
        const fr = document.querySelector(`[data-clipboard="${ar.input}"]`);
        if (!fr)
          throw new Error(`Missing HTMLInputElement with an attribute of [data-clipboard="${ar.input}"]`);
        copyToClipboard(fr.value).then(cr);
        return;
      }
    }
    copyToClipboard(ar).then(cr);
  };
  return lr.addEventListener("click", ur), {
    update(fr) {
      ar = fr;
    },
    destroy() {
      lr.removeEventListener("click", ur);
    }
  };
}
async function copyToClipboard(lr, ar = "text/plain") {
  navigator.clipboard.write ? await navigator.clipboard.write([
    new ClipboardItem({
      [ar]: new Blob([lr], {
        type: ar
      }),
      "text/plain": new Blob([lr], {
        type: "text/plain"
      })
    })
  ]) : await new Promise((cr) => {
    cr(navigator.clipboard.writeText(String(lr)));
  });
}
function focusTrap(lr, ar) {
  const cr = 'a[href]:not([tabindex="-1"]), button:not([tabindex="-1"]), input:not([tabindex="-1"]), textarea:not([tabindex="-1"]), select:not([tabindex="-1"]), details:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])';
  let ur, fr;
  function dr(_r) {
    _r.shiftKey && _r.code === "Tab" && (_r.preventDefault(), fr.focus());
  }
  function gr(_r) {
    !_r.shiftKey && _r.code === "Tab" && (_r.preventDefault(), ur.focus());
  }
  const mr = (_r) => {
    if (ar === !1)
      return;
    const xr = Array.from(lr.querySelectorAll(cr));
    xr.length && (ur = xr[0], fr = xr[xr.length - 1], _r || ur.focus(), ur.addEventListener("keydown", dr), fr.addEventListener("keydown", gr));
  };
  mr(!1);
  function vr() {
    ur && ur.removeEventListener("keydown", dr), fr && fr.removeEventListener("keydown", gr);
  }
  const yr = (_r, xr) => (_r.length && (vr(), mr(!0)), xr), kr = new MutationObserver(yr);
  return kr.observe(lr, { childList: !0, subtree: !0 }), {
    update(_r) {
      ar = _r, _r ? mr(!1) : vr();
    },
    destroy() {
      vr(), kr.disconnect();
    }
  };
}
function cubicIn(lr) {
  return lr * lr * lr;
}
function cubicOut(lr) {
  const ar = lr - 1;
  return ar * ar * ar + 1;
}
function fade(lr, { delay: ar = 0, duration: cr = 400, easing: ur = identity } = {}) {
  const fr = +getComputedStyle(lr).opacity;
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (dr) => `opacity: ${dr * fr}`
  };
}
function fly(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, x: fr = 0, y: dr = 0, opacity: gr = 0 } = {}) {
  const mr = getComputedStyle(lr), vr = +mr.opacity, yr = mr.transform === "none" ? "" : mr.transform, kr = vr * (1 - gr), [_r, xr] = split_css_unit(fr), [Sr, Er] = split_css_unit(dr);
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (Cr, Tr) => `
			transform: ${yr} translate(${(1 - Cr) * _r}${xr}, ${(1 - Cr) * Sr}${Er});
			opacity: ${vr - kr * Tr}`
  };
}
function slide(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, axis: fr = "y" } = {}) {
  const dr = getComputedStyle(lr), gr = +dr.opacity, mr = fr === "y" ? "height" : "width", vr = parseFloat(dr[mr]), yr = fr === "y" ? ["top", "bottom"] : ["left", "right"], kr = yr.map(
    (Ar) => `${Ar[0].toUpperCase()}${Ar.slice(1)}`
  ), _r = parseFloat(dr[`padding${kr[0]}`]), xr = parseFloat(dr[`padding${kr[1]}`]), Sr = parseFloat(dr[`margin${kr[0]}`]), Er = parseFloat(dr[`margin${kr[1]}`]), Cr = parseFloat(
    dr[`border${kr[0]}Width`]
  ), Tr = parseFloat(
    dr[`border${kr[1]}Width`]
  );
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (Ar) => `overflow: hidden;opacity: ${Math.min(Ar * 20, 1) * gr};${mr}: ${Ar * vr}px;padding-${yr[0]}: ${Ar * _r}px;padding-${yr[1]}: ${Ar * xr}px;margin-${yr[0]}: ${Ar * Sr}px;margin-${yr[1]}: ${Ar * Er}px;border-${yr[0]}-width: ${Ar * Cr}px;border-${yr[1]}-width: ${Ar * Tr}px;`
  };
}
function scale(lr, { delay: ar = 0, duration: cr = 400, easing: ur = cubicOut, start: fr = 0, opacity: dr = 0 } = {}) {
  const gr = getComputedStyle(lr), mr = +gr.opacity, vr = gr.transform === "none" ? "" : gr.transform, yr = 1 - fr, kr = mr * (1 - dr);
  return {
    delay: ar,
    duration: cr,
    easing: ur,
    css: (_r, xr) => `
			transform: ${vr} scale(${1 - yr * xr});
			opacity: ${mr - kr * xr}
		`
  };
}
function create_fragment$17(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "accordion " + /*classesBase*/
      lr[0]), attr(ar, "data-testid", "accordion");
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[18],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      1 && cr !== (cr = "accordion " + /*classesBase*/
      gr[0])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function instance$O(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, prefersReducedMotionStore, (Jr) => cr(20, fr = Jr));
  let { $$slots: dr = {}, $$scope: gr } = ar, { autocollapse: mr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: yr = "space-y-1" } = ar, { disabled: kr = !1 } = ar, { padding: _r = "py-2 px-4" } = ar, { hover: xr = "hover:bg-primary-hover-token" } = ar, { rounded: Sr = "rounded-container-token" } = ar, { caretOpen: Er = "rotate-180" } = ar, { caretClosed: Cr = "" } = ar, { regionControl: Tr = "" } = ar, { regionPanel: Ar = "space-y-4" } = ar, { regionCaret: Ir = "" } = ar, { transitions: Mr = !fr } = ar, { transitionIn: Hr = slide } = ar, { transitionInParams: Br = { duration: 200 } } = ar, { transitionOut: zr = slide } = ar, { transitionOutParams: Gr = { duration: 200 } } = ar;
  const Xr = writable(null);
  return setContext("active", Xr), setContext("autocollapse", mr), setContext("disabled", kr), setContext("padding", _r), setContext("hover", xr), setContext("rounded", Sr), setContext("caretOpen", Er), setContext("caretClosed", Cr), setContext("regionControl", Tr), setContext("regionPanel", Ar), setContext("regionCaret", Ir), setContext("transitions", Mr), setContext("transitionIn", Hr), setContext("transitionInParams", Br), setContext("transitionOut", zr), setContext("transitionOutParams", Gr), lr.$$set = (Jr) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Jr))), "autocollapse" in Jr && cr(1, mr = Jr.autocollapse), "width" in Jr && cr(2, vr = Jr.width), "spacing" in Jr && cr(3, yr = Jr.spacing), "disabled" in Jr && cr(4, kr = Jr.disabled), "padding" in Jr && cr(5, _r = Jr.padding), "hover" in Jr && cr(6, xr = Jr.hover), "rounded" in Jr && cr(7, Sr = Jr.rounded), "caretOpen" in Jr && cr(8, Er = Jr.caretOpen), "caretClosed" in Jr && cr(9, Cr = Jr.caretClosed), "regionControl" in Jr && cr(10, Tr = Jr.regionControl), "regionPanel" in Jr && cr(11, Ar = Jr.regionPanel), "regionCaret" in Jr && cr(12, Ir = Jr.regionCaret), "transitions" in Jr && cr(13, Mr = Jr.transitions), "transitionIn" in Jr && cr(14, Hr = Jr.transitionIn), "transitionInParams" in Jr && cr(15, Br = Jr.transitionInParams), "transitionOut" in Jr && cr(16, zr = Jr.transitionOut), "transitionOutParams" in Jr && cr(17, Gr = Jr.transitionOutParams), "$$scope" in Jr && cr(18, gr = Jr.$$scope);
  }, lr.$$.update = () => {
    var Jr;
    cr(0, ur = `${vr} ${yr} ${(Jr = ar.class) != null ? Jr : ""}`);
  }, ar = exclude_internal_props(ar), [
    ur,
    mr,
    vr,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    gr,
    dr
  ];
}
class Accordion extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$O, create_fragment$17, safe_not_equal, {
      autocollapse: 1,
      width: 2,
      spacing: 3,
      disabled: 4,
      padding: 5,
      hover: 6,
      rounded: 7,
      caretOpen: 8,
      caretClosed: 9,
      regionControl: 10,
      regionPanel: 11,
      regionCaret: 12,
      transitions: 13,
      transitionIn: 14,
      transitionInParams: 15,
      transitionOut: 16,
      transitionOutParams: 17
    });
  }
  get autocollapse() {
    return this.$$.ctx[1];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get width() {
    return this.$$.ctx[2];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[4];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[5];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[7];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[8];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[9];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[10];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[11];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[12];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[13];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[14];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[15];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[16];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[17];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Accordion, { autocollapse: { type: "Boolean" }, width: {}, spacing: {}, disabled: { type: "Boolean" }, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
function dynamicTransition(lr, ar) {
  const { transition: cr, params: ur, enabled: fr } = ar;
  return fr ? cr(lr, ur) : "duration" in ur ? cr(lr, { duration: 0 }) : { duration: 0 };
}
const get_content_slot_changes = (lr) => ({}), get_content_slot_context = (lr) => ({}), get_summary_slot_changes = (lr) => ({}), get_summary_slot_context = (lr) => ({}), get_lead_slot_changes$9 = (lr) => ({}), get_lead_slot_context$9 = (lr) => ({});
function create_if_block_1$h(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[28].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[27],
    get_lead_slot_context$9
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "accordion-lead");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr[0] & /*$$scope*/
      134217728) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[27],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[27],
          gr,
          get_lead_slot_changes$9
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[27]
        ),
        get_lead_slot_context$9
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function fallback_block_1$2(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(summary)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block$y(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  const yr = (
    /*#slots*/
    lr[28].content
  ), kr = create_slot(
    yr,
    lr,
    /*$$scope*/
    lr[27],
    get_content_slot_context
  ), _r = kr || fallback_block$5();
  return {
    c() {
      ar = element("div"), _r && _r.c(), attr(ar, "class", cr = "accordion-panel " + /*classesPanel*/
      lr[9]), attr(ar, "id", ur = "accordion-panel-" + /*id*/
      lr[0]), attr(ar, "role", "region"), attr(ar, "aria-hidden", fr = !/*openState*/
      lr[8]), attr(ar, "aria-labelledby", dr = "accordion-control-" + /*id*/
      lr[0]);
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), _r && _r.m(ar, null), vr = !0;
    },
    p(xr, Sr) {
      lr = xr, kr && kr.p && (!vr || Sr[0] & /*$$scope*/
      134217728) && update_slot_base(
        kr,
        yr,
        lr,
        /*$$scope*/
        lr[27],
        vr ? get_slot_changes(
          yr,
          /*$$scope*/
          lr[27],
          Sr,
          get_content_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          lr[27]
        ),
        get_content_slot_context
      ), (!vr || Sr[0] & /*classesPanel*/
      512 && cr !== (cr = "accordion-panel " + /*classesPanel*/
      lr[9])) && attr(ar, "class", cr), (!vr || Sr[0] & /*id*/
      1 && ur !== (ur = "accordion-panel-" + /*id*/
      lr[0])) && attr(ar, "id", ur), (!vr || Sr[0] & /*openState*/
      256 && fr !== (fr = !/*openState*/
      lr[8])) && attr(ar, "aria-hidden", fr), (!vr || Sr[0] & /*id*/
      1 && dr !== (dr = "accordion-control-" + /*id*/
      lr[0])) && attr(ar, "aria-labelledby", dr);
    },
    i(xr) {
      vr || (transition_in(_r, xr), xr && add_render_callback(() => {
        vr && (mr && mr.end(1), gr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[4]
          ),
          params: (
            /*transitionInParams*/
            lr[5]
          ),
          enabled: (
            /*transitions*/
            lr[3]
          )
        }), gr.start());
      }), vr = !0);
    },
    o(xr) {
      transition_out(_r, xr), gr && gr.invalidate(), xr && (mr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[6]
        ),
        params: (
          /*transitionOutParams*/
          lr[7]
        ),
        enabled: (
          /*transitions*/
          lr[3]
        )
      })), vr = !1;
    },
    d(xr) {
      xr && detach(ar), _r && _r.d(xr), xr && mr && mr.end();
    }
  };
}
function fallback_block$5(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(content)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_fragment$16(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir = (
    /*$$slots*/
    lr[14].lead && create_if_block_1$h(lr)
  );
  const Mr = (
    /*#slots*/
    lr[28].summary
  ), Hr = create_slot(
    Mr,
    lr,
    /*$$scope*/
    lr[27],
    get_summary_slot_context
  ), Br = Hr || fallback_block_1$2();
  let zr = (
    /*openState*/
    lr[8] && create_if_block$y(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("button"), Ir && Ir.c(), ur = space(), fr = element("div"), Br && Br.c(), dr = space(), gr = element("div"), mr = svg_element("svg"), vr = svg_element("path"), Sr = space(), zr && zr.c(), attr(fr, "class", "accordion-summary flex-1"), attr(vr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(mr, "xmlns", "http://www.w3.org/2000/svg"), attr(mr, "viewBox", "0 0 448 512"), attr(gr, "class", yr = "accordion-summary-caret " + /*classesControlCaret*/
      lr[10]), attr(cr, "type", "button"), attr(cr, "class", kr = "accordion-control " + /*classesControl*/
      lr[11]), attr(cr, "id", _r = "accordion-control-" + /*id*/
      lr[0]), attr(
        cr,
        "aria-expanded",
        /*openState*/
        lr[8]
      ), attr(cr, "aria-controls", xr = "accordion-panel-" + /*id*/
      lr[0]), cr.disabled = /*disabled*/
      lr[2], attr(ar, "class", Er = "accordion-item " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "accordion-item");
    },
    m(Gr, Xr) {
      insert(Gr, ar, Xr), append(ar, cr), Ir && Ir.m(cr, null), append(cr, ur), append(cr, fr), Br && Br.m(fr, null), append(cr, dr), append(cr, gr), append(gr, mr), append(mr, vr), append(ar, Sr), zr && zr.m(ar, null), Cr = !0, Tr || (Ar = [
        listen(
          cr,
          "click",
          /*setActive*/
          lr[13]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[29]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[30]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[31]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[32]
        )
      ], Tr = !0);
    },
    p(Gr, Xr) {
      /*$$slots*/
      Gr[14].lead ? Ir ? (Ir.p(Gr, Xr), Xr[0] & /*$$slots*/
      16384 && transition_in(Ir, 1)) : (Ir = create_if_block_1$h(Gr), Ir.c(), transition_in(Ir, 1), Ir.m(cr, ur)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Hr && Hr.p && (!Cr || Xr[0] & /*$$scope*/
      134217728) && update_slot_base(
        Hr,
        Mr,
        Gr,
        /*$$scope*/
        Gr[27],
        Cr ? get_slot_changes(
          Mr,
          /*$$scope*/
          Gr[27],
          Xr,
          get_summary_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Gr[27]
        ),
        get_summary_slot_context
      ), (!Cr || Xr[0] & /*classesControlCaret*/
      1024 && yr !== (yr = "accordion-summary-caret " + /*classesControlCaret*/
      Gr[10])) && attr(gr, "class", yr), (!Cr || Xr[0] & /*classesControl*/
      2048 && kr !== (kr = "accordion-control " + /*classesControl*/
      Gr[11])) && attr(cr, "class", kr), (!Cr || Xr[0] & /*id*/
      1 && _r !== (_r = "accordion-control-" + /*id*/
      Gr[0])) && attr(cr, "id", _r), (!Cr || Xr[0] & /*openState*/
      256) && attr(
        cr,
        "aria-expanded",
        /*openState*/
        Gr[8]
      ), (!Cr || Xr[0] & /*id*/
      1 && xr !== (xr = "accordion-panel-" + /*id*/
      Gr[0])) && attr(cr, "aria-controls", xr), (!Cr || Xr[0] & /*disabled*/
      4) && (cr.disabled = /*disabled*/
      Gr[2]), /*openState*/
      Gr[8] ? zr ? (zr.p(Gr, Xr), Xr[0] & /*openState*/
      256 && transition_in(zr, 1)) : (zr = create_if_block$y(Gr), zr.c(), transition_in(zr, 1), zr.m(ar, null)) : zr && (group_outros(), transition_out(zr, 1, 1, () => {
        zr = null;
      }), check_outros()), (!Cr || Xr[0] & /*classesBase*/
      4096 && Er !== (Er = "accordion-item " + /*classesBase*/
      Gr[12])) && attr(ar, "class", Er);
    },
    i(Gr) {
      Cr || (transition_in(Ir), transition_in(Br, Gr), transition_in(zr), Cr = !0);
    },
    o(Gr) {
      transition_out(Ir), transition_out(Br, Gr), transition_out(zr), Cr = !1;
    },
    d(Gr) {
      Gr && detach(ar), Ir && Ir.d(), Br && Br.d(Gr), zr && zr.d(), Tr = !1, run_all(Ar);
    }
  };
}
const cBase$p = "", cControl = "text-start w-full flex items-center space-x-4", cControlCaret = "fill-current w-3 transition-transform duration-[200ms]", cPanel$1 = "";
function instance$N(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr = noop$1, _r = () => (kr(), kr = subscribe(Mr, (ki) => cr(26, yr = ki)), Mr);
  lr.$$.on_destroy.push(() => kr());
  let { $$slots: xr = {}, $$scope: Sr } = ar;
  const Er = compute_slots(xr), Cr = createEventDispatcher();
  let { open: Tr = !1 } = ar, { id: Ar = String(Math.random()) } = ar, { autocollapse: Ir = getContext("autocollapse") } = ar, { active: Mr = getContext("active") } = ar;
  _r();
  let { disabled: Hr = getContext("disabled") } = ar, { padding: Br = getContext("padding") } = ar, { hover: zr = getContext("hover") } = ar, { rounded: Gr = getContext("rounded") } = ar, { caretOpen: Xr = getContext("caretOpen") } = ar, { caretClosed: Jr = getContext("caretClosed") } = ar, { regionControl: li = getContext("regionControl") } = ar, { regionPanel: Qr = getContext("regionPanel") } = ar, { regionCaret: ei = getContext("regionCaret") } = ar, { transitions: ui = getContext("transitions") } = ar, { transitionIn: Ai = getContext("transitionIn") } = ar, { transitionInParams: fi = getContext("transitionInParams") } = ar, { transitionOut: gi = getContext("transitionOut") } = ar, { transitionOutParams: Ci = getContext("transitionOutParams") } = ar;
  function mi(ki) {
    Ir === !0 ? Mr.set(Ar) : cr(15, Tr = !Tr), vi(ki);
  }
  function vi(ki) {
    const Ji = Ir ? yr === Ar : Tr;
    Cr("toggle", {
      event: ki,
      id: `accordion-control-${Ar}`,
      open: Ji,
      autocollapse: Ir
    });
  }
  Ir && Tr && mi();
  function Ri(ki) {
    bubble.call(this, lr, ki);
  }
  function di(ki) {
    bubble.call(this, lr, ki);
  }
  function Ti(ki) {
    bubble.call(this, lr, ki);
  }
  function qi(ki) {
    bubble.call(this, lr, ki);
  }
  return lr.$$set = (ki) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(ki))), "open" in ki && cr(15, Tr = ki.open), "id" in ki && cr(0, Ar = ki.id), "autocollapse" in ki && cr(16, Ir = ki.autocollapse), "active" in ki && _r(cr(1, Mr = ki.active)), "disabled" in ki && cr(2, Hr = ki.disabled), "padding" in ki && cr(17, Br = ki.padding), "hover" in ki && cr(18, zr = ki.hover), "rounded" in ki && cr(19, Gr = ki.rounded), "caretOpen" in ki && cr(20, Xr = ki.caretOpen), "caretClosed" in ki && cr(21, Jr = ki.caretClosed), "regionControl" in ki && cr(22, li = ki.regionControl), "regionPanel" in ki && cr(23, Qr = ki.regionPanel), "regionCaret" in ki && cr(24, ei = ki.regionCaret), "transitions" in ki && cr(3, ui = ki.transitions), "transitionIn" in ki && cr(4, Ai = ki.transitionIn), "transitionInParams" in ki && cr(5, fi = ki.transitionInParams), "transitionOut" in ki && cr(6, gi = ki.transitionOut), "transitionOutParams" in ki && cr(7, Ci = ki.transitionOutParams), "$$scope" in ki && cr(27, Sr = ki.$$scope);
  }, lr.$$.update = () => {
    var ki;
    lr.$$.dirty[0] & /*open, autocollapse*/
    98304 && Tr && Ir && mi(), lr.$$.dirty[0] & /*autocollapse, $active, id, open*/
    67207169 && cr(8, ur = Ir ? yr === Ar : Tr), cr(12, fr = `${cBase$p} ${(ki = ar.class) != null ? ki : ""}`), lr.$$.dirty[0] & /*padding, hover, rounded, regionControl*/
    5111808 && cr(11, dr = `${cControl} ${Br} ${zr} ${Gr} ${li}`), lr.$$.dirty[0] & /*openState, caretOpen, caretClosed*/
    3145984 && cr(25, gr = ur ? Xr : Jr), lr.$$.dirty[0] & /*regionCaret, classesCaretState*/
    50331648 && cr(10, mr = `${cControlCaret} ${ei} ${gr}`), lr.$$.dirty[0] & /*padding, rounded, regionPanel*/
    9043968 && cr(9, vr = `${cPanel$1} ${Br} ${Gr} ${Qr}`);
  }, ar = exclude_internal_props(ar), [
    Ar,
    Mr,
    Hr,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    ur,
    vr,
    mr,
    dr,
    fr,
    mi,
    Er,
    Tr,
    Ir,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    gr,
    yr,
    Sr,
    xr,
    Ri,
    di,
    Ti,
    qi
  ];
}
class AccordionItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$N,
      create_fragment$16,
      safe_not_equal,
      {
        open: 15,
        id: 0,
        autocollapse: 16,
        active: 1,
        disabled: 2,
        padding: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        regionControl: 22,
        regionPanel: 23,
        regionCaret: 24,
        transitions: 3,
        transitionIn: 4,
        transitionInParams: 5,
        transitionOut: 6,
        transitionOutParams: 7
      },
      null,
      [-1, -1]
    );
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get autocollapse() {
    return this.$$.ctx[16];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[2];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[22];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[23];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[24];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[3];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[4];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[5];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[6];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[7];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(AccordionItem, { open: { type: "Boolean" }, id: {}, autocollapse: {}, active: {}, disabled: {}, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["lead", "summary", "content"], [], !0);
const get_headline_slot_changes = (lr) => ({}), get_headline_slot_context = (lr) => ({}), get_trail_slot_changes$3 = (lr) => ({}), get_trail_slot_context$3 = (lr) => ({}), get_lead_slot_changes$8 = (lr) => ({}), get_lead_slot_context$8 = (lr) => ({});
function create_if_block_2$d(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_lead_slot_context$8
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-slot-lead " + /*classesSlotLead*/
      lr[4]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[21],
          mr,
          get_lead_slot_changes$8
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_lead_slot_context$8
      ), (!ur || mr & /*classesSlotLead*/
      16 && cr !== (cr = "app-bar-slot-lead " + /*classesSlotLead*/
      gr[4])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_if_block_1$g(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].trail
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_trail_slot_context$3
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-slot-trail " + /*classesSlotTrail*/
      lr[2]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[21],
          mr,
          get_trail_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_trail_slot_context$3
      ), (!ur || mr & /*classesSlotTrail*/
      4 && cr !== (cr = "app-bar-slot-trail " + /*classesSlotTrail*/
      gr[2])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_if_block$x(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].headline
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    get_headline_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-bar-row-headline " + /*classesRowHeadline*/
      lr[5]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[21],
          mr,
          get_headline_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_headline_slot_context
      ), (!ur || mr & /*classesRowHeadline*/
      32 && cr !== (cr = "app-bar-row-headline " + /*classesRowHeadline*/
      gr[5])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$15(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r = (
    /*$$slots*/
    lr[8].lead && create_if_block_2$d(lr)
  );
  const xr = (
    /*#slots*/
    lr[22].default
  ), Sr = create_slot(
    xr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  let Er = (
    /*$$slots*/
    lr[8].trail && create_if_block_1$g(lr)
  ), Cr = (
    /*$$slots*/
    lr[8].headline && create_if_block$x(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), _r && _r.c(), ur = space(), fr = element("div"), Sr && Sr.c(), gr = space(), Er && Er.c(), vr = space(), Cr && Cr.c(), attr(fr, "class", dr = "app-bar-slot-default " + /*classesSlotDefault*/
      lr[3]), attr(cr, "class", mr = "app-bar-row-main " + /*classesRowMain*/
      lr[6]), attr(ar, "class", yr = "app-bar " + /*classesBase*/
      lr[7]), attr(ar, "data-testid", "app-bar"), attr(ar, "role", "toolbar"), attr(
        ar,
        "aria-label",
        /*label*/
        lr[0]
      ), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[1]
      );
    },
    m(Tr, Ar) {
      insert(Tr, ar, Ar), append(ar, cr), _r && _r.m(cr, null), append(cr, ur), append(cr, fr), Sr && Sr.m(fr, null), append(cr, gr), Er && Er.m(cr, null), append(ar, vr), Cr && Cr.m(ar, null), kr = !0;
    },
    p(Tr, [Ar]) {
      /*$$slots*/
      Tr[8].lead ? _r ? (_r.p(Tr, Ar), Ar & /*$$slots*/
      256 && transition_in(_r, 1)) : (_r = create_if_block_2$d(Tr), _r.c(), transition_in(_r, 1), _r.m(cr, ur)) : _r && (group_outros(), transition_out(_r, 1, 1, () => {
        _r = null;
      }), check_outros()), Sr && Sr.p && (!kr || Ar & /*$$scope*/
      2097152) && update_slot_base(
        Sr,
        xr,
        Tr,
        /*$$scope*/
        Tr[21],
        kr ? get_slot_changes(
          xr,
          /*$$scope*/
          Tr[21],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[21]
        ),
        null
      ), (!kr || Ar & /*classesSlotDefault*/
      8 && dr !== (dr = "app-bar-slot-default " + /*classesSlotDefault*/
      Tr[3])) && attr(fr, "class", dr), /*$$slots*/
      Tr[8].trail ? Er ? (Er.p(Tr, Ar), Ar & /*$$slots*/
      256 && transition_in(Er, 1)) : (Er = create_if_block_1$g(Tr), Er.c(), transition_in(Er, 1), Er.m(cr, null)) : Er && (group_outros(), transition_out(Er, 1, 1, () => {
        Er = null;
      }), check_outros()), (!kr || Ar & /*classesRowMain*/
      64 && mr !== (mr = "app-bar-row-main " + /*classesRowMain*/
      Tr[6])) && attr(cr, "class", mr), /*$$slots*/
      Tr[8].headline ? Cr ? (Cr.p(Tr, Ar), Ar & /*$$slots*/
      256 && transition_in(Cr, 1)) : (Cr = create_if_block$x(Tr), Cr.c(), transition_in(Cr, 1), Cr.m(ar, null)) : Cr && (group_outros(), transition_out(Cr, 1, 1, () => {
        Cr = null;
      }), check_outros()), (!kr || Ar & /*classesBase*/
      128 && yr !== (yr = "app-bar " + /*classesBase*/
      Tr[7])) && attr(ar, "class", yr), (!kr || Ar & /*label*/
      1) && attr(
        ar,
        "aria-label",
        /*label*/
        Tr[0]
      ), (!kr || Ar & /*labelledby*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        Tr[1]
      );
    },
    i(Tr) {
      kr || (transition_in(_r), transition_in(Sr, Tr), transition_in(Er), transition_in(Cr), kr = !0);
    },
    o(Tr) {
      transition_out(_r), transition_out(Sr, Tr), transition_out(Er), transition_out(Cr), kr = !1;
    },
    d(Tr) {
      Tr && detach(ar), _r && _r.d(), Sr && Sr.d(Tr), Er && Er.d(), Cr && Cr.d();
    }
  };
}
const cBase$o = "flex flex-col", cRowMain = "grid items-center", cRowHeadline = "", cSlotLead = "flex-none flex justify-between items-center", cSlotDefault = "flex-auto", cSlotTrail = "flex-none flex items-center space-x-4";
function instance$M(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, { $$slots: yr = {}, $$scope: kr } = ar;
  const _r = compute_slots(yr);
  let { background: xr = "bg-surface-100-800-token" } = ar, { border: Sr = "" } = ar, { padding: Er = "p-4" } = ar, { shadow: Cr = "" } = ar, { spacing: Tr = "space-y-4" } = ar, { gridColumns: Ar = "grid-cols-[auto_1fr_auto]" } = ar, { gap: Ir = "gap-4" } = ar, { regionRowMain: Mr = "" } = ar, { regionRowHeadline: Hr = "" } = ar, { slotLead: Br = "" } = ar, { slotDefault: zr = "" } = ar, { slotTrail: Gr = "" } = ar, { label: Xr = "" } = ar, { labelledby: Jr = "" } = ar;
  return lr.$$set = (li) => {
    cr(23, ar = assign$1(assign$1({}, ar), exclude_internal_props(li))), "background" in li && cr(9, xr = li.background), "border" in li && cr(10, Sr = li.border), "padding" in li && cr(11, Er = li.padding), "shadow" in li && cr(12, Cr = li.shadow), "spacing" in li && cr(13, Tr = li.spacing), "gridColumns" in li && cr(14, Ar = li.gridColumns), "gap" in li && cr(15, Ir = li.gap), "regionRowMain" in li && cr(16, Mr = li.regionRowMain), "regionRowHeadline" in li && cr(17, Hr = li.regionRowHeadline), "slotLead" in li && cr(18, Br = li.slotLead), "slotDefault" in li && cr(19, zr = li.slotDefault), "slotTrail" in li && cr(20, Gr = li.slotTrail), "label" in li && cr(0, Xr = li.label), "labelledby" in li && cr(1, Jr = li.labelledby), "$$scope" in li && cr(21, kr = li.$$scope);
  }, lr.$$.update = () => {
    var li;
    cr(7, ur = `${cBase$o} ${xr} ${Sr} ${Tr} ${Er} ${Cr} ${(li = ar.class) != null ? li : ""}`), lr.$$.dirty & /*gridColumns, gap, regionRowMain*/
    114688 && cr(6, fr = `${cRowMain} ${Ar} ${Ir} ${Mr}`), lr.$$.dirty & /*regionRowHeadline*/
    131072 && cr(5, dr = `${cRowHeadline} ${Hr}`), lr.$$.dirty & /*slotLead*/
    262144 && cr(4, gr = `${cSlotLead} ${Br}`), lr.$$.dirty & /*slotDefault*/
    524288 && cr(3, mr = `${cSlotDefault} ${zr}`), lr.$$.dirty & /*slotTrail*/
    1048576 && cr(2, vr = `${cSlotTrail} ${Gr}`);
  }, ar = exclude_internal_props(ar), [
    Xr,
    Jr,
    vr,
    mr,
    gr,
    dr,
    fr,
    ur,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    kr,
    yr
  ];
}
class AppBar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$M, create_fragment$15, safe_not_equal, {
      background: 9,
      border: 10,
      padding: 11,
      shadow: 12,
      spacing: 13,
      gridColumns: 14,
      gap: 15,
      regionRowMain: 16,
      regionRowHeadline: 17,
      slotLead: 18,
      slotDefault: 19,
      slotTrail: 20,
      label: 0,
      labelledby: 1
    });
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[10];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[12];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get gridColumns() {
    return this.$$.ctx[14];
  }
  set gridColumns(ar) {
    this.$$set({ gridColumns: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[15];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionRowMain() {
    return this.$$.ctx[16];
  }
  set regionRowMain(ar) {
    this.$$set({ regionRowMain: ar }), flush();
  }
  get regionRowHeadline() {
    return this.$$.ctx[17];
  }
  set regionRowHeadline(ar) {
    this.$$set({ regionRowHeadline: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[18];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotDefault() {
    return this.$$.ctx[19];
  }
  set slotDefault(ar) {
    this.$$set({ slotDefault: ar }), flush();
  }
  get slotTrail() {
    return this.$$.ctx[20];
  }
  set slotTrail(ar) {
    this.$$set({ slotTrail: ar }), flush();
  }
  get label() {
    return this.$$.ctx[0];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[1];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(AppBar, { background: {}, border: {}, padding: {}, shadow: {}, spacing: {}, gridColumns: {}, gap: {}, regionRowMain: {}, regionRowHeadline: {}, slotLead: {}, slotDefault: {}, slotTrail: {}, label: {}, labelledby: {} }, ["lead", "default", "trail", "headline"], [], !0);
const get_trail_slot_changes$2 = (lr) => ({}), get_trail_slot_context$2 = (lr) => ({}), get_lead_slot_changes$7 = (lr) => ({}), get_lead_slot_context$7 = (lr) => ({});
function create_fragment$14(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r;
  const xr = (
    /*#slots*/
    lr[17].lead
  ), Sr = create_slot(
    xr,
    lr,
    /*$$scope*/
    lr[16],
    get_lead_slot_context$7
  ), Er = (
    /*#slots*/
    lr[17].default
  ), Cr = create_slot(
    Er,
    lr,
    /*$$scope*/
    lr[16],
    null
  ), Tr = (
    /*#slots*/
    lr[17].trail
  ), Ar = create_slot(
    Tr,
    lr,
    /*$$scope*/
    lr[16],
    get_trail_slot_context$2
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), Sr && Sr.c(), fr = space(), dr = element("div"), Cr && Cr.c(), mr = space(), vr = element("div"), Ar && Ar.c(), attr(cr, "class", ur = "app-bar-lead " + /*classesRegionLead*/
      lr[2]), attr(dr, "class", gr = "app-bar-default " + /*classesRegionDefault*/
      lr[1]), attr(vr, "class", yr = "app-bar-trail " + /*classesRegionTrail*/
      lr[0]), attr(ar, "class", kr = "app-rail " + /*classesBase*/
      lr[3]), attr(ar, "data-testid", "app-rail");
    },
    m(Ir, Mr) {
      insert(Ir, ar, Mr), append(ar, cr), Sr && Sr.m(cr, null), append(ar, fr), append(ar, dr), Cr && Cr.m(dr, null), append(ar, mr), append(ar, vr), Ar && Ar.m(vr, null), _r = !0;
    },
    p(Ir, [Mr]) {
      Sr && Sr.p && (!_r || Mr & /*$$scope*/
      65536) && update_slot_base(
        Sr,
        xr,
        Ir,
        /*$$scope*/
        Ir[16],
        _r ? get_slot_changes(
          xr,
          /*$$scope*/
          Ir[16],
          Mr,
          get_lead_slot_changes$7
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ir[16]
        ),
        get_lead_slot_context$7
      ), (!_r || Mr & /*classesRegionLead*/
      4 && ur !== (ur = "app-bar-lead " + /*classesRegionLead*/
      Ir[2])) && attr(cr, "class", ur), Cr && Cr.p && (!_r || Mr & /*$$scope*/
      65536) && update_slot_base(
        Cr,
        Er,
        Ir,
        /*$$scope*/
        Ir[16],
        _r ? get_slot_changes(
          Er,
          /*$$scope*/
          Ir[16],
          Mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ir[16]
        ),
        null
      ), (!_r || Mr & /*classesRegionDefault*/
      2 && gr !== (gr = "app-bar-default " + /*classesRegionDefault*/
      Ir[1])) && attr(dr, "class", gr), Ar && Ar.p && (!_r || Mr & /*$$scope*/
      65536) && update_slot_base(
        Ar,
        Tr,
        Ir,
        /*$$scope*/
        Ir[16],
        _r ? get_slot_changes(
          Tr,
          /*$$scope*/
          Ir[16],
          Mr,
          get_trail_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ir[16]
        ),
        get_trail_slot_context$2
      ), (!_r || Mr & /*classesRegionTrail*/
      1 && yr !== (yr = "app-bar-trail " + /*classesRegionTrail*/
      Ir[0])) && attr(vr, "class", yr), (!_r || Mr & /*classesBase*/
      8 && kr !== (kr = "app-rail " + /*classesBase*/
      Ir[3])) && attr(ar, "class", kr);
    },
    i(Ir) {
      _r || (transition_in(Sr, Ir), transition_in(Cr, Ir), transition_in(Ar, Ir), _r = !0);
    },
    o(Ir) {
      transition_out(Sr, Ir), transition_out(Cr, Ir), transition_out(Ar, Ir), _r = !1;
    },
    d(Ir) {
      Ir && detach(ar), Sr && Sr.d(Ir), Cr && Cr.d(Ir), Ar && Ar.d(Ir);
    }
  };
}
const cBase$n = "grid grid-rows-[auto_1fr_auto] overflow-y-auto", cRegionLead$1 = "box-border", cRegionDefault$1 = "box-border", cRegionTrail$1 = "box-border";
function instance$L(lr, ar, cr) {
  let ur, fr, dr, gr, { $$slots: mr = {}, $$scope: vr } = ar, { background: yr = "bg-surface-100-800-token" } = ar, { border: kr = "" } = ar, { width: _r = "w-20" } = ar, { height: xr = "h-full" } = ar, { gap: Sr = "gap-0" } = ar, { regionLead: Er = "" } = ar, { regionDefault: Cr = "" } = ar, { regionTrail: Tr = "" } = ar, { hover: Ar = "bg-primary-hover-token" } = ar, { active: Ir = "bg-primary-active-token" } = ar, { spacing: Mr = "space-y-1" } = ar, { aspectRatio: Hr = "aspect-square" } = ar;
  return setContext("active", Ir), setContext("hover", Ar), setContext("spacing", Mr), setContext("aspectRatio", Hr), lr.$$set = (Br) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Br))), "background" in Br && cr(4, yr = Br.background), "border" in Br && cr(5, kr = Br.border), "width" in Br && cr(6, _r = Br.width), "height" in Br && cr(7, xr = Br.height), "gap" in Br && cr(8, Sr = Br.gap), "regionLead" in Br && cr(9, Er = Br.regionLead), "regionDefault" in Br && cr(10, Cr = Br.regionDefault), "regionTrail" in Br && cr(11, Tr = Br.regionTrail), "hover" in Br && cr(12, Ar = Br.hover), "active" in Br && cr(13, Ir = Br.active), "spacing" in Br && cr(14, Mr = Br.spacing), "aspectRatio" in Br && cr(15, Hr = Br.aspectRatio), "$$scope" in Br && cr(16, vr = Br.$$scope);
  }, lr.$$.update = () => {
    cr(3, ur = `${cBase$n} ${yr} ${kr} ${_r} ${xr} ${Sr} ${ar.class || ""}`), lr.$$.dirty & /*regionLead*/
    512 && cr(2, fr = `${cRegionLead$1} ${Er}`), lr.$$.dirty & /*regionDefault*/
    1024 && cr(1, dr = `${cRegionDefault$1} ${Cr}`), lr.$$.dirty & /*regionTrail*/
    2048 && cr(0, gr = `${cRegionTrail$1} ${Tr}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    dr,
    fr,
    ur,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    vr,
    mr
  ];
}
class AppRail extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$L, create_fragment$14, safe_not_equal, {
      background: 4,
      border: 5,
      width: 6,
      height: 7,
      gap: 8,
      regionLead: 9,
      regionDefault: 10,
      regionTrail: 11,
      hover: 12,
      active: 13,
      spacing: 14,
      aspectRatio: 15
    });
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[7];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[8];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[9];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[10];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[11];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[12];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[15];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRail, { background: {}, border: {}, width: {}, height: {}, gap: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default", "trail"], [], !0);
const get_lead_slot_changes$6 = (lr) => ({}), get_lead_slot_context$6 = (lr) => ({});
function create_if_block$w(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_lead_slot_context$6
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-rail-lead " + /*classesLead*/
      lr[6]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[22],
          mr,
          get_lead_slot_changes$6
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_lead_slot_context$6
      ), (!ur || mr[0] & /*classesLead*/
      64 && cr !== (cr = "app-rail-lead " + /*classesLead*/
      gr[6])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$13(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[12](),
    { tabindex: "-1" }
  ], Ir = {};
  for (let zr = 0; zr < Ar.length; zr += 1)
    Ir = assign$1(Ir, Ar[zr]);
  let Mr = (
    /*$$slots*/
    lr[13].lead && create_if_block$w(lr)
  );
  const Hr = (
    /*#slots*/
    lr[23].default
  ), Br = create_slot(
    Hr,
    lr,
    /*$$scope*/
    lr[22],
    null
  );
  return Er = init_binding_group(
    /*$$binding_groups*/
    lr[34][0]
  ), {
    c() {
      ar = element("label"), cr = element("button"), ur = element("div"), fr = element("input"), dr = space(), gr = element("div"), Mr && Mr.c(), mr = space(), vr = element("div"), Br && Br.c(), set_attributes(fr, Ir), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", yr = "app-rail-label " + /*classesLabel*/
      lr[5]), attr(gr, "class", kr = "app-rail-interface " + /*classesInterface*/
      lr[7]), attr(cr, "class", _r = "app-rail-wrapper " + /*classesWrapper*/
      lr[8]), attr(cr, "tabindex", "0"), attr(ar, "class", xr = "app-rail-tile " + /*classesBase*/
      lr[9]), attr(ar, "data-testid", "app-rail-tile"), attr(
        ar,
        "title",
        /*title*/
        lr[3]
      ), Er.p(fr);
    },
    m(zr, Gr) {
      insert(zr, ar, Gr), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[32](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), append(cr, gr), Mr && Mr.m(gr, null), append(gr, mr), append(gr, vr), Br && Br.m(vr, null), Sr = !0, Cr || (Tr = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[33]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[30]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[31]
        ),
        listen(
          cr,
          "click",
          /*selectElemInput*/
          lr[11]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[28]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[29]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[24]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[25]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[26]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[27]
        )
      ], Cr = !0);
    },
    p(zr, Gr) {
      set_attributes(fr, Ir = get_spread_update(Ar, [
        { type: "radio" },
        (!Sr || Gr[0] & /*name*/
        2) && { name: (
          /*name*/
          zr[1]
        ) },
        (!Sr || Gr[0] & /*value*/
        4) && { __value: (
          /*value*/
          zr[2]
        ) },
        /*prunedRestProps*/
        zr[12](),
        { tabindex: "-1" }
      ])), Gr[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      zr[0]), /*$$slots*/
      zr[13].lead ? Mr ? (Mr.p(zr, Gr), Gr[0] & /*$$slots*/
      8192 && transition_in(Mr, 1)) : (Mr = create_if_block$w(zr), Mr.c(), transition_in(Mr, 1), Mr.m(gr, mr)) : Mr && (group_outros(), transition_out(Mr, 1, 1, () => {
        Mr = null;
      }), check_outros()), Br && Br.p && (!Sr || Gr[0] & /*$$scope*/
      4194304) && update_slot_base(
        Br,
        Hr,
        zr,
        /*$$scope*/
        zr[22],
        Sr ? get_slot_changes(
          Hr,
          /*$$scope*/
          zr[22],
          Gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          zr[22]
        ),
        null
      ), (!Sr || Gr[0] & /*classesLabel*/
      32 && yr !== (yr = "app-rail-label " + /*classesLabel*/
      zr[5])) && attr(vr, "class", yr), (!Sr || Gr[0] & /*classesInterface*/
      128 && kr !== (kr = "app-rail-interface " + /*classesInterface*/
      zr[7])) && attr(gr, "class", kr), (!Sr || Gr[0] & /*classesWrapper*/
      256 && _r !== (_r = "app-rail-wrapper " + /*classesWrapper*/
      zr[8])) && attr(cr, "class", _r), (!Sr || Gr[0] & /*classesBase*/
      512 && xr !== (xr = "app-rail-tile " + /*classesBase*/
      zr[9])) && attr(ar, "class", xr), (!Sr || Gr[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        zr[3]
      );
    },
    i(zr) {
      Sr || (transition_in(Mr), transition_in(Br, zr), Sr = !0);
    },
    o(zr) {
      transition_out(Mr), transition_out(Br, zr), Sr = !1;
    },
    d(zr) {
      zr && detach(ar), lr[32](null), Mr && Mr.d(), Br && Br.d(zr), Er.r(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$m = "cursor-pointer", cWrapper$3 = "flex flex-col justify-center items-stretch w-full", cInterface$3 = "text-center", cLabel$4 = "font-bold text-xs";
function instance$K(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr;
  const yr = [
    "group",
    "name",
    "value",
    "title",
    "regionLead",
    "regionLabel",
    "hover",
    "active",
    "spacing",
    "width",
    "aspectRatio"
  ];
  let kr = compute_rest_props(ar, yr), { $$slots: _r = {}, $$scope: xr } = ar;
  const Sr = compute_slots(_r);
  let { group: Er } = ar, { name: Cr } = ar, { value: Tr } = ar, { title: Ar = "" } = ar, { regionLead: Ir = "" } = ar, { regionLabel: Mr = "" } = ar, { hover: Hr = getContext("hover") } = ar, { active: Br = getContext("active") } = ar, { spacing: zr = getContext("spacing") } = ar, { width: Gr = getContext("width") } = ar, { aspectRatio: Xr = getContext("aspectRatio") } = ar, Jr;
  function li(ki) {
    ["Enter", "Space"].includes(ki.code) && (ki.preventDefault(), Qr());
  }
  function Qr() {
    Jr.click();
  }
  function ei() {
    return delete kr.class, kr;
  }
  const ui = [[]];
  function Ai(ki) {
    bubble.call(this, lr, ki);
  }
  function fi(ki) {
    bubble.call(this, lr, ki);
  }
  function gi(ki) {
    bubble.call(this, lr, ki);
  }
  function Ci(ki) {
    bubble.call(this, lr, ki);
  }
  function mi(ki) {
    bubble.call(this, lr, ki);
  }
  function vi(ki) {
    bubble.call(this, lr, ki);
  }
  function Ri(ki) {
    bubble.call(this, lr, ki);
  }
  function di(ki) {
    bubble.call(this, lr, ki);
  }
  function Ti(ki) {
    binding_callbacks[ki ? "unshift" : "push"](() => {
      Jr = ki, cr(4, Jr);
    });
  }
  function qi() {
    Er = this.__value, cr(0, Er);
  }
  return lr.$$set = (ki) => {
    cr(36, ar = assign$1(assign$1({}, ar), exclude_internal_props(ki))), cr(35, kr = compute_rest_props(ar, yr)), "group" in ki && cr(0, Er = ki.group), "name" in ki && cr(1, Cr = ki.name), "value" in ki && cr(2, Tr = ki.value), "title" in ki && cr(3, Ar = ki.title), "regionLead" in ki && cr(14, Ir = ki.regionLead), "regionLabel" in ki && cr(15, Mr = ki.regionLabel), "hover" in ki && cr(16, Hr = ki.hover), "active" in ki && cr(17, Br = ki.active), "spacing" in ki && cr(18, zr = ki.spacing), "width" in ki && cr(19, Gr = ki.width), "aspectRatio" in ki && cr(20, Xr = ki.aspectRatio), "$$scope" in ki && cr(22, xr = ki.$$scope);
  }, lr.$$.update = () => {
    lr.$$.dirty[0] & /*group, value, active*/
    131077 && cr(21, ur = Er === Tr ? Br : ""), cr(9, fr = `${cBase$m} ${ar.class || ""}`), lr.$$.dirty[0] & /*aspectRatio, width, hover, classActive*/
    3735552 && cr(8, dr = `${cWrapper$3} ${Xr} ${Gr} ${Hr} ${ur}`), lr.$$.dirty[0] & /*spacing*/
    262144 && cr(7, gr = `${cInterface$3} ${zr}`), lr.$$.dirty[0] & /*regionLead*/
    16384 && cr(6, mr = `${Ir}`), lr.$$.dirty[0] & /*regionLabel*/
    32768 && cr(5, vr = `${cLabel$4} ${Mr}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Cr,
    Tr,
    Ar,
    Jr,
    vr,
    mr,
    gr,
    dr,
    fr,
    li,
    Qr,
    ei,
    Sr,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    ur,
    xr,
    _r,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    Ri,
    di,
    Ti,
    qi,
    ui
  ];
}
class AppRailTile extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$K,
      create_fragment$13,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        regionLead: 14,
        regionLabel: 15,
        hover: 16,
        active: 17,
        spacing: 18,
        width: 19,
        aspectRatio: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[14];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[15];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[17];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[18];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[20];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailTile, { group: {}, name: {}, value: {}, title: {}, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, width: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$5 = (lr) => ({}), get_lead_slot_context$5 = (lr) => ({});
function create_if_block$v(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[16].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[15],
    get_lead_slot_context$5
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "app-rail-lead " + /*classesLead*/
      lr[1]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      32768) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[15],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[15],
          mr,
          get_lead_slot_changes$5
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[15]
        ),
        get_lead_slot_context$5
      ), (!ur || mr & /*classesLead*/
      2 && cr !== (cr = "app-rail-lead " + /*classesLead*/
      gr[1])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$12(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr = (
    /*$$slots*/
    lr[6].lead && create_if_block$v(lr)
  );
  const Sr = (
    /*#slots*/
    lr[16].default
  ), Er = create_slot(
    Sr,
    lr,
    /*$$scope*/
    lr[15],
    null
  );
  let Cr = [
    {
      class: mr = "app-rail-anchor " + /*classesBase*/
      lr[3]
    },
    {
      href: vr = /*$$props*/
      lr[5].href
    },
    /*prunedRestProps*/
    lr[4](),
    { "data-testid": "app-rail-anchor" }
  ], Tr = {};
  for (let Ar = 0; Ar < Cr.length; Ar += 1)
    Tr = assign$1(Tr, Cr[Ar]);
  return {
    c() {
      ar = element("a"), cr = element("div"), xr && xr.c(), ur = space(), fr = element("div"), Er && Er.c(), attr(fr, "class", dr = "app-rail-label " + /*classesLabel*/
      lr[0]), attr(cr, "class", gr = "app-rail-wrapper " + /*classesWrapper*/
      lr[2]), set_attributes(ar, Tr);
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), xr && xr.m(cr, null), append(cr, ur), append(cr, fr), Er && Er.m(fr, null), yr = !0, kr || (_r = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[20]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[21]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[22]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[23]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[24]
        )
      ], kr = !0);
    },
    p(Ar, [Ir]) {
      /*$$slots*/
      Ar[6].lead ? xr ? (xr.p(Ar, Ir), Ir & /*$$slots*/
      64 && transition_in(xr, 1)) : (xr = create_if_block$v(Ar), xr.c(), transition_in(xr, 1), xr.m(cr, ur)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), Er && Er.p && (!yr || Ir & /*$$scope*/
      32768) && update_slot_base(
        Er,
        Sr,
        Ar,
        /*$$scope*/
        Ar[15],
        yr ? get_slot_changes(
          Sr,
          /*$$scope*/
          Ar[15],
          Ir,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[15]
        ),
        null
      ), (!yr || Ir & /*classesLabel*/
      1 && dr !== (dr = "app-rail-label " + /*classesLabel*/
      Ar[0])) && attr(fr, "class", dr), (!yr || Ir & /*classesWrapper*/
      4 && gr !== (gr = "app-rail-wrapper " + /*classesWrapper*/
      Ar[2])) && attr(cr, "class", gr), set_attributes(ar, Tr = get_spread_update(Cr, [
        (!yr || Ir & /*classesBase*/
        8 && mr !== (mr = "app-rail-anchor " + /*classesBase*/
        Ar[3])) && { class: mr },
        (!yr || Ir & /*$$props*/
        32 && vr !== (vr = /*$$props*/
        Ar[5].href)) && { href: vr },
        /*prunedRestProps*/
        Ar[4](),
        { "data-testid": "app-rail-anchor" }
      ]));
    },
    i(Ar) {
      yr || (transition_in(xr), transition_in(Er, Ar), yr = !0);
    },
    o(Ar) {
      transition_out(xr), transition_out(Er, Ar), yr = !1;
    },
    d(Ar) {
      Ar && detach(ar), xr && xr.d(), Er && Er.d(Ar), kr = !1, run_all(_r);
    }
  };
}
const cBase$l = "unstyled", cWrapper$2 = "w-full flex flex-col justify-center items-stretch text-center space-y-1", cLabel$3 = "font-bold text-xs";
function instance$J(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  const vr = ["selected", "regionLead", "regionLabel", "hover", "active", "spacing", "aspectRatio"];
  let yr = compute_rest_props(ar, vr), { $$slots: kr = {}, $$scope: _r } = ar;
  const xr = compute_slots(kr);
  let { selected: Sr = !1 } = ar, { regionLead: Er = "flex justify-center items-center" } = ar, { regionLabel: Cr = "" } = ar, { hover: Tr = getContext("hover") } = ar, { active: Ar = getContext("active") } = ar, { spacing: Ir = getContext("spacing") } = ar, { aspectRatio: Mr = getContext("aspectRatio") } = ar;
  function Hr() {
    return delete yr.class, yr;
  }
  function Br(ui) {
    bubble.call(this, lr, ui);
  }
  function zr(ui) {
    bubble.call(this, lr, ui);
  }
  function Gr(ui) {
    bubble.call(this, lr, ui);
  }
  function Xr(ui) {
    bubble.call(this, lr, ui);
  }
  function Jr(ui) {
    bubble.call(this, lr, ui);
  }
  function li(ui) {
    bubble.call(this, lr, ui);
  }
  function Qr(ui) {
    bubble.call(this, lr, ui);
  }
  function ei(ui) {
    bubble.call(this, lr, ui);
  }
  return lr.$$set = (ui) => {
    cr(5, ar = assign$1(assign$1({}, ar), exclude_internal_props(ui))), cr(25, yr = compute_rest_props(ar, vr)), "selected" in ui && cr(7, Sr = ui.selected), "regionLead" in ui && cr(8, Er = ui.regionLead), "regionLabel" in ui && cr(9, Cr = ui.regionLabel), "hover" in ui && cr(10, Tr = ui.hover), "active" in ui && cr(11, Ar = ui.active), "spacing" in ui && cr(12, Ir = ui.spacing), "aspectRatio" in ui && cr(13, Mr = ui.aspectRatio), "$$scope" in ui && cr(15, _r = ui.$$scope);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*selected, active*/
    2176 && cr(14, ur = Sr ? Ar : ""), cr(3, fr = `${cBase$l} ${ar.class || ""}`), lr.$$.dirty & /*aspectRatio, hover, spacing, classActive*/
    29696 && cr(2, dr = `${cWrapper$2} ${Mr} ${Tr} ${Ir} ${ur}`), lr.$$.dirty & /*regionLead*/
    256 && cr(1, gr = `${Er}`), lr.$$.dirty & /*regionLabel*/
    512 && cr(0, mr = `${cLabel$3} ${Cr}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    gr,
    dr,
    fr,
    Hr,
    ar,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    ur,
    _r,
    kr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei
  ];
}
class AppRailAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$J, create_fragment$12, safe_not_equal, {
      selected: 7,
      regionLead: 8,
      regionLabel: 9,
      hover: 10,
      active: 11,
      spacing: 12,
      aspectRatio: 13
    });
  }
  get selected() {
    return this.$$.ctx[7];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[9];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[10];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[11];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[13];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailAnchor, { selected: { type: "Boolean" }, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_footer_slot_changes = (lr) => ({}), get_footer_slot_context = (lr) => ({}), get_sidebarRight_slot_changes = (lr) => ({}), get_sidebarRight_slot_context = (lr) => ({}), get_pageFooter_slot_changes = (lr) => ({}), get_pageFooter_slot_context = (lr) => ({}), get_pageHeader_slot_changes = (lr) => ({}), get_pageHeader_slot_context = (lr) => ({}), get_sidebarLeft_slot_changes = (lr) => ({}), get_sidebarLeft_slot_context = (lr) => ({}), get_header_slot_changes$1 = (lr) => ({}), get_header_slot_context$1 = (lr) => ({});
function create_if_block_5$4(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].header
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_header_slot_context$1
  );
  return {
    c() {
      ar = element("header"), dr && dr.c(), attr(ar, "id", "shell-header"), attr(ar, "class", cr = "flex-none " + /*classesHeader*/
      lr[8]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[18],
          mr,
          get_header_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_header_slot_context$1
      ), (!ur || mr & /*classesHeader*/
      256 && cr !== (cr = "flex-none " + /*classesHeader*/
      gr[8])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_if_block_4$6(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[19].sidebarLeft
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[18],
    get_sidebarLeft_slot_context
  );
  return {
    c() {
      ar = element("aside"), fr && fr.c(), attr(ar, "id", "sidebar-left"), attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        lr[7]
      );
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[18],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[18],
          gr,
          get_sidebarLeft_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[18]
        ),
        get_sidebarLeft_slot_context
      ), (!cr || gr & /*classesSidebarLeft*/
      128) && attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        dr[7]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block_3$8(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].pageHeader
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_pageHeader_slot_context
  ), gr = dr || fallback_block_1$1();
  return {
    c() {
      ar = element("header"), gr && gr.c(), attr(ar, "id", "page-header"), attr(ar, "class", cr = "flex-none " + /*classesPageHeader*/
      lr[5]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), gr && gr.m(ar, null), ur = !0;
    },
    p(mr, vr) {
      dr && dr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        mr,
        /*$$scope*/
        mr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          mr[18],
          vr,
          get_pageHeader_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          mr[18]
        ),
        get_pageHeader_slot_context
      ), (!ur || vr & /*classesPageHeader*/
      32 && cr !== (cr = "flex-none " + /*classesPageHeader*/
      mr[5])) && attr(ar, "class", cr);
    },
    i(mr) {
      ur || (transition_in(gr, mr), ur = !0);
    },
    o(mr) {
      transition_out(gr, mr), ur = !1;
    },
    d(mr) {
      mr && detach(ar), gr && gr.d(mr);
    }
  };
}
function fallback_block_1$1(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:header)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_2$c(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].pageFooter
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_pageFooter_slot_context
  ), gr = dr || fallback_block$4();
  return {
    c() {
      ar = element("footer"), gr && gr.c(), attr(ar, "id", "page-footer"), attr(ar, "class", cr = "flex-none " + /*classesPageFooter*/
      lr[3]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), gr && gr.m(ar, null), ur = !0;
    },
    p(mr, vr) {
      dr && dr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        mr,
        /*$$scope*/
        mr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          mr[18],
          vr,
          get_pageFooter_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          mr[18]
        ),
        get_pageFooter_slot_context
      ), (!ur || vr & /*classesPageFooter*/
      8 && cr !== (cr = "flex-none " + /*classesPageFooter*/
      mr[3])) && attr(ar, "class", cr);
    },
    i(mr) {
      ur || (transition_in(gr, mr), ur = !0);
    },
    o(mr) {
      transition_out(gr, mr), ur = !1;
    },
    d(mr) {
      mr && detach(ar), gr && gr.d(mr);
    }
  };
}
function fallback_block$4(lr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:footer)");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_1$f(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[19].sidebarRight
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[18],
    get_sidebarRight_slot_context
  );
  return {
    c() {
      ar = element("aside"), fr && fr.c(), attr(ar, "id", "sidebar-right"), attr(
        ar,
        "class",
        /*classesSidebarRight*/
        lr[6]
      );
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[18],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[18],
          gr,
          get_sidebarRight_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[18]
        ),
        get_sidebarRight_slot_context
      ), (!cr || gr & /*classesSidebarRight*/
      64) && attr(
        ar,
        "class",
        /*classesSidebarRight*/
        dr[6]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block$u(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[19].footer
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[18],
    get_footer_slot_context
  );
  return {
    c() {
      ar = element("footer"), dr && dr.c(), attr(ar, "id", "shell-footer"), attr(ar, "class", cr = "flex-none " + /*classesFooter*/
      lr[2]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[18],
          mr,
          get_footer_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_footer_slot_context
      ), (!ur || mr & /*classesFooter*/
      4 && cr !== (cr = "flex-none " + /*classesFooter*/
      gr[2])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$11(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr = (
    /*$$slots*/
    lr[10].header && create_if_block_5$4(lr)
  ), Ar = (
    /*$$slots*/
    lr[10].sidebarLeft && create_if_block_4$6(lr)
  ), Ir = (
    /*$$slots*/
    lr[10].pageHeader && create_if_block_3$8(lr)
  );
  const Mr = (
    /*#slots*/
    lr[19].default
  ), Hr = create_slot(
    Mr,
    lr,
    /*$$scope*/
    lr[18],
    null
  );
  let Br = (
    /*$$slots*/
    lr[10].pageFooter && create_if_block_2$c(lr)
  ), zr = (
    /*$$slots*/
    lr[10].sidebarRight && create_if_block_1$f(lr)
  ), Gr = (
    /*$$slots*/
    lr[10].footer && create_if_block$u(lr)
  );
  return {
    c() {
      ar = element("div"), Tr && Tr.c(), cr = space(), ur = element("div"), Ar && Ar.c(), fr = space(), dr = element("div"), Ir && Ir.c(), gr = space(), mr = element("main"), Hr && Hr.c(), yr = space(), Br && Br.c(), _r = space(), zr && zr.c(), xr = space(), Gr && Gr.c(), attr(mr, "id", "page-content"), attr(mr, "class", vr = "flex-auto " + /*classesPageContent*/
      lr[4]), attr(dr, "id", "page"), attr(dr, "class", kr = /*regionPage*/
      lr[1] + " " + cPage), set_style(
        dr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        lr[0]
      ), attr(ur, "class", "flex-auto " + cContentArea), attr(ar, "id", "appShell"), attr(
        ar,
        "class",
        /*classesBase*/
        lr[9]
      ), attr(ar, "data-testid", "app-shell");
    },
    m(Xr, Jr) {
      insert(Xr, ar, Jr), Tr && Tr.m(ar, null), append(ar, cr), append(ar, ur), Ar && Ar.m(ur, null), append(ur, fr), append(ur, dr), Ir && Ir.m(dr, null), append(dr, gr), append(dr, mr), Hr && Hr.m(mr, null), append(dr, yr), Br && Br.m(dr, null), append(ur, _r), zr && zr.m(ur, null), append(ar, xr), Gr && Gr.m(ar, null), Sr = !0, Er || (Cr = listen(
        dr,
        "scroll",
        /*scroll_handler*/
        lr[20]
      ), Er = !0);
    },
    p(Xr, [Jr]) {
      /*$$slots*/
      Xr[10].header ? Tr ? (Tr.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(Tr, 1)) : (Tr = create_if_block_5$4(Xr), Tr.c(), transition_in(Tr, 1), Tr.m(ar, cr)) : Tr && (group_outros(), transition_out(Tr, 1, 1, () => {
        Tr = null;
      }), check_outros()), /*$$slots*/
      Xr[10].sidebarLeft ? Ar ? (Ar.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(Ar, 1)) : (Ar = create_if_block_4$6(Xr), Ar.c(), transition_in(Ar, 1), Ar.m(ur, fr)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), /*$$slots*/
      Xr[10].pageHeader ? Ir ? (Ir.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(Ir, 1)) : (Ir = create_if_block_3$8(Xr), Ir.c(), transition_in(Ir, 1), Ir.m(dr, gr)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Hr && Hr.p && (!Sr || Jr & /*$$scope*/
      262144) && update_slot_base(
        Hr,
        Mr,
        Xr,
        /*$$scope*/
        Xr[18],
        Sr ? get_slot_changes(
          Mr,
          /*$$scope*/
          Xr[18],
          Jr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Xr[18]
        ),
        null
      ), (!Sr || Jr & /*classesPageContent*/
      16 && vr !== (vr = "flex-auto " + /*classesPageContent*/
      Xr[4])) && attr(mr, "class", vr), /*$$slots*/
      Xr[10].pageFooter ? Br ? (Br.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(Br, 1)) : (Br = create_if_block_2$c(Xr), Br.c(), transition_in(Br, 1), Br.m(dr, null)) : Br && (group_outros(), transition_out(Br, 1, 1, () => {
        Br = null;
      }), check_outros()), (!Sr || Jr & /*regionPage*/
      2 && kr !== (kr = /*regionPage*/
      Xr[1] + " " + cPage)) && attr(dr, "class", kr), Jr & /*scrollbarGutter*/
      1 && set_style(
        dr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        Xr[0]
      ), /*$$slots*/
      Xr[10].sidebarRight ? zr ? (zr.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(zr, 1)) : (zr = create_if_block_1$f(Xr), zr.c(), transition_in(zr, 1), zr.m(ur, null)) : zr && (group_outros(), transition_out(zr, 1, 1, () => {
        zr = null;
      }), check_outros()), /*$$slots*/
      Xr[10].footer ? Gr ? (Gr.p(Xr, Jr), Jr & /*$$slots*/
      1024 && transition_in(Gr, 1)) : (Gr = create_if_block$u(Xr), Gr.c(), transition_in(Gr, 1), Gr.m(ar, null)) : Gr && (group_outros(), transition_out(Gr, 1, 1, () => {
        Gr = null;
      }), check_outros()), (!Sr || Jr & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Xr[9]
      );
    },
    i(Xr) {
      Sr || (transition_in(Tr), transition_in(Ar), transition_in(Ir), transition_in(Hr, Xr), transition_in(Br), transition_in(zr), transition_in(Gr), Sr = !0);
    },
    o(Xr) {
      transition_out(Tr), transition_out(Ar), transition_out(Ir), transition_out(Hr, Xr), transition_out(Br), transition_out(zr), transition_out(Gr), Sr = !1;
    },
    d(Xr) {
      Xr && detach(ar), Tr && Tr.d(), Ar && Ar.d(), Ir && Ir.d(), Hr && Hr.d(Xr), Br && Br.d(), zr && zr.d(), Gr && Gr.d(), Er = !1, Cr();
    }
  };
}
const cBaseAppShell = "w-full h-full flex flex-col overflow-hidden", cContentArea = "w-full h-full flex overflow-hidden", cPage = "flex-1 overflow-x-hidden flex flex-col", cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto", cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance$I(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr, { $$slots: _r = {}, $$scope: xr } = ar;
  const Sr = compute_slots(_r);
  let { scrollbarGutter: Er = "auto" } = ar, { regionPage: Cr = "" } = ar, { slotHeader: Tr = "z-10" } = ar, { slotSidebarLeft: Ar = "w-auto" } = ar, { slotSidebarRight: Ir = "w-auto" } = ar, { slotPageHeader: Mr = "" } = ar, { slotPageContent: Hr = "" } = ar, { slotPageFooter: Br = "" } = ar, { slotFooter: zr = "" } = ar;
  function Gr(Xr) {
    bubble.call(this, lr, Xr);
  }
  return lr.$$set = (Xr) => {
    cr(21, ar = assign$1(assign$1({}, ar), exclude_internal_props(Xr))), "scrollbarGutter" in Xr && cr(0, Er = Xr.scrollbarGutter), "regionPage" in Xr && cr(1, Cr = Xr.regionPage), "slotHeader" in Xr && cr(11, Tr = Xr.slotHeader), "slotSidebarLeft" in Xr && cr(12, Ar = Xr.slotSidebarLeft), "slotSidebarRight" in Xr && cr(13, Ir = Xr.slotSidebarRight), "slotPageHeader" in Xr && cr(14, Mr = Xr.slotPageHeader), "slotPageContent" in Xr && cr(15, Hr = Xr.slotPageContent), "slotPageFooter" in Xr && cr(16, Br = Xr.slotPageFooter), "slotFooter" in Xr && cr(17, zr = Xr.slotFooter), "$$scope" in Xr && cr(18, xr = Xr.$$scope);
  }, lr.$$.update = () => {
    var Xr;
    cr(9, ur = `${cBaseAppShell} ${(Xr = ar.class) != null ? Xr : ""}`), lr.$$.dirty & /*slotHeader*/
    2048 && cr(8, fr = `${Tr}`), lr.$$.dirty & /*slotSidebarLeft*/
    4096 && cr(7, dr = `${cSidebarLeft} ${Ar}`), lr.$$.dirty & /*slotSidebarRight*/
    8192 && cr(6, gr = `${cSidebarRight} ${Ir}`), lr.$$.dirty & /*slotPageHeader*/
    16384 && cr(5, mr = `${Mr}`), lr.$$.dirty & /*slotPageContent*/
    32768 && cr(4, vr = `${Hr}`), lr.$$.dirty & /*slotPageFooter*/
    65536 && cr(3, yr = `${Br}`), lr.$$.dirty & /*slotFooter*/
    131072 && cr(2, kr = `${zr}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Cr,
    kr,
    yr,
    vr,
    mr,
    gr,
    dr,
    fr,
    ur,
    Sr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    xr,
    _r,
    Gr
  ];
}
class AppShell extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$I, create_fragment$11, safe_not_equal, {
      scrollbarGutter: 0,
      regionPage: 1,
      slotHeader: 11,
      slotSidebarLeft: 12,
      slotSidebarRight: 13,
      slotPageHeader: 14,
      slotPageContent: 15,
      slotPageFooter: 16,
      slotFooter: 17
    });
  }
  get scrollbarGutter() {
    return this.$$.ctx[0];
  }
  set scrollbarGutter(ar) {
    this.$$set({ scrollbarGutter: ar }), flush();
  }
  get regionPage() {
    return this.$$.ctx[1];
  }
  set regionPage(ar) {
    this.$$set({ regionPage: ar }), flush();
  }
  get slotHeader() {
    return this.$$.ctx[11];
  }
  set slotHeader(ar) {
    this.$$set({ slotHeader: ar }), flush();
  }
  get slotSidebarLeft() {
    return this.$$.ctx[12];
  }
  set slotSidebarLeft(ar) {
    this.$$set({ slotSidebarLeft: ar }), flush();
  }
  get slotSidebarRight() {
    return this.$$.ctx[13];
  }
  set slotSidebarRight(ar) {
    this.$$set({ slotSidebarRight: ar }), flush();
  }
  get slotPageHeader() {
    return this.$$.ctx[14];
  }
  set slotPageHeader(ar) {
    this.$$set({ slotPageHeader: ar }), flush();
  }
  get slotPageContent() {
    return this.$$.ctx[15];
  }
  set slotPageContent(ar) {
    this.$$set({ slotPageContent: ar }), flush();
  }
  get slotPageFooter() {
    return this.$$.ctx[16];
  }
  set slotPageFooter(ar) {
    this.$$set({ slotPageFooter: ar }), flush();
  }
  get slotFooter() {
    return this.$$.ctx[17];
  }
  set slotFooter(ar) {
    this.$$set({ slotFooter: ar }), flush();
  }
}
create_custom_element(
  AppShell,
  { scrollbarGutter: {}, regionPage: {}, slotHeader: {}, slotSidebarLeft: {}, slotSidebarRight: {}, slotPageHeader: {}, slotPageContent: {}, slotPageFooter: {}, slotFooter: {} },
  [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ],
  [],
  !0
);
function get_each_context$c(lr, ar, cr) {
  const ur = lr.slice();
  return ur[35] = ar[cr], ur;
}
function create_else_block$d(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("div"), cr = text$3(
        /*emptyState*/
        lr[0]
      ), attr(ar, "class", ur = "autocomplete-empty " + /*classesEmpty*/
      lr[7]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr);
    },
    p(fr, dr) {
      dr[0] & /*emptyState*/
      1 && set_data(
        cr,
        /*emptyState*/
        fr[0]
      ), dr[0] & /*classesEmpty*/
      128 && ur !== (ur = "autocomplete-empty " + /*classesEmpty*/
      fr[7]) && attr(ar, "class", ur);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block$t(lr) {
  let ar, cr, ur = [], fr = /* @__PURE__ */ new Map(), dr, gr, mr, vr = ensure_array_like(
    /*optionsFiltered*/
    lr[6].slice(
      0,
      /*sliceLimit*/
      lr[13]
    )
  );
  const yr = (kr) => (
    /*option*/
    kr[35]
  );
  for (let kr = 0; kr < vr.length; kr += 1) {
    let _r = get_each_context$c(lr, vr, kr), xr = yr(_r);
    fr.set(xr, ur[kr] = create_each_block$c(xr, _r));
  }
  return {
    c() {
      ar = element("nav"), cr = element("ul");
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr].c();
      attr(cr, "class", dr = "autocomplete-list " + /*classesList*/
      lr[10]), attr(ar, "class", gr = "autocomplete-nav " + /*classesNav*/
      lr[11]);
    },
    m(kr, _r) {
      insert(kr, ar, _r), append(ar, cr);
      for (let xr = 0; xr < ur.length; xr += 1)
        ur[xr] && ur[xr].m(cr, null);
      mr = !0;
    },
    p(kr, _r) {
      _r[0] & /*classesItem, transitionOut, transitionOutParams, transitions, classesButton, onSelection, optionsFiltered, sliceLimit*/
      25458 && (vr = ensure_array_like(
        /*optionsFiltered*/
        kr[6].slice(
          0,
          /*sliceLimit*/
          kr[13]
        )
      ), group_outros(), ur = update_keyed_each(ur, _r, yr, 1, kr, vr, fr, cr, outro_and_destroy_block, create_each_block$c, null, get_each_context$c), check_outros()), (!mr || _r[0] & /*classesList*/
      1024 && dr !== (dr = "autocomplete-list " + /*classesList*/
      kr[10])) && attr(cr, "class", dr), (!mr || _r[0] & /*classesNav*/
      2048 && gr !== (gr = "autocomplete-nav " + /*classesNav*/
      kr[11])) && attr(ar, "class", gr);
    },
    i(kr) {
      if (!mr) {
        for (let _r = 0; _r < vr.length; _r += 1)
          transition_in(ur[_r]);
        mr = !0;
      }
    },
    o(kr) {
      for (let _r = 0; _r < ur.length; _r += 1)
        transition_out(ur[_r]);
      mr = !1;
    },
    d(kr) {
      kr && detach(ar);
      for (let _r = 0; _r < ur.length; _r += 1)
        ur[_r].d();
    }
  };
}
function create_each_block$c(lr, ar) {
  let cr, ur, fr = (
    /*option*/
    ar[35].label + ""
  ), dr, gr, mr, vr, yr, kr, _r, xr;
  function Sr() {
    return (
      /*click_handler_1*/
      ar[29](
        /*option*/
        ar[35]
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      cr = element("li"), ur = element("button"), gr = space(), attr(ur, "class", dr = "autocomplete-button " + /*classesButton*/
      ar[8]), attr(ur, "type", "button"), attr(cr, "class", mr = "autocomplete-item " + /*classesItem*/
      ar[9]), this.first = cr;
    },
    m(Er, Cr) {
      insert(Er, cr, Cr), append(cr, ur), ur.innerHTML = fr, append(cr, gr), kr = !0, _r || (xr = [
        listen(ur, "click", Sr),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[27]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[28]
        )
      ], _r = !0);
    },
    p(Er, Cr) {
      ar = Er, (!kr || Cr[0] & /*optionsFiltered, sliceLimit*/
      8256) && fr !== (fr = /*option*/
      ar[35].label + "") && (ur.innerHTML = fr), (!kr || Cr[0] & /*classesButton*/
      256 && dr !== (dr = "autocomplete-button " + /*classesButton*/
      ar[8])) && attr(ur, "class", dr), (!kr || Cr[0] & /*classesItem*/
      512 && mr !== (mr = "autocomplete-item " + /*classesItem*/
      ar[9])) && attr(cr, "class", mr);
    },
    i(Er) {
      kr || (Er && add_render_callback(() => {
        kr && (yr && yr.end(1), vr = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[2]
          ),
          params: (
            /*transitionInParams*/
            ar[3]
          ),
          enabled: (
            /*transitions*/
            ar[1]
          )
        }), vr.start());
      }), kr = !0);
    },
    o(Er) {
      vr && vr.invalidate(), Er && (yr = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[4]
        ),
        params: (
          /*transitionOutParams*/
          ar[5]
        ),
        enabled: (
          /*transitions*/
          ar[1]
        )
      })), kr = !1;
    },
    d(Er) {
      Er && detach(cr), Er && yr && yr.end(), _r = !1, run_all(xr);
    }
  };
}
function create_fragment$10(lr) {
  let ar, cr, ur, fr, dr;
  const gr = [create_if_block$t, create_else_block$d], mr = [];
  function vr(yr, kr) {
    return (
      /*optionsFiltered*/
      yr[6].length > 0 ? 0 : 1
    );
  }
  return cr = vr(lr), ur = mr[cr] = gr[cr](lr), {
    c() {
      ar = element("div"), ur.c(), attr(ar, "class", fr = "autocomplete " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "autocomplete");
    },
    m(yr, kr) {
      insert(yr, ar, kr), mr[cr].m(ar, null), dr = !0;
    },
    p(yr, kr) {
      let _r = cr;
      cr = vr(yr), cr === _r ? mr[cr].p(yr, kr) : (group_outros(), transition_out(mr[_r], 1, 1, () => {
        mr[_r] = null;
      }), check_outros(), ur = mr[cr], ur ? ur.p(yr, kr) : (ur = mr[cr] = gr[cr](yr), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!dr || kr[0] & /*classesBase*/
      4096 && fr !== (fr = "autocomplete " + /*classesBase*/
      yr[12])) && attr(ar, "class", fr);
    },
    i(yr) {
      dr || (transition_in(ur), dr = !0);
    },
    o(yr) {
      transition_out(ur), dr = !1;
    },
    d(yr) {
      yr && detach(ar), mr[cr].d();
    }
  };
}
function instance$H(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr, _r, xr;
  component_subscribe(lr, prefersReducedMotionStore, (di) => cr(30, xr = di));
  const Sr = createEventDispatcher();
  let { input: Er = void 0 } = ar, { options: Cr = [] } = ar, { limit: Tr = void 0 } = ar, { allowlist: Ar = [] } = ar, { denylist: Ir = [] } = ar, { emptyState: Mr = "No Results Found." } = ar, { regionNav: Hr = "" } = ar, { regionList: Br = "list-nav" } = ar, { regionItem: zr = "" } = ar, { regionButton: Gr = "w-full" } = ar, { regionEmpty: Xr = "text-center" } = ar, { filter: Jr = gi } = ar, { transitions: li = !xr } = ar, { transitionIn: Qr = slide } = ar, { transitionInParams: ei = { duration: 200 } } = ar, { transitionOut: ui = slide } = ar, { transitionOutParams: Ai = { duration: 200 } } = ar;
  function fi(di, Ti) {
    let qi = [...Cr];
    di.length && (qi = qi.filter((ki) => di.includes(ki.value))), Ti.length && (qi = qi.filter((ki) => !Ti.includes(ki.value))), !di.length && !Ti.length && (qi = Cr), cr(26, ur = qi);
  }
  function gi() {
    let di = [...ur];
    return di = di.filter((Ti) => {
      const qi = String(Er).toLowerCase().trim();
      if (JSON.stringify([Ti.label, Ti.value, Ti.keywords]).toLowerCase().includes(qi))
        return Ti;
    }), di;
  }
  function Ci(di) {
    Sr("selection", di);
  }
  function mi(di) {
    bubble.call(this, lr, di);
  }
  function vi(di) {
    bubble.call(this, lr, di);
  }
  const Ri = (di) => Ci(di);
  return lr.$$set = (di) => {
    cr(34, ar = assign$1(assign$1({}, ar), exclude_internal_props(di))), "input" in di && cr(15, Er = di.input), "options" in di && cr(16, Cr = di.options), "limit" in di && cr(17, Tr = di.limit), "allowlist" in di && cr(18, Ar = di.allowlist), "denylist" in di && cr(19, Ir = di.denylist), "emptyState" in di && cr(0, Mr = di.emptyState), "regionNav" in di && cr(20, Hr = di.regionNav), "regionList" in di && cr(21, Br = di.regionList), "regionItem" in di && cr(22, zr = di.regionItem), "regionButton" in di && cr(23, Gr = di.regionButton), "regionEmpty" in di && cr(24, Xr = di.regionEmpty), "filter" in di && cr(25, Jr = di.filter), "transitions" in di && cr(1, li = di.transitions), "transitionIn" in di && cr(2, Qr = di.transitionIn), "transitionInParams" in di && cr(3, ei = di.transitionInParams), "transitionOut" in di && cr(4, ui = di.transitionOut), "transitionOutParams" in di && cr(5, Ai = di.transitionOutParams);
  }, lr.$$.update = () => {
    var di;
    lr.$$.dirty[0] & /*options*/
    65536 && cr(26, ur = Cr), lr.$$.dirty[0] & /*allowlist, denylist*/
    786432 && fi(Ar, Ir), lr.$$.dirty[0] & /*input, filter, listedOptions*/
    100696064 && cr(6, fr = Er ? Jr() : ur), lr.$$.dirty[0] & /*limit, optionsFiltered*/
    131136 && cr(13, dr = Tr != null ? Tr : fr.length), cr(12, gr = `${(di = ar.class) != null ? di : ""}`), lr.$$.dirty[0] & /*regionNav*/
    1048576 && cr(11, mr = `${Hr}`), lr.$$.dirty[0] & /*regionList*/
    2097152 && cr(10, vr = `${Br}`), lr.$$.dirty[0] & /*regionItem*/
    4194304 && cr(9, yr = `${zr}`), lr.$$.dirty[0] & /*regionButton*/
    8388608 && cr(8, kr = `${Gr}`), lr.$$.dirty[0] & /*regionEmpty*/
    16777216 && cr(7, _r = `${Xr}`);
  }, ar = exclude_internal_props(ar), [
    Mr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fr,
    _r,
    kr,
    yr,
    vr,
    mr,
    gr,
    dr,
    Ci,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    ur,
    mi,
    vi,
    Ri
  ];
}
class Autocomplete extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$H,
      create_fragment$10,
      safe_not_equal,
      {
        input: 15,
        options: 16,
        limit: 17,
        allowlist: 18,
        denylist: 19,
        emptyState: 0,
        regionNav: 20,
        regionList: 21,
        regionItem: 22,
        regionButton: 23,
        regionEmpty: 24,
        filter: 25,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get input() {
    return this.$$.ctx[15];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get options() {
    return this.$$.ctx[16];
  }
  set options(ar) {
    this.$$set({ options: ar }), flush();
  }
  get limit() {
    return this.$$.ctx[17];
  }
  set limit(ar) {
    this.$$set({ limit: ar }), flush();
  }
  get allowlist() {
    return this.$$.ctx[18];
  }
  set allowlist(ar) {
    this.$$set({ allowlist: ar }), flush();
  }
  get denylist() {
    return this.$$.ctx[19];
  }
  set denylist(ar) {
    this.$$set({ denylist: ar }), flush();
  }
  get emptyState() {
    return this.$$.ctx[0];
  }
  set emptyState(ar) {
    this.$$set({ emptyState: ar }), flush();
  }
  get regionNav() {
    return this.$$.ctx[20];
  }
  set regionNav(ar) {
    this.$$set({ regionNav: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[21];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionItem() {
    return this.$$.ctx[22];
  }
  set regionItem(ar) {
    this.$$set({ regionItem: ar }), flush();
  }
  get regionButton() {
    return this.$$.ctx[23];
  }
  set regionButton(ar) {
    this.$$set({ regionButton: ar }), flush();
  }
  get regionEmpty() {
    return this.$$.ctx[24];
  }
  set regionEmpty(ar) {
    this.$$set({ regionEmpty: ar }), flush();
  }
  get filter() {
    return this.$$.ctx[25];
  }
  set filter(ar) {
    this.$$set({ filter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Autocomplete, { input: {}, options: {}, limit: {}, allowlist: {}, denylist: {}, emptyState: {}, regionNav: {}, regionList: {}, regionItem: {}, regionButton: {}, regionEmpty: {}, filter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function create_else_block$c(lr) {
  let ar, cr, ur = String(
    /*initials*/
    lr[1]
  ).substring(0, 2).toUpperCase() + "", fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("text"), fr = text$3(ur), attr(cr, "x", "50%"), attr(cr, "y", "50%"), attr(cr, "dominant-baseline", "central"), attr(cr, "text-anchor", "middle"), attr(cr, "font-weight", "bold"), attr(cr, "font-size", 150), attr(cr, "class", dr = "avatar-text " + /*fill*/
      lr[2]), attr(ar, "class", "avatar-initials w-full h-full"), attr(ar, "viewBox", "0 0 512 512");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, cr), append(cr, fr);
    },
    p(gr, mr) {
      mr & /*initials*/
      2 && ur !== (ur = String(
        /*initials*/
        gr[1]
      ).substring(0, 2).toUpperCase() + "") && set_data(fr, ur), mr & /*fill*/
      4 && dr !== (dr = "avatar-text " + /*fill*/
      gr[2]) && attr(cr, "class", dr);
    },
    d(gr) {
      gr && detach(ar);
    }
  };
}
function create_if_block$s(lr) {
  var _r;
  let ar, cr, ur, fr, dr, gr, mr, vr, yr = [
    {
      class: cr = "avatar-image " + cImage
    },
    {
      style: ur = /*$$props*/
      (_r = lr[8].style) != null ? _r : ""
    },
    { src: fr = /*src*/
    lr[0] },
    {
      alt: dr = /*$$props*/
      lr[8].alt || ""
    },
    /*prunedRestProps*/
    lr[7]()
  ], kr = {};
  for (let xr = 0; xr < yr.length; xr += 1)
    kr = assign$1(kr, yr[xr]);
  return {
    c() {
      ar = element("img"), set_attributes(ar, kr);
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), mr || (vr = [
        action_destroyer(gr = /*action*/
        lr[4].call(
          null,
          ar,
          /*actionParams*/
          lr[5]
        )),
        listen(
          ar,
          "error",
          /*error_handler*/
          lr[19]
        )
      ], mr = !0);
    },
    p(xr, Sr) {
      var Er;
      set_attributes(ar, kr = get_spread_update(yr, [
        { class: cr },
        Sr & /*$$props*/
        256 && ur !== (ur = /*$$props*/
        (Er = xr[8].style) != null ? Er : "") && { style: ur },
        Sr & /*src*/
        1 && !src_url_equal(ar.src, fr = /*src*/
        xr[0]) && { src: fr },
        Sr & /*$$props*/
        256 && dr !== (dr = /*$$props*/
        xr[8].alt || "") && { alt: dr },
        /*prunedRestProps*/
        xr[7]()
      ])), gr && is_function(gr.update) && Sr & /*actionParams*/
      32 && gr.update.call(
        null,
        /*actionParams*/
        xr[5]
      );
    },
    d(xr) {
      xr && detach(ar), mr = !1, run_all(vr);
    }
  };
}
function create_fragment$$(lr) {
  let ar, cr, ur, fr;
  function dr(vr, yr) {
    return (
      /*src*/
      vr[0] ? create_if_block$s : create_else_block$c
    );
  }
  let gr = dr(lr), mr = gr(lr);
  return {
    c() {
      ar = element("figure"), mr.c(), attr(ar, "class", cr = "avatar " + /*classesBase*/
      lr[6]), attr(ar, "data-testid", "avatar");
    },
    m(vr, yr) {
      insert(vr, ar, yr), mr.m(ar, null), ur || (fr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[15]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[16]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[18]
        )
      ], ur = !0);
    },
    p(vr, [yr]) {
      gr === (gr = dr(vr)) && mr ? mr.p(vr, yr) : (mr.d(1), mr = gr(vr), mr && (mr.c(), mr.m(ar, null))), yr & /*classesBase*/
      64 && cr !== (cr = "avatar " + /*classesBase*/
      vr[6]) && attr(ar, "class", cr);
    },
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar), mr.d(), ur = !1, run_all(fr);
    }
  };
}
let cBase$k = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate", cImage = "w-full h-full object-cover";
function instance$G(lr, ar, cr) {
  let ur;
  const fr = [
    "initials",
    "fill",
    "src",
    "fallback",
    "action",
    "actionParams",
    "background",
    "width",
    "border",
    "rounded",
    "shadow",
    "cursor"
  ];
  let dr = compute_rest_props(ar, fr), { initials: gr = "AB" } = ar, { fill: mr = "fill-token" } = ar, { src: vr = "" } = ar, { fallback: yr = "" } = ar, { action: kr = () => {
  } } = ar, { actionParams: _r = "" } = ar, { background: xr = "bg-surface-400-500-token" } = ar, { width: Sr = "w-16" } = ar, { border: Er = "" } = ar, { rounded: Cr = "rounded-full" } = ar, { shadow: Tr = "" } = ar, { cursor: Ar = "" } = ar;
  function Ir() {
    return delete dr.class, dr;
  }
  function Mr(Xr) {
    bubble.call(this, lr, Xr);
  }
  function Hr(Xr) {
    bubble.call(this, lr, Xr);
  }
  function Br(Xr) {
    bubble.call(this, lr, Xr);
  }
  function zr(Xr) {
    bubble.call(this, lr, Xr);
  }
  const Gr = () => cr(0, vr = yr);
  return lr.$$set = (Xr) => {
    cr(8, ar = assign$1(assign$1({}, ar), exclude_internal_props(Xr))), cr(20, dr = compute_rest_props(ar, fr)), "initials" in Xr && cr(1, gr = Xr.initials), "fill" in Xr && cr(2, mr = Xr.fill), "src" in Xr && cr(0, vr = Xr.src), "fallback" in Xr && cr(3, yr = Xr.fallback), "action" in Xr && cr(4, kr = Xr.action), "actionParams" in Xr && cr(5, _r = Xr.actionParams), "background" in Xr && cr(9, xr = Xr.background), "width" in Xr && cr(10, Sr = Xr.width), "border" in Xr && cr(11, Er = Xr.border), "rounded" in Xr && cr(12, Cr = Xr.rounded), "shadow" in Xr && cr(13, Tr = Xr.shadow), "cursor" in Xr && cr(14, Ar = Xr.cursor);
  }, lr.$$.update = () => {
    var Xr;
    cr(6, ur = `${cBase$k} ${xr} ${Sr} ${Er} ${Cr} ${Tr} ${Ar} ${(Xr = ar.class) != null ? Xr : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    gr,
    mr,
    yr,
    kr,
    _r,
    ur,
    Ir,
    ar,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Mr,
    Hr,
    Br,
    zr,
    Gr
  ];
}
class Avatar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$G, create_fragment$$, safe_not_equal, {
      initials: 1,
      fill: 2,
      src: 0,
      fallback: 3,
      action: 4,
      actionParams: 5,
      background: 9,
      width: 10,
      border: 11,
      rounded: 12,
      shadow: 13,
      cursor: 14
    });
  }
  get initials() {
    return this.$$.ctx[1];
  }
  set initials(ar) {
    this.$$set({ initials: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[2];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get src() {
    return this.$$.ctx[0];
  }
  set src(ar) {
    this.$$set({ src: ar }), flush();
  }
  get fallback() {
    return this.$$.ctx[3];
  }
  set fallback(ar) {
    this.$$set({ fallback: ar }), flush();
  }
  get action() {
    return this.$$.ctx[4];
  }
  set action(ar) {
    this.$$set({ action: ar }), flush();
  }
  get actionParams() {
    return this.$$.ctx[5];
  }
  set actionParams(ar) {
    this.$$set({ actionParams: ar }), flush();
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[10];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get border() {
    return this.$$.ctx[11];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[13];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get cursor() {
    return this.$$.ctx[14];
  }
  set cursor(ar) {
    this.$$set({ cursor: ar }), flush();
  }
}
create_custom_element(Avatar, { initials: {}, fill: {}, src: {}, fallback: {}, action: {}, actionParams: {}, background: {}, width: {}, border: {}, rounded: {}, shadow: {}, cursor: {} }, [], [], !0);
const tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      50: { hex: "#f8fafc", rgb: "248 250 252" },
      100: { hex: "#f1f5f9", rgb: "241 245 249" },
      200: { hex: "#e2e8f0", rgb: "226 232 240" },
      300: { hex: "#cbd5e1", rgb: "203 213 225" },
      400: { hex: "#94a3b8", rgb: "148 163 184" },
      500: { hex: "#64748b", rgb: "100 116 139" },
      600: { hex: "#475569", rgb: "71 85 105" },
      700: { hex: "#334155", rgb: "51 65 85" },
      800: { hex: "#1e293b", rgb: "30 41 59" },
      900: { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      50: { hex: "#f9fafb", rgb: "249 250 251" },
      100: { hex: "#f3f4f6", rgb: "243 244 246" },
      200: { hex: "#e5e7eb", rgb: "229 231 235" },
      300: { hex: "#d1d5db", rgb: "209 213 219" },
      400: { hex: "#9ca3af", rgb: "156 163 175" },
      500: { hex: "#6b7280", rgb: "107 114 128" },
      600: { hex: "#4b5563", rgb: "75 85 99" },
      700: { hex: "#374151", rgb: "55 65 81" },
      800: { hex: "#1f2937", rgb: "31 41 55" },
      900: { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f4f4f5", rgb: "244 244 245" },
      200: { hex: "#e4e4e7", rgb: "228 228 231" },
      300: { hex: "#d4d4d8", rgb: "212 212 216" },
      400: { hex: "#a1a1aa", rgb: "161 161 170" },
      500: { hex: "#71717a", rgb: "113 113 122" },
      600: { hex: "#52525b", rgb: "82 82 91" },
      700: { hex: "#3f3f46", rgb: "63 63 70" },
      800: { hex: "#27272a", rgb: "39 39 42" },
      900: { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f5f5f5", rgb: "245 245 245" },
      200: { hex: "#e5e5e5", rgb: "229 229 229" },
      300: { hex: "#d4d4d4", rgb: "212 212 212" },
      400: { hex: "#a3a3a3", rgb: "163 163 163" },
      500: { hex: "#737373", rgb: "115 115 115" },
      600: { hex: "#525252", rgb: "82 82 82" },
      700: { hex: "#404040", rgb: "64 64 64" },
      800: { hex: "#262626", rgb: "38 38 38" },
      900: { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      50: { hex: "#fafaf9", rgb: "250 250 249" },
      100: { hex: "#f5f5f4", rgb: "245 245 244" },
      200: { hex: "#e7e5e4", rgb: "231 229 228" },
      300: { hex: "#d6d3d1", rgb: "214 211 209" },
      400: { hex: "#a8a29e", rgb: "168 162 158" },
      500: { hex: "#78716c", rgb: "120 113 108" },
      600: { hex: "#57534e", rgb: "87 83 78" },
      700: { hex: "#44403c", rgb: "68 64 60" },
      800: { hex: "#292524", rgb: "41 37 36" },
      900: { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      50: { hex: "#fef2f2", rgb: "254 242 242" },
      100: { hex: "#fee2e2", rgb: "254 226 226" },
      200: { hex: "#fecaca", rgb: "254 202 202" },
      300: { hex: "#fca5a5", rgb: "252 165 165" },
      400: { hex: "#f87171", rgb: "248 113 113" },
      500: { hex: "#ef4444", rgb: "239 68 68" },
      600: { hex: "#dc2626", rgb: "220 38 38" },
      700: { hex: "#b91c1c", rgb: "185 28 28" },
      800: { hex: "#991b1b", rgb: "153 27 27" },
      900: { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      50: { hex: "#fff7ed", rgb: "255 247 237" },
      100: { hex: "#ffedd5", rgb: "255 237 213" },
      200: { hex: "#fed7aa", rgb: "254 215 170" },
      300: { hex: "#fdba74", rgb: "253 186 116" },
      400: { hex: "#fb923c", rgb: "251 146 60" },
      500: { hex: "#f97316", rgb: "249 115 22" },
      600: { hex: "#ea580c", rgb: "234 88 12" },
      700: { hex: "#c2410c", rgb: "194 65 12" },
      800: { hex: "#9a3412", rgb: "154 52 18" },
      900: { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      50: { hex: "#fffbeb", rgb: "255 251 235" },
      100: { hex: "#fef3c7", rgb: "254 243 199" },
      200: { hex: "#fde68a", rgb: "253 230 138" },
      300: { hex: "#fcd34d", rgb: "252 211 77" },
      400: { hex: "#fbbf24", rgb: "251 191 36" },
      500: { hex: "#f59e0b", rgb: "245 158 11" },
      600: { hex: "#d97706", rgb: "217 119 6" },
      700: { hex: "#b45309", rgb: "180 83 9" },
      800: { hex: "#92400e", rgb: "146 64 14" },
      900: { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      50: { hex: "#fefce8", rgb: "254 252 232" },
      100: { hex: "#fef9c3", rgb: "254 249 195" },
      200: { hex: "#fef08a", rgb: "254 240 138" },
      300: { hex: "#fde047", rgb: "253 224 71" },
      400: { hex: "#facc15", rgb: "250 204 21" },
      500: { hex: "#eab308", rgb: "234 179 8" },
      600: { hex: "#ca8a04", rgb: "202 138 4" },
      700: { hex: "#a16207", rgb: "161 98 7" },
      800: { hex: "#854d0e", rgb: "133 77 14" },
      900: { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      50: { hex: "#f7fee7", rgb: "247 254 231" },
      100: { hex: "#ecfccb", rgb: "236 252 203" },
      200: { hex: "#d9f99d", rgb: "217 249 157" },
      300: { hex: "#bef264", rgb: "190 242 100" },
      400: { hex: "#a3e635", rgb: "163 230 53" },
      500: { hex: "#84cc16", rgb: "132 204 22" },
      600: { hex: "#65a30d", rgb: "101 163 13" },
      700: { hex: "#4d7c0f", rgb: "77 124 15" },
      800: { hex: "#3f6212", rgb: "63 98 18" },
      900: { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      50: { hex: "#f0fdf4", rgb: "240 253 244" },
      100: { hex: "#dcfce7", rgb: "220 252 231" },
      200: { hex: "#bbf7d0", rgb: "187 247 208" },
      300: { hex: "#86efac", rgb: "134 239 172" },
      400: { hex: "#4ade80", rgb: "74 222 128" },
      500: { hex: "#22c55e", rgb: "34 197 94" },
      600: { hex: "#16a34a", rgb: "22 163 74" },
      700: { hex: "#15803d", rgb: "21 128 61" },
      800: { hex: "#166534", rgb: "22 101 52" },
      900: { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      50: { hex: "#ecfdf5", rgb: "236 253 245" },
      100: { hex: "#d1fae5", rgb: "209 250 229" },
      200: { hex: "#a7f3d0", rgb: "167 243 208" },
      300: { hex: "#6ee7b7", rgb: "110 231 183" },
      400: { hex: "#34d399", rgb: "52 211 153" },
      500: { hex: "#10b981", rgb: "16 185 129" },
      600: { hex: "#059669", rgb: "5 150 105" },
      700: { hex: "#047857", rgb: "4 120 87" },
      800: { hex: "#065f46", rgb: "6 95 70" },
      900: { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      50: { hex: "#f0fdfa", rgb: "240 253 250" },
      100: { hex: "#ccfbf1", rgb: "204 251 241" },
      200: { hex: "#99f6e4", rgb: "153 246 228" },
      300: { hex: "#5eead4", rgb: "94 234 212" },
      400: { hex: "#2dd4bf", rgb: "45 212 191" },
      500: { hex: "#14b8a6", rgb: "20 184 166" },
      600: { hex: "#0d9488", rgb: "13 148 136" },
      700: { hex: "#0f766e", rgb: "15 118 110" },
      800: { hex: "#115e59", rgb: "17 94 89" },
      900: { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      50: { hex: "#ecfeff", rgb: "236 254 255" },
      100: { hex: "#cffafe", rgb: "207 250 254" },
      200: { hex: "#a5f3fc", rgb: "165 243 252" },
      300: { hex: "#67e8f9", rgb: "103 232 249" },
      400: { hex: "#22d3ee", rgb: "34 211 238" },
      500: { hex: "#06b6d4", rgb: "6 182 212" },
      600: { hex: "#0891b2", rgb: "8 145 178" },
      700: { hex: "#0e7490", rgb: "14 116 144" },
      800: { hex: "#155e75", rgb: "21 94 117" },
      900: { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      50: { hex: "#f0f9ff", rgb: "240 249 255" },
      100: { hex: "#e0f2fe", rgb: "224 242 254" },
      200: { hex: "#bae6fd", rgb: "186 230 253" },
      300: { hex: "#7dd3fc", rgb: "125 211 252" },
      400: { hex: "#38bdf8", rgb: "56 189 248" },
      500: { hex: "#0ea5e9", rgb: "14 165 233" },
      600: { hex: "#0284c7", rgb: "2 132 199" },
      700: { hex: "#0369a1", rgb: "3 105 161" },
      800: { hex: "#075985", rgb: "7 89 133" },
      900: { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      50: { hex: "#eff6ff", rgb: "239 246 255" },
      100: { hex: "#dbeafe", rgb: "219 234 254" },
      200: { hex: "#bfdbfe", rgb: "191 219 254" },
      300: { hex: "#93c5fd", rgb: "147 197 253" },
      400: { hex: "#60a5fa", rgb: "96 165 250" },
      500: { hex: "#3b82f6", rgb: "59 130 246" },
      600: { hex: "#2563eb", rgb: "37 99 235" },
      700: { hex: "#1d4ed8", rgb: "29 78 216" },
      800: { hex: "#1e40af", rgb: "30 64 175" },
      900: { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      50: { hex: "#eef2ff", rgb: "238 242 255" },
      100: { hex: "#e0e7ff", rgb: "224 231 255" },
      200: { hex: "#c7d2fe", rgb: "199 210 254" },
      300: { hex: "#a5b4fc", rgb: "165 180 252" },
      400: { hex: "#818cf8", rgb: "129 140 248" },
      500: { hex: "#6366f1", rgb: "99 102 241" },
      600: { hex: "#4f46e5", rgb: "79 70 229" },
      700: { hex: "#4338ca", rgb: "67 56 202" },
      800: { hex: "#3730a3", rgb: "55 48 163" },
      900: { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      50: { hex: "#f5f3ff", rgb: "245 243 255" },
      100: { hex: "#ede9fe", rgb: "237 233 254" },
      200: { hex: "#ddd6fe", rgb: "221 214 254" },
      300: { hex: "#c4b5fd", rgb: "196 181 253" },
      400: { hex: "#a78bfa", rgb: "167 139 250" },
      500: { hex: "#8b5cf6", rgb: "139 92 246" },
      600: { hex: "#7c3aed", rgb: "124 58 237" },
      700: { hex: "#6d28d9", rgb: "109 40 217" },
      800: { hex: "#5b21b6", rgb: "91 33 182" },
      900: { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      50: { hex: "#faf5ff", rgb: "250 245 255" },
      100: { hex: "#f3e8ff", rgb: "243 232 255" },
      200: { hex: "#e9d5ff", rgb: "233 213 255" },
      300: { hex: "#d8b4fe", rgb: "216 180 254" },
      400: { hex: "#c084fc", rgb: "192 132 252" },
      500: { hex: "#a855f7", rgb: "168 85 247" },
      600: { hex: "#9333ea", rgb: "147 51 234" },
      700: { hex: "#7e22ce", rgb: "126 34 206" },
      800: { hex: "#6b21a8", rgb: "107 33 168" },
      900: { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      50: { hex: "#fdf4ff", rgb: "253 244 255" },
      100: { hex: "#fae8ff", rgb: "250 232 255" },
      200: { hex: "#f5d0fe", rgb: "245 208 254" },
      300: { hex: "#f0abfc", rgb: "240 171 252" },
      400: { hex: "#e879f9", rgb: "232 121 249" },
      500: { hex: "#d946ef", rgb: "217 70 239" },
      600: { hex: "#c026d3", rgb: "192 38 211" },
      700: { hex: "#a21caf", rgb: "162 28 175" },
      800: { hex: "#86198f", rgb: "134 25 143" },
      900: { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      50: { hex: "#fdf2f8", rgb: "253 242 248" },
      100: { hex: "#fce7f3", rgb: "252 231 243" },
      200: { hex: "#fbcfe8", rgb: "251 207 232" },
      300: { hex: "#f9a8d4", rgb: "249 168 212" },
      400: { hex: "#f472b6", rgb: "244 114 182" },
      500: { hex: "#ec4899", rgb: "236 72 153" },
      600: { hex: "#db2777", rgb: "219 39 119" },
      700: { hex: "#be185d", rgb: "190 24 93" },
      800: { hex: "#9d174d", rgb: "157 23 77" },
      900: { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      50: { hex: "#fff1f2", rgb: "255 241 242" },
      100: { hex: "#ffe4e6", rgb: "255 228 230" },
      200: { hex: "#fecdd3", rgb: "254 205 211" },
      300: { hex: "#fda4af", rgb: "253 164 175" },
      400: { hex: "#fb7185", rgb: "251 113 133" },
      500: { hex: "#f43f5e", rgb: "244 63 94" },
      600: { hex: "#e11d48", rgb: "225 29 72" },
      700: { hex: "#be123c", rgb: "190 18 60" },
      800: { hex: "#9f1239", rgb: "159 18 57" },
      900: { hex: "#881337", rgb: "136 19 55" }
    }
  }
];
function get_each_context$b(lr, ar, cr) {
  const ur = lr.slice();
  return ur[26] = ar[cr].color, ur[27] = ar[cr].label, ur[28] = ar[cr].value, ur;
}
function create_if_block_2$b(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[17].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[16],
    null
  );
  return {
    c() {
      ar = element("figcaption"), dr && dr.c(), attr(ar, "class", cr = "conic-caption " + /*classesCaption*/
      lr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      65536) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[16],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[16],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[16]
        ),
        null
      ), (!ur || mr & /*classesCaption*/
      128 && cr !== (cr = "conic-caption " + /*classesCaption*/
      gr[7])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_if_block_1$e(lr) {
  let ar, cr;
  return {
    c() {
      ar = element("div"), attr(ar, "class", cr = "conic-cone " + /*classesCone*/
      lr[6]), toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        lr[1]
      ), set_style(
        ar,
        "background",
        /*cone*/
        lr[3]
      );
    },
    m(ur, fr) {
      insert(ur, ar, fr);
    },
    p(ur, fr) {
      fr & /*classesCone*/
      64 && cr !== (cr = "conic-cone " + /*classesCone*/
      ur[6]) && attr(ar, "class", cr), fr & /*classesCone, spin*/
      66 && toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        ur[1]
      ), fr & /*cone*/
      8 && set_style(
        ar,
        "background",
        /*cone*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block$r(lr) {
  let ar, cr, ur = ensure_array_like(
    /*generatedLegendList*/
    lr[4]
  ), fr = [];
  for (let dr = 0; dr < ur.length; dr += 1)
    fr[dr] = create_each_block$b(get_each_context$b(lr, ur, dr));
  return {
    c() {
      ar = element("ul");
      for (let dr = 0; dr < fr.length; dr += 1)
        fr[dr].c();
      attr(ar, "class", cr = "conic-list list " + /*classesLegend*/
      lr[5]);
    },
    m(dr, gr) {
      insert(dr, ar, gr);
      for (let mr = 0; mr < fr.length; mr += 1)
        fr[mr] && fr[mr].m(ar, null);
    },
    p(dr, gr) {
      if (gr & /*hover, generatedLegendList, cSwatch*/
      20) {
        ur = ensure_array_like(
          /*generatedLegendList*/
          dr[4]
        );
        let mr;
        for (mr = 0; mr < ur.length; mr += 1) {
          const vr = get_each_context$b(dr, ur, mr);
          fr[mr] ? fr[mr].p(vr, gr) : (fr[mr] = create_each_block$b(vr), fr[mr].c(), fr[mr].m(ar, null));
        }
        for (; mr < fr.length; mr += 1)
          fr[mr].d(1);
        fr.length = ur.length;
      }
      gr & /*classesLegend*/
      32 && cr !== (cr = "conic-list list " + /*classesLegend*/
      dr[5]) && attr(ar, "class", cr);
    },
    d(dr) {
      dr && detach(ar), destroy_each(fr, dr);
    }
  };
}
function create_each_block$b(lr) {
  let ar, cr, ur, fr, dr = (
    /*label*/
    lr[27] + ""
  ), gr, mr, vr, yr = (
    /*value*/
    lr[28] + ""
  ), kr, _r, xr, Sr, Er, Cr;
  return {
    c() {
      ar = element("li"), cr = element("span"), ur = space(), fr = element("span"), gr = text$3(dr), mr = space(), vr = element("strong"), kr = text$3(yr), _r = text$3("%"), xr = space(), attr(cr, "class", "conic-swatch " + cSwatch), set_style(
        cr,
        "background",
        /*color*/
        lr[26]
      ), attr(fr, "class", "conic-label flex-auto"), attr(vr, "class", "conic-value"), attr(ar, "class", Sr = "conic-item " + /*hover*/
      lr[2]);
    },
    m(Tr, Ar) {
      insert(Tr, ar, Ar), append(ar, cr), append(ar, ur), append(ar, fr), append(fr, gr), append(ar, mr), append(ar, vr), append(vr, kr), append(vr, _r), append(ar, xr), Er || (Cr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[20]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[21]
        )
      ], Er = !0);
    },
    p(Tr, Ar) {
      Ar & /*generatedLegendList*/
      16 && set_style(
        cr,
        "background",
        /*color*/
        Tr[26]
      ), Ar & /*generatedLegendList*/
      16 && dr !== (dr = /*label*/
      Tr[27] + "") && set_data(gr, dr), Ar & /*generatedLegendList*/
      16 && yr !== (yr = /*value*/
      Tr[28] + "") && set_data(kr, yr), Ar & /*hover*/
      4 && Sr !== (Sr = "conic-item " + /*hover*/
      Tr[2]) && attr(ar, "class", Sr);
    },
    d(Tr) {
      Tr && detach(ar), Er = !1, run_all(Cr);
    }
  };
}
function create_fragment$_(lr) {
  let ar, cr, ur, fr, dr, gr = (
    /*$$slots*/
    lr[9].default && create_if_block_2$b(lr)
  ), mr = (
    /*cone*/
    lr[3] && create_if_block_1$e(lr)
  ), vr = (
    /*legend*/
    lr[0] && /*generatedLegendList*/
    lr[4] && create_if_block$r(lr)
  );
  return {
    c() {
      ar = element("figure"), gr && gr.c(), cr = space(), mr && mr.c(), ur = space(), vr && vr.c(), attr(ar, "class", fr = "conic-gradient " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "conic-gradient");
    },
    m(yr, kr) {
      insert(yr, ar, kr), gr && gr.m(ar, null), append(ar, cr), mr && mr.m(ar, null), append(ar, ur), vr && vr.m(ar, null), dr = !0;
    },
    p(yr, [kr]) {
      /*$$slots*/
      yr[9].default ? gr ? (gr.p(yr, kr), kr & /*$$slots*/
      512 && transition_in(gr, 1)) : (gr = create_if_block_2$b(yr), gr.c(), transition_in(gr, 1), gr.m(ar, cr)) : gr && (group_outros(), transition_out(gr, 1, 1, () => {
        gr = null;
      }), check_outros()), /*cone*/
      yr[3] ? mr ? mr.p(yr, kr) : (mr = create_if_block_1$e(yr), mr.c(), mr.m(ar, ur)) : mr && (mr.d(1), mr = null), /*legend*/
      yr[0] && /*generatedLegendList*/
      yr[4] ? vr ? vr.p(yr, kr) : (vr = create_if_block$r(yr), vr.c(), vr.m(ar, null)) : vr && (vr.d(1), vr = null), (!dr || kr & /*classesBase*/
      256 && fr !== (fr = "conic-gradient " + /*classesBase*/
      yr[8])) && attr(ar, "class", fr);
    },
    i(yr) {
      dr || (transition_in(gr), dr = !0);
    },
    o(yr) {
      transition_out(gr), dr = !1;
    },
    d(yr) {
      yr && detach(ar), gr && gr.d(), mr && mr.d(), vr && vr.d();
    }
  };
}
const cBase$j = "flex flex-col items-center space-y-4 w-", cCaption = "text-center", cCone = "block aspect-square rounded-full", cLegend = "text-sm w-full", cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance$F(lr, ar, cr) {
  let ur, fr, dr, gr, { $$slots: mr = {}, $$scope: vr } = ar;
  const yr = compute_slots(mr);
  let { stops: kr = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = ar, { legend: _r = !1 } = ar, { spin: xr = !1 } = ar, { width: Sr = "w-24" } = ar, { hover: Er = "bg-primary-hover-token" } = ar, { digits: Cr = 0 } = ar, { regionCaption: Tr = "" } = ar, { regionCone: Ar = "" } = ar, { regionLegend: Ir = "" } = ar, Mr, Hr;
  function Br(ei) {
    if (typeof ei == "string")
      return ei;
    const ui = tailwindDefaultColors.find((Ai) => Ai.label === ei[0]);
    return ui == null ? void 0 : ui.shades[ei[1]].hex;
  }
  function zr() {
    let ei = kr.map((ui) => `${Br(ui.color)} ${ui.start}% ${ui.end}%`);
    cr(3, Mr = `conic-gradient(${ei.join(", ")})`);
  }
  function Gr() {
    _r && cr(4, Hr = kr.map((ei) => ({
      label: ei.label,
      color: Br(ei.color),
      value: (ei.end - ei.start).toFixed(Cr)
    })));
  }
  afterUpdate(() => {
    zr(), Gr();
  });
  function Xr(ei) {
    bubble.call(this, lr, ei);
  }
  function Jr(ei) {
    bubble.call(this, lr, ei);
  }
  function li(ei) {
    bubble.call(this, lr, ei);
  }
  function Qr(ei) {
    bubble.call(this, lr, ei);
  }
  return lr.$$set = (ei) => {
    cr(25, ar = assign$1(assign$1({}, ar), exclude_internal_props(ei))), "stops" in ei && cr(10, kr = ei.stops), "legend" in ei && cr(0, _r = ei.legend), "spin" in ei && cr(1, xr = ei.spin), "width" in ei && cr(11, Sr = ei.width), "hover" in ei && cr(2, Er = ei.hover), "digits" in ei && cr(12, Cr = ei.digits), "regionCaption" in ei && cr(13, Tr = ei.regionCaption), "regionCone" in ei && cr(14, Ar = ei.regionCone), "regionLegend" in ei && cr(15, Ir = ei.regionLegend), "$$scope" in ei && cr(16, vr = ei.$$scope);
  }, lr.$$.update = () => {
    var ei;
    cr(8, ur = `${cBase$j} ${(ei = ar.class) != null ? ei : ""}`), lr.$$.dirty & /*regionCaption*/
    8192 && cr(7, fr = `${cCaption} ${Tr}`), lr.$$.dirty & /*width, regionCone*/
    18432 && cr(6, dr = `${cCone} ${Sr} ${Ar}`), lr.$$.dirty & /*regionLegend*/
    32768 && cr(5, gr = `${cLegend} ${Ir}`);
  }, ar = exclude_internal_props(ar), [
    _r,
    xr,
    Er,
    Mr,
    Hr,
    gr,
    dr,
    fr,
    ur,
    yr,
    kr,
    Sr,
    Cr,
    Tr,
    Ar,
    Ir,
    vr,
    mr,
    Xr,
    Jr,
    li,
    Qr
  ];
}
class ConicGradient extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$F, create_fragment$_, safe_not_equal, {
      stops: 10,
      legend: 0,
      spin: 1,
      width: 11,
      hover: 2,
      digits: 12,
      regionCaption: 13,
      regionCone: 14,
      regionLegend: 15
    });
  }
  get stops() {
    return this.$$.ctx[10];
  }
  set stops(ar) {
    this.$$set({ stops: ar }), flush();
  }
  get legend() {
    return this.$$.ctx[0];
  }
  set legend(ar) {
    this.$$set({ legend: ar }), flush();
  }
  get spin() {
    return this.$$.ctx[1];
  }
  set spin(ar) {
    this.$$set({ spin: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[2];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get digits() {
    return this.$$.ctx[12];
  }
  set digits(ar) {
    this.$$set({ digits: ar }), flush();
  }
  get regionCaption() {
    return this.$$.ctx[13];
  }
  set regionCaption(ar) {
    this.$$set({ regionCaption: ar }), flush();
  }
  get regionCone() {
    return this.$$.ctx[14];
  }
  set regionCone(ar) {
    this.$$set({ regionCone: ar }), flush();
  }
  get regionLegend() {
    return this.$$.ctx[15];
  }
  set regionLegend(ar) {
    this.$$set({ regionLegend: ar }), flush();
  }
}
create_custom_element(ConicGradient, { stops: {}, legend: { type: "Boolean" }, spin: { type: "Boolean" }, width: {}, hover: {}, digits: {}, regionCaption: {}, regionCone: {}, regionLegend: {} }, ["default"], [], !0);
function fallback_block$3(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Select a File");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_fragment$Z(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr = [
    { type: "file" },
    { name: (
      /*name*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[6]()
  ], Sr = {};
  for (let Ar = 0; Ar < xr.length; Ar += 1)
    Sr = assign$1(Sr, xr[Ar]);
  const Er = (
    /*#slots*/
    lr[11].default
  ), Cr = create_slot(
    Er,
    lr,
    /*$$scope*/
    lr[10],
    null
  ), Tr = Cr || fallback_block$3();
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("input"), fr = space(), dr = element("button"), Tr && Tr.c(), set_attributes(ur, Sr), attr(cr, "class", "w-0 h-0 overflow-hidden"), attr(dr, "type", "button"), attr(dr, "class", gr = "file-button-btn " + /*classesButton*/
      lr[3]), dr.disabled = mr = /*$$restProps*/
      lr[7].disabled, attr(ar, "class", vr = "file-button " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "file-button");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), append(cr, ur), ur.autofocus && ur.focus(), lr[16](ur), append(ar, fr), append(ar, dr), Tr && Tr.m(dr, null), yr = !0, kr || (_r = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          lr[17]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          lr[15]
        ),
        listen(
          dr,
          "click",
          /*onButtonClick*/
          lr[5]
        ),
        listen(
          dr,
          "keydown",
          /*keydown_handler*/
          lr[12]
        ),
        listen(
          dr,
          "keyup",
          /*keyup_handler*/
          lr[13]
        ),
        listen(
          dr,
          "keypress",
          /*keypress_handler*/
          lr[14]
        )
      ], kr = !0);
    },
    p(Ar, [Ir]) {
      set_attributes(ur, Sr = get_spread_update(xr, [
        { type: "file" },
        (!yr || Ir & /*name*/
        4) && { name: (
          /*name*/
          Ar[2]
        ) },
        /*prunedRestProps*/
        Ar[6]()
      ])), Cr && Cr.p && (!yr || Ir & /*$$scope*/
      1024) && update_slot_base(
        Cr,
        Er,
        Ar,
        /*$$scope*/
        Ar[10],
        yr ? get_slot_changes(
          Er,
          /*$$scope*/
          Ar[10],
          Ir,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[10]
        ),
        null
      ), (!yr || Ir & /*classesButton*/
      8 && gr !== (gr = "file-button-btn " + /*classesButton*/
      Ar[3])) && attr(dr, "class", gr), (!yr || Ir & /*$$restProps*/
      128 && mr !== (mr = /*$$restProps*/
      Ar[7].disabled)) && (dr.disabled = mr), (!yr || Ir & /*classesBase*/
      16 && vr !== (vr = "file-button " + /*classesBase*/
      Ar[4])) && attr(ar, "class", vr);
    },
    i(Ar) {
      yr || (transition_in(Tr, Ar), yr = !0);
    },
    o(Ar) {
      transition_out(Tr, Ar), yr = !1;
    },
    d(Ar) {
      Ar && detach(ar), lr[16](null), Tr && Tr.d(Ar), kr = !1, run_all(_r);
    }
  };
}
function instance$E(lr, ar, cr) {
  let ur, fr;
  const dr = ["files", "fileInput", "name", "width", "button"];
  let gr = compute_rest_props(ar, dr), { $$slots: mr = {}, $$scope: vr } = ar, { files: yr = void 0 } = ar, { fileInput: kr = void 0 } = ar, { name: _r } = ar, { width: xr = "" } = ar, { button: Sr = "btn variant-filled" } = ar;
  function Er() {
    kr && kr.click();
  }
  function Cr() {
    return delete gr.class, gr;
  }
  function Tr(zr) {
    bubble.call(this, lr, zr);
  }
  function Ar(zr) {
    bubble.call(this, lr, zr);
  }
  function Ir(zr) {
    bubble.call(this, lr, zr);
  }
  function Mr(zr) {
    bubble.call(this, lr, zr);
  }
  function Hr(zr) {
    binding_callbacks[zr ? "unshift" : "push"](() => {
      kr = zr, cr(1, kr);
    });
  }
  function Br() {
    yr = this.files, cr(0, yr);
  }
  return lr.$$set = (zr) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(zr))), cr(7, gr = compute_rest_props(ar, dr)), "files" in zr && cr(0, yr = zr.files), "fileInput" in zr && cr(1, kr = zr.fileInput), "name" in zr && cr(2, _r = zr.name), "width" in zr && cr(8, xr = zr.width), "button" in zr && cr(9, Sr = zr.button), "$$scope" in zr && cr(10, vr = zr.$$scope);
  }, lr.$$.update = () => {
    var zr;
    cr(4, ur = `${(zr = ar.class) != null ? zr : ""}`), lr.$$.dirty & /*button, width*/
    768 && cr(3, fr = `${Sr} ${xr}`);
  }, ar = exclude_internal_props(ar), [
    yr,
    kr,
    _r,
    fr,
    ur,
    Er,
    Cr,
    gr,
    xr,
    Sr,
    vr,
    mr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br
  ];
}
class FileButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$E, create_fragment$Z, safe_not_equal, {
      files: 0,
      fileInput: 1,
      name: 2,
      width: 8,
      button: 9
    });
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get width() {
    return this.$$.ctx[8];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get button() {
    return this.$$.ctx[9];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
}
create_custom_element(FileButton, { files: {}, fileInput: {}, name: {}, width: {}, button: {} }, ["default"], [], !0);
const get_meta_slot_changes = (lr) => ({}), get_meta_slot_context = (lr) => ({}), get_message_slot_changes = (lr) => ({}), get_message_slot_context = (lr) => ({}), get_lead_slot_changes$4 = (lr) => ({}), get_lead_slot_context$4 = (lr) => ({});
function create_if_block_1$d(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[18].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[17],
    get_lead_slot_context$4
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "dropzone-lead " + /*slotLead*/
      lr[5]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr[0] & /*$$scope*/
      131072) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[17],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[17],
          mr,
          get_lead_slot_changes$4
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[17]
        ),
        get_lead_slot_context$4
      ), (!ur || mr[0] & /*slotLead*/
      32 && cr !== (cr = "dropzone-lead " + /*slotLead*/
      gr[5])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function fallback_block$2(lr) {
  let ar, cr;
  return {
    c() {
      ar = element("strong"), ar.textContent = "Upload a file", cr = text$3(" or drag and drop");
    },
    m(ur, fr) {
      insert(ur, ar, fr), insert(ur, cr, fr);
    },
    p: noop$1,
    d(ur) {
      ur && (detach(ar), detach(cr));
    }
  };
}
function create_if_block$q(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[18].meta
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[17],
    get_meta_slot_context
  );
  return {
    c() {
      ar = element("small"), dr && dr.c(), attr(ar, "class", cr = "dropzone-meta " + /*slotMeta*/
      lr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr[0] & /*$$scope*/
      131072) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[17],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[17],
          mr,
          get_meta_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[17]
        ),
        get_meta_slot_context
      ), (!ur || mr[0] & /*slotMeta*/
      128 && cr !== (cr = "dropzone-meta " + /*slotMeta*/
      gr[7])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$Y(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar = [
    { type: "file" },
    { name: (
      /*name*/
      lr[2]
    ) },
    {
      class: ur = "dropzone-input " + /*classesInput*/
      lr[9]
    },
    /*prunedRestProps*/
    lr[11]()
  ], Ir = {};
  for (let Xr = 0; Xr < Ar.length; Xr += 1)
    Ir = assign$1(Ir, Ar[Xr]);
  let Mr = (
    /*$$slots*/
    lr[13].lead && create_if_block_1$d(lr)
  );
  const Hr = (
    /*#slots*/
    lr[18].message
  ), Br = create_slot(
    Hr,
    lr,
    /*$$scope*/
    lr[17],
    get_message_slot_context
  ), zr = Br || fallback_block$2();
  let Gr = (
    /*$$slots*/
    lr[13].meta && create_if_block$q(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("input"), fr = space(), dr = element("div"), gr = element("div"), Mr && Mr.c(), mr = space(), vr = element("div"), zr && zr.c(), kr = space(), Gr && Gr.c(), set_attributes(cr, Ir), attr(vr, "class", yr = "dropzone-message " + /*slotMessage*/
      lr[6]), attr(gr, "class", _r = "dropzone-interface-text " + /*regionInterfaceText*/
      lr[4]), attr(dr, "class", xr = "dropzone-interface " + /*classesInterface*/
      lr[8] + " " + /*regionInterface*/
      lr[3]), attr(ar, "class", Sr = "dropzone " + /*classesBase*/
      lr[10]), attr(ar, "data-testid", "file-dropzone"), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        lr[12].disabled
      );
    },
    m(Xr, Jr) {
      insert(Xr, ar, Jr), append(ar, cr), cr.autofocus && cr.focus(), lr[32](cr), append(ar, fr), append(ar, dr), append(dr, gr), Mr && Mr.m(gr, null), append(gr, mr), append(gr, vr), zr && zr.m(vr, null), append(gr, kr), Gr && Gr.m(gr, null), Er = !0, Cr || (Tr = [
        listen(
          cr,
          "change",
          /*input_change_handler*/
          lr[31]
        ),
        listen(
          cr,
          "change",
          /*change_handler*/
          lr[19]
        ),
        listen(
          cr,
          "dragenter",
          /*dragenter_handler*/
          lr[20]
        ),
        listen(
          cr,
          "dragover",
          /*dragover_handler*/
          lr[21]
        ),
        listen(
          cr,
          "dragleave",
          /*dragleave_handler*/
          lr[22]
        ),
        listen(
          cr,
          "drop",
          /*drop_handler*/
          lr[23]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[25]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[26]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[27]
        ),
        listen(
          cr,
          "focus",
          /*focus_handler*/
          lr[28]
        ),
        listen(
          cr,
          "focusin",
          /*focusin_handler*/
          lr[29]
        ),
        listen(
          cr,
          "focusout",
          /*focusout_handler*/
          lr[30]
        )
      ], Cr = !0);
    },
    p(Xr, Jr) {
      set_attributes(cr, Ir = get_spread_update(Ar, [
        { type: "file" },
        (!Er || Jr[0] & /*name*/
        4) && { name: (
          /*name*/
          Xr[2]
        ) },
        (!Er || Jr[0] & /*classesInput*/
        512 && ur !== (ur = "dropzone-input " + /*classesInput*/
        Xr[9])) && { class: ur },
        /*prunedRestProps*/
        Xr[11]()
      ])), /*$$slots*/
      Xr[13].lead ? Mr ? (Mr.p(Xr, Jr), Jr[0] & /*$$slots*/
      8192 && transition_in(Mr, 1)) : (Mr = create_if_block_1$d(Xr), Mr.c(), transition_in(Mr, 1), Mr.m(gr, mr)) : Mr && (group_outros(), transition_out(Mr, 1, 1, () => {
        Mr = null;
      }), check_outros()), Br && Br.p && (!Er || Jr[0] & /*$$scope*/
      131072) && update_slot_base(
        Br,
        Hr,
        Xr,
        /*$$scope*/
        Xr[17],
        Er ? get_slot_changes(
          Hr,
          /*$$scope*/
          Xr[17],
          Jr,
          get_message_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Xr[17]
        ),
        get_message_slot_context
      ), (!Er || Jr[0] & /*slotMessage*/
      64 && yr !== (yr = "dropzone-message " + /*slotMessage*/
      Xr[6])) && attr(vr, "class", yr), /*$$slots*/
      Xr[13].meta ? Gr ? (Gr.p(Xr, Jr), Jr[0] & /*$$slots*/
      8192 && transition_in(Gr, 1)) : (Gr = create_if_block$q(Xr), Gr.c(), transition_in(Gr, 1), Gr.m(gr, null)) : Gr && (group_outros(), transition_out(Gr, 1, 1, () => {
        Gr = null;
      }), check_outros()), (!Er || Jr[0] & /*regionInterfaceText*/
      16 && _r !== (_r = "dropzone-interface-text " + /*regionInterfaceText*/
      Xr[4])) && attr(gr, "class", _r), (!Er || Jr[0] & /*classesInterface, regionInterface*/
      264 && xr !== (xr = "dropzone-interface " + /*classesInterface*/
      Xr[8] + " " + /*regionInterface*/
      Xr[3])) && attr(dr, "class", xr), (!Er || Jr[0] & /*classesBase*/
      1024 && Sr !== (Sr = "dropzone " + /*classesBase*/
      Xr[10])) && attr(ar, "class", Sr), (!Er || Jr[0] & /*classesBase, $$restProps*/
      5120) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Xr[12].disabled
      );
    },
    i(Xr) {
      Er || (transition_in(Mr), transition_in(zr, Xr), transition_in(Gr), Er = !0);
    },
    o(Xr) {
      transition_out(Mr), transition_out(zr, Xr), transition_out(Gr), Er = !1;
    },
    d(Xr) {
      Xr && detach(ar), lr[32](null), Mr && Mr.d(), zr && zr.d(Xr), Gr && Gr.d(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$i = "textarea relative flex justify-center items-center", cInput = "w-full absolute top-0 left-0 right-0 bottom-0 z-[1] opacity-0 disabled:!opacity-0 cursor-pointer", cInterface$2 = "flex justify-center items-center text-center";
function instance$D(lr, ar, cr) {
  let ur, fr, dr;
  const gr = [
    "files",
    "fileInput",
    "name",
    "border",
    "padding",
    "rounded",
    "regionInterface",
    "regionInterfaceText",
    "slotLead",
    "slotMessage",
    "slotMeta"
  ];
  let mr = compute_rest_props(ar, gr), { $$slots: vr = {}, $$scope: yr } = ar;
  const kr = compute_slots(vr);
  let { files: _r = void 0 } = ar, { fileInput: xr = void 0 } = ar, { name: Sr } = ar, { border: Er = "border-2 border-dashed" } = ar, { padding: Cr = "p-4 py-8" } = ar, { rounded: Tr = "rounded-container-token" } = ar, { regionInterface: Ar = "" } = ar, { regionInterfaceText: Ir = "" } = ar, { slotLead: Mr = "mb-4" } = ar, { slotMessage: Hr = "" } = ar, { slotMeta: Br = "opacity-75" } = ar;
  function zr() {
    return delete mr.class, mr;
  }
  function Gr(di) {
    bubble.call(this, lr, di);
  }
  function Xr(di) {
    bubble.call(this, lr, di);
  }
  function Jr(di) {
    bubble.call(this, lr, di);
  }
  function li(di) {
    bubble.call(this, lr, di);
  }
  function Qr(di) {
    bubble.call(this, lr, di);
  }
  function ei(di) {
    bubble.call(this, lr, di);
  }
  function ui(di) {
    bubble.call(this, lr, di);
  }
  function Ai(di) {
    bubble.call(this, lr, di);
  }
  function fi(di) {
    bubble.call(this, lr, di);
  }
  function gi(di) {
    bubble.call(this, lr, di);
  }
  function Ci(di) {
    bubble.call(this, lr, di);
  }
  function mi(di) {
    bubble.call(this, lr, di);
  }
  function vi() {
    _r = this.files, cr(0, _r);
  }
  function Ri(di) {
    binding_callbacks[di ? "unshift" : "push"](() => {
      xr = di, cr(1, xr);
    });
  }
  return lr.$$set = (di) => {
    cr(33, ar = assign$1(assign$1({}, ar), exclude_internal_props(di))), cr(12, mr = compute_rest_props(ar, gr)), "files" in di && cr(0, _r = di.files), "fileInput" in di && cr(1, xr = di.fileInput), "name" in di && cr(2, Sr = di.name), "border" in di && cr(14, Er = di.border), "padding" in di && cr(15, Cr = di.padding), "rounded" in di && cr(16, Tr = di.rounded), "regionInterface" in di && cr(3, Ar = di.regionInterface), "regionInterfaceText" in di && cr(4, Ir = di.regionInterfaceText), "slotLead" in di && cr(5, Mr = di.slotLead), "slotMessage" in di && cr(6, Hr = di.slotMessage), "slotMeta" in di && cr(7, Br = di.slotMeta), "$$scope" in di && cr(17, yr = di.$$scope);
  }, lr.$$.update = () => {
    var di;
    cr(10, ur = `${cBase$i} ${Er} ${Cr} ${Tr} ${(di = ar.class) != null ? di : ""}`);
  }, cr(9, fr = `${cInput}`), cr(8, dr = `${cInterface$2}`), ar = exclude_internal_props(ar), [
    _r,
    xr,
    Sr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    dr,
    fr,
    ur,
    zr,
    mr,
    kr,
    Er,
    Cr,
    Tr,
    yr,
    vr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    Ri
  ];
}
class FileDropzone extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$D,
      create_fragment$Y,
      safe_not_equal,
      {
        files: 0,
        fileInput: 1,
        name: 2,
        border: 14,
        padding: 15,
        rounded: 16,
        regionInterface: 3,
        regionInterfaceText: 4,
        slotLead: 5,
        slotMessage: 6,
        slotMeta: 7
      },
      null,
      [-1, -1]
    );
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[15];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[16];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionInterface() {
    return this.$$.ctx[3];
  }
  set regionInterface(ar) {
    this.$$set({ regionInterface: ar }), flush();
  }
  get regionInterfaceText() {
    return this.$$.ctx[4];
  }
  set regionInterfaceText(ar) {
    this.$$set({ regionInterfaceText: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[5];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotMessage() {
    return this.$$.ctx[6];
  }
  set slotMessage(ar) {
    this.$$set({ slotMessage: ar }), flush();
  }
  get slotMeta() {
    return this.$$.ctx[7];
  }
  set slotMeta(ar) {
    this.$$set({ slotMeta: ar }), flush();
  }
}
create_custom_element(FileDropzone, { files: {}, fileInput: {}, name: {}, border: {}, padding: {}, rounded: {}, regionInterface: {}, regionInterfaceText: {}, slotLead: {}, slotMessage: {}, slotMeta: {} }, ["lead", "message", "meta"], [], !0);
function flip(lr, { from: ar, to: cr }, ur = {}) {
  const fr = getComputedStyle(lr), dr = fr.transform === "none" ? "" : fr.transform, [gr, mr] = fr.transformOrigin.split(" ").map(parseFloat), vr = ar.left + ar.width * gr / cr.width - (cr.left + gr), yr = ar.top + ar.height * mr / cr.height - (cr.top + mr), { delay: kr = 0, duration: _r = (Sr) => Math.sqrt(Sr) * 120, easing: xr = cubicOut } = ur;
  return {
    delay: kr,
    duration: is_function(_r) ? _r(Math.sqrt(vr * vr + yr * yr)) : _r,
    easing: xr,
    css: (Sr, Er) => {
      const Cr = Er * vr, Tr = Er * yr, Ar = Sr + Er * ar.width / cr.width, Ir = Sr + Er * ar.height / cr.height;
      return `transform: ${dr} translate(${Cr}px, ${Tr}px) scale(${Ar}, ${Ir});`;
    }
  };
}
function get_each_context$a(lr, ar, cr) {
  const ur = lr.slice();
  return ur[56] = ar[cr].id, ur[57] = ar[cr].val, ur[59] = cr, ur;
}
function get_each_context_1$4(lr, ar, cr) {
  const ur = lr.slice();
  return ur[60] = ar[cr], ur;
}
function create_each_block_1$4(lr) {
  let ar, cr = (
    /*option*/
    lr[60] + ""
  ), ur, fr;
  return {
    c() {
      ar = element("option"), ur = text$3(cr), ar.__value = fr = /*option*/
      lr[60], set_input_value(ar, ar.__value);
    },
    m(dr, gr) {
      insert(dr, ar, gr), append(ar, ur);
    },
    p(dr, gr) {
      gr[0] & /*value*/
      1 && cr !== (cr = /*option*/
      dr[60] + "") && set_data(ur, cr), gr[0] & /*value*/
      1 && fr !== (fr = /*option*/
      dr[60]) && (ar.__value = fr, set_input_value(ar, ar.__value));
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block$p(lr) {
  let ar, cr = [], ur = /* @__PURE__ */ new Map(), fr, dr, gr, mr, vr = ensure_array_like(
    /*chipValues*/
    lr[15]
  );
  const yr = (kr) => (
    /*id*/
    kr[56]
  );
  for (let kr = 0; kr < vr.length; kr += 1) {
    let _r = get_each_context$a(lr, vr, kr), xr = yr(_r);
    ur.set(xr, cr[kr] = create_each_block$a(xr, _r));
  }
  return {
    c() {
      ar = element("div");
      for (let kr = 0; kr < cr.length; kr += 1)
        cr[kr].c();
      attr(ar, "class", fr = "input-chip-list " + /*classesChipList*/
      lr[18]);
    },
    m(kr, _r) {
      insert(kr, ar, _r);
      for (let xr = 0; xr < cr.length; xr += 1)
        cr[xr] && cr[xr].m(ar, null);
      mr = !0;
    },
    p(kr, _r) {
      if (lr = kr, _r[0] & /*chips, chipTransitionOut, chipTransitionOutParams, transitions, removeChip, chipValues*/
      8446048) {
        vr = ensure_array_like(
          /*chipValues*/
          lr[15]
        ), group_outros();
        for (let xr = 0; xr < cr.length; xr += 1)
          cr[xr].r();
        cr = update_keyed_each(cr, _r, yr, 1, lr, vr, ur, ar, fix_and_outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
        for (let xr = 0; xr < cr.length; xr += 1)
          cr[xr].a();
        check_outros();
      }
      (!mr || _r[0] & /*classesChipList*/
      262144 && fr !== (fr = "input-chip-list " + /*classesChipList*/
      lr[18])) && attr(ar, "class", fr);
    },
    i(kr) {
      if (!mr) {
        for (let _r = 0; _r < vr.length; _r += 1)
          transition_in(cr[_r]);
        kr && add_render_callback(() => {
          mr && (gr && gr.end(1), dr = create_in_transition(ar, dynamicTransition, {
            transition: (
              /*listTransitionIn*/
              lr[7]
            ),
            params: (
              /*listTransitionInParams*/
              lr[8]
            ),
            enabled: (
              /*transitions*/
              lr[6]
            )
          }), dr.start());
        }), mr = !0;
      }
    },
    o(kr) {
      for (let _r = 0; _r < cr.length; _r += 1)
        transition_out(cr[_r]);
      dr && dr.invalidate(), kr && (gr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*listTransitionOut*/
          lr[9]
        ),
        params: (
          /*listTransitionOutParams*/
          lr[10]
        ),
        enabled: (
          /*transitions*/
          lr[6]
        )
      })), mr = !1;
    },
    d(kr) {
      kr && detach(ar);
      for (let _r = 0; _r < cr.length; _r += 1)
        cr[_r].d();
      kr && gr && gr.end();
    }
  };
}
function create_each_block$a(lr, ar) {
  let cr, ur, fr, dr = (
    /*val*/
    ar[57] + ""
  ), gr, mr, vr, yr, kr, _r, xr, Sr, Er = noop$1, Cr, Tr, Ar;
  function Ir(...Mr) {
    return (
      /*click_handler_1*/
      ar[50](
        /*i*/
        ar[59],
        /*val*/
        ar[57],
        ...Mr
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      cr = element("div"), ur = element("button"), fr = element("span"), gr = text$3(dr), mr = space(), vr = element("span"), vr.textContent = "✕", xr = space(), attr(ur, "type", "button"), attr(ur, "class", yr = "chip " + /*chips*/
      ar[5]), this.first = cr;
    },
    m(Mr, Hr) {
      insert(Mr, cr, Hr), append(cr, ur), append(ur, fr), append(fr, gr), append(ur, mr), append(ur, vr), append(cr, xr), Cr = !0, Tr || (Ar = [
        listen(ur, "click", Ir),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[40]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[41]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          ar[42]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          ar[43]
        )
      ], Tr = !0);
    },
    p(Mr, Hr) {
      ar = Mr, (!Cr || Hr[0] & /*chipValues*/
      32768) && dr !== (dr = /*val*/
      ar[57] + "") && set_data(gr, dr), (!Cr || Hr[0] & /*chips*/
      32 && yr !== (yr = "chip " + /*chips*/
      ar[5])) && attr(ur, "class", yr);
    },
    r() {
      Sr = cr.getBoundingClientRect();
    },
    f() {
      fix_position(cr), Er();
    },
    a() {
      Er(), Er = create_animation(cr, Sr, flip, { duration: (
        /*duration*/
        ar[3]
      ) });
    },
    i(Mr) {
      Cr || (Mr && add_render_callback(() => {
        Cr && (_r && _r.end(1), kr = create_in_transition(ur, dynamicTransition, {
          transition: (
            /*chipTransitionIn*/
            ar[11]
          ),
          params: (
            /*chipTransitionInParams*/
            ar[12]
          ),
          enabled: (
            /*transitions*/
            ar[6]
          )
        }), kr.start());
      }), Cr = !0);
    },
    o(Mr) {
      kr && kr.invalidate(), Mr && (_r = create_out_transition(ur, dynamicTransition, {
        transition: (
          /*chipTransitionOut*/
          ar[13]
        ),
        params: (
          /*chipTransitionOutParams*/
          ar[14]
        ),
        enabled: (
          /*transitions*/
          ar[6]
        )
      })), Cr = !1;
    },
    d(Mr) {
      Mr && detach(cr), Mr && _r && _r.end(), Tr = !1, run_all(Ar);
    }
  };
}
function create_fragment$X(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar = ensure_array_like(
    /*value*/
    lr[0]
  ), Ir = [];
  for (let Hr = 0; Hr < Ar.length; Hr += 1)
    Ir[Hr] = create_each_block_1$4(get_each_context_1$4(lr, Ar, Hr));
  let Mr = (
    /*chipValues*/
    lr[15].length && create_if_block$p(lr)
  );
  return {
    c() {
      var Hr;
      ar = element("div"), cr = element("div"), ur = element("select");
      for (let Br = 0; Br < Ir.length; Br += 1)
        Ir[Br].c();
      fr = space(), dr = element("div"), gr = element("form"), mr = element("input"), _r = space(), Mr && Mr.c(), attr(
        ur,
        "name",
        /*name*/
        lr[2]
      ), ur.multiple = !0, ur.required = /*required*/
      lr[4], attr(ur, "tabindex", "-1"), /*value*/
      lr[0] === void 0 && add_render_callback(() => (
        /*select_change_handler*/
        lr[48].call(ur)
      )), attr(cr, "class", "h-0 overflow-hidden"), attr(mr, "type", "text"), attr(mr, "placeholder", vr = /*$$restProps*/
      (Hr = lr[24].placeholder) != null ? Hr : "Enter values..."), attr(mr, "class", yr = "input-chip-field " + /*classesInput*/
      lr[17]), mr.disabled = kr = /*$$restProps*/
      lr[24].disabled, attr(dr, "class", xr = "input-chip-wrapper " + /*classesChipWrapper*/
      lr[19]), attr(ar, "class", Sr = "input-chip " + /*classesBase*/
      lr[20]), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        lr[24].disabled
      );
    },
    m(Hr, Br) {
      insert(Hr, ar, Br), append(ar, cr), append(cr, ur);
      for (let zr = 0; zr < Ir.length; zr += 1)
        Ir[zr] && Ir[zr].m(ur, null);
      lr[47](ur), select_options(
        ur,
        /*value*/
        lr[0]
      ), append(ar, fr), append(ar, dr), append(dr, gr), append(gr, mr), set_input_value(
        mr,
        /*input*/
        lr[1]
      ), append(dr, _r), Mr && Mr.m(dr, null), Er = !0, Cr || (Tr = [
        listen(
          ur,
          "change",
          /*select_change_handler*/
          lr[48]
        ),
        listen(
          mr,
          "input",
          /*input_1_input_handler*/
          lr[49]
        ),
        listen(
          mr,
          "input",
          /*onInputHandler*/
          lr[21]
        ),
        listen(
          mr,
          "input",
          /*input_handler*/
          lr[44]
        ),
        listen(
          mr,
          "focus",
          /*focus_handler*/
          lr[45]
        ),
        listen(
          mr,
          "blur",
          /*blur_handler*/
          lr[46]
        ),
        listen(
          gr,
          "submit",
          /*addChip*/
          lr[22]
        )
      ], Cr = !0);
    },
    p(Hr, Br) {
      var zr;
      if (Br[0] & /*value*/
      1) {
        Ar = ensure_array_like(
          /*value*/
          Hr[0]
        );
        let Gr;
        for (Gr = 0; Gr < Ar.length; Gr += 1) {
          const Xr = get_each_context_1$4(Hr, Ar, Gr);
          Ir[Gr] ? Ir[Gr].p(Xr, Br) : (Ir[Gr] = create_each_block_1$4(Xr), Ir[Gr].c(), Ir[Gr].m(ur, null));
        }
        for (; Gr < Ir.length; Gr += 1)
          Ir[Gr].d(1);
        Ir.length = Ar.length;
      }
      (!Er || Br[0] & /*name*/
      4) && attr(
        ur,
        "name",
        /*name*/
        Hr[2]
      ), (!Er || Br[0] & /*required*/
      16) && (ur.required = /*required*/
      Hr[4]), Br[0] & /*value*/
      1 && select_options(
        ur,
        /*value*/
        Hr[0]
      ), (!Er || Br[0] & /*$$restProps*/
      16777216 && vr !== (vr = /*$$restProps*/
      (zr = Hr[24].placeholder) != null ? zr : "Enter values...")) && attr(mr, "placeholder", vr), (!Er || Br[0] & /*classesInput*/
      131072 && yr !== (yr = "input-chip-field " + /*classesInput*/
      Hr[17])) && attr(mr, "class", yr), (!Er || Br[0] & /*$$restProps*/
      16777216 && kr !== (kr = /*$$restProps*/
      Hr[24].disabled)) && (mr.disabled = kr), Br[0] & /*input*/
      2 && mr.value !== /*input*/
      Hr[1] && set_input_value(
        mr,
        /*input*/
        Hr[1]
      ), /*chipValues*/
      Hr[15].length ? Mr ? (Mr.p(Hr, Br), Br[0] & /*chipValues*/
      32768 && transition_in(Mr, 1)) : (Mr = create_if_block$p(Hr), Mr.c(), transition_in(Mr, 1), Mr.m(dr, null)) : Mr && (group_outros(), transition_out(Mr, 1, 1, () => {
        Mr = null;
      }), check_outros()), (!Er || Br[0] & /*classesChipWrapper*/
      524288 && xr !== (xr = "input-chip-wrapper " + /*classesChipWrapper*/
      Hr[19])) && attr(dr, "class", xr), (!Er || Br[0] & /*classesBase*/
      1048576 && Sr !== (Sr = "input-chip " + /*classesBase*/
      Hr[20])) && attr(ar, "class", Sr), (!Er || Br[0] & /*classesBase, $$restProps*/
      17825792) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Hr[24].disabled
      );
    },
    i(Hr) {
      Er || (transition_in(Mr), Er = !0);
    },
    o(Hr) {
      transition_out(Mr), Er = !1;
    },
    d(Hr) {
      Hr && detach(ar), destroy_each(Ir, Hr), lr[47](null), Mr && Mr.d(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$h = "textarea cursor-pointer", cChipWrapper = "space-y-4", cChipList = "flex flex-wrap gap-2", cInputField = "unstyled bg-transparent border-0 !ring-0 p-0 w-full";
function instance$C(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  const vr = [
    "input",
    "name",
    "value",
    "whitelist",
    "max",
    "minlength",
    "maxlength",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "duration",
    "required",
    "chips",
    "invalid",
    "padding",
    "rounded",
    "regionChipWrapper",
    "regionChipList",
    "regionInput",
    "transitions",
    "listTransitionIn",
    "listTransitionInParams",
    "listTransitionOut",
    "listTransitionOutParams",
    "chipTransitionIn",
    "chipTransitionInParams",
    "chipTransitionOut",
    "chipTransitionOutParams"
  ];
  let yr = compute_rest_props(ar, vr), kr;
  component_subscribe(lr, prefersReducedMotionStore, (Gi) => cr(51, kr = Gi));
  const _r = createEventDispatcher();
  let { input: xr = "" } = ar, { name: Sr } = ar, { value: Er = [] } = ar, { whitelist: Cr = [] } = ar, { max: Tr = -1 } = ar, { minlength: Ar = -1 } = ar, { maxlength: Ir = -1 } = ar, { allowUpperCase: Mr = !1 } = ar, { allowDuplicates: Hr = !1 } = ar, { validation: Br = () => !0 } = ar, { duration: zr = 150 } = ar, { required: Gr = !1 } = ar, { chips: Xr = "variant-filled" } = ar, { invalid: Jr = "input-error" } = ar, { padding: li = "p-2" } = ar, { rounded: Qr = "rounded-container-token" } = ar, { regionChipWrapper: ei = "" } = ar, { regionChipList: ui = "" } = ar, { regionInput: Ai = "" } = ar, { transitions: fi = !kr } = ar, { listTransitionIn: gi = fly } = ar, { listTransitionInParams: Ci = { duration: 150, opacity: 0, y: -20 } } = ar, { listTransitionOut: mi = fly } = ar, { listTransitionOutParams: vi = { duration: 150, opacity: 0, y: -20 } } = ar, { chipTransitionIn: Ri = scale } = ar, { chipTransitionInParams: di = { duration: 150, opacity: 0 } } = ar, { chipTransitionOut: Ti = scale } = ar, { chipTransitionOutParams: qi = { duration: 150, opacity: 0 } } = ar, ki = !0, Ji = (Er == null ? void 0 : Er.map((Gi) => ({ val: Gi, id: Math.random() }))) || [];
  function Bi() {
    cr(0, Er = []);
  }
  let Ni;
  onMount(() => {
    if (!Ni.form)
      return;
    const Gi = Ni.form;
    return Gi.addEventListener("reset", Bi), () => {
      Gi.removeEventListener("reset", Bi);
    };
  });
  function Mi() {
    cr(38, ki = !0);
  }
  function bi() {
    return !(!xr || (cr(1, xr = xr.trim()), Br !== void 0 && !Br(xr)) || Tr !== -1 && Er.length >= Tr || Ar !== -1 && xr.length < Ar || Ir !== -1 && xr.length > Ir || Cr.length > 0 && !Cr.includes(xr) || Hr === !1 && Er.includes(xr));
  }
  function Ei(Gi) {
    if (Gi.preventDefault(), cr(38, ki = bi()), ki === !1) {
      _r("invalid", { event: Gi, input: xr });
      return;
    }
    cr(1, xr = Mr ? xr : xr.toLowerCase()), Er.push(xr), cr(0, Er), Ji.push({ val: xr, id: Math.random() }), cr(15, Ji), cr(0, Er), _r("add", {
      event: Gi,
      chipIndex: Er.length - 1,
      chipValue: xr
    }), cr(1, xr = "");
  }
  function Si(Gi, Ca, $a) {
    yr.disabled || (Er.splice(Ca, 1), cr(0, Er), Ji.splice(Ca, 1), cr(15, Ji), cr(0, Er), _r("remove", { event: Gi, chipIndex: Ca, chipValue: $a }));
  }
  function Vi(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Di(Gi) {
    bubble.call(this, lr, Gi);
  }
  function sa(Gi) {
    bubble.call(this, lr, Gi);
  }
  function ra(Gi) {
    bubble.call(this, lr, Gi);
  }
  function fa(Gi) {
    bubble.call(this, lr, Gi);
  }
  function ba(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Ua(Gi) {
    bubble.call(this, lr, Gi);
  }
  function Va(Gi) {
    binding_callbacks[Gi ? "unshift" : "push"](() => {
      Ni = Gi, cr(16, Ni);
    });
  }
  function Ma() {
    Er = select_multiple_value(this), cr(0, Er);
  }
  function Fi() {
    xr = this.value, cr(1, xr);
  }
  const na = (Gi, Ca, $a) => {
    Si($a, Gi, Ca);
  };
  return lr.$$set = (Gi) => {
    cr(55, ar = assign$1(assign$1({}, ar), exclude_internal_props(Gi))), cr(24, yr = compute_rest_props(ar, vr)), "input" in Gi && cr(1, xr = Gi.input), "name" in Gi && cr(2, Sr = Gi.name), "value" in Gi && cr(0, Er = Gi.value), "whitelist" in Gi && cr(25, Cr = Gi.whitelist), "max" in Gi && cr(26, Tr = Gi.max), "minlength" in Gi && cr(27, Ar = Gi.minlength), "maxlength" in Gi && cr(28, Ir = Gi.maxlength), "allowUpperCase" in Gi && cr(29, Mr = Gi.allowUpperCase), "allowDuplicates" in Gi && cr(30, Hr = Gi.allowDuplicates), "validation" in Gi && cr(31, Br = Gi.validation), "duration" in Gi && cr(3, zr = Gi.duration), "required" in Gi && cr(4, Gr = Gi.required), "chips" in Gi && cr(5, Xr = Gi.chips), "invalid" in Gi && cr(32, Jr = Gi.invalid), "padding" in Gi && cr(33, li = Gi.padding), "rounded" in Gi && cr(34, Qr = Gi.rounded), "regionChipWrapper" in Gi && cr(35, ei = Gi.regionChipWrapper), "regionChipList" in Gi && cr(36, ui = Gi.regionChipList), "regionInput" in Gi && cr(37, Ai = Gi.regionInput), "transitions" in Gi && cr(6, fi = Gi.transitions), "listTransitionIn" in Gi && cr(7, gi = Gi.listTransitionIn), "listTransitionInParams" in Gi && cr(8, Ci = Gi.listTransitionInParams), "listTransitionOut" in Gi && cr(9, mi = Gi.listTransitionOut), "listTransitionOutParams" in Gi && cr(10, vi = Gi.listTransitionOutParams), "chipTransitionIn" in Gi && cr(11, Ri = Gi.chipTransitionIn), "chipTransitionInParams" in Gi && cr(12, di = Gi.chipTransitionInParams), "chipTransitionOut" in Gi && cr(13, Ti = Gi.chipTransitionOut), "chipTransitionOutParams" in Gi && cr(14, qi = Gi.chipTransitionOutParams);
  }, lr.$$.update = () => {
    var Gi;
    lr.$$.dirty[1] & /*inputValid, invalid*/
    130 && cr(39, ur = ki === !1 ? Jr : ""), cr(20, fr = `${cBase$h} ${li} ${Qr} ${(Gi = ar.class) != null ? Gi : ""} ${ur}`), lr.$$.dirty[1] & /*regionChipWrapper*/
    16 && cr(19, dr = `${cChipWrapper} ${ei}`), lr.$$.dirty[1] & /*regionChipList*/
    32 && cr(18, gr = `${cChipList} ${ui}`), lr.$$.dirty[1] & /*regionInput*/
    64 && cr(17, mr = `${cInputField} ${Ai}`), lr.$$.dirty[0] & /*value, chipValues*/
    32769 && cr(15, Ji = (Er == null ? void 0 : Er.map((Ca, $a) => {
      var no;
      return ((no = Ji[$a]) == null ? void 0 : no.val) === Ca ? Ji[$a] : { id: Math.random(), val: Ca };
    })) || []);
  }, ar = exclude_internal_props(ar), [
    Er,
    xr,
    Sr,
    zr,
    Gr,
    Xr,
    fi,
    gi,
    Ci,
    mi,
    vi,
    Ri,
    di,
    Ti,
    qi,
    Ji,
    Ni,
    mr,
    gr,
    dr,
    fr,
    Mi,
    Ei,
    Si,
    yr,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    ki,
    ur,
    Vi,
    Di,
    sa,
    ra,
    fa,
    ba,
    Ua,
    Va,
    Ma,
    Fi,
    na
  ];
}
class InputChip extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$C,
      create_fragment$X,
      safe_not_equal,
      {
        input: 1,
        name: 2,
        value: 0,
        whitelist: 25,
        max: 26,
        minlength: 27,
        maxlength: 28,
        allowUpperCase: 29,
        allowDuplicates: 30,
        validation: 31,
        duration: 3,
        required: 4,
        chips: 5,
        invalid: 32,
        padding: 33,
        rounded: 34,
        regionChipWrapper: 35,
        regionChipList: 36,
        regionInput: 37,
        transitions: 6,
        listTransitionIn: 7,
        listTransitionInParams: 8,
        listTransitionOut: 9,
        listTransitionOutParams: 10,
        chipTransitionIn: 11,
        chipTransitionInParams: 12,
        chipTransitionOut: 13,
        chipTransitionOutParams: 14
      },
      null,
      [-1, -1, -1]
    );
  }
  get input() {
    return this.$$.ctx[1];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get whitelist() {
    return this.$$.ctx[25];
  }
  set whitelist(ar) {
    this.$$set({ whitelist: ar }), flush();
  }
  get max() {
    return this.$$.ctx[26];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get minlength() {
    return this.$$.ctx[27];
  }
  set minlength(ar) {
    this.$$set({ minlength: ar }), flush();
  }
  get maxlength() {
    return this.$$.ctx[28];
  }
  set maxlength(ar) {
    this.$$set({ maxlength: ar }), flush();
  }
  get allowUpperCase() {
    return this.$$.ctx[29];
  }
  set allowUpperCase(ar) {
    this.$$set({ allowUpperCase: ar }), flush();
  }
  get allowDuplicates() {
    return this.$$.ctx[30];
  }
  set allowDuplicates(ar) {
    this.$$set({ allowDuplicates: ar }), flush();
  }
  get validation() {
    return this.$$.ctx[31];
  }
  set validation(ar) {
    this.$$set({ validation: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[3];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get required() {
    return this.$$.ctx[4];
  }
  set required(ar) {
    this.$$set({ required: ar }), flush();
  }
  get chips() {
    return this.$$.ctx[5];
  }
  set chips(ar) {
    this.$$set({ chips: ar }), flush();
  }
  get invalid() {
    return this.$$.ctx[32];
  }
  set invalid(ar) {
    this.$$set({ invalid: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[33];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionChipWrapper() {
    return this.$$.ctx[35];
  }
  set regionChipWrapper(ar) {
    this.$$set({ regionChipWrapper: ar }), flush();
  }
  get regionChipList() {
    return this.$$.ctx[36];
  }
  set regionChipList(ar) {
    this.$$set({ regionChipList: ar }), flush();
  }
  get regionInput() {
    return this.$$.ctx[37];
  }
  set regionInput(ar) {
    this.$$set({ regionInput: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[6];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get listTransitionIn() {
    return this.$$.ctx[7];
  }
  set listTransitionIn(ar) {
    this.$$set({ listTransitionIn: ar }), flush();
  }
  get listTransitionInParams() {
    return this.$$.ctx[8];
  }
  set listTransitionInParams(ar) {
    this.$$set({ listTransitionInParams: ar }), flush();
  }
  get listTransitionOut() {
    return this.$$.ctx[9];
  }
  set listTransitionOut(ar) {
    this.$$set({ listTransitionOut: ar }), flush();
  }
  get listTransitionOutParams() {
    return this.$$.ctx[10];
  }
  set listTransitionOutParams(ar) {
    this.$$set({ listTransitionOutParams: ar }), flush();
  }
  get chipTransitionIn() {
    return this.$$.ctx[11];
  }
  set chipTransitionIn(ar) {
    this.$$set({ chipTransitionIn: ar }), flush();
  }
  get chipTransitionInParams() {
    return this.$$.ctx[12];
  }
  set chipTransitionInParams(ar) {
    this.$$set({ chipTransitionInParams: ar }), flush();
  }
  get chipTransitionOut() {
    return this.$$.ctx[13];
  }
  set chipTransitionOut(ar) {
    this.$$set({ chipTransitionOut: ar }), flush();
  }
  get chipTransitionOutParams() {
    return this.$$.ctx[14];
  }
  set chipTransitionOutParams(ar) {
    this.$$set({ chipTransitionOutParams: ar }), flush();
  }
}
create_custom_element(InputChip, { input: {}, name: {}, value: {}, whitelist: {}, max: {}, minlength: {}, maxlength: {}, allowUpperCase: { type: "Boolean" }, allowDuplicates: { type: "Boolean" }, validation: {}, duration: {}, required: { type: "Boolean" }, chips: {}, invalid: {}, padding: {}, rounded: {}, regionChipWrapper: {}, regionChipList: {}, regionInput: {}, transitions: {}, listTransitionIn: {}, listTransitionInParams: {}, listTransitionOut: {}, listTransitionOutParams: {}, chipTransitionIn: {}, chipTransitionInParams: {}, chipTransitionOut: {}, chipTransitionOutParams: {} }, [], [], !0);
function create_fragment$W(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[12].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[11],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox " + /*classesBase*/
      lr[1]), attr(ar, "role", "listbox"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(ar, "data-testid", "listbox");
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      2048) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[11],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[11],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[11]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      2 && cr !== (cr = "listbox " + /*classesBase*/
      gr[1])) && attr(ar, "class", cr), (!ur || mr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        gr[0]
      );
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
const cBase$g = "";
function instance$B(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { multiple: gr = !1 } = ar, { spacing: mr = "space-y-1" } = ar, { rounded: vr = "rounded-token" } = ar, { active: yr = "variant-filled" } = ar, { hover: kr = "hover:variant-soft" } = ar, { padding: _r = "px-4 py-2" } = ar, { regionLead: xr = "" } = ar, { regionDefault: Sr = "" } = ar, { regionTrail: Er = "" } = ar, { labelledby: Cr = "" } = ar;
  return setContext("multiple", gr), setContext("rounded", vr), setContext("active", yr), setContext("hover", kr), setContext("padding", _r), setContext("regionLead", xr), setContext("regionDefault", Sr), setContext("regionTrail", Er), lr.$$set = (Tr) => {
    cr(13, ar = assign$1(assign$1({}, ar), exclude_internal_props(Tr))), "multiple" in Tr && cr(2, gr = Tr.multiple), "spacing" in Tr && cr(3, mr = Tr.spacing), "rounded" in Tr && cr(4, vr = Tr.rounded), "active" in Tr && cr(5, yr = Tr.active), "hover" in Tr && cr(6, kr = Tr.hover), "padding" in Tr && cr(7, _r = Tr.padding), "regionLead" in Tr && cr(8, xr = Tr.regionLead), "regionDefault" in Tr && cr(9, Sr = Tr.regionDefault), "regionTrail" in Tr && cr(10, Er = Tr.regionTrail), "labelledby" in Tr && cr(0, Cr = Tr.labelledby), "$$scope" in Tr && cr(11, dr = Tr.$$scope);
  }, lr.$$.update = () => {
    var Tr;
    cr(1, ur = `${cBase$g} ${mr} ${vr} ${(Tr = ar.class) != null ? Tr : ""}`);
  }, ar = exclude_internal_props(ar), [
    Cr,
    ur,
    gr,
    mr,
    vr,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    dr,
    fr
  ];
}
class ListBox extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$B, create_fragment$W, safe_not_equal, {
      multiple: 2,
      spacing: 3,
      rounded: 4,
      active: 5,
      hover: 6,
      padding: 7,
      regionLead: 8,
      regionDefault: 9,
      regionTrail: 10,
      labelledby: 0
    });
  }
  get multiple() {
    return this.$$.ctx[2];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[4];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[5];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[9];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[10];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ListBox, { multiple: { type: "Boolean" }, spacing: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, labelledby: {} }, ["default"], [], !0);
const get_trail_slot_changes$1 = (lr) => ({}), get_trail_slot_context$1 = (lr) => ({}), get_lead_slot_changes$3 = (lr) => ({}), get_lead_slot_context$3 = (lr) => ({});
function create_else_block$b(lr) {
  let ar, cr = !1, ur, fr, dr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    lr[35][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        lr[1]
      ), ar.__value = /*value*/
      lr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1"), ur.p(ar);
    },
    m(gr, mr) {
      insert(gr, ar, mr), lr[33](ar), ar.checked = ar.__value === /*group*/
      lr[0], fr || (dr = [
        listen(
          ar,
          "change",
          /*input_change_handler_1*/
          lr[34]
        ),
        listen(
          ar,
          "click",
          /*click_handler_1*/
          lr[29]
        ),
        listen(
          ar,
          "change",
          /*change_handler_1*/
          lr[30]
        )
      ], fr = !0);
    },
    p(gr, mr) {
      mr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        gr[1]
      ), mr[0] & /*value*/
      4 && (ar.__value = /*value*/
      gr[2], set_input_value(ar, ar.__value), cr = !0), (cr || mr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      gr[0]);
    },
    d(gr) {
      gr && detach(ar), lr[33](null), ur.r(), fr = !1, run_all(dr);
    }
  };
}
function create_if_block_2$a(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        lr[1]
      ), ar.__value = /*value*/
      lr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1");
    },
    m(fr, dr) {
      insert(fr, ar, dr), lr[31](ar), ar.checked = /*checked*/
      lr[4], cr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          lr[32]
        ),
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[27]
        ),
        listen(
          ar,
          "change",
          /*change_handler*/
          lr[28]
        )
      ], cr = !0);
    },
    p(fr, dr) {
      dr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        fr[1]
      ), dr[0] & /*value*/
      4 && (ar.__value = /*value*/
      fr[2], set_input_value(ar, ar.__value)), dr[0] & /*checked*/
      16 && (ar.checked = /*checked*/
      fr[4]);
    },
    d(fr) {
      fr && detach(ar), lr[31](null), cr = !1, run_all(ur);
    }
  };
}
function create_if_block_1$c(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].lead
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_lead_slot_context$3
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox-label-lead " + /*classesRegionLead*/
      lr[9]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[22],
          mr,
          get_lead_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_lead_slot_context$3
      ), (!ur || mr[0] & /*classesRegionLead*/
      512 && cr !== (cr = "listbox-label-lead " + /*classesRegionLead*/
      gr[9])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_if_block$o(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[23].trail
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[22],
    get_trail_slot_context$1
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "listbox-label-trail " + /*classesRegionTrail*/
      lr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[22],
          mr,
          get_trail_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_trail_slot_context$1
      ), (!ur || mr[0] & /*classesRegionTrail*/
      128 && cr !== (cr = "listbox-label-trail " + /*classesRegionTrail*/
      gr[7])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$V(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er;
  function Cr(zr, Gr) {
    return (
      /*multiple*/
      zr[3] ? create_if_block_2$a : create_else_block$b
    );
  }
  let Tr = Cr(lr), Ar = Tr(lr), Ir = (
    /*$$slots*/
    lr[13].lead && create_if_block_1$c(lr)
  );
  const Mr = (
    /*#slots*/
    lr[23].default
  ), Hr = create_slot(
    Mr,
    lr,
    /*$$scope*/
    lr[22],
    null
  );
  let Br = (
    /*$$slots*/
    lr[13].trail && create_if_block$o(lr)
  );
  return {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), Ar.c(), fr = space(), dr = element("div"), Ir && Ir.c(), gr = space(), mr = element("div"), Hr && Hr.c(), yr = space(), Br && Br.c(), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(mr, "class", vr = "listbox-label-content " + /*classesRegionDefault*/
      lr[8]), attr(dr, "class", kr = "listbox-label " + /*classesLabel*/
      lr[10]), attr(cr, "class", _r = "listbox-item " + /*classesBase*/
      lr[11]), attr(cr, "data-testid", "listbox-item"), attr(cr, "role", "option"), attr(
        cr,
        "aria-selected",
        /*selected*/
        lr[5]
      ), attr(cr, "tabindex", "0");
    },
    m(zr, Gr) {
      insert(zr, ar, Gr), append(ar, cr), append(cr, ur), Ar.m(ur, null), append(cr, fr), append(cr, dr), Ir && Ir.m(dr, null), append(dr, gr), append(dr, mr), Hr && Hr.m(mr, null), append(dr, yr), Br && Br.m(dr, null), xr = !0, Sr || (Er = [
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[12]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[25]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[26]
        )
      ], Sr = !0);
    },
    p(zr, Gr) {
      Tr === (Tr = Cr(zr)) && Ar ? Ar.p(zr, Gr) : (Ar.d(1), Ar = Tr(zr), Ar && (Ar.c(), Ar.m(ur, null))), /*$$slots*/
      zr[13].lead ? Ir ? (Ir.p(zr, Gr), Gr[0] & /*$$slots*/
      8192 && transition_in(Ir, 1)) : (Ir = create_if_block_1$c(zr), Ir.c(), transition_in(Ir, 1), Ir.m(dr, gr)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Hr && Hr.p && (!xr || Gr[0] & /*$$scope*/
      4194304) && update_slot_base(
        Hr,
        Mr,
        zr,
        /*$$scope*/
        zr[22],
        xr ? get_slot_changes(
          Mr,
          /*$$scope*/
          zr[22],
          Gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          zr[22]
        ),
        null
      ), (!xr || Gr[0] & /*classesRegionDefault*/
      256 && vr !== (vr = "listbox-label-content " + /*classesRegionDefault*/
      zr[8])) && attr(mr, "class", vr), /*$$slots*/
      zr[13].trail ? Br ? (Br.p(zr, Gr), Gr[0] & /*$$slots*/
      8192 && transition_in(Br, 1)) : (Br = create_if_block$o(zr), Br.c(), transition_in(Br, 1), Br.m(dr, null)) : Br && (group_outros(), transition_out(Br, 1, 1, () => {
        Br = null;
      }), check_outros()), (!xr || Gr[0] & /*classesLabel*/
      1024 && kr !== (kr = "listbox-label " + /*classesLabel*/
      zr[10])) && attr(dr, "class", kr), (!xr || Gr[0] & /*classesBase*/
      2048 && _r !== (_r = "listbox-item " + /*classesBase*/
      zr[11])) && attr(cr, "class", _r), (!xr || Gr[0] & /*selected*/
      32) && attr(
        cr,
        "aria-selected",
        /*selected*/
        zr[5]
      );
    },
    i(zr) {
      xr || (transition_in(Ir), transition_in(Hr, zr), transition_in(Br), xr = !0);
    },
    o(zr) {
      transition_out(Ir), transition_out(Hr, zr), transition_out(Br), xr = !1;
    },
    d(zr) {
      zr && detach(ar), Ar.d(), Ir && Ir.d(), Hr && Hr.d(zr), Br && Br.d(), Sr = !1, run_all(Er);
    }
  };
}
const cBase$f = "cursor-pointer -outline-offset-[3px]", cLabel$2 = "flex items-center space-x-4", cRegionLead = "", cRegionDefault = "flex-1", cRegionTrail = "";
function areDeeplyEqual(lr, ar) {
  if (lr === ar)
    return !0;
  if (!(lr instanceof Object) || !(ar instanceof Object))
    return !1;
  const cr = Object.keys(lr), ur = Object.keys(ar);
  if (cr.length !== ur.length)
    return !1;
  for (const fr of cr) {
    const dr = lr[fr], gr = ar[fr];
    if (!areDeeplyEqual(dr, gr))
      return !1;
  }
  return !0;
}
function instance$A(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, { $$slots: kr = {}, $$scope: _r } = ar;
  const xr = compute_slots(kr);
  let { group: Sr } = ar, { name: Er } = ar, { value: Cr } = ar, { multiple: Tr = getContext("multiple") } = ar, { rounded: Ar = getContext("rounded") } = ar, { active: Ir = getContext("active") } = ar, { hover: Mr = getContext("hover") } = ar, { padding: Hr = getContext("padding") } = ar, { regionLead: Br = getContext("regionLead") } = ar, { regionDefault: zr = getContext("regionDefault") } = ar, { regionTrail: Gr = getContext("regionTrail") } = ar, Xr, Jr;
  function li(Ji) {
    cr(4, Xr = Ji.indexOf(Cr) >= 0);
  }
  function Qr(Ji) {
    const Bi = Sr.indexOf(Cr);
    Ji ? Bi < 0 && (Sr.push(Cr), cr(0, Sr)) : Bi >= 0 && (Sr.splice(Bi, 1), cr(0, Sr));
  }
  function ei(Ji) {
    ["Enter", "Space"].includes(Ji.code) && (Ji.preventDefault(), Jr.click());
  }
  const ui = [[]];
  function Ai(Ji) {
    bubble.call(this, lr, Ji);
  }
  function fi(Ji) {
    bubble.call(this, lr, Ji);
  }
  function gi(Ji) {
    bubble.call(this, lr, Ji);
  }
  function Ci(Ji) {
    bubble.call(this, lr, Ji);
  }
  function mi(Ji) {
    bubble.call(this, lr, Ji);
  }
  function vi(Ji) {
    bubble.call(this, lr, Ji);
  }
  function Ri(Ji) {
    bubble.call(this, lr, Ji);
  }
  function di(Ji) {
    binding_callbacks[Ji ? "unshift" : "push"](() => {
      Jr = Ji, cr(6, Jr);
    });
  }
  function Ti() {
    Xr = this.checked, cr(4, Xr);
  }
  function qi(Ji) {
    binding_callbacks[Ji ? "unshift" : "push"](() => {
      Jr = Ji, cr(6, Jr);
    });
  }
  function ki() {
    Sr = this.__value, cr(0, Sr);
  }
  return lr.$$set = (Ji) => {
    cr(38, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ji))), "group" in Ji && cr(0, Sr = Ji.group), "name" in Ji && cr(1, Er = Ji.name), "value" in Ji && cr(2, Cr = Ji.value), "multiple" in Ji && cr(3, Tr = Ji.multiple), "rounded" in Ji && cr(14, Ar = Ji.rounded), "active" in Ji && cr(15, Ir = Ji.active), "hover" in Ji && cr(16, Mr = Ji.hover), "padding" in Ji && cr(17, Hr = Ji.padding), "regionLead" in Ji && cr(18, Br = Ji.regionLead), "regionDefault" in Ji && cr(19, zr = Ji.regionDefault), "regionTrail" in Ji && cr(20, Gr = Ji.regionTrail), "$$scope" in Ji && cr(22, _r = Ji.$$scope);
  }, lr.$$.update = () => {
    var Ji;
    lr.$$.dirty[0] & /*multiple, group*/
    9 && Tr && li(Sr), lr.$$.dirty[0] & /*multiple, checked*/
    24 && Tr && Qr(Xr), lr.$$.dirty[0] & /*multiple, group, value*/
    13 && cr(5, ur = Tr ? Sr.some((Bi) => areDeeplyEqual(Cr, Bi)) : areDeeplyEqual(Sr, Cr)), lr.$$.dirty[0] & /*selected, active, hover*/
    98336 && cr(21, fr = ur ? Ir : Mr), cr(11, dr = `${cBase$f} ${Ar} ${Hr} ${fr} ${(Ji = ar.class) != null ? Ji : ""}`), lr.$$.dirty[0] & /*regionLead*/
    262144 && cr(9, mr = `${cRegionLead} ${Br}`), lr.$$.dirty[0] & /*regionDefault*/
    524288 && cr(8, vr = `${cRegionDefault} ${zr}`), lr.$$.dirty[0] & /*regionTrail*/
    1048576 && cr(7, yr = `${cRegionTrail} ${Gr}`);
  }, cr(10, gr = `${cLabel$2}`), ar = exclude_internal_props(ar), [
    Sr,
    Er,
    Cr,
    Tr,
    Xr,
    ur,
    Jr,
    yr,
    vr,
    mr,
    gr,
    dr,
    ei,
    xr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    fr,
    _r,
    kr,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    Ri,
    di,
    Ti,
    qi,
    ki,
    ui
  ];
}
class ListBoxItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$A,
      create_fragment$V,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        multiple: 3,
        rounded: 14,
        active: 15,
        hover: 16,
        padding: 17,
        regionLead: 18,
        regionDefault: 19,
        regionTrail: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[3];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[15];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[18];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[19];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[20];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
}
create_custom_element(ListBoxItem, { group: {}, name: {}, value: {}, multiple: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {} }, ["lead", "default", "trail"], [], !0);
const leftArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>', rightArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"/></svg>', leftAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/></svg>', rightAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>';
function get_each_context$9(lr, ar, cr) {
  const ur = lr.slice();
  return ur[43] = ar[cr], ur;
}
function get_each_context_1$3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[46] = ar[cr], ur;
}
function create_if_block_5$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr = ensure_array_like(
    /*settings*/
    lr[0].amounts
  ), vr = [];
  for (let yr = 0; yr < mr.length; yr += 1)
    vr[yr] = create_each_block_1$3(get_each_context_1$3(lr, mr, yr));
  return {
    c() {
      ar = element("label"), cr = element("select");
      for (let yr = 0; yr < vr.length; yr += 1)
        vr[yr].c();
      attr(cr, "class", ur = "paginator-select " + /*classesSelect*/
      lr[19]), cr.disabled = /*disabled*/
      lr[1], attr(cr, "aria-label", "Select Amount"), /*settings*/
      lr[0].limit === void 0 && add_render_callback(() => (
        /*select_1_change_handler*/
        lr[32].call(cr)
      )), attr(ar, "class", fr = "paginator-label " + /*classesLabel*/
      lr[20]);
    },
    m(yr, kr) {
      insert(yr, ar, kr), append(ar, cr);
      for (let _r = 0; _r < vr.length; _r += 1)
        vr[_r] && vr[_r].m(cr, null);
      select_option(
        cr,
        /*settings*/
        lr[0].limit,
        !0
      ), dr || (gr = [
        listen(
          cr,
          "change",
          /*select_1_change_handler*/
          lr[32]
        ),
        listen(
          cr,
          "change",
          /*onChangeLength*/
          lr[23]
        )
      ], dr = !0);
    },
    p(yr, kr) {
      if (kr[0] & /*settings, amountText*/
      33) {
        mr = ensure_array_like(
          /*settings*/
          yr[0].amounts
        );
        let _r;
        for (_r = 0; _r < mr.length; _r += 1) {
          const xr = get_each_context_1$3(yr, mr, _r);
          vr[_r] ? vr[_r].p(xr, kr) : (vr[_r] = create_each_block_1$3(xr), vr[_r].c(), vr[_r].m(cr, null));
        }
        for (; _r < vr.length; _r += 1)
          vr[_r].d(1);
        vr.length = mr.length;
      }
      kr[0] & /*classesSelect*/
      524288 && ur !== (ur = "paginator-select " + /*classesSelect*/
      yr[19]) && attr(cr, "class", ur), kr[0] & /*disabled*/
      2 && (cr.disabled = /*disabled*/
      yr[1]), kr[0] & /*settings*/
      1 && select_option(
        cr,
        /*settings*/
        yr[0].limit
      ), kr[0] & /*classesLabel*/
      1048576 && fr !== (fr = "paginator-label " + /*classesLabel*/
      yr[20]) && attr(ar, "class", fr);
    },
    d(yr) {
      yr && detach(ar), destroy_each(vr, yr), dr = !1, run_all(gr);
    }
  };
}
function create_each_block_1$3(lr) {
  let ar, cr = (
    /*amount*/
    lr[46] + ""
  ), ur, fr, dr, gr;
  return {
    c() {
      ar = element("option"), ur = text$3(cr), fr = space(), dr = text$3(
        /*amountText*/
        lr[5]
      ), ar.__value = gr = /*amount*/
      lr[46], set_input_value(ar, ar.__value);
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, ur), append(ar, fr), append(ar, dr);
    },
    p(mr, vr) {
      vr[0] & /*settings*/
      1 && cr !== (cr = /*amount*/
      mr[46] + "") && set_data(ur, cr), vr[0] & /*amountText*/
      32 && set_data(
        dr,
        /*amountText*/
        mr[5]
      ), vr[0] & /*settings*/
      1 && gr !== (gr = /*amount*/
      mr[46]) && (ar.__value = gr, set_input_value(ar, ar.__value));
    },
    d(mr) {
      mr && detach(ar);
    }
  };
}
function create_if_block_4$5(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelFirst*/
        lr[12]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      lr[0].page === 0;
    },
    m(dr, gr) {
      insert(dr, ar, gr), ar.innerHTML = /*buttonTextFirst*/
      lr[9], ur || (fr = listen(
        ar,
        "click",
        /*click_handler*/
        lr[33]
      ), ur = !0);
    },
    p(dr, gr) {
      gr[0] & /*buttonTextFirst*/
      512 && (ar.innerHTML = /*buttonTextFirst*/
      dr[9]), gr[0] & /*labelFirst*/
      4096 && attr(
        ar,
        "aria-label",
        /*labelFirst*/
        dr[12]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), gr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      dr[0].page === 0) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_3$7(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        lr[13]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      lr[0].page === 0;
    },
    m(dr, gr) {
      insert(dr, ar, gr), ar.innerHTML = /*buttonTextPrevious*/
      lr[7], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_1*/
        lr[34]
      ), ur = !0);
    },
    p(dr, gr) {
      gr[0] & /*buttonTextPrevious*/
      128 && (ar.innerHTML = /*buttonTextPrevious*/
      dr[7]), gr[0] & /*labelPrevious*/
      8192 && attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        dr[13]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), gr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      dr[0].page === 0) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_else_block$a(lr) {
  let ar, cr = ensure_array_like(
    /*controlPages*/
    lr[17]
  ), ur = [];
  for (let fr = 0; fr < cr.length; fr += 1)
    ur[fr] = create_each_block$9(get_each_context$9(lr, cr, fr));
  return {
    c() {
      for (let fr = 0; fr < ur.length; fr += 1)
        ur[fr].c();
      ar = empty$1();
    },
    m(fr, dr) {
      for (let gr = 0; gr < ur.length; gr += 1)
        ur[gr] && ur[gr].m(fr, dr);
      insert(fr, ar, dr);
    },
    p(fr, dr) {
      if (dr[0] & /*buttonClasses, classesButtonActive, controlPages, gotoPage*/
      21102656) {
        cr = ensure_array_like(
          /*controlPages*/
          fr[17]
        );
        let gr;
        for (gr = 0; gr < cr.length; gr += 1) {
          const mr = get_each_context$9(fr, cr, gr);
          ur[gr] ? ur[gr].p(mr, dr) : (ur[gr] = create_each_block$9(mr), ur[gr].c(), ur[gr].m(ar.parentNode, ar));
        }
        for (; gr < ur.length; gr += 1)
          ur[gr].d(1);
        ur.length = cr.length;
      }
    },
    d(fr) {
      fr && detach(ar), destroy_each(ur, fr);
    }
  };
}
function create_if_block_2$9(lr) {
  let ar, cr = (
    /*settings*/
    lr[0].page * /*settings*/
    lr[0].limit + 1 + ""
  ), ur, fr, dr = Math.min(
    /*settings*/
    lr[0].page * /*settings*/
    lr[0].limit + /*settings*/
    lr[0].limit,
    /*settings*/
    lr[0].size
  ) + "", gr, mr, vr, yr, kr, _r = (
    /*settings*/
    lr[0].size + ""
  ), xr, Sr;
  return {
    c() {
      ar = element("button"), ur = text$3(cr), fr = text$3("-"), gr = text$3(dr), mr = text$3(" "), vr = element("span"), yr = text$3(
        /*separatorText*/
        lr[11]
      ), kr = space(), xr = text$3(_r), attr(vr, "class", "opacity-50"), attr(ar, "type", "button"), attr(ar, "class", Sr = /*buttonClasses*/
      lr[6] + " pointer-events-none !text-sm");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, ur), append(ar, fr), append(ar, gr), append(ar, mr), append(ar, vr), append(vr, yr), append(vr, kr), append(vr, xr);
    },
    p(Er, Cr) {
      Cr[0] & /*settings*/
      1 && cr !== (cr = /*settings*/
      Er[0].page * /*settings*/
      Er[0].limit + 1 + "") && set_data(ur, cr), Cr[0] & /*settings*/
      1 && dr !== (dr = Math.min(
        /*settings*/
        Er[0].page * /*settings*/
        Er[0].limit + /*settings*/
        Er[0].limit,
        /*settings*/
        Er[0].size
      ) + "") && set_data(gr, dr), Cr[0] & /*separatorText*/
      2048 && set_data(
        yr,
        /*separatorText*/
        Er[11]
      ), Cr[0] & /*settings*/
      1 && _r !== (_r = /*settings*/
      Er[0].size + "") && set_data(xr, _r), Cr[0] & /*buttonClasses*/
      64 && Sr !== (Sr = /*buttonClasses*/
      Er[6] + " pointer-events-none !text-sm") && attr(ar, "class", Sr);
    },
    d(Er) {
      Er && detach(ar);
    }
  };
}
function create_each_block$9(lr) {
  let ar, cr = (
    /*page*/
    (lr[43] >= 0 ? (
      /*page*/
      lr[43] + 1
    ) : "...") + ""
  ), ur, fr, dr, gr, mr;
  function vr() {
    return (
      /*click_handler_2*/
      lr[35](
        /*page*/
        lr[43]
      )
    );
  }
  return {
    c() {
      ar = element("button"), ur = text$3(cr), fr = space(), attr(ar, "type", "button"), attr(ar, "class", dr = /*buttonClasses*/
      lr[6] + " " + /*classesButtonActive*/
      lr[22](
        /*page*/
        lr[43]
      ));
    },
    m(yr, kr) {
      insert(yr, ar, kr), append(ar, ur), append(ar, fr), gr || (mr = listen(ar, "click", vr), gr = !0);
    },
    p(yr, kr) {
      lr = yr, kr[0] & /*controlPages*/
      131072 && cr !== (cr = /*page*/
      (lr[43] >= 0 ? (
        /*page*/
        lr[43] + 1
      ) : "...") + "") && set_data(ur, cr), kr[0] & /*buttonClasses, classesButtonActive, controlPages*/
      4325440 && dr !== (dr = /*buttonClasses*/
      lr[6] + " " + /*classesButtonActive*/
      lr[22](
        /*page*/
        lr[43]
      )) && attr(ar, "class", dr);
    },
    d(yr) {
      yr && detach(ar), gr = !1, mr();
    }
  };
}
function create_if_block_1$b(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelNext*/
        lr[14]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      (lr[0].page + 1) * /*settings*/
      lr[0].limit >= /*settings*/
      lr[0].size;
    },
    m(dr, gr) {
      insert(dr, ar, gr), ar.innerHTML = /*buttonTextNext*/
      lr[8], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_3*/
        lr[36]
      ), ur = !0);
    },
    p(dr, gr) {
      gr[0] & /*buttonTextNext*/
      256 && (ar.innerHTML = /*buttonTextNext*/
      dr[8]), gr[0] & /*labelNext*/
      16384 && attr(
        ar,
        "aria-label",
        /*labelNext*/
        dr[14]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), gr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      (dr[0].page + 1) * /*settings*/
      dr[0].limit >= /*settings*/
      dr[0].size) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block$n(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelLast*/
        lr[15]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        lr[6]
      ), ar.disabled = cr = /*disabled*/
      lr[1] || /*settings*/
      (lr[0].page + 1) * /*settings*/
      lr[0].limit >= /*settings*/
      lr[0].size;
    },
    m(dr, gr) {
      insert(dr, ar, gr), ar.innerHTML = /*buttonTextLast*/
      lr[10], ur || (fr = listen(
        ar,
        "click",
        /*click_handler_4*/
        lr[37]
      ), ur = !0);
    },
    p(dr, gr) {
      gr[0] & /*buttonTextLast*/
      1024 && (ar.innerHTML = /*buttonTextLast*/
      dr[10]), gr[0] & /*labelLast*/
      32768 && attr(
        ar,
        "aria-label",
        /*labelLast*/
        dr[15]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        dr[6]
      ), gr[0] & /*disabled, settings*/
      3 && cr !== (cr = /*disabled*/
      dr[1] || /*settings*/
      (dr[0].page + 1) * /*settings*/
      dr[0].limit >= /*settings*/
      dr[0].size) && (ar.disabled = cr);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_fragment$U(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr = (
    /*settings*/
    lr[0].amounts.length && create_if_block_5$3(lr)
  ), _r = (
    /*showFirstLastButtons*/
    lr[3] && create_if_block_4$5(lr)
  ), xr = (
    /*showPreviousNextButtons*/
    lr[2] && create_if_block_3$7(lr)
  );
  function Sr(Ir, Mr) {
    return (
      /*showNumerals*/
      Ir[4] === !1 ? create_if_block_2$9 : create_else_block$a
    );
  }
  let Er = Sr(lr), Cr = Er(lr), Tr = (
    /*showPreviousNextButtons*/
    lr[2] && create_if_block_1$b(lr)
  ), Ar = (
    /*showFirstLastButtons*/
    lr[3] && create_if_block$n(lr)
  );
  return {
    c() {
      ar = element("div"), kr && kr.c(), cr = space(), ur = element("div"), _r && _r.c(), fr = space(), xr && xr.c(), dr = space(), Cr.c(), gr = space(), Tr && Tr.c(), mr = space(), Ar && Ar.c(), attr(ur, "class", vr = "paginator-controls " + /*classesControls*/
      lr[18]), attr(ar, "class", yr = "paginator " + /*classesBase*/
      lr[21]), attr(ar, "data-testid", "paginator");
    },
    m(Ir, Mr) {
      insert(Ir, ar, Mr), kr && kr.m(ar, null), append(ar, cr), append(ar, ur), _r && _r.m(ur, null), append(ur, fr), xr && xr.m(ur, null), append(ur, dr), Cr.m(ur, null), append(ur, gr), Tr && Tr.m(ur, null), append(ur, mr), Ar && Ar.m(ur, null);
    },
    p(Ir, Mr) {
      /*settings*/
      Ir[0].amounts.length ? kr ? kr.p(Ir, Mr) : (kr = create_if_block_5$3(Ir), kr.c(), kr.m(ar, cr)) : kr && (kr.d(1), kr = null), /*showFirstLastButtons*/
      Ir[3] ? _r ? _r.p(Ir, Mr) : (_r = create_if_block_4$5(Ir), _r.c(), _r.m(ur, fr)) : _r && (_r.d(1), _r = null), /*showPreviousNextButtons*/
      Ir[2] ? xr ? xr.p(Ir, Mr) : (xr = create_if_block_3$7(Ir), xr.c(), xr.m(ur, dr)) : xr && (xr.d(1), xr = null), Er === (Er = Sr(Ir)) && Cr ? Cr.p(Ir, Mr) : (Cr.d(1), Cr = Er(Ir), Cr && (Cr.c(), Cr.m(ur, gr))), /*showPreviousNextButtons*/
      Ir[2] ? Tr ? Tr.p(Ir, Mr) : (Tr = create_if_block_1$b(Ir), Tr.c(), Tr.m(ur, mr)) : Tr && (Tr.d(1), Tr = null), /*showFirstLastButtons*/
      Ir[3] ? Ar ? Ar.p(Ir, Mr) : (Ar = create_if_block$n(Ir), Ar.c(), Ar.m(ur, null)) : Ar && (Ar.d(1), Ar = null), Mr[0] & /*classesControls*/
      262144 && vr !== (vr = "paginator-controls " + /*classesControls*/
      Ir[18]) && attr(ur, "class", vr), Mr[0] & /*classesBase*/
      2097152 && yr !== (yr = "paginator " + /*classesBase*/
      Ir[21]) && attr(ar, "class", yr);
    },
    i: noop$1,
    o: noop$1,
    d(Ir) {
      Ir && detach(ar), kr && kr.d(), _r && _r.d(), xr && xr.d(), Cr.d(), Tr && Tr.d(), Ar && Ar.d();
    }
  };
}
const cBase$e = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4", cLabel$1 = "w-full md:w-auto";
function instance$z(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  const vr = createEventDispatcher();
  let { settings: yr = {
    page: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = ar, { disabled: kr = !1 } = ar, { showPreviousNextButtons: _r = !0 } = ar, { showFirstLastButtons: xr = !1 } = ar, { showNumerals: Sr = !1 } = ar, { maxNumerals: Er = 1 } = ar, { justify: Cr = "justify-between" } = ar, { select: Tr = "select min-w-[150px]" } = ar, { amountText: Ar = "Items" } = ar, { regionControl: Ir = "btn-group" } = ar, { controlVariant: Mr = "variant-filled" } = ar, { controlSeparator: Hr = "" } = ar, { active: Br = "variant-filled-primary" } = ar, { buttonClasses: zr = "!px-3 !py-1.5 fill-current" } = ar, { buttonTextPrevious: Gr = leftArrow } = ar, { buttonTextNext: Xr = rightArrow } = ar, { buttonTextFirst: Jr = leftAngles } = ar, { buttonTextLast: li = rightAngles } = ar, { separatorText: Qr = "of" } = ar, { labelFirst: ei = "First page" } = ar, { labelPrevious: ui = "Previous page" } = ar, { labelNext: Ai = "Next page" } = ar, { labelLast: fi = "Last page" } = ar, gi = Math.max(0, Math.ceil(yr.size / yr.limit - 1)), Ci = di();
  function mi() {
    vr("amount", yr.limit), cr(16, gi = Math.max(0, Math.ceil(yr.size / yr.limit - 1))), yr.page > gi && cr(0, yr.page = gi, yr), cr(17, Ci = di());
  }
  function vi(bi) {
    bi < 0 || (cr(0, yr.page = bi, yr), vr("page", yr.page), cr(17, Ci = di()));
  }
  function Ri() {
    const bi = [];
    for (let Ei = 0; Ei <= gi; Ei++)
      bi.push(Ei);
    return bi;
  }
  function di() {
    const bi = [], Ei = yr.page < Er + 2, Si = yr.page > gi - (Er + 2);
    if (gi <= Er * 2 + 1)
      return Ri();
    if (bi.push(0), Ei || bi.push(-1), Ei || Si) {
      const Vi = Ei ? 1 : gi - (Er + 2), Di = Si ? gi - 1 : Er + 2;
      for (let sa = Vi; sa <= Di; sa++)
        bi.push(sa);
    } else
      for (let Vi = yr.page - Er; Vi <= yr.page + Er; Vi++)
        bi.push(Vi);
    return Si || bi.push(-1), bi.push(gi), bi;
  }
  function Ti(bi) {
    cr(16, gi = Math.max(0, Math.ceil(bi / yr.limit - 1))), cr(17, Ci = di());
  }
  function qi() {
    yr.limit = select_value(this), cr(0, yr);
  }
  const ki = () => {
    vi(0);
  }, Ji = () => {
    vi(yr.page - 1);
  }, Bi = (bi) => vi(bi), Ni = () => {
    vi(yr.page + 1);
  }, Mi = () => {
    vi(gi);
  };
  return lr.$$set = (bi) => {
    cr(42, ar = assign$1(assign$1({}, ar), exclude_internal_props(bi))), "settings" in bi && cr(0, yr = bi.settings), "disabled" in bi && cr(1, kr = bi.disabled), "showPreviousNextButtons" in bi && cr(2, _r = bi.showPreviousNextButtons), "showFirstLastButtons" in bi && cr(3, xr = bi.showFirstLastButtons), "showNumerals" in bi && cr(4, Sr = bi.showNumerals), "maxNumerals" in bi && cr(25, Er = bi.maxNumerals), "justify" in bi && cr(26, Cr = bi.justify), "select" in bi && cr(27, Tr = bi.select), "amountText" in bi && cr(5, Ar = bi.amountText), "regionControl" in bi && cr(28, Ir = bi.regionControl), "controlVariant" in bi && cr(29, Mr = bi.controlVariant), "controlSeparator" in bi && cr(30, Hr = bi.controlSeparator), "active" in bi && cr(31, Br = bi.active), "buttonClasses" in bi && cr(6, zr = bi.buttonClasses), "buttonTextPrevious" in bi && cr(7, Gr = bi.buttonTextPrevious), "buttonTextNext" in bi && cr(8, Xr = bi.buttonTextNext), "buttonTextFirst" in bi && cr(9, Jr = bi.buttonTextFirst), "buttonTextLast" in bi && cr(10, li = bi.buttonTextLast), "separatorText" in bi && cr(11, Qr = bi.separatorText), "labelFirst" in bi && cr(12, ei = bi.labelFirst), "labelPrevious" in bi && cr(13, ui = bi.labelPrevious), "labelNext" in bi && cr(14, Ai = bi.labelNext), "labelLast" in bi && cr(15, fi = bi.labelLast);
  }, lr.$$.update = () => {
    var bi;
    lr.$$.dirty[0] & /*settings*/
    1 | lr.$$.dirty[1] & /*active*/
    1 && cr(22, ur = (Ei) => Ei === yr.page ? `${Br} pointer-events-none` : ""), lr.$$.dirty[0] & /*maxNumerals*/
    33554432 && mi(), lr.$$.dirty[0] & /*settings*/
    1 && Ti(yr.size), cr(21, fr = `${cBase$e} ${Cr} ${(bi = ar.class) != null ? bi : ""}`), lr.$$.dirty[0] & /*select*/
    134217728 && cr(19, gr = `${Tr}`), lr.$$.dirty[0] & /*regionControl, controlVariant, controlSeparator*/
    1879048192 && cr(18, mr = `${Ir} ${Mr} ${Hr}`);
  }, cr(20, dr = `${cLabel$1}`), ar = exclude_internal_props(ar), [
    yr,
    kr,
    _r,
    xr,
    Sr,
    Ar,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mr,
    gr,
    dr,
    fr,
    ur,
    mi,
    vi,
    Er,
    Cr,
    Tr,
    Ir,
    Mr,
    Hr,
    Br,
    qi,
    ki,
    Ji,
    Bi,
    Ni,
    Mi
  ];
}
class Paginator extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$z,
      create_fragment$U,
      safe_not_equal,
      {
        settings: 0,
        disabled: 1,
        showPreviousNextButtons: 2,
        showFirstLastButtons: 3,
        showNumerals: 4,
        maxNumerals: 25,
        justify: 26,
        select: 27,
        amountText: 5,
        regionControl: 28,
        controlVariant: 29,
        controlSeparator: 30,
        active: 31,
        buttonClasses: 6,
        buttonTextPrevious: 7,
        buttonTextNext: 8,
        buttonTextFirst: 9,
        buttonTextLast: 10,
        separatorText: 11,
        labelFirst: 12,
        labelPrevious: 13,
        labelNext: 14,
        labelLast: 15
      },
      null,
      [-1, -1]
    );
  }
  get settings() {
    return this.$$.ctx[0];
  }
  set settings(ar) {
    this.$$set({ settings: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get showPreviousNextButtons() {
    return this.$$.ctx[2];
  }
  set showPreviousNextButtons(ar) {
    this.$$set({ showPreviousNextButtons: ar }), flush();
  }
  get showFirstLastButtons() {
    return this.$$.ctx[3];
  }
  set showFirstLastButtons(ar) {
    this.$$set({ showFirstLastButtons: ar }), flush();
  }
  get showNumerals() {
    return this.$$.ctx[4];
  }
  set showNumerals(ar) {
    this.$$set({ showNumerals: ar }), flush();
  }
  get maxNumerals() {
    return this.$$.ctx[25];
  }
  set maxNumerals(ar) {
    this.$$set({ maxNumerals: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[26];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get select() {
    return this.$$.ctx[27];
  }
  set select(ar) {
    this.$$set({ select: ar }), flush();
  }
  get amountText() {
    return this.$$.ctx[5];
  }
  set amountText(ar) {
    this.$$set({ amountText: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[28];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get controlVariant() {
    return this.$$.ctx[29];
  }
  set controlVariant(ar) {
    this.$$set({ controlVariant: ar }), flush();
  }
  get controlSeparator() {
    return this.$$.ctx[30];
  }
  set controlSeparator(ar) {
    this.$$set({ controlSeparator: ar }), flush();
  }
  get active() {
    return this.$$.ctx[31];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get buttonClasses() {
    return this.$$.ctx[6];
  }
  set buttonClasses(ar) {
    this.$$set({ buttonClasses: ar }), flush();
  }
  get buttonTextPrevious() {
    return this.$$.ctx[7];
  }
  set buttonTextPrevious(ar) {
    this.$$set({ buttonTextPrevious: ar }), flush();
  }
  get buttonTextNext() {
    return this.$$.ctx[8];
  }
  set buttonTextNext(ar) {
    this.$$set({ buttonTextNext: ar }), flush();
  }
  get buttonTextFirst() {
    return this.$$.ctx[9];
  }
  set buttonTextFirst(ar) {
    this.$$set({ buttonTextFirst: ar }), flush();
  }
  get buttonTextLast() {
    return this.$$.ctx[10];
  }
  set buttonTextLast(ar) {
    this.$$set({ buttonTextLast: ar }), flush();
  }
  get separatorText() {
    return this.$$.ctx[11];
  }
  set separatorText(ar) {
    this.$$set({ separatorText: ar }), flush();
  }
  get labelFirst() {
    return this.$$.ctx[12];
  }
  set labelFirst(ar) {
    this.$$set({ labelFirst: ar }), flush();
  }
  get labelPrevious() {
    return this.$$.ctx[13];
  }
  set labelPrevious(ar) {
    this.$$set({ labelPrevious: ar }), flush();
  }
  get labelNext() {
    return this.$$.ctx[14];
  }
  set labelNext(ar) {
    this.$$set({ labelNext: ar }), flush();
  }
  get labelLast() {
    return this.$$.ctx[15];
  }
  set labelLast(ar) {
    this.$$set({ labelLast: ar }), flush();
  }
}
create_custom_element(Paginator, { settings: {}, disabled: { type: "Boolean" }, showPreviousNextButtons: { type: "Boolean" }, showFirstLastButtons: { type: "Boolean" }, showNumerals: { type: "Boolean" }, maxNumerals: {}, justify: {}, select: {}, amountText: {}, regionControl: {}, controlVariant: {}, controlSeparator: {}, active: {}, buttonClasses: {}, buttonTextPrevious: {}, buttonTextNext: {}, buttonTextFirst: {}, buttonTextLast: {}, separatorText: {}, labelFirst: {}, labelPrevious: {}, labelNext: {}, labelLast: {} }, [], [], !0);
function add_css$b(lr) {
  append_styles(lr, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}");
}
function create_fragment$T(lr) {
  let ar, cr, ur, fr = `${/*indeterminate*/
  lr[4] ? 100 : (
    /*fillPercent*/
    lr[7]
  )}%`, dr, gr;
  return {
    c() {
      ar = element("div"), cr = element("div"), attr(cr, "class", ur = "progress-bar-meter " + /*classesMeter*/
      lr[5] + " " + /*classesMeter*/
      lr[5] + " svelte-meqa4r"), set_style(cr, "width", fr), attr(ar, "class", dr = "progress-bar " + /*classesTrack*/
      lr[6] + " svelte-meqa4r"), attr(ar, "data-testid", "progress-bar"), attr(ar, "role", "progressbar"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[3]
      ), attr(
        ar,
        "aria-valuenow",
        /*value*/
        lr[0]
      ), attr(
        ar,
        "aria-valuemin",
        /*min*/
        lr[1]
      ), attr(ar, "aria-valuemax", gr = /*max*/
      lr[2] - /*min*/
      lr[1]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, cr);
    },
    p(mr, [vr]) {
      vr & /*classesMeter*/
      32 && ur !== (ur = "progress-bar-meter " + /*classesMeter*/
      mr[5] + " " + /*classesMeter*/
      mr[5] + " svelte-meqa4r") && attr(cr, "class", ur), vr & /*indeterminate, fillPercent*/
      144 && fr !== (fr = `${/*indeterminate*/
      mr[4] ? 100 : (
        /*fillPercent*/
        mr[7]
      )}%`) && set_style(cr, "width", fr), vr & /*classesTrack*/
      64 && dr !== (dr = "progress-bar " + /*classesTrack*/
      mr[6] + " svelte-meqa4r") && attr(ar, "class", dr), vr & /*labelledby*/
      8 && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        mr[3]
      ), vr & /*value*/
      1 && attr(
        ar,
        "aria-valuenow",
        /*value*/
        mr[0]
      ), vr & /*min*/
      2 && attr(
        ar,
        "aria-valuemin",
        /*min*/
        mr[1]
      ), vr & /*max, min*/
      6 && gr !== (gr = /*max*/
      mr[2] - /*min*/
      mr[1]) && attr(ar, "aria-valuemax", gr);
    },
    i: noop$1,
    o: noop$1,
    d(mr) {
      mr && detach(ar);
    }
  };
}
const cTrack$2 = "w-full overflow-hidden", cMeter = "h-full";
function instance$y(lr, ar, cr) {
  let ur, fr, dr, gr, mr, { value: vr = void 0 } = ar, { min: yr = 0 } = ar, { max: kr = 100 } = ar, { height: _r = "h-2" } = ar, { rounded: xr = "rounded-token" } = ar, { transition: Sr = "transition-[width]" } = ar, { meter: Er = "bg-surface-900-50-token" } = ar, { track: Cr = "bg-surface-200-700-token" } = ar, { labelledby: Tr = "" } = ar;
  return lr.$$set = (Ar) => {
    cr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ar))), "value" in Ar && cr(0, vr = Ar.value), "min" in Ar && cr(1, yr = Ar.min), "max" in Ar && cr(2, kr = Ar.max), "height" in Ar && cr(8, _r = Ar.height), "rounded" in Ar && cr(9, xr = Ar.rounded), "transition" in Ar && cr(10, Sr = Ar.transition), "meter" in Ar && cr(11, Er = Ar.meter), "track" in Ar && cr(12, Cr = Ar.track), "labelledby" in Ar && cr(3, Tr = Ar.labelledby);
  }, lr.$$.update = () => {
    var Ar;
    lr.$$.dirty & /*value, min, max*/
    7 && cr(7, ur = vr ? 100 * (vr - yr) / (kr - yr) : 0), lr.$$.dirty & /*value*/
    1 && cr(4, fr = vr === void 0 || vr < 0), lr.$$.dirty & /*indeterminate*/
    16 && cr(13, dr = fr ? "animIndeterminate" : ""), cr(6, gr = `${cTrack$2} ${Cr} ${_r} ${xr} ${(Ar = ar.class) != null ? Ar : ""}`), lr.$$.dirty & /*meter, rounded, classesIndeterminate, transition*/
    11776 && cr(5, mr = `${cMeter} ${Er} ${xr} ${dr} ${Sr}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    yr,
    kr,
    Tr,
    fr,
    mr,
    gr,
    ur,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    dr
  ];
}
class ProgressBar extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$y,
      create_fragment$T,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        height: 8,
        rounded: 9,
        transition: 10,
        meter: 11,
        track: 12,
        labelledby: 3
      },
      add_css$b
    );
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[1];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[2];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get height() {
    return this.$$.ctx[8];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[9];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[10];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[11];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[12];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[3];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressBar, { value: {}, min: {}, max: {}, height: {}, rounded: {}, transition: {}, meter: {}, track: {}, labelledby: {} }, [], [], !0);
function create_if_block$m(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[16].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[15],
    null
  );
  return {
    c() {
      ar = svg_element("text"), dr && dr.c(), attr(ar, "x", "50%"), attr(ar, "y", "50%"), attr(ar, "text-anchor", "middle"), attr(ar, "dominant-baseline", "middle"), attr(ar, "font-weight", "bold"), attr(
        ar,
        "font-size",
        /*font*/
        lr[2]
      ), attr(ar, "class", cr = "progress-radial-text " + /*fill*/
      lr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      32768) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[15],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[15],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[15]
        ),
        null
      ), (!ur || mr & /*font*/
      4) && attr(
        ar,
        "font-size",
        /*font*/
        gr[2]
      ), (!ur || mr & /*fill*/
      128 && cr !== (cr = "progress-radial-text " + /*fill*/
      gr[7])) && attr(ar, "class", cr);
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$S(lr) {
  let ar, cr, ur, fr, dr, gr, mr = `${/*circumference*/
  lr[9]}
			${/*circumference*/
  lr[9]}`, vr, yr, kr, _r, xr = (
    /*value*/
    lr[0] != null && /*value*/
    lr[0] >= 0 && /*$$slots*/
    lr[13].default && create_if_block$m(lr)
  );
  return {
    c() {
      ar = element("figure"), cr = svg_element("svg"), ur = svg_element("circle"), dr = svg_element("circle"), xr && xr.c(), attr(ur, "class", fr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      lr[6]), attr(
        ur,
        "stroke-width",
        /*stroke*/
        lr[1]
      ), attr(
        ur,
        "r",
        /*radius*/
        lr[12]
      ), attr(ur, "cx", "50%"), attr(ur, "cy", "50%"), attr(dr, "class", gr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      lr[5] + " " + /*transition*/
      lr[4]), attr(
        dr,
        "stroke-width",
        /*stroke*/
        lr[1]
      ), attr(
        dr,
        "r",
        /*radius*/
        lr[12]
      ), attr(dr, "cx", "50%"), attr(dr, "cy", "50%"), attr(
        dr,
        "stroke-linecap",
        /*strokeLinecap*/
        lr[3]
      ), set_style(dr, "stroke-dasharray", mr), set_style(
        dr,
        "stroke-dashoffset",
        /*dashoffset*/
        lr[10]
      ), attr(cr, "viewBox", "0 0 " + baseSize + " " + baseSize), attr(cr, "class", "rounded-full"), toggle_class(
        cr,
        "animate-spin",
        /*value*/
        lr[0] === void 0
      ), attr(ar, "class", vr = "progress-radial " + /*classesBase*/
      lr[11]), attr(ar, "data-testid", "progress-radial"), attr(ar, "role", "meter"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[8]
      ), attr(ar, "aria-valuenow", yr = /*value*/
      lr[0] || 0), attr(ar, "aria-valuetext", kr = /*value*/
      lr[0] ? `${/*value*/
      lr[0]}%` : "Indeterminate Spinner"), attr(ar, "aria-valuemin", 0), attr(ar, "aria-valuemax", 100);
    },
    m(Sr, Er) {
      insert(Sr, ar, Er), append(ar, cr), append(cr, ur), append(cr, dr), xr && xr.m(cr, null), _r = !0;
    },
    p(Sr, [Er]) {
      (!_r || Er & /*track*/
      64 && fr !== (fr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      Sr[6])) && attr(ur, "class", fr), (!_r || Er & /*stroke*/
      2) && attr(
        ur,
        "stroke-width",
        /*stroke*/
        Sr[1]
      ), (!_r || Er & /*meter, transition*/
      48 && gr !== (gr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      Sr[5] + " " + /*transition*/
      Sr[4])) && attr(dr, "class", gr), (!_r || Er & /*stroke*/
      2) && attr(
        dr,
        "stroke-width",
        /*stroke*/
        Sr[1]
      ), (!_r || Er & /*strokeLinecap*/
      8) && attr(
        dr,
        "stroke-linecap",
        /*strokeLinecap*/
        Sr[3]
      ), Er & /*circumference*/
      512 && mr !== (mr = `${/*circumference*/
      Sr[9]}
			${/*circumference*/
      Sr[9]}`) && set_style(dr, "stroke-dasharray", mr), Er & /*dashoffset*/
      1024 && set_style(
        dr,
        "stroke-dashoffset",
        /*dashoffset*/
        Sr[10]
      ), /*value*/
      Sr[0] != null && /*value*/
      Sr[0] >= 0 && /*$$slots*/
      Sr[13].default ? xr ? (xr.p(Sr, Er), Er & /*value, $$slots*/
      8193 && transition_in(xr, 1)) : (xr = create_if_block$m(Sr), xr.c(), transition_in(xr, 1), xr.m(cr, null)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), (!_r || Er & /*value, undefined*/
      1) && toggle_class(
        cr,
        "animate-spin",
        /*value*/
        Sr[0] === void 0
      ), (!_r || Er & /*classesBase*/
      2048 && vr !== (vr = "progress-radial " + /*classesBase*/
      Sr[11])) && attr(ar, "class", vr), (!_r || Er & /*labelledby*/
      256) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        Sr[8]
      ), (!_r || Er & /*value*/
      1 && yr !== (yr = /*value*/
      Sr[0] || 0)) && attr(ar, "aria-valuenow", yr), (!_r || Er & /*value*/
      1 && kr !== (kr = /*value*/
      Sr[0] ? `${/*value*/
      Sr[0]}%` : "Indeterminate Spinner")) && attr(ar, "aria-valuetext", kr);
    },
    i(Sr) {
      _r || (transition_in(xr), _r = !0);
    },
    o(Sr) {
      transition_out(xr), _r = !1;
    },
    d(Sr) {
      Sr && detach(ar), xr && xr.d();
    }
  };
}
const cBase$d = "progress-radial relative overflow-hidden", cBaseTrack = "fill-transparent", cBaseMeter = "fill-transparent -rotate-90 origin-[50%_50%]", baseSize = 512;
function instance$x(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar;
  const gr = compute_slots(fr);
  let { value: mr = void 0 } = ar, { stroke: vr = 40 } = ar, { font: yr = 56 } = ar, { strokeLinecap: kr = "butt" } = ar, { transition: _r = "transition-[stroke-dashoffset]" } = ar, { width: xr = "w-36" } = ar, { meter: Sr = "stroke-surface-900 dark:stroke-surface-50" } = ar, { track: Er = "stroke-surface-500/30" } = ar, { fill: Cr = "fill-token" } = ar, { labelledby: Tr = "" } = ar;
  const Ar = baseSize / 2 - vr / 2;
  let Ir = Ar, Mr;
  function Hr(Br) {
    cr(9, Ir = Ar * 2 * Math.PI), cr(10, Mr = Ir - Br / 100 * Ir);
  }
  return Hr(0), afterUpdate(() => {
    Hr(mr === void 0 ? 25 : mr);
  }), lr.$$set = (Br) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Br))), "value" in Br && cr(0, mr = Br.value), "stroke" in Br && cr(1, vr = Br.stroke), "font" in Br && cr(2, yr = Br.font), "strokeLinecap" in Br && cr(3, kr = Br.strokeLinecap), "transition" in Br && cr(4, _r = Br.transition), "width" in Br && cr(14, xr = Br.width), "meter" in Br && cr(5, Sr = Br.meter), "track" in Br && cr(6, Er = Br.track), "fill" in Br && cr(7, Cr = Br.fill), "labelledby" in Br && cr(8, Tr = Br.labelledby), "$$scope" in Br && cr(15, dr = Br.$$scope);
  }, lr.$$.update = () => {
    var Br;
    cr(11, ur = `${cBase$d} ${xr} ${(Br = ar.class) != null ? Br : ""}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    vr,
    yr,
    kr,
    _r,
    Sr,
    Er,
    Cr,
    Tr,
    Ir,
    Mr,
    ur,
    Ar,
    gr,
    xr,
    dr,
    fr
  ];
}
class ProgressRadial extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$x, create_fragment$S, safe_not_equal, {
      value: 0,
      stroke: 1,
      font: 2,
      strokeLinecap: 3,
      transition: 4,
      width: 14,
      meter: 5,
      track: 6,
      fill: 7,
      labelledby: 8
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get stroke() {
    return this.$$.ctx[1];
  }
  set stroke(ar) {
    this.$$set({ stroke: ar }), flush();
  }
  get font() {
    return this.$$.ctx[2];
  }
  set font(ar) {
    this.$$set({ font: ar }), flush();
  }
  get strokeLinecap() {
    return this.$$.ctx[3];
  }
  set strokeLinecap(ar) {
    this.$$set({ strokeLinecap: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[4];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get width() {
    return this.$$.ctx[14];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[5];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[6];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[8];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressRadial, { value: {}, stroke: {}, font: {}, strokeLinecap: {}, transition: {}, width: {}, meter: {}, track: {}, fill: {}, labelledby: {} }, ["default"], [], !0);
function get_each_context$8(lr, ar, cr) {
  const ur = lr.slice();
  return ur[15] = ar[cr], ur[17] = cr, ur;
}
const get_empty_slot_changes_1 = (lr) => ({}), get_empty_slot_context_1 = (lr) => ({}), get_half_slot_changes_1 = (lr) => ({}), get_half_slot_context_1 = (lr) => ({}), get_full_slot_changes_1 = (lr) => ({}), get_full_slot_context_1 = (lr) => ({}), get_empty_slot_changes = (lr) => ({}), get_empty_slot_context = (lr) => ({}), get_half_slot_changes = (lr) => ({}), get_half_slot_context = (lr) => ({}), get_full_slot_changes = (lr) => ({}), get_full_slot_context = (lr) => ({});
function create_else_block_1$6(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  const yr = [create_if_block_3$6, create_if_block_4$4, create_else_block_2$1], kr = [];
  function _r(xr, Sr) {
    return Sr & /*value*/
    1 && (cr = null), Sr & /*value*/
    1 && (ur = null), cr == null && (cr = !!isFull(
      /*value*/
      xr[0],
      /*i*/
      xr[17]
    )), cr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      xr[0],
      /*i*/
      xr[17]
    )), ur ? 1 : 2);
  }
  return fr = _r(lr, -1), dr = kr[fr] = yr[fr](lr), {
    c() {
      ar = element("span"), dr.c(), gr = space(), attr(ar, "class", mr = "rating-icon " + /*regionIcon*/
      lr[3]);
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), kr[fr].m(ar, null), append(ar, gr), vr = !0;
    },
    p(xr, Sr) {
      let Er = fr;
      fr = _r(xr, Sr), fr === Er ? kr[fr].p(xr, Sr) : (group_outros(), transition_out(kr[Er], 1, 1, () => {
        kr[Er] = null;
      }), check_outros(), dr = kr[fr], dr ? dr.p(xr, Sr) : (dr = kr[fr] = yr[fr](xr), dr.c()), transition_in(dr, 1), dr.m(ar, gr)), (!vr || Sr & /*regionIcon*/
      8 && mr !== (mr = "rating-icon " + /*regionIcon*/
      xr[3])) && attr(ar, "class", mr);
    },
    i(xr) {
      vr || (transition_in(dr), vr = !0);
    },
    o(xr) {
      transition_out(dr), vr = !1;
    },
    d(xr) {
      xr && detach(ar), kr[fr].d();
    }
  };
}
function create_if_block$l(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr;
  const _r = [create_if_block_1$a, create_if_block_2$8, create_else_block$9], xr = [];
  function Sr(Cr, Tr) {
    return Tr & /*value*/
    1 && (cr = null), Tr & /*value*/
    1 && (ur = null), cr == null && (cr = !!isFull(
      /*value*/
      Cr[0],
      /*i*/
      Cr[17]
    )), cr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      Cr[0],
      /*i*/
      Cr[17]
    )), ur ? 1 : 2);
  }
  fr = Sr(lr, -1), dr = xr[fr] = _r[fr](lr);
  function Er() {
    return (
      /*click_handler*/
      lr[12](
        /*i*/
        lr[17]
      )
    );
  }
  return {
    c() {
      ar = element("button"), dr.c(), gr = space(), attr(ar, "class", mr = "rating-icon " + /*regionIcon*/
      lr[3]), attr(ar, "type", "button");
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), xr[fr].m(ar, null), append(ar, gr), vr = !0, yr || (kr = listen(ar, "click", Er), yr = !0);
    },
    p(Cr, Tr) {
      lr = Cr;
      let Ar = fr;
      fr = Sr(lr, Tr), fr === Ar ? xr[fr].p(lr, Tr) : (group_outros(), transition_out(xr[Ar], 1, 1, () => {
        xr[Ar] = null;
      }), check_outros(), dr = xr[fr], dr ? dr.p(lr, Tr) : (dr = xr[fr] = _r[fr](lr), dr.c()), transition_in(dr, 1), dr.m(ar, gr)), (!vr || Tr & /*regionIcon*/
      8 && mr !== (mr = "rating-icon " + /*regionIcon*/
      lr[3])) && attr(ar, "class", mr);
    },
    i(Cr) {
      vr || (transition_in(dr), vr = !0);
    },
    o(Cr) {
      transition_out(dr), vr = !1;
    },
    d(Cr) {
      Cr && detach(ar), xr[fr].d(), yr = !1, kr();
    }
  };
}
function create_else_block_2$1(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].empty
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_empty_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_empty_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_empty_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_4$4(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].half
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_half_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_half_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_half_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_3$6(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].full
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_full_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_full_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_full_slot_context_1
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_else_block$9(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].empty
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_empty_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_empty_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_empty_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_2$8(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].half
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_half_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_half_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_half_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_if_block_1$a(lr) {
  let ar;
  const cr = (
    /*#slots*/
    lr[11].full
  ), ur = create_slot(
    cr,
    lr,
    /*$$scope*/
    lr[10],
    get_full_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), ar = !0;
    },
    p(fr, dr) {
      ur && ur.p && (!ar || dr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        cr,
        fr,
        /*$$scope*/
        fr[10],
        ar ? get_slot_changes(
          cr,
          /*$$scope*/
          fr[10],
          dr,
          get_full_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[10]
        ),
        get_full_slot_context
      );
    },
    i(fr) {
      ar || (transition_in(ur, fr), ar = !0);
    },
    o(fr) {
      transition_out(ur, fr), ar = !1;
    },
    d(fr) {
      ur && ur.d(fr);
    }
  };
}
function create_each_block$8(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block$l, create_else_block_1$6], gr = [];
  function mr(vr, yr) {
    return (
      /*interactive*/
      vr[2] ? 0 : 1
    );
  }
  return ar = mr(lr), cr = gr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = empty$1();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), fr = !0;
    },
    p(vr, yr) {
      let kr = ar;
      ar = mr(vr), ar === kr ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), cr = gr[ar], cr ? cr.p(vr, yr) : (cr = gr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_fragment$R(lr) {
  let ar, cr, ur, fr = ensure_array_like({ length: (
    /*max*/
    lr[1]
  ) }), dr = [];
  for (let mr = 0; mr < fr.length; mr += 1)
    dr[mr] = create_each_block$8(get_each_context$8(lr, fr, mr));
  const gr = (mr) => transition_out(dr[mr], 1, 1, () => {
    dr[mr] = null;
  });
  return {
    c() {
      ar = element("div");
      for (let mr = 0; mr < dr.length; mr += 1)
        dr[mr].c();
      attr(ar, "class", cr = "ratings " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "rating-bar");
    },
    m(mr, vr) {
      insert(mr, ar, vr);
      for (let yr = 0; yr < dr.length; yr += 1)
        dr[yr] && dr[yr].m(ar, null);
      ur = !0;
    },
    p(mr, [vr]) {
      if (vr & /*regionIcon, iconClick, $$scope, isFull, value, isHalf, interactive, max*/
      1071) {
        fr = ensure_array_like({ length: (
          /*max*/
          mr[1]
        ) });
        let yr;
        for (yr = 0; yr < fr.length; yr += 1) {
          const kr = get_each_context$8(mr, fr, yr);
          dr[yr] ? (dr[yr].p(kr, vr), transition_in(dr[yr], 1)) : (dr[yr] = create_each_block$8(kr), dr[yr].c(), transition_in(dr[yr], 1), dr[yr].m(ar, null));
        }
        for (group_outros(), yr = fr.length; yr < dr.length; yr += 1)
          gr(yr);
        check_outros();
      }
      (!ur || vr & /*classesBase*/
      16 && cr !== (cr = "ratings " + /*classesBase*/
      mr[4])) && attr(ar, "class", cr);
    },
    i(mr) {
      if (!ur) {
        for (let vr = 0; vr < fr.length; vr += 1)
          transition_in(dr[vr]);
        ur = !0;
      }
    },
    o(mr) {
      dr = dr.filter(Boolean);
      for (let vr = 0; vr < dr.length; vr += 1)
        transition_out(dr[vr]);
      ur = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_each(dr, mr);
    }
  };
}
const cBase$c = "w-full flex";
function isFull(lr, ar) {
  return Math.floor(lr) >= ar + 1;
}
function isHalf(lr, ar) {
  return lr === ar + 0.5;
}
function instance$w(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { value: gr = 0 } = ar, { max: mr = 5 } = ar, { interactive: vr = !1 } = ar, { text: yr = "text-token" } = ar, { fill: kr = "fill-token" } = ar, { justify: _r = "justify-center" } = ar, { spacing: xr = "space-x-2" } = ar, { regionIcon: Sr = "" } = ar;
  const Er = createEventDispatcher();
  function Cr(Ar) {
    Er("icon", { index: Ar + 1 });
  }
  const Tr = (Ar) => Cr(Ar);
  return lr.$$set = (Ar) => {
    cr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ar))), "value" in Ar && cr(0, gr = Ar.value), "max" in Ar && cr(1, mr = Ar.max), "interactive" in Ar && cr(2, vr = Ar.interactive), "text" in Ar && cr(6, yr = Ar.text), "fill" in Ar && cr(7, kr = Ar.fill), "justify" in Ar && cr(8, _r = Ar.justify), "spacing" in Ar && cr(9, xr = Ar.spacing), "regionIcon" in Ar && cr(3, Sr = Ar.regionIcon), "$$scope" in Ar && cr(10, dr = Ar.$$scope);
  }, lr.$$.update = () => {
    var Ar;
    cr(4, ur = `${cBase$c} ${yr} ${kr} ${_r} ${xr} ${(Ar = ar.class) != null ? Ar : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    vr,
    Sr,
    ur,
    Cr,
    yr,
    kr,
    _r,
    xr,
    dr,
    fr,
    Tr
  ];
}
class Ratings extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$w, create_fragment$R, safe_not_equal, {
      value: 0,
      max: 1,
      interactive: 2,
      text: 6,
      fill: 7,
      justify: 8,
      spacing: 9,
      regionIcon: 3
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get max() {
    return this.$$.ctx[1];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[2];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get text() {
    return this.$$.ctx[6];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[8];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[9];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionIcon() {
    return this.$$.ctx[3];
  }
  set regionIcon(ar) {
    this.$$set({ regionIcon: ar }), flush();
  }
}
create_custom_element(Ratings, { value: {}, max: {}, interactive: { type: "Boolean" }, text: {}, fill: {}, justify: {}, spacing: {}, regionIcon: {} }, ["full", "half", "empty"], [], !0);
function create_fragment$Q(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[14].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[13],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "radio-group " + /*classesBase*/
      lr[1]), attr(ar, "data-testid", "radio-group"), attr(ar, "role", "radiogroup"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      8192) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[13],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[13],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[13]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      2 && cr !== (cr = "radio-group " + /*classesBase*/
      gr[1])) && attr(ar, "class", cr), (!ur || mr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        gr[0]
      );
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
const cBase$b = "p-1";
function instance$v(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { display: gr = "inline-flex" } = ar, { background: mr = "bg-surface-200-700-token" } = ar, { border: vr = "border-token border-surface-400-500-token" } = ar, { spacing: yr = "" } = ar, { rounded: kr = "rounded-token" } = ar, { padding: _r = "px-4 py-1" } = ar, { active: xr = "variant-filled" } = ar, { hover: Sr = "hover:variant-soft" } = ar, { color: Er = "" } = ar, { fill: Cr = "" } = ar, { regionLabel: Tr = "" } = ar, { labelledby: Ar = "" } = ar;
  return setContext("rounded", kr), setContext("padding", _r), setContext("active", xr), setContext("hover", Sr), setContext("color", Er), setContext("fill", Cr), setContext("regionLabel", Tr), lr.$$set = (Ir) => {
    cr(15, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ir))), "display" in Ir && cr(3, gr = Ir.display), "background" in Ir && cr(4, mr = Ir.background), "border" in Ir && cr(5, vr = Ir.border), "spacing" in Ir && cr(2, yr = Ir.spacing), "rounded" in Ir && cr(6, kr = Ir.rounded), "padding" in Ir && cr(7, _r = Ir.padding), "active" in Ir && cr(8, xr = Ir.active), "hover" in Ir && cr(9, Sr = Ir.hover), "color" in Ir && cr(10, Er = Ir.color), "fill" in Ir && cr(11, Cr = Ir.fill), "regionLabel" in Ir && cr(12, Tr = Ir.regionLabel), "labelledby" in Ir && cr(0, Ar = Ir.labelledby), "$$scope" in Ir && cr(13, dr = Ir.$$scope);
  }, lr.$$.update = () => {
    var Ir;
    lr.$$.dirty & /*display*/
    8 && cr(2, yr = `${gr.includes("flex-col") ? "" : "space-x-1"}`), cr(1, ur = `${cBase$b} ${gr} ${mr} ${vr} ${yr} ${kr} ${(Ir = ar.class) != null ? Ir : ""}`);
  }, ar = exclude_internal_props(ar), [
    Ar,
    ur,
    yr,
    gr,
    mr,
    vr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    dr,
    fr
  ];
}
class RadioGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$v, create_fragment$Q, safe_not_equal, {
      display: 3,
      background: 4,
      border: 5,
      spacing: 2,
      rounded: 6,
      padding: 7,
      active: 8,
      hover: 9,
      color: 10,
      fill: 11,
      regionLabel: 12,
      labelledby: 0
    });
  }
  get display() {
    return this.$$.ctx[3];
  }
  set display(ar) {
    this.$$set({ display: ar }), flush();
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[2];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[6];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[10];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[11];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[12];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RadioGroup, { display: {}, background: {}, border: {}, spacing: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {}, labelledby: {} }, ["default"], [], !0);
function create_fragment$P(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[11](),
    { tabindex: "-1" }
  ], Sr = {};
  for (let Tr = 0; Tr < xr.length; Tr += 1)
    Sr = assign$1(Sr, xr[Tr]);
  const Er = (
    /*#slots*/
    lr[21].default
  ), Cr = create_slot(
    Er,
    lr,
    /*$$scope*/
    lr[20],
    null
  );
  return yr = init_binding_group(
    /*$$binding_groups*/
    lr[29][0]
  ), {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), fr = element("input"), dr = space(), Cr && Cr.c(), set_attributes(fr, Sr), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(cr, "class", gr = "radio-item " + /*classesWrapper*/
      lr[8]), attr(cr, "data-testid", "radio-item"), attr(cr, "role", "radio"), attr(
        cr,
        "aria-checked",
        /*checked*/
        lr[6]
      ), attr(
        cr,
        "aria-label",
        /*label*/
        lr[4]
      ), attr(cr, "tabindex", "0"), attr(
        cr,
        "title",
        /*title*/
        lr[3]
      ), attr(ar, "class", mr = "radio-label " + /*classsBase*/
      lr[9] + " " + /*regionLabel*/
      lr[5]), yr.p(fr);
    },
    m(Tr, Ar) {
      insert(Tr, ar, Ar), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[27](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), Cr && Cr.m(cr, null), vr = !0, kr || (_r = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[28]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[25]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[26]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[22]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[23]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[24]
        )
      ], kr = !0);
    },
    p(Tr, Ar) {
      set_attributes(fr, Sr = get_spread_update(xr, [
        { type: "radio" },
        (!vr || Ar[0] & /*name*/
        2) && { name: (
          /*name*/
          Tr[1]
        ) },
        (!vr || Ar[0] & /*value*/
        4) && { __value: (
          /*value*/
          Tr[2]
        ) },
        /*prunedRestProps*/
        Tr[11](),
        { tabindex: "-1" }
      ])), Ar[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      Tr[0]), Cr && Cr.p && (!vr || Ar[0] & /*$$scope*/
      1048576) && update_slot_base(
        Cr,
        Er,
        Tr,
        /*$$scope*/
        Tr[20],
        vr ? get_slot_changes(
          Er,
          /*$$scope*/
          Tr[20],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[20]
        ),
        null
      ), (!vr || Ar[0] & /*classesWrapper*/
      256 && gr !== (gr = "radio-item " + /*classesWrapper*/
      Tr[8])) && attr(cr, "class", gr), (!vr || Ar[0] & /*checked*/
      64) && attr(
        cr,
        "aria-checked",
        /*checked*/
        Tr[6]
      ), (!vr || Ar[0] & /*label*/
      16) && attr(
        cr,
        "aria-label",
        /*label*/
        Tr[4]
      ), (!vr || Ar[0] & /*title*/
      8) && attr(
        cr,
        "title",
        /*title*/
        Tr[3]
      ), (!vr || Ar[0] & /*classsBase, regionLabel*/
      544 && mr !== (mr = "radio-label " + /*classsBase*/
      Tr[9] + " " + /*regionLabel*/
      Tr[5])) && attr(ar, "class", mr);
    },
    i(Tr) {
      vr || (transition_in(Cr, Tr), vr = !0);
    },
    o(Tr) {
      transition_out(Cr, Tr), vr = !1;
    },
    d(Tr) {
      Tr && detach(ar), lr[27](null), Cr && Cr.d(Tr), yr.r(), kr = !1, run_all(_r);
    }
  };
}
const cBase$a = "flex-auto", cWrapper$1 = "text-base text-center cursor-pointer", cDisabled$1 = "opacity-50 cursor-not-allowed";
function instance$u(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "label",
    "rounded",
    "padding",
    "active",
    "hover",
    "color",
    "fill",
    "regionLabel"
  ];
  let yr = compute_rest_props(ar, vr), { $$slots: kr = {}, $$scope: _r } = ar, { group: xr } = ar, { name: Sr } = ar, { value: Er } = ar, { title: Cr = "" } = ar, { label: Tr = "" } = ar, { rounded: Ar = getContext("rounded") } = ar, { padding: Ir = getContext("padding") } = ar, { active: Mr = getContext("active") } = ar, { hover: Hr = getContext("hover") } = ar, { color: Br = getContext("color") } = ar, { fill: zr = getContext("fill") } = ar, { regionLabel: Gr = getContext("regionLabel") } = ar, Xr;
  function Jr(vi) {
    ["Enter", "Space"].includes(vi.code) && (vi.preventDefault(), Xr.click());
  }
  function li() {
    return delete yr.class, yr;
  }
  const Qr = [[]];
  function ei(vi) {
    bubble.call(this, lr, vi);
  }
  function ui(vi) {
    bubble.call(this, lr, vi);
  }
  function Ai(vi) {
    bubble.call(this, lr, vi);
  }
  function fi(vi) {
    bubble.call(this, lr, vi);
  }
  function gi(vi) {
    bubble.call(this, lr, vi);
  }
  function Ci(vi) {
    binding_callbacks[vi ? "unshift" : "push"](() => {
      Xr = vi, cr(7, Xr);
    });
  }
  function mi() {
    xr = this.__value, cr(0, xr);
  }
  return lr.$$set = (vi) => {
    cr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(vi))), cr(30, yr = compute_rest_props(ar, vr)), "group" in vi && cr(0, xr = vi.group), "name" in vi && cr(1, Sr = vi.name), "value" in vi && cr(2, Er = vi.value), "title" in vi && cr(3, Cr = vi.title), "label" in vi && cr(4, Tr = vi.label), "rounded" in vi && cr(12, Ar = vi.rounded), "padding" in vi && cr(13, Ir = vi.padding), "active" in vi && cr(14, Mr = vi.active), "hover" in vi && cr(15, Hr = vi.hover), "color" in vi && cr(16, Br = vi.color), "fill" in vi && cr(17, zr = vi.fill), "regionLabel" in vi && cr(5, Gr = vi.regionLabel), "$$scope" in vi && cr(20, _r = vi.$$scope);
  }, lr.$$.update = () => {
    var vi;
    lr.$$.dirty[0] & /*value, group*/
    5 && cr(6, ur = Er === xr), lr.$$.dirty[0] & /*checked, active, color, fill, hover*/
    245824 && cr(19, fr = ur ? `${Mr} ${Br} ${zr}` : Hr), cr(18, dr = ar.disabled ? cDisabled$1 : ""), cr(8, mr = `${cWrapper$1} ${Ir} ${Ar} ${fr} ${dr} ${(vi = ar.class) != null ? vi : ""}`);
  }, cr(9, gr = `${cBase$a}`), ar = exclude_internal_props(ar), [
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Gr,
    ur,
    Xr,
    mr,
    gr,
    Jr,
    li,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    dr,
    fr,
    _r,
    kr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    Qr
  ];
}
class RadioItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$u,
      create_fragment$P,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        label: 4,
        rounded: 12,
        padding: 13,
        active: 14,
        hover: 15,
        color: 16,
        fill: 17,
        regionLabel: 5
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get label() {
    return this.$$.ctx[4];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[13];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[16];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[17];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[5];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
}
create_custom_element(RadioItem, { group: {}, name: {}, value: {}, title: {}, label: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {} }, ["default"], [], !0);
const get_trail_slot_changes = (lr) => ({}), get_trail_slot_context = (lr) => ({});
function get_each_context$7(lr, ar, cr) {
  const ur = lr.slice();
  return ur[23] = ar[cr], ur;
}
function create_if_block_2$7(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].default
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    null
  );
  return {
    c() {
      ar = element("label"), fr && fr.c(), attr(ar, "class", "range-slider-label " + cBaseLabel), attr(
        ar,
        "for",
        /*id*/
        lr[2]
      );
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        null
      ), (!cr || gr & /*id*/
      4) && attr(
        ar,
        "for",
        /*id*/
        dr[2]
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_if_block_1$9(lr) {
  let ar, cr, ur = ensure_array_like(
    /*tickmarks*/
    lr[8]
  ), fr = [];
  for (let dr = 0; dr < ur.length; dr += 1)
    fr[dr] = create_each_block$7(get_each_context$7(lr, ur, dr));
  return {
    c() {
      ar = element("datalist");
      for (let dr = 0; dr < fr.length; dr += 1)
        fr[dr].c();
      attr(ar, "id", cr = "tickmarks-" + /*id*/
      lr[2]), attr(ar, "class", "range-slider-ticks");
    },
    m(dr, gr) {
      insert(dr, ar, gr);
      for (let mr = 0; mr < fr.length; mr += 1)
        fr[mr] && fr[mr].m(ar, null);
    },
    p(dr, gr) {
      if (gr & /*tickmarks*/
      256) {
        ur = ensure_array_like(
          /*tickmarks*/
          dr[8]
        );
        let mr;
        for (mr = 0; mr < ur.length; mr += 1) {
          const vr = get_each_context$7(dr, ur, mr);
          fr[mr] ? fr[mr].p(vr, gr) : (fr[mr] = create_each_block$7(vr), fr[mr].c(), fr[mr].m(ar, null));
        }
        for (; mr < fr.length; mr += 1)
          fr[mr].d(1);
        fr.length = ur.length;
      }
      gr & /*id*/
      4 && cr !== (cr = "tickmarks-" + /*id*/
      dr[2]) && attr(ar, "id", cr);
    },
    d(dr) {
      dr && detach(ar), destroy_each(fr, dr);
    }
  };
}
function create_each_block$7(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("option"), ar.__value = cr = /*tm*/
      lr[23], set_input_value(ar, ar.__value), attr(ar, "label", ur = /*tm*/
      lr[23]);
    },
    m(fr, dr) {
      insert(fr, ar, dr);
    },
    p(fr, dr) {
      dr & /*tickmarks*/
      256 && cr !== (cr = /*tm*/
      fr[23]) && (ar.__value = cr, set_input_value(ar, ar.__value)), dr & /*tickmarks*/
      256 && ur !== (ur = /*tm*/
      fr[23]) && attr(ar, "label", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block$k(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].trail
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    get_trail_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "range-slider-trail");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          gr,
          get_trail_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        get_trail_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$O(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr = (
    /*$$slots*/
    lr[12].default && create_if_block_2$7(lr)
  ), Er = [
    { type: "range" },
    { id: (
      /*id*/
      lr[2]
    ) },
    { name: (
      /*name*/
      lr[1]
    ) },
    {
      class: dr = "range-slider-input " + /*classesInput*/
      lr[9]
    },
    {
      list: gr = "tickmarks-" + /*id*/
      lr[2]
    },
    { "aria-label": (
      /*label*/
      lr[7]
    ) },
    { min: (
      /*min*/
      lr[3]
    ) },
    { max: (
      /*max*/
      lr[4]
    ) },
    { step: (
      /*step*/
      lr[5]
    ) },
    /*prunedRestProps*/
    lr[11]()
  ], Cr = {};
  for (let Ir = 0; Ir < Er.length; Ir += 1)
    Cr = assign$1(Cr, Er[Ir]);
  let Tr = (
    /*ticked*/
    lr[6] && /*tickmarks*/
    lr[8] && /*tickmarks*/
    lr[8].length && create_if_block_1$9(lr)
  ), Ar = (
    /*$$slots*/
    lr[12].trail && create_if_block$k(lr)
  );
  return {
    c() {
      ar = element("div"), Sr && Sr.c(), cr = space(), ur = element("div"), fr = element("input"), mr = space(), Tr && Tr.c(), vr = space(), Ar && Ar.c(), set_attributes(fr, Cr), attr(ur, "class", "range-content " + cBaseContent), attr(ar, "class", yr = "range-slider " + /*classesBase*/
      lr[10]), attr(ar, "data-testid", "range-slider");
    },
    m(Ir, Mr) {
      insert(Ir, ar, Mr), Sr && Sr.m(ar, null), append(ar, cr), append(ar, ur), append(ur, fr), fr.autofocus && fr.focus(), set_input_value(
        fr,
        /*value*/
        lr[0]
      ), append(ur, mr), Tr && Tr.m(ur, null), append(ar, vr), Ar && Ar.m(ar, null), kr = !0, _r || (xr = [
        listen(
          fr,
          "change",
          /*input_change_input_handler*/
          lr[19]
        ),
        listen(
          fr,
          "input",
          /*input_change_input_handler*/
          lr[19]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[16]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[17]
        ),
        listen(
          fr,
          "blur",
          /*blur_handler*/
          lr[18]
        )
      ], _r = !0);
    },
    p(Ir, [Mr]) {
      /*$$slots*/
      Ir[12].default ? Sr ? (Sr.p(Ir, Mr), Mr & /*$$slots*/
      4096 && transition_in(Sr, 1)) : (Sr = create_if_block_2$7(Ir), Sr.c(), transition_in(Sr, 1), Sr.m(ar, cr)) : Sr && (group_outros(), transition_out(Sr, 1, 1, () => {
        Sr = null;
      }), check_outros()), set_attributes(fr, Cr = get_spread_update(Er, [
        { type: "range" },
        (!kr || Mr & /*id*/
        4) && { id: (
          /*id*/
          Ir[2]
        ) },
        (!kr || Mr & /*name*/
        2) && { name: (
          /*name*/
          Ir[1]
        ) },
        (!kr || Mr & /*classesInput*/
        512 && dr !== (dr = "range-slider-input " + /*classesInput*/
        Ir[9])) && { class: dr },
        (!kr || Mr & /*id*/
        4 && gr !== (gr = "tickmarks-" + /*id*/
        Ir[2])) && { list: gr },
        (!kr || Mr & /*label*/
        128) && { "aria-label": (
          /*label*/
          Ir[7]
        ) },
        (!kr || Mr & /*min*/
        8) && { min: (
          /*min*/
          Ir[3]
        ) },
        (!kr || Mr & /*max*/
        16) && { max: (
          /*max*/
          Ir[4]
        ) },
        (!kr || Mr & /*step*/
        32) && { step: (
          /*step*/
          Ir[5]
        ) },
        /*prunedRestProps*/
        Ir[11]()
      ])), Mr & /*value*/
      1 && set_input_value(
        fr,
        /*value*/
        Ir[0]
      ), /*ticked*/
      Ir[6] && /*tickmarks*/
      Ir[8] && /*tickmarks*/
      Ir[8].length ? Tr ? Tr.p(Ir, Mr) : (Tr = create_if_block_1$9(Ir), Tr.c(), Tr.m(ur, null)) : Tr && (Tr.d(1), Tr = null), /*$$slots*/
      Ir[12].trail ? Ar ? (Ar.p(Ir, Mr), Mr & /*$$slots*/
      4096 && transition_in(Ar, 1)) : (Ar = create_if_block$k(Ir), Ar.c(), transition_in(Ar, 1), Ar.m(ar, null)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), (!kr || Mr & /*classesBase*/
      1024 && yr !== (yr = "range-slider " + /*classesBase*/
      Ir[10])) && attr(ar, "class", yr);
    },
    i(Ir) {
      kr || (transition_in(Sr), transition_in(Ar), kr = !0);
    },
    o(Ir) {
      transition_out(Sr), transition_out(Ar), kr = !1;
    },
    d(Ir) {
      Ir && detach(ar), Sr && Sr.d(), Tr && Tr.d(), Ar && Ar.d(), _r = !1, run_all(xr);
    }
  };
}
const cBase$9 = "space-y-2", cBaseLabel = "", cBaseContent = "flex justify-center py-2", cBaseInput = "w-full h-2";
function instance$t(lr, ar, cr) {
  let ur, fr;
  const dr = ["name", "id", "value", "min", "max", "step", "ticked", "accent", "label"];
  let gr = compute_rest_props(ar, dr), { $$slots: mr = {}, $$scope: vr } = ar;
  const yr = compute_slots(mr);
  let { name: kr } = ar, { id: _r = String(Math.random()) } = ar, { value: xr = 0 } = ar, { min: Sr = 0 } = ar, { max: Er = 100 } = ar, { step: Cr = 1 } = ar, { ticked: Tr = !1 } = ar, { accent: Ar = "accent-surface-900 dark:accent-surface-50" } = ar, { label: Ir = "" } = ar, Mr;
  function Hr() {
    Tr != !1 && cr(8, Mr = Array.from({ length: Er - Sr + 1 }, (li, Qr) => Qr + Sr));
  }
  Tr && Hr(), afterUpdate(() => {
    Hr();
  });
  function Br() {
    return delete gr.class, gr;
  }
  function zr(li) {
    bubble.call(this, lr, li);
  }
  function Gr(li) {
    bubble.call(this, lr, li);
  }
  function Xr(li) {
    bubble.call(this, lr, li);
  }
  function Jr() {
    xr = to_number(this.value), cr(0, xr);
  }
  return lr.$$set = (li) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(li))), cr(21, gr = compute_rest_props(ar, dr)), "name" in li && cr(1, kr = li.name), "id" in li && cr(2, _r = li.id), "value" in li && cr(0, xr = li.value), "min" in li && cr(3, Sr = li.min), "max" in li && cr(4, Er = li.max), "step" in li && cr(5, Cr = li.step), "ticked" in li && cr(6, Tr = li.ticked), "accent" in li && cr(13, Ar = li.accent), "label" in li && cr(7, Ir = li.label), "$$scope" in li && cr(14, vr = li.$$scope);
  }, lr.$$.update = () => {
    var li;
    cr(10, ur = `${cBase$9} ${(li = ar.class) != null ? li : ""}`), lr.$$.dirty & /*accent*/
    8192 && cr(9, fr = `${cBaseInput} ${Ar}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    kr,
    _r,
    Sr,
    Er,
    Cr,
    Tr,
    Ir,
    Mr,
    fr,
    ur,
    Br,
    yr,
    Ar,
    vr,
    mr,
    zr,
    Gr,
    Xr,
    Jr
  ];
}
class RangeSlider extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$t, create_fragment$O, safe_not_equal, {
      name: 1,
      id: 2,
      value: 0,
      min: 3,
      max: 4,
      step: 5,
      ticked: 6,
      accent: 13,
      label: 7
    });
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get id() {
    return this.$$.ctx[2];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[3];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[4];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get step() {
    return this.$$.ctx[5];
  }
  set step(ar) {
    this.$$set({ step: ar }), flush();
  }
  get ticked() {
    return this.$$.ctx[6];
  }
  set ticked(ar) {
    this.$$set({ ticked: ar }), flush();
  }
  get accent() {
    return this.$$.ctx[13];
  }
  set accent(ar) {
    this.$$set({ accent: ar }), flush();
  }
  get label() {
    return this.$$.ctx[7];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(RangeSlider, { name: {}, id: {}, value: {}, min: {}, max: {}, step: {}, ticked: { type: "Boolean" }, accent: {}, label: {} }, ["default", "trail"], [], !0);
function create_if_block$j(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[22].default
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "slide-toggle-text ml-3");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr[0] & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[21],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[21],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[21]
        ),
        null
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$N(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    { name: (
      /*name*/
      lr[1]
    ) },
    /*prunedRestProps*/
    lr[8](),
    {
      disabled: fr = /*$$props*/
      lr[9].disabled
    }
  ], Ar = {};
  for (let Mr = 0; Mr < Tr.length; Mr += 1)
    Ar = assign$1(Ar, Tr[Mr]);
  let Ir = (
    /*$$slots*/
    lr[10].default && create_if_block$j(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("label"), ur = element("input"), dr = space(), gr = element("div"), mr = element("div"), kr = space(), Ir && Ir.c(), set_attributes(ur, Ar), attr(mr, "class", vr = "slide-toggle-thumb " + /*classesThumb*/
      lr[3]), toggle_class(
        mr,
        "cursor-not-allowed",
        /*$$props*/
        lr[9].disabled
      ), attr(gr, "class", yr = "slide-toggle-track " + /*classesTrack*/
      lr[4]), toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        lr[9].disabled
      ), attr(cr, "class", _r = "slide-toggle-label " + /*classesLabel*/
      lr[5]), attr(
        ar,
        "id",
        /*label*/
        lr[2]
      ), attr(ar, "class", xr = "slide-toggle " + /*classesBase*/
      lr[6]), attr(ar, "data-testid", "slide-toggle"), attr(ar, "role", "switch"), attr(
        ar,
        "aria-label",
        /*label*/
        lr[2]
      ), attr(
        ar,
        "aria-checked",
        /*checked*/
        lr[0]
      ), attr(ar, "tabindex", "0");
    },
    m(Mr, Hr) {
      insert(Mr, ar, Hr), append(ar, cr), append(cr, ur), ur.autofocus && ur.focus(), ur.checked = /*checked*/
      lr[0], append(cr, dr), append(cr, gr), append(gr, mr), append(cr, kr), Ir && Ir.m(cr, null), Sr = !0, Er || (Cr = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          lr[31]
        ),
        listen(
          ur,
          "click",
          /*click_handler*/
          lr[23]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          lr[24]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          lr[25]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          lr[26]
        ),
        listen(
          ur,
          "mouseover",
          /*mouseover_handler*/
          lr[27]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          lr[28]
        ),
        listen(
          ur,
          "focus",
          /*focus_handler*/
          lr[29]
        ),
        listen(
          ur,
          "blur",
          /*blur_handler*/
          lr[30]
        ),
        listen(
          ar,
          "keydown",
          /*onKeyDown*/
          lr[7]
        )
      ], Er = !0);
    },
    p(Mr, Hr) {
      set_attributes(ur, Ar = get_spread_update(Tr, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        (!Sr || Hr[0] & /*name*/
        2) && { name: (
          /*name*/
          Mr[1]
        ) },
        /*prunedRestProps*/
        Mr[8](),
        (!Sr || Hr[0] & /*$$props*/
        512 && fr !== (fr = /*$$props*/
        Mr[9].disabled)) && { disabled: fr }
      ])), Hr[0] & /*checked*/
      1 && (ur.checked = /*checked*/
      Mr[0]), (!Sr || Hr[0] & /*classesThumb*/
      8 && vr !== (vr = "slide-toggle-thumb " + /*classesThumb*/
      Mr[3])) && attr(mr, "class", vr), (!Sr || Hr[0] & /*classesThumb, $$props*/
      520) && toggle_class(
        mr,
        "cursor-not-allowed",
        /*$$props*/
        Mr[9].disabled
      ), (!Sr || Hr[0] & /*classesTrack*/
      16 && yr !== (yr = "slide-toggle-track " + /*classesTrack*/
      Mr[4])) && attr(gr, "class", yr), (!Sr || Hr[0] & /*classesTrack, $$props*/
      528) && toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        Mr[9].disabled
      ), /*$$slots*/
      Mr[10].default ? Ir ? (Ir.p(Mr, Hr), Hr[0] & /*$$slots*/
      1024 && transition_in(Ir, 1)) : (Ir = create_if_block$j(Mr), Ir.c(), transition_in(Ir, 1), Ir.m(cr, null)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), (!Sr || Hr[0] & /*classesLabel*/
      32 && _r !== (_r = "slide-toggle-label " + /*classesLabel*/
      Mr[5])) && attr(cr, "class", _r), (!Sr || Hr[0] & /*label*/
      4) && attr(
        ar,
        "id",
        /*label*/
        Mr[2]
      ), (!Sr || Hr[0] & /*classesBase*/
      64 && xr !== (xr = "slide-toggle " + /*classesBase*/
      Mr[6])) && attr(ar, "class", xr), (!Sr || Hr[0] & /*label*/
      4) && attr(
        ar,
        "aria-label",
        /*label*/
        Mr[2]
      ), (!Sr || Hr[0] & /*checked*/
      1) && attr(
        ar,
        "aria-checked",
        /*checked*/
        Mr[0]
      );
    },
    i(Mr) {
      Sr || (transition_in(Ir), Sr = !0);
    },
    o(Mr) {
      transition_out(Ir), Sr = !1;
    },
    d(Mr) {
      Mr && detach(ar), Ir && Ir.d(), Er = !1, run_all(Cr);
    }
  };
}
const cBase$8 = "inline-block", cLabel = "unstyled flex items-center", cTrack$1 = "flex transition-all duration-[200ms] cursor-pointer", cThumb$1 = "w-[50%] h-full scale-[0.8] transition-all duration-[200ms] shadow";
function instance$s(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr;
  const _r = ["name", "checked", "size", "background", "active", "border", "rounded", "label"];
  let xr = compute_rest_props(ar, _r), { $$slots: Sr = {}, $$scope: Er } = ar;
  const Cr = compute_slots(Sr), Tr = createEventDispatcher();
  let { name: Ar } = ar, { checked: Ir = !1 } = ar, { size: Mr = "md" } = ar, { background: Hr = "bg-surface-400 dark:bg-surface-700" } = ar, { active: Br = "bg-surface-900 dark:bg-surface-300" } = ar, { border: zr = "" } = ar, { rounded: Gr = "rounded-full" } = ar, { label: Xr = "" } = ar, Jr;
  switch (Mr) {
    case "sm":
      Jr = "w-12 h-6";
      break;
    case "lg":
      Jr = "w-20 h-10";
      break;
    default:
      Jr = "w-16 h-8";
  }
  function li(di) {
    ["Enter", "Space"].includes(di.code) && (di.preventDefault(), Tr("keyup", di), di.currentTarget.firstChild.click());
  }
  function Qr() {
    return delete xr.class, xr;
  }
  function ei(di) {
    bubble.call(this, lr, di);
  }
  function ui(di) {
    bubble.call(this, lr, di);
  }
  function Ai(di) {
    bubble.call(this, lr, di);
  }
  function fi(di) {
    bubble.call(this, lr, di);
  }
  function gi(di) {
    bubble.call(this, lr, di);
  }
  function Ci(di) {
    bubble.call(this, lr, di);
  }
  function mi(di) {
    bubble.call(this, lr, di);
  }
  function vi(di) {
    bubble.call(this, lr, di);
  }
  function Ri() {
    Ir = this.checked, cr(0, Ir);
  }
  return lr.$$set = (di) => {
    cr(9, ar = assign$1(assign$1({}, ar), exclude_internal_props(di))), cr(33, xr = compute_rest_props(ar, _r)), "name" in di && cr(1, Ar = di.name), "checked" in di && cr(0, Ir = di.checked), "size" in di && cr(11, Mr = di.size), "background" in di && cr(12, Hr = di.background), "active" in di && cr(13, Br = di.active), "border" in di && cr(14, zr = di.border), "rounded" in di && cr(15, Gr = di.rounded), "label" in di && cr(2, Xr = di.label), "$$scope" in di && cr(21, Er = di.$$scope);
  }, lr.$$.update = () => {
    var di;
    lr.$$.dirty[0] & /*checked, active, background*/
    12289 && cr(19, ur = Ir ? Br : `${Hr} cursor-pointer`), lr.$$.dirty[0] & /*checked*/
    1 && cr(18, fr = Ir ? "bg-white/75" : "bg-white"), lr.$$.dirty[0] & /*checked*/
    1 && cr(17, dr = Ir ? "translate-x-full" : ""), cr(20, gr = ar.disabled === !0 ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer"), cr(6, mr = `${cBase$8} ${Gr} ${gr} ${(di = ar.class) != null ? di : ""}`), lr.$$.dirty[0] & /*border, rounded, trackSize, cTrackActive*/
    638976 && cr(4, yr = `${cTrack$1} ${zr} ${Gr} ${Jr} ${ur}`), lr.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    425984 && cr(3, kr = `${cThumb$1} ${Gr} ${fr} ${dr}`);
  }, cr(5, vr = `${cLabel}`), ar = exclude_internal_props(ar), [
    Ir,
    Ar,
    Xr,
    kr,
    yr,
    vr,
    mr,
    li,
    Qr,
    ar,
    Cr,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Jr,
    dr,
    fr,
    ur,
    gr,
    Er,
    Sr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    Ri
  ];
}
class SlideToggle extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$s,
      create_fragment$N,
      safe_not_equal,
      {
        name: 1,
        checked: 0,
        size: 11,
        background: 12,
        active: 13,
        border: 14,
        rounded: 15,
        label: 2
      },
      null,
      [-1, -1]
    );
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[0];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get size() {
    return this.$$.ctx[11];
  }
  set size(ar) {
    this.$$set({ size: ar }), flush();
  }
  get background() {
    return this.$$.ctx[12];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get label() {
    return this.$$.ctx[2];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(SlideToggle, { name: {}, checked: { type: "Boolean" }, size: {}, background: {}, active: {}, border: {}, rounded: {}, label: {} }, ["default"], [], !0);
function get_each_context$6(lr, ar, cr) {
  const ur = lr.slice();
  return ur[36] = ar[cr], ur;
}
function create_if_block$i(lr) {
  let ar, cr, ur, fr, dr, gr = ensure_array_like(Array.from(Array(
    /*$state*/
    lr[7].total
  ).keys())), mr = [];
  for (let vr = 0; vr < gr.length; vr += 1)
    mr[vr] = create_each_block$6(get_each_context$6(lr, gr, vr));
  return {
    c() {
      ar = element("header");
      for (let vr = 0; vr < mr.length; vr += 1)
        mr[vr].c();
      attr(ar, "class", cr = "stepper-header " + /*classesHeader*/
      lr[11]);
    },
    m(vr, yr) {
      insert(vr, ar, yr);
      for (let kr = 0; kr < mr.length; kr += 1)
        mr[kr] && mr[kr].m(ar, null);
      dr = !0;
    },
    p(vr, yr) {
      if (lr = vr, yr[0] & /*classesHeaderStep, isActive, $state, classesBadge, stepTerm*/
      1729) {
        gr = ensure_array_like(Array.from(Array(
          /*$state*/
          lr[7].total
        ).keys()));
        let kr;
        for (kr = 0; kr < gr.length; kr += 1) {
          const _r = get_each_context$6(lr, gr, kr);
          mr[kr] ? mr[kr].p(_r, yr) : (mr[kr] = create_each_block$6(_r), mr[kr].c(), mr[kr].m(ar, null));
        }
        for (; kr < mr.length; kr += 1)
          mr[kr].d(1);
        mr.length = gr.length;
      }
      (!dr || yr[0] & /*classesHeader*/
      2048 && cr !== (cr = "stepper-header " + /*classesHeader*/
      lr[11])) && attr(ar, "class", cr);
    },
    i(vr) {
      dr || (vr && add_render_callback(() => {
        dr && (fr && fr.end(1), ur = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[2]
          ),
          params: (
            /*transitionInParams*/
            lr[3]
          ),
          enabled: (
            /*transitions*/
            lr[1]
          )
        }), ur.start());
      }), dr = !0);
    },
    o(vr) {
      ur && ur.invalidate(), vr && (fr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[4]
        ),
        params: (
          /*transitionOutParams*/
          lr[5]
        ),
        enabled: (
          /*transitions*/
          lr[1]
        )
      })), dr = !1;
    },
    d(vr) {
      vr && detach(ar), destroy_each(mr, vr), vr && fr && fr.end();
    }
  };
}
function create_each_block$6(lr) {
  let ar, cr, ur = (
    /*isActive*/
    (lr[6](
      /*step*/
      lr[36]
    ) ? `${/*stepTerm*/
    lr[0]} ${/*step*/
    lr[36] + 1}` : (
      /*step*/
      lr[36] + 1
    )) + ""
  ), fr, dr, gr, mr;
  return {
    c() {
      ar = element("div"), cr = element("span"), fr = text$3(ur), gr = space(), attr(cr, "class", dr = "badge " + /*classesBadge*/
      lr[9](
        /*step*/
        lr[36]
      )), attr(ar, "class", mr = "stepper-header-step " + /*classesHeaderStep*/
      lr[10]), toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        lr[6](
          /*step*/
          lr[36]
        )
      );
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, cr), append(cr, fr), append(ar, gr);
    },
    p(vr, yr) {
      yr[0] & /*isActive, $state, stepTerm*/
      193 && ur !== (ur = /*isActive*/
      (vr[6](
        /*step*/
        vr[36]
      ) ? `${/*stepTerm*/
      vr[0]} ${/*step*/
      vr[36] + 1}` : (
        /*step*/
        vr[36] + 1
      )) + "") && set_data(fr, ur), yr[0] & /*classesBadge, $state*/
      640 && dr !== (dr = "badge " + /*classesBadge*/
      vr[9](
        /*step*/
        vr[36]
      )) && attr(cr, "class", dr), yr[0] & /*classesHeaderStep*/
      1024 && mr !== (mr = "stepper-header-step " + /*classesHeaderStep*/
      vr[10]) && attr(ar, "class", mr), yr[0] & /*classesHeaderStep, isActive, $state*/
      1216 && toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        vr[6](
          /*step*/
          vr[36]
        )
      );
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_fragment$M(lr) {
  let ar, cr, ur, fr, dr, gr, mr = (
    /*$state*/
    lr[7].total && create_if_block$i(lr)
  );
  const vr = (
    /*#slots*/
    lr[32].default
  ), yr = create_slot(
    vr,
    lr,
    /*$$scope*/
    lr[31],
    null
  );
  return {
    c() {
      ar = element("div"), mr && mr.c(), cr = space(), ur = element("div"), yr && yr.c(), attr(ur, "class", fr = "stepper-content " + /*classesContent*/
      lr[8]), attr(ar, "class", dr = "stepper " + /*classesBase*/
      lr[12]), attr(ar, "data-testid", "stepper");
    },
    m(kr, _r) {
      insert(kr, ar, _r), mr && mr.m(ar, null), append(ar, cr), append(ar, ur), yr && yr.m(ur, null), gr = !0;
    },
    p(kr, _r) {
      /*$state*/
      kr[7].total ? mr ? (mr.p(kr, _r), _r[0] & /*$state*/
      128 && transition_in(mr, 1)) : (mr = create_if_block$i(kr), mr.c(), transition_in(mr, 1), mr.m(ar, cr)) : mr && (group_outros(), transition_out(mr, 1, 1, () => {
        mr = null;
      }), check_outros()), yr && yr.p && (!gr || _r[1] & /*$$scope*/
      1) && update_slot_base(
        yr,
        vr,
        kr,
        /*$$scope*/
        kr[31],
        gr ? get_slot_changes(
          vr,
          /*$$scope*/
          kr[31],
          _r,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          kr[31]
        ),
        null
      ), (!gr || _r[0] & /*classesContent*/
      256 && fr !== (fr = "stepper-content " + /*classesContent*/
      kr[8])) && attr(ur, "class", fr), (!gr || _r[0] & /*classesBase*/
      4096 && dr !== (dr = "stepper " + /*classesBase*/
      kr[12])) && attr(ar, "class", dr);
    },
    i(kr) {
      gr || (transition_in(mr), transition_in(yr, kr), gr = !0);
    },
    o(kr) {
      transition_out(mr), transition_out(yr, kr), gr = !1;
    },
    d(kr) {
      kr && detach(ar), mr && mr.d(), yr && yr.d(kr);
    }
  };
}
const cBase$7 = "space-y-4", cHeader$2 = "flex items-center border-t mt-[15px]", cHeaderStep = "-mt-[15px] transition-all duration-300", cContent$1 = "";
function instance$r(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr;
  component_subscribe(lr, prefersReducedMotionStore, (Ti) => cr(33, kr = Ti));
  let { $$slots: _r = {}, $$scope: xr } = ar;
  const Sr = createEventDispatcher();
  let { gap: Er = "gap-4" } = ar, { stepTerm: Cr = "Step" } = ar, { badge: Tr = "variant-filled-surface" } = ar, { active: Ar = "variant-filled" } = ar, { border: Ir = "border-surface-400-500-token" } = ar, { start: Mr = 0 } = ar, { justify: Hr = "justify-between" } = ar, { buttonBack: Br = "variant-ghost" } = ar, { buttonBackType: zr = "button" } = ar, { buttonBackLabel: Gr = "&larr; Back" } = ar, { buttonNext: Xr = "variant-filled" } = ar, { buttonNextType: Jr = "button" } = ar, { buttonNextLabel: li = "Next &rarr;" } = ar, { buttonComplete: Qr = "variant-filled-primary" } = ar, { buttonCompleteType: ei = "button" } = ar, { buttonCompleteLabel: ui = "Complete" } = ar, { regionHeader: Ai = "" } = ar, { regionContent: fi = "" } = ar, { transitions: gi = !kr } = ar, { transitionIn: Ci = fade } = ar, { transitionInParams: mi = { duration: 100 } } = ar, { transitionOut: vi = fade } = ar, { transitionOutParams: Ri = { duration: 100 } } = ar, di = writable({ current: Mr, total: 0 });
  return component_subscribe(lr, di, (Ti) => cr(7, yr = Ti)), setContext("state", di), setContext("dispatchParent", Sr), setContext("stepTerm", Cr), setContext("gap", Er), setContext("justify", Hr), setContext("buttonBack", Br), setContext("buttonBackType", zr), setContext("buttonBackLabel", Gr), setContext("buttonNext", Xr), setContext("buttonNextType", Jr), setContext("buttonNextLabel", li), setContext("buttonComplete", Qr), setContext("buttonCompleteType", ei), setContext("buttonCompleteLabel", ui), setContext("transitions", gi), setContext("transitionIn", Ci), setContext("transitionInParams", mi), setContext("transitionOut", vi), setContext("transitionOutParams", Ri), lr.$$set = (Ti) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ti))), "gap" in Ti && cr(14, Er = Ti.gap), "stepTerm" in Ti && cr(0, Cr = Ti.stepTerm), "badge" in Ti && cr(15, Tr = Ti.badge), "active" in Ti && cr(16, Ar = Ti.active), "border" in Ti && cr(17, Ir = Ti.border), "start" in Ti && cr(18, Mr = Ti.start), "justify" in Ti && cr(19, Hr = Ti.justify), "buttonBack" in Ti && cr(20, Br = Ti.buttonBack), "buttonBackType" in Ti && cr(21, zr = Ti.buttonBackType), "buttonBackLabel" in Ti && cr(22, Gr = Ti.buttonBackLabel), "buttonNext" in Ti && cr(23, Xr = Ti.buttonNext), "buttonNextType" in Ti && cr(24, Jr = Ti.buttonNextType), "buttonNextLabel" in Ti && cr(25, li = Ti.buttonNextLabel), "buttonComplete" in Ti && cr(26, Qr = Ti.buttonComplete), "buttonCompleteType" in Ti && cr(27, ei = Ti.buttonCompleteType), "buttonCompleteLabel" in Ti && cr(28, ui = Ti.buttonCompleteLabel), "regionHeader" in Ti && cr(29, Ai = Ti.regionHeader), "regionContent" in Ti && cr(30, fi = Ti.regionContent), "transitions" in Ti && cr(1, gi = Ti.transitions), "transitionIn" in Ti && cr(2, Ci = Ti.transitionIn), "transitionInParams" in Ti && cr(3, mi = Ti.transitionInParams), "transitionOut" in Ti && cr(4, vi = Ti.transitionOut), "transitionOutParams" in Ti && cr(5, Ri = Ti.transitionOutParams), "$$scope" in Ti && cr(31, xr = Ti.$$scope);
  }, lr.$$.update = () => {
    var Ti;
    lr.$$.dirty[0] & /*$state*/
    128 && cr(6, ur = (qi) => qi === yr.current), cr(12, fr = `${cBase$7} ${(Ti = ar.class) != null ? Ti : ""}`), lr.$$.dirty[0] & /*border, gap, regionHeader*/
    537018368 && cr(11, dr = `${cHeader$2} ${Ir} ${Er} ${Ai}`), lr.$$.dirty[0] & /*isActive, active, badge*/
    98368 && cr(9, mr = (qi) => ur(qi) ? Ar : Tr), lr.$$.dirty[0] & /*regionContent*/
    1073741824 && cr(8, vr = `${cContent$1} ${fi}`);
  }, cr(10, gr = `${cHeaderStep}`), ar = exclude_internal_props(ar), [
    Cr,
    gi,
    Ci,
    mi,
    vi,
    Ri,
    ur,
    yr,
    vr,
    mr,
    gr,
    dr,
    fr,
    di,
    Er,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    xr,
    _r
  ];
}
class Stepper extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$r,
      create_fragment$M,
      safe_not_equal,
      {
        gap: 14,
        stepTerm: 0,
        badge: 15,
        active: 16,
        border: 17,
        start: 18,
        justify: 19,
        buttonBack: 20,
        buttonBackType: 21,
        buttonBackLabel: 22,
        buttonNext: 23,
        buttonNextType: 24,
        buttonNextLabel: 25,
        buttonComplete: 26,
        buttonCompleteType: 27,
        buttonCompleteLabel: 28,
        regionHeader: 29,
        regionContent: 30,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get gap() {
    return this.$$.ctx[14];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[0];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get badge() {
    return this.$$.ctx[15];
  }
  set badge(ar) {
    this.$$set({ badge: ar }), flush();
  }
  get active() {
    return this.$$.ctx[16];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[17];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get start() {
    return this.$$.ctx[18];
  }
  set start(ar) {
    this.$$set({ start: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[19];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[20];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[21];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[22];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[23];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[24];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[25];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[26];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[27];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[28];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[29];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[30];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Stepper, { gap: {}, stepTerm: {}, badge: {}, active: {}, border: {}, start: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, regionHeader: {}, regionContent: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
const get_navigation_slot_changes = (lr) => ({}), get_navigation_slot_context = (lr) => ({}), get_header_slot_changes = (lr) => ({}), get_header_slot_context = (lr) => ({});
function create_if_block$h(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr;
  const kr = (
    /*#slots*/
    lr[34].header
  ), _r = create_slot(
    kr,
    lr,
    /*$$scope*/
    lr[33],
    get_header_slot_context
  ), xr = _r || fallback_block_1(lr), Sr = (
    /*#slots*/
    lr[34].default
  ), Er = create_slot(
    Sr,
    lr,
    /*$$scope*/
    lr[33],
    null
  ), Cr = Er || fallback_block$1(lr);
  let Tr = (
    /*$state*/
    lr[21].total > 1 && create_if_block_1$8(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("header"), xr && xr.c(), fr = space(), dr = element("div"), Cr && Cr.c(), mr = space(), Tr && Tr.c(), attr(cr, "class", ur = "step-header " + /*classesHeader*/
      lr[19]), attr(dr, "class", gr = "step-content " + /*classesContent*/
      lr[18]), attr(ar, "class", vr = "step " + /*classesBase*/
      lr[20]), attr(ar, "data-testid", "step");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), xr && xr.m(cr, null), append(ar, fr), append(ar, dr), Cr && Cr.m(dr, null), append(ar, mr), Tr && Tr.m(ar, null), yr = !0;
    },
    p(Ar, Ir) {
      _r ? _r.p && (!yr || Ir[1] & /*$$scope*/
      4) && update_slot_base(
        _r,
        kr,
        Ar,
        /*$$scope*/
        Ar[33],
        yr ? get_slot_changes(
          kr,
          /*$$scope*/
          Ar[33],
          Ir,
          get_header_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[33]
        ),
        get_header_slot_context
      ) : xr && xr.p && (!yr || Ir[0] & /*stepTerm*/
      4) && xr.p(Ar, yr ? Ir : [-1, -1]), (!yr || Ir[0] & /*classesHeader*/
      524288 && ur !== (ur = "step-header " + /*classesHeader*/
      Ar[19])) && attr(cr, "class", ur), Er ? Er.p && (!yr || Ir[1] & /*$$scope*/
      4) && update_slot_base(
        Er,
        Sr,
        Ar,
        /*$$scope*/
        Ar[33],
        yr ? get_slot_changes(
          Sr,
          /*$$scope*/
          Ar[33],
          Ir,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ar[33]
        ),
        null
      ) : Cr && Cr.p && (!yr || Ir[0] & /*stepTerm*/
      4) && Cr.p(Ar, yr ? Ir : [-1, -1]), (!yr || Ir[0] & /*classesContent*/
      262144 && gr !== (gr = "step-content " + /*classesContent*/
      Ar[18])) && attr(dr, "class", gr), /*$state*/
      Ar[21].total > 1 ? Tr ? (Tr.p(Ar, Ir), Ir[0] & /*$state*/
      2097152 && transition_in(Tr, 1)) : (Tr = create_if_block_1$8(Ar), Tr.c(), transition_in(Tr, 1), Tr.m(ar, null)) : Tr && (group_outros(), transition_out(Tr, 1, 1, () => {
        Tr = null;
      }), check_outros()), (!yr || Ir[0] & /*classesBase*/
      1048576 && vr !== (vr = "step " + /*classesBase*/
      Ar[20])) && attr(ar, "class", vr);
    },
    i(Ar) {
      yr || (transition_in(xr, Ar), transition_in(Cr, Ar), transition_in(Tr), yr = !0);
    },
    o(Ar) {
      transition_out(xr, Ar), transition_out(Cr, Ar), transition_out(Tr), yr = !1;
    },
    d(Ar) {
      Ar && detach(ar), xr && xr.d(Ar), Cr && Cr.d(Ar), Tr && Tr.d();
    }
  };
}
function fallback_block_1(lr) {
  let ar, cr, ur = (
    /*stepIndex*/
    lr[22] + 1 + ""
  ), fr;
  return {
    c() {
      ar = text$3(
        /*stepTerm*/
        lr[2]
      ), cr = space(), fr = text$3(ur);
    },
    m(dr, gr) {
      insert(dr, ar, gr), insert(dr, cr, gr), insert(dr, fr, gr);
    },
    p(dr, gr) {
      gr[0] & /*stepTerm*/
      4 && set_data(
        ar,
        /*stepTerm*/
        dr[2]
      );
    },
    d(dr) {
      dr && (detach(ar), detach(cr), detach(fr));
    }
  };
}
function fallback_block$1(lr) {
  let ar, cr, ur, fr = (
    /*stepIndex*/
    lr[22] + 1 + ""
  ), dr, gr;
  return {
    c() {
      ar = text$3("("), cr = text$3(
        /*stepTerm*/
        lr[2]
      ), ur = space(), dr = text$3(fr), gr = text$3(" Content)");
    },
    m(mr, vr) {
      insert(mr, ar, vr), insert(mr, cr, vr), insert(mr, ur, vr), insert(mr, dr, vr), insert(mr, gr, vr);
    },
    p(mr, vr) {
      vr[0] & /*stepTerm*/
      4 && set_data(
        cr,
        /*stepTerm*/
        mr[2]
      );
    },
    d(mr) {
      mr && (detach(ar), detach(cr), detach(ur), detach(dr), detach(gr));
    }
  };
}
function create_if_block_1$8(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  const yr = [create_if_block_4$3, create_else_block_1$5], kr = [];
  function _r(Cr, Tr) {
    return (
      /*stepIndex*/
      Cr[22] === 0 && /*$$slots*/
      Cr[26].navigation ? 0 : 1
    );
  }
  cr = _r(lr), ur = kr[cr] = yr[cr](lr);
  function xr(Cr, Tr) {
    return (
      /*stepIndex*/
      Cr[22] < /*$state*/
      Cr[21].total - 1 ? create_if_block_2$6 : create_else_block$8
    );
  }
  let Sr = xr(lr), Er = Sr(lr);
  return {
    c() {
      ar = element("div"), ur.c(), fr = space(), Er.c(), attr(ar, "class", dr = "step-navigation " + /*classesNavigation*/
      lr[17]);
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), kr[cr].m(ar, null), append(ar, fr), Er.m(ar, null), vr = !0;
    },
    p(Cr, Tr) {
      lr = Cr;
      let Ar = cr;
      cr = _r(lr), cr === Ar ? kr[cr].p(lr, Tr) : (group_outros(), transition_out(kr[Ar], 1, 1, () => {
        kr[Ar] = null;
      }), check_outros(), ur = kr[cr], ur ? ur.p(lr, Tr) : (ur = kr[cr] = yr[cr](lr), ur.c()), transition_in(ur, 1), ur.m(ar, fr)), Sr === (Sr = xr(lr)) && Er ? Er.p(lr, Tr) : (Er.d(1), Er = Sr(lr), Er && (Er.c(), Er.m(ar, null))), (!vr || Tr[0] & /*classesNavigation*/
      131072 && dr !== (dr = "step-navigation " + /*classesNavigation*/
      lr[17])) && attr(ar, "class", dr);
    },
    i(Cr) {
      vr || (transition_in(ur), Cr && add_render_callback(() => {
        vr && (mr && mr.end(1), gr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[13]
          ),
          params: (
            /*transitionInParams*/
            lr[14]
          ),
          enabled: (
            /*transitions*/
            lr[12]
          )
        }), gr.start());
      }), vr = !0);
    },
    o(Cr) {
      transition_out(ur), gr && gr.invalidate(), Cr && (mr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[15]
        ),
        params: (
          /*transitionOutParams*/
          lr[16]
        ),
        enabled: (
          /*transitions*/
          lr[12]
        )
      })), vr = !1;
    },
    d(Cr) {
      Cr && detach(ar), kr[cr].d(), Er.d(), Cr && mr && mr.end();
    }
  };
}
function create_else_block_1$5(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonBackType*/
        lr[4]
      ), attr(ar, "class", cr = "btn " + /*buttonBack*/
      lr[3]), ar.disabled = ur = /*$state*/
      lr[21].current === 0;
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.innerHTML = /*buttonBackLabel*/
      lr[5], fr || (dr = listen(
        ar,
        "click",
        /*onBack*/
        lr[24]
      ), fr = !0);
    },
    p(gr, mr) {
      mr[0] & /*buttonBackLabel*/
      32 && (ar.innerHTML = /*buttonBackLabel*/
      gr[5]), mr[0] & /*buttonBackType*/
      16 && attr(
        ar,
        "type",
        /*buttonBackType*/
        gr[4]
      ), mr[0] & /*buttonBack*/
      8 && cr !== (cr = "btn " + /*buttonBack*/
      gr[3]) && attr(ar, "class", cr), mr[0] & /*$state*/
      2097152 && ur !== (ur = /*$state*/
      gr[21].current === 0) && (ar.disabled = ur);
    },
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar), fr = !1, dr();
    }
  };
}
function create_if_block_4$3(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[34].navigation
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[33],
    get_navigation_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "step-navigation-slot");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr[1] & /*$$scope*/
      4) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[33],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[33],
          gr,
          get_navigation_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[33]
        ),
        get_navigation_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_else_block$8(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonCompleteType*/
        lr[10]
      ), attr(ar, "class", cr = "btn " + /*buttonComplete*/
      lr[9]), ar.disabled = /*locked*/
      lr[0];
    },
    m(dr, gr) {
      insert(dr, ar, gr), ar.innerHTML = /*buttonCompleteLabel*/
      lr[11], ur || (fr = listen(
        ar,
        "click",
        /*onComplete*/
        lr[25]
      ), ur = !0);
    },
    p(dr, gr) {
      gr[0] & /*buttonCompleteLabel*/
      2048 && (ar.innerHTML = /*buttonCompleteLabel*/
      dr[11]), gr[0] & /*buttonCompleteType*/
      1024 && attr(
        ar,
        "type",
        /*buttonCompleteType*/
        dr[10]
      ), gr[0] & /*buttonComplete*/
      512 && cr !== (cr = "btn " + /*buttonComplete*/
      dr[9]) && attr(ar, "class", cr), gr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      dr[0]);
    },
    d(dr) {
      dr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_2$6(lr) {
  let ar, cr, ur, fr, dr, gr, mr = (
    /*locked*/
    lr[0] && create_if_block_3$5()
  );
  return {
    c() {
      ar = element("button"), mr && mr.c(), cr = space(), ur = element("span"), attr(
        ar,
        "type",
        /*buttonNextType*/
        lr[7]
      ), attr(ar, "class", fr = "btn " + /*buttonNext*/
      lr[6]), ar.disabled = /*locked*/
      lr[0];
    },
    m(vr, yr) {
      insert(vr, ar, yr), mr && mr.m(ar, null), append(ar, cr), append(ar, ur), ur.innerHTML = /*buttonNextLabel*/
      lr[8], dr || (gr = listen(
        ar,
        "click",
        /*onNext*/
        lr[23]
      ), dr = !0);
    },
    p(vr, yr) {
      /*locked*/
      vr[0] ? mr || (mr = create_if_block_3$5(), mr.c(), mr.m(ar, cr)) : mr && (mr.d(1), mr = null), yr[0] & /*buttonNextLabel*/
      256 && (ur.innerHTML = /*buttonNextLabel*/
      vr[8]), yr[0] & /*buttonNextType*/
      128 && attr(
        ar,
        "type",
        /*buttonNextType*/
        vr[7]
      ), yr[0] & /*buttonNext*/
      64 && fr !== (fr = "btn " + /*buttonNext*/
      vr[6]) && attr(ar, "class", fr), yr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      vr[0]);
    },
    d(vr) {
      vr && detach(ar), mr && mr.d(), dr = !1, gr();
    }
  };
}
function create_if_block_3$5(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z"), attr(ar, "class", "w-3 aspect-square fill-current"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$L(lr) {
  let ar, cr, ur = (
    /*stepIndex*/
    lr[22] === /*$state*/
    lr[21].current && create_if_block$h(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*stepIndex*/
      fr[22] === /*$state*/
      fr[21].current ? ur ? (ur.p(fr, dr), dr[0] & /*$state*/
      2097152 && transition_in(ur, 1)) : (ur = create_if_block$h(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cBase$6 = "space-y-4", cHeader$1 = "text-2xl font-bold", cContent = "space-y-4", cNavigation = "flex";
function instance$q(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr = noop$1, yr = () => (vr(), vr = subscribe(Ar, (ki) => cr(21, mr = ki)), Ar);
  lr.$$.on_destroy.push(() => vr());
  let { $$slots: kr = {}, $$scope: _r } = ar;
  const xr = compute_slots(kr);
  let { locked: Sr = !1 } = ar, { regionHeader: Er = "" } = ar, { regionContent: Cr = "" } = ar, { regionNavigation: Tr = "" } = ar, { state: Ar = getContext("state") } = ar;
  yr();
  let { dispatchParent: Ir = getContext("dispatchParent") } = ar, { stepTerm: Mr = getContext("stepTerm") } = ar, { gap: Hr = getContext("gap") } = ar, { justify: Br = getContext("justify") } = ar, { buttonBack: zr = getContext("buttonBack") } = ar, { buttonBackType: Gr = getContext("buttonBackType") } = ar, { buttonBackLabel: Xr = getContext("buttonBackLabel") } = ar, { buttonNext: Jr = getContext("buttonNext") } = ar, { buttonNextType: li = getContext("buttonNextType") } = ar, { buttonNextLabel: Qr = getContext("buttonNextLabel") } = ar, { buttonComplete: ei = getContext("buttonComplete") } = ar, { buttonCompleteType: ui = getContext("buttonCompleteType") } = ar, { buttonCompleteLabel: Ai = getContext("buttonCompleteLabel") } = ar, { transitions: fi = getContext("transitions") } = ar, { transitionIn: gi = getContext("transitionIn") } = ar, { transitionInParams: Ci = getContext("transitionInParams") } = ar, { transitionOut: mi = getContext("transitionOut") } = ar, { transitionOutParams: vi = getContext("transitionOutParams") } = ar;
  const Ri = mr.total;
  set_store_value(Ar, mr.total++, mr);
  async function di() {
    await new Promise((ki) => setTimeout(ki)), !Sr && (set_store_value(Ar, mr.current++, mr), Ir("next", { step: Ri, state: mr }), Ir("step", { step: Ri, state: mr }));
  }
  function Ti() {
    set_store_value(Ar, mr.current--, mr), Ir("back", { step: Ri, state: mr }), Ir("step", { step: Ri, state: mr });
  }
  function qi() {
    Ir("complete", { step: Ri, state: mr });
  }
  return onDestroy(() => {
    set_store_value(Ar, mr.total--, mr);
  }), lr.$$set = (ki) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(ki))), "locked" in ki && cr(0, Sr = ki.locked), "regionHeader" in ki && cr(27, Er = ki.regionHeader), "regionContent" in ki && cr(28, Cr = ki.regionContent), "regionNavigation" in ki && cr(29, Tr = ki.regionNavigation), "state" in ki && yr(cr(1, Ar = ki.state)), "dispatchParent" in ki && cr(30, Ir = ki.dispatchParent), "stepTerm" in ki && cr(2, Mr = ki.stepTerm), "gap" in ki && cr(31, Hr = ki.gap), "justify" in ki && cr(32, Br = ki.justify), "buttonBack" in ki && cr(3, zr = ki.buttonBack), "buttonBackType" in ki && cr(4, Gr = ki.buttonBackType), "buttonBackLabel" in ki && cr(5, Xr = ki.buttonBackLabel), "buttonNext" in ki && cr(6, Jr = ki.buttonNext), "buttonNextType" in ki && cr(7, li = ki.buttonNextType), "buttonNextLabel" in ki && cr(8, Qr = ki.buttonNextLabel), "buttonComplete" in ki && cr(9, ei = ki.buttonComplete), "buttonCompleteType" in ki && cr(10, ui = ki.buttonCompleteType), "buttonCompleteLabel" in ki && cr(11, Ai = ki.buttonCompleteLabel), "transitions" in ki && cr(12, fi = ki.transitions), "transitionIn" in ki && cr(13, gi = ki.transitionIn), "transitionInParams" in ki && cr(14, Ci = ki.transitionInParams), "transitionOut" in ki && cr(15, mi = ki.transitionOut), "transitionOutParams" in ki && cr(16, vi = ki.transitionOutParams), "$$scope" in ki && cr(33, _r = ki.$$scope);
  }, lr.$$.update = () => {
    var ki;
    cr(20, ur = `${cBase$6} ${(ki = ar.class) != null ? ki : ""}`), lr.$$.dirty[0] & /*regionHeader*/
    134217728 && cr(19, fr = `${cHeader$1} ${Er}`), lr.$$.dirty[0] & /*regionContent*/
    268435456 && cr(18, dr = `${cContent} ${Cr}`), lr.$$.dirty[0] & /*regionNavigation*/
    536870912 | lr.$$.dirty[1] & /*justify, gap*/
    3 && cr(17, gr = `${cNavigation} ${Br} ${Hr} ${Tr}`);
  }, ar = exclude_internal_props(ar), [
    Sr,
    Ar,
    Mr,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    gr,
    dr,
    fr,
    ur,
    mr,
    Ri,
    di,
    Ti,
    qi,
    xr,
    Er,
    Cr,
    Tr,
    Ir,
    Hr,
    Br,
    _r,
    kr
  ];
}
let Step$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$q,
      create_fragment$L,
      safe_not_equal,
      {
        locked: 0,
        regionHeader: 27,
        regionContent: 28,
        regionNavigation: 29,
        state: 1,
        dispatchParent: 30,
        stepTerm: 2,
        gap: 31,
        justify: 32,
        buttonBack: 3,
        buttonBackType: 4,
        buttonBackLabel: 5,
        buttonNext: 6,
        buttonNextType: 7,
        buttonNextLabel: 8,
        buttonComplete: 9,
        buttonCompleteType: 10,
        buttonCompleteLabel: 11,
        transitions: 12,
        transitionIn: 13,
        transitionInParams: 14,
        transitionOut: 15,
        transitionOutParams: 16
      },
      null,
      [-1, -1]
    );
  }
  get locked() {
    return this.$$.ctx[0];
  }
  set locked(ar) {
    this.$$set({ locked: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[27];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[28];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get regionNavigation() {
    return this.$$.ctx[29];
  }
  set regionNavigation(ar) {
    this.$$set({ regionNavigation: ar }), flush();
  }
  get state() {
    return this.$$.ctx[1];
  }
  set state(ar) {
    this.$$set({ state: ar }), flush();
  }
  get dispatchParent() {
    return this.$$.ctx[30];
  }
  set dispatchParent(ar) {
    this.$$set({ dispatchParent: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[2];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[31];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[32];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[3];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[4];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[5];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[6];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[7];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[8];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[9];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[10];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[11];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[12];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[13];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[14];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[15];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[16];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
};
create_custom_element(Step$1, { locked: { type: "Boolean" }, regionHeader: {}, regionContent: {}, regionNavigation: {}, state: {}, dispatchParent: {}, stepTerm: {}, gap: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["header", "default", "navigation"], [], !0);
function tableA11y(lr) {
  const ar = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"], cr = (ur) => {
    if (ar.includes(ur.code))
      switch (ur.preventDefault(), ur.code) {
        case "ArrowUp":
          a11ySetActiveCell(lr, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(lr, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(lr, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(lr, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(lr, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(lr, "last");
          break;
      }
  };
  return lr.addEventListener("keydown", cr), {
    destroy() {
      lr.removeEventListener("keydown", cr);
    }
  };
}
function a11ySetActiveCell(lr, ar, cr) {
  const ur = document.activeElement;
  if (!ur || !ur.parentElement || !ur.parentElement.ariaRowIndex || !ur.ariaColIndex)
    return;
  const fr = parseInt(ur.parentElement.ariaRowIndex), dr = parseInt(ur.ariaColIndex), gr = lr.querySelector(`[aria-rowindex="${fr + cr}"]`);
  if (gr !== null) {
    const mr = gr.querySelector(`[aria-colindex="${dr + ar}"]`);
    mr !== null && mr.focus();
  }
}
function a11yGetTargetElem(lr) {
  const ar = document.activeElement;
  if (!ar || !ar.parentElement || !ar.parentElement.ariaRowIndex)
    return null;
  const cr = parseInt(ar.parentElement.ariaRowIndex);
  return lr.querySelector(`[aria-rowindex="${cr}"]`);
}
function a11yJumpToOuterColumn(lr, ar = "first") {
  const cr = a11yGetTargetElem(lr);
  if (cr === null)
    return;
  const ur = cr.children.length, fr = ar === "first" ? 1 : ur, dr = cr.querySelector(`[aria-colindex="${fr}"]`);
  dr !== null && dr.focus();
}
function get_each_context$5(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur;
}
function get_each_context_1$2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[22] = ar[cr], ur[24] = cr, ur;
}
function get_each_context_2$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur[26] = cr, ur;
}
function get_each_context_3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[27] = ar[cr], ur;
}
function create_each_block_3(lr) {
  let ar, cr = (
    /*heading*/
    lr[27] + ""
  );
  return {
    c() {
      ar = element("th"), attr(
        ar,
        "class",
        /*regionHeadCell*/
        lr[3]
      ), attr(ar, "role", "columnheader");
    },
    m(ur, fr) {
      insert(ur, ar, fr), ar.innerHTML = cr;
    },
    p(ur, fr) {
      fr & /*source*/
      1 && cr !== (cr = /*heading*/
      ur[27] + "") && (ar.innerHTML = cr), fr & /*regionHeadCell*/
      8 && attr(
        ar,
        "class",
        /*regionHeadCell*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_each_block_2$1(lr) {
  let ar, cr = (Number(
    /*cell*/
    lr[19]
  ) === 0 || /*cell*/
  lr[19] ? (
    /*cell*/
    lr[19]
  ) : "-") + "", ur;
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionCell*/
        lr[5]
      ), attr(ar, "role", "gridcell"), attr(
        ar,
        "aria-colindex",
        /*cellIndex*/
        lr[26] + 1
      ), attr(ar, "tabindex", ur = /*cellIndex*/
      lr[26] === 0 && /*interactive*/
      lr[1] ? 0 : -1);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr & /*source*/
      1 && cr !== (cr = (Number(
        /*cell*/
        fr[19]
      ) === 0 || /*cell*/
      fr[19] ? (
        /*cell*/
        fr[19]
      ) : "-") + "") && (ar.innerHTML = cr), dr & /*regionCell*/
      32 && attr(
        ar,
        "class",
        /*regionCell*/
        fr[5]
      ), dr & /*interactive*/
      2 && ur !== (ur = /*cellIndex*/
      fr[26] === 0 && /*interactive*/
      fr[1] ? 0 : -1) && attr(ar, "tabindex", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_each_block_1$2(lr) {
  let ar, cr, ur, fr, dr = ensure_array_like(
    /*row*/
    lr[22]
  ), gr = [];
  for (let yr = 0; yr < dr.length; yr += 1)
    gr[yr] = create_each_block_2$1(get_each_context_2$1(lr, dr, yr));
  function mr(...yr) {
    return (
      /*click_handler*/
      lr[15](
        /*rowIndex*/
        lr[24],
        ...yr
      )
    );
  }
  function vr(...yr) {
    return (
      /*keydown_handler*/
      lr[16](
        /*rowIndex*/
        lr[24],
        ...yr
      )
    );
  }
  return {
    c() {
      ar = element("tr");
      for (let yr = 0; yr < gr.length; yr += 1)
        gr[yr].c();
      cr = space(), attr(
        ar,
        "aria-rowindex",
        /*rowIndex*/
        lr[24] + 1
      );
    },
    m(yr, kr) {
      insert(yr, ar, kr);
      for (let _r = 0; _r < gr.length; _r += 1)
        gr[_r] && gr[_r].m(ar, null);
      append(ar, cr), ur || (fr = [
        listen(ar, "click", mr),
        listen(ar, "keydown", vr)
      ], ur = !0);
    },
    p(yr, kr) {
      if (lr = yr, kr & /*regionCell, interactive, Number, source*/
      35) {
        dr = ensure_array_like(
          /*row*/
          lr[22]
        );
        let _r;
        for (_r = 0; _r < dr.length; _r += 1) {
          const xr = get_each_context_2$1(lr, dr, _r);
          gr[_r] ? gr[_r].p(xr, kr) : (gr[_r] = create_each_block_2$1(xr), gr[_r].c(), gr[_r].m(ar, cr));
        }
        for (; _r < gr.length; _r += 1)
          gr[_r].d(1);
        gr.length = dr.length;
      }
    },
    d(yr) {
      yr && detach(ar), destroy_each(gr, yr), ur = !1, run_all(fr);
    }
  };
}
function create_if_block$g(lr) {
  let ar, cr, ur, fr = ensure_array_like(
    /*source*/
    lr[0].foot
  ), dr = [];
  for (let gr = 0; gr < fr.length; gr += 1)
    dr[gr] = create_each_block$5(get_each_context$5(lr, fr, gr));
  return {
    c() {
      ar = element("tfoot"), cr = element("tr");
      for (let gr = 0; gr < dr.length; gr += 1)
        dr[gr].c();
      attr(ar, "class", ur = "table-foot " + /*regionFoot*/
      lr[6]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, cr);
      for (let vr = 0; vr < dr.length; vr += 1)
        dr[vr] && dr[vr].m(cr, null);
    },
    p(gr, mr) {
      if (mr & /*regionFootCell, source*/
      129) {
        fr = ensure_array_like(
          /*source*/
          gr[0].foot
        );
        let vr;
        for (vr = 0; vr < fr.length; vr += 1) {
          const yr = get_each_context$5(gr, fr, vr);
          dr[vr] ? dr[vr].p(yr, mr) : (dr[vr] = create_each_block$5(yr), dr[vr].c(), dr[vr].m(cr, null));
        }
        for (; vr < dr.length; vr += 1)
          dr[vr].d(1);
        dr.length = fr.length;
      }
      mr & /*regionFoot*/
      64 && ur !== (ur = "table-foot " + /*regionFoot*/
      gr[6]) && attr(ar, "class", ur);
    },
    d(gr) {
      gr && detach(ar), destroy_each(dr, gr);
    }
  };
}
function create_each_block$5(lr) {
  let ar, cr = (
    /*cell*/
    lr[19] + ""
  );
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionFootCell*/
        lr[7]
      );
    },
    m(ur, fr) {
      insert(ur, ar, fr), ar.innerHTML = cr;
    },
    p(ur, fr) {
      fr & /*source*/
      1 && cr !== (cr = /*cell*/
      ur[19] + "") && (ar.innerHTML = cr), fr & /*regionFootCell*/
      128 && attr(
        ar,
        "class",
        /*regionFootCell*/
        ur[7]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$K(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er = ensure_array_like(
    /*source*/
    lr[0].head
  ), Cr = [];
  for (let Mr = 0; Mr < Er.length; Mr += 1)
    Cr[Mr] = create_each_block_3(get_each_context_3(lr, Er, Mr));
  let Tr = ensure_array_like(
    /*source*/
    lr[0].body
  ), Ar = [];
  for (let Mr = 0; Mr < Tr.length; Mr += 1)
    Ar[Mr] = create_each_block_1$2(get_each_context_1$2(lr, Tr, Mr));
  let Ir = (
    /*source*/
    lr[0].foot && create_if_block$g(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("table"), ur = element("thead"), fr = element("tr");
      for (let Mr = 0; Mr < Cr.length; Mr += 1)
        Cr[Mr].c();
      gr = space(), mr = element("tbody");
      for (let Mr = 0; Mr < Ar.length; Mr += 1)
        Ar[Mr].c();
      yr = space(), Ir && Ir.c(), attr(ur, "class", dr = "table-head " + /*regionHead*/
      lr[2]), attr(mr, "class", vr = "table-body " + /*regionBody*/
      lr[4]), attr(
        cr,
        "class",
        /*classesTable*/
        lr[8]
      ), attr(cr, "role", kr = /*interactive*/
      lr[1] ? "grid" : "table"), toggle_class(
        cr,
        "table-interactive",
        /*interactive*/
        lr[1]
      ), attr(ar, "class", _r = "table-container " + /*classesBase*/
      lr[9]);
    },
    m(Mr, Hr) {
      insert(Mr, ar, Hr), append(ar, cr), append(cr, ur), append(ur, fr);
      for (let Br = 0; Br < Cr.length; Br += 1)
        Cr[Br] && Cr[Br].m(fr, null);
      append(cr, gr), append(cr, mr);
      for (let Br = 0; Br < Ar.length; Br += 1)
        Ar[Br] && Ar[Br].m(mr, null);
      append(cr, yr), Ir && Ir.m(cr, null), xr || (Sr = action_destroyer(tableA11y.call(null, cr)), xr = !0);
    },
    p(Mr, [Hr]) {
      if (Hr & /*regionHeadCell, source*/
      9) {
        Er = ensure_array_like(
          /*source*/
          Mr[0].head
        );
        let Br;
        for (Br = 0; Br < Er.length; Br += 1) {
          const zr = get_each_context_3(Mr, Er, Br);
          Cr[Br] ? Cr[Br].p(zr, Hr) : (Cr[Br] = create_each_block_3(zr), Cr[Br].c(), Cr[Br].m(fr, null));
        }
        for (; Br < Cr.length; Br += 1)
          Cr[Br].d(1);
        Cr.length = Er.length;
      }
      if (Hr & /*regionHead*/
      4 && dr !== (dr = "table-head " + /*regionHead*/
      Mr[2]) && attr(ur, "class", dr), Hr & /*onRowClick, onRowKeydown, source, regionCell, interactive, Number*/
      3107) {
        Tr = ensure_array_like(
          /*source*/
          Mr[0].body
        );
        let Br;
        for (Br = 0; Br < Tr.length; Br += 1) {
          const zr = get_each_context_1$2(Mr, Tr, Br);
          Ar[Br] ? Ar[Br].p(zr, Hr) : (Ar[Br] = create_each_block_1$2(zr), Ar[Br].c(), Ar[Br].m(mr, null));
        }
        for (; Br < Ar.length; Br += 1)
          Ar[Br].d(1);
        Ar.length = Tr.length;
      }
      Hr & /*regionBody*/
      16 && vr !== (vr = "table-body " + /*regionBody*/
      Mr[4]) && attr(mr, "class", vr), /*source*/
      Mr[0].foot ? Ir ? Ir.p(Mr, Hr) : (Ir = create_if_block$g(Mr), Ir.c(), Ir.m(cr, null)) : Ir && (Ir.d(1), Ir = null), Hr & /*classesTable*/
      256 && attr(
        cr,
        "class",
        /*classesTable*/
        Mr[8]
      ), Hr & /*interactive*/
      2 && kr !== (kr = /*interactive*/
      Mr[1] ? "grid" : "table") && attr(cr, "role", kr), Hr & /*classesTable, interactive*/
      258 && toggle_class(
        cr,
        "table-interactive",
        /*interactive*/
        Mr[1]
      ), Hr & /*classesBase*/
      512 && _r !== (_r = "table-container " + /*classesBase*/
      Mr[9]) && attr(ar, "class", _r);
    },
    i: noop$1,
    o: noop$1,
    d(Mr) {
      Mr && detach(ar), destroy_each(Cr, Mr), destroy_each(Ar, Mr), Ir && Ir.d(), xr = !1, Sr();
    }
  };
}
function instance$p(lr, ar, cr) {
  let ur, fr;
  const dr = createEventDispatcher();
  let { source: gr } = ar, { interactive: mr = !1 } = ar, { element: vr = "table" } = ar, { text: yr = "" } = ar, { color: kr = "" } = ar, { regionHead: _r = "" } = ar, { regionHeadCell: xr = "" } = ar, { regionBody: Sr = "" } = ar, { regionCell: Er = "" } = ar, { regionFoot: Cr = "" } = ar, { regionFootCell: Tr = "" } = ar;
  function Ar(Br, zr) {
    if (!mr)
      return;
    Br.preventDefault(), Br.stopPropagation();
    const Gr = gr.meta ? gr.meta[zr] : gr.body[zr];
    dr("selected", Gr);
  }
  function Ir(Br, zr) {
    ["Enter", "Space"].includes(Br.code) && Ar(Br, zr);
  }
  const Mr = (Br, zr) => {
    Ar(zr, Br);
  }, Hr = (Br, zr) => {
    Ir(zr, Br);
  };
  return lr.$$set = (Br) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Br))), "source" in Br && cr(0, gr = Br.source), "interactive" in Br && cr(1, mr = Br.interactive), "element" in Br && cr(12, vr = Br.element), "text" in Br && cr(13, yr = Br.text), "color" in Br && cr(14, kr = Br.color), "regionHead" in Br && cr(2, _r = Br.regionHead), "regionHeadCell" in Br && cr(3, xr = Br.regionHeadCell), "regionBody" in Br && cr(4, Sr = Br.regionBody), "regionCell" in Br && cr(5, Er = Br.regionCell), "regionFoot" in Br && cr(6, Cr = Br.regionFoot), "regionFootCell" in Br && cr(7, Tr = Br.regionFootCell);
  }, lr.$$.update = () => {
    cr(9, ur = `${ar.class || ""}`), lr.$$.dirty & /*element, text, color*/
    28672 && cr(8, fr = `${vr} ${yr} ${kr}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    fr,
    ur,
    Ar,
    Ir,
    vr,
    yr,
    kr,
    Mr,
    Hr
  ];
}
let Table$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$p, create_fragment$K, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 12,
      text: 13,
      color: 14,
      regionHead: 2,
      regionHeadCell: 3,
      regionBody: 4,
      regionCell: 5,
      regionFoot: 6,
      regionFootCell: 7
    });
  }
  get source() {
    return this.$$.ctx[0];
  }
  set source(ar) {
    this.$$set({ source: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[1];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get element() {
    return this.$$.ctx[12];
  }
  set element(ar) {
    this.$$set({ element: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get regionHead() {
    return this.$$.ctx[2];
  }
  set regionHead(ar) {
    this.$$set({ regionHead: ar }), flush();
  }
  get regionHeadCell() {
    return this.$$.ctx[3];
  }
  set regionHeadCell(ar) {
    this.$$set({ regionHeadCell: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[4];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionCell() {
    return this.$$.ctx[5];
  }
  set regionCell(ar) {
    this.$$set({ regionCell: ar }), flush();
  }
  get regionFoot() {
    return this.$$.ctx[6];
  }
  set regionFoot(ar) {
    this.$$set({ regionFoot: ar }), flush();
  }
  get regionFootCell() {
    return this.$$.ctx[7];
  }
  set regionFootCell(ar) {
    this.$$set({ regionFootCell: ar }), flush();
  }
};
create_custom_element(Table$2, { source: {}, interactive: { type: "Boolean" }, element: {}, text: {}, color: {}, regionHead: {}, regionHeadCell: {}, regionBody: {}, regionCell: {}, regionFoot: {}, regionFootCell: {} }, [], [], !0);
const get_panel_slot_changes = (lr) => ({}), get_panel_slot_context = (lr) => ({});
function create_if_block$f(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[17].panel
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[16],
    get_panel_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "tab-panel " + /*classesPanel*/
      lr[2]), attr(ar, "role", "tabpanel"), attr(
        ar,
        "aria-labelledby",
        /*panel*/
        lr[1]
      ), attr(ar, "tabindex", "0");
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      65536) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[16],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[16],
          mr,
          get_panel_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[16]
        ),
        get_panel_slot_context
      ), (!ur || mr & /*classesPanel*/
      4 && cr !== (cr = "tab-panel " + /*classesPanel*/
      gr[2])) && attr(ar, "class", cr), (!ur || mr & /*panel*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*panel*/
        gr[1]
      );
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr);
    }
  };
}
function create_fragment$J(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  const yr = (
    /*#slots*/
    lr[17].default
  ), kr = create_slot(
    yr,
    lr,
    /*$$scope*/
    lr[16],
    null
  );
  let _r = (
    /*$$slots*/
    lr[5].panel && create_if_block$f(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), kr && kr.c(), fr = space(), _r && _r.c(), attr(cr, "class", ur = "tab-list " + /*classesList*/
      lr[3]), attr(cr, "role", "tablist"), attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(ar, "class", dr = "tab-group " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "tab-group");
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), append(ar, cr), kr && kr.m(cr, null), append(ar, fr), _r && _r.m(ar, null), gr = !0, mr || (vr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[19]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[20]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[21]
        )
      ], mr = !0);
    },
    p(xr, [Sr]) {
      kr && kr.p && (!gr || Sr & /*$$scope*/
      65536) && update_slot_base(
        kr,
        yr,
        xr,
        /*$$scope*/
        xr[16],
        gr ? get_slot_changes(
          yr,
          /*$$scope*/
          xr[16],
          Sr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          xr[16]
        ),
        null
      ), (!gr || Sr & /*classesList*/
      8 && ur !== (ur = "tab-list " + /*classesList*/
      xr[3])) && attr(cr, "class", ur), (!gr || Sr & /*labelledby*/
      1) && attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        xr[0]
      ), /*$$slots*/
      xr[5].panel ? _r ? (_r.p(xr, Sr), Sr & /*$$slots*/
      32 && transition_in(_r, 1)) : (_r = create_if_block$f(xr), _r.c(), transition_in(_r, 1), _r.m(ar, null)) : _r && (group_outros(), transition_out(_r, 1, 1, () => {
        _r = null;
      }), check_outros()), (!gr || Sr & /*classesBase*/
      16 && dr !== (dr = "tab-group " + /*classesBase*/
      xr[4])) && attr(ar, "class", dr);
    },
    i(xr) {
      gr || (transition_in(kr, xr), transition_in(_r), gr = !0);
    },
    o(xr) {
      transition_out(kr, xr), transition_out(_r), gr = !1;
    },
    d(xr) {
      xr && detach(ar), kr && kr.d(xr), _r && _r.d(), mr = !1, run_all(vr);
    }
  };
}
const cBase$5 = "space-y-4", cList$1 = "flex overflow-x-auto hide-scrollbar", cPanel = "";
function instance$o(lr, ar, cr) {
  let ur, fr, dr, { $$slots: gr = {}, $$scope: mr } = ar;
  const vr = compute_slots(gr);
  let { justify: yr = "justify-start" } = ar, { border: kr = "border-b border-surface-400-500-token" } = ar, { active: _r = "border-b-2 border-surface-900-50-token" } = ar, { hover: xr = "hover:variant-soft" } = ar, { flex: Sr = "flex-none" } = ar, { padding: Er = "px-4 py-2" } = ar, { rounded: Cr = "rounded-tl-container-token rounded-tr-container-token" } = ar, { spacing: Tr = "space-y-1" } = ar, { regionList: Ar = "" } = ar, { regionPanel: Ir = "" } = ar, { labelledby: Mr = "" } = ar, { panel: Hr = "" } = ar;
  setContext("active", _r), setContext("hover", xr), setContext("flex", Sr), setContext("padding", Er), setContext("rounded", Cr), setContext("spacing", Tr);
  function Br(Jr) {
    bubble.call(this, lr, Jr);
  }
  function zr(Jr) {
    bubble.call(this, lr, Jr);
  }
  function Gr(Jr) {
    bubble.call(this, lr, Jr);
  }
  function Xr(Jr) {
    bubble.call(this, lr, Jr);
  }
  return lr.$$set = (Jr) => {
    cr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Jr))), "justify" in Jr && cr(6, yr = Jr.justify), "border" in Jr && cr(7, kr = Jr.border), "active" in Jr && cr(8, _r = Jr.active), "hover" in Jr && cr(9, xr = Jr.hover), "flex" in Jr && cr(10, Sr = Jr.flex), "padding" in Jr && cr(11, Er = Jr.padding), "rounded" in Jr && cr(12, Cr = Jr.rounded), "spacing" in Jr && cr(13, Tr = Jr.spacing), "regionList" in Jr && cr(14, Ar = Jr.regionList), "regionPanel" in Jr && cr(15, Ir = Jr.regionPanel), "labelledby" in Jr && cr(0, Mr = Jr.labelledby), "panel" in Jr && cr(1, Hr = Jr.panel), "$$scope" in Jr && cr(16, mr = Jr.$$scope);
  }, lr.$$.update = () => {
    var Jr;
    cr(4, ur = `${cBase$5} ${(Jr = ar.class) != null ? Jr : ""}`), lr.$$.dirty & /*justify, border, regionList*/
    16576 && cr(3, fr = `${cList$1} ${yr} ${kr} ${Ar}`), lr.$$.dirty & /*regionPanel*/
    32768 && cr(2, dr = `${cPanel} ${Ir}`);
  }, ar = exclude_internal_props(ar), [
    Mr,
    Hr,
    dr,
    fr,
    ur,
    vr,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    mr,
    gr,
    Br,
    zr,
    Gr,
    Xr
  ];
}
class TabGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$o, create_fragment$J, safe_not_equal, {
      justify: 6,
      border: 7,
      active: 8,
      hover: 9,
      flex: 10,
      padding: 11,
      rounded: 12,
      spacing: 13,
      regionList: 14,
      regionPanel: 15,
      labelledby: 0,
      panel: 1
    });
  }
  get justify() {
    return this.$$.ctx[6];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get border() {
    return this.$$.ctx[7];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[10];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[14];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[15];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get panel() {
    return this.$$.ctx[1];
  }
  set panel(ar) {
    this.$$set({ panel: ar }), flush();
  }
}
create_custom_element(TabGroup, { justify: {}, border: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {}, regionList: {}, regionPanel: {}, labelledby: {}, panel: {} }, ["default", "panel"], [], !0);
const get_lead_slot_changes$2 = (lr) => ({}), get_lead_slot_context$2 = (lr) => ({});
function create_if_block$e(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[22].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[21],
    get_lead_slot_context$2
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tab-lead");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr[0] & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[21],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[21],
          gr,
          get_lead_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[21]
        ),
        get_lead_slot_context$2
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$I(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr = [
    { type: "radio" },
    { name: (
      /*name*/
      lr[1]
    ) },
    { __value: (
      /*value*/
      lr[2]
    ) },
    /*prunedRestProps*/
    lr[11](),
    { tabindex: "-1" }
  ], Ar = {};
  for (let Br = 0; Br < Tr.length; Br += 1)
    Ar = assign$1(Ar, Tr[Br]);
  let Ir = (
    /*$$slots*/
    lr[12].lead && create_if_block$e(lr)
  );
  const Mr = (
    /*#slots*/
    lr[22].default
  ), Hr = create_slot(
    Mr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return Sr = init_binding_group(
    /*$$binding_groups*/
    lr[30][0]
  ), {
    c() {
      ar = element("label"), cr = element("div"), ur = element("div"), fr = element("input"), dr = space(), gr = element("div"), Ir && Ir.c(), mr = space(), vr = element("div"), Hr && Hr.c(), set_attributes(fr, Ar), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", "tab-label"), attr(gr, "class", yr = "tab-interface " + /*classesInterface*/
      lr[8]), attr(cr, "class", kr = "tab " + /*classesTab*/
      lr[7]), attr(cr, "data-testid", "tab"), attr(cr, "role", "tab"), attr(
        cr,
        "aria-controls",
        /*controls*/
        lr[4]
      ), attr(
        cr,
        "aria-selected",
        /*selected*/
        lr[5]
      ), attr(cr, "tabindex", _r = /*selected*/
      lr[5] ? 0 : -1), attr(
        ar,
        "class",
        /*classesBase*/
        lr[9]
      ), attr(
        ar,
        "title",
        /*title*/
        lr[3]
      ), Sr.p(fr);
    },
    m(Br, zr) {
      insert(Br, ar, zr), append(ar, cr), append(cr, ur), append(ur, fr), fr.autofocus && fr.focus(), lr[28](fr), fr.checked = fr.__value === /*group*/
      lr[0], append(cr, dr), append(cr, gr), Ir && Ir.m(gr, null), append(gr, mr), append(gr, vr), Hr && Hr.m(vr, null), xr = !0, Er || (Cr = [
        listen(
          fr,
          "change",
          /*input_change_handler*/
          lr[29]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          lr[26]
        ),
        listen(
          fr,
          "change",
          /*change_handler*/
          lr[27]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[10]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[23]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[24]
        ),
        listen(
          cr,
          "keypress",
          /*keypress_handler*/
          lr[25]
        )
      ], Er = !0);
    },
    p(Br, zr) {
      set_attributes(fr, Ar = get_spread_update(Tr, [
        { type: "radio" },
        (!xr || zr[0] & /*name*/
        2) && { name: (
          /*name*/
          Br[1]
        ) },
        (!xr || zr[0] & /*value*/
        4) && { __value: (
          /*value*/
          Br[2]
        ) },
        /*prunedRestProps*/
        Br[11](),
        { tabindex: "-1" }
      ])), zr[0] & /*group*/
      1 && (fr.checked = fr.__value === /*group*/
      Br[0]), /*$$slots*/
      Br[12].lead ? Ir ? (Ir.p(Br, zr), zr[0] & /*$$slots*/
      4096 && transition_in(Ir, 1)) : (Ir = create_if_block$e(Br), Ir.c(), transition_in(Ir, 1), Ir.m(gr, mr)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Hr && Hr.p && (!xr || zr[0] & /*$$scope*/
      2097152) && update_slot_base(
        Hr,
        Mr,
        Br,
        /*$$scope*/
        Br[21],
        xr ? get_slot_changes(
          Mr,
          /*$$scope*/
          Br[21],
          zr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Br[21]
        ),
        null
      ), (!xr || zr[0] & /*classesInterface*/
      256 && yr !== (yr = "tab-interface " + /*classesInterface*/
      Br[8])) && attr(gr, "class", yr), (!xr || zr[0] & /*classesTab*/
      128 && kr !== (kr = "tab " + /*classesTab*/
      Br[7])) && attr(cr, "class", kr), (!xr || zr[0] & /*controls*/
      16) && attr(
        cr,
        "aria-controls",
        /*controls*/
        Br[4]
      ), (!xr || zr[0] & /*selected*/
      32) && attr(
        cr,
        "aria-selected",
        /*selected*/
        Br[5]
      ), (!xr || zr[0] & /*selected*/
      32 && _r !== (_r = /*selected*/
      Br[5] ? 0 : -1)) && attr(cr, "tabindex", _r), (!xr || zr[0] & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Br[9]
      ), (!xr || zr[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        Br[3]
      );
    },
    i(Br) {
      xr || (transition_in(Ir), transition_in(Hr, Br), xr = !0);
    },
    o(Br) {
      transition_out(Ir), transition_out(Hr, Br), xr = !1;
    },
    d(Br) {
      Br && detach(ar), lr[28](null), Ir && Ir.d(), Hr && Hr.d(Br), Sr.r(), Er = !1, run_all(Cr);
    }
  };
}
const cBase$4 = "text-center cursor-pointer transition-colors duration-100", cInterface$1 = "";
function instance$n(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "controls",
    "regionTab",
    "active",
    "hover",
    "flex",
    "padding",
    "rounded",
    "spacing"
  ];
  let yr = compute_rest_props(ar, vr), { $$slots: kr = {}, $$scope: _r } = ar;
  const xr = compute_slots(kr);
  let { group: Sr } = ar, { name: Er } = ar, { value: Cr } = ar, { title: Tr = "" } = ar, { controls: Ar = "" } = ar, { regionTab: Ir = "" } = ar, { active: Mr = getContext("active") } = ar, { hover: Hr = getContext("hover") } = ar, { flex: Br = getContext("flex") } = ar, { padding: zr = getContext("padding") } = ar, { rounded: Gr = getContext("rounded") } = ar, { spacing: Xr = getContext("spacing") } = ar, Jr;
  function li(Ri) {
    if (["Enter", "Space"].includes(Ri.code))
      Ri.preventDefault(), Jr.click();
    else if (Ri.code === "ArrowRight") {
      const di = Jr.closest(".tab-list");
      if (!di)
        return;
      const Ti = Array.from(di.querySelectorAll(".tab")), qi = Jr.closest(".tab");
      if (!qi)
        return;
      const ki = Ti.indexOf(qi), Ji = ki + 1 >= Ti.length ? 0 : ki + 1, Bi = Ti[Ji], Ni = Bi == null ? void 0 : Bi.querySelector("input");
      Bi && Ni && (Ni.click(), Bi.focus());
    } else if (Ri.code === "ArrowLeft") {
      const di = Jr.closest(".tab-list");
      if (!di)
        return;
      const Ti = Array.from(di.querySelectorAll(".tab")), qi = Jr.closest(".tab");
      if (!qi)
        return;
      const ki = Ti.indexOf(qi), Ji = ki - 1 < 0 ? Ti.length - 1 : ki - 1, Bi = Ti[Ji], Ni = Bi == null ? void 0 : Bi.querySelector("input");
      Bi && Ni && (Ni.click(), Bi.focus());
    }
  }
  function Qr() {
    return delete yr.class, yr;
  }
  const ei = [[]];
  function ui(Ri) {
    bubble.call(this, lr, Ri);
  }
  function Ai(Ri) {
    bubble.call(this, lr, Ri);
  }
  function fi(Ri) {
    bubble.call(this, lr, Ri);
  }
  function gi(Ri) {
    bubble.call(this, lr, Ri);
  }
  function Ci(Ri) {
    bubble.call(this, lr, Ri);
  }
  function mi(Ri) {
    binding_callbacks[Ri ? "unshift" : "push"](() => {
      Jr = Ri, cr(6, Jr);
    });
  }
  function vi() {
    Sr = this.__value, cr(0, Sr);
  }
  return lr.$$set = (Ri) => {
    cr(32, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ri))), cr(31, yr = compute_rest_props(ar, vr)), "group" in Ri && cr(0, Sr = Ri.group), "name" in Ri && cr(1, Er = Ri.name), "value" in Ri && cr(2, Cr = Ri.value), "title" in Ri && cr(3, Tr = Ri.title), "controls" in Ri && cr(4, Ar = Ri.controls), "regionTab" in Ri && cr(13, Ir = Ri.regionTab), "active" in Ri && cr(14, Mr = Ri.active), "hover" in Ri && cr(15, Hr = Ri.hover), "flex" in Ri && cr(16, Br = Ri.flex), "padding" in Ri && cr(17, zr = Ri.padding), "rounded" in Ri && cr(18, Gr = Ri.rounded), "spacing" in Ri && cr(19, Xr = Ri.spacing), "$$scope" in Ri && cr(21, _r = Ri.$$scope);
  }, lr.$$.update = () => {
    var Ri;
    lr.$$.dirty[0] & /*value, group*/
    5 && cr(5, ur = Cr === Sr), lr.$$.dirty[0] & /*selected, active, hover*/
    49184 && cr(20, fr = ur ? Mr : Hr), cr(9, dr = `${cBase$4} ${Br} ${zr} ${Gr} ${fr} ${(Ri = ar.class) != null ? Ri : ""}`), lr.$$.dirty[0] & /*spacing*/
    524288 && cr(8, gr = `${cInterface$1} ${Xr}`), lr.$$.dirty[0] & /*regionTab*/
    8192 && cr(7, mr = `${Ir}`);
  }, ar = exclude_internal_props(ar), [
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    ur,
    Jr,
    mr,
    gr,
    dr,
    li,
    Qr,
    xr,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    fr,
    _r,
    kr,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vi,
    ei
  ];
}
let Tab$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$n,
      create_fragment$I,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        controls: 4,
        regionTab: 13,
        active: 14,
        hover: 15,
        flex: 16,
        padding: 17,
        rounded: 18,
        spacing: 19
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[4];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get regionTab() {
    return this.$$.ctx[13];
  }
  set regionTab(ar) {
    this.$$set({ regionTab: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[16];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[18];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[19];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
};
create_custom_element(Tab$1, { group: {}, name: {}, value: {}, title: {}, controls: {}, regionTab: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$1 = (lr) => ({}), get_lead_slot_context$1 = (lr) => ({});
function create_if_block$d(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[15].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[14],
    get_lead_slot_context$1
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tab-lead");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr & /*$$scope*/
      16384) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[14],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[14],
          gr,
          get_lead_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[14]
        ),
        get_lead_slot_context$1
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$H(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r = (
    /*$$slots*/
    lr[5].lead && create_if_block$d(lr)
  );
  const xr = (
    /*#slots*/
    lr[15].default
  ), Sr = create_slot(
    xr,
    lr,
    /*$$scope*/
    lr[14],
    null
  );
  let Er = [
    {
      class: gr = "tab-anchor " + /*classesBase*/
      lr[2]
    },
    {
      href: mr = /*$$props*/
      lr[4].href
    },
    /*prunedRestProps*/
    lr[3](),
    { "aria-controls": (
      /*controls*/
      lr[0]
    ) },
    { "data-testid": "tab-anchor" }
  ], Cr = {};
  for (let Tr = 0; Tr < Er.length; Tr += 1)
    Cr = assign$1(Cr, Er[Tr]);
  return {
    c() {
      ar = element("a"), cr = element("div"), _r && _r.c(), ur = space(), fr = element("div"), Sr && Sr.c(), attr(fr, "class", "tab-label"), attr(cr, "class", dr = "tab-interface " + /*classesInterface*/
      lr[1]), set_attributes(ar, Cr);
    },
    m(Tr, Ar) {
      insert(Tr, ar, Ar), append(ar, cr), _r && _r.m(cr, null), append(cr, ur), append(cr, fr), Sr && Sr.m(fr, null), vr = !0, yr || (kr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          lr[16]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          lr[17]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          lr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[19]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[20]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          lr[21]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          lr[22]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          lr[23]
        )
      ], yr = !0);
    },
    p(Tr, [Ar]) {
      /*$$slots*/
      Tr[5].lead ? _r ? (_r.p(Tr, Ar), Ar & /*$$slots*/
      32 && transition_in(_r, 1)) : (_r = create_if_block$d(Tr), _r.c(), transition_in(_r, 1), _r.m(cr, ur)) : _r && (group_outros(), transition_out(_r, 1, 1, () => {
        _r = null;
      }), check_outros()), Sr && Sr.p && (!vr || Ar & /*$$scope*/
      16384) && update_slot_base(
        Sr,
        xr,
        Tr,
        /*$$scope*/
        Tr[14],
        vr ? get_slot_changes(
          xr,
          /*$$scope*/
          Tr[14],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[14]
        ),
        null
      ), (!vr || Ar & /*classesInterface*/
      2 && dr !== (dr = "tab-interface " + /*classesInterface*/
      Tr[1])) && attr(cr, "class", dr), set_attributes(ar, Cr = get_spread_update(Er, [
        (!vr || Ar & /*classesBase*/
        4 && gr !== (gr = "tab-anchor " + /*classesBase*/
        Tr[2])) && { class: gr },
        (!vr || Ar & /*$$props*/
        16 && mr !== (mr = /*$$props*/
        Tr[4].href)) && { href: mr },
        /*prunedRestProps*/
        Tr[3](),
        (!vr || Ar & /*controls*/
        1) && { "aria-controls": (
          /*controls*/
          Tr[0]
        ) },
        { "data-testid": "tab-anchor" }
      ]));
    },
    i(Tr) {
      vr || (transition_in(_r), transition_in(Sr, Tr), vr = !0);
    },
    o(Tr) {
      transition_out(_r), transition_out(Sr, Tr), vr = !1;
    },
    d(Tr) {
      Tr && detach(ar), _r && _r.d(), Sr && Sr.d(Tr), yr = !1, run_all(kr);
    }
  };
}
const cBase$3 = "text-center cursor-pointer transition-colors duration-100", cInterface = "";
function instance$m(lr, ar, cr) {
  let ur, fr, dr;
  const gr = ["selected", "controls", "active", "hover", "flex", "padding", "rounded", "spacing"];
  let mr = compute_rest_props(ar, gr), { $$slots: vr = {}, $$scope: yr } = ar;
  const kr = compute_slots(vr);
  let { selected: _r = !1 } = ar, { controls: xr = "" } = ar, { active: Sr = getContext("active") } = ar, { hover: Er = getContext("hover") } = ar, { flex: Cr = getContext("flex") } = ar, { padding: Tr = getContext("padding") } = ar, { rounded: Ar = getContext("rounded") } = ar, { spacing: Ir = getContext("spacing") } = ar;
  function Mr() {
    return delete mr.class, mr;
  }
  function Hr(ei) {
    bubble.call(this, lr, ei);
  }
  function Br(ei) {
    bubble.call(this, lr, ei);
  }
  function zr(ei) {
    bubble.call(this, lr, ei);
  }
  function Gr(ei) {
    bubble.call(this, lr, ei);
  }
  function Xr(ei) {
    bubble.call(this, lr, ei);
  }
  function Jr(ei) {
    bubble.call(this, lr, ei);
  }
  function li(ei) {
    bubble.call(this, lr, ei);
  }
  function Qr(ei) {
    bubble.call(this, lr, ei);
  }
  return lr.$$set = (ei) => {
    cr(4, ar = assign$1(assign$1({}, ar), exclude_internal_props(ei))), cr(24, mr = compute_rest_props(ar, gr)), "selected" in ei && cr(6, _r = ei.selected), "controls" in ei && cr(0, xr = ei.controls), "active" in ei && cr(7, Sr = ei.active), "hover" in ei && cr(8, Er = ei.hover), "flex" in ei && cr(9, Cr = ei.flex), "padding" in ei && cr(10, Tr = ei.padding), "rounded" in ei && cr(11, Ar = ei.rounded), "spacing" in ei && cr(12, Ir = ei.spacing), "$$scope" in ei && cr(14, yr = ei.$$scope);
  }, lr.$$.update = () => {
    var ei;
    lr.$$.dirty & /*selected, active, hover*/
    448 && cr(13, ur = _r ? Sr : Er), cr(2, fr = `${cBase$3} ${Cr} ${Tr} ${Ar} ${ur} ${(ei = ar.class) != null ? ei : ""}`), lr.$$.dirty & /*spacing*/
    4096 && cr(1, dr = `${cInterface} ${Ir}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    dr,
    fr,
    Mr,
    ar,
    kr,
    _r,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    ur,
    yr,
    vr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr
  ];
}
class TabAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$m, create_fragment$H, safe_not_equal, {
      selected: 6,
      controls: 0,
      active: 7,
      hover: 8,
      flex: 9,
      padding: 10,
      rounded: 11,
      spacing: 12
    });
  }
  get selected() {
    return this.$$.ctx[6];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[0];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get active() {
    return this.$$.ctx[7];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[8];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[9];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[10];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[11];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
}
create_custom_element(TabAnchor, { selected: { type: "Boolean" }, controls: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
function create_fragment$G(lr) {
  let ar, cr, ur;
  const fr = (
    /*#slots*/
    lr[22].default
  ), dr = create_slot(
    fr,
    lr,
    /*$$scope*/
    lr[21],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", cr = "tree " + /*classesBase*/
      lr[4]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        lr[0]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        lr[2]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[1]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), dr && dr.m(ar, null), lr[23](ar), ur = !0;
    },
    p(gr, [mr]) {
      dr && dr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        fr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          fr,
          /*$$scope*/
          gr[21],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      16 && cr !== (cr = "tree " + /*classesBase*/
      gr[4])) && attr(ar, "class", cr), (!ur || mr & /*multiple*/
      1) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        gr[0]
      ), (!ur || mr & /*labelledby*/
      4) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        gr[2]
      ), (!ur || mr & /*disabled*/
      2) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        gr[1]
      );
    },
    i(gr) {
      ur || (transition_in(dr, gr), ur = !0);
    },
    o(gr) {
      transition_out(dr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr), lr[23](null);
    }
  };
}
function instance$l(lr, ar, cr) {
  let ur, { $$slots: fr = {}, $$scope: dr } = ar, { selection: gr = !1 } = ar, { multiple: mr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: yr = "space-y-1" } = ar, { open: kr = !1 } = ar, { disabled: _r = !1 } = ar, { padding: xr = "py-4 px-4" } = ar, { indent: Sr = "ml-4" } = ar, { hover: Er = "hover:variant-soft" } = ar, { rounded: Cr = "rounded-container-token" } = ar, { caretOpen: Tr = "rotate-180" } = ar, { caretClosed: Ar = "" } = ar, { hyphenOpacity: Ir = "opacity-10" } = ar, { regionSummary: Mr = "" } = ar, { regionSymbol: Hr = "" } = ar, { regionChildren: Br = "" } = ar, { labelledby: zr = "" } = ar;
  function Gr() {
    Jr.querySelectorAll("details.tree-item").forEach((ei) => {
      if (!ei.open) {
        const ui = ei.querySelector("summary.tree-item-summary");
        ui && ui.click();
      }
    });
  }
  function Xr() {
    Jr.querySelectorAll("details.tree-item").forEach((ei) => {
      if (ei.open) {
        const ui = ei.querySelector("summary.tree-item-summary");
        ui && ui.click();
      }
    });
  }
  setContext("open", kr), setContext("selection", gr), setContext("multiple", mr), setContext("disabled", _r), setContext("padding", xr), setContext("indent", Sr), setContext("hover", Er), setContext("rounded", Cr), setContext("caretOpen", Tr), setContext("caretClosed", Ar), setContext("hyphenOpacity", Ir), setContext("regionSummary", Mr), setContext("regionSymbol", Hr), setContext("regionChildren", Br);
  let Jr;
  function li(Qr) {
    binding_callbacks[Qr ? "unshift" : "push"](() => {
      Jr = Qr, cr(3, Jr);
    });
  }
  return lr.$$set = (Qr) => {
    cr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(Qr))), "selection" in Qr && cr(5, gr = Qr.selection), "multiple" in Qr && cr(0, mr = Qr.multiple), "width" in Qr && cr(6, vr = Qr.width), "spacing" in Qr && cr(7, yr = Qr.spacing), "open" in Qr && cr(8, kr = Qr.open), "disabled" in Qr && cr(1, _r = Qr.disabled), "padding" in Qr && cr(9, xr = Qr.padding), "indent" in Qr && cr(10, Sr = Qr.indent), "hover" in Qr && cr(11, Er = Qr.hover), "rounded" in Qr && cr(12, Cr = Qr.rounded), "caretOpen" in Qr && cr(13, Tr = Qr.caretOpen), "caretClosed" in Qr && cr(14, Ar = Qr.caretClosed), "hyphenOpacity" in Qr && cr(15, Ir = Qr.hyphenOpacity), "regionSummary" in Qr && cr(16, Mr = Qr.regionSummary), "regionSymbol" in Qr && cr(17, Hr = Qr.regionSymbol), "regionChildren" in Qr && cr(18, Br = Qr.regionChildren), "labelledby" in Qr && cr(2, zr = Qr.labelledby), "$$scope" in Qr && cr(21, dr = Qr.$$scope);
  }, lr.$$.update = () => {
    var Qr;
    cr(4, ur = `${vr} ${yr} ${(Qr = ar.class) != null ? Qr : ""}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    _r,
    zr,
    Jr,
    ur,
    gr,
    vr,
    yr,
    kr,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    Gr,
    Xr,
    dr,
    fr,
    li
  ];
}
class TreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$l, create_fragment$G, safe_not_equal, {
      selection: 5,
      multiple: 0,
      width: 6,
      spacing: 7,
      open: 8,
      disabled: 1,
      padding: 9,
      indent: 10,
      hover: 11,
      rounded: 12,
      caretOpen: 13,
      caretClosed: 14,
      hyphenOpacity: 15,
      regionSummary: 16,
      regionSymbol: 17,
      regionChildren: 18,
      labelledby: 2,
      expandAll: 19,
      collapseAll: 20
    });
  }
  get selection() {
    return this.$$.ctx[5];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[0];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[7];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[8];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[9];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[10];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[11];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[13];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[14];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[15];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[16];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[17];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[18];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[2];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get expandAll() {
    return this.$$.ctx[19];
  }
  get collapseAll() {
    return this.$$.ctx[20];
  }
}
create_custom_element(TreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, ["default"], ["expandAll", "collapseAll"], !0);
const get_children_slot_changes = (lr) => ({}), get_children_slot_context = (lr) => ({}), get_lead_slot_changes = (lr) => ({}), get_lead_slot_context = (lr) => ({});
function create_else_block_1$4(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512"), attr(ar, "class", ur = "w-3 " + /*classesHyphen*/
      lr[15]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr);
    },
    p(fr, dr) {
      dr[0] & /*classesHyphen*/
      32768 && ur !== (ur = "w-3 " + /*classesHyphen*/
      fr[15]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_3$4(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_1$7(lr) {
  let ar;
  function cr(dr, gr) {
    return (
      /*multiple*/
      dr[7] ? create_if_block_2$5 : create_else_block$7
    );
  }
  let ur = cr(lr), fr = ur(lr);
  return {
    c() {
      fr.c(), ar = empty$1();
    },
    m(dr, gr) {
      fr.m(dr, gr), insert(dr, ar, gr);
    },
    p(dr, gr) {
      ur === (ur = cr(dr)) && fr ? fr.p(dr, gr) : (fr.d(1), fr = ur(dr), fr && (fr.c(), fr.m(ar.parentNode, ar)));
    },
    d(dr) {
      dr && detach(ar), fr.d(dr);
    }
  };
}
function create_else_block$7(lr) {
  let ar, cr = !1, ur, fr, dr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    lr[44][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "class", "radio tree-item-radio"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        lr[4]
      ), ar.__value = /*value*/
      lr[5], set_input_value(ar, ar.__value), ur.p(ar);
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.checked = ar.__value === /*group*/
      lr[0], fr || (dr = listen(
        ar,
        "change",
        /*input_change_handler_1*/
        lr[43]
      ), fr = !0);
    },
    p(gr, mr) {
      mr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        gr[4]
      ), mr[0] & /*value*/
      32 && (ar.__value = /*value*/
      gr[5], set_input_value(ar, ar.__value), cr = !0), (cr || mr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      gr[0]);
    },
    d(gr) {
      gr && detach(ar), ur.r(), fr = !1, dr();
    }
  };
}
function create_if_block_2$5(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "class", "checkbox tree-item-checkbox"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        lr[4]
      ), ar.__value = /*value*/
      lr[5], set_input_value(ar, ar.__value), /*checked*/
      (lr[1] === void 0 || /*indeterminate*/
      lr[3] === void 0) && add_render_callback(() => (
        /*input_change_handler*/
        lr[42].call(ar)
      ));
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.checked = /*checked*/
      lr[1], ar.indeterminate = /*indeterminate*/
      lr[3], cr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          lr[42]
        ),
        listen(
          ar,
          "change",
          /*onParentChange*/
          lr[11]
        )
      ], cr = !0);
    },
    p(fr, dr) {
      dr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        fr[4]
      ), dr[0] & /*value*/
      32 && (ar.__value = /*value*/
      fr[5], set_input_value(ar, ar.__value)), dr[0] & /*checked*/
      2 && (ar.checked = /*checked*/
      fr[1]), dr[0] & /*indeterminate*/
      8 && (ar.indeterminate = /*indeterminate*/
      fr[3]);
    },
    d(fr) {
      fr && detach(ar), cr = !1, run_all(ur);
    }
  };
}
function create_if_block$c(lr) {
  let ar, cr;
  const ur = (
    /*#slots*/
    lr[38].lead
  ), fr = create_slot(
    ur,
    lr,
    /*$$scope*/
    lr[37],
    get_lead_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", "tree-item-lead");
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), cr = !0;
    },
    p(dr, gr) {
      fr && fr.p && (!cr || gr[1] & /*$$scope*/
      64) && update_slot_base(
        fr,
        ur,
        dr,
        /*$$scope*/
        dr[37],
        cr ? get_slot_changes(
          ur,
          /*$$scope*/
          dr[37],
          gr,
          get_lead_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[37]
        ),
        get_lead_slot_context
      );
    },
    i(dr) {
      cr || (transition_in(fr, dr), cr = !0);
    },
    o(dr) {
      transition_out(fr, dr), cr = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d(dr);
    }
  };
}
function create_fragment$F(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir;
  function Mr(ei, ui) {
    return (
      /*$$slots*/
      ei[21].children && !/*hideChildren*/
      ei[10] ? create_if_block_3$4 : create_else_block_1$4
    );
  }
  let Hr = Mr(lr), Br = Hr(lr), zr = (
    /*selection*/
    lr[6] && /*name*/
    lr[4] && /*group*/
    lr[0] !== void 0 && create_if_block_1$7(lr)
  ), Gr = (
    /*$$slots*/
    lr[21].lead && !/*hideLead*/
    lr[9] && create_if_block$c(lr)
  );
  const Xr = (
    /*#slots*/
    lr[38].default
  ), Jr = create_slot(
    Xr,
    lr,
    /*$$scope*/
    lr[37],
    null
  ), li = (
    /*#slots*/
    lr[38].children
  ), Qr = create_slot(
    li,
    lr,
    /*$$scope*/
    lr[37],
    get_children_slot_context
  );
  return {
    c() {
      ar = element("details"), cr = element("summary"), ur = element("div"), Br.c(), dr = space(), zr && zr.c(), gr = space(), Gr && Gr.c(), mr = space(), vr = element("div"), Jr && Jr.c(), xr = space(), Sr = element("div"), Qr && Qr.c(), attr(ur, "class", fr = "tree-summary-symbol " + /*classesSymbol*/
      lr[16]), attr(vr, "class", "tree-item-content"), attr(cr, "class", yr = "tree-item-summary " + /*classesSummary*/
      lr[17]), attr(cr, "role", "treeitem"), attr(cr, "aria-selected", kr = /*selection*/
      lr[6] ? (
        /*checked*/
        lr[1]
      ) : void 0), attr(cr, "aria-expanded", _r = /*$$slots*/
      lr[21].children ? (
        /*open*/
        lr[2]
      ) : void 0), attr(Sr, "class", Er = "tree-item-children " + /*classesChildren*/
      lr[14]), attr(Sr, "role", "group"), attr(ar, "class", Cr = "tree-item " + /*classesBase*/
      lr[18]), attr(ar, "data-testid", "tree-item"), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[8]
      );
    },
    m(ei, ui) {
      insert(ei, ar, ui), append(ar, cr), append(cr, ur), Br.m(ur, null), append(cr, dr), zr && zr.m(cr, null), append(cr, gr), Gr && Gr.m(cr, null), append(cr, mr), append(cr, vr), Jr && Jr.m(vr, null), append(ar, xr), append(ar, Sr), Qr && Qr.m(Sr, null), lr[45](Sr), lr[46](ar), ar.open = /*open*/
      lr[2], Tr = !0, Ar || (Ir = [
        listen(
          cr,
          "click",
          /*onSummaryClick*/
          lr[19]
        ),
        listen(
          cr,
          "click",
          /*click_handler*/
          lr[39]
        ),
        listen(
          cr,
          "keydown",
          /*onKeyDown*/
          lr[20]
        ),
        listen(
          cr,
          "keydown",
          /*keydown_handler*/
          lr[40]
        ),
        listen(
          cr,
          "keyup",
          /*keyup_handler*/
          lr[41]
        ),
        listen(
          ar,
          "toggle",
          /*details_toggle_handler*/
          lr[47]
        )
      ], Ar = !0);
    },
    p(ei, ui) {
      Hr === (Hr = Mr(ei)) && Br ? Br.p(ei, ui) : (Br.d(1), Br = Hr(ei), Br && (Br.c(), Br.m(ur, null))), (!Tr || ui[0] & /*classesSymbol*/
      65536 && fr !== (fr = "tree-summary-symbol " + /*classesSymbol*/
      ei[16])) && attr(ur, "class", fr), /*selection*/
      ei[6] && /*name*/
      ei[4] && /*group*/
      ei[0] !== void 0 ? zr ? zr.p(ei, ui) : (zr = create_if_block_1$7(ei), zr.c(), zr.m(cr, gr)) : zr && (zr.d(1), zr = null), /*$$slots*/
      ei[21].lead && !/*hideLead*/
      ei[9] ? Gr ? (Gr.p(ei, ui), ui[0] & /*$$slots, hideLead*/
      2097664 && transition_in(Gr, 1)) : (Gr = create_if_block$c(ei), Gr.c(), transition_in(Gr, 1), Gr.m(cr, mr)) : Gr && (group_outros(), transition_out(Gr, 1, 1, () => {
        Gr = null;
      }), check_outros()), Jr && Jr.p && (!Tr || ui[1] & /*$$scope*/
      64) && update_slot_base(
        Jr,
        Xr,
        ei,
        /*$$scope*/
        ei[37],
        Tr ? get_slot_changes(
          Xr,
          /*$$scope*/
          ei[37],
          ui,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          ei[37]
        ),
        null
      ), (!Tr || ui[0] & /*classesSummary*/
      131072 && yr !== (yr = "tree-item-summary " + /*classesSummary*/
      ei[17])) && attr(cr, "class", yr), (!Tr || ui[0] & /*selection, checked*/
      66 && kr !== (kr = /*selection*/
      ei[6] ? (
        /*checked*/
        ei[1]
      ) : void 0)) && attr(cr, "aria-selected", kr), (!Tr || ui[0] & /*$$slots, open*/
      2097156 && _r !== (_r = /*$$slots*/
      ei[21].children ? (
        /*open*/
        ei[2]
      ) : void 0)) && attr(cr, "aria-expanded", _r), Qr && Qr.p && (!Tr || ui[1] & /*$$scope*/
      64) && update_slot_base(
        Qr,
        li,
        ei,
        /*$$scope*/
        ei[37],
        Tr ? get_slot_changes(
          li,
          /*$$scope*/
          ei[37],
          ui,
          get_children_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          ei[37]
        ),
        get_children_slot_context
      ), (!Tr || ui[0] & /*classesChildren*/
      16384 && Er !== (Er = "tree-item-children " + /*classesChildren*/
      ei[14])) && attr(Sr, "class", Er), (!Tr || ui[0] & /*classesBase*/
      262144 && Cr !== (Cr = "tree-item " + /*classesBase*/
      ei[18])) && attr(ar, "class", Cr), (!Tr || ui[0] & /*disabled*/
      256) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        ei[8]
      ), ui[0] & /*open*/
      4 && (ar.open = /*open*/
      ei[2]);
    },
    i(ei) {
      Tr || (transition_in(Gr), transition_in(Jr, ei), transition_in(Qr, ei), Tr = !0);
    },
    o(ei) {
      transition_out(Gr), transition_out(Jr, ei), transition_out(Qr, ei), Tr = !1;
    },
    d(ei) {
      ei && detach(ar), Br.d(), zr && zr.d(), Gr && Gr.d(), Jr && Jr.d(ei), Qr && Qr.d(ei), lr[45](null), lr[46](null), Ar = !1, run_all(Ir);
    }
  };
}
const cBase$2 = "", cSummary = "list-none [&::-webkit-details-marker]:hidden flex items-center cursor-pointer", cSymbol = "fill-current w-3 text-center transition-transform duration-[200ms]", cChildren = "", cDisabled = "opacity-50 !cursor-not-allowed";
function instance$k(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr, { $$slots: _r = {}, $$scope: xr } = ar;
  const Sr = compute_slots(_r);
  let { group: Er = void 0 } = ar, { name: Cr = void 0 } = ar, { value: Tr = void 0 } = ar, { checked: Ar = !1 } = ar, { children: Ir = [] } = ar, { spacing: Mr = "space-x-4" } = ar, { open: Hr = getContext("open") } = ar, { selection: Br = getContext("selection") } = ar, { multiple: zr = getContext("multiple") } = ar, { disabled: Gr = getContext("disabled") } = ar, { indeterminate: Xr = !1 } = ar, { padding: Jr = getContext("padding") } = ar, { indent: li = getContext("indent") } = ar, { hover: Qr = getContext("hover") } = ar, { rounded: ei = getContext("rounded") } = ar, { caretOpen: ui = getContext("caretOpen") } = ar, { caretClosed: Ai = getContext("caretClosed") } = ar, { hyphenOpacity: fi = getContext("hyphenOpacity") } = ar, { regionSummary: gi = getContext("regionSummary") } = ar, { regionSymbol: Ci = getContext("regionSymbol") } = ar, { regionChildren: mi = getContext("regionChildren") } = ar, { hideLead: vi = !1 } = ar, { hideChildren: Ri = !1 } = ar, di, Ti;
  function qi(Fi) {
    Gr && Fi.preventDefault();
  }
  function ki(Fi, na) {
    Array.isArray(Fi) && (cr(1, Ar = Fi.indexOf(Tr) >= 0), Ei("groupChange", { checked: Ar, indeterminate: na }), Ei("childChange"));
  }
  function Ji(Fi, na) {
    if (!Array.isArray(Er))
      return;
    const Gi = Er.indexOf(Tr);
    Fi ? Gi < 0 && (Er.push(Tr), cr(0, Er)) : Gi >= 0 && (Er.splice(Gi, 1), cr(0, Er)), na || bi();
  }
  function Bi(Fi) {
    cr(1, Ar = Fi === Tr), Ei("groupChange", { checked: Ar, indeterminate: !1 }), Fi && Ei("childChange");
  }
  function Ni(Fi) {
    Fi && Er !== Tr ? cr(0, Er = Tr) : !Fi && Er === Tr && cr(0, Er = "");
  }
  function Mi() {
    if (zr) {
      if (!Array.isArray(Er))
        return;
      const Fi = Ir.map((Ca) => Ca.value), na = Ir[0].group, Gi = Er.indexOf(Tr);
      Ir.some((Ca) => Ca.indeterminate) ? (cr(3, Xr = !0), Gi >= 0 && (Er.splice(Gi, 1), cr(0, Er))) : Fi.every((Ca) => Array.isArray(na) && na.includes(Ca)) ? (cr(3, Xr = !1), Gi < 0 && (Er.push(Tr), cr(0, Er))) : Fi.some((Ca) => Array.isArray(na) && na.includes(Ca)) ? (cr(3, Xr = !0), Gi >= 0 && (Er.splice(Gi, 1), cr(0, Er))) : (cr(3, Xr = !1), Gi >= 0 && (Er.splice(Gi, 1), cr(0, Er)));
    } else
      Er !== Tr && Ir.some((Fi) => Fi.checked) ? cr(0, Er = Tr) : Er === Tr && !Ir.some((Fi) => Fi.checked) && cr(0, Er = "");
    Ei("childChange");
  }
  function bi() {
    if (!zr || !Ir || Ir.length === 0 || !Array.isArray(Er))
      return;
    const Fi = Er.indexOf(Tr), na = (Ca) => {
      !Ca || !Array.isArray(Ca.group) || (Ca.indeterminate = !1, Ca.group.indexOf(Ca.value) < 0 && (Ca.group.push(Ca.value), Ca.group = Ca.group));
    }, Gi = (Ca) => {
      if (!Ca || !Array.isArray(Ca.group))
        return;
      Ca.indeterminate = !1;
      const $a = Ca.group.indexOf(Ca.value);
      $a >= 0 && (Ca.group.splice($a, 1), Ca.group = Ca.group);
    };
    Ir.forEach((Ca) => {
      Ca && (Fi >= 0 ? na(Ca) : Gi(Ca), Ca.onParentChange());
    });
  }
  const Ei = createEventDispatcher();
  function Si(Fi) {
    var $a, no, ga, pa, Sa, Na, Oa, Ja, za;
    function na() {
      let Ia = di;
      for (; Ia !== null; ) {
        if (Ia.classList.contains("tree"))
          return Ia;
        Ia = Ia.parentElement;
      }
    }
    let Gi, Ca = null;
    switch (Fi.code) {
      case "ArrowRight":
        if (!Hr)
          cr(2, Hr = !0);
        else if (Sr.children && !Ri) {
          const Ia = Ti.querySelector("details>summary");
          Ia && Ia.focus();
        }
        break;
      case "ArrowLeft":
        if (Hr)
          cr(2, Hr = !1);
        else {
          const Ia = ($a = di.parentElement) == null ? void 0 : $a.parentElement;
          Ia && Ia.tagName === "DETAILS" && ((no = Ia.querySelector("summary")) == null || no.focus());
        }
        break;
      case "Home":
        Fi.preventDefault(), Gi = na(), Gi && ((ga = Gi == null ? void 0 : Gi.querySelector("summary")) == null || ga.focus());
        break;
      case "End":
        if (Fi.preventDefault(), Gi = na(), Gi) {
          const Ia = Gi == null ? void 0 : Gi.querySelectorAll("details");
          if (!Ia)
            return;
          for (let Yi = Ia.length - 1; Yi >= 0; Yi--) {
            const La = Ia[Yi];
            if ((Sa = (pa = La.parentElement) == null ? void 0 : pa.classList) != null && Sa.contains("tree") || ((Oa = (Na = La.parentElement) == null ? void 0 : Na.parentElement) == null ? void 0 : Oa.getAttribute("open")) !== null) {
              Ca = La;
              break;
            } else if (((za = (Ja = La.parentElement) == null ? void 0 : Ja.parentElement) == null ? void 0 : za.tagName) !== "details") {
              Ca = La.parentElement.parentElement;
              break;
            }
          }
          if (Ca) {
            const Yi = Ca.querySelector("summary");
            Yi && Yi.focus();
          }
        }
        break;
    }
  }
  const Vi = [[]];
  function Di(Fi) {
    bubble.call(this, lr, Fi);
  }
  function sa(Fi) {
    bubble.call(this, lr, Fi);
  }
  function ra(Fi) {
    bubble.call(this, lr, Fi);
  }
  function fa() {
    Ar = this.checked, Xr = this.indeterminate, cr(1, Ar), cr(3, Xr);
  }
  function ba() {
    Er = this.__value, cr(0, Er);
  }
  function Ua(Fi) {
    binding_callbacks[Fi ? "unshift" : "push"](() => {
      Ti = Fi, cr(13, Ti);
    });
  }
  function Va(Fi) {
    binding_callbacks[Fi ? "unshift" : "push"](() => {
      di = Fi, cr(12, di);
    });
  }
  function Ma() {
    Hr = this.open, cr(2, Hr);
  }
  return lr.$$set = (Fi) => {
    cr(54, ar = assign$1(assign$1({}, ar), exclude_internal_props(Fi))), "group" in Fi && cr(0, Er = Fi.group), "name" in Fi && cr(4, Cr = Fi.name), "value" in Fi && cr(5, Tr = Fi.value), "checked" in Fi && cr(1, Ar = Fi.checked), "children" in Fi && cr(22, Ir = Fi.children), "spacing" in Fi && cr(23, Mr = Fi.spacing), "open" in Fi && cr(2, Hr = Fi.open), "selection" in Fi && cr(6, Br = Fi.selection), "multiple" in Fi && cr(7, zr = Fi.multiple), "disabled" in Fi && cr(8, Gr = Fi.disabled), "indeterminate" in Fi && cr(3, Xr = Fi.indeterminate), "padding" in Fi && cr(24, Jr = Fi.padding), "indent" in Fi && cr(25, li = Fi.indent), "hover" in Fi && cr(26, Qr = Fi.hover), "rounded" in Fi && cr(27, ei = Fi.rounded), "caretOpen" in Fi && cr(28, ui = Fi.caretOpen), "caretClosed" in Fi && cr(29, Ai = Fi.caretClosed), "hyphenOpacity" in Fi && cr(30, fi = Fi.hyphenOpacity), "regionSummary" in Fi && cr(31, gi = Fi.regionSummary), "regionSymbol" in Fi && cr(32, Ci = Fi.regionSymbol), "regionChildren" in Fi && cr(33, mi = Fi.regionChildren), "hideLead" in Fi && cr(9, vi = Fi.hideLead), "hideChildren" in Fi && cr(10, Ri = Fi.hideChildren), "$$scope" in Fi && cr(37, xr = Fi.$$scope);
  }, lr.$$.update = () => {
    var Fi;
    lr.$$.dirty[0] & /*multiple, group, indeterminate*/
    137 && zr && ki(Er, Xr), lr.$$.dirty[0] & /*multiple, checked, indeterminate*/
    138 && zr && Ji(Ar, Xr), lr.$$.dirty[0] & /*multiple, group*/
    129 && (zr || Bi(Er)), lr.$$.dirty[0] & /*multiple, checked*/
    130 && (zr || Ni(Ar)), lr.$$.dirty[0] & /*multiple, group, value, children*/
    4194465 && !zr && Er !== void 0 && Er !== Tr && Ir.forEach((na) => {
      na && (na.group = "");
    }), lr.$$.dirty[0] & /*open*/
    4 && Ei("toggle", { open: Hr }), lr.$$.dirty[0] & /*children*/
    4194304 && Ir.forEach((na) => {
      na && na.$on("childChange", Mi);
    }), lr.$$.dirty[0] & /*open, hideChildren, caretOpen, caretClosed*/
    805307396 && cr(34, ur = Hr && Sr.children && !Ri ? ui : Ai), lr.$$.dirty[0] & /*disabled*/
    256 && cr(36, fr = Gr ? cDisabled : ""), cr(18, dr = `${cBase$2} ${(Fi = ar.class) != null ? Fi : ""}`), lr.$$.dirty[0] & /*spacing, rounded, padding, hover*/
    226492416 | lr.$$.dirty[1] & /*classesDisabled, regionSummary*/
    33 && cr(17, gr = `${cSummary} ${fr} ${Mr} ${ei} ${Jr} ${Qr} ${gi}`), lr.$$.dirty[1] & /*classesCaretState*/
    8 && cr(35, vr = `${ur}`), lr.$$.dirty[1] & /*classesCaret, regionSymbol*/
    18 && cr(16, mr = `${cSymbol} ${vr} ${Ci}`), lr.$$.dirty[0] & /*hyphenOpacity*/
    1073741824 && cr(15, yr = `${fi}`), lr.$$.dirty[0] & /*indent*/
    33554432 | lr.$$.dirty[1] & /*regionChildren*/
    4 && cr(14, kr = `${cChildren} ${li} ${mi}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Ar,
    Hr,
    Xr,
    Cr,
    Tr,
    Br,
    zr,
    Gr,
    vi,
    Ri,
    bi,
    di,
    Ti,
    kr,
    yr,
    mr,
    gr,
    dr,
    qi,
    Si,
    Sr,
    Ir,
    Mr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    ur,
    vr,
    fr,
    xr,
    _r,
    Di,
    sa,
    ra,
    fa,
    ba,
    Vi,
    Ua,
    Va,
    Ma
  ];
}
class TreeViewItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$k,
      create_fragment$F,
      safe_not_equal,
      {
        group: 0,
        name: 4,
        value: 5,
        checked: 1,
        children: 22,
        spacing: 23,
        open: 2,
        selection: 6,
        multiple: 7,
        disabled: 8,
        indeterminate: 3,
        padding: 24,
        indent: 25,
        hover: 26,
        rounded: 27,
        caretOpen: 28,
        caretClosed: 29,
        hyphenOpacity: 30,
        regionSummary: 31,
        regionSymbol: 32,
        regionChildren: 33,
        hideLead: 9,
        hideChildren: 10,
        onParentChange: 11
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[4];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[5];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[1];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get children() {
    return this.$$.ctx[22];
  }
  set children(ar) {
    this.$$set({ children: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[23];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[2];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get selection() {
    return this.$$.ctx[6];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[7];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[8];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get indeterminate() {
    return this.$$.ctx[3];
  }
  set indeterminate(ar) {
    this.$$set({ indeterminate: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[24];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[25];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[26];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[27];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[28];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[29];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[30];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[31];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[32];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[33];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get hideLead() {
    return this.$$.ctx[9];
  }
  set hideLead(ar) {
    this.$$set({ hideLead: ar }), flush();
  }
  get hideChildren() {
    return this.$$.ctx[10];
  }
  set hideChildren(ar) {
    this.$$set({ hideChildren: ar }), flush();
  }
  get onParentChange() {
    return this.$$.ctx[11];
  }
}
create_custom_element(TreeViewItem, { group: {}, name: {}, value: {}, checked: { type: "Boolean" }, children: {}, spacing: {}, open: {}, selection: {}, multiple: {}, disabled: {}, indeterminate: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, hideLead: { type: "Boolean" }, hideChildren: { type: "Boolean" } }, ["lead", "default", "children"], ["onParentChange"], !0);
function get_each_context$4(lr, ar, cr) {
  const ur = lr.slice();
  return ur[31] = ar[cr], ur[32] = ar, ur[33] = cr, ur;
}
function create_if_block$b(lr) {
  let ar, cr, ur = ensure_array_like(
    /*nodes*/
    lr[0]
  ), fr = [];
  for (let gr = 0; gr < ur.length; gr += 1)
    fr[gr] = create_each_block$4(get_each_context$4(lr, ur, gr));
  const dr = (gr) => transition_out(fr[gr], 1, 1, () => {
    fr[gr] = null;
  });
  return {
    c() {
      for (let gr = 0; gr < fr.length; gr += 1)
        fr[gr].c();
      ar = empty$1();
    },
    m(gr, mr) {
      for (let vr = 0; vr < fr.length; vr += 1)
        fr[vr] && fr[vr].m(gr, mr);
      insert(gr, ar, mr), cr = !0;
    },
    p(gr, mr) {
      if (mr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, treeItems, children, group, name, toggleNode, checkNode, dispatch*/
      4095) {
        ur = ensure_array_like(
          /*nodes*/
          gr[0]
        );
        let vr;
        for (vr = 0; vr < ur.length; vr += 1) {
          const yr = get_each_context$4(gr, ur, vr);
          fr[vr] ? (fr[vr].p(yr, mr), transition_in(fr[vr], 1)) : (fr[vr] = create_each_block$4(yr), fr[vr].c(), transition_in(fr[vr], 1), fr[vr].m(ar.parentNode, ar));
        }
        for (group_outros(), vr = ur.length; vr < fr.length; vr += 1)
          dr(vr);
        check_outros();
      }
    },
    i(gr) {
      if (!cr) {
        for (let mr = 0; mr < ur.length; mr += 1)
          transition_in(fr[mr]);
        cr = !0;
      }
    },
    o(gr) {
      fr = fr.filter(Boolean);
      for (let mr = 0; mr < fr.length; mr += 1)
        transition_out(fr[mr]);
      cr = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_each(fr, gr);
    }
  };
}
function create_else_block_1$3(lr) {
  let ar, cr, ur;
  const fr = [
    /*node*/
    lr[31].contentProps
  ];
  var dr = (
    /*node*/
    lr[31].content
  );
  function gr(mr, vr) {
    let yr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      yr = get_spread_update(fr, [get_spread_object(
        /*node*/
        mr[31].contentProps
      )]);
    else
      for (let kr = 0; kr < fr.length; kr += 1)
        yr = assign$1(yr, fr[kr]);
    return { props: yr };
  }
  return dr && (ar = construct_svelte_component(dr, gr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(mr, vr) {
      ar && mount_component(ar, mr, vr), insert(mr, cr, vr), ur = !0;
    },
    p(mr, vr) {
      if (vr[0] & /*nodes*/
      1 && dr !== (dr = /*node*/
      mr[31].content)) {
        if (ar) {
          group_outros();
          const yr = ar;
          transition_out(yr.$$.fragment, 1, 0, () => {
            destroy_component(yr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, gr(mr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const yr = vr[0] & /*nodes*/
        1 ? get_spread_update(fr, [get_spread_object(
          /*node*/
          mr[31].contentProps
        )]) : {};
        ar.$set(yr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(cr), ar && destroy_component(ar, mr);
    }
  };
}
function create_if_block_2$4(lr) {
  let ar, cr = (
    /*node*/
    lr[31].content + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(fr, dr) {
      ar.m(cr, fr, dr), insert(fr, ur, dr);
    },
    p(fr, dr) {
      dr[0] & /*nodes*/
      1 && cr !== (cr = /*node*/
      fr[31].content + "") && ar.p(cr);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && (detach(ur), ar.d());
    }
  };
}
function create_default_slot$2(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_2$4, create_else_block_1$3], gr = [];
  function mr(vr, yr) {
    return typeof /*node*/
    vr[31].content == "string" ? 0 : 1;
  }
  return ar = mr(lr), cr = gr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = space();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), fr = !0;
    },
    p(vr, yr) {
      let kr = ar;
      ar = mr(vr), ar === kr ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), cr = gr[ar], cr ? cr.p(vr, yr) : (cr = gr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_else_block$6(lr) {
  let ar, cr, ur;
  const fr = [
    /*node*/
    lr[31].leadProps
  ];
  var dr = (
    /*node*/
    lr[31].lead
  );
  function gr(mr, vr) {
    let yr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      yr = get_spread_update(fr, [get_spread_object(
        /*node*/
        mr[31].leadProps
      )]);
    else
      for (let kr = 0; kr < fr.length; kr += 1)
        yr = assign$1(yr, fr[kr]);
    return { props: yr };
  }
  return dr && (ar = construct_svelte_component(dr, gr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(mr, vr) {
      ar && mount_component(ar, mr, vr), insert(mr, cr, vr), ur = !0;
    },
    p(mr, vr) {
      if (vr[0] & /*nodes*/
      1 && dr !== (dr = /*node*/
      mr[31].lead)) {
        if (ar) {
          group_outros();
          const yr = ar;
          transition_out(yr.$$.fragment, 1, 0, () => {
            destroy_component(yr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, gr(mr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const yr = vr[0] & /*nodes*/
        1 ? get_spread_update(fr, [get_spread_object(
          /*node*/
          mr[31].leadProps
        )]) : {};
        ar.$set(yr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(cr), ar && destroy_component(ar, mr);
    }
  };
}
function create_if_block_1$6(lr) {
  let ar, cr = (
    /*node*/
    lr[31].lead + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(fr, dr) {
      ar.m(cr, fr, dr), insert(fr, ur, dr);
    },
    p(fr, dr) {
      dr[0] & /*nodes*/
      1 && cr !== (cr = /*node*/
      fr[31].lead + "") && ar.p(cr);
    },
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && (detach(ur), ar.d());
    }
  };
}
function create_lead_slot(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_1$6, create_else_block$6], gr = [];
  function mr(vr, yr) {
    return typeof /*node*/
    vr[31].lead == "string" ? 0 : 1;
  }
  return ar = mr(lr), cr = gr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = space();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), fr = !0;
    },
    p(vr, yr) {
      let kr = ar;
      ar = mr(vr), ar === kr ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), cr = gr[ar], cr ? cr.p(vr, yr) : (cr = gr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_children_slot(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  function yr(Cr) {
    lr[12](Cr);
  }
  function kr(Cr) {
    lr[13](Cr);
  }
  function _r(Cr) {
    lr[14](Cr);
  }
  function xr(Cr) {
    lr[15](Cr);
  }
  function Sr(Cr) {
    lr[16](
      Cr,
      /*i*/
      lr[33]
    );
  }
  let Er = { nodes: (
    /*node*/
    lr[31].children
  ) };
  return (
    /*expandedNodes*/
    lr[1] !== void 0 && (Er.expandedNodes = /*expandedNodes*/
    lr[1]), /*disabledNodes*/
    lr[2] !== void 0 && (Er.disabledNodes = /*disabledNodes*/
    lr[2]), /*checkedNodes*/
    lr[3] !== void 0 && (Er.checkedNodes = /*checkedNodes*/
    lr[3]), /*indeterminateNodes*/
    lr[4] !== void 0 && (Er.indeterminateNodes = /*indeterminateNodes*/
    lr[4]), /*children*/
    lr[8][
      /*i*/
      lr[33]
    ] !== void 0 && (Er.treeItems = /*children*/
    lr[8][
      /*i*/
      lr[33]
    ]), ar = new RecursiveTreeViewItem_1({ props: Er }), binding_callbacks.push(() => bind(ar, "expandedNodes", yr)), binding_callbacks.push(() => bind(ar, "disabledNodes", kr)), binding_callbacks.push(() => bind(ar, "checkedNodes", _r)), binding_callbacks.push(() => bind(ar, "indeterminateNodes", xr)), binding_callbacks.push(() => bind(ar, "treeItems", Sr)), ar.$on(
      "click",
      /*click_handler*/
      lr[17]
    ), ar.$on(
      "toggle",
      /*toggle_handler*/
      lr[18]
    ), {
      c() {
        create_component(ar.$$.fragment), mr = space();
      },
      m(Cr, Tr) {
        mount_component(ar, Cr, Tr), insert(Cr, mr, Tr), vr = !0;
      },
      p(Cr, Tr) {
        lr = Cr;
        const Ar = {};
        Tr[0] & /*nodes*/
        1 && (Ar.nodes = /*node*/
        lr[31].children), !cr && Tr[0] & /*expandedNodes*/
        2 && (cr = !0, Ar.expandedNodes = /*expandedNodes*/
        lr[1], add_flush_callback(() => cr = !1)), !ur && Tr[0] & /*disabledNodes*/
        4 && (ur = !0, Ar.disabledNodes = /*disabledNodes*/
        lr[2], add_flush_callback(() => ur = !1)), !fr && Tr[0] & /*checkedNodes*/
        8 && (fr = !0, Ar.checkedNodes = /*checkedNodes*/
        lr[3], add_flush_callback(() => fr = !1)), !dr && Tr[0] & /*indeterminateNodes*/
        16 && (dr = !0, Ar.indeterminateNodes = /*indeterminateNodes*/
        lr[4], add_flush_callback(() => dr = !1)), !gr && Tr[0] & /*children*/
        256 && (gr = !0, Ar.treeItems = /*children*/
        lr[8][
          /*i*/
          lr[33]
        ], add_flush_callback(() => gr = !1)), ar.$set(Ar);
      },
      i(Cr) {
        vr || (transition_in(ar.$$.fragment, Cr), vr = !0);
      },
      o(Cr) {
        transition_out(ar.$$.fragment, Cr), vr = !1;
      },
      d(Cr) {
        Cr && detach(mr), destroy_component(ar, Cr);
      }
    }
  );
}
function create_each_block$4(lr) {
  let ar, cr = (
    /*i*/
    lr[33]
  ), ur, fr, dr, gr, mr;
  const vr = () => (
    /*treeviewitem_binding*/
    lr[19](ar, cr)
  ), yr = () => (
    /*treeviewitem_binding*/
    lr[19](null, cr)
  );
  function kr(Mr) {
    lr[20](
      Mr,
      /*i*/
      lr[33]
    );
  }
  function _r(Mr) {
    lr[21](Mr);
  }
  function xr(Mr) {
    lr[22](Mr);
  }
  function Sr(Mr) {
    lr[23](
      Mr,
      /*node*/
      lr[31]
    );
  }
  function Er(...Mr) {
    return (
      /*toggle_handler_1*/
      lr[24](
        /*node*/
        lr[31],
        ...Mr
      )
    );
  }
  function Cr(...Mr) {
    return (
      /*groupChange_handler*/
      lr[25](
        /*node*/
        lr[31],
        ...Mr
      )
    );
  }
  function Tr() {
    return (
      /*click_handler_1*/
      lr[26](
        /*node*/
        lr[31]
      )
    );
  }
  function Ar() {
    return (
      /*toggle_handler_2*/
      lr[27](
        /*node*/
        lr[31]
      )
    );
  }
  let Ir = {
    hideLead: !/*node*/
    lr[31].lead,
    hideChildren: !/*node*/
    lr[31].children || /*node*/
    lr[31].children.length === 0,
    open: (
      /*expandedNodes*/
      lr[1].includes(
        /*node*/
        lr[31].id
      )
    ),
    disabled: (
      /*disabledNodes*/
      lr[2].includes(
        /*node*/
        lr[31].id
      )
    ),
    checked: (
      /*checkedNodes*/
      lr[3].includes(
        /*node*/
        lr[31].id
      )
    ),
    indeterminate: (
      /*indeterminateNodes*/
      lr[4].includes(
        /*node*/
        lr[31].id
      )
    ),
    $$slots: {
      children: [create_children_slot],
      lead: [create_lead_slot],
      default: [create_default_slot$2]
    },
    $$scope: { ctx: lr }
  };
  return (
    /*children*/
    lr[8][
      /*i*/
      lr[33]
    ] !== void 0 && (Ir.children = /*children*/
    lr[8][
      /*i*/
      lr[33]
    ]), /*group*/
    lr[6] !== void 0 && (Ir.group = /*group*/
    lr[6]), /*name*/
    lr[7] !== void 0 && (Ir.name = /*name*/
    lr[7]), /*node*/
    lr[31].id !== void 0 && (Ir.value = /*node*/
    lr[31].id), ar = new TreeViewItem({ props: Ir }), vr(), binding_callbacks.push(() => bind(ar, "children", kr)), binding_callbacks.push(() => bind(ar, "group", _r)), binding_callbacks.push(() => bind(ar, "name", xr)), binding_callbacks.push(() => bind(ar, "value", Sr)), ar.$on("toggle", Er), ar.$on("groupChange", Cr), ar.$on("click", Tr), ar.$on("toggle", Ar), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(Mr, Hr) {
        mount_component(ar, Mr, Hr), mr = !0;
      },
      p(Mr, Hr) {
        lr = Mr, cr !== /*i*/
        lr[33] && (yr(), cr = /*i*/
        lr[33], vr());
        const Br = {};
        Hr[0] & /*nodes*/
        1 && (Br.hideLead = !/*node*/
        lr[31].lead), Hr[0] & /*nodes*/
        1 && (Br.hideChildren = !/*node*/
        lr[31].children || /*node*/
        lr[31].children.length === 0), Hr[0] & /*expandedNodes, nodes*/
        3 && (Br.open = /*expandedNodes*/
        lr[1].includes(
          /*node*/
          lr[31].id
        )), Hr[0] & /*disabledNodes, nodes*/
        5 && (Br.disabled = /*disabledNodes*/
        lr[2].includes(
          /*node*/
          lr[31].id
        )), Hr[0] & /*checkedNodes, nodes*/
        9 && (Br.checked = /*checkedNodes*/
        lr[3].includes(
          /*node*/
          lr[31].id
        )), Hr[0] & /*indeterminateNodes, nodes*/
        17 && (Br.indeterminate = /*indeterminateNodes*/
        lr[4].includes(
          /*node*/
          lr[31].id
        )), Hr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, children*/
        287 | Hr[1] & /*$$scope*/
        8 && (Br.$$scope = { dirty: Hr, ctx: lr }), !ur && Hr[0] & /*children*/
        256 && (ur = !0, Br.children = /*children*/
        lr[8][
          /*i*/
          lr[33]
        ], add_flush_callback(() => ur = !1)), !fr && Hr[0] & /*group*/
        64 && (fr = !0, Br.group = /*group*/
        lr[6], add_flush_callback(() => fr = !1)), !dr && Hr[0] & /*name*/
        128 && (dr = !0, Br.name = /*name*/
        lr[7], add_flush_callback(() => dr = !1)), !gr && Hr[0] & /*nodes*/
        1 && (gr = !0, Br.value = /*node*/
        lr[31].id, add_flush_callback(() => gr = !1)), ar.$set(Br);
      },
      i(Mr) {
        mr || (transition_in(ar.$$.fragment, Mr), mr = !0);
      },
      o(Mr) {
        transition_out(ar.$$.fragment, Mr), mr = !1;
      },
      d(Mr) {
        yr(), destroy_component(ar, Mr);
      }
    }
  );
}
function create_fragment$E(lr) {
  let ar, cr, ur = (
    /*nodes*/
    lr[0] && /*nodes*/
    lr[0].length > 0 && create_if_block$b(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*nodes*/
      fr[0] && /*nodes*/
      fr[0].length > 0 ? ur ? (ur.p(fr, dr), dr[0] & /*nodes*/
      1 && transition_in(ur, 1)) : (ur = create_if_block$b(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
function instance$j(lr, ar, cr) {
  let { nodes: ur = [] } = ar, { expandedNodes: fr = [] } = ar, { disabledNodes: dr = [] } = ar, { checkedNodes: gr = [] } = ar, { indeterminateNodes: mr = [] } = ar, vr = getContext("selection"), yr = getContext("multiple"), kr = getContext("relational"), _r = yr ? [] : "", xr = "";
  const Sr = createEventDispatcher();
  function Er(mi, vi) {
    var Ri;
    (Ri = mi.children) != null && Ri.length && (vi ? fr.includes(mi.id) || (fr.push(mi.id), cr(1, fr)) : fr.includes(mi.id) && (fr.splice(fr.indexOf(mi.id), 1), cr(1, fr)));
  }
  function Cr(mi, vi, Ri) {
    vi ? (gr.includes(mi.id) || (gr.push(mi.id), cr(3, gr)), !Ri && mr.includes(mi.id) && (mr.splice(mr.indexOf(mi.id), 1), cr(4, mr))) : (gr.includes(mi.id) && (gr.splice(gr.indexOf(mi.id), 1), cr(3, gr)), Ri && !mr.includes(mi.id) ? (mr.push(mi.id), cr(4, mr)) : !Ri && mr.includes(mi.id) && (mr.splice(mr.indexOf(mi.id), 1), cr(4, mr)));
  }
  vr && (yr ? (ur.forEach((mi) => {
    Array.isArray(_r) && gr.includes(mi.id) && !_r.includes(mi.id) && _r.push(mi.id);
  }), _r = _r) : ur.forEach((mi) => {
    gr.includes(mi.id) && _r !== mi.id && cr(6, _r = mi.id);
  })), onMount(async () => {
    vr && (cr(7, xr = String(Math.random())), kr || cr(5, Tr = []));
  });
  let { treeItems: Tr = [] } = ar, Ar = [];
  function Ir(mi) {
    fr = mi, cr(1, fr);
  }
  function Mr(mi) {
    dr = mi, cr(2, dr);
  }
  function Hr(mi) {
    gr = mi, cr(3, gr);
  }
  function Br(mi) {
    mr = mi, cr(4, mr);
  }
  function zr(mi, vi) {
    lr.$$.not_equal(Ar[vi], mi) && (Ar[vi] = mi, cr(8, Ar));
  }
  const Gr = (mi) => Sr("click", { id: mi.detail.id }), Xr = (mi) => Sr("toggle", { id: mi.detail.id });
  function Jr(mi, vi) {
    binding_callbacks[mi ? "unshift" : "push"](() => {
      Tr[vi] = mi, cr(5, Tr);
    });
  }
  function li(mi, vi) {
    lr.$$.not_equal(Ar[vi], mi) && (Ar[vi] = mi, cr(8, Ar));
  }
  function Qr(mi) {
    _r = mi, cr(6, _r);
  }
  function ei(mi) {
    xr = mi, cr(7, xr);
  }
  function ui(mi, vi) {
    lr.$$.not_equal(vi.id, mi) && (vi.id = mi, cr(0, ur));
  }
  const Ai = (mi, vi) => Er(mi, vi.detail.open), fi = (mi, vi) => Cr(mi, vi.detail.checked, vi.detail.indeterminate), gi = (mi) => Sr("click", { id: mi.id }), Ci = (mi) => {
    Sr("toggle", { id: mi.id });
  };
  return lr.$$set = (mi) => {
    "nodes" in mi && cr(0, ur = mi.nodes), "expandedNodes" in mi && cr(1, fr = mi.expandedNodes), "disabledNodes" in mi && cr(2, dr = mi.disabledNodes), "checkedNodes" in mi && cr(3, gr = mi.checkedNodes), "indeterminateNodes" in mi && cr(4, mr = mi.indeterminateNodes), "treeItems" in mi && cr(5, Tr = mi.treeItems);
  }, [
    ur,
    fr,
    dr,
    gr,
    mr,
    Tr,
    _r,
    xr,
    Ar,
    Sr,
    Er,
    Cr,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci
  ];
}
class RecursiveTreeViewItem_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$j,
      create_fragment$E,
      safe_not_equal,
      {
        nodes: 0,
        expandedNodes: 1,
        disabledNodes: 2,
        checkedNodes: 3,
        indeterminateNodes: 4,
        treeItems: 5
      },
      null,
      [-1, -1]
    );
  }
  get nodes() {
    return this.$$.ctx[0];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[1];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[2];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[3];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[4];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get treeItems() {
    return this.$$.ctx[5];
  }
  set treeItems(ar) {
    this.$$set({ treeItems: ar }), flush();
  }
}
create_custom_element(RecursiveTreeViewItem_1, { nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, treeItems: {} }, [], [], !0);
function create_if_block$a(lr) {
  let ar, cr, ur, fr, dr, gr;
  function mr(xr) {
    lr[26](xr);
  }
  function vr(xr) {
    lr[27](xr);
  }
  function yr(xr) {
    lr[28](xr);
  }
  function kr(xr) {
    lr[29](xr);
  }
  let _r = { nodes: (
    /*nodes*/
    lr[5]
  ) };
  return (
    /*expandedNodes*/
    lr[0] !== void 0 && (_r.expandedNodes = /*expandedNodes*/
    lr[0]), /*disabledNodes*/
    lr[1] !== void 0 && (_r.disabledNodes = /*disabledNodes*/
    lr[1]), /*checkedNodes*/
    lr[2] !== void 0 && (_r.checkedNodes = /*checkedNodes*/
    lr[2]), /*indeterminateNodes*/
    lr[3] !== void 0 && (_r.indeterminateNodes = /*indeterminateNodes*/
    lr[3]), ar = new RecursiveTreeViewItem_1({ props: _r }), binding_callbacks.push(() => bind(ar, "expandedNodes", mr)), binding_callbacks.push(() => bind(ar, "disabledNodes", vr)), binding_callbacks.push(() => bind(ar, "checkedNodes", yr)), binding_callbacks.push(() => bind(ar, "indeterminateNodes", kr)), ar.$on(
      "click",
      /*onClick*/
      lr[9]
    ), ar.$on(
      "toggle",
      /*onToggle*/
      lr[10]
    ), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(xr, Sr) {
        mount_component(ar, xr, Sr), gr = !0;
      },
      p(xr, Sr) {
        const Er = {};
        Sr[0] & /*nodes*/
        32 && (Er.nodes = /*nodes*/
        xr[5]), !cr && Sr[0] & /*expandedNodes*/
        1 && (cr = !0, Er.expandedNodes = /*expandedNodes*/
        xr[0], add_flush_callback(() => cr = !1)), !ur && Sr[0] & /*disabledNodes*/
        2 && (ur = !0, Er.disabledNodes = /*disabledNodes*/
        xr[1], add_flush_callback(() => ur = !1)), !fr && Sr[0] & /*checkedNodes*/
        4 && (fr = !0, Er.checkedNodes = /*checkedNodes*/
        xr[2], add_flush_callback(() => fr = !1)), !dr && Sr[0] & /*indeterminateNodes*/
        8 && (dr = !0, Er.indeterminateNodes = /*indeterminateNodes*/
        xr[3], add_flush_callback(() => dr = !1)), ar.$set(Er);
      },
      i(xr) {
        gr || (transition_in(ar.$$.fragment, xr), gr = !0);
      },
      o(xr) {
        transition_out(ar.$$.fragment, xr), gr = !1;
      },
      d(xr) {
        destroy_component(ar, xr);
      }
    }
  );
}
function create_fragment$D(lr) {
  let ar, cr, ur, fr = (
    /*nodes*/
    lr[5] && /*nodes*/
    lr[5].length > 0 && create_if_block$a(lr)
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", cr = "tree " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        lr[4]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        lr[7]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        lr[6]
      );
    },
    m(dr, gr) {
      insert(dr, ar, gr), fr && fr.m(ar, null), ur = !0;
    },
    p(dr, gr) {
      /*nodes*/
      dr[5] && /*nodes*/
      dr[5].length > 0 ? fr ? (fr.p(dr, gr), gr[0] & /*nodes*/
      32 && transition_in(fr, 1)) : (fr = create_if_block$a(dr), fr.c(), transition_in(fr, 1), fr.m(ar, null)) : fr && (group_outros(), transition_out(fr, 1, 1, () => {
        fr = null;
      }), check_outros()), (!ur || gr[0] & /*classesBase*/
      256 && cr !== (cr = "tree " + /*classesBase*/
      dr[8])) && attr(ar, "class", cr), (!ur || gr[0] & /*multiple*/
      16) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        dr[4]
      ), (!ur || gr[0] & /*labelledby*/
      128) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        dr[7]
      ), (!ur || gr[0] & /*disabled*/
      64) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        dr[6]
      );
    },
    i(dr) {
      ur || (transition_in(fr), ur = !0);
    },
    o(dr) {
      transition_out(fr), ur = !1;
    },
    d(dr) {
      dr && detach(ar), fr && fr.d();
    }
  };
}
function instance$i(lr, ar, cr) {
  let ur, { selection: fr = !1 } = ar, { multiple: dr = !1 } = ar, { relational: gr = !1 } = ar, { nodes: mr = [] } = ar, { expandedNodes: vr = [] } = ar, { disabledNodes: yr = [] } = ar, { checkedNodes: kr = [] } = ar, { indeterminateNodes: _r = [] } = ar, { width: xr = "w-full" } = ar, { spacing: Sr = "space-y-1" } = ar, { open: Er = !1 } = ar, { disabled: Cr = !1 } = ar, { padding: Tr = "py-4 px-4" } = ar, { indent: Ar = "ml-4" } = ar, { hover: Ir = "hover:variant-soft" } = ar, { rounded: Mr = "rounded-container-token" } = ar, { caretOpen: Hr = "rotate-180" } = ar, { caretClosed: Br = "" } = ar, { hyphenOpacity: zr = "opacity-10" } = ar, { regionSummary: Gr = "" } = ar, { regionSymbol: Xr = "" } = ar, { regionChildren: Jr = "" } = ar, { labelledby: li = "" } = ar;
  setContext("open", Er), setContext("selection", fr), setContext("multiple", dr), setContext("relational", gr), setContext("disabled", Cr), setContext("padding", Tr), setContext("indent", Ar), setContext("hover", Ir), setContext("rounded", Mr), setContext("caretOpen", Hr), setContext("caretClosed", Br), setContext("hyphenOpacity", zr), setContext("regionSummary", Gr), setContext("regionSymbol", Xr), setContext("regionChildren", Jr);
  const Qr = createEventDispatcher();
  function ei(mi) {
    Qr("click", { id: mi.detail.id });
  }
  function ui(mi) {
    Qr("toggle", { id: mi.detail.id });
  }
  function Ai(mi) {
    vr = mi, cr(0, vr);
  }
  function fi(mi) {
    yr = mi, cr(1, yr);
  }
  function gi(mi) {
    kr = mi, cr(2, kr);
  }
  function Ci(mi) {
    _r = mi, cr(3, _r);
  }
  return lr.$$set = (mi) => {
    cr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(mi))), "selection" in mi && cr(11, fr = mi.selection), "multiple" in mi && cr(4, dr = mi.multiple), "relational" in mi && cr(12, gr = mi.relational), "nodes" in mi && cr(5, mr = mi.nodes), "expandedNodes" in mi && cr(0, vr = mi.expandedNodes), "disabledNodes" in mi && cr(1, yr = mi.disabledNodes), "checkedNodes" in mi && cr(2, kr = mi.checkedNodes), "indeterminateNodes" in mi && cr(3, _r = mi.indeterminateNodes), "width" in mi && cr(13, xr = mi.width), "spacing" in mi && cr(14, Sr = mi.spacing), "open" in mi && cr(15, Er = mi.open), "disabled" in mi && cr(6, Cr = mi.disabled), "padding" in mi && cr(16, Tr = mi.padding), "indent" in mi && cr(17, Ar = mi.indent), "hover" in mi && cr(18, Ir = mi.hover), "rounded" in mi && cr(19, Mr = mi.rounded), "caretOpen" in mi && cr(20, Hr = mi.caretOpen), "caretClosed" in mi && cr(21, Br = mi.caretClosed), "hyphenOpacity" in mi && cr(22, zr = mi.hyphenOpacity), "regionSummary" in mi && cr(23, Gr = mi.regionSummary), "regionSymbol" in mi && cr(24, Xr = mi.regionSymbol), "regionChildren" in mi && cr(25, Jr = mi.regionChildren), "labelledby" in mi && cr(7, li = mi.labelledby);
  }, lr.$$.update = () => {
    var mi;
    cr(8, ur = `${xr} ${Sr} ${(mi = ar.class) != null ? mi : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    yr,
    kr,
    _r,
    dr,
    mr,
    Cr,
    li,
    ur,
    ei,
    ui,
    fr,
    gr,
    xr,
    Sr,
    Er,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    Ai,
    fi,
    gi,
    Ci
  ];
}
class RecursiveTreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$i,
      create_fragment$D,
      safe_not_equal,
      {
        selection: 11,
        multiple: 4,
        relational: 12,
        nodes: 5,
        expandedNodes: 0,
        disabledNodes: 1,
        checkedNodes: 2,
        indeterminateNodes: 3,
        width: 13,
        spacing: 14,
        open: 15,
        disabled: 6,
        padding: 16,
        indent: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        hyphenOpacity: 22,
        regionSummary: 23,
        regionSymbol: 24,
        regionChildren: 25,
        labelledby: 7
      },
      null,
      [-1, -1]
    );
  }
  get selection() {
    return this.$$.ctx[11];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[4];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get relational() {
    return this.$$.ctx[12];
  }
  set relational(ar) {
    this.$$set({ relational: ar }), flush();
  }
  get nodes() {
    return this.$$.ctx[5];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[0];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[1];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[2];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[3];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get width() {
    return this.$$.ctx[13];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[6];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[16];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[17];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[22];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[23];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[24];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[25];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[7];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RecursiveTreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, relational: { type: "Boolean" }, nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, [], [], !0);
function create_if_block$9(lr) {
  let ar, cr, ur, fr = languageFormatter(
    /*language*/
    lr[0]
  ) + "", dr, gr, mr, vr = (/*copyState*/
  lr[7] ? (
    /*buttonCopied*/
    lr[4]
  ) : (
    /*buttonLabel*/
    lr[3]
  )) + "", yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir;
  function Mr(zr, Gr) {
    return (
      /*formatted*/
      zr[6] ? create_if_block_1$5 : create_else_block$5
    );
  }
  let Hr = Mr(lr), Br = Hr(lr);
  return {
    c() {
      ar = element("div"), cr = element("header"), ur = element("span"), dr = text$3(fr), gr = space(), mr = element("button"), yr = text$3(vr), xr = space(), Sr = element("pre"), Er = element("code"), Br.c(), attr(ur, "class", "codeblock-language"), attr(mr, "class", kr = "codeblock-btn " + /*button*/
      lr[2]), attr(cr, "class", "codeblock-header " + cHeader), attr(Er, "class", Cr = "codeblock-code language-" + /*language*/
      lr[0] + " lineNumbers"), attr(Sr, "class", "codeblock-pre " + cPre), attr(ar, "class", Tr = "codeblock " + /*classesBase*/
      lr[8]), attr(ar, "data-testid", "codeblock");
    },
    m(zr, Gr) {
      insert(zr, ar, Gr), append(ar, cr), append(cr, ur), append(ur, dr), append(cr, gr), append(cr, mr), append(mr, yr), append(ar, xr), append(ar, Sr), append(Sr, Er), Br.m(Er, null), Ar || (Ir = [
        listen(
          mr,
          "click",
          /*onCopyClick*/
          lr[9]
        ),
        action_destroyer(_r = clipboard.call(
          null,
          mr,
          /*code*/
          lr[1]
        ))
      ], Ar = !0);
    },
    p(zr, Gr) {
      Gr & /*language*/
      1 && fr !== (fr = languageFormatter(
        /*language*/
        zr[0]
      ) + "") && set_data(dr, fr), Gr & /*copyState, buttonLabel, buttonCopied*/
      152 && vr !== (vr = (/*copyState*/
      zr[7] ? (
        /*buttonCopied*/
        zr[4]
      ) : (
        /*buttonLabel*/
        zr[3]
      )) + "") && set_data(yr, vr), Gr & /*button*/
      4 && kr !== (kr = "codeblock-btn " + /*button*/
      zr[2]) && attr(mr, "class", kr), _r && is_function(_r.update) && Gr & /*code*/
      2 && _r.update.call(
        null,
        /*code*/
        zr[1]
      ), Hr === (Hr = Mr(zr)) && Br ? Br.p(zr, Gr) : (Br.d(1), Br = Hr(zr), Br && (Br.c(), Br.m(Er, null))), Gr & /*language*/
      1 && Cr !== (Cr = "codeblock-code language-" + /*language*/
      zr[0] + " lineNumbers") && attr(Er, "class", Cr), Gr & /*classesBase*/
      256 && Tr !== (Tr = "codeblock " + /*classesBase*/
      zr[8]) && attr(ar, "class", Tr);
    },
    d(zr) {
      zr && detach(ar), Br.d(), Ar = !1, run_all(Ir);
    }
  };
}
function create_else_block$5(lr) {
  let ar = (
    /*code*/
    lr[1].trim() + ""
  ), cr;
  return {
    c() {
      cr = text$3(ar);
    },
    m(ur, fr) {
      insert(ur, cr, fr);
    },
    p(ur, fr) {
      fr & /*code*/
      2 && ar !== (ar = /*code*/
      ur[1].trim() + "") && set_data(cr, ar);
    },
    d(ur) {
      ur && detach(cr);
    }
  };
}
function create_if_block_1$5(lr) {
  let ar, cr;
  return {
    c() {
      ar = new HtmlTag(!1), cr = empty$1(), ar.a = cr;
    },
    m(ur, fr) {
      ar.m(
        /*displayCode*/
        lr[5],
        ur,
        fr
      ), insert(ur, cr, fr);
    },
    p(ur, fr) {
      fr & /*displayCode*/
      32 && ar.p(
        /*displayCode*/
        ur[5]
      );
    },
    d(ur) {
      ur && (detach(cr), ar.d());
    }
  };
}
function create_fragment$C(lr) {
  let ar, cr = (
    /*language*/
    lr[0] && /*code*/
    lr[1] && create_if_block$9(lr)
  );
  return {
    c() {
      cr && cr.c(), ar = empty$1();
    },
    m(ur, fr) {
      cr && cr.m(ur, fr), insert(ur, ar, fr);
    },
    p(ur, [fr]) {
      /*language*/
      ur[0] && /*code*/
      ur[1] ? cr ? cr.p(ur, fr) : (cr = create_if_block$9(ur), cr.c(), cr.m(ar.parentNode, ar)) : cr && (cr.d(1), cr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), cr && cr.d(ur);
    }
  };
}
const cBase$1 = "overflow-hidden shadow", cHeader = "text-xs text-white/50 uppercase flex justify-between items-center p-2 pl-4", cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lr) {
  return lr === "js" ? "javascript" : lr === "ts" ? "typescript" : lr === "shell" ? "terminal" : lr;
}
function instance$h(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, storeHighlightJs, (zr) => cr(17, fr = zr));
  const dr = createEventDispatcher();
  let { language: gr = "plaintext" } = ar, { code: mr = "" } = ar, { lineNumbers: vr = !1 } = ar, { background: yr = "bg-neutral-900/90" } = ar, { blur: kr = "" } = ar, { text: _r = "text-sm" } = ar, { color: xr = "text-white" } = ar, { rounded: Sr = "rounded-container-token" } = ar, { shadow: Er = "shadow" } = ar, { button: Cr = "btn btn-sm variant-soft !text-white" } = ar, { buttonLabel: Tr = "Copy" } = ar, { buttonCopied: Ar = "👍" } = ar, Ir = !1, Mr = mr, Hr = !1;
  function Br() {
    cr(7, Hr = !0), setTimeout(
      () => {
        cr(7, Hr = !1);
      },
      2e3
    ), dr("copy");
  }
  return lr.$$set = (zr) => {
    cr(19, ar = assign$1(assign$1({}, ar), exclude_internal_props(zr))), "language" in zr && cr(0, gr = zr.language), "code" in zr && cr(1, mr = zr.code), "lineNumbers" in zr && cr(10, vr = zr.lineNumbers), "background" in zr && cr(11, yr = zr.background), "blur" in zr && cr(12, kr = zr.blur), "text" in zr && cr(13, _r = zr.text), "color" in zr && cr(14, xr = zr.color), "rounded" in zr && cr(15, Sr = zr.rounded), "shadow" in zr && cr(16, Er = zr.shadow), "button" in zr && cr(2, Cr = zr.button), "buttonLabel" in zr && cr(3, Tr = zr.buttonLabel), "buttonCopied" in zr && cr(4, Ar = zr.buttonCopied);
  }, lr.$$.update = () => {
    var zr;
    lr.$$.dirty & /*$storeHighlightJs, code, language*/
    131075 && fr !== void 0 && (cr(5, Mr = fr.highlight(mr, { language: gr }).value.trim()), cr(6, Ir = !0)), lr.$$.dirty & /*lineNumbers, displayCode*/
    1056 && vr && (cr(5, Mr = Mr.replace(/^/gm, () => '<span class="line"></span>	')), cr(6, Ir = !0)), cr(8, ur = `${cBase$1} ${yr} ${kr} ${_r} ${xr} ${Sr} ${Er} ${(zr = ar.class) != null ? zr : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    Cr,
    Tr,
    Ar,
    Mr,
    Ir,
    Hr,
    ur,
    Br,
    vr,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    fr
  ];
}
let CodeBlock$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$h, create_fragment$C, safe_not_equal, {
      language: 0,
      code: 1,
      lineNumbers: 10,
      background: 11,
      blur: 12,
      text: 13,
      color: 14,
      rounded: 15,
      shadow: 16,
      button: 2,
      buttonLabel: 3,
      buttonCopied: 4
    });
  }
  get language() {
    return this.$$.ctx[0];
  }
  set language(ar) {
    this.$$set({ language: ar }), flush();
  }
  get code() {
    return this.$$.ctx[1];
  }
  set code(ar) {
    this.$$set({ code: ar }), flush();
  }
  get lineNumbers() {
    return this.$$.ctx[10];
  }
  set lineNumbers(ar) {
    this.$$set({ lineNumbers: ar }), flush();
  }
  get background() {
    return this.$$.ctx[11];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[12];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[16];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get button() {
    return this.$$.ctx[2];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
  get buttonLabel() {
    return this.$$.ctx[3];
  }
  set buttonLabel(ar) {
    this.$$set({ buttonLabel: ar }), flush();
  }
  get buttonCopied() {
    return this.$$.ctx[4];
  }
  set buttonCopied(ar) {
    this.$$set({ buttonCopied: ar }), flush();
  }
};
create_custom_element(CodeBlock$2, { language: {}, code: {}, lineNumbers: { type: "Boolean" }, background: {}, blur: {}, text: {}, color: {}, rounded: {}, shadow: {}, button: {}, buttonLabel: {}, buttonCopied: {} }, [], [], !0);
function create_if_block$8(lr) {
  let ar = (
    /*$modalStore*/
    lr[13]
  ), cr, ur, fr = create_key_block(lr);
  return {
    c() {
      fr.c(), cr = empty$1();
    },
    m(dr, gr) {
      fr.m(dr, gr), insert(dr, cr, gr), ur = !0;
    },
    p(dr, gr) {
      gr[0] & /*$modalStore*/
      8192 && safe_not_equal(ar, ar = /*$modalStore*/
      dr[13]) ? (group_outros(), transition_out(fr, 1, 1, noop$1), check_outros(), fr = create_key_block(dr), fr.c(), transition_in(fr, 1), fr.m(cr.parentNode, cr)) : fr.p(dr, gr);
    },
    i(dr) {
      ur || (transition_in(fr), ur = !0);
    },
    o(dr) {
      transition_out(fr), ur = !1;
    },
    d(dr) {
      dr && detach(cr), fr.d(dr);
    }
  };
}
function create_else_block$4(lr) {
  let ar, cr, ur, fr, dr, gr;
  const mr = [create_if_block_8$1, create_else_block_1$2], vr = [];
  function yr(kr, _r) {
    var xr;
    return (
      /*currentComponent*/
      (xr = kr[15]) != null && xr.slot ? 0 : 1
    );
  }
  return cr = yr(lr), ur = vr[cr] = mr[cr](lr), {
    c() {
      var kr, _r, xr;
      ar = element("div"), ur.c(), attr(ar, "class", fr = "modal contents " + /*$modalStore*/
      ((_r = (kr = lr[13][0]) == null ? void 0 : kr.modalClasses) != null ? _r : "")), attr(ar, "data-testid", "modal-component"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", dr = /*$modalStore*/
      (xr = lr[13][0].title) != null ? xr : "");
    },
    m(kr, _r) {
      insert(kr, ar, _r), vr[cr].m(ar, null), gr = !0;
    },
    p(kr, _r) {
      var Sr, Er, Cr;
      let xr = cr;
      cr = yr(kr), cr === xr ? vr[cr].p(kr, _r) : (group_outros(), transition_out(vr[xr], 1, 1, () => {
        vr[xr] = null;
      }), check_outros(), ur = vr[cr], ur ? ur.p(kr, _r) : (ur = vr[cr] = mr[cr](kr), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!gr || _r[0] & /*$modalStore*/
      8192 && fr !== (fr = "modal contents " + /*$modalStore*/
      ((Er = (Sr = kr[13][0]) == null ? void 0 : Sr.modalClasses) != null ? Er : ""))) && attr(ar, "class", fr), (!gr || _r[0] & /*$modalStore*/
      8192 && dr !== (dr = /*$modalStore*/
      (Cr = kr[13][0].title) != null ? Cr : "")) && attr(ar, "aria-label", dr);
    },
    i(kr) {
      gr || (transition_in(ur), gr = !0);
    },
    o(kr) {
      transition_out(ur), gr = !1;
    },
    d(kr) {
      kr && detach(ar), vr[cr].d();
    }
  };
}
function create_if_block_1$4(lr) {
  var Sr, Er, Cr, Tr;
  let ar, cr, ur, fr, dr, gr, mr = (
    /*$modalStore*/
    ((Sr = lr[13][0]) == null ? void 0 : Sr.title) && create_if_block_7$2(lr)
  ), vr = (
    /*$modalStore*/
    ((Er = lr[13][0]) == null ? void 0 : Er.body) && create_if_block_6$2(lr)
  ), yr = (
    /*$modalStore*/
    ((Cr = lr[13][0]) == null ? void 0 : Cr.image) && typeof /*$modalStore*/
    ((Tr = lr[13][0]) == null ? void 0 : Tr.image) == "string" && create_if_block_5$2(lr)
  );
  function kr(Ar, Ir) {
    if (
      /*$modalStore*/
      Ar[13][0].type === "alert"
    )
      return create_if_block_2$3;
    if (
      /*$modalStore*/
      Ar[13][0].type === "confirm"
    )
      return create_if_block_3$3;
    if (
      /*$modalStore*/
      Ar[13][0].type === "prompt"
    )
      return create_if_block_4$2;
  }
  let _r = kr(lr), xr = _r && _r(lr);
  return {
    c() {
      var Ar;
      ar = element("div"), mr && mr.c(), cr = space(), vr && vr.c(), ur = space(), yr && yr.c(), fr = space(), xr && xr.c(), attr(ar, "class", dr = "modal " + /*classesModal*/
      lr[17]), attr(ar, "data-testid", "modal"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", gr = /*$modalStore*/
      (Ar = lr[13][0].title) != null ? Ar : "");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), mr && mr.m(ar, null), append(ar, cr), vr && vr.m(ar, null), append(ar, ur), yr && yr.m(ar, null), append(ar, fr), xr && xr.m(ar, null);
    },
    p(Ar, Ir) {
      var Mr, Hr, Br, zr, Gr;
      /*$modalStore*/
      (Mr = Ar[13][0]) != null && Mr.title ? mr ? mr.p(Ar, Ir) : (mr = create_if_block_7$2(Ar), mr.c(), mr.m(ar, cr)) : mr && (mr.d(1), mr = null), /*$modalStore*/
      (Hr = Ar[13][0]) != null && Hr.body ? vr ? vr.p(Ar, Ir) : (vr = create_if_block_6$2(Ar), vr.c(), vr.m(ar, ur)) : vr && (vr.d(1), vr = null), /*$modalStore*/
      (Br = Ar[13][0]) != null && Br.image && typeof /*$modalStore*/
      ((zr = Ar[13][0]) == null ? void 0 : zr.image) == "string" ? yr ? yr.p(Ar, Ir) : (yr = create_if_block_5$2(Ar), yr.c(), yr.m(ar, fr)) : yr && (yr.d(1), yr = null), _r === (_r = kr(Ar)) && xr ? xr.p(Ar, Ir) : (xr && xr.d(1), xr = _r && _r(Ar), xr && (xr.c(), xr.m(ar, null))), Ir[0] & /*classesModal*/
      131072 && dr !== (dr = "modal " + /*classesModal*/
      Ar[17]) && attr(ar, "class", dr), Ir[0] & /*$modalStore*/
      8192 && gr !== (gr = /*$modalStore*/
      (Gr = Ar[13][0].title) != null ? Gr : "") && attr(ar, "aria-label", gr);
    },
    i: noop$1,
    o: noop$1,
    d(Ar) {
      Ar && detach(ar), mr && mr.d(), vr && vr.d(), yr && yr.d(), xr && xr.d();
    }
  };
}
function create_else_block_1$2(lr) {
  var mr, vr;
  let ar, cr, ur;
  const fr = [
    /*currentComponent*/
    (mr = lr[15]) == null ? void 0 : mr.props,
    { parent: (
      /*parent*/
      lr[16]
    ) }
  ];
  var dr = (
    /*currentComponent*/
    (vr = lr[15]) == null ? void 0 : vr.ref
  );
  function gr(yr, kr) {
    var xr;
    let _r = {};
    if (kr !== void 0 && kr[0] & /*currentComponent, parent*/
    98304)
      _r = get_spread_update(fr, [
        kr[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (xr = yr[15]) == null ? void 0 : xr.props
        ),
        kr[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          yr[16]
        ) }
      ]);
    else
      for (let Sr = 0; Sr < fr.length; Sr += 1)
        _r = assign$1(_r, fr[Sr]);
    return { props: _r };
  }
  return dr && (ar = construct_svelte_component(dr, gr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(yr, kr) {
      ar && mount_component(ar, yr, kr), insert(yr, cr, kr), ur = !0;
    },
    p(yr, kr) {
      var _r, xr;
      if (kr[0] & /*currentComponent*/
      32768 && dr !== (dr = /*currentComponent*/
      (_r = yr[15]) == null ? void 0 : _r.ref)) {
        if (ar) {
          group_outros();
          const Sr = ar;
          transition_out(Sr.$$.fragment, 1, 0, () => {
            destroy_component(Sr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, gr(yr, kr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const Sr = kr[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(fr, [
          kr[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (xr = yr[15]) == null ? void 0 : xr.props
          ),
          kr[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            yr[16]
          ) }
        ]) : {};
        ar.$set(Sr);
      }
    },
    i(yr) {
      ur || (ar && transition_in(ar.$$.fragment, yr), ur = !0);
    },
    o(yr) {
      ar && transition_out(ar.$$.fragment, yr), ur = !1;
    },
    d(yr) {
      yr && detach(cr), ar && destroy_component(ar, yr);
    }
  };
}
function create_if_block_8$1(lr) {
  var mr, vr;
  let ar, cr, ur;
  const fr = [
    /*currentComponent*/
    (mr = lr[15]) == null ? void 0 : mr.props,
    { parent: (
      /*parent*/
      lr[16]
    ) }
  ];
  var dr = (
    /*currentComponent*/
    (vr = lr[15]) == null ? void 0 : vr.ref
  );
  function gr(yr, kr) {
    var xr;
    let _r = {
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx: yr }
    };
    if (kr !== void 0 && kr[0] & /*currentComponent, parent*/
    98304)
      _r = get_spread_update(fr, [
        kr[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (xr = yr[15]) == null ? void 0 : xr.props
        ),
        kr[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          yr[16]
        ) }
      ]);
    else
      for (let Sr = 0; Sr < fr.length; Sr += 1)
        _r = assign$1(_r, fr[Sr]);
    return { props: _r };
  }
  return dr && (ar = construct_svelte_component(dr, gr(lr))), {
    c() {
      ar && create_component(ar.$$.fragment), cr = empty$1();
    },
    m(yr, kr) {
      ar && mount_component(ar, yr, kr), insert(yr, cr, kr), ur = !0;
    },
    p(yr, kr) {
      var _r, xr;
      if (kr[0] & /*currentComponent*/
      32768 && dr !== (dr = /*currentComponent*/
      (_r = yr[15]) == null ? void 0 : _r.ref)) {
        if (ar) {
          group_outros();
          const Sr = ar;
          transition_out(Sr.$$.fragment, 1, 0, () => {
            destroy_component(Sr, 1);
          }), check_outros();
        }
        dr ? (ar = construct_svelte_component(dr, gr(yr, kr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, cr.parentNode, cr)) : ar = null;
      } else if (dr) {
        const Sr = kr[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(fr, [
          kr[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (xr = yr[15]) == null ? void 0 : xr.props
          ),
          kr[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            yr[16]
          ) }
        ]) : {};
        kr[0] & /*currentComponent*/
        32768 | kr[1] & /*$$scope*/
        65536 && (Sr.$$scope = { dirty: kr, ctx: yr }), ar.$set(Sr);
      }
    },
    i(yr) {
      ur || (ar && transition_in(ar.$$.fragment, yr), ur = !0);
    },
    o(yr) {
      ar && transition_out(ar.$$.fragment, yr), ur = !1;
    },
    d(yr) {
      yr && detach(cr), ar && destroy_component(ar, yr);
    }
  };
}
function create_default_slot$1(lr) {
  var fr;
  let ar, cr = (
    /*currentComponent*/
    ((fr = lr[15]) == null ? void 0 : fr.slot) + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), ar.a = ur;
    },
    m(dr, gr) {
      ar.m(cr, dr, gr), insert(dr, ur, gr);
    },
    p(dr, gr) {
      var mr;
      gr[0] & /*currentComponent*/
      32768 && cr !== (cr = /*currentComponent*/
      ((mr = dr[15]) == null ? void 0 : mr.slot) + "") && ar.p(cr);
    },
    d(dr) {
      dr && (detach(ur), ar.d());
    }
  };
}
function create_if_block_7$2(lr) {
  let ar, cr = (
    /*$modalStore*/
    lr[13][0].title + ""
  ), ur;
  return {
    c() {
      ar = element("header"), attr(ar, "class", ur = "modal-header " + /*regionHeader*/
      lr[5]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr[0] & /*$modalStore*/
      8192 && cr !== (cr = /*$modalStore*/
      fr[13][0].title + "") && (ar.innerHTML = cr), dr[0] & /*regionHeader*/
      32 && ur !== (ur = "modal-header " + /*regionHeader*/
      fr[5]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_6$2(lr) {
  let ar, cr = (
    /*$modalStore*/
    lr[13][0].body + ""
  ), ur;
  return {
    c() {
      ar = element("article"), attr(ar, "class", ur = "modal-body " + /*regionBody*/
      lr[6]);
    },
    m(fr, dr) {
      insert(fr, ar, dr), ar.innerHTML = cr;
    },
    p(fr, dr) {
      dr[0] & /*$modalStore*/
      8192 && cr !== (cr = /*$modalStore*/
      fr[13][0].body + "") && (ar.innerHTML = cr), dr[0] & /*regionBody*/
      64 && ur !== (ur = "modal-body " + /*regionBody*/
      fr[6]) && attr(ar, "class", ur);
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block_5$2(lr) {
  let ar, cr;
  return {
    c() {
      var ur;
      ar = element("img"), attr(ar, "class", "modal-image " + cModalImage), src_url_equal(ar.src, cr = /*$modalStore*/
      (ur = lr[13][0]) == null ? void 0 : ur.image) || attr(ar, "src", cr), attr(ar, "alt", "Modal");
    },
    m(ur, fr) {
      insert(ur, ar, fr);
    },
    p(ur, fr) {
      var dr;
      fr[0] & /*$modalStore*/
      8192 && !src_url_equal(ar.src, cr = /*$modalStore*/
      (dr = ur[13][0]) == null ? void 0 : dr.image) && attr(ar, "src", cr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_4$2(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr = [
    { class: "modal-prompt-input input" },
    { name: "prompt" },
    { type: "text" },
    /*$modalStore*/
    lr[13][0].valueAttr
  ], Tr = {};
  for (let Ar = 0; Ar < Cr.length; Ar += 1)
    Tr = assign$1(Tr, Cr[Ar]);
  return {
    c() {
      ar = element("form"), cr = element("input"), ur = space(), fr = element("footer"), dr = element("button"), gr = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), vr = space(), yr = element("button"), kr = text$3(
        /*buttonTextSubmit*/
        lr[2]
      ), set_attributes(cr, Tr), attr(dr, "type", "button"), attr(dr, "class", mr = "btn " + /*buttonNeutral*/
      lr[3]), attr(yr, "type", "submit"), attr(yr, "class", _r = "btn " + /*buttonPositive*/
      lr[4]), attr(fr, "class", xr = "modal-footer " + /*regionFooter*/
      lr[7]), attr(ar, "class", "space-y-4");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), cr.autofocus && cr.focus(), set_input_value(
        cr,
        /*promptValue*/
        lr[14]
      ), append(ar, ur), append(ar, fr), append(fr, dr), append(dr, gr), append(fr, vr), append(fr, yr), append(yr, kr), Sr || (Er = [
        listen(
          cr,
          "input",
          /*input_input_handler*/
          lr[41]
        ),
        listen(
          dr,
          "click",
          /*onClose*/
          lr[23]
        ),
        listen(
          ar,
          "submit",
          /*onPromptSubmit*/
          lr[25]
        )
      ], Sr = !0);
    },
    p(Ar, Ir) {
      set_attributes(cr, Tr = get_spread_update(Cr, [
        { class: "modal-prompt-input input" },
        { name: "prompt" },
        { type: "text" },
        Ir[0] & /*$modalStore*/
        8192 && /*$modalStore*/
        Ar[13][0].valueAttr
      ])), Ir[0] & /*promptValue*/
      16384 && cr.value !== /*promptValue*/
      Ar[14] && set_input_value(
        cr,
        /*promptValue*/
        Ar[14]
      ), Ir[0] & /*buttonTextCancel*/
      1 && set_data(
        gr,
        /*buttonTextCancel*/
        Ar[0]
      ), Ir[0] & /*buttonNeutral*/
      8 && mr !== (mr = "btn " + /*buttonNeutral*/
      Ar[3]) && attr(dr, "class", mr), Ir[0] & /*buttonTextSubmit*/
      4 && set_data(
        kr,
        /*buttonTextSubmit*/
        Ar[2]
      ), Ir[0] & /*buttonPositive*/
      16 && _r !== (_r = "btn " + /*buttonPositive*/
      Ar[4]) && attr(yr, "class", _r), Ir[0] & /*regionFooter*/
      128 && xr !== (xr = "modal-footer " + /*regionFooter*/
      Ar[7]) && attr(fr, "class", xr);
    },
    d(Ar) {
      Ar && detach(ar), Sr = !1, run_all(Er);
    }
  };
}
function create_if_block_3$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r;
  return {
    c() {
      ar = element("footer"), cr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), dr = space(), gr = element("button"), mr = text$3(
        /*buttonTextConfirm*/
        lr[1]
      ), attr(cr, "type", "button"), attr(cr, "class", fr = "btn " + /*buttonNeutral*/
      lr[3]), attr(gr, "type", "button"), attr(gr, "class", vr = "btn " + /*buttonPositive*/
      lr[4]), attr(ar, "class", yr = "modal-footer " + /*regionFooter*/
      lr[7]);
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), append(ar, cr), append(cr, ur), append(ar, dr), append(ar, gr), append(gr, mr), kr || (_r = [
        listen(
          cr,
          "click",
          /*onClose*/
          lr[23]
        ),
        listen(
          gr,
          "click",
          /*onConfirm*/
          lr[24]
        )
      ], kr = !0);
    },
    p(xr, Sr) {
      Sr[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        xr[0]
      ), Sr[0] & /*buttonNeutral*/
      8 && fr !== (fr = "btn " + /*buttonNeutral*/
      xr[3]) && attr(cr, "class", fr), Sr[0] & /*buttonTextConfirm*/
      2 && set_data(
        mr,
        /*buttonTextConfirm*/
        xr[1]
      ), Sr[0] & /*buttonPositive*/
      16 && vr !== (vr = "btn " + /*buttonPositive*/
      xr[4]) && attr(gr, "class", vr), Sr[0] & /*regionFooter*/
      128 && yr !== (yr = "modal-footer " + /*regionFooter*/
      xr[7]) && attr(ar, "class", yr);
    },
    d(xr) {
      xr && detach(ar), kr = !1, run_all(_r);
    }
  };
}
function create_if_block_2$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr;
  return {
    c() {
      ar = element("footer"), cr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        lr[0]
      ), attr(cr, "type", "button"), attr(cr, "class", fr = "btn " + /*buttonNeutral*/
      lr[3]), attr(ar, "class", dr = "modal-footer " + /*regionFooter*/
      lr[7]);
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, cr), append(cr, ur), gr || (mr = listen(
        cr,
        "click",
        /*onClose*/
        lr[23]
      ), gr = !0);
    },
    p(vr, yr) {
      yr[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        vr[0]
      ), yr[0] & /*buttonNeutral*/
      8 && fr !== (fr = "btn " + /*buttonNeutral*/
      vr[3]) && attr(cr, "class", fr), yr[0] & /*regionFooter*/
      128 && dr !== (dr = "modal-footer " + /*regionFooter*/
      vr[7]) && attr(ar, "class", dr);
    },
    d(vr) {
      vr && detach(ar), gr = !1, mr();
    }
  };
}
function create_key_block(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr;
  const Sr = [create_if_block_1$4, create_else_block$4], Er = [];
  function Cr(Tr, Ar) {
    return (
      /*$modalStore*/
      Tr[13][0].type !== "component" ? 0 : 1
    );
  }
  return ur = Cr(lr), fr = Er[ur] = Sr[ur](lr), {
    c() {
      ar = element("div"), cr = element("div"), fr.c(), attr(cr, "class", dr = "modal-transition " + /*classesTransitionLayer*/
      lr[18]), attr(ar, "class", vr = "modal-backdrop " + /*classesBackdrop*/
      lr[19]), attr(ar, "data-testid", "modal-backdrop");
    },
    m(Tr, Ar) {
      insert(Tr, ar, Ar), append(ar, cr), Er[ur].m(cr, null), kr = !0, _r || (xr = [
        listen(
          ar,
          "mousedown",
          /*onBackdropInteractionBegin*/
          lr[21]
        ),
        listen(
          ar,
          "mouseup",
          /*onBackdropInteractionEnd*/
          lr[22]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          lr[39],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          lr[40],
          { passive: !0 }
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], _r = !0);
    },
    p(Tr, Ar) {
      lr = Tr;
      let Ir = ur;
      ur = Cr(lr), ur === Ir ? Er[ur].p(lr, Ar) : (group_outros(), transition_out(Er[Ir], 1, 1, () => {
        Er[Ir] = null;
      }), check_outros(), fr = Er[ur], fr ? fr.p(lr, Ar) : (fr = Er[ur] = Sr[ur](lr), fr.c()), transition_in(fr, 1), fr.m(cr, null)), (!kr || Ar[0] & /*classesTransitionLayer*/
      262144 && dr !== (dr = "modal-transition " + /*classesTransitionLayer*/
      lr[18])) && attr(cr, "class", dr), (!kr || Ar[0] & /*classesBackdrop*/
      524288 && vr !== (vr = "modal-backdrop " + /*classesBackdrop*/
      lr[19])) && attr(ar, "class", vr);
    },
    i(Tr) {
      kr || (transition_in(fr), add_render_callback(() => {
        kr && (mr && mr.end(1), gr = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            lr[9]
          ),
          params: (
            /*transitionInParams*/
            lr[10]
          ),
          enabled: (
            /*transitions*/
            lr[8]
          )
        }), gr.start());
      }), add_render_callback(() => {
        kr && (yr || (yr = create_bidirectional_transition(
          ar,
          dynamicTransition,
          {
            transition: fade,
            params: { duration: 150 },
            enabled: (
              /*transitions*/
              lr[8]
            )
          },
          !0
        )), yr.run(1));
      }), kr = !0);
    },
    o(Tr) {
      transition_out(fr), gr && gr.invalidate(), mr = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          lr[11]
        ),
        params: (
          /*transitionOutParams*/
          lr[12]
        ),
        enabled: (
          /*transitions*/
          lr[8]
        )
      }), yr || (yr = create_bidirectional_transition(
        ar,
        dynamicTransition,
        {
          transition: fade,
          params: { duration: 150 },
          enabled: (
            /*transitions*/
            lr[8]
          )
        },
        !1
      )), yr.run(0), kr = !1;
    },
    d(Tr) {
      Tr && detach(ar), Er[ur].d(), Tr && mr && mr.end(), Tr && yr && yr.end(), _r = !1, run_all(xr);
    }
  };
}
function create_fragment$B(lr) {
  let ar, cr, ur, fr, dr = (
    /*$modalStore*/
    lr[13].length > 0 && create_if_block$8(lr)
  );
  return {
    c() {
      dr && dr.c(), ar = empty$1();
    },
    m(gr, mr) {
      dr && dr.m(gr, mr), insert(gr, ar, mr), cr = !0, ur || (fr = listen(
        window,
        "keydown",
        /*onKeyDown*/
        lr[26]
      ), ur = !0);
    },
    p(gr, mr) {
      /*$modalStore*/
      gr[13].length > 0 ? dr ? (dr.p(gr, mr), mr[0] & /*$modalStore*/
      8192 && transition_in(dr, 1)) : (dr = create_if_block$8(gr), dr.c(), transition_in(dr, 1), dr.m(ar.parentNode, ar)) : dr && (group_outros(), transition_out(dr, 1, 1, () => {
        dr = null;
      }), check_outros());
    },
    i(gr) {
      cr || (transition_in(dr), cr = !0);
    },
    o(gr) {
      transition_out(dr), cr = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr), ur = !1, fr();
    }
  };
}
const cBackdrop$1 = "fixed top-0 left-0 right-0 bottom-0 overflow-y-auto", cTransitionLayer = "w-full h-fit min-h-full p-4 overflow-y-auto flex justify-center", cModal = "block overflow-y-auto", cModalImage = "w-full h-auto";
function instance$g(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr;
  component_subscribe(lr, prefersReducedMotionStore, (Di) => cr(43, yr = Di));
  const kr = createEventDispatcher();
  let { position: _r = "items-center" } = ar, { components: xr = {} } = ar, { background: Sr = "bg-surface-100-800-token" } = ar, { width: Er = "w-modal" } = ar, { height: Cr = "h-auto" } = ar, { padding: Tr = "p-4" } = ar, { spacing: Ar = "space-y-4" } = ar, { rounded: Ir = "rounded-container-token" } = ar, { shadow: Mr = "shadow-xl" } = ar, { zIndex: Hr = "z-[999]" } = ar, { buttonNeutral: Br = "variant-ghost-surface" } = ar, { buttonPositive: zr = "variant-filled" } = ar, { buttonTextCancel: Gr = "Cancel" } = ar, { buttonTextConfirm: Xr = "Confirm" } = ar, { buttonTextSubmit: Jr = "Submit" } = ar, { regionBackdrop: li = "bg-surface-backdrop-token" } = ar, { regionHeader: Qr = "text-2xl font-bold" } = ar, { regionBody: ei = "max-h-[200px] overflow-hidden" } = ar, { regionFooter: ui = "flex justify-end space-x-2" } = ar, { transitions: Ai = !yr } = ar, { transitionIn: fi = fly } = ar, { transitionInParams: gi = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, { transitionOut: Ci = fly } = ar, { transitionOutParams: mi = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, vi;
  const Ri = {
    buttonTextCancel: Gr,
    buttonTextConfirm: Xr,
    buttonTextSubmit: Jr
  };
  let di, Ti = !1;
  const qi = getModalStore();
  component_subscribe(lr, qi, (Di) => cr(13, vr = Di)), qi.subscribe((Di) => {
    Di.length && (Di[0].type === "prompt" && cr(14, vi = Di[0].value), cr(0, Gr = Di[0].buttonTextCancel || Ri.buttonTextCancel), cr(1, Xr = Di[0].buttonTextConfirm || Ri.buttonTextConfirm), cr(2, Jr = Di[0].buttonTextSubmit || Ri.buttonTextSubmit), cr(15, di = typeof Di[0].component == "string" ? xr[Di[0].component] : Di[0].component));
  });
  function ki(Di) {
    if (!(Di.target instanceof Element))
      return;
    const sa = Di.target.classList;
    (sa.contains("modal-backdrop") || sa.contains("modal-transition")) && (Ti = !0);
  }
  function Ji(Di) {
    if (!(Di.target instanceof Element))
      return;
    const sa = Di.target.classList;
    (sa.contains("modal-backdrop") || sa.contains("modal-transition")) && Ti && (vr[0].response && vr[0].response(void 0), qi.close(), kr("backdrop", Di)), Ti = !1;
  }
  function Bi() {
    vr[0].response && vr[0].response(!1), qi.close();
  }
  function Ni() {
    vr[0].response && vr[0].response(!0), qi.close();
  }
  function Mi(Di) {
    Di.preventDefault(), vr[0].response && vr[0].response(vi), qi.close();
  }
  function bi(Di) {
    vr.length && Di.code === "Escape" && Bi();
  }
  function Ei(Di) {
    bubble.call(this, lr, Di);
  }
  function Si(Di) {
    bubble.call(this, lr, Di);
  }
  function Vi() {
    vi = this.value, cr(14, vi);
  }
  return lr.$$set = (Di) => {
    cr(46, ar = assign$1(assign$1({}, ar), exclude_internal_props(Di))), "position" in Di && cr(27, _r = Di.position), "components" in Di && cr(28, xr = Di.components), "background" in Di && cr(29, Sr = Di.background), "width" in Di && cr(30, Er = Di.width), "height" in Di && cr(31, Cr = Di.height), "padding" in Di && cr(32, Tr = Di.padding), "spacing" in Di && cr(33, Ar = Di.spacing), "rounded" in Di && cr(34, Ir = Di.rounded), "shadow" in Di && cr(35, Mr = Di.shadow), "zIndex" in Di && cr(36, Hr = Di.zIndex), "buttonNeutral" in Di && cr(3, Br = Di.buttonNeutral), "buttonPositive" in Di && cr(4, zr = Di.buttonPositive), "buttonTextCancel" in Di && cr(0, Gr = Di.buttonTextCancel), "buttonTextConfirm" in Di && cr(1, Xr = Di.buttonTextConfirm), "buttonTextSubmit" in Di && cr(2, Jr = Di.buttonTextSubmit), "regionBackdrop" in Di && cr(37, li = Di.regionBackdrop), "regionHeader" in Di && cr(5, Qr = Di.regionHeader), "regionBody" in Di && cr(6, ei = Di.regionBody), "regionFooter" in Di && cr(7, ui = Di.regionFooter), "transitions" in Di && cr(8, Ai = Di.transitions), "transitionIn" in Di && cr(9, fi = Di.transitionIn), "transitionInParams" in Di && cr(10, gi = Di.transitionInParams), "transitionOut" in Di && cr(11, Ci = Di.transitionOut), "transitionOutParams" in Di && cr(12, mi = Di.transitionOutParams);
  }, lr.$$.update = () => {
    var Di, sa, ra, fa, ba, Ua, Va;
    lr.$$.dirty[0] & /*$modalStore, position*/
    134225920 && cr(38, ur = (sa = (Di = vr[0]) == null ? void 0 : Di.position) != null ? sa : _r), cr(19, fr = `${cBackdrop$1} ${li} ${Hr} ${(ra = ar.class) != null ? ra : ""} ${(ba = (fa = vr[0]) == null ? void 0 : fa.backdropClasses) != null ? ba : ""}`), lr.$$.dirty[1] & /*cPosition*/
    128 && cr(18, dr = `${cTransitionLayer} ${ur != null ? ur : ""}`), lr.$$.dirty[0] & /*background, width, $modalStore*/
    1610620928 | lr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow*/
    31 && cr(17, gr = `${cModal} ${Sr} ${Er} ${Cr} ${Tr} ${Ar} ${Ir} ${Mr} ${(Va = (Ua = vr[0]) == null ? void 0 : Ua.modalClasses) != null ? Va : ""}`), lr.$$.dirty[0] & /*position, background, width, buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionHeader, regionBody, regionFooter*/
    1744830719 | lr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow, regionBackdrop*/
    95 && cr(16, mr = {
      position: _r,
      // ---
      background: Sr,
      width: Er,
      height: Cr,
      padding: Tr,
      spacing: Ar,
      rounded: Ir,
      shadow: Mr,
      // ---
      buttonNeutral: Br,
      buttonPositive: zr,
      buttonTextCancel: Gr,
      buttonTextConfirm: Xr,
      buttonTextSubmit: Jr,
      // ---
      regionBackdrop: li,
      regionHeader: Qr,
      regionBody: ei,
      regionFooter: ui,
      // ---
      onClose: Bi
    });
  }, ar = exclude_internal_props(ar), [
    Gr,
    Xr,
    Jr,
    Br,
    zr,
    Qr,
    ei,
    ui,
    Ai,
    fi,
    gi,
    Ci,
    mi,
    vr,
    vi,
    di,
    mr,
    gr,
    dr,
    fr,
    qi,
    ki,
    Ji,
    Bi,
    Ni,
    Mi,
    bi,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    li,
    ur,
    Ei,
    Si,
    Vi
  ];
}
class Modal extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$g,
      create_fragment$B,
      safe_not_equal,
      {
        position: 27,
        components: 28,
        background: 29,
        width: 30,
        height: 31,
        padding: 32,
        spacing: 33,
        rounded: 34,
        shadow: 35,
        zIndex: 36,
        buttonNeutral: 3,
        buttonPositive: 4,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 37,
        regionHeader: 5,
        regionBody: 6,
        regionFooter: 7,
        transitions: 8,
        transitionIn: 9,
        transitionInParams: 10,
        transitionOut: 11,
        transitionOutParams: 12
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[27];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get components() {
    return this.$$.ctx[28];
  }
  set components(ar) {
    this.$$set({ components: ar }), flush();
  }
  get background() {
    return this.$$.ctx[29];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[30];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[31];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[32];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[33];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[35];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[36];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonNeutral() {
    return this.$$.ctx[3];
  }
  set buttonNeutral(ar) {
    this.$$set({ buttonNeutral: ar }), flush();
  }
  get buttonPositive() {
    return this.$$.ctx[4];
  }
  set buttonPositive(ar) {
    this.$$set({ buttonPositive: ar }), flush();
  }
  get buttonTextCancel() {
    return this.$$.ctx[0];
  }
  set buttonTextCancel(ar) {
    this.$$set({ buttonTextCancel: ar }), flush();
  }
  get buttonTextConfirm() {
    return this.$$.ctx[1];
  }
  set buttonTextConfirm(ar) {
    this.$$set({ buttonTextConfirm: ar }), flush();
  }
  get buttonTextSubmit() {
    return this.$$.ctx[2];
  }
  set buttonTextSubmit(ar) {
    this.$$set({ buttonTextSubmit: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[37];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[5];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[6];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionFooter() {
    return this.$$.ctx[7];
  }
  set regionFooter(ar) {
    this.$$set({ regionFooter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[8];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[9];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[10];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[11];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[12];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Modal, { position: {}, components: {}, background: {}, width: {}, height: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonNeutral: {}, buttonPositive: {}, buttonTextCancel: {}, buttonTextConfirm: {}, buttonTextSubmit: {}, regionBackdrop: {}, regionHeader: {}, regionBody: {}, regionFooter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
const { window: window_1 } = globals;
function create_if_block$7(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r;
  const xr = (
    /*#slots*/
    lr[32].default
  ), Sr = create_slot(
    xr,
    lr,
    /*$$scope*/
    lr[31],
    null
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), Sr && Sr.c(), attr(cr, "class", ur = "drawer " + /*classesDrawer*/
      lr[8]), attr(cr, "data-testid", "drawer"), attr(cr, "role", "dialog"), attr(cr, "aria-modal", "true"), attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), attr(
        cr,
        "aria-describedby",
        /*describedby*/
        lr[1]
      ), attr(ar, "class", gr = "drawer-backdrop " + /*classesBackdrop*/
      lr[9]), attr(ar, "data-testid", "drawer-backdrop");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, cr), Sr && Sr.m(cr, null), lr[36](cr), lr[37](ar), yr = !0, kr || (_r = [
        listen(
          ar,
          "mousedown",
          /*onDrawerInteraction*/
          lr[12]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          lr[33],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          lr[34],
          { passive: !0 }
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          lr[35]
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], kr = !0);
    },
    p(Er, Cr) {
      lr = Er, Sr && Sr.p && (!yr || Cr[1] & /*$$scope*/
      1) && update_slot_base(
        Sr,
        xr,
        lr,
        /*$$scope*/
        lr[31],
        yr ? get_slot_changes(
          xr,
          /*$$scope*/
          lr[31],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          lr[31]
        ),
        null
      ), (!yr || Cr[0] & /*classesDrawer*/
      256 && ur !== (ur = "drawer " + /*classesDrawer*/
      lr[8])) && attr(cr, "class", ur), (!yr || Cr[0] & /*labelledby*/
      1) && attr(
        cr,
        "aria-labelledby",
        /*labelledby*/
        lr[0]
      ), (!yr || Cr[0] & /*describedby*/
      2) && attr(
        cr,
        "aria-describedby",
        /*describedby*/
        lr[1]
      ), (!yr || Cr[0] & /*classesBackdrop*/
      512 && gr !== (gr = "drawer-backdrop " + /*classesBackdrop*/
      lr[9])) && attr(ar, "class", gr);
    },
    i(Er) {
      yr || (transition_in(Sr, Er), Er && add_render_callback(() => {
        yr && (dr && dr.end(1), fr = create_in_transition(cr, dynamicTransition, {
          transition: fly,
          params: {
            x: (
              /*anim*/
              lr[7].x
            ),
            y: (
              /*anim*/
              lr[7].y
            ),
            duration: (
              /*duration*/
              lr[2]
            ),
            opacity: (
              /*opacityTransition*/
              lr[3] ? void 0 : 1
            )
          },
          enabled: (
            /*transitions*/
            lr[4]
          )
        }), fr.start());
      }), Er && add_render_callback(() => {
        yr && (vr && vr.end(1), mr = create_in_transition(ar, dynamicTransition, {
          transition: fade,
          params: { duration: (
            /*duration*/
            lr[2]
          ) },
          enabled: (
            /*transitions*/
            lr[4] && /*opacityTransition*/
            lr[3]
          )
        }), mr.start());
      }), yr = !0);
    },
    o(Er) {
      transition_out(Sr, Er), fr && fr.invalidate(), Er && (dr = create_out_transition(cr, dynamicTransition, {
        transition: fly,
        params: {
          x: (
            /*anim*/
            lr[7].x
          ),
          y: (
            /*anim*/
            lr[7].y
          ),
          duration: (
            /*duration*/
            lr[2]
          ),
          opacity: (
            /*opacityTransition*/
            lr[3] ? void 0 : 1
          ),
          easing: cubicIn
        },
        enabled: (
          /*transitions*/
          lr[4]
        )
      })), mr && mr.invalidate(), Er && (vr = create_out_transition(ar, dynamicTransition, {
        transition: fade,
        params: { duration: (
          /*duration*/
          lr[2]
        ) },
        enabled: (
          /*transitions*/
          lr[4] && /*opacityTransition*/
          lr[3]
        )
      })), yr = !1;
    },
    d(Er) {
      Er && detach(ar), Sr && Sr.d(Er), lr[36](null), Er && dr && dr.end(), lr[37](null), Er && vr && vr.end(), kr = !1, run_all(_r);
    }
  };
}
function create_fragment$A(lr) {
  let ar, cr, ur, fr, dr = (
    /*$drawerStore*/
    lr[10].open === !0 && create_if_block$7(lr)
  );
  return {
    c() {
      dr && dr.c(), ar = empty$1();
    },
    m(gr, mr) {
      dr && dr.m(gr, mr), insert(gr, ar, mr), cr = !0, ur || (fr = listen(
        window_1,
        "keydown",
        /*onKeydownWindow*/
        lr[13]
      ), ur = !0);
    },
    p(gr, mr) {
      /*$drawerStore*/
      gr[10].open === !0 ? dr ? (dr.p(gr, mr), mr[0] & /*$drawerStore*/
      1024 && transition_in(dr, 1)) : (dr = create_if_block$7(gr), dr.c(), transition_in(dr, 1), dr.m(ar.parentNode, ar)) : dr && (group_outros(), transition_out(dr, 1, 1, () => {
        dr = null;
      }), check_outros());
    },
    i(gr) {
      cr || (transition_in(dr), cr = !0);
    },
    o(gr) {
      transition_out(dr), cr = !1;
    },
    d(gr) {
      gr && detach(ar), dr && dr.d(gr), ur = !1, fr();
    }
  };
}
const cBackdrop = "fixed top-0 left-0 right-0 bottom-0 flex", cDrawer = "overflow-y-auto transition-transform";
function instance$f(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr;
  component_subscribe(lr, prefersReducedMotionStore, (Si) => cr(38, kr = Si));
  let { $$slots: _r = {}, $$scope: xr } = ar;
  const Sr = createEventDispatcher();
  let { position: Er = "left" } = ar, { bgDrawer: Cr = "bg-surface-100-800-token" } = ar, { border: Tr = "" } = ar, { rounded: Ar = "" } = ar, { shadow: Ir = "shadow-xl" } = ar, { width: Mr = "" } = ar, { height: Hr = "" } = ar, { bgBackdrop: Br = "bg-surface-backdrop-token" } = ar, { blur: zr = "" } = ar, { padding: Gr = "" } = ar, { zIndex: Xr = "z-40" } = ar, { regionBackdrop: Jr = "" } = ar, { regionDrawer: li = "" } = ar, { labelledby: Qr = "" } = ar, { describedby: ei = "" } = ar, { duration: ui = 200 } = ar, { transitions: Ai = !kr } = ar, { opacityTransition: fi = !0 } = ar;
  const gi = {
    top: {
      alignment: "items-start",
      width: "w-full",
      height: "h-[50%]",
      rounded: "rounded-bl-container-token rounded-br-container-token"
    },
    bottom: {
      alignment: "items-end",
      width: "w-full",
      height: " h-[50%]",
      rounded: "rounded-tl-container-token rounded-tr-container-token"
    },
    left: {
      alignment: "justify-start",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tr-container-token rounded-br-container-token"
    },
    right: {
      alignment: "justify-end",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tl-container-token rounded-bl-container-token"
    }
  };
  let Ci, mi, vi = { x: 0, y: 0 };
  const Ri = getDrawerStore();
  component_subscribe(lr, Ri, (Si) => cr(10, yr = Si));
  const di = {
    position: Er,
    bgBackdrop: Br,
    blur: zr,
    padding: Gr,
    bgDrawer: Cr,
    border: Tr,
    rounded: Ar,
    shadow: Ir,
    width: Mr,
    height: Hr,
    opacityTransition: fi,
    regionBackdrop: Jr,
    regionDrawer: li,
    labelledby: Qr,
    describedby: ei,
    duration: ui
  };
  function Ti(Si) {
    cr(14, Er = Si.position || di.position), cr(21, Br = Si.bgBackdrop || di.bgBackdrop), cr(22, zr = Si.blur || di.blur), cr(23, Gr = Si.padding || di.padding), cr(15, Cr = Si.bgDrawer || di.bgDrawer), cr(16, Tr = Si.border || di.border), cr(17, Ar = Si.rounded || di.rounded), cr(18, Ir = Si.shadow || di.shadow), cr(19, Mr = Si.width || di.width), cr(20, Hr = Si.height || di.height), cr(24, Jr = Si.regionBackdrop || di.regionBackdrop), cr(25, li = Si.regionDrawer || di.regionDrawer), cr(0, Qr = Si.labelledby || di.labelledby), cr(1, ei = Si.describedby || di.describedby), cr(3, fi = Si.opacityTransition || di.opacityTransition), cr(2, ui = Si.duration || di.duration);
  }
  function qi() {
    switch (Er) {
      case "top":
        cr(7, vi = { x: 0, y: -window.innerWidth });
        break;
      case "bottom":
        cr(7, vi = { x: 0, y: window.innerWidth });
        break;
      case "left":
        cr(7, vi = { x: -window.innerHeight, y: 0 });
        break;
      case "right":
        cr(7, vi = { x: window.innerHeight, y: 0 });
        break;
      default:
        console.error("Error: unknown position property value.");
        break;
    }
  }
  function ki(Si) {
    Si.target === Ci ? (Ri.close(), Sr("backdrop", Si)) : Sr("drawer", Si);
  }
  function Ji(Si) {
    yr && Si.code === "Escape" && Ri.close();
  }
  Ri.subscribe((Si) => {
    Si.open === !0 && (Ti(Si), qi());
  });
  function Bi(Si) {
    bubble.call(this, lr, Si);
  }
  function Ni(Si) {
    bubble.call(this, lr, Si);
  }
  function Mi(Si) {
    bubble.call(this, lr, Si);
  }
  function bi(Si) {
    binding_callbacks[Si ? "unshift" : "push"](() => {
      mi = Si, cr(6, mi);
    });
  }
  function Ei(Si) {
    binding_callbacks[Si ? "unshift" : "push"](() => {
      Ci = Si, cr(5, Ci);
    });
  }
  return lr.$$set = (Si) => {
    cr(44, ar = assign$1(assign$1({}, ar), exclude_internal_props(Si))), "position" in Si && cr(14, Er = Si.position), "bgDrawer" in Si && cr(15, Cr = Si.bgDrawer), "border" in Si && cr(16, Tr = Si.border), "rounded" in Si && cr(17, Ar = Si.rounded), "shadow" in Si && cr(18, Ir = Si.shadow), "width" in Si && cr(19, Mr = Si.width), "height" in Si && cr(20, Hr = Si.height), "bgBackdrop" in Si && cr(21, Br = Si.bgBackdrop), "blur" in Si && cr(22, zr = Si.blur), "padding" in Si && cr(23, Gr = Si.padding), "zIndex" in Si && cr(26, Xr = Si.zIndex), "regionBackdrop" in Si && cr(24, Jr = Si.regionBackdrop), "regionDrawer" in Si && cr(25, li = Si.regionDrawer), "labelledby" in Si && cr(0, Qr = Si.labelledby), "describedby" in Si && cr(1, ei = Si.describedby), "duration" in Si && cr(2, ui = Si.duration), "transitions" in Si && cr(4, Ai = Si.transitions), "opacityTransition" in Si && cr(3, fi = Si.opacityTransition), "$$scope" in Si && cr(31, xr = Si.$$scope);
  }, lr.$$.update = () => {
    var Si;
    lr.$$.dirty[0] & /*position*/
    16384 && cr(30, ur = gi[Er].alignment), lr.$$.dirty[0] & /*width, position*/
    540672 && cr(29, fr = Mr || gi[Er].width), lr.$$.dirty[0] & /*height, position*/
    1064960 && cr(28, dr = Hr || gi[Er].height), lr.$$.dirty[0] & /*rounded, position*/
    147456 && cr(27, gr = Ar || gi[Er].rounded), cr(9, mr = `${cBackdrop} ${Br} ${Gr} ${zr} ${ur} ${Jr} ${Xr} ${(Si = ar.class) != null ? Si : ""}`), lr.$$.dirty[0] & /*bgDrawer, border, rounded, shadow, classesWidth, classesHeight, classesRounded, regionDrawer*/
    973570048 && cr(8, vr = `${cDrawer} ${Cr} ${Tr} ${Ar} ${Ir} ${fr} ${dr} ${gr} ${li}`);
  }, ar = exclude_internal_props(ar), [
    Qr,
    ei,
    ui,
    fi,
    Ai,
    Ci,
    mi,
    vi,
    vr,
    mr,
    yr,
    Ri,
    ki,
    Ji,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr,
    Br,
    zr,
    Gr,
    Jr,
    li,
    Xr,
    gr,
    dr,
    fr,
    ur,
    xr,
    _r,
    Bi,
    Ni,
    Mi,
    bi,
    Ei
  ];
}
class Drawer extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$f,
      create_fragment$A,
      safe_not_equal,
      {
        position: 14,
        bgDrawer: 15,
        border: 16,
        rounded: 17,
        shadow: 18,
        width: 19,
        height: 20,
        bgBackdrop: 21,
        blur: 22,
        padding: 23,
        zIndex: 26,
        regionBackdrop: 24,
        regionDrawer: 25,
        labelledby: 0,
        describedby: 1,
        duration: 2,
        transitions: 4,
        opacityTransition: 3
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[14];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get bgDrawer() {
    return this.$$.ctx[15];
  }
  set bgDrawer(ar) {
    this.$$set({ bgDrawer: ar }), flush();
  }
  get border() {
    return this.$$.ctx[16];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[17];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[18];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[20];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get bgBackdrop() {
    return this.$$.ctx[21];
  }
  set bgBackdrop(ar) {
    this.$$set({ bgBackdrop: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[22];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[26];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[24];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionDrawer() {
    return this.$$.ctx[25];
  }
  set regionDrawer(ar) {
    this.$$set({ regionDrawer: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get describedby() {
    return this.$$.ctx[1];
  }
  set describedby(ar) {
    this.$$set({ describedby: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[2];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get opacityTransition() {
    return this.$$.ctx[3];
  }
  set opacityTransition(ar) {
    this.$$set({ opacityTransition: ar }), flush();
  }
}
create_custom_element(Drawer, { position: {}, bgDrawer: {}, border: {}, rounded: {}, shadow: {}, width: {}, height: {}, bgBackdrop: {}, blur: {}, padding: {}, zIndex: {}, regionBackdrop: {}, regionDrawer: {}, labelledby: {}, describedby: {}, duration: {}, transitions: {}, opacityTransition: { type: "Boolean" } }, ["default"], [], !0);
function create_fragment$z(lr) {
  let ar, cr = `<script nonce="%sveltekit.nonce%">(${setInitialClassState.toString()})();<\/script>`, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$1(), fr = space(), dr = element("div"), gr = element("div"), mr = svg_element("svg"), vr = svg_element("path"), ar.a = ur, attr(vr, "d", yr = /*$modeCurrent*/
      lr[1] ? (
        /*svgPath*/
        lr[5].sun
      ) : (
        /*svgPath*/
        lr[5].moon
      )), attr(mr, "class", kr = "lightswitch-icon " + /*classesIcon*/
      lr[2]), attr(mr, "xmlns", "http://www.w3.org/2000/svg"), attr(mr, "viewBox", "0 0 512 512"), attr(gr, "class", _r = "lightswitch-thumb " + /*classesThumb*/
      lr[3]), attr(dr, "class", xr = "lightswitch-track " + /*classesTrack*/
      lr[4]), attr(dr, "role", "switch"), attr(dr, "aria-label", "Light Switch"), attr(
        dr,
        "aria-checked",
        /*$modeCurrent*/
        lr[1]
      ), attr(
        dr,
        "title",
        /*title*/
        lr[0]
      ), attr(dr, "tabindex", "0");
    },
    m(Cr, Tr) {
      ar.m(cr, document.head), append(document.head, ur), insert(Cr, fr, Tr), insert(Cr, dr, Tr), append(dr, gr), append(gr, mr), append(mr, vr), Sr || (Er = [
        listen(
          dr,
          "click",
          /*onToggleHandler*/
          lr[6]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          lr[19]
        ),
        listen(dr, "keydown", onKeyDown),
        listen(
          dr,
          "keydown",
          /*keydown_handler*/
          lr[20]
        ),
        listen(
          dr,
          "keyup",
          /*keyup_handler*/
          lr[21]
        ),
        listen(
          dr,
          "keypress",
          /*keypress_handler*/
          lr[22]
        )
      ], Sr = !0);
    },
    p(Cr, [Tr]) {
      Tr & /*$modeCurrent*/
      2 && yr !== (yr = /*$modeCurrent*/
      Cr[1] ? (
        /*svgPath*/
        Cr[5].sun
      ) : (
        /*svgPath*/
        Cr[5].moon
      )) && attr(vr, "d", yr), Tr & /*classesIcon*/
      4 && kr !== (kr = "lightswitch-icon " + /*classesIcon*/
      Cr[2]) && attr(mr, "class", kr), Tr & /*classesThumb*/
      8 && _r !== (_r = "lightswitch-thumb " + /*classesThumb*/
      Cr[3]) && attr(gr, "class", _r), Tr & /*classesTrack*/
      16 && xr !== (xr = "lightswitch-track " + /*classesTrack*/
      Cr[4]) && attr(dr, "class", xr), Tr & /*$modeCurrent*/
      2 && attr(
        dr,
        "aria-checked",
        /*$modeCurrent*/
        Cr[1]
      ), Tr & /*title*/
      1 && attr(
        dr,
        "title",
        /*title*/
        Cr[0]
      );
    },
    i: noop$1,
    o: noop$1,
    d(Cr) {
      Cr && (ar.d(), detach(fr), detach(dr)), detach(ur), Sr = !1, run_all(Er);
    }
  };
}
const cTrack = "cursor-pointer", cThumb = "aspect-square scale-[0.8] flex justify-center items-center", cIcon = "w-[70%] aspect-square";
function onKeyDown(lr) {
  ["Enter", "Space"].includes(lr.code) && (lr.preventDefault(), lr.currentTarget.click());
}
function instance$e(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr, kr;
  component_subscribe(lr, modeCurrent, (Qr) => cr(1, kr = Qr));
  let { title: _r = "Toggle light or dark mode." } = ar, { bgLight: xr = "bg-surface-50" } = ar, { bgDark: Sr = "bg-surface-900" } = ar, { fillLight: Er = "fill-surface-50" } = ar, { fillDark: Cr = "fill-surface-900" } = ar, { width: Tr = "w-12" } = ar, { height: Ar = "h-6" } = ar, { ring: Ir = "ring-[1px] ring-surface-500/30" } = ar, { rounded: Mr = "rounded-token" } = ar;
  const Hr = "transition-all duration-[200ms]", Br = {
    sun: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z",
    moon: "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
  };
  function zr() {
    set_store_value(modeCurrent, kr = !kr, kr), setModeUserPrefers(kr), setModeCurrent(kr);
  }
  onMount(() => {
    "modeCurrent" in localStorage || setModeCurrent(getModeOsPrefers());
  });
  function Gr(Qr) {
    bubble.call(this, lr, Qr);
  }
  function Xr(Qr) {
    bubble.call(this, lr, Qr);
  }
  function Jr(Qr) {
    bubble.call(this, lr, Qr);
  }
  function li(Qr) {
    bubble.call(this, lr, Qr);
  }
  return lr.$$set = (Qr) => {
    cr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(Qr))), "title" in Qr && cr(0, _r = Qr.title), "bgLight" in Qr && cr(7, xr = Qr.bgLight), "bgDark" in Qr && cr(8, Sr = Qr.bgDark), "fillLight" in Qr && cr(9, Er = Qr.fillLight), "fillDark" in Qr && cr(10, Cr = Qr.fillDark), "width" in Qr && cr(11, Tr = Qr.width), "height" in Qr && cr(12, Ar = Qr.height), "ring" in Qr && cr(13, Ir = Qr.ring), "rounded" in Qr && cr(14, Mr = Qr.rounded);
  }, lr.$$.update = () => {
    var Qr;
    lr.$$.dirty & /*$modeCurrent, bgLight, bgDark*/
    386 && cr(18, ur = kr === !0 ? xr : Sr), lr.$$.dirty & /*$modeCurrent, bgDark, bgLight*/
    386 && cr(17, fr = kr === !0 ? Sr : xr), lr.$$.dirty & /*$modeCurrent*/
    2 && cr(16, dr = kr === !0 ? "translate-x-[100%]" : ""), lr.$$.dirty & /*$modeCurrent, fillLight, fillDark*/
    1538 && cr(15, gr = kr === !0 ? Er : Cr), cr(4, mr = `${cTrack} ${Hr} ${Tr} ${Ar} ${Ir} ${Mr} ${ur} ${(Qr = ar.class) != null ? Qr : ""}`), lr.$$.dirty & /*height, rounded, thumbBg, thumbPosition*/
    217088 && cr(3, vr = `${cThumb} ${Hr} ${Ar} ${Mr} ${fr} ${dr}`), lr.$$.dirty & /*iconFill*/
    32768 && cr(2, yr = `${cIcon} ${gr}`);
  }, ar = exclude_internal_props(ar), [
    _r,
    kr,
    yr,
    vr,
    mr,
    Br,
    zr,
    xr,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    gr,
    dr,
    fr,
    ur,
    Gr,
    Xr,
    Jr,
    li
  ];
}
class LightSwitch extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$e, create_fragment$z, safe_not_equal, {
      title: 0,
      bgLight: 7,
      bgDark: 8,
      fillLight: 9,
      fillDark: 10,
      width: 11,
      height: 12,
      ring: 13,
      rounded: 14
    });
  }
  get title() {
    return this.$$.ctx[0];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get bgLight() {
    return this.$$.ctx[7];
  }
  set bgLight(ar) {
    this.$$set({ bgLight: ar }), flush();
  }
  get bgDark() {
    return this.$$.ctx[8];
  }
  set bgDark(ar) {
    this.$$set({ bgDark: ar }), flush();
  }
  get fillLight() {
    return this.$$.ctx[9];
  }
  set fillLight(ar) {
    this.$$set({ fillLight: ar }), flush();
  }
  get fillDark() {
    return this.$$.ctx[10];
  }
  set fillDark(ar) {
    this.$$set({ fillDark: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[12];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get ring() {
    return this.$$.ctx[13];
  }
  set ring(ar) {
    this.$$set({ ring: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
}
create_custom_element(LightSwitch, { title: {}, bgLight: {}, bgDark: {}, fillLight: {}, fillDark: {}, width: {}, height: {}, ring: {}, rounded: {} }, [], [], !0);
function get_each_context$3(lr, ar, cr) {
  const ur = lr.slice();
  return ur[36] = ar[cr], ur[38] = cr, ur;
}
function create_if_block$6(lr) {
  let ar, cr, ur = [], fr = /* @__PURE__ */ new Map(), dr, gr, mr, vr = ensure_array_like(
    /*filteredToasts*/
    lr[11]
  );
  const yr = (kr) => (
    /*t*/
    kr[36]
  );
  for (let kr = 0; kr < vr.length; kr += 1) {
    let _r = get_each_context$3(lr, vr, kr), xr = yr(_r);
    fr.set(xr, ur[kr] = create_each_block$3(xr, _r));
  }
  return {
    c() {
      ar = element("div"), cr = element("div");
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr].c();
      attr(cr, "class", dr = "snackbar " + /*classesSnackbar*/
      lr[13]), attr(ar, "class", gr = "snackbar-wrapper " + /*classesWrapper*/
      lr[14]), attr(ar, "data-testid", "snackbar-wrapper");
    },
    m(kr, _r) {
      insert(kr, ar, _r), append(ar, cr);
      for (let xr = 0; xr < ur.length; xr += 1)
        ur[xr] && ur[xr].m(cr, null);
      mr = !0;
    },
    p(kr, _r) {
      if (_r[0] & /*filteredToasts, transitionOut, animAxis, transitionOutParams, transitions, onMouseEnter, onMouseLeave, classesToast, background, buttonDismiss, toastStore, buttonDismissLabel, buttonAction, onAction*/
      499103) {
        vr = ensure_array_like(
          /*filteredToasts*/
          kr[11]
        ), group_outros();
        for (let xr = 0; xr < ur.length; xr += 1)
          ur[xr].r();
        ur = update_keyed_each(ur, _r, yr, 1, kr, vr, fr, cr, fix_and_outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        for (let xr = 0; xr < ur.length; xr += 1)
          ur[xr].a();
        check_outros();
      }
      (!mr || _r[0] & /*classesSnackbar*/
      8192 && dr !== (dr = "snackbar " + /*classesSnackbar*/
      kr[13])) && attr(cr, "class", dr), (!mr || _r[0] & /*classesWrapper*/
      16384 && gr !== (gr = "snackbar-wrapper " + /*classesWrapper*/
      kr[14])) && attr(ar, "class", gr);
    },
    i(kr) {
      if (!mr) {
        for (let _r = 0; _r < vr.length; _r += 1)
          transition_in(ur[_r]);
        mr = !0;
      }
    },
    o(kr) {
      for (let _r = 0; _r < ur.length; _r += 1)
        transition_out(ur[_r]);
      mr = !1;
    },
    d(kr) {
      kr && detach(ar);
      for (let _r = 0; _r < ur.length; _r += 1)
        ur[_r].d();
    }
  };
}
function create_if_block_1$3(lr) {
  let ar, cr, ur = (
    /*t*/
    lr[36].action && create_if_block_3$2(lr)
  ), fr = !/*t*/
  lr[36].hideDismiss && create_if_block_2$2(lr);
  return {
    c() {
      ar = element("div"), ur && ur.c(), cr = space(), fr && fr.c(), attr(ar, "class", "toast-actions " + cToastActions);
    },
    m(dr, gr) {
      insert(dr, ar, gr), ur && ur.m(ar, null), append(ar, cr), fr && fr.m(ar, null);
    },
    p(dr, gr) {
      /*t*/
      dr[36].action ? ur ? ur.p(dr, gr) : (ur = create_if_block_3$2(dr), ur.c(), ur.m(ar, cr)) : ur && (ur.d(1), ur = null), /*t*/
      dr[36].hideDismiss ? fr && (fr.d(1), fr = null) : fr ? fr.p(dr, gr) : (fr = create_if_block_2$2(dr), fr.c(), fr.m(ar, null));
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(), fr && fr.d();
    }
  };
}
function create_if_block_3$2(lr) {
  let ar, cr = (
    /*t*/
    lr[36].action.label + ""
  ), ur, fr;
  function dr() {
    return (
      /*click_handler*/
      lr[30](
        /*i*/
        lr[38]
      )
    );
  }
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "class",
        /*buttonAction*/
        lr[1]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.innerHTML = cr, ur || (fr = listen(ar, "click", dr), ur = !0);
    },
    p(gr, mr) {
      lr = gr, mr[0] & /*filteredToasts*/
      2048 && cr !== (cr = /*t*/
      lr[36].action.label + "") && (ar.innerHTML = cr), mr[0] & /*buttonAction*/
      2 && attr(
        ar,
        "class",
        /*buttonAction*/
        lr[1]
      );
    },
    d(gr) {
      gr && detach(ar), ur = !1, fr();
    }
  };
}
function create_if_block_2$2(lr) {
  let ar, cr, ur, fr;
  function dr() {
    return (
      /*click_handler_1*/
      lr[31](
        /*t*/
        lr[36]
      )
    );
  }
  return {
    c() {
      ar = element("button"), cr = text$3(
        /*buttonDismissLabel*/
        lr[3]
      ), attr(
        ar,
        "class",
        /*buttonDismiss*/
        lr[2]
      ), attr(ar, "aria-label", "Dismiss toast");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, cr), ur || (fr = listen(ar, "click", dr), ur = !0);
    },
    p(gr, mr) {
      lr = gr, mr[0] & /*buttonDismissLabel*/
      8 && set_data(
        cr,
        /*buttonDismissLabel*/
        lr[3]
      ), mr[0] & /*buttonDismiss*/
      4 && attr(
        ar,
        "class",
        /*buttonDismiss*/
        lr[2]
      );
    },
    d(gr) {
      gr && detach(ar), ur = !1, fr();
    }
  };
}
function create_each_block$3(lr, ar) {
  let cr, ur, fr, dr = (
    /*t*/
    ar[36].message + ""
  ), gr, mr, vr, yr, kr, _r, xr, Sr = noop$1, Er, Cr, Tr, Ar = (
    /*t*/
    (ar[36].action || !/*t*/
    ar[36].hideDismiss) && create_if_block_1$3(ar)
  );
  function Ir() {
    return (
      /*mouseenter_handler*/
      ar[32](
        /*i*/
        ar[38]
      )
    );
  }
  function Mr() {
    return (
      /*mouseleave_handler*/
      ar[33](
        /*i*/
        ar[38]
      )
    );
  }
  return {
    key: lr,
    first: null,
    c() {
      var Hr, Br;
      cr = element("div"), ur = element("div"), fr = element("div"), gr = space(), Ar && Ar.c(), vr = space(), attr(fr, "class", "text-base"), attr(ur, "class", mr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((Hr = ar[36].background) != null ? Hr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      ((Br = ar[36].classes) != null ? Br : "")), attr(ur, "data-testid", "toast"), attr(cr, "role", yr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog"), attr(cr, "aria-live", "polite"), this.first = cr;
    },
    m(Hr, Br) {
      insert(Hr, cr, Br), append(cr, ur), append(ur, fr), fr.innerHTML = dr, append(ur, gr), Ar && Ar.m(ur, null), append(cr, vr), Er = !0, Cr || (Tr = [
        listen(cr, "mouseenter", Ir),
        listen(cr, "mouseleave", Mr)
      ], Cr = !0);
    },
    p(Hr, Br) {
      var zr, Gr;
      ar = Hr, (!Er || Br[0] & /*filteredToasts*/
      2048) && dr !== (dr = /*t*/
      ar[36].message + "") && (fr.innerHTML = dr), /*t*/
      ar[36].action || !/*t*/
      ar[36].hideDismiss ? Ar ? Ar.p(ar, Br) : (Ar = create_if_block_1$3(ar), Ar.c(), Ar.m(ur, null)) : Ar && (Ar.d(1), Ar = null), (!Er || Br[0] & /*classesToast, filteredToasts, background*/
      6145 && mr !== (mr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((zr = ar[36].background) != null ? zr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      ((Gr = ar[36].classes) != null ? Gr : ""))) && attr(ur, "class", mr), (!Er || Br[0] & /*filteredToasts*/
      2048 && yr !== (yr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog")) && attr(cr, "role", yr);
    },
    r() {
      xr = cr.getBoundingClientRect();
    },
    f() {
      fix_position(cr), Sr(), add_transform(cr, xr);
    },
    a() {
      Sr(), Sr = create_animation(cr, xr, flip, {
        duration: (
          /*transitions*/
          ar[4] ? 250 : 0
        )
      });
    },
    i(Hr) {
      Er || (add_render_callback(() => {
        Er && (_r && _r.end(1), kr = create_in_transition(cr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[5]
          ),
          params: {
            x: (
              /*animAxis*/
              ar[10].x
            ),
            y: (
              /*animAxis*/
              ar[10].y
            ),
            .../*transitionInParams*/
            ar[6]
          },
          enabled: (
            /*transitions*/
            ar[4]
          )
        }), kr.start());
      }), Er = !0);
    },
    o(Hr) {
      kr && kr.invalidate(), _r = create_out_transition(cr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[7]
        ),
        params: {
          x: (
            /*animAxis*/
            ar[10].x
          ),
          y: (
            /*animAxis*/
            ar[10].y
          ),
          .../*transitionOutParams*/
          ar[8]
        },
        enabled: (
          /*transitions*/
          ar[4]
        )
      }), Er = !1;
    },
    d(Hr) {
      Hr && detach(cr), Ar && Ar.d(), Hr && _r && _r.end(), Cr = !1, run_all(Tr);
    }
  };
}
function create_fragment$y(lr) {
  let ar, cr, ur = (
    /*$toastStore*/
    lr[9].length && create_if_block$6(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*$toastStore*/
      fr[9].length ? ur ? (ur.p(fr, dr), dr[0] & /*$toastStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$6(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cWrapper = "flex fixed top-0 left-0 right-0 bottom-0 pointer-events-none", cSnackbar = "flex flex-col gap-y-2", cToast = "flex justify-between items-center pointer-events-auto", cToastActions = "flex items-center space-x-2";
function instance$d(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr;
  component_subscribe(lr, prefersReducedMotionStore, (Ti) => cr(34, vr = Ti));
  const yr = getToastStore();
  component_subscribe(lr, yr, (Ti) => cr(9, mr = Ti));
  let { position: kr = "b" } = ar, { max: _r = 3 } = ar, { background: xr = "variant-filled-secondary" } = ar, { width: Sr = "max-w-[640px]" } = ar, { color: Er = "" } = ar, { padding: Cr = "p-4" } = ar, { spacing: Tr = "space-x-4" } = ar, { rounded: Ar = "rounded-container-token" } = ar, { shadow: Ir = "shadow-lg" } = ar, { zIndex: Mr = "z-[888]" } = ar, { buttonAction: Hr = "btn variant-filled" } = ar, { buttonDismiss: Br = "btn-icon btn-icon-sm variant-filled" } = ar, { buttonDismissLabel: zr = "✕" } = ar, { transitions: Gr = !vr } = ar, { transitionIn: Xr = fly } = ar, { transitionInParams: Jr = { duration: 250 } } = ar, { transitionOut: li = fly } = ar, { transitionOutParams: Qr = { duration: 250 } } = ar, ei, ui, Ai = { x: 0, y: 0 };
  switch (kr) {
    case "t":
      ei = "justify-center items-start", ui = "items-center", Ai = { x: 0, y: -100 };
      break;
    case "b":
      ei = "justify-center items-end", ui = "items-center", Ai = { x: 0, y: 100 };
      break;
    case "l":
      ei = "justify-start items-center", ui = "items-start", Ai = { x: -100, y: 0 };
      break;
    case "r":
      ei = "justify-end items-center", ui = "items-end", Ai = { x: 100, y: 0 };
      break;
    case "tl":
      ei = "justify-start items-start", ui = "items-start", Ai = { x: -100, y: 0 };
      break;
    case "tr":
      ei = "justify-end items-start", ui = "items-end", Ai = { x: 100, y: 0 };
      break;
    case "bl":
      ei = "justify-start items-end", ui = "items-start", Ai = { x: -100, y: 0 };
      break;
    case "br":
      ei = "justify-end items-end", ui = "items-end", Ai = { x: 100, y: 0 };
      break;
  }
  function fi(Ti) {
    var qi, ki;
    (ki = (qi = mr[Ti]) == null ? void 0 : qi.action) == null || ki.response(), yr.close(mr[Ti].id);
  }
  function gi(Ti) {
    var qi;
    (qi = mr[Ti]) != null && qi.hoverable && (yr.freeze(Ti), cr(13, fr += " scale-[105%]"));
  }
  function Ci(Ti) {
    var qi;
    (qi = mr[Ti]) != null && qi.hoverable && (yr.unfreeze(Ti), cr(13, fr = fr.replace(" scale-[105%]", "")));
  }
  const mi = (Ti) => fi(Ti), vi = (Ti) => yr.close(Ti.id), Ri = (Ti) => gi(Ti), di = (Ti) => Ci(Ti);
  return lr.$$set = (Ti) => {
    cr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ti))), "position" in Ti && cr(19, kr = Ti.position), "max" in Ti && cr(20, _r = Ti.max), "background" in Ti && cr(0, xr = Ti.background), "width" in Ti && cr(21, Sr = Ti.width), "color" in Ti && cr(22, Er = Ti.color), "padding" in Ti && cr(23, Cr = Ti.padding), "spacing" in Ti && cr(24, Tr = Ti.spacing), "rounded" in Ti && cr(25, Ar = Ti.rounded), "shadow" in Ti && cr(26, Ir = Ti.shadow), "zIndex" in Ti && cr(27, Mr = Ti.zIndex), "buttonAction" in Ti && cr(1, Hr = Ti.buttonAction), "buttonDismiss" in Ti && cr(2, Br = Ti.buttonDismiss), "buttonDismissLabel" in Ti && cr(3, zr = Ti.buttonDismissLabel), "transitions" in Ti && cr(4, Gr = Ti.transitions), "transitionIn" in Ti && cr(5, Xr = Ti.transitionIn), "transitionInParams" in Ti && cr(6, Jr = Ti.transitionInParams), "transitionOut" in Ti && cr(7, li = Ti.transitionOut), "transitionOutParams" in Ti && cr(8, Qr = Ti.transitionOutParams);
  }, lr.$$.update = () => {
    cr(14, ur = `${cWrapper} ${ei} ${Mr} ${ar.class || ""}`), lr.$$.dirty[0] & /*cAlign, padding*/
    545259520 && cr(13, fr = `${cSnackbar} ${ui} ${Cr}`), lr.$$.dirty[0] & /*width, color, padding, spacing, rounded, shadow*/
    132120576 && cr(12, dr = `${cToast} ${Sr} ${Er} ${Cr} ${Tr} ${Ar} ${Ir}`), lr.$$.dirty[0] & /*$toastStore, max*/
    1049088 && cr(11, gr = Array.from(mr).slice(0, _r));
  }, ar = exclude_internal_props(ar), [
    xr,
    Hr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    mr,
    Ai,
    gr,
    dr,
    fr,
    ur,
    yr,
    fi,
    gi,
    Ci,
    kr,
    _r,
    Sr,
    Er,
    Cr,
    Tr,
    Ar,
    Ir,
    Mr,
    ei,
    ui,
    mi,
    vi,
    Ri,
    di
  ];
}
class Toast extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$d,
      create_fragment$y,
      safe_not_equal,
      {
        position: 19,
        max: 20,
        background: 0,
        width: 21,
        color: 22,
        padding: 23,
        spacing: 24,
        rounded: 25,
        shadow: 26,
        zIndex: 27,
        buttonAction: 1,
        buttonDismiss: 2,
        buttonDismissLabel: 3,
        transitions: 4,
        transitionIn: 5,
        transitionInParams: 6,
        transitionOut: 7,
        transitionOutParams: 8
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[19];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get max() {
    return this.$$.ctx[20];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get background() {
    return this.$$.ctx[0];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[21];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get color() {
    return this.$$.ctx[22];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[24];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[25];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[26];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[27];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonAction() {
    return this.$$.ctx[1];
  }
  set buttonAction(ar) {
    this.$$set({ buttonAction: ar }), flush();
  }
  get buttonDismiss() {
    return this.$$.ctx[2];
  }
  set buttonDismiss(ar) {
    this.$$set({ buttonDismiss: ar }), flush();
  }
  get buttonDismissLabel() {
    return this.$$.ctx[3];
  }
  set buttonDismissLabel(ar) {
    this.$$set({ buttonDismissLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[5];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[6];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[7];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[8];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Toast, { position: {}, max: {}, background: {}, width: {}, color: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonAction: {}, buttonDismiss: {}, buttonDismissLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function get_each_context$2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[19] = ar[cr], ur;
}
function create_if_block$5(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  const yr = (
    /*#slots*/
    lr[16].default
  ), kr = create_slot(
    yr,
    lr,
    /*$$scope*/
    lr[15],
    null
  ), _r = kr || fallback_block();
  let xr = ensure_array_like(
    /*$tocStore*/
    lr[9]
  ), Sr = [];
  for (let Er = 0; Er < xr.length; Er += 1)
    Sr[Er] = create_each_block$2(get_each_context$2(lr, xr, Er));
  return {
    c() {
      ar = element("nav"), cr = element("div"), _r && _r.c(), ur = space(), fr = element("ul");
      for (let Er = 0; Er < Sr.length; Er += 1)
        Sr[Er].c();
      attr(
        cr,
        "class",
        /*regionLead*/
        lr[3]
      ), attr(fr, "class", dr = "toc-list " + /*classesList*/
      lr[6]), attr(ar, "class", gr = "toc " + /*classesBase*/
      lr[7]), attr(ar, "data-testid", "toc");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, cr), _r && _r.m(cr, null), append(ar, ur), append(ar, fr);
      for (let Tr = 0; Tr < Sr.length; Tr += 1)
        Sr[Tr] && Sr[Tr].m(fr, null);
      vr = !0;
    },
    p(Er, Cr) {
      if (kr && kr.p && (!vr || Cr & /*$$scope*/
      32768) && update_slot_base(
        kr,
        yr,
        Er,
        /*$$scope*/
        Er[15],
        vr ? get_slot_changes(
          yr,
          /*$$scope*/
          Er[15],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Er[15]
        ),
        null
      ), (!vr || Cr & /*regionLead*/
      8) && attr(
        cr,
        "class",
        /*regionLead*/
        Er[3]
      ), Cr & /*classesListItem, indentStyles, $tocStore, classesAnchor, reactiveActiveId, active, inactive*/
      823) {
        xr = ensure_array_like(
          /*$tocStore*/
          Er[9]
        );
        let Tr;
        for (Tr = 0; Tr < xr.length; Tr += 1) {
          const Ar = get_each_context$2(Er, xr, Tr);
          Sr[Tr] ? Sr[Tr].p(Ar, Cr) : (Sr[Tr] = create_each_block$2(Ar), Sr[Tr].c(), Sr[Tr].m(fr, null));
        }
        for (; Tr < Sr.length; Tr += 1)
          Sr[Tr].d(1);
        Sr.length = xr.length;
      }
      (!vr || Cr & /*classesList*/
      64 && dr !== (dr = "toc-list " + /*classesList*/
      Er[6])) && attr(fr, "class", dr), (!vr || Cr & /*classesBase*/
      128 && gr !== (gr = "toc " + /*classesBase*/
      Er[7])) && attr(ar, "class", gr);
    },
    i(Er) {
      vr || (transition_in(_r, Er), Er && add_render_callback(() => {
        vr && (mr || (mr = create_bidirectional_transition(ar, fade, { duration: 100 }, !0)), mr.run(1));
      }), vr = !0);
    },
    o(Er) {
      transition_out(_r, Er), Er && (mr || (mr = create_bidirectional_transition(ar, fade, { duration: 100 }, !1)), mr.run(0)), vr = !1;
    },
    d(Er) {
      Er && detach(ar), _r && _r.d(Er), destroy_each(Sr, Er), Er && mr && mr.end();
    }
  };
}
function fallback_block(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Table of Contents");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_each_block$2(lr) {
  let ar, cr, ur = (
    /*tocHeading*/
    lr[19].text + ""
  ), fr, dr, gr, mr, vr, yr, kr;
  function _r() {
    return (
      /*click_handler*/
      lr[17](
        /*tocHeading*/
        lr[19]
      )
    );
  }
  return {
    c() {
      ar = element("li"), cr = element("a"), fr = text$3(ur), mr = space(), attr(cr, "href", dr = "#" + /*tocHeading*/
      lr[19].id), attr(cr, "class", gr = "toc-anchor " + /*classesAnchor*/
      lr[4] + " " + /*tocHeading*/
      (lr[19].id === /*reactiveActiveId*/
      lr[8] ? (
        /*active*/
        lr[1]
      ) : (
        /*inactive*/
        lr[0]
      ))), attr(ar, "class", vr = "toc-list-item " + /*classesListItem*/
      lr[5] + " " + /*indentStyles*/
      lr[2][
        /*tocHeading*/
        lr[19].element
      ]);
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), append(ar, cr), append(cr, fr), append(ar, mr), yr || (kr = listen(cr, "click", _r), yr = !0);
    },
    p(xr, Sr) {
      lr = xr, Sr & /*$tocStore*/
      512 && ur !== (ur = /*tocHeading*/
      lr[19].text + "") && set_data(fr, ur), Sr & /*$tocStore*/
      512 && dr !== (dr = "#" + /*tocHeading*/
      lr[19].id) && attr(cr, "href", dr), Sr & /*classesAnchor, $tocStore, reactiveActiveId, active, inactive*/
      787 && gr !== (gr = "toc-anchor " + /*classesAnchor*/
      lr[4] + " " + /*tocHeading*/
      (lr[19].id === /*reactiveActiveId*/
      lr[8] ? (
        /*active*/
        lr[1]
      ) : (
        /*inactive*/
        lr[0]
      ))) && attr(cr, "class", gr), Sr & /*classesListItem, indentStyles, $tocStore*/
      548 && vr !== (vr = "toc-list-item " + /*classesListItem*/
      lr[5] + " " + /*indentStyles*/
      lr[2][
        /*tocHeading*/
        lr[19].element
      ]) && attr(ar, "class", vr);
    },
    d(xr) {
      xr && detach(ar), yr = !1, kr();
    }
  };
}
function create_fragment$x(lr) {
  let ar, cr, ur = (
    /*$tocStore*/
    lr[9].length && create_if_block$5(lr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, [dr]) {
      /*$tocStore*/
      fr[9].length ? ur ? (ur.p(fr, dr), dr & /*$tocStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$5(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const cBase = "space-y-4", cList = "space-y-2", cListItem = "block", cAnchor = "";
function instance$c(lr, ar, cr) {
  let ur, fr, dr, gr, mr, vr, yr;
  component_subscribe(lr, tocActiveId, (Br) => cr(14, vr = Br)), component_subscribe(lr, tocStore, (Br) => cr(9, yr = Br));
  let { $$slots: kr = {}, $$scope: _r } = ar, { inactive: xr = "opacity-60 hover:opacity-100" } = ar, { active: Sr = "text-primary-500" } = ar, { activeId: Er = "" } = ar, { indentStyles: Cr = {
    h2: "",
    h3: "ml-4",
    h4: "ml-8",
    h5: "ml-12",
    h6: "ml-16"
  } } = ar, { regionLead: Tr = "font-bold" } = ar, { regionList: Ar = "" } = ar, { regionListItem: Ir = "" } = ar, { regionAnchor: Mr = "" } = ar;
  const Hr = (Br) => {
    cr(8, ur = Br.id);
  };
  return lr.$$set = (Br) => {
    cr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Br))), "inactive" in Br && cr(0, xr = Br.inactive), "active" in Br && cr(1, Sr = Br.active), "activeId" in Br && cr(10, Er = Br.activeId), "indentStyles" in Br && cr(2, Cr = Br.indentStyles), "regionLead" in Br && cr(3, Tr = Br.regionLead), "regionList" in Br && cr(11, Ar = Br.regionList), "regionListItem" in Br && cr(12, Ir = Br.regionListItem), "regionAnchor" in Br && cr(13, Mr = Br.regionAnchor), "$$scope" in Br && cr(15, _r = Br.$$scope);
  }, lr.$$.update = () => {
    var Br;
    lr.$$.dirty & /*$tocActiveId, activeId*/
    17408 && cr(8, ur = vr || Er.replace("#", "")), cr(7, fr = `${cBase} ${(Br = ar.class) != null ? Br : ""}`), lr.$$.dirty & /*regionList*/
    2048 && cr(6, dr = `${cList} ${Ar}`), lr.$$.dirty & /*regionListItem*/
    4096 && cr(5, gr = `${cListItem} ${Ir}`), lr.$$.dirty & /*regionAnchor*/
    8192 && cr(4, mr = `${cAnchor} ${Mr}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    Sr,
    Cr,
    Tr,
    mr,
    gr,
    dr,
    fr,
    ur,
    yr,
    Er,
    Ar,
    Ir,
    Mr,
    vr,
    _r,
    kr,
    Hr
  ];
}
class TableOfContents extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$c, create_fragment$x, safe_not_equal, {
      inactive: 0,
      active: 1,
      activeId: 10,
      indentStyles: 2,
      regionLead: 3,
      regionList: 11,
      regionListItem: 12,
      regionAnchor: 13
    });
  }
  get inactive() {
    return this.$$.ctx[0];
  }
  set inactive(ar) {
    this.$$set({ inactive: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get activeId() {
    return this.$$.ctx[10];
  }
  set activeId(ar) {
    this.$$set({ activeId: ar }), flush();
  }
  get indentStyles() {
    return this.$$.ctx[2];
  }
  set indentStyles(ar) {
    this.$$set({ indentStyles: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[3];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[11];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionListItem() {
    return this.$$.ctx[12];
  }
  set regionListItem(ar) {
    this.$$set({ regionListItem: ar }), flush();
  }
  get regionAnchor() {
    return this.$$.ctx[13];
  }
  set regionAnchor(ar) {
    this.$$set({ regionAnchor: ar }), flush();
  }
}
create_custom_element(TableOfContents, { inactive: {}, active: {}, activeId: {}, indentStyles: {}, regionLead: {}, regionList: {}, regionListItem: {}, regionAnchor: {} }, ["default"], [], !0);
function create_fragment$w(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "values", `0.8 0.6 -0.4 0.1 0,
					0 1.2 0.05 0 0,
					0 -1 3 0.02 0,
					0 0 0 50 0`), attr(ur, "result", "final"), attr(ur, "in", "SourceGraphic"), attr(cr, "id", "Apollo"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-apollo"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Apollo extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$w, safe_not_equal, {});
  }
}
create_custom_element(Apollo, {}, [], [], !0);
function create_fragment$v(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.000 0.000 0.000 0.000 0.000 
                    0.000 1.000 0.000 0.000 0.05 
                    0.000 0.000 1.000 0.000 0.400 
                    0.000 0.000 0.000 1.000 0.000`), attr(cr, "id", "BlueNight"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-bluenight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class BlueNight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$v, safe_not_equal, {});
  }
}
create_custom_element(BlueNight, {}, [], [], !0);
function create_fragment$u(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feComponentTransfer"), dr = svg_element("feFuncR"), gr = svg_element("feFuncG"), mr = svg_element("feFuncB"), vr = svg_element("feFuncA"), yr = svg_element("feBlend"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            0 0 0 0.33 0`), attr(dr, "type", "table"), attr(dr, "tableValues", "0.03 0.9"), attr(gr, "type", "table"), attr(gr, "tableValues", "0.57 1"), attr(mr, "type", "table"), attr(mr, "tableValues", "0.49 0.53"), attr(vr, "type", "table"), attr(vr, "tableValues", "0 1"), attr(fr, "in", "colormatrix"), attr(fr, "result", "componentTransfer"), attr(yr, "mode", "normal"), attr(yr, "in", "componentTransfer"), attr(yr, "in2", "SourceGraphic"), attr(yr, "result", "blend"), attr(cr, "id", "Emerald"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-emerald"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(kr, _r) {
      insert(kr, ar, _r), append(ar, cr), append(cr, ur), append(cr, fr), append(fr, dr), append(fr, gr), append(fr, mr), append(fr, vr), append(cr, yr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(kr) {
      kr && detach(ar);
    }
  };
}
class Emerald extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$u, safe_not_equal, {});
  }
}
create_custom_element(Emerald, {}, [], [], !0);
function create_fragment$t(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `0.5 -0.4 0.3332 0 0
					0 0.4 0.3 0 0
					0 0 0.5 0 0
					0 0 0 500 -20`), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(cr, "id", "GreenFall"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-greenfall"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class GreenFall extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$t, safe_not_equal, {});
  }
}
create_custom_element(GreenFall, {}, [], [], !0);
function create_fragment$s(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feBlend"), dr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix1"), attr(fr, "mode", "lighten"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "colormatrix1"), attr(fr, "in2", "colormatrix1"), attr(fr, "result", "blend"), attr(dr, "mode", "multiply"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "colormatrix1"), attr(dr, "in2", "diffuseLighting"), attr(dr, "result", "blend1"), attr(cr, "id", "Noir"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noir"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar);
    }
  };
}
class Noir extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$s, safe_not_equal, {});
  }
}
create_custom_element(Noir, {}, [], [], !0);
function create_fragment$r(lr) {
  let ar, cr, ur, fr, dr, gr, mr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), fr = svg_element("feBlend"), dr = svg_element("feBlend"), gr = svg_element("feColorMatrix"), mr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix2"), attr(fr, "mode", "saturation"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "SourceGraphic"), attr(fr, "in2", "colormatrix2"), attr(fr, "result", "blend2"), attr(dr, "mode", "screen"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "colormatrix2"), attr(dr, "in2", "blend2"), attr(dr, "result", "blend3"), attr(gr, "type", "luminanceToAlpha"), attr(gr, "x", "0%"), attr(gr, "y", "0%"), attr(gr, "width", "100%"), attr(gr, "height", "100%"), attr(gr, "in", "blend3"), attr(gr, "result", "colormatrix3"), attr(mr, "mode", "exclusion"), attr(mr, "x", "0%"), attr(mr, "y", "0%"), attr(mr, "width", "100%"), attr(mr, "height", "100%"), attr(mr, "in", "blend3"), attr(mr, "in2", "colormatrix3"), attr(mr, "result", "blend5"), attr(cr, "id", "NoirLight"), attr(cr, "x", "-20%"), attr(cr, "y", "-20%"), attr(cr, "width", "140%"), attr(cr, "height", "140%"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noirlight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, gr), append(cr, mr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar);
    }
  };
}
class NoirLight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$r, safe_not_equal, {});
  }
}
create_custom_element(NoirLight, {}, [], [], !0);
function create_fragment$q(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 
					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 
					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  
					0 0 0 1 0`), attr(cr, "id", "Rustic"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-rustic"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Rustic extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$q, safe_not_equal, {});
  }
}
create_custom_element(Rustic, {}, [], [], !0);
function create_fragment$p(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.300 0.200 0.000 0.000 0.000 
					0.300 0.600 0.200 0.000 0.000 
					0.200 1.000 0.200 0.000 0.000 
					0.000 0.000 0.000 1.000 0.000`), attr(cr, "id", "Summer84"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-summer84"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Summer84 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$p, safe_not_equal, {});
  }
}
create_custom_element(Summer84, {}, [], [], !0);
function create_fragment$o(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.70 -0.20 0.00 0.00 0.00 
                    0.10 0.800 0.30 0.00 0.00 
                    0.20 0.300 0.50 0.00 0.00 
                    0.00 0.00 0.00 1.00 0.00`), attr(cr, "id", "XPro"), attr(cr, "filterUnits", "objectBoundingBox"), attr(cr, "primitiveUnits", "userSpaceOnUse"), attr(cr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-xpro"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class XPro extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$o, safe_not_equal, {});
  }
}
create_custom_element(XPro, {}, [], [], !0);
const ndkUser = writable(null), isNip05Valid = writable({
  isNip05Valid: null,
  Nip05address: void 0,
  UserNpub: void 0,
  Vanity: void 0,
  UserIdentifier: void 0
}), activeProfile = writable(null);
activeProfile.subscribe((lr) => {
  lr && activeProfile.set(lr);
});
const localStore = localStorageStore("localStore", {
  lastUserLogged: void 0,
  pk: void 0
}), themeModeLocalStorageObject = writable("colour-scheme"), theme = writable("light");
function create_fragment$n(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#4DA84D"), attr(ur, "d", "M12 16.2553L14.8661 19L19 12"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Positive extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$n, safe_not_equal, {});
  }
}
create_custom_element(Positive, {}, [], [], !0);
function create_fragment$m(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#42BDD8"), attr(ur, "d", "M12.8661 17H18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(fr, "d", "M12.8661 13H18.5"), attr(fr, "stroke", "white"), attr(fr, "stroke-width", "1.5"), attr(fr, "stroke-linecap", "round"), attr(fr, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, gr) {
      insert(dr, ar, gr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Neutral extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$m, safe_not_equal, {});
  }
}
create_custom_element(Neutral, {}, [], [], !0);
function create_fragment$l(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(cr, "fill", "#ED1B24"), attr(ur, "d", "M12 11.5L19 18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.3125"), attr(ur, "stroke-linecap", "round"), attr(fr, "d", "M19 11.5L12 18.5"), attr(fr, "stroke", "white"), attr(fr, "stroke-width", "1.3125"), attr(fr, "stroke-linecap", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, gr) {
      insert(dr, ar, gr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Negative extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$l, safe_not_equal, {});
  }
}
create_custom_element(Negative, {}, [], [], !0);
function number$6(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$5(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$6(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$6(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$6(lr.outputLen), number$6(lr.blockLen);
}
function exists$6(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$6(lr, ar) {
  bytes$6(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$6 = {
  number: number$6,
  bool: bool$5,
  bytes: bytes$6,
  hash: hash$6,
  exists: exists$6,
  output: output$6
}, crypto$6 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$8 = (lr) => lr instanceof Uint8Array, createView$5 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$5 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$6)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function utf8ToBytes$8(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$6(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$8(lr)), !u8a$8(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$7(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$8(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$5 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$5(lr) {
  const ar = (ur) => lr().update(toBytes$6(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$5(lr = 32) {
  if (crypto$6 && typeof crypto$6.getRandomValues == "function")
    return crypto$6.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$5(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
let SHA2$5 = class extends Hash$5 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$5(this.buffer);
  }
  update(ar) {
    assert$6.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$6(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView$5(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64$5(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView$5(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$6 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$5 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$5 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$5 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$5 = new Uint32Array(64);
let SHA256$5 = class extends SHA2$5 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$5[0] | 0, this.B = IV$5[1] | 0, this.C = IV$5[2] | 0, this.D = IV$5[3] | 0, this.E = IV$5[4] | 0, this.F = IV$5[5] | 0, this.G = IV$5[6] | 0, this.H = IV$5[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W$5[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W$5[_r - 15], Sr = SHA256_W$5[_r - 2], Er = rotr$5(xr, 7) ^ rotr$5(xr, 18) ^ xr >>> 3, Cr = rotr$5(Sr, 17) ^ rotr$5(Sr, 19) ^ Sr >>> 10;
      SHA256_W$5[_r] = Cr + SHA256_W$5[_r - 7] + Er + SHA256_W$5[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr$5(mr, 6) ^ rotr$5(mr, 11) ^ rotr$5(mr, 25), Sr = kr + xr + Chi$6(mr, vr, yr) + SHA256_K$5[_r] + SHA256_W$5[_r] | 0, Cr = (rotr$5(ur, 2) ^ rotr$5(ur, 13) ^ rotr$5(ur, 22)) + Maj$5(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W$5.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$3 = class extends SHA256$5 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$5 = wrapConstructor$5(() => new SHA256$5());
wrapConstructor$5(() => new SHA224$3());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$9 = BigInt(0), _1n$9 = BigInt(1), _2n$5 = BigInt(2), u8a$7 = (lr) => lr instanceof Uint8Array, hexes$5 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$5(lr) {
  if (!u8a$7(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$5[lr[cr]];
  return ar;
}
function numberToHexUnpadded$1(lr) {
  const ar = lr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber$1(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  return BigInt(lr === "" ? "0" : `0x${lr}`);
}
function hexToBytes$6(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function bytesToNumberBE$1(lr) {
  return hexToNumber$1(bytesToHex$5(lr));
}
function bytesToNumberLE$1(lr) {
  if (!u8a$7(lr))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$5(Uint8Array.from(lr).reverse()));
}
function numberToBytesBE$1(lr, ar) {
  return hexToBytes$6(lr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE$1(lr, ar) {
  return numberToBytesBE$1(lr, ar).reverse();
}
function numberToVarBytesBE$1(lr) {
  return hexToBytes$6(numberToHexUnpadded$1(lr));
}
function ensureBytes$2(lr, ar, cr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$6(ar);
    } catch (dr) {
      throw new Error(`${lr} must be valid hex string, got "${ar}". Cause: ${dr}`);
    }
  else if (u8a$7(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${lr} must be hex string or Uint8Array`);
  const fr = ur.length;
  if (typeof cr == "number" && fr !== cr)
    throw new Error(`${lr} expected ${cr} bytes, got ${fr}`);
  return ur;
}
function concatBytes$6(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$7(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
function equalBytes$2(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length; cr++)
    if (lr[cr] !== ar[cr])
      return !1;
  return !0;
}
function utf8ToBytes$7(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function bitLen$1(lr) {
  let ar;
  for (ar = 0; lr > _0n$9; lr >>= _1n$9, ar += 1)
    ;
  return ar;
}
function bitGet$1(lr, ar) {
  return lr >> BigInt(ar) & _1n$9;
}
const bitSet$1 = (lr, ar, cr) => lr | (cr ? _1n$9 : _0n$9) << BigInt(ar), bitMask$1 = (lr) => (_2n$5 << BigInt(lr - 1)) - _1n$9, u8n$1 = (lr) => new Uint8Array(lr), u8fr$1 = (lr) => Uint8Array.from(lr);
function createHmacDrbg$1(lr, ar, cr) {
  if (typeof lr != "number" || lr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof cr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n$1(lr), fr = u8n$1(lr), dr = 0;
  const gr = () => {
    ur.fill(1), fr.fill(0), dr = 0;
  }, mr = (..._r) => cr(fr, ur, ..._r), vr = (_r = u8n$1()) => {
    fr = mr(u8fr$1([0]), _r), ur = mr(), _r.length !== 0 && (fr = mr(u8fr$1([1]), _r), ur = mr());
  }, yr = () => {
    if (dr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let _r = 0;
    const xr = [];
    for (; _r < ar; ) {
      ur = mr();
      const Sr = ur.slice();
      xr.push(Sr), _r += ur.length;
    }
    return concatBytes$6(...xr);
  };
  return (_r, xr) => {
    gr(), vr(_r);
    let Sr;
    for (; !(Sr = xr(yr())); )
      vr();
    return gr(), Sr;
  };
}
const validatorFns$1 = {
  bigint: (lr) => typeof lr == "bigint",
  function: (lr) => typeof lr == "function",
  boolean: (lr) => typeof lr == "boolean",
  string: (lr) => typeof lr == "string",
  isSafeInteger: (lr) => Number.isSafeInteger(lr),
  array: (lr) => Array.isArray(lr),
  field: (lr, ar) => ar.Fp.isValid(lr),
  hash: (lr) => typeof lr == "function" && Number.isSafeInteger(lr.outputLen)
};
function validateObject$1(lr, ar, cr = {}) {
  const ur = (fr, dr, gr) => {
    const mr = validatorFns$1[dr];
    if (typeof mr != "function")
      throw new Error(`Invalid validator "${dr}", expected function`);
    const vr = lr[fr];
    if (!(gr && vr === void 0) && !mr(vr, lr))
      throw new Error(`Invalid param ${String(fr)}=${vr} (${typeof vr}), expected ${dr}`);
  };
  for (const [fr, dr] of Object.entries(ar))
    ur(fr, dr, !1);
  for (const [fr, dr] of Object.entries(cr))
    ur(fr, dr, !0);
  return lr;
}
const ut$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$5,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$6,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$2,
  equalBytes: equalBytes$2,
  hexToBytes: hexToBytes$6,
  hexToNumber: hexToNumber$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$7,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = BigInt(0), _1n$8 = BigInt(1), _2n$4 = BigInt(2), _3n$3 = BigInt(3), _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(lr, ar) {
  const cr = lr % ar;
  return cr >= _0n$8 ? cr : ar + cr;
}
function pow$1(lr, ar, cr) {
  if (cr <= _0n$8 || ar < _0n$8)
    throw new Error("Expected power/modulo > 0");
  if (cr === _1n$8)
    return _0n$8;
  let ur = _1n$8;
  for (; ar > _0n$8; )
    ar & _1n$8 && (ur = ur * lr % cr), lr = lr * lr % cr, ar >>= _1n$8;
  return ur;
}
function pow2$1(lr, ar, cr) {
  let ur = lr;
  for (; ar-- > _0n$8; )
    ur *= ur, ur %= cr;
  return ur;
}
function invert$1(lr, ar) {
  if (lr === _0n$8 || ar <= _0n$8)
    throw new Error(`invert: expected positive integers, got n=${lr} mod=${ar}`);
  let cr = mod$1(lr, ar), ur = ar, fr = _0n$8, dr = _1n$8;
  for (; cr !== _0n$8; ) {
    const mr = ur / cr, vr = ur % cr, yr = fr - dr * mr;
    ur = cr, cr = vr, fr = dr, dr = yr;
  }
  if (ur !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(fr, ar);
}
function tonelliShanks$1(lr) {
  const ar = (lr - _1n$8) / _2n$4;
  let cr, ur, fr;
  for (cr = lr - _1n$8, ur = 0; cr % _2n$4 === _0n$8; cr /= _2n$4, ur++)
    ;
  for (fr = _2n$4; fr < lr && pow$1(fr, ar, lr) !== lr - _1n$8; fr++)
    ;
  if (ur === 1) {
    const gr = (lr + _1n$8) / _4n$1;
    return function(vr, yr) {
      const kr = vr.pow(yr, gr);
      if (!vr.eql(vr.sqr(kr), yr))
        throw new Error("Cannot find square root");
      return kr;
    };
  }
  const dr = (cr + _1n$8) / _2n$4;
  return function(mr, vr) {
    if (mr.pow(vr, ar) === mr.neg(mr.ONE))
      throw new Error("Cannot find square root");
    let yr = ur, kr = mr.pow(mr.mul(mr.ONE, fr), cr), _r = mr.pow(vr, dr), xr = mr.pow(vr, cr);
    for (; !mr.eql(xr, mr.ONE); ) {
      if (mr.eql(xr, mr.ZERO))
        return mr.ZERO;
      let Sr = 1;
      for (let Cr = mr.sqr(xr); Sr < yr && !mr.eql(Cr, mr.ONE); Sr++)
        Cr = mr.sqr(Cr);
      const Er = mr.pow(kr, _1n$8 << BigInt(yr - Sr - 1));
      kr = mr.sqr(Er), _r = mr.mul(_r, Er), xr = mr.mul(xr, kr), yr = Sr;
    }
    return _r;
  };
}
function FpSqrt$1(lr) {
  if (lr % _4n$1 === _3n$3) {
    const ar = (lr + _1n$8) / _4n$1;
    return function(ur, fr) {
      const dr = ur.pow(fr, ar);
      if (!ur.eql(ur.sqr(dr), fr))
        throw new Error("Cannot find square root");
      return dr;
    };
  }
  if (lr % _8n$1 === _5n$1) {
    const ar = (lr - _5n$1) / _8n$1;
    return function(ur, fr) {
      const dr = ur.mul(fr, _2n$4), gr = ur.pow(dr, ar), mr = ur.mul(fr, gr), vr = ur.mul(ur.mul(mr, _2n$4), gr), yr = ur.mul(mr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(yr), fr))
        throw new Error("Cannot find square root");
      return yr;
    };
  }
  return tonelliShanks$1(lr);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(lr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, cr = FIELD_FIELDS$1.reduce((ur, fr) => (ur[fr] = "function", ur), ar);
  return validateObject$1(lr, cr);
}
function FpPow$1(lr, ar, cr) {
  if (cr < _0n$8)
    throw new Error("Expected power > 0");
  if (cr === _0n$8)
    return lr.ONE;
  if (cr === _1n$8)
    return ar;
  let ur = lr.ONE, fr = ar;
  for (; cr > _0n$8; )
    cr & _1n$8 && (ur = lr.mul(ur, fr)), fr = lr.sqr(fr), cr >>= _1n$8;
  return ur;
}
function FpInvertBatch$1(lr, ar) {
  const cr = new Array(ar.length), ur = ar.reduce((dr, gr, mr) => lr.is0(gr) ? dr : (cr[mr] = dr, lr.mul(dr, gr)), lr.ONE), fr = lr.inv(ur);
  return ar.reduceRight((dr, gr, mr) => lr.is0(gr) ? dr : (cr[mr] = lr.mul(dr, cr[mr]), lr.mul(dr, gr)), fr), cr;
}
function nLength$1(lr, ar) {
  const cr = ar !== void 0 ? ar : lr.toString(2).length, ur = Math.ceil(cr / 8);
  return { nBitLength: cr, nByteLength: ur };
}
function Field$1(lr, ar, cr = !1, ur = {}) {
  if (lr <= _0n$8)
    throw new Error(`Expected Fp ORDER > 0, got ${lr}`);
  const { nBitLength: fr, nByteLength: dr } = nLength$1(lr, ar);
  if (dr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const gr = FpSqrt$1(lr), mr = Object.freeze({
    ORDER: lr,
    BITS: fr,
    BYTES: dr,
    MASK: bitMask$1(fr),
    ZERO: _0n$8,
    ONE: _1n$8,
    create: (vr) => mod$1(vr, lr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$8 <= vr && vr < lr;
    },
    is0: (vr) => vr === _0n$8,
    isOdd: (vr) => (vr & _1n$8) === _1n$8,
    neg: (vr) => mod$1(-vr, lr),
    eql: (vr, yr) => vr === yr,
    sqr: (vr) => mod$1(vr * vr, lr),
    add: (vr, yr) => mod$1(vr + yr, lr),
    sub: (vr, yr) => mod$1(vr - yr, lr),
    mul: (vr, yr) => mod$1(vr * yr, lr),
    pow: (vr, yr) => FpPow$1(mr, vr, yr),
    div: (vr, yr) => mod$1(vr * invert$1(yr, lr), lr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, yr) => vr + yr,
    subN: (vr, yr) => vr - yr,
    mulN: (vr, yr) => vr * yr,
    inv: (vr) => invert$1(vr, lr),
    sqrt: ur.sqrt || ((vr) => gr(mr, vr)),
    invertBatch: (vr) => FpInvertBatch$1(mr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, yr, kr) => kr ? yr : vr,
    toBytes: (vr) => cr ? numberToBytesLE$1(vr, dr) : numberToBytesBE$1(vr, dr),
    fromBytes: (vr) => {
      if (vr.length !== dr)
        throw new Error(`Fp.fromBytes: expected ${dr}, got ${vr.length}`);
      return cr ? bytesToNumberLE$1(vr) : bytesToNumberBE$1(vr);
    }
  });
  return Object.freeze(mr);
}
function hashToPrivateScalar(lr, ar, cr = !1) {
  lr = ensureBytes$2("privateHash", lr);
  const ur = lr.length, fr = nLength$1(ar).nByteLength + 8;
  if (fr < 24 || ur < fr || ur > 1024)
    throw new Error(`hashToPrivateScalar: expected ${fr}-1024 bytes of input, got ${ur}`);
  const dr = cr ? bytesToNumberLE$1(lr) : bytesToNumberBE$1(lr);
  return mod$1(dr, ar - _1n$8) + _1n$8;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$7 = BigInt(1);
function wNAF$1(lr, ar) {
  const cr = (fr, dr) => {
    const gr = dr.negate();
    return fr ? gr : dr;
  }, ur = (fr) => {
    const dr = Math.ceil(ar / fr) + 1, gr = 2 ** (fr - 1);
    return { windows: dr, windowSize: gr };
  };
  return {
    constTimeNegate: cr,
    // non-const time multiplication ladder
    unsafeLadder(fr, dr) {
      let gr = lr.ZERO, mr = fr;
      for (; dr > _0n$7; )
        dr & _1n$7 && (gr = gr.add(mr)), mr = mr.double(), dr >>= _1n$7;
      return gr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(fr, dr) {
      const { windows: gr, windowSize: mr } = ur(dr), vr = [];
      let yr = fr, kr = yr;
      for (let _r = 0; _r < gr; _r++) {
        kr = yr, vr.push(kr);
        for (let xr = 1; xr < mr; xr++)
          kr = kr.add(yr), vr.push(kr);
        yr = kr.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(fr, dr, gr) {
      const { windows: mr, windowSize: vr } = ur(fr);
      let yr = lr.ZERO, kr = lr.BASE;
      const _r = BigInt(2 ** fr - 1), xr = 2 ** fr, Sr = BigInt(fr);
      for (let Er = 0; Er < mr; Er++) {
        const Cr = Er * vr;
        let Tr = Number(gr & _r);
        gr >>= Sr, Tr > vr && (Tr -= xr, gr += _1n$7);
        const Ar = Cr, Ir = Cr + Math.abs(Tr) - 1, Mr = Er % 2 !== 0, Hr = Tr < 0;
        Tr === 0 ? kr = kr.add(cr(Mr, dr[Ar])) : yr = yr.add(cr(Hr, dr[Ir]));
      }
      return { p: yr, f: kr };
    },
    wNAFCached(fr, dr, gr, mr) {
      const vr = fr._WINDOW_SIZE || 1;
      let yr = dr.get(fr);
      return yr || (yr = this.precomputeWindow(fr, vr), vr !== 1 && dr.set(fr, mr(yr))), this.wNAF(vr, yr, gr);
    }
  };
}
function validateBasic$1(lr) {
  return validateField$1(lr.Fp), validateObject$1(lr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength$1(lr.n, lr.nBitLength),
    ...lr,
    p: lr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(lr) {
  const ar = validateBasic$1(lr);
  validateObject$1(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: cr, Fp: ur, a: fr } = ar;
  if (cr) {
    if (!ur.eql(fr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof cr != "object" || typeof cr.beta != "bigint" || typeof cr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$2, DER$1 = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(lr) {
    const { Err: ar } = DER$1;
    if (lr.length < 2 || lr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const cr = lr[1], ur = lr.subarray(2, cr + 2);
    if (!cr || ur.length !== cr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(ur), l: lr.subarray(cr + 2) };
  },
  toSig(lr) {
    const { Err: ar } = DER$1, cr = typeof lr == "string" ? h2b$1(lr) : lr;
    if (!(cr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = cr.length;
    if (ur < 2 || cr[0] != 48)
      throw new ar("Invalid signature tag");
    if (cr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: fr, l: dr } = DER$1._parseInt(cr.subarray(2)), { d: gr, l: mr } = DER$1._parseInt(dr);
    if (mr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: fr, s: gr };
  },
  hexFromSig(lr) {
    const ar = (yr) => Number.parseInt(yr[0], 16) & 8 ? "00" + yr : yr, cr = (yr) => {
      const kr = yr.toString(16);
      return kr.length & 1 ? `0${kr}` : kr;
    }, ur = ar(cr(lr.s)), fr = ar(cr(lr.r)), dr = ur.length / 2, gr = fr.length / 2, mr = cr(dr), vr = cr(gr);
    return `30${cr(gr + dr + 4)}02${vr}${fr}02${mr}${ur}`;
  }
}, _0n$6 = BigInt(0), _1n$6 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(lr) {
  const ar = validatePointOpts$1(lr), { Fp: cr } = ar, ur = ar.toBytes || ((Er, Cr, Tr) => {
    const Ar = Cr.toAffine();
    return concatBytes$6(Uint8Array.from([4]), cr.toBytes(Ar.x), cr.toBytes(Ar.y));
  }), fr = ar.fromBytes || ((Er) => {
    const Cr = Er.subarray(1), Tr = cr.fromBytes(Cr.subarray(0, cr.BYTES)), Ar = cr.fromBytes(Cr.subarray(cr.BYTES, 2 * cr.BYTES));
    return { x: Tr, y: Ar };
  });
  function dr(Er) {
    const { a: Cr, b: Tr } = ar, Ar = cr.sqr(Er), Ir = cr.mul(Ar, Er);
    return cr.add(cr.add(Ir, cr.mul(Er, Cr)), Tr);
  }
  if (!cr.eql(cr.sqr(ar.Gy), dr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function gr(Er) {
    return typeof Er == "bigint" && _0n$6 < Er && Er < ar.n;
  }
  function mr(Er) {
    if (!gr(Er))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(Er) {
    const { allowedPrivateKeyLengths: Cr, nByteLength: Tr, wrapPrivateKey: Ar, n: Ir } = ar;
    if (Cr && typeof Er != "bigint") {
      if (Er instanceof Uint8Array && (Er = bytesToHex$5(Er)), typeof Er != "string" || !Cr.includes(Er.length))
        throw new Error("Invalid key");
      Er = Er.padStart(Tr * 2, "0");
    }
    let Mr;
    try {
      Mr = typeof Er == "bigint" ? Er : bytesToNumberBE$1(ensureBytes$2("private key", Er, Tr));
    } catch (Hr) {
      throw new Error(`private key must be ${Tr} bytes, hex or bigint, not ${typeof Er}`);
    }
    return Ar && (Mr = mod$1(Mr, Ir)), mr(Mr), Mr;
  }
  const yr = /* @__PURE__ */ new Map();
  function kr(Er) {
    if (!(Er instanceof _r))
      throw new Error("ProjectivePoint expected");
  }
  class _r {
    constructor(Cr, Tr, Ar) {
      if (this.px = Cr, this.py = Tr, this.pz = Ar, Cr == null || !cr.isValid(Cr))
        throw new Error("x required");
      if (Tr == null || !cr.isValid(Tr))
        throw new Error("y required");
      if (Ar == null || !cr.isValid(Ar))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Cr) {
      const { x: Tr, y: Ar } = Cr || {};
      if (!Cr || !cr.isValid(Tr) || !cr.isValid(Ar))
        throw new Error("invalid affine point");
      if (Cr instanceof _r)
        throw new Error("projective point not allowed");
      const Ir = (Mr) => cr.eql(Mr, cr.ZERO);
      return Ir(Tr) && Ir(Ar) ? _r.ZERO : new _r(Tr, Ar, cr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Cr) {
      const Tr = cr.invertBatch(Cr.map((Ar) => Ar.pz));
      return Cr.map((Ar, Ir) => Ar.toAffine(Tr[Ir])).map(_r.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Cr) {
      const Tr = _r.fromAffine(fr(ensureBytes$2("pointHex", Cr)));
      return Tr.assertValidity(), Tr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Cr) {
      return _r.BASE.multiply(vr(Cr));
    }
    // "Private method", don't use it directly
    _setWindowSize(Cr) {
      this._WINDOW_SIZE = Cr, yr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Cr, y: Tr } = this.toAffine();
      if (!cr.isValid(Cr) || !cr.isValid(Tr))
        throw new Error("bad point: x or y not FE");
      const Ar = cr.sqr(Tr), Ir = dr(Cr);
      if (!cr.eql(Ar, Ir))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Cr } = this.toAffine();
      if (cr.isOdd)
        return !cr.isOdd(Cr);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Cr) {
      kr(Cr);
      const { px: Tr, py: Ar, pz: Ir } = this, { px: Mr, py: Hr, pz: Br } = Cr, zr = cr.eql(cr.mul(Tr, Br), cr.mul(Mr, Ir)), Gr = cr.eql(cr.mul(Ar, Br), cr.mul(Hr, Ir));
      return zr && Gr;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new _r(this.px, cr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Cr, b: Tr } = ar, Ar = cr.mul(Tr, _3n$2), { px: Ir, py: Mr, pz: Hr } = this;
      let Br = cr.ZERO, zr = cr.ZERO, Gr = cr.ZERO, Xr = cr.mul(Ir, Ir), Jr = cr.mul(Mr, Mr), li = cr.mul(Hr, Hr), Qr = cr.mul(Ir, Mr);
      return Qr = cr.add(Qr, Qr), Gr = cr.mul(Ir, Hr), Gr = cr.add(Gr, Gr), Br = cr.mul(Cr, Gr), zr = cr.mul(Ar, li), zr = cr.add(Br, zr), Br = cr.sub(Jr, zr), zr = cr.add(Jr, zr), zr = cr.mul(Br, zr), Br = cr.mul(Qr, Br), Gr = cr.mul(Ar, Gr), li = cr.mul(Cr, li), Qr = cr.sub(Xr, li), Qr = cr.mul(Cr, Qr), Qr = cr.add(Qr, Gr), Gr = cr.add(Xr, Xr), Xr = cr.add(Gr, Xr), Xr = cr.add(Xr, li), Xr = cr.mul(Xr, Qr), zr = cr.add(zr, Xr), li = cr.mul(Mr, Hr), li = cr.add(li, li), Xr = cr.mul(li, Qr), Br = cr.sub(Br, Xr), Gr = cr.mul(li, Jr), Gr = cr.add(Gr, Gr), Gr = cr.add(Gr, Gr), new _r(Br, zr, Gr);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Cr) {
      kr(Cr);
      const { px: Tr, py: Ar, pz: Ir } = this, { px: Mr, py: Hr, pz: Br } = Cr;
      let zr = cr.ZERO, Gr = cr.ZERO, Xr = cr.ZERO;
      const Jr = ar.a, li = cr.mul(ar.b, _3n$2);
      let Qr = cr.mul(Tr, Mr), ei = cr.mul(Ar, Hr), ui = cr.mul(Ir, Br), Ai = cr.add(Tr, Ar), fi = cr.add(Mr, Hr);
      Ai = cr.mul(Ai, fi), fi = cr.add(Qr, ei), Ai = cr.sub(Ai, fi), fi = cr.add(Tr, Ir);
      let gi = cr.add(Mr, Br);
      return fi = cr.mul(fi, gi), gi = cr.add(Qr, ui), fi = cr.sub(fi, gi), gi = cr.add(Ar, Ir), zr = cr.add(Hr, Br), gi = cr.mul(gi, zr), zr = cr.add(ei, ui), gi = cr.sub(gi, zr), Xr = cr.mul(Jr, fi), zr = cr.mul(li, ui), Xr = cr.add(zr, Xr), zr = cr.sub(ei, Xr), Xr = cr.add(ei, Xr), Gr = cr.mul(zr, Xr), ei = cr.add(Qr, Qr), ei = cr.add(ei, Qr), ui = cr.mul(Jr, ui), fi = cr.mul(li, fi), ei = cr.add(ei, ui), ui = cr.sub(Qr, ui), ui = cr.mul(Jr, ui), fi = cr.add(fi, ui), Qr = cr.mul(ei, fi), Gr = cr.add(Gr, Qr), Qr = cr.mul(gi, fi), zr = cr.mul(Ai, zr), zr = cr.sub(zr, Qr), Qr = cr.mul(Ai, ei), Xr = cr.mul(gi, Xr), Xr = cr.add(Xr, Qr), new _r(zr, Gr, Xr);
    }
    subtract(Cr) {
      return this.add(Cr.negate());
    }
    is0() {
      return this.equals(_r.ZERO);
    }
    wNAF(Cr) {
      return Sr.wNAFCached(this, yr, Cr, (Tr) => {
        const Ar = cr.invertBatch(Tr.map((Ir) => Ir.pz));
        return Tr.map((Ir, Mr) => Ir.toAffine(Ar[Mr])).map(_r.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Cr) {
      const Tr = _r.ZERO;
      if (Cr === _0n$6)
        return Tr;
      if (mr(Cr), Cr === _1n$6)
        return this;
      const { endo: Ar } = ar;
      if (!Ar)
        return Sr.unsafeLadder(this, Cr);
      let { k1neg: Ir, k1: Mr, k2neg: Hr, k2: Br } = Ar.splitScalar(Cr), zr = Tr, Gr = Tr, Xr = this;
      for (; Mr > _0n$6 || Br > _0n$6; )
        Mr & _1n$6 && (zr = zr.add(Xr)), Br & _1n$6 && (Gr = Gr.add(Xr)), Xr = Xr.double(), Mr >>= _1n$6, Br >>= _1n$6;
      return Ir && (zr = zr.negate()), Hr && (Gr = Gr.negate()), Gr = new _r(cr.mul(Gr.px, Ar.beta), Gr.py, Gr.pz), zr.add(Gr);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Cr) {
      mr(Cr);
      let Tr = Cr, Ar, Ir;
      const { endo: Mr } = ar;
      if (Mr) {
        const { k1neg: Hr, k1: Br, k2neg: zr, k2: Gr } = Mr.splitScalar(Tr);
        let { p: Xr, f: Jr } = this.wNAF(Br), { p: li, f: Qr } = this.wNAF(Gr);
        Xr = Sr.constTimeNegate(Hr, Xr), li = Sr.constTimeNegate(zr, li), li = new _r(cr.mul(li.px, Mr.beta), li.py, li.pz), Ar = Xr.add(li), Ir = Jr.add(Qr);
      } else {
        const { p: Hr, f: Br } = this.wNAF(Tr);
        Ar = Hr, Ir = Br;
      }
      return _r.normalizeZ([Ar, Ir])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Cr, Tr, Ar) {
      const Ir = _r.BASE, Mr = (Br, zr) => zr === _0n$6 || zr === _1n$6 || !Br.equals(Ir) ? Br.multiplyUnsafe(zr) : Br.multiply(zr), Hr = Mr(this, Tr).add(Mr(Cr, Ar));
      return Hr.is0() ? void 0 : Hr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(Cr) {
      const { px: Tr, py: Ar, pz: Ir } = this, Mr = this.is0();
      Cr == null && (Cr = Mr ? cr.ONE : cr.inv(Ir));
      const Hr = cr.mul(Tr, Cr), Br = cr.mul(Ar, Cr), zr = cr.mul(Ir, Cr);
      if (Mr)
        return { x: cr.ZERO, y: cr.ZERO };
      if (!cr.eql(zr, cr.ONE))
        throw new Error("invZ was invalid");
      return { x: Hr, y: Br };
    }
    isTorsionFree() {
      const { h: Cr, isTorsionFree: Tr } = ar;
      if (Cr === _1n$6)
        return !0;
      if (Tr)
        return Tr(_r, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Cr, clearCofactor: Tr } = ar;
      return Cr === _1n$6 ? this : Tr ? Tr(_r, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Cr = !0) {
      return this.assertValidity(), ur(_r, this, Cr);
    }
    toHex(Cr = !0) {
      return bytesToHex$5(this.toRawBytes(Cr));
    }
  }
  _r.BASE = new _r(ar.Gx, ar.Gy, cr.ONE), _r.ZERO = new _r(cr.ZERO, cr.ONE, cr.ZERO);
  const xr = ar.nBitLength, Sr = wNAF$1(_r, ar.endo ? Math.ceil(xr / 2) : xr);
  return {
    CURVE: ar,
    ProjectivePoint: _r,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: dr,
    isWithinCurveOrder: gr
  };
}
function validateOpts$1(lr) {
  const ar = validateBasic$1(lr);
  return validateObject$1(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass$1(lr) {
  const ar = validateOpts$1(lr), { Fp: cr, n: ur } = ar, fr = cr.BYTES + 1, dr = 2 * cr.BYTES + 1;
  function gr(fi) {
    return _0n$6 < fi && fi < cr.ORDER;
  }
  function mr(fi) {
    return mod$1(fi, ur);
  }
  function vr(fi) {
    return invert$1(fi, ur);
  }
  const { ProjectivePoint: yr, normPrivateKeyToScalar: kr, weierstrassEquation: _r, isWithinCurveOrder: xr } = weierstrassPoints$1({
    ...ar,
    toBytes(fi, gi, Ci) {
      const mi = gi.toAffine(), vi = cr.toBytes(mi.x), Ri = concatBytes$6;
      return Ci ? Ri(Uint8Array.from([gi.hasEvenY() ? 2 : 3]), vi) : Ri(Uint8Array.from([4]), vi, cr.toBytes(mi.y));
    },
    fromBytes(fi) {
      const gi = fi.length, Ci = fi[0], mi = fi.subarray(1);
      if (gi === fr && (Ci === 2 || Ci === 3)) {
        const vi = bytesToNumberBE$1(mi);
        if (!gr(vi))
          throw new Error("Point is not on curve");
        const Ri = _r(vi);
        let di = cr.sqrt(Ri);
        const Ti = (di & _1n$6) === _1n$6;
        return (Ci & 1) === 1 !== Ti && (di = cr.neg(di)), { x: vi, y: di };
      } else if (gi === dr && Ci === 4) {
        const vi = cr.fromBytes(mi.subarray(0, cr.BYTES)), Ri = cr.fromBytes(mi.subarray(cr.BYTES, 2 * cr.BYTES));
        return { x: vi, y: Ri };
      } else
        throw new Error(`Point of length ${gi} was invalid. Expected ${fr} compressed bytes or ${dr} uncompressed bytes`);
    }
  }), Sr = (fi) => bytesToHex$5(numberToBytesBE$1(fi, ar.nByteLength));
  function Er(fi) {
    const gi = ur >> _1n$6;
    return fi > gi;
  }
  function Cr(fi) {
    return Er(fi) ? mr(-fi) : fi;
  }
  const Tr = (fi, gi, Ci) => bytesToNumberBE$1(fi.slice(gi, Ci));
  class Ar {
    constructor(gi, Ci, mi) {
      this.r = gi, this.s = Ci, this.recovery = mi, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(gi) {
      const Ci = ar.nByteLength;
      return gi = ensureBytes$2("compactSignature", gi, Ci * 2), new Ar(Tr(gi, 0, Ci), Tr(gi, Ci, 2 * Ci));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(gi) {
      const { r: Ci, s: mi } = DER$1.toSig(ensureBytes$2("DER", gi));
      return new Ar(Ci, mi);
    }
    assertValidity() {
      if (!xr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!xr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(gi) {
      return new Ar(this.r, this.s, gi);
    }
    recoverPublicKey(gi) {
      const { r: Ci, s: mi, recovery: vi } = this, Ri = Gr(ensureBytes$2("msgHash", gi));
      if (vi == null || ![0, 1, 2, 3].includes(vi))
        throw new Error("recovery id invalid");
      const di = vi === 2 || vi === 3 ? Ci + ar.n : Ci;
      if (di >= cr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ti = vi & 1 ? "03" : "02", qi = yr.fromHex(Ti + Sr(di)), ki = vr(di), Ji = mr(-Ri * ki), Bi = mr(mi * ki), Ni = yr.BASE.multiplyAndAddUnsafe(qi, Ji, Bi);
      if (!Ni)
        throw new Error("point at infinify");
      return Ni.assertValidity(), Ni;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return Er(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ar(this.r, mr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$6(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$6(this.toCompactHex());
    }
    toCompactHex() {
      return Sr(this.r) + Sr(this.s);
    }
  }
  const Ir = {
    isValidPrivateKey(fi) {
      try {
        return kr(fi), !0;
      } catch (gi) {
        return !1;
      }
    },
    normPrivateKeyToScalar: kr,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const fi = ar.randomBytes(cr.BYTES + 8), gi = hashToPrivateScalar(fi, ur);
      return numberToBytesBE$1(gi, ar.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(fi = 8, gi = yr.BASE) {
      return gi._setWindowSize(fi), gi.multiply(BigInt(3)), gi;
    }
  };
  function Mr(fi, gi = !0) {
    return yr.fromPrivateKey(fi).toRawBytes(gi);
  }
  function Hr(fi) {
    const gi = fi instanceof Uint8Array, Ci = typeof fi == "string", mi = (gi || Ci) && fi.length;
    return gi ? mi === fr || mi === dr : Ci ? mi === 2 * fr || mi === 2 * dr : fi instanceof yr;
  }
  function Br(fi, gi, Ci = !0) {
    if (Hr(fi))
      throw new Error("first arg must be private key");
    if (!Hr(gi))
      throw new Error("second arg must be public key");
    return yr.fromHex(gi).multiply(kr(fi)).toRawBytes(Ci);
  }
  const zr = ar.bits2int || function(fi) {
    const gi = bytesToNumberBE$1(fi), Ci = fi.length * 8 - ar.nBitLength;
    return Ci > 0 ? gi >> BigInt(Ci) : gi;
  }, Gr = ar.bits2int_modN || function(fi) {
    return mr(zr(fi));
  }, Xr = bitMask$1(ar.nBitLength);
  function Jr(fi) {
    if (typeof fi != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$6 <= fi && fi < Xr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE$1(fi, ar.nByteLength);
  }
  function li(fi, gi, Ci = Qr) {
    if (["recovered", "canonical"].some((bi) => bi in Ci))
      throw new Error("sign() legacy options not supported");
    const { hash: mi, randomBytes: vi } = ar;
    let { lowS: Ri, prehash: di, extraEntropy: Ti } = Ci;
    Ri == null && (Ri = !0), fi = ensureBytes$2("msgHash", fi), di && (fi = ensureBytes$2("prehashed msgHash", mi(fi)));
    const qi = Gr(fi), ki = kr(gi), Ji = [Jr(ki), Jr(qi)];
    if (Ti != null) {
      const bi = Ti === !0 ? vi(cr.BYTES) : Ti;
      Ji.push(ensureBytes$2("extraEntropy", bi, cr.BYTES));
    }
    const Bi = concatBytes$6(...Ji), Ni = qi;
    function Mi(bi) {
      const Ei = zr(bi);
      if (!xr(Ei))
        return;
      const Si = vr(Ei), Vi = yr.BASE.multiply(Ei).toAffine(), Di = mr(Vi.x);
      if (Di === _0n$6)
        return;
      const sa = mr(Si * mr(Ni + Di * ki));
      if (sa === _0n$6)
        return;
      let ra = (Vi.x === Di ? 0 : 2) | Number(Vi.y & _1n$6), fa = sa;
      return Ri && Er(sa) && (fa = Cr(sa), ra ^= 1), new Ar(Di, fa, ra);
    }
    return { seed: Bi, k2sig: Mi };
  }
  const Qr = { lowS: ar.lowS, prehash: !1 }, ei = { lowS: ar.lowS, prehash: !1 };
  function ui(fi, gi, Ci = Qr) {
    const { seed: mi, k2sig: vi } = li(fi, gi, Ci), Ri = ar;
    return createHmacDrbg$1(Ri.hash.outputLen, Ri.nByteLength, Ri.hmac)(mi, vi);
  }
  yr.BASE._setWindowSize(8);
  function Ai(fi, gi, Ci, mi = ei) {
    var Vi;
    const vi = fi;
    if (gi = ensureBytes$2("msgHash", gi), Ci = ensureBytes$2("publicKey", Ci), "strict" in mi)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Ri, prehash: di } = mi;
    let Ti, qi;
    try {
      if (typeof vi == "string" || vi instanceof Uint8Array)
        try {
          Ti = Ar.fromDER(vi);
        } catch (Di) {
          if (!(Di instanceof DER$1.Err))
            throw Di;
          Ti = Ar.fromCompact(vi);
        }
      else if (typeof vi == "object" && typeof vi.r == "bigint" && typeof vi.s == "bigint") {
        const { r: Di, s: sa } = vi;
        Ti = new Ar(Di, sa);
      } else
        throw new Error("PARSE");
      qi = yr.fromHex(Ci);
    } catch (Di) {
      if (Di.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Ri && Ti.hasHighS())
      return !1;
    di && (gi = ar.hash(gi));
    const { r: ki, s: Ji } = Ti, Bi = Gr(gi), Ni = vr(Ji), Mi = mr(Bi * Ni), bi = mr(ki * Ni), Ei = (Vi = yr.BASE.multiplyAndAddUnsafe(qi, Mi, bi)) == null ? void 0 : Vi.toAffine();
    return Ei ? mr(Ei.x) === ki : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Mr,
    getSharedSecret: Br,
    sign: ui,
    verify: Ai,
    ProjectivePoint: yr,
    Signature: Ar,
    utils: Ir
  };
}
let HMAC$5 = class extends Hash$5 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$6.hash(ar);
    const ur = toBytes$6(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$6.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$5 = (lr, ar, cr) => new HMAC$5(lr, ar).update(cr).digest();
hmac$5.create = (lr, ar) => new HMAC$5(lr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(lr) {
  return {
    hash: lr,
    hmac: (ar, ...cr) => hmac$5(lr, ar, concatBytes$7(...cr)),
    randomBytes: randomBytes$5
  };
}
function createCurve$1(lr, ar) {
  const cr = (ur) => weierstrass$1({ ...lr, ...getHash$1(ur) });
  return Object.freeze({ ...cr(ar), create: cr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$5 = BigInt(1), _2n$3 = BigInt(2), divNearest$1 = (lr, ar) => (lr + ar / _2n$3) / ar;
function sqrtMod$1(lr) {
  const ar = secp256k1P$1, cr = BigInt(3), ur = BigInt(6), fr = BigInt(11), dr = BigInt(22), gr = BigInt(23), mr = BigInt(44), vr = BigInt(88), yr = lr * lr * lr % ar, kr = yr * yr * lr % ar, _r = pow2$1(kr, cr, ar) * kr % ar, xr = pow2$1(_r, cr, ar) * kr % ar, Sr = pow2$1(xr, _2n$3, ar) * yr % ar, Er = pow2$1(Sr, fr, ar) * Sr % ar, Cr = pow2$1(Er, dr, ar) * Er % ar, Tr = pow2$1(Cr, mr, ar) * Cr % ar, Ar = pow2$1(Tr, vr, ar) * Tr % ar, Ir = pow2$1(Ar, mr, ar) * Cr % ar, Mr = pow2$1(Ir, cr, ar) * kr % ar, Hr = pow2$1(Mr, gr, ar) * Er % ar, Br = pow2$1(Hr, ur, ar) * yr % ar, zr = pow2$1(Br, _2n$3, ar);
  if (!Fp$1.eql(Fp$1.sqr(zr), lr))
    throw new Error("Cannot find square root");
  return zr;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 }), secp256k1$1 = createCurve$1({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (lr) => {
      const ar = secp256k1N$1, cr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n$5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), fr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), dr = cr, gr = BigInt("0x100000000000000000000000000000000"), mr = divNearest$1(dr * lr, ar), vr = divNearest$1(-ur * lr, ar);
      let yr = mod$1(lr - mr * cr - vr * fr, ar), kr = mod$1(-mr * ur - vr * dr, ar);
      const _r = yr > gr, xr = kr > gr;
      if (_r && (yr = ar - yr), xr && (kr = ar - kr), yr > gr || kr > gr)
        throw new Error("splitScalar: Endomorphism failed, k=" + lr);
      return { k1neg: _r, k1: yr, k2neg: xr, k2: kr };
    }
  }
}, sha256$5), _0n$5 = BigInt(0), fe$2 = (lr) => typeof lr == "bigint" && _0n$5 < lr && lr < secp256k1P$1, ge$3 = (lr) => typeof lr == "bigint" && _0n$5 < lr && lr < secp256k1N$1, TAGGED_HASH_PREFIXES$1 = {};
function taggedHash$1(lr, ...ar) {
  let cr = TAGGED_HASH_PREFIXES$1[lr];
  if (cr === void 0) {
    const ur = sha256$5(Uint8Array.from(lr, (fr) => fr.charCodeAt(0)));
    cr = concatBytes$6(ur, ur), TAGGED_HASH_PREFIXES$1[lr] = cr;
  }
  return sha256$5(concatBytes$6(cr, ...ar));
}
const pointToBytes$1 = (lr) => lr.toRawBytes(!0).slice(1), numTo32b$1 = (lr) => numberToBytesBE$1(lr, 32), modP$1 = (lr) => mod$1(lr, secp256k1P$1), modN$1 = (lr) => mod$1(lr, secp256k1N$1), Point$2 = secp256k1$1.ProjectivePoint, GmulAdd$1 = (lr, ar, cr) => Point$2.BASE.multiplyAndAddUnsafe(lr, ar, cr);
function schnorrGetExtPubKey$1(lr) {
  let ar = secp256k1$1.utils.normPrivateKeyToScalar(lr), cr = Point$2.fromPrivateKey(ar);
  return { scalar: cr.hasEvenY() ? ar : modN$1(-ar), bytes: pointToBytes$1(cr) };
}
function lift_x$1(lr) {
  if (!fe$2(lr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP$1(lr * lr), cr = modP$1(ar * lr + BigInt(7));
  let ur = sqrtMod$1(cr);
  ur % _2n$3 !== _0n$5 && (ur = modP$1(-ur));
  const fr = new Point$2(lr, ur, _1n$5);
  return fr.assertValidity(), fr;
}
function challenge$1(...lr) {
  return modN$1(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge", ...lr)));
}
function schnorrGetPublicKey$1(lr) {
  return schnorrGetExtPubKey$1(lr).bytes;
}
function schnorrSign$1(lr, ar, cr = randomBytes$5(32)) {
  const ur = ensureBytes$2("message", lr), { bytes: fr, scalar: dr } = schnorrGetExtPubKey$1(ar), gr = ensureBytes$2("auxRand", cr, 32), mr = numTo32b$1(dr ^ bytesToNumberBE$1(taggedHash$1("BIP0340/aux", gr))), vr = taggedHash$1("BIP0340/nonce", mr, fr, ur), yr = modN$1(bytesToNumberBE$1(vr));
  if (yr === _0n$5)
    throw new Error("sign failed: k is zero");
  const { bytes: kr, scalar: _r } = schnorrGetExtPubKey$1(yr), xr = challenge$1(kr, fr, ur), Sr = new Uint8Array(64);
  if (Sr.set(kr, 0), Sr.set(numTo32b$1(modN$1(_r + xr * dr)), 32), !schnorrVerify$1(Sr, ur, fr))
    throw new Error("sign: Invalid signature produced");
  return Sr;
}
function schnorrVerify$1(lr, ar, cr) {
  const ur = ensureBytes$2("signature", lr, 64), fr = ensureBytes$2("message", ar), dr = ensureBytes$2("publicKey", cr, 32);
  try {
    const gr = lift_x$1(bytesToNumberBE$1(dr)), mr = bytesToNumberBE$1(ur.subarray(0, 32));
    if (!fe$2(mr))
      return !1;
    const vr = bytesToNumberBE$1(ur.subarray(32, 64));
    if (!ge$3(vr))
      return !1;
    const yr = challenge$1(numTo32b$1(mr), pointToBytes$1(gr), fr), kr = GmulAdd$1(gr, vr, modN$1(-yr));
    return !(!kr || !kr.hasEvenY() || kr.toAffine().x !== mr);
  } catch (gr) {
    return !1;
  }
}
const schnorr$1 = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey$1,
  sign: schnorrSign$1,
  verify: schnorrVerify$1,
  utils: {
    randomPrivateKey: secp256k1$1.utils.randomPrivateKey,
    lift_x: lift_x$1,
    pointToBytes: pointToBytes$1,
    numberToBytesBE: numberToBytesBE$1,
    bytesToNumberBE: bytesToNumberBE$1,
    taggedHash: taggedHash$1,
    mod: mod$1
  }
}))(), crypto$5 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$6 = (lr) => lr instanceof Uint8Array, createView$4 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$4 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$5)
  throw new Error("Non little-endian hardware is not supported");
const hexes$4 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$4(lr) {
  if (!u8a$6(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$4[lr[cr]];
  return ar;
}
function hexToBytes$5(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function utf8ToBytes$6(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$5(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$6(lr)), !u8a$6(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$5(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$6(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$4 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$4(lr) {
  const ar = (ur) => lr().update(toBytes$5(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$4(lr = 32) {
  if (crypto$5 && typeof crypto$5.getRandomValues == "function")
    return crypto$5.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$5(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$4(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$5(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$5(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$5(lr.outputLen), number$5(lr.blockLen);
}
function exists$5(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$5(lr, ar) {
  bytes$5(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$5 = {
  number: number$5,
  bool: bool$4,
  bytes: bytes$5,
  hash: hash$5,
  exists: exists$5,
  output: output$5
};
function setBigUint64$4(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
let SHA2$4 = class extends Hash$4 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$4(this.buffer);
  }
  update(ar) {
    assert$5.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$5(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView$4(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64$4(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView$4(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$5 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$4 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$4 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$4 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$4 = new Uint32Array(64);
let SHA256$4 = class extends SHA2$4 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$4[0] | 0, this.B = IV$4[1] | 0, this.C = IV$4[2] | 0, this.D = IV$4[3] | 0, this.E = IV$4[4] | 0, this.F = IV$4[5] | 0, this.G = IV$4[6] | 0, this.H = IV$4[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W$4[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W$4[_r - 15], Sr = SHA256_W$4[_r - 2], Er = rotr$4(xr, 7) ^ rotr$4(xr, 18) ^ xr >>> 3, Cr = rotr$4(Sr, 17) ^ rotr$4(Sr, 19) ^ Sr >>> 10;
      SHA256_W$4[_r] = Cr + SHA256_W$4[_r - 7] + Er + SHA256_W$4[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr$4(mr, 6) ^ rotr$4(mr, 11) ^ rotr$4(mr, 25), Sr = kr + xr + Chi$5(mr, vr, yr) + SHA256_K$4[_r] + SHA256_W$4[_r] | 0, Cr = (rotr$4(ur, 2) ^ rotr$4(ur, 13) ^ rotr$4(ur, 22)) + Maj$4(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W$4.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$2 = class extends SHA256$4 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$4 = wrapConstructor$4(() => new SHA256$4());
wrapConstructor$4(() => new SHA224$2());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$2(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain$3(...lr) {
  const ar = (fr, dr) => (gr) => fr(dr(gr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet$3(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber$2(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$4(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding$3(lr, ar = "=") {
  if (assertNumber$2(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize$3(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix$3(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((gr) => {
    if (assertNumber$2(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const yr = dr[vr], kr = ar * gr + yr;
      if (!Number.isSafeInteger(kr) || ar * gr / ar !== gr || kr - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = kr % cr, dr[vr] = Math.floor(kr / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + gr !== kr)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        dr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < lr.length - 1 && lr[gr] === 0; gr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$3 = (lr, ar) => ar ? gcd$3(ar, lr % ar) : lr, radix2carry$3 = (lr, ar) => lr + (ar - gcd$3(lr, ar));
function convertRadix2$3(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry$3(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry$3(ar, cr)}`);
  let fr = 0, dr = 0;
  const gr = 2 ** cr - 1, mr = [];
  for (const vr of lr) {
    if (assertNumber$2(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      mr.push((fr >> dr - cr & gr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & gr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && mr.push(fr >>> 0), mr;
}
function radix$3(lr) {
  return assertNumber$2(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$3(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$3(ar, lr, 2 ** 8));
    }
  };
}
function radix2$3(lr, ar = !1) {
  if (assertNumber$2(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$3(8, lr) > 32 || radix2carry$3(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$3(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$3(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper$2(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16$2 = chain$3(radix2$3(4), alphabet$3("0123456789ABCDEF"), join$4("")), base32$2 = chain$3(radix2$3(5), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$4(""), normalize$3((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$3(6), join$4("")), base64url$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$3(6), join$4("")), genBase58$3 = (lr) => chain$3(radix$3(58), alphabet$3(lr), join$4("")), base58$3 = genBase58$3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$2 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$2 = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58$3.encode(ur).padStart(XMR_BLOCK_LEN$2[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN$2.indexOf(ur.length), dr = base58$3.decode(ur);
      for (let gr = 0; gr < dr.length - fr; gr++)
        if (dr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$2 = chain$3(alphabet$3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$4("")), POLYMOD_GENERATORS$2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$2(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$2.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS$2[ur]);
  return cr;
}
function bechChecksum$2(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const gr = lr.charCodeAt(dr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod$2(fr) ^ gr >> 5;
  }
  fr = bech32Polymod$2(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod$2(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod$2(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod$2(fr);
  return fr ^= cr, BECH_ALPHABET$2.encode(convertRadix2$3([fr % 2 ** 30], 30, 5, !1));
}
function genBech32$2(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2$3(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper$2(ur);
  function gr(kr, _r, xr = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof kr}`);
    if (!Array.isArray(_r) || _r.length && typeof _r[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof _r}`);
    const Sr = kr.length + 7 + _r.length;
    if (xr !== !1 && Sr > xr)
      throw new TypeError(`Length ${Sr} exceeds limit ${xr}`);
    return kr = kr.toLowerCase(), `${kr}1${BECH_ALPHABET$2.encode(_r)}${bechChecksum$2(kr, _r, ar)}`;
  }
  function mr(kr, _r = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof kr}`);
    if (kr.length < 8 || _r !== !1 && kr.length > _r)
      throw new TypeError(`Wrong string length: ${kr.length} (${kr}). Expected (8..${_r})`);
    const xr = kr.toLowerCase();
    if (kr !== xr && kr !== kr.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    kr = xr;
    const Sr = kr.lastIndexOf("1");
    if (Sr === 0 || Sr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = kr.slice(0, Sr), Cr = kr.slice(Sr + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET$2.decode(Cr).slice(0, -6), Ar = bechChecksum$2(Er, Tr, ar);
    if (!Cr.endsWith(Ar))
      throw new Error(`Invalid checksum in ${kr}: expected "${Ar}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper$2(mr);
  function yr(kr) {
    const { prefix: _r, words: xr } = mr(kr, !1);
    return { prefix: _r, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32$3 = genBech32$2("bech32");
genBech32$2("bech32m");
const utf8$2 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex$2 = chain$3(radix2$3(4), alphabet$3("0123456789abcdef"), join$4(""), normalize$3((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS$2 = {
  utf8: utf8$2,
  hex: hex$2,
  base16: base16$2,
  base32: base32$2,
  base64: base64$2,
  base64url: base64url$2,
  base58: base58$3,
  base58xmr: base58xmr$2
};
`${Object.keys(CODERS$2).join(", ")}`;
const wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split(`
`);
function number$4(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$3(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$4(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$4(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$4(lr.outputLen), number$4(lr.blockLen);
}
function exists$4(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$4(lr, ar) {
  bytes$4(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$3 = { number: number$4, bool: bool$3, bytes: bytes$4, hash: hash$4, exists: exists$4, output: output$4 }, assert$4 = assert$3, crypto$4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$5 = (lr) => lr instanceof Uint8Array, createView$3 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$3 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$4)
  throw new Error("Non little-endian hardware is not supported");
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$3(lr) {
  if (!u8a$5(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$3[lr[cr]];
  return ar;
}
function hexToBytes$4(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function utf8ToBytes$5(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$4(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$5(lr)), !u8a$5(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$4(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$5(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts$1(lr, ar) {
  if (ar !== void 0 && toStr.call(ar) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(lr, ar);
}
function wrapConstructor$3(lr) {
  const ar = (ur) => lr().update(toBytes$4(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$3(lr = 32) {
  if (crypto$4 && typeof crypto$4.getRandomValues == "function")
    return crypto$4.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$4 = class extends Hash$3 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, hash$4(ar);
    const ur = toBytes$4(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return exists$4(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$4(this), bytes$4(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$4 = (lr, ar, cr) => new HMAC$4(lr, ar).update(cr).digest();
hmac$4.create = (lr, ar) => new HMAC$4(lr, ar);
function pbkdf2Init(lr, ar, cr, ur) {
  hash$4(lr);
  const fr = checkOpts$1({ dkLen: 32, asyncTick: 10 }, ur), { c: dr, dkLen: gr, asyncTick: mr } = fr;
  if (number$4(dr), number$4(gr), number$4(mr), dr < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const vr = toBytes$4(ar), yr = toBytes$4(cr), kr = new Uint8Array(gr), _r = hmac$4.create(lr, vr), xr = _r._cloneInto().update(yr);
  return { c: dr, dkLen: gr, asyncTick: mr, DK: kr, PRF: _r, PRFSalt: xr };
}
function pbkdf2Output(lr, ar, cr, ur, fr) {
  return lr.destroy(), ar.destroy(), ur && ur.destroy(), fr.fill(0), cr;
}
function pbkdf2(lr, ar, cr, ur) {
  const { c: fr, dkLen: dr, DK: gr, PRF: mr, PRFSalt: vr } = pbkdf2Init(lr, ar, cr, ur);
  let yr;
  const kr = new Uint8Array(4), _r = createView$3(kr), xr = new Uint8Array(mr.outputLen);
  for (let Sr = 1, Er = 0; Er < dr; Sr++, Er += mr.outputLen) {
    const Cr = gr.subarray(Er, Er + mr.outputLen);
    _r.setInt32(0, Sr, !1), (yr = vr._cloneInto(yr)).update(kr).digestInto(xr), Cr.set(xr.subarray(0, Cr.length));
    for (let Tr = 1; Tr < fr; Tr++) {
      mr._cloneInto(yr).update(xr).digestInto(xr);
      for (let Ar = 0; Ar < Cr.length; Ar++)
        Cr[Ar] ^= xr[Ar];
    }
  }
  return pbkdf2Output(mr, vr, gr, yr, xr);
}
function setBigUint64$3(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
let SHA2$3 = class extends Hash$3 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$3(this.buffer);
  }
  update(ar) {
    exists$4(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$4(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView$3(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$4(this), output$4(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64$3(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView$3(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$4 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$3 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$3 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$3 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$3 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$3 = class extends SHA2$3 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$3[0] | 0, this.B = IV$3[1] | 0, this.C = IV$3[2] | 0, this.D = IV$3[3] | 0, this.E = IV$3[4] | 0, this.F = IV$3[5] | 0, this.G = IV$3[6] | 0, this.H = IV$3[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W$3[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W$3[_r - 15], Sr = SHA256_W$3[_r - 2], Er = rotr$3(xr, 7) ^ rotr$3(xr, 18) ^ xr >>> 3, Cr = rotr$3(Sr, 17) ^ rotr$3(Sr, 19) ^ Sr >>> 10;
      SHA256_W$3[_r] = Cr + SHA256_W$3[_r - 7] + Er + SHA256_W$3[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr$3(mr, 6) ^ rotr$3(mr, 11) ^ rotr$3(mr, 25), Sr = kr + xr + Chi$4(mr, vr, yr) + SHA256_K$3[_r] + SHA256_W$3[_r] | 0, Cr = (rotr$3(ur, 2) ^ rotr$3(ur, 13) ^ rotr$3(ur, 22)) + Maj$3(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W$3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$3(() => new SHA256$3()), U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(lr, ar = !1) {
  return ar ? { h: Number(lr & U32_MASK64), l: Number(lr >> _32n & U32_MASK64) } : { h: Number(lr >> _32n & U32_MASK64) | 0, l: Number(lr & U32_MASK64) | 0 };
}
function split$1(lr, ar = !1) {
  let cr = new Uint32Array(lr.length), ur = new Uint32Array(lr.length);
  for (let fr = 0; fr < lr.length; fr++) {
    const { h: dr, l: gr } = fromBig(lr[fr], ar);
    [cr[fr], ur[fr]] = [dr, gr];
  }
  return [cr, ur];
}
const toBig = (lr, ar) => BigInt(lr >>> 0) << _32n | BigInt(ar >>> 0), shrSH = (lr, ar, cr) => lr >>> cr, shrSL = (lr, ar, cr) => lr << 32 - cr | ar >>> cr, rotrSH = (lr, ar, cr) => lr >>> cr | ar << 32 - cr, rotrSL = (lr, ar, cr) => lr << 32 - cr | ar >>> cr, rotrBH = (lr, ar, cr) => lr << 64 - cr | ar >>> cr - 32, rotrBL = (lr, ar, cr) => lr >>> cr - 32 | ar << 64 - cr, rotr32H = (lr, ar) => ar, rotr32L = (lr, ar) => lr, rotlSH = (lr, ar, cr) => lr << cr | ar >>> 32 - cr, rotlSL = (lr, ar, cr) => ar << cr | lr >>> 32 - cr, rotlBH = (lr, ar, cr) => ar << cr - 32 | lr >>> 64 - cr, rotlBL = (lr, ar, cr) => lr << cr - 32 | ar >>> 64 - cr;
function add(lr, ar, cr, ur) {
  const fr = (ar >>> 0) + (ur >>> 0);
  return { h: lr + cr + (fr / 2 ** 32 | 0) | 0, l: fr | 0 };
}
const add3L = (lr, ar, cr) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0), add3H = (lr, ar, cr, ur) => ar + cr + ur + (lr / 2 ** 32 | 0) | 0, add4L = (lr, ar, cr, ur) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0) + (ur >>> 0), add4H = (lr, ar, cr, ur, fr) => ar + cr + ur + fr + (lr / 2 ** 32 | 0) | 0, add5L = (lr, ar, cr, ur, fr) => (lr >>> 0) + (ar >>> 0) + (cr >>> 0) + (ur >>> 0) + (fr >>> 0), add5H = (lr, ar, cr, ur, fr, dr) => ar + cr + ur + fr + dr + (lr / 2 ** 32 | 0) | 0, u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, u64$1 = u64, [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((lr) => BigInt(lr))))(), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2$3 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: ar, Al: cr, Bh: ur, Bl: fr, Ch: dr, Cl: gr, Dh: mr, Dl: vr, Eh: yr, El: kr, Fh: _r, Fl: xr, Gh: Sr, Gl: Er, Hh: Cr, Hl: Tr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr) {
    this.Ah = ar | 0, this.Al = cr | 0, this.Bh = ur | 0, this.Bl = fr | 0, this.Ch = dr | 0, this.Cl = gr | 0, this.Dh = mr | 0, this.Dl = vr | 0, this.Eh = yr | 0, this.El = kr | 0, this.Fh = _r | 0, this.Fl = xr | 0, this.Gh = Sr | 0, this.Gl = Er | 0, this.Hh = Cr | 0, this.Hl = Tr | 0;
  }
  process(ar, cr) {
    for (let Mr = 0; Mr < 16; Mr++, cr += 4)
      SHA512_W_H[Mr] = ar.getUint32(cr), SHA512_W_L[Mr] = ar.getUint32(cr += 4);
    for (let Mr = 16; Mr < 80; Mr++) {
      const Hr = SHA512_W_H[Mr - 15] | 0, Br = SHA512_W_L[Mr - 15] | 0, zr = u64$1.rotrSH(Hr, Br, 1) ^ u64$1.rotrSH(Hr, Br, 8) ^ u64$1.shrSH(Hr, Br, 7), Gr = u64$1.rotrSL(Hr, Br, 1) ^ u64$1.rotrSL(Hr, Br, 8) ^ u64$1.shrSL(Hr, Br, 7), Xr = SHA512_W_H[Mr - 2] | 0, Jr = SHA512_W_L[Mr - 2] | 0, li = u64$1.rotrSH(Xr, Jr, 19) ^ u64$1.rotrBH(Xr, Jr, 61) ^ u64$1.shrSH(Xr, Jr, 6), Qr = u64$1.rotrSL(Xr, Jr, 19) ^ u64$1.rotrBL(Xr, Jr, 61) ^ u64$1.shrSL(Xr, Jr, 6), ei = u64$1.add4L(Gr, Qr, SHA512_W_L[Mr - 7], SHA512_W_L[Mr - 16]), ui = u64$1.add4H(ei, zr, li, SHA512_W_H[Mr - 7], SHA512_W_H[Mr - 16]);
      SHA512_W_H[Mr] = ui | 0, SHA512_W_L[Mr] = ei | 0;
    }
    let { Ah: ur, Al: fr, Bh: dr, Bl: gr, Ch: mr, Cl: vr, Dh: yr, Dl: kr, Eh: _r, El: xr, Fh: Sr, Fl: Er, Gh: Cr, Gl: Tr, Hh: Ar, Hl: Ir } = this;
    for (let Mr = 0; Mr < 80; Mr++) {
      const Hr = u64$1.rotrSH(_r, xr, 14) ^ u64$1.rotrSH(_r, xr, 18) ^ u64$1.rotrBH(_r, xr, 41), Br = u64$1.rotrSL(_r, xr, 14) ^ u64$1.rotrSL(_r, xr, 18) ^ u64$1.rotrBL(_r, xr, 41), zr = _r & Sr ^ ~_r & Cr, Gr = xr & Er ^ ~xr & Tr, Xr = u64$1.add5L(Ir, Br, Gr, SHA512_Kl[Mr], SHA512_W_L[Mr]), Jr = u64$1.add5H(Xr, Ar, Hr, zr, SHA512_Kh[Mr], SHA512_W_H[Mr]), li = Xr | 0, Qr = u64$1.rotrSH(ur, fr, 28) ^ u64$1.rotrBH(ur, fr, 34) ^ u64$1.rotrBH(ur, fr, 39), ei = u64$1.rotrSL(ur, fr, 28) ^ u64$1.rotrBL(ur, fr, 34) ^ u64$1.rotrBL(ur, fr, 39), ui = ur & dr ^ ur & mr ^ dr & mr, Ai = fr & gr ^ fr & vr ^ gr & vr;
      Ar = Cr | 0, Ir = Tr | 0, Cr = Sr | 0, Tr = Er | 0, Sr = _r | 0, Er = xr | 0, { h: _r, l: xr } = u64$1.add(yr | 0, kr | 0, Jr | 0, li | 0), yr = mr | 0, kr = vr | 0, mr = dr | 0, vr = gr | 0, dr = ur | 0, gr = fr | 0;
      const fi = u64$1.add3L(li, ei, Ai);
      ur = u64$1.add3H(fi, Jr, Qr, ui), fr = fi | 0;
    }
    ({ h: ur, l: fr } = u64$1.add(this.Ah | 0, this.Al | 0, ur | 0, fr | 0)), { h: dr, l: gr } = u64$1.add(this.Bh | 0, this.Bl | 0, dr | 0, gr | 0), { h: mr, l: vr } = u64$1.add(this.Ch | 0, this.Cl | 0, mr | 0, vr | 0), { h: yr, l: kr } = u64$1.add(this.Dh | 0, this.Dl | 0, yr | 0, kr | 0), { h: _r, l: xr } = u64$1.add(this.Eh | 0, this.El | 0, _r | 0, xr | 0), { h: Sr, l: Er } = u64$1.add(this.Fh | 0, this.Fl | 0, Sr | 0, Er | 0), { h: Cr, l: Tr } = u64$1.add(this.Gh | 0, this.Gl | 0, Cr | 0, Tr | 0), { h: Ar, l: Ir } = u64$1.add(this.Hh | 0, this.Hl | 0, Ar | 0, Ir | 0), this.set(ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor$3(() => new SHA512());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function chain$2(...lr) {
  const ar = (fr, dr) => (gr) => fr(dr(gr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
// @__NO_SIDE_EFFECTS__
function alphabet$2(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join$3(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding$2(lr, ar = "=") {
  if (typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix$2(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((gr) => {
    if (gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const yr = dr[vr], kr = ar * gr + yr;
      if (!Number.isSafeInteger(kr) || ar * gr / ar !== gr || kr - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      gr = kr % cr;
      const _r = Math.floor(kr / cr);
      if (dr[vr] = _r, !Number.isSafeInteger(_r) || _r * cr + gr !== kr)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        _r ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < lr.length - 1 && lr[gr] === 0; gr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$2 = /* @__NO_SIDE_EFFECTS__ */ (lr, ar) => ar ? /* @__PURE__ */ gcd$2(ar, lr % ar) : lr, radix2carry$2 = /* @__NO_SIDE_EFFECTS__ */ (lr, ar) => lr + (ar - /* @__PURE__ */ gcd$2(lr, ar));
// @__NO_SIDE_EFFECTS__
function convertRadix2$2(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (/* @__PURE__ */ radix2carry$2(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${/* @__PURE__ */ radix2carry$2(ar, cr)}`);
  let fr = 0, dr = 0;
  const gr = 2 ** cr - 1, mr = [];
  for (const vr of lr) {
    if (vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      mr.push((fr >> dr - cr & gr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & gr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && mr.push(fr >>> 0), mr;
}
// @__NO_SIDE_EFFECTS__
function radix$2(lr) {
  return {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix$2(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix$2(ar, lr, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function radix2$2(lr, ar = !1) {
  if (lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry$2(8, lr) > 32 || /* @__PURE__ */ radix2carry$2(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix2$2(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix2$2(cr, lr, 8, ar));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function checksum(lr, ar) {
  if (typeof ar != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(cr) {
      if (!(cr instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const ur = ar(cr).slice(0, lr), fr = new Uint8Array(cr.length + lr);
      return fr.set(cr), fr.set(ur, cr.length), fr;
    },
    decode(cr) {
      if (!(cr instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const ur = cr.slice(0, -lr), fr = ar(ur).slice(0, lr), dr = cr.slice(-lr);
      for (let gr = 0; gr < lr; gr++)
        if (fr[gr] !== dr[gr])
          throw new Error("Invalid checksum");
      return ur;
    }
  };
}
const utils$4 = { alphabet: alphabet$2, chain: chain$2, checksum, radix: radix$2, radix2: radix2$2, join: join$3, padding: padding$2 }, genBase58$2 = (lr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ radix$2(58), /* @__PURE__ */ alphabet$2(lr), /* @__PURE__ */ join$3("")), base58$2 = /* @__PURE__ */ genBase58$2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), base58check$1 = (lr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ checksum(4, (ar) => lr(lr(ar))), base58$2), isJapanese = (lr) => lr[0] === "あいこくしん";
function nfkd(lr) {
  if (typeof lr != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof lr}`);
  return lr.normalize("NFKD");
}
function normalize$2(lr) {
  const ar = nfkd(lr), cr = ar.split(" ");
  if (![12, 15, 18, 21, 24].includes(cr.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: ar, words: cr };
}
function assertEntropy(lr) {
  assert$4.bytes(lr, 16, 20, 24, 28, 32);
}
function generateMnemonic(lr, ar = 128) {
  if (assert$4.number(ar), ar % 32 !== 0 || ar > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes$3(ar / 8), lr);
}
const calcChecksum = (lr) => {
  const ar = 8 - lr.length / 4;
  return new Uint8Array([sha256$3(lr)[0] >> ar << ar]);
};
function getCoder(lr) {
  if (!Array.isArray(lr) || lr.length !== 2048 || typeof lr[0] != "string")
    throw new Error("Worlist: expected array of 2048 strings");
  return lr.forEach((ar) => {
    if (typeof ar != "string")
      throw new Error(`Wordlist: non-string element: ${ar}`);
  }), utils$4.chain(utils$4.checksum(1, calcChecksum), utils$4.radix2(11, !0), utils$4.alphabet(lr));
}
function mnemonicToEntropy(lr, ar) {
  const { words: cr } = normalize$2(lr), ur = getCoder(ar).decode(cr);
  return assertEntropy(ur), ur;
}
function entropyToMnemonic(lr, ar) {
  return assertEntropy(lr), getCoder(ar).encode(lr).join(isJapanese(ar) ? "　" : " ");
}
function validateMnemonic(lr, ar) {
  try {
    mnemonicToEntropy(lr, ar);
  } catch (cr) {
    return !1;
  }
  return !0;
}
const salt = (lr) => nfkd(`mnemonic${lr}`);
function mnemonicToSeedSync(lr, ar = "") {
  return pbkdf2(sha512, normalize$2(lr).nfkd, salt(ar), { c: 2048, dkLen: 64 });
}
const Rho$1 = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (lr, ar) => ar), Pi$1 = /* @__PURE__ */ Id.map((lr) => (9 * lr + 5) % 16);
let idxL = [Id], idxR = [Pi$1];
for (let lr = 0; lr < 4; lr++)
  for (let ar of [idxL, idxR])
    ar.push(ar[lr].map((cr) => Rho$1[cr]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((lr) => new Uint8Array(lr)), shiftsL = /* @__PURE__ */ idxL.map((lr, ar) => lr.map((cr) => shifts[ar][cr])), shiftsR = /* @__PURE__ */ idxR.map((lr, ar) => lr.map((cr) => shifts[ar][cr])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]), rotl$1 = (lr, ar) => lr << ar | lr >>> 32 - ar;
function f$1(lr, ar, cr, ur) {
  return lr === 0 ? ar ^ cr ^ ur : lr === 1 ? ar & cr | ~ar & ur : lr === 2 ? (ar | ~cr) ^ ur : lr === 3 ? ar & ur | cr & ~ur : ar ^ (cr | ~ur);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2$3 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: ar, h1: cr, h2: ur, h3: fr, h4: dr } = this;
    return [ar, cr, ur, fr, dr];
  }
  set(ar, cr, ur, fr, dr) {
    this.h0 = ar | 0, this.h1 = cr | 0, this.h2 = ur | 0, this.h3 = fr | 0, this.h4 = dr | 0;
  }
  process(ar, cr) {
    for (let Sr = 0; Sr < 16; Sr++, cr += 4)
      BUF[Sr] = ar.getUint32(cr, !0);
    let ur = this.h0 | 0, fr = ur, dr = this.h1 | 0, gr = dr, mr = this.h2 | 0, vr = mr, yr = this.h3 | 0, kr = yr, _r = this.h4 | 0, xr = _r;
    for (let Sr = 0; Sr < 5; Sr++) {
      const Er = 4 - Sr, Cr = Kl[Sr], Tr = Kr[Sr], Ar = idxL[Sr], Ir = idxR[Sr], Mr = shiftsL[Sr], Hr = shiftsR[Sr];
      for (let Br = 0; Br < 16; Br++) {
        const zr = rotl$1(ur + f$1(Sr, dr, mr, yr) + BUF[Ar[Br]] + Cr, Mr[Br]) + _r | 0;
        ur = _r, _r = yr, yr = rotl$1(mr, 10) | 0, mr = dr, dr = zr;
      }
      for (let Br = 0; Br < 16; Br++) {
        const zr = rotl$1(fr + f$1(Er, gr, vr, kr) + BUF[Ir[Br]] + Tr, Hr[Br]) + xr | 0;
        fr = xr, xr = kr, kr = rotl$1(vr, 10) | 0, vr = gr, gr = zr;
      }
    }
    this.set(this.h1 + mr + kr | 0, this.h2 + yr + xr | 0, this.h3 + _r + fr | 0, this.h4 + ur + gr | 0, this.h0 + dr + vr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160 = /* @__PURE__ */ wrapConstructor$3(() => new RIPEMD160()), Point$1 = secp256k1$1.ProjectivePoint, base58check = base58check$1(sha256$3);
function bytesToNumber(lr) {
  return BigInt(`0x${bytesToHex$3(lr)}`);
}
function numberToBytes(lr) {
  return hexToBytes$4(lr.toString(16).padStart(64, "0"));
}
const MASTER_SECRET = utf8ToBytes$5("Bitcoin seed"), BITCOIN_VERSIONS = { private: 76066276, public: 76067358 }, HARDENED_OFFSET = 2147483648, hash160 = (lr) => ripemd160(sha256$3(lr)), fromU32 = (lr) => createView$3(lr).getUint32(0, !1), toU32 = (lr) => {
  if (!Number.isSafeInteger(lr) || lr < 0 || lr > 2 ** 32 - 1)
    throw new Error(`Invalid number=${lr}. Should be from 0 to 2 ** 32 - 1`);
  const ar = new Uint8Array(4);
  return createView$3(ar).setUint32(0, lr, !1), ar;
};
class HDKey {
  get fingerprint() {
    if (!this.pubHash)
      throw new Error("No publicKey set!");
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const ar = this.privateKey;
    if (!ar)
      throw new Error("No private key");
    return base58check.encode(this.serialize(this.versions.private, concatBytes$4(new Uint8Array([0]), ar)));
  }
  get publicExtendedKey() {
    if (!this.pubKey)
      throw new Error("No public key");
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(ar, cr = BITCOIN_VERSIONS) {
    if (bytes$4(ar), 8 * ar.length < 128 || 8 * ar.length > 512)
      throw new Error(`HDKey: wrong seed length=${ar.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const ur = hmac$4(sha512, MASTER_SECRET, ar);
    return new HDKey({
      versions: cr,
      chainCode: ur.slice(32),
      privateKey: ur.slice(0, 32)
    });
  }
  static fromExtendedKey(ar, cr = BITCOIN_VERSIONS) {
    const ur = base58check.decode(ar), fr = createView$3(ur), dr = fr.getUint32(0, !1), gr = {
      versions: cr,
      depth: ur[4],
      parentFingerprint: fr.getUint32(5, !1),
      index: fr.getUint32(9, !1),
      chainCode: ur.slice(13, 45)
    }, mr = ur.slice(45), vr = mr[0] === 0;
    if (dr !== cr[vr ? "private" : "public"])
      throw new Error("Version mismatch");
    return vr ? new HDKey({ ...gr, privateKey: mr.slice(1) }) : new HDKey({ ...gr, publicKey: mr });
  }
  static fromJSON(ar) {
    return HDKey.fromExtendedKey(ar.xpriv);
  }
  constructor(ar) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !ar || typeof ar != "object")
      throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = ar.versions || BITCOIN_VERSIONS, this.depth = ar.depth || 0, this.chainCode = ar.chainCode, this.index = ar.index || 0, this.parentFingerprint = ar.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))
      throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (ar.publicKey && ar.privateKey)
      throw new Error("HDKey: publicKey and privateKey at same time.");
    if (ar.privateKey) {
      if (!secp256k1$1.utils.isValidPrivateKey(ar.privateKey))
        throw new Error("Invalid private key");
      this.privKey = typeof ar.privateKey == "bigint" ? ar.privateKey : bytesToNumber(ar.privateKey), this.privKeyBytes = numberToBytes(this.privKey), this.pubKey = secp256k1$1.getPublicKey(ar.privateKey, !0);
    } else if (ar.publicKey)
      this.pubKey = Point$1.fromHex(ar.publicKey).toRawBytes(!0);
    else
      throw new Error("HDKey: no public or private key provided");
    this.pubHash = hash160(this.pubKey);
  }
  derive(ar) {
    if (!/^[mM]'?/.test(ar))
      throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(ar))
      return this;
    const cr = ar.replace(/^[mM]'?\//, "").split("/");
    let ur = this;
    for (const fr of cr) {
      const dr = /^(\d+)('?)$/.exec(fr);
      if (!dr || dr.length !== 3)
        throw new Error(`Invalid child index: ${fr}`);
      let gr = +dr[1];
      if (!Number.isSafeInteger(gr) || gr >= HARDENED_OFFSET)
        throw new Error("Invalid index");
      dr[2] === "'" && (gr += HARDENED_OFFSET), ur = ur.deriveChild(gr);
    }
    return ur;
  }
  deriveChild(ar) {
    if (!this.pubKey || !this.chainCode)
      throw new Error("No publicKey or chainCode set");
    let cr = toU32(ar);
    if (ar >= HARDENED_OFFSET) {
      const mr = this.privateKey;
      if (!mr)
        throw new Error("Could not derive hardened child key");
      cr = concatBytes$4(new Uint8Array([0]), mr, cr);
    } else
      cr = concatBytes$4(this.pubKey, cr);
    const ur = hmac$4(sha512, this.chainCode, cr), fr = bytesToNumber(ur.slice(0, 32)), dr = ur.slice(32);
    if (!secp256k1$1.utils.isValidPrivateKey(fr))
      throw new Error("Tweak bigger than curve order");
    const gr = {
      versions: this.versions,
      chainCode: dr,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: ar
    };
    try {
      if (this.privateKey) {
        const mr = mod$1(this.privKey + fr, secp256k1$1.CURVE.n);
        if (!secp256k1$1.utils.isValidPrivateKey(mr))
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        gr.privateKey = mr;
      } else {
        const mr = Point$1.fromHex(this.pubKey).add(Point$1.fromPrivateKey(fr));
        if (mr.equals(Point$1.ZERO))
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        gr.publicKey = mr.toRawBytes(!0);
      }
      return new HDKey(gr);
    } catch (mr) {
      return this.deriveChild(ar + 1);
    }
  }
  sign(ar) {
    if (!this.privateKey)
      throw new Error("No privateKey set!");
    return bytes$4(ar, 32), secp256k1$1.sign(ar, this.privKey).toCompactRawBytes();
  }
  verify(ar, cr) {
    if (bytes$4(ar, 32), bytes$4(cr, 64), !this.publicKey)
      throw new Error("No publicKey set!");
    let ur;
    try {
      ur = secp256k1$1.Signature.fromCompact(cr);
    } catch (fr) {
      return !1;
    }
    return secp256k1$1.verify(ur, ar, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(ar, cr) {
    if (!this.chainCode)
      throw new Error("No chainCode set");
    return bytes$4(cr, 33), concatBytes$4(toU32(ar), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, cr);
  }
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
const u8a$4 = (lr) => lr instanceof Uint8Array, u32 = (lr) => new Uint32Array(lr.buffer, lr.byteOffset, Math.floor(lr.byteLength / 4)), isLE$3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$3)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$4(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$3(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$4(lr)), !u8a$4(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
const isPlainObject = (lr) => Object.prototype.toString.call(lr) === "[object Object]" && lr.constructor === Object;
function checkOpts(lr, ar) {
  if (ar !== void 0 && (typeof ar != "object" || !isPlainObject(ar)))
    throw new Error("options must be object or undefined");
  return Object.assign(lr, ar);
}
function ensureBytes$1(lr, ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof ar == "number" && lr.length !== ar)
    throw new Error(`Uint8Array length ${ar} expected`);
}
function equalBytes$1(lr, ar) {
  if (lr.length !== ar.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let cr = !0;
  for (let ur = 0; ur < lr.length; ur++)
    cr && (cr = lr[ur] === ar[ur]);
  return cr;
}
function number$3(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$2(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$3(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$3(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("hash must be wrapped by utils.wrapConstructor");
  number$3(lr.outputLen), number$3(lr.blockLen);
}
function exists$3(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$3(lr, ar) {
  bytes$3(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$2 = { number: number$3, bool: bool$2, bytes: bytes$3, hash: hash$3, exists: exists$3, output: output$3 }, u8to16 = (lr, ar) => lr[ar++] & 255 | (lr[ar++] & 255) << 8;
class Poly1305 {
  constructor(ar) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, ar = toBytes$3(ar), ensureBytes$1(ar, 32);
    const cr = u8to16(ar, 0), ur = u8to16(ar, 2), fr = u8to16(ar, 4), dr = u8to16(ar, 6), gr = u8to16(ar, 8), mr = u8to16(ar, 10), vr = u8to16(ar, 12), yr = u8to16(ar, 14);
    this.r[0] = cr & 8191, this.r[1] = (cr >>> 13 | ur << 3) & 8191, this.r[2] = (ur >>> 10 | fr << 6) & 7939, this.r[3] = (fr >>> 7 | dr << 9) & 8191, this.r[4] = (dr >>> 4 | gr << 12) & 255, this.r[5] = gr >>> 1 & 8190, this.r[6] = (gr >>> 14 | mr << 2) & 8191, this.r[7] = (mr >>> 11 | vr << 5) & 8065, this.r[8] = (vr >>> 8 | yr << 8) & 8191, this.r[9] = yr >>> 5 & 127;
    for (let kr = 0; kr < 8; kr++)
      this.pad[kr] = u8to16(ar, 16 + 2 * kr);
  }
  process(ar, cr, ur = !1) {
    const fr = ur ? 0 : 2048, { h: dr, r: gr } = this, mr = gr[0], vr = gr[1], yr = gr[2], kr = gr[3], _r = gr[4], xr = gr[5], Sr = gr[6], Er = gr[7], Cr = gr[8], Tr = gr[9], Ar = u8to16(ar, cr + 0), Ir = u8to16(ar, cr + 2), Mr = u8to16(ar, cr + 4), Hr = u8to16(ar, cr + 6), Br = u8to16(ar, cr + 8), zr = u8to16(ar, cr + 10), Gr = u8to16(ar, cr + 12), Xr = u8to16(ar, cr + 14);
    let Jr = dr[0] + (Ar & 8191), li = dr[1] + ((Ar >>> 13 | Ir << 3) & 8191), Qr = dr[2] + ((Ir >>> 10 | Mr << 6) & 8191), ei = dr[3] + ((Mr >>> 7 | Hr << 9) & 8191), ui = dr[4] + ((Hr >>> 4 | Br << 12) & 8191), Ai = dr[5] + (Br >>> 1 & 8191), fi = dr[6] + ((Br >>> 14 | zr << 2) & 8191), gi = dr[7] + ((zr >>> 11 | Gr << 5) & 8191), Ci = dr[8] + ((Gr >>> 8 | Xr << 8) & 8191), mi = dr[9] + (Xr >>> 5 | fr), vi = 0, Ri = vi + Jr * mr + li * (5 * Tr) + Qr * (5 * Cr) + ei * (5 * Er) + ui * (5 * Sr);
    vi = Ri >>> 13, Ri &= 8191, Ri += Ai * (5 * xr) + fi * (5 * _r) + gi * (5 * kr) + Ci * (5 * yr) + mi * (5 * vr), vi += Ri >>> 13, Ri &= 8191;
    let di = vi + Jr * vr + li * mr + Qr * (5 * Tr) + ei * (5 * Cr) + ui * (5 * Er);
    vi = di >>> 13, di &= 8191, di += Ai * (5 * Sr) + fi * (5 * xr) + gi * (5 * _r) + Ci * (5 * kr) + mi * (5 * yr), vi += di >>> 13, di &= 8191;
    let Ti = vi + Jr * yr + li * vr + Qr * mr + ei * (5 * Tr) + ui * (5 * Cr);
    vi = Ti >>> 13, Ti &= 8191, Ti += Ai * (5 * Er) + fi * (5 * Sr) + gi * (5 * xr) + Ci * (5 * _r) + mi * (5 * kr), vi += Ti >>> 13, Ti &= 8191;
    let qi = vi + Jr * kr + li * yr + Qr * vr + ei * mr + ui * (5 * Tr);
    vi = qi >>> 13, qi &= 8191, qi += Ai * (5 * Cr) + fi * (5 * Er) + gi * (5 * Sr) + Ci * (5 * xr) + mi * (5 * _r), vi += qi >>> 13, qi &= 8191;
    let ki = vi + Jr * _r + li * kr + Qr * yr + ei * vr + ui * mr;
    vi = ki >>> 13, ki &= 8191, ki += Ai * (5 * Tr) + fi * (5 * Cr) + gi * (5 * Er) + Ci * (5 * Sr) + mi * (5 * xr), vi += ki >>> 13, ki &= 8191;
    let Ji = vi + Jr * xr + li * _r + Qr * kr + ei * yr + ui * vr;
    vi = Ji >>> 13, Ji &= 8191, Ji += Ai * mr + fi * (5 * Tr) + gi * (5 * Cr) + Ci * (5 * Er) + mi * (5 * Sr), vi += Ji >>> 13, Ji &= 8191;
    let Bi = vi + Jr * Sr + li * xr + Qr * _r + ei * kr + ui * yr;
    vi = Bi >>> 13, Bi &= 8191, Bi += Ai * vr + fi * mr + gi * (5 * Tr) + Ci * (5 * Cr) + mi * (5 * Er), vi += Bi >>> 13, Bi &= 8191;
    let Ni = vi + Jr * Er + li * Sr + Qr * xr + ei * _r + ui * kr;
    vi = Ni >>> 13, Ni &= 8191, Ni += Ai * yr + fi * vr + gi * mr + Ci * (5 * Tr) + mi * (5 * Cr), vi += Ni >>> 13, Ni &= 8191;
    let Mi = vi + Jr * Cr + li * Er + Qr * Sr + ei * xr + ui * _r;
    vi = Mi >>> 13, Mi &= 8191, Mi += Ai * kr + fi * yr + gi * vr + Ci * mr + mi * (5 * Tr), vi += Mi >>> 13, Mi &= 8191;
    let bi = vi + Jr * Tr + li * Cr + Qr * Er + ei * Sr + ui * xr;
    vi = bi >>> 13, bi &= 8191, bi += Ai * _r + fi * kr + gi * yr + Ci * vr + mi * mr, vi += bi >>> 13, bi &= 8191, vi = (vi << 2) + vi | 0, vi = vi + Ri | 0, Ri = vi & 8191, vi = vi >>> 13, di += vi, dr[0] = Ri, dr[1] = di, dr[2] = Ti, dr[3] = qi, dr[4] = ki, dr[5] = Ji, dr[6] = Bi, dr[7] = Ni, dr[8] = Mi, dr[9] = bi;
  }
  finalize() {
    const { h: ar, pad: cr } = this, ur = new Uint16Array(10);
    let fr = ar[1] >>> 13;
    ar[1] &= 8191;
    for (let mr = 2; mr < 10; mr++)
      ar[mr] += fr, fr = ar[mr] >>> 13, ar[mr] &= 8191;
    ar[0] += fr * 5, fr = ar[0] >>> 13, ar[0] &= 8191, ar[1] += fr, fr = ar[1] >>> 13, ar[1] &= 8191, ar[2] += fr, ur[0] = ar[0] + 5, fr = ur[0] >>> 13, ur[0] &= 8191;
    for (let mr = 1; mr < 10; mr++)
      ur[mr] = ar[mr] + fr, fr = ur[mr] >>> 13, ur[mr] &= 8191;
    ur[9] -= 8192;
    let dr = (fr ^ 1) - 1;
    for (let mr = 0; mr < 10; mr++)
      ur[mr] &= dr;
    dr = ~dr;
    for (let mr = 0; mr < 10; mr++)
      ar[mr] = ar[mr] & dr | ur[mr];
    ar[0] = (ar[0] | ar[1] << 13) & 65535, ar[1] = (ar[1] >>> 3 | ar[2] << 10) & 65535, ar[2] = (ar[2] >>> 6 | ar[3] << 7) & 65535, ar[3] = (ar[3] >>> 9 | ar[4] << 4) & 65535, ar[4] = (ar[4] >>> 12 | ar[5] << 1 | ar[6] << 14) & 65535, ar[5] = (ar[6] >>> 2 | ar[7] << 11) & 65535, ar[6] = (ar[7] >>> 5 | ar[8] << 8) & 65535, ar[7] = (ar[8] >>> 8 | ar[9] << 5) & 65535;
    let gr = ar[0] + cr[0];
    ar[0] = gr & 65535;
    for (let mr = 1; mr < 8; mr++)
      gr = (ar[mr] + cr[mr] | 0) + (gr >>> 16) | 0, ar[mr] = gr & 65535;
  }
  update(ar) {
    assert$2.exists(this);
    const { buffer: cr, blockLen: ur } = this;
    ar = toBytes$3(ar);
    const fr = ar.length;
    for (let dr = 0; dr < fr; ) {
      const gr = Math.min(ur - this.pos, fr - dr);
      if (gr === ur) {
        for (; ur <= fr - dr; dr += ur)
          this.process(ar, dr);
        continue;
      }
      cr.set(ar.subarray(dr, dr + gr), this.pos), this.pos += gr, dr += gr, this.pos === ur && (this.process(cr, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    this.h.fill(0), this.r.fill(0), this.buffer.fill(0), this.pad.fill(0);
  }
  digestInto(ar) {
    assert$2.exists(this), assert$2.output(ar, this), this.finished = !0;
    const { buffer: cr, h: ur } = this;
    let { pos: fr } = this;
    if (fr) {
      for (cr[fr++] = 1; fr < 16; fr++)
        cr[fr] = 0;
      this.process(cr, 0, !0);
    }
    this.finalize();
    let dr = 0;
    for (let gr = 0; gr < 8; gr++)
      ar[dr++] = ur[gr] >>> 0, ar[dr++] = ur[gr] >>> 8;
    return ar;
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
}
function wrapConstructorWithKey(lr) {
  const ar = (ur, fr) => lr(fr).update(toBytes$3(ur)).digest(), cr = lr(new Uint8Array(32));
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = (ur) => lr(ur), ar;
}
wrapConstructorWithKey((lr) => new Poly1305(lr));
const sigma16 = utf8ToBytes$4("expand 16-byte k"), sigma32 = utf8ToBytes$4("expand 32-byte k"), sigma16_32 = u32(sigma16), sigma32_32 = u32(sigma32), isAligned32 = (lr) => !(lr.byteOffset % 4), salsaBasic = (lr) => {
  const { core: ar, rounds: cr, counterRight: ur, counterLen: fr, allow128bitKeys: dr, extendNonceFn: gr, blockLen: mr } = checkOpts({ rounds: 20, counterRight: !1, counterLen: 8, allow128bitKeys: !0, blockLen: 64 }, lr);
  assert$2.number(fr), assert$2.number(cr), assert$2.number(mr), assert$2.bool(ur), assert$2.bool(dr);
  const vr = mr / 4;
  if (mr % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen must be aligned to 4 bytes");
  return (yr, kr, _r, xr, Sr = 0) => {
    if (assert$2.bytes(yr), assert$2.bytes(kr), assert$2.bytes(_r), xr || (xr = new Uint8Array(_r.length)), assert$2.bytes(xr), assert$2.number(Sr), Sr < 0 || Sr >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (xr.length < _r.length)
      throw new Error(`Salsa/ChaCha: output (${xr.length}) is shorter than data (${_r.length})`);
    const Er = [];
    let Cr, Tr;
    if (yr.length === 32)
      Cr = yr, Tr = sigma32_32;
    else if (yr.length === 16 && dr)
      Cr = new Uint8Array(32), Cr.set(yr), Cr.set(yr, 16), Tr = sigma16_32, Er.push(Cr);
    else
      throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${yr.length}`);
    if (gr) {
      if (kr.length <= 16)
        throw new Error("Salsa/ChaCha: extended nonce must be bigger than 16 bytes");
      Cr = gr(Tr, Cr, kr.subarray(0, 16), new Uint8Array(32)), Er.push(Cr), kr = kr.subarray(16);
    }
    const Ar = 16 - fr;
    if (kr.length !== Ar)
      throw new Error(`Salsa/ChaCha: nonce must be ${Ar} or 16 bytes`);
    if (Ar !== 12) {
      const Jr = new Uint8Array(12);
      Jr.set(kr, ur ? 0 : 12 - kr.length), Er.push(kr = Jr);
    }
    const Ir = new Uint8Array(mr), Mr = u32(Ir), Hr = u32(Cr), Br = u32(kr), zr = isAligned32(_r) && u32(_r), Gr = isAligned32(xr) && u32(xr);
    Er.push(Mr);
    const Xr = _r.length;
    for (let Jr = 0, li = Sr; Jr < Xr; li++) {
      if (ar(Tr, Hr, Br, Mr, li, cr), li >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const Qr = Math.min(mr, Xr - Jr);
      if (Qr === mr && Gr && zr) {
        const ei = Jr / 4;
        if (Jr % 4 !== 0)
          throw new Error("Salsa/ChaCha: invalid block position");
        for (let ui = 0; ui < vr; ui++)
          Gr[ei + ui] = zr[ei + ui] ^ Mr[ui];
        Jr += mr;
        continue;
      }
      for (let ei = 0; ei < Qr; ei++)
        xr[Jr + ei] = _r[Jr + ei] ^ Ir[ei];
      Jr += Qr;
    }
    for (let Jr = 0; Jr < Er.length; Jr++)
      Er[Jr].fill(0);
    return xr;
  };
}, rotl = (lr, ar) => lr << ar | lr >>> 32 - ar;
function chachaCore(lr, ar, cr, ur, fr, dr = 20) {
  let gr = lr[0], mr = lr[1], vr = lr[2], yr = lr[3], kr = ar[0], _r = ar[1], xr = ar[2], Sr = ar[3], Er = ar[4], Cr = ar[5], Tr = ar[6], Ar = ar[7], Ir = fr, Mr = cr[0], Hr = cr[1], Br = cr[2], zr = gr, Gr = mr, Xr = vr, Jr = yr, li = kr, Qr = _r, ei = xr, ui = Sr, Ai = Er, fi = Cr, gi = Tr, Ci = Ar, mi = Ir, vi = Mr, Ri = Hr, di = Br;
  for (let qi = 0; qi < dr; qi += 2)
    zr = zr + li | 0, mi = rotl(mi ^ zr, 16), Ai = Ai + mi | 0, li = rotl(li ^ Ai, 12), zr = zr + li | 0, mi = rotl(mi ^ zr, 8), Ai = Ai + mi | 0, li = rotl(li ^ Ai, 7), Gr = Gr + Qr | 0, vi = rotl(vi ^ Gr, 16), fi = fi + vi | 0, Qr = rotl(Qr ^ fi, 12), Gr = Gr + Qr | 0, vi = rotl(vi ^ Gr, 8), fi = fi + vi | 0, Qr = rotl(Qr ^ fi, 7), Xr = Xr + ei | 0, Ri = rotl(Ri ^ Xr, 16), gi = gi + Ri | 0, ei = rotl(ei ^ gi, 12), Xr = Xr + ei | 0, Ri = rotl(Ri ^ Xr, 8), gi = gi + Ri | 0, ei = rotl(ei ^ gi, 7), Jr = Jr + ui | 0, di = rotl(di ^ Jr, 16), Ci = Ci + di | 0, ui = rotl(ui ^ Ci, 12), Jr = Jr + ui | 0, di = rotl(di ^ Jr, 8), Ci = Ci + di | 0, ui = rotl(ui ^ Ci, 7), zr = zr + Qr | 0, di = rotl(di ^ zr, 16), gi = gi + di | 0, Qr = rotl(Qr ^ gi, 12), zr = zr + Qr | 0, di = rotl(di ^ zr, 8), gi = gi + di | 0, Qr = rotl(Qr ^ gi, 7), Gr = Gr + ei | 0, mi = rotl(mi ^ Gr, 16), Ci = Ci + mi | 0, ei = rotl(ei ^ Ci, 12), Gr = Gr + ei | 0, mi = rotl(mi ^ Gr, 8), Ci = Ci + mi | 0, ei = rotl(ei ^ Ci, 7), Xr = Xr + ui | 0, vi = rotl(vi ^ Xr, 16), Ai = Ai + vi | 0, ui = rotl(ui ^ Ai, 12), Xr = Xr + ui | 0, vi = rotl(vi ^ Xr, 8), Ai = Ai + vi | 0, ui = rotl(ui ^ Ai, 7), Jr = Jr + li | 0, Ri = rotl(Ri ^ Jr, 16), fi = fi + Ri | 0, li = rotl(li ^ fi, 12), Jr = Jr + li | 0, Ri = rotl(Ri ^ Jr, 8), fi = fi + Ri | 0, li = rotl(li ^ fi, 7);
  let Ti = 0;
  ur[Ti++] = gr + zr | 0, ur[Ti++] = mr + Gr | 0, ur[Ti++] = vr + Xr | 0, ur[Ti++] = yr + Jr | 0, ur[Ti++] = kr + li | 0, ur[Ti++] = _r + Qr | 0, ur[Ti++] = xr + ei | 0, ur[Ti++] = Sr + ui | 0, ur[Ti++] = Er + Ai | 0, ur[Ti++] = Cr + fi | 0, ur[Ti++] = Tr + gi | 0, ur[Ti++] = Ar + Ci | 0, ur[Ti++] = Ir + mi | 0, ur[Ti++] = Mr + vi | 0, ur[Ti++] = Hr + Ri | 0, ur[Ti++] = Br + di | 0;
}
const chacha20 = /* @__PURE__ */ salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  allow128bitKeys: !1
});
let HMAC$3 = class extends Hash$4 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$5.hash(ar);
    const ur = toBytes$5(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$5.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$3 = (lr, ar, cr) => new HMAC$3(lr, ar).update(cr).digest();
hmac$3.create = (lr, ar) => new HMAC$3(lr, ar);
function extract$2(lr, ar, cr) {
  return assert$5.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac$3(lr, toBytes$5(cr), toBytes$5(ar));
}
const HKDF_COUNTER$2 = new Uint8Array([0]), EMPTY_BUFFER$2 = new Uint8Array();
function expand$2(lr, ar, cr, ur = 32) {
  if (assert$5.hash(lr), assert$5.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER$2);
  const dr = new Uint8Array(fr * lr.outputLen), gr = hmac$3.create(lr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < fr; yr++)
    HKDF_COUNTER$2[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER$2 : vr).update(cr).update(HKDF_COUNTER$2).digestInto(vr), dr.set(vr, lr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER$2.fill(0), dr.slice(0, ur);
}
const hkdf$1 = (lr, ar, cr, ur, fr) => expand$2(lr, extract$2(lr, ar, cr), ur, fr);
var __defProp$2 = Object.defineProperty, __export$2 = (lr, ar) => {
  for (var cr in ar)
    __defProp$2(lr, cr, { get: ar[cr], enumerable: !0 });
};
function generatePrivateKey() {
  return bytesToHex$4(schnorr$1.utils.randomPrivateKey());
}
function getPublicKey$1(lr) {
  return bytesToHex$4(schnorr$1.getPublicKey(lr));
}
var utils_exports$2 = {};
__export$2(utils_exports$2, {
  MessageNode: () => MessageNode$1,
  MessageQueue: () => MessageQueue$1,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$2,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$2,
  normalizeURL: () => normalizeURL$2,
  utf8Decoder: () => utf8Decoder$2,
  utf8Encoder: () => utf8Encoder$2
});
var utf8Decoder$2 = new TextDecoder("utf-8"), utf8Encoder$2 = new TextEncoder();
function normalizeURL$2(lr) {
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$2(lr, ar) {
  var gr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at < lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at >= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at > ar.created_at)
        cr = fr;
      else if (lr[fr].created_at < ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((gr = lr[dr]) == null ? void 0 : gr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
function insertEventIntoAscendingList$2(lr, ar) {
  var gr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at > lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at <= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at < ar.created_at)
        cr = fr;
      else if (lr[fr].created_at > ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((gr = lr[dr]) == null ? void 0 : gr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
var MessageNode$1 = class {
  constructor(ar) {
    ji(this, "_value");
    ji(this, "_next");
    this._value = ar, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(ar) {
    this._value = ar;
  }
  get next() {
    return this._next;
  }
  set next(ar) {
    this._next = ar;
  }
}, MessageQueue$1 = class {
  constructor() {
    ji(this, "_first");
    ji(this, "_last");
    ji(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(ar) {
    this._first = ar;
  }
  get last() {
    return this._last;
  }
  set last(ar) {
    this._last = ar;
  }
  get size() {
    return this._size;
  }
  set size(ar) {
    this._size = ar;
  }
  enqueue(ar) {
    const cr = new MessageNode$1(ar);
    return this._size === 0 || !this._last ? (this._first = cr, this._last = cr) : (this._last.next = cr, this._last = cr), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let ar = this._first;
    return this._first = ar.next, ar.next = null, this._size--, ar.value;
  }
}, verifiedSymbol$2 = Symbol("verified");
function getBlankEvent$1(lr = 255) {
  return {
    kind: lr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent$1(lr, ar) {
  const cr = lr;
  return cr.pubkey = getPublicKey$1(ar), cr.id = getEventHash$2(cr), cr.sig = getSignature$1(cr, ar), cr[verifiedSymbol$2] = !0, cr;
}
function serializeEvent$2(lr) {
  if (!validateEvent$2(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash$2(lr) {
  let ar = sha256$4(utf8Encoder$2.encode(serializeEvent$2(lr)));
  return bytesToHex$4(ar);
}
var isRecord$2 = (lr) => lr instanceof Object;
function validateEvent$2(lr) {
  if (!isRecord$2(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature$1(lr) {
  if (typeof lr[verifiedSymbol$2] == "boolean")
    return lr[verifiedSymbol$2];
  const ar = getEventHash$2(lr);
  if (ar !== lr.id)
    return lr[verifiedSymbol$2] = !1;
  try {
    return lr[verifiedSymbol$2] = schnorr$1.verify(lr.sig, ar, lr.pubkey);
  } catch (cr) {
    return lr[verifiedSymbol$2] = !1;
  }
}
function getSignature$1(lr, ar) {
  return bytesToHex$4(schnorr$1.sign(getEventHash$2(lr), ar));
}
function matchFilter$1(lr, ar) {
  if (lr.ids && lr.ids.indexOf(ar.id) === -1 && !lr.ids.some((cr) => ar.id.startsWith(cr)) || lr.kinds && lr.kinds.indexOf(ar.kind) === -1 || lr.authors && lr.authors.indexOf(ar.pubkey) === -1 && !lr.authors.some((cr) => ar.pubkey.startsWith(cr)))
    return !1;
  for (let cr in lr)
    if (cr[0] === "#") {
      let ur = cr.slice(1), fr = lr[`#${ur}`];
      if (fr && !ar.tags.find(([dr, gr]) => dr === cr.slice(1) && fr.indexOf(gr) !== -1))
        return !1;
    }
  return !(lr.since && ar.created_at < lr.since || lr.until && ar.created_at > lr.until);
}
function matchFilters(lr, ar) {
  for (let cr = 0; cr < lr.length; cr++)
    if (matchFilter$1(lr[cr], ar))
      return !0;
  return !1;
}
var fakejson_exports$2 = {};
__export$2(fakejson_exports$2, {
  getHex64: () => getHex64$2,
  getInt: () => getInt$2,
  getSubscriptionId: () => getSubscriptionId$2,
  matchEventId: () => matchEventId$2,
  matchEventKind: () => matchEventKind$2,
  matchEventPubkey: () => matchEventPubkey$2
});
function getHex64$2(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt$2(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId$2(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId$2(lr, ar) {
  return ar === getHex64$2(lr, "id");
}
function matchEventPubkey$2(lr, ar) {
  return ar === getHex64$2(lr, "pubkey");
}
function matchEventKind$2(lr, ar) {
  return ar === getInt$2(lr, "kind");
}
var newListeners = () => ({
  connect: [],
  disconnect: [],
  error: [],
  notice: [],
  auth: []
});
function relayInit(lr, ar = {}) {
  let { listTimeout: cr = 3e3, getTimeout: ur = 3e3, countTimeout: fr = 3e3 } = ar;
  var dr, gr = {}, mr = newListeners(), vr = {}, yr = {}, kr;
  async function _r() {
    return kr || (kr = new Promise((Ar, Ir) => {
      try {
        dr = new WebSocket(lr);
      } catch (zr) {
        Ir(zr);
      }
      dr.onopen = () => {
        mr.connect.forEach((zr) => zr()), Ar();
      }, dr.onerror = () => {
        kr = void 0, mr.error.forEach((zr) => zr()), Ir();
      }, dr.onclose = async () => {
        kr = void 0, mr.disconnect.forEach((zr) => zr());
      };
      let Mr = new MessageQueue$1(), Hr;
      dr.onmessage = (zr) => {
        Mr.enqueue(zr.data), Hr || (Hr = setInterval(Br, 0));
      };
      function Br() {
        var Xr, Jr, li;
        if (Mr.size === 0) {
          clearInterval(Hr), Hr = null;
          return;
        }
        var zr = Mr.dequeue();
        if (!zr)
          return;
        let Gr = getSubscriptionId$2(zr);
        if (Gr) {
          let Qr = gr[Gr];
          if (Qr && Qr.alreadyHaveEvent && Qr.alreadyHaveEvent(getHex64$2(zr, "id"), lr))
            return;
        }
        try {
          let Qr = JSON.parse(zr);
          switch (Qr[0]) {
            case "EVENT": {
              let fi = Qr[1], gi = Qr[2];
              validateEvent$2(gi) && gr[fi] && (gr[fi].skipVerification || verifySignature$1(gi)) && matchFilters(gr[fi].filters, gi) && (gr[fi], (((Xr = vr[fi]) == null ? void 0 : Xr.event) || []).forEach((Ci) => Ci(gi)));
              return;
            }
            case "COUNT":
              let ei = Qr[1], ui = Qr[2];
              gr[ei] && (((Jr = vr[ei]) == null ? void 0 : Jr.count) || []).forEach((fi) => fi(ui));
              return;
            case "EOSE": {
              let fi = Qr[1];
              fi in vr && (vr[fi].eose.forEach((gi) => gi()), vr[fi].eose = []);
              return;
            }
            case "OK": {
              let fi = Qr[1], gi = Qr[2], Ci = Qr[3] || "";
              if (fi in yr) {
                let { resolve: mi, reject: vi } = yr[fi];
                gi ? mi(null) : vi(new Error(Ci));
              }
              return;
            }
            case "NOTICE":
              let Ai = Qr[1];
              mr.notice.forEach((fi) => fi(Ai));
              return;
            case "AUTH": {
              let fi = Qr[1];
              (li = mr.auth) == null || li.forEach((gi) => gi(fi));
              return;
            }
          }
        } catch (Qr) {
          return;
        }
      }
    }), kr);
  }
  function xr() {
    return (dr == null ? void 0 : dr.readyState) === 1;
  }
  async function Sr() {
    xr() || await _r();
  }
  async function Er(Ar) {
    let Ir = JSON.stringify(Ar);
    if (!(!xr() && (await new Promise((Mr) => setTimeout(Mr, 1e3)), !xr())))
      try {
        dr.send(Ir);
      } catch (Mr) {
        console.log(Mr);
      }
  }
  const Cr = (Ar, {
    verb: Ir = "REQ",
    skipVerification: Mr = !1,
    alreadyHaveEvent: Hr = null,
    id: Br = Math.random().toString().slice(2)
  } = {}) => {
    let zr = Br;
    gr[zr] = {
      id: zr,
      filters: Ar,
      skipVerification: Mr,
      alreadyHaveEvent: Hr
    }, Er([Ir, zr, ...Ar]);
    let Gr = {
      sub: (Xr, Jr = {}) => Cr(Xr || Ar, {
        skipVerification: Jr.skipVerification || Mr,
        alreadyHaveEvent: Jr.alreadyHaveEvent || Hr,
        id: zr
      }),
      unsub: () => {
        delete gr[zr], delete vr[zr], Er(["CLOSE", zr]);
      },
      on: (Xr, Jr) => {
        vr[zr] = vr[zr] || {
          event: [],
          count: [],
          eose: []
        }, vr[zr][Xr].push(Jr);
      },
      off: (Xr, Jr) => {
        let li = vr[zr], Qr = li[Xr].indexOf(Jr);
        Qr >= 0 && li[Xr].splice(Qr, 1);
      },
      get events() {
        return eventsGenerator(Gr);
      }
    };
    return Gr;
  };
  function Tr(Ar, Ir) {
    return new Promise((Mr, Hr) => {
      if (!Ar.id) {
        Hr(new Error(`event ${Ar} has no id`));
        return;
      }
      let Br = Ar.id;
      Er([Ir, Ar]), yr[Br] = { resolve: Mr, reject: Hr };
    });
  }
  return {
    url: lr,
    sub: Cr,
    on: (Ar, Ir) => {
      mr[Ar].push(Ir), Ar === "connect" && (dr == null ? void 0 : dr.readyState) === 1 && Ir();
    },
    off: (Ar, Ir) => {
      let Mr = mr[Ar].indexOf(Ir);
      Mr !== -1 && mr[Ar].splice(Mr, 1);
    },
    list: (Ar, Ir) => new Promise((Mr) => {
      let Hr = Cr(Ar, Ir), Br = [], zr = setTimeout(() => {
        Hr.unsub(), Mr(Br);
      }, cr);
      Hr.on("eose", () => {
        Hr.unsub(), clearTimeout(zr), Mr(Br);
      }), Hr.on("event", (Gr) => {
        Br.push(Gr);
      });
    }),
    get: (Ar, Ir) => new Promise((Mr) => {
      let Hr = Cr([Ar], Ir), Br = setTimeout(() => {
        Hr.unsub(), Mr(null);
      }, ur);
      Hr.on("event", (zr) => {
        Hr.unsub(), clearTimeout(Br), Mr(zr);
      });
    }),
    count: (Ar) => new Promise((Ir) => {
      let Mr = Cr(Ar, { ...Cr, verb: "COUNT" }), Hr = setTimeout(() => {
        Mr.unsub(), Ir(null);
      }, fr);
      Mr.on("count", (Br) => {
        Mr.unsub(), clearTimeout(Hr), Ir(Br);
      });
    }),
    async publish(Ar) {
      await Tr(Ar, "EVENT");
    },
    async auth(Ar) {
      await Tr(Ar, "AUTH");
    },
    connect: Sr,
    close() {
      mr = newListeners(), vr = {}, yr = {}, (dr == null ? void 0 : dr.readyState) === WebSocket.OPEN && dr.close();
    },
    get status() {
      var Ar;
      return (Ar = dr == null ? void 0 : dr.readyState) != null ? Ar : 3;
    }
  };
}
async function* eventsGenerator(lr) {
  let ar;
  const cr = [], ur = (fr) => {
    ar ? (ar(fr), ar = void 0) : cr.push(fr);
  };
  lr.on("event", ur);
  try {
    for (; ; )
      cr.length > 0 ? yield cr.shift() : yield await new Promise((dr) => {
        ar = dr;
      });
  } finally {
    lr.off("event", ur);
  }
}
var nip19_exports$2 = {};
__export$2(nip19_exports$2, {
  BECH32_REGEX: () => BECH32_REGEX$2,
  decode: () => decode$3,
  naddrEncode: () => naddrEncode$2,
  neventEncode: () => neventEncode$2,
  noteEncode: () => noteEncode$2,
  nprofileEncode: () => nprofileEncode$2,
  npubEncode: () => npubEncode$2,
  nrelayEncode: () => nrelayEncode$2,
  nsecEncode: () => nsecEncode$2
});
var Bech32MaxSize$2 = 5e3, BECH32_REGEX$2 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$2(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$3(lr) {
  var fr, dr, gr, mr, vr, yr, kr, _r;
  let { prefix: ar, words: cr } = bech32$3.decode(lr, Bech32MaxSize$2), ur = new Uint8Array(bech32$3.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV$2(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$4(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$2.decode(Sr)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV$2(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$4(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$2.decode(Sr)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex$4(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex$4(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV$2(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((kr = xr[3]) != null && kr[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$2.decode(xr[0][0]),
          pubkey: bytesToHex$4(xr[2][0]),
          kind: parseInt(bytesToHex$4(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$2.decode(Sr)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV$2(ur);
      if (!((_r = xr[0]) != null && _r[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$2.decode(xr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$4(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$2(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1];
    if (!fr)
      throw new Error(`malformed TLV ${ur}`);
    let dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode$2(lr) {
  return encodeBytes$2("nsec", lr);
}
function npubEncode$2(lr) {
  return encodeBytes$2("npub", lr);
}
function noteEncode$2(lr) {
  return encodeBytes$2("note", lr);
}
function encodeBech32$2(lr, ar) {
  let cr = bech32$3.toWords(ar);
  return bech32$3.encode(lr, cr, Bech32MaxSize$2);
}
function encodeBytes$2(lr, ar) {
  let cr = hexToBytes$5(ar);
  return encodeBech32$2(lr, cr);
}
function nprofileEncode$2(lr) {
  let ar = encodeTLV$2({
    0: [hexToBytes$5(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder$2.encode(cr))
  });
  return encodeBech32$2("nprofile", ar);
}
function neventEncode$2(lr) {
  let ar;
  lr.kind != null && (ar = integerToUint8Array$2(lr.kind));
  let cr = encodeTLV$2({
    0: [hexToBytes$5(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: lr.author ? [hexToBytes$5(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$2("nevent", cr);
}
function naddrEncode$2(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV$2({
    0: [utf8Encoder$2.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: [hexToBytes$5(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$2("naddr", cr);
}
function nrelayEncode$2(lr) {
  let ar = encodeTLV$2({
    0: [utf8Encoder$2.encode(lr)]
  });
  return encodeBech32$2("nrelay", ar);
}
function encodeTLV$2(lr) {
  let ar = [];
  return Object.entries(lr).forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes$5(...ar);
}
var nip04_exports$2 = {};
__export$2(nip04_exports$2, {
  decrypt: () => decrypt$3,
  encrypt: () => encrypt$3
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$3(lr, ar, cr) {
  const ur = secp256k1$1.getSharedSecret(lr, "02" + ar), fr = getNormalizedX$2(ur);
  let dr = Uint8Array.from(randomBytes$4(16)), gr = utf8Encoder$2.encode(cr), mr = await crypto.subtle.importKey("raw", fr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: dr }, mr, gr), yr = base64$2.encode(new Uint8Array(vr)), kr = base64$2.encode(new Uint8Array(dr.buffer));
  return `${yr}?iv=${kr}`;
}
async function decrypt$3(lr, ar, cr) {
  let [ur, fr] = cr.split("?iv="), dr = secp256k1$1.getSharedSecret(lr, "02" + ar), gr = getNormalizedX$2(dr), mr = await crypto.subtle.importKey("raw", gr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$2.decode(ur), yr = base64$2.decode(fr), kr = await crypto.subtle.decrypt({ name: "AES-CBC", iv: yr }, mr, vr);
  return utf8Decoder$2.decode(kr);
}
function getNormalizedX$2(lr) {
  return lr.slice(1, 33);
}
var nip05_exports$2 = {};
__export$2(nip05_exports$2, {
  NIP05_REGEX: () => NIP05_REGEX$2,
  queryProfile: () => queryProfile$2,
  searchDomain: () => searchDomain$2,
  useFetchImplementation: () => useFetchImplementation$2
});
var NIP05_REGEX$2 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$2;
try {
  _fetch$2 = fetch;
} catch (lr) {
}
function useFetchImplementation$2(lr) {
  _fetch$2 = lr;
}
async function searchDomain$2(lr, ar = "") {
  try {
    return (await (await _fetch$2(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile$2(lr) {
  const ar = lr.match(NIP05_REGEX$2);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch$2(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result$2(await dr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result$2(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip06_exports$1 = {};
__export$2(nip06_exports$1, {
  generateSeedWords: () => generateSeedWords$1,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords$1,
  validateWords: () => validateWords$1
});
function privateKeyFromSeedWords$1(lr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(lr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$4(ur);
}
function generateSeedWords$1() {
  return generateMnemonic(wordlist);
}
function validateWords$1(lr) {
  return validateMnemonic(lr, wordlist);
}
var nip10_exports$2 = {};
__export$2(nip10_exports$2, {
  parse: () => parse$2
});
function parse$2(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, gr, mr, vr] = fr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, kr = ur === 0, _r = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (kr) {
      ar.root = yr;
      continue;
    }
    if (_r) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip13_exports$2 = {};
__export$2(nip13_exports$2, {
  getPow: () => getPow$2,
  minePow: () => minePow$2
});
function getPow$2(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$2(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash$2(ur), getPow$2(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$2 = {};
__export$2(nip18_exports$2, {
  finishRepostEvent: () => finishRepostEvent$2,
  getRepostedEvent: () => getRepostedEvent$2,
  getRepostedEventPointer: () => getRepostedEventPointer$2
});
function finishRepostEvent$2(lr, ar, cr, ur) {
  var fr;
  return finishEvent$1(
    {
      kind: 6,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$2(lr) {
  if (lr.kind !== 6)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent$2(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer$2(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifySignature$1(ur)))
    return ur;
}
var nip21_exports$2 = {};
__export$2(nip21_exports$2, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$2,
  parse: () => parse2$2,
  test: () => test$2
});
var NOSTR_URI_REGEX$2 = new RegExp(`nostr:(${BECH32_REGEX$2.source})`);
function test$2(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX$2.source}$`).test(lr);
}
function parse2$2(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX$2.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$3(ar[1])
  };
}
var nip25_exports$2 = {};
__export$2(nip25_exports$2, {
  finishReactionEvent: () => finishReactionEvent$2,
  getReactedEventPointer: () => getReactedEventPointer$2
});
function finishReactionEvent$2(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finishEvent$1(
    {
      ...lr,
      kind: 7,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer$2(lr) {
  if (lr.kind !== 7)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip26_exports$1 = {};
__export$2(nip26_exports$1, {
  createDelegation: () => createDelegation$1,
  getDelegator: () => getDelegator$1
});
function createDelegation$1(lr, ar) {
  let cr = [];
  (ar.kind || -1) >= 0 && cr.push(`kind=${ar.kind}`), ar.until && cr.push(`created_at<${ar.until}`), ar.since && cr.push(`created_at>${ar.since}`);
  let ur = cr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let fr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), dr = bytesToHex$4(schnorr$1.sign(fr, lr));
  return {
    from: getPublicKey$1(lr),
    to: ar.pubkey,
    cond: ur,
    sig: dr
  };
}
function getDelegator$1(lr) {
  let ar = lr.tags.find((mr) => mr[0] === "delegation" && mr.length >= 4);
  if (!ar)
    return null;
  let cr = ar[1], ur = ar[2], fr = ar[3], dr = ur.split("&");
  for (let mr = 0; mr < dr.length; mr++) {
    let [vr, yr, kr] = dr[mr].split(/\b/);
    if (!(vr === "kind" && yr === "=" && lr.kind === parseInt(kr))) {
      if (vr === "created_at" && yr === "<" && lr.created_at < parseInt(kr))
        continue;
      if (vr === "created_at" && yr === ">" && lr.created_at > parseInt(kr))
        continue;
      return null;
    }
  }
  let gr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${lr.pubkey}:${ur}`));
  return schnorr$1.verify(fr, gr, cr) ? cr : null;
}
var nip27_exports$2 = {};
__export$2(nip27_exports$2, {
  matchAll: () => matchAll$2,
  regex: () => regex$2,
  replaceAll: () => replaceAll$2
});
var regex$2 = () => new RegExp(`\\b${NOSTR_URI_REGEX$2.source}\\b`, "g");
function* matchAll$2(lr) {
  const ar = lr.matchAll(regex$2());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$3(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$2(lr, ar) {
  return lr.replaceAll(regex$2(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$3(ur)
  }));
}
var nip28_exports$2 = {};
__export$2(nip28_exports$2, {
  channelCreateEvent: () => channelCreateEvent$2,
  channelHideMessageEvent: () => channelHideMessageEvent$2,
  channelMessageEvent: () => channelMessageEvent$2,
  channelMetadataEvent: () => channelMetadataEvent$2,
  channelMuteUserEvent: () => channelMuteUserEvent$2
});
var channelCreateEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 40,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 41,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent$2 = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finishEvent$1(
    {
      kind: 42,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 43,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent$2 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 44,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip39_exports$2 = {};
__export$2(nip39_exports$2, {
  useFetchImplementation: () => useFetchImplementation2$2,
  validateGithub: () => validateGithub$2
});
var _fetch2$2;
try {
  _fetch2$2 = fetch;
} catch (lr) {
}
function useFetchImplementation2$2(lr) {
  _fetch2$2 = lr;
}
async function validateGithub$2(lr, ar, cr) {
  try {
    return await (await _fetch2$2(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$2 = {};
__export$2(nip42_exports$2, {
  authenticate: () => authenticate$1
});
var authenticate$1 = async ({
  challenge: lr,
  relay: ar,
  sign: cr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", lr]
    ],
    content: ""
  };
  return ar.auth(await cr(ur));
}, nip44_exports$2 = {};
__export$2(nip44_exports$2, {
  decrypt: () => decrypt2$2,
  encrypt: () => encrypt2$2,
  utils: () => utils$3
});
var utils$3 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(lr, ar) {
      return secp256k1$1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(lr, ar) {
      const cr = hkdf$1(sha256$4, lr, ar, "nip44-v2", 76);
      return {
        encryption: cr.subarray(0, 32),
        nonce: cr.subarray(32, 44),
        auth: cr.subarray(44, 76)
      };
    },
    calcPadding(lr) {
      if (!Number.isSafeInteger(lr) || lr < 0)
        throw new Error("expected positive integer");
      if (lr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
      return cr * (Math.floor((lr - 1) / cr) + 1);
    },
    pad(lr) {
      const ar = utf8Encoder$2.encode(lr), cr = ar.length;
      if (cr < 1 || cr >= utils$3.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$3.v2.calcPadding(cr), fr = new Uint8Array(ur - cr), dr = new Uint8Array(2);
      return new DataView(dr.buffer).setUint16(0, cr), concatBytes$5(dr, ar, fr);
    },
    unpad(lr) {
      const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
      if (ar === 0 || cr.length !== ar || lr.length !== 2 + utils$3.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$2.decode(cr);
    }
  }
};
function encrypt2$2(lr, ar, cr = {}) {
  var yr, kr;
  const ur = (yr = cr.version) != null ? yr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const fr = (kr = cr.salt) != null ? kr : randomBytes$4(32);
  ensureBytes$1(fr, 32);
  const dr = utils$3.v2.getMessageKeys(lr, fr), gr = utils$3.v2.pad(ar), mr = chacha20(dr.encryption, dr.nonce, gr), vr = hmac$3(sha256$4, dr.auth, mr);
  return base64$2.encode(concatBytes$5(new Uint8Array([ur]), fr, mr, vr));
}
function decrypt2$2(lr, ar) {
  const cr = utils$3.v2;
  ensureBytes$1(lr, 32);
  const ur = ar.length;
  if (ur < cr.minCiphertextSize || ur >= cr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let fr;
  try {
    fr = base64$2.decode(ar);
  } catch (xr) {
    throw new Error("invalid base64: " + xr.message);
  }
  const dr = fr.subarray(0, 1)[0];
  if (dr !== 2)
    throw new Error("unknown encryption version " + dr);
  const gr = fr.subarray(1, 33), mr = fr.subarray(33, -32), vr = fr.subarray(-32), yr = cr.getMessageKeys(lr, gr), kr = hmac$3(sha256$4, yr.auth, mr);
  if (!equalBytes$1(kr, vr))
    throw new Error("invalid MAC");
  const _r = chacha20(yr.encryption, yr.nonce, mr);
  return cr.unpad(_r);
}
var nip47_exports$2 = {};
__export$2(nip47_exports$2, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$2,
  parseConnectionString: () => parseConnectionString$2
});
function parseConnectionString$2(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent$2({
  pubkey: lr,
  secret: ar,
  invoice: cr
}) {
  const fr = await encrypt$3(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finishEvent$1(dr, ar);
}
var nip57_exports$2 = {};
__export$2(nip57_exports$2, {
  getZapEndpoint: () => getZapEndpoint$2,
  makeZapReceipt: () => makeZapReceipt$2,
  makeZapRequest: () => makeZapRequest$2,
  useFetchImplementation: () => useFetchImplementation3$2,
  validateZapRequest: () => validateZapRequest$2
});
var _fetch3$2;
try {
  _fetch3$2 = fetch;
} catch (lr) {
}
function useFetchImplementation3$2(lr) {
  _fetch3$2 = lr;
}
async function getZapEndpoint$2(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: gr } = bech32$3.decode(cr, 1e3), mr = bech32$3.fromWords(gr);
      ar = utf8Decoder$2.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = `https://${mr}/.well-known/lnurlp/${gr}`;
    } else
      return null;
    let dr = await (await _fetch3$2(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$2({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest$2(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$2(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature$1(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, gr]) => dr === "p" && gr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, gr]) => dr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, gr]) => dr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$2({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let dr = JSON.parse(lr).tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["bolt11", cr], ["description", lr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports$2 = {};
__export$2(nip98_exports$2, {
  getToken: () => getToken$2,
  unpackEventFromToken: () => unpackEventFromToken$2,
  validateEvent: () => validateEvent2$2,
  validateToken: () => validateToken$2
});
var _authorizationScheme$2 = "Nostr ";
async function getToken$2(lr, ar, cr, ur = !1) {
  if (!lr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const fr = getBlankEvent$1(
    27235
    /* HttpAuth */
  );
  fr.tags = [
    ["u", lr],
    ["method", ar]
  ], fr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const dr = await cr(fr);
  return (ur ? _authorizationScheme$2 : "") + base64$2.encode(utf8Encoder$2.encode(JSON.stringify(dr)));
}
async function validateToken$2(lr, ar, cr) {
  const ur = await unpackEventFromToken$2(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2$2(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken$2(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme$2, "");
  const ar = utf8Decoder$2.decode(base64$2.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$2(lr, ar, cr) {
  if (!lr)
    throw new Error("Invalid nostr event");
  if (!verifySignature$1(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (lr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!lr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = lr.tags.find((dr) => dr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const fr = lr.tags.find((dr) => dr[0] === "method");
  if ((fr == null ? void 0 : fr.length) !== 1 && (fr == null ? void 0 : fr[1].toLowerCase()) !== cr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
var commonjsGlobal$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function getDefaultExportFromCjs(lr) {
  return lr && lr.__esModule && Object.prototype.hasOwnProperty.call(lr, "default") ? lr.default : lr;
}
function getAugmentedNamespace(lr) {
  if (lr.__esModule)
    return lr;
  var ar = lr.default;
  if (typeof ar == "function") {
    var cr = function ur() {
      return this instanceof ur ? Reflect.construct(ar, arguments, this.constructor) : ar.apply(this, arguments);
    };
    cr.prototype = ar.prototype;
  } else
    cr = {};
  return Object.defineProperty(cr, "__esModule", { value: !0 }), Object.keys(lr).forEach(function(ur) {
    var fr = Object.getOwnPropertyDescriptor(lr, ur);
    Object.defineProperty(cr, ur, fr.get ? fr : {
      enumerable: !0,
      get: function() {
        return lr[ur];
      }
    });
  }), cr;
}
var lib$2 = {}, types = {};
Object.defineProperty(types, "__esModule", { value: !0 });
var ee$2 = {}, taskCollection$1 = {}, taskCollection = {}, bakeCollection = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.bakeCollectionVariadic = exports.bakeCollectionAwait = exports.bakeCollection = exports.BAKED_EMPTY_FUNC = void 0, exports.BAKED_EMPTY_FUNC = function() {
  };
  var FORLOOP_FALLBACK = 1500;
  function generateArgsDefCode(lr) {
    var ar = "";
    if (lr === 0)
      return ar;
    for (var cr = 0; cr < lr - 1; ++cr)
      ar += "arg" + String(cr) + ", ";
    return ar += "arg" + String(lr - 1), ar;
  }
  function generateBodyPartsCode(lr, ar) {
    for (var cr = "", ur = "", fr = 0; fr < ar; ++fr)
      cr += "var f".concat(fr, " = collection[").concat(fr, `];
`), ur += "f".concat(fr, "(").concat(lr, `)
`);
    return { funcDefCode: cr, funcCallCode: ur };
  }
  function generateBodyPartsVariadicCode(lr) {
    for (var ar = "", cr = "", ur = 0; ur < lr; ++ur)
      ar += "var f".concat(ur, " = collection[").concat(ur, `];
`), cr += "f".concat(ur, `.apply(undefined, arguments)
`);
    return { funcDefCode: ar, funcCallCode: cr };
  }
  function bakeCollection(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                `).concat(funcCallCode, `
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      collection.length % 10 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                        collection[i+4](`).concat(argsDefCode, `);
                        collection[i+5](`).concat(argsDefCode, `);
                        collection[i+6](`).concat(argsDefCode, `);
                        collection[i+7](`).concat(argsDefCode, `);
                        collection[i+8](`).concat(argsDefCode, `);
                        collection[i+9](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 4 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 3 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                    }
                });
            })`) : funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode, `);
                    }
                });
            })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollection = bakeCollection;
  function bakeCollectionAwait(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                return Promise.all([ `).concat(funcCallCode, ` ]);
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      funcFactoryCode = `(function(collection) {
            return (function(`.concat(argsDefCode, `) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode, `);
                }
                return Promise.all(promises);
            });
        })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionAwait = bakeCollectionAwait;
  function bakeCollectionVariadic(collection) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var _a = generateBodyPartsVariadicCode(collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function() {
                `).concat(funcCallCode, `
            });
        })`);
    } else
      funcFactoryCode = `(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionVariadic = bakeCollectionVariadic;
})(bakeCollection);
var __spreadArray$3 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
};
Object.defineProperty(taskCollection, "__esModule", { value: !0 });
taskCollection.TaskCollection = taskCollection._fast_remove_single = void 0;
var bake_collection_1 = bakeCollection;
function push_norebuild(lr, ar) {
  var cr = this.length;
  if (cr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(lr), this.length++;
  else if (ar) {
    if (cr === 1) {
      var fr = Array(1 + arguments.length);
      fr.push(fr), fr.push.apply(fr, arguments), this._tasks = fr;
    } else {
      var fr = Array(arguments.length);
      fr.push.apply(fr, arguments), this._tasks = fr;
    }
    this.length += arguments.length;
  } else
    cr === 1 ? this._tasks = [this._tasks, lr] : this._tasks = lr, this.length++;
}
function push_rebuild(lr, ar) {
  var cr = this.length;
  if (cr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(lr), this.length++;
  else if (ar) {
    if (cr === 1) {
      var fr = Array(1 + arguments.length);
      fr.push(fr), fr.push.apply(fr, arguments), this._tasks = fr;
    } else {
      var fr = Array(arguments.length);
      fr.push.apply(fr, arguments), this._tasks = fr;
    }
    this.length += arguments.length;
  } else
    cr === 1 ? this._tasks = [this._tasks, lr] : this._tasks = lr, this.length++;
  this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function _fast_remove_single(lr, ar) {
  ar !== -1 && (ar === 0 ? lr.shift() : ar === lr.length - 1 ? lr.length = lr.length - 1 : lr.splice(ar, 1));
}
taskCollection._fast_remove_single = _fast_remove_single;
function removeLast_norebuild(lr) {
  this.length !== 0 && (this.length === 1 ? this._tasks === lr && (this.length = 0) : (_fast_remove_single(this._tasks, this._tasks.lastIndexOf(lr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length));
}
function removeLast_rebuild(lr) {
  if (this.length !== 0) {
    if (this.length === 1)
      if (this._tasks === lr && (this.length = 0), this.firstEmitBuildStrategy) {
        this.call = bake_collection_1.BAKED_EMPTY_FUNC;
        return;
      } else {
        this.rebuild();
        return;
      }
    else
      _fast_remove_single(this._tasks, this._tasks.lastIndexOf(lr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length;
    this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
  }
}
function insert_norebuild(lr) {
  for (var ar, cr = [], ur = 1; ur < arguments.length; ur++)
    cr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = cr, this.length = 1) : this.length === 1 ? (cr.unshift(this._tasks), this._tasks = cr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([lr, 0], cr, !1)), this.length = this._tasks.length);
}
function insert_rebuild(lr) {
  for (var ar, cr = [], ur = 1; ur < arguments.length; ur++)
    cr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = cr, this.length = 1) : this.length === 1 ? (cr.unshift(this._tasks), this._tasks = cr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([lr, 0], cr, !1)), this.length = this._tasks.length), this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function rebuild_noawait() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollection)(this._tasks, this.argsNum);
}
function rebuild_await() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollectionAwait)(this._tasks, this.argsNum);
}
function rebuild_on_first_call() {
  this.rebuild(), this.call.apply(void 0, arguments);
}
var TaskCollection = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      cr === void 0 && (cr = !0), ur === void 0 && (ur = null), fr === void 0 && (fr = !1), this.awaitTasks = fr, this.call = bake_collection_1.BAKED_EMPTY_FUNC, this.argsNum = ar, this.firstEmitBuildStrategy = !0, fr ? this.rebuild = rebuild_await.bind(this) : this.rebuild = rebuild_noawait.bind(this), this.setAutoRebuild(cr), ur ? typeof ur == "function" ? (this._tasks = ur, this.length = 1) : (this._tasks = ur, this.length = ur.length) : (this._tasks = null, this.length = 0), cr && this.rebuild();
    }
    return lr;
  }()
);
taskCollection.TaskCollection = TaskCollection;
function fastClear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function clear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function growArgsNum(lr) {
  this.argsNum < lr && (this.argsNum = lr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
function setAutoRebuild(lr) {
  lr ? (this.push = push_rebuild.bind(this), this.insert = insert_rebuild.bind(this), this.removeLast = removeLast_rebuild.bind(this)) : (this.push = push_norebuild.bind(this), this.insert = insert_norebuild.bind(this), this.removeLast = removeLast_norebuild.bind(this));
}
function tasksAsArray() {
  return this.length === 0 ? [] : this.length === 1 ? [this._tasks] : this._tasks;
}
function setTasks(lr) {
  lr.length === 0 ? (this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC) : lr.length === 1 ? (this.length = 1, this.call = lr[0], this._tasks = lr[0]) : (this.length = lr.length, this._tasks = lr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
TaskCollection.prototype.fastClear = fastClear;
TaskCollection.prototype.clear = clear;
TaskCollection.prototype.growArgsNum = growArgsNum;
TaskCollection.prototype.setAutoRebuild = setAutoRebuild;
TaskCollection.prototype.tasksAsArray = tasksAsArray;
TaskCollection.prototype.setTasks = setTasks;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr);
    var mr = Object.getOwnPropertyDescriptor(fr, dr);
    (!mr || ("get" in mr ? !fr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr), ur[gr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(taskCollection, lr);
})(taskCollection$1);
var utils$2 = {};
Object.defineProperty(utils$2, "__esModule", { value: !0 });
utils$2.nullObj = void 0;
function nullObj() {
  var lr = {};
  return lr.__proto__ = null, lr.prototype = null, lr;
}
utils$2.nullObj = nullObj;
var __spreadArray$2 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
};
Object.defineProperty(ee$2, "__esModule", { value: !0 });
ee$2.EventEmitter = void 0;
var task_collection_1 = taskCollection$1, utils_1$1 = utils$2;
function emit(lr, ar, cr, ur, fr, dr) {
  var gr = this.events[lr];
  return gr ? gr.length === 0 ? !1 : (gr.argsNum < 6 ? gr.call(ar, cr, ur, fr, dr) : gr.call.apply(void 0, arguments), !0) : !1;
}
function emitHasOnce(lr, ar, cr, ur, fr, dr) {
  var gr = this.events[lr];
  if (gr) {
    if (gr.length === 0)
      return !1;
    gr.argsNum < 6 ? gr.call(ar, cr, ur, fr, dr) : gr.call.apply(void 0, arguments);
  }
  var mr = this.onceEvents[lr];
  if (mr) {
    if (typeof mr == "function")
      this.onceEvents[lr] = void 0, arguments.length < 6 ? mr(ar, cr, ur, fr, dr) : mr.apply(void 0, arguments);
    else {
      var vr = mr;
      if (this.onceEvents[lr] = void 0, arguments.length < 6)
        for (var yr = 0; yr < vr.length; ++yr)
          vr[yr](ar, cr, ur, fr, dr);
      else
        for (var yr = 0; yr < vr.length; ++yr)
          vr[yr].apply(void 0, arguments);
    }
    return !0;
  }
  return !!gr;
}
var EventEmitter$1 = (
  /** @class */
  function() {
    function lr() {
      this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set(), this.maxListeners = 1 / 0;
    }
    return Object.defineProperty(lr.prototype, "_eventsCount", {
      get: function() {
        return this.eventNames().length;
      },
      enumerable: !1,
      configurable: !0
    }), lr;
  }()
);
ee$2.EventEmitter = EventEmitter$1;
function once(lr, ar) {
  switch (this.emit === emit && (this.emit = emitHasOnce), typeof this.onceEvents[lr]) {
    case "undefined":
      this.onceEvents[lr] = ar, typeof lr == "symbol" && this._symbolKeys.add(lr);
      break;
    case "function":
      this.onceEvents[lr] = [this.onceEvents[lr], ar];
      break;
    case "object":
      this.onceEvents[lr].push(ar);
  }
  return this;
}
function addListener(lr, ar, cr) {
  if (cr === void 0 && (cr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[lr];
  return ur ? (ur.push(ar), ur.growArgsNum(cr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(lr), '" event!'))) : (this.events[lr] = new task_collection_1.TaskCollection(cr, !0, ar, !1), typeof lr == "symbol" && this._symbolKeys.add(lr)), this;
}
function removeListener(lr, ar) {
  var cr = this.events[lr];
  cr && cr.removeLast(ar);
  var ur = this.onceEvents[lr];
  return ur && (typeof ur == "function" ? this.onceEvents[lr] = void 0 : typeof ur == "object" && (ur.length === 1 && ur[0] === ar ? this.onceEvents[lr] = void 0 : (0, task_collection_1._fast_remove_single)(ur, ur.lastIndexOf(ar)))), this;
}
function hasListeners(lr) {
  return this.events[lr] && !!this.events[lr].length;
}
function prependListener(lr, ar, cr) {
  if (cr === void 0 && (cr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[lr];
  return !ur || !(ur instanceof task_collection_1.TaskCollection) ? (ur = this.events[lr] = new task_collection_1.TaskCollection(cr, !0, ar, !1), typeof lr == "symbol" && this._symbolKeys.add(lr)) : (ur.insert(0, ar), ur.growArgsNum(cr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(lr), '" event!'))), this;
}
function prependOnceListener(lr, ar) {
  this.emit === emit && (this.emit = emitHasOnce);
  var cr = this.onceEvents[lr];
  if (!cr || typeof cr != "object")
    cr = this.onceEvents[lr] = [ar], typeof lr == "symbol" && this._symbolKeys.add(lr);
  else
    throw new Error("FIXME");
  return this;
}
function removeAllListeners(lr) {
  return lr === void 0 ? (this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set()) : (this.events[lr] = void 0, this.onceEvents[lr] = void 0, typeof lr == "symbol" && this._symbolKeys.delete(lr)), this;
}
function setMaxListeners(lr) {
  return this.maxListeners = lr, this;
}
function getMaxListeners() {
  return this.maxListeners;
}
function listeners(lr) {
  return this.emit === emit ? this.events[lr] ? this.events[lr].tasksAsArray().slice() : [] : this.events[lr] && this.onceEvents[lr] ? __spreadArray$2(__spreadArray$2([], this.events[lr].tasksAsArray(), !0), typeof this.onceEvents[lr] == "function" ? [this.onceEvents[lr]] : this.onceEvents[lr], !0) : this.events[lr] ? this.events[lr].tasksAsArray() : this.onceEvents[lr] ? typeof this.onceEvents[lr] == "function" ? [this.onceEvents[lr]] : this.onceEvents[lr] : [];
}
function eventNames() {
  var lr = this;
  if (this.emit === emit) {
    var ar = Object.keys(this.events);
    return __spreadArray$2(__spreadArray$2([], ar, !0), Array.from(this._symbolKeys), !0).filter(function(ur) {
      return ur in lr.events && lr.events[ur] && lr.events[ur].length;
    });
  } else {
    var ar = Object.keys(this.events).filter(function(fr) {
      return lr.events[fr] && lr.events[fr].length;
    }), cr = Object.keys(this.onceEvents).filter(function(fr) {
      return lr.onceEvents[fr] && lr.onceEvents[fr].length;
    });
    return __spreadArray$2(__spreadArray$2(__spreadArray$2([], ar, !0), cr, !0), Array.from(this._symbolKeys).filter(function(fr) {
      return fr in lr.events && lr.events[fr] && lr.events[fr].length || fr in lr.onceEvents && lr.onceEvents[fr] && lr.onceEvents[fr].length;
    }), !0);
  }
}
function listenerCount(lr) {
  return this.emit === emit ? this.events[lr] && this.events[lr].length || 0 : (this.events[lr] && this.events[lr].length || 0) + (this.onceEvents[lr] && this.onceEvents[lr].length || 0);
}
EventEmitter$1.prototype.emit = emit;
EventEmitter$1.prototype.on = addListener;
EventEmitter$1.prototype.once = once;
EventEmitter$1.prototype.addListener = addListener;
EventEmitter$1.prototype.removeListener = removeListener;
EventEmitter$1.prototype.hasListeners = hasListeners;
EventEmitter$1.prototype.prependListener = prependListener;
EventEmitter$1.prototype.prependOnceListener = prependOnceListener;
EventEmitter$1.prototype.off = removeListener;
EventEmitter$1.prototype.removeAllListeners = removeAllListeners;
EventEmitter$1.prototype.setMaxListeners = setMaxListeners;
EventEmitter$1.prototype.getMaxListeners = getMaxListeners;
EventEmitter$1.prototype.listeners = listeners;
EventEmitter$1.prototype.eventNames = eventNames;
EventEmitter$1.prototype.listenerCount = listenerCount;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr);
    var mr = Object.getOwnPropertyDescriptor(fr, dr);
    (!mr || ("get" in mr ? !fr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr), ur[gr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(types, lr), cr(ee$2, lr);
})(lib$2);
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var lr = 1e3, ar = lr * 60, cr = ar * 60, ur = cr * 24, fr = ur * 7, dr = ur * 365.25;
  ms = function(kr, _r) {
    _r = _r || {};
    var xr = typeof kr;
    if (xr === "string" && kr.length > 0)
      return gr(kr);
    if (xr === "number" && isFinite(kr))
      return _r.long ? vr(kr) : mr(kr);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(kr)
    );
  };
  function gr(kr) {
    if (kr = String(kr), !(kr.length > 100)) {
      var _r = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        kr
      );
      if (_r) {
        var xr = parseFloat(_r[1]), Sr = (_r[2] || "ms").toLowerCase();
        switch (Sr) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return xr * dr;
          case "weeks":
          case "week":
          case "w":
            return xr * fr;
          case "days":
          case "day":
          case "d":
            return xr * ur;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return xr * cr;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return xr * ar;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return xr * lr;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return xr;
          default:
            return;
        }
      }
    }
  }
  function mr(kr) {
    var _r = Math.abs(kr);
    return _r >= ur ? Math.round(kr / ur) + "d" : _r >= cr ? Math.round(kr / cr) + "h" : _r >= ar ? Math.round(kr / ar) + "m" : _r >= lr ? Math.round(kr / lr) + "s" : kr + "ms";
  }
  function vr(kr) {
    var _r = Math.abs(kr);
    return _r >= ur ? yr(kr, _r, ur, "day") : _r >= cr ? yr(kr, _r, cr, "hour") : _r >= ar ? yr(kr, _r, ar, "minute") : _r >= lr ? yr(kr, _r, lr, "second") : kr + " ms";
  }
  function yr(kr, _r, xr, Sr) {
    var Er = _r >= xr * 1.5;
    return Math.round(kr / xr) + " " + Sr + (Er ? "s" : "");
  }
  return ms;
}
function setup(lr) {
  cr.debug = cr, cr.default = cr, cr.coerce = vr, cr.disable = dr, cr.enable = fr, cr.enabled = gr, cr.humanize = requireMs(), cr.destroy = yr, Object.keys(lr).forEach((kr) => {
    cr[kr] = lr[kr];
  }), cr.names = [], cr.skips = [], cr.formatters = {};
  function ar(kr) {
    let _r = 0;
    for (let xr = 0; xr < kr.length; xr++)
      _r = (_r << 5) - _r + kr.charCodeAt(xr), _r |= 0;
    return cr.colors[Math.abs(_r) % cr.colors.length];
  }
  cr.selectColor = ar;
  function cr(kr) {
    let _r, xr = null, Sr, Er;
    function Cr(...Tr) {
      if (!Cr.enabled)
        return;
      const Ar = Cr, Ir = Number(/* @__PURE__ */ new Date()), Mr = Ir - (_r || Ir);
      Ar.diff = Mr, Ar.prev = _r, Ar.curr = Ir, _r = Ir, Tr[0] = cr.coerce(Tr[0]), typeof Tr[0] != "string" && Tr.unshift("%O");
      let Hr = 0;
      Tr[0] = Tr[0].replace(/%([a-zA-Z%])/g, (zr, Gr) => {
        if (zr === "%%")
          return "%";
        Hr++;
        const Xr = cr.formatters[Gr];
        if (typeof Xr == "function") {
          const Jr = Tr[Hr];
          zr = Xr.call(Ar, Jr), Tr.splice(Hr, 1), Hr--;
        }
        return zr;
      }), cr.formatArgs.call(Ar, Tr), (Ar.log || cr.log).apply(Ar, Tr);
    }
    return Cr.namespace = kr, Cr.useColors = cr.useColors(), Cr.color = cr.selectColor(kr), Cr.extend = ur, Cr.destroy = cr.destroy, Object.defineProperty(Cr, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => xr !== null ? xr : (Sr !== cr.namespaces && (Sr = cr.namespaces, Er = cr.enabled(kr)), Er),
      set: (Tr) => {
        xr = Tr;
      }
    }), typeof cr.init == "function" && cr.init(Cr), Cr;
  }
  function ur(kr, _r) {
    const xr = cr(this.namespace + (typeof _r == "undefined" ? ":" : _r) + kr);
    return xr.log = this.log, xr;
  }
  function fr(kr) {
    cr.save(kr), cr.namespaces = kr, cr.names = [], cr.skips = [];
    let _r;
    const xr = (typeof kr == "string" ? kr : "").split(/[\s,]+/), Sr = xr.length;
    for (_r = 0; _r < Sr; _r++)
      xr[_r] && (kr = xr[_r].replace(/\*/g, ".*?"), kr[0] === "-" ? cr.skips.push(new RegExp("^" + kr.slice(1) + "$")) : cr.names.push(new RegExp("^" + kr + "$")));
  }
  function dr() {
    const kr = [
      ...cr.names.map(mr),
      ...cr.skips.map(mr).map((_r) => "-" + _r)
    ].join(",");
    return cr.enable(""), kr;
  }
  function gr(kr) {
    if (kr[kr.length - 1] === "*")
      return !0;
    let _r, xr;
    for (_r = 0, xr = cr.skips.length; _r < xr; _r++)
      if (cr.skips[_r].test(kr))
        return !1;
    for (_r = 0, xr = cr.names.length; _r < xr; _r++)
      if (cr.names[_r].test(kr))
        return !0;
    return !1;
  }
  function mr(kr) {
    return kr.toString().substring(2, kr.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function vr(kr) {
    return kr instanceof Error ? kr.stack || kr.message : kr;
  }
  function yr() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return cr.enable(cr.load()), cr;
}
var common = setup;
(function(lr, ar) {
  ar.formatArgs = ur, ar.save = fr, ar.load = dr, ar.useColors = cr, ar.storage = gr(), ar.destroy = (() => {
    let vr = !1;
    return () => {
      vr || (vr = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), ar.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function cr() {
    return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function ur(vr) {
    if (vr[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + vr[0] + (this.useColors ? "%c " : " ") + "+" + lr.exports.humanize(this.diff), !this.useColors)
      return;
    const yr = "color: " + this.color;
    vr.splice(1, 0, yr, "color: inherit");
    let kr = 0, _r = 0;
    vr[0].replace(/%[a-zA-Z%]/g, (xr) => {
      xr !== "%%" && (kr++, xr === "%c" && (_r = kr));
    }), vr.splice(_r, 0, yr);
  }
  ar.log = console.debug || console.log || (() => {
  });
  function fr(vr) {
    try {
      vr ? ar.storage.setItem("debug", vr) : ar.storage.removeItem("debug");
    } catch (yr) {
    }
  }
  function dr() {
    let vr;
    try {
      vr = ar.storage.getItem("debug");
    } catch (yr) {
    }
    return !vr && typeof process != "undefined" && "env" in process && (vr = process.env.DEBUG), vr;
  }
  function gr() {
    try {
      return localStorage;
    } catch (vr) {
    }
  }
  lr.exports = common(ar);
  const { formatters: mr } = lr.exports;
  mr.j = function(vr) {
    try {
      return JSON.stringify(vr);
    } catch (yr) {
      return "[UnexpectedJSONParseError]: " + yr.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const _debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var dist$9 = {}, LRUCache$1 = {}, LRUCacheNode$1 = {};
Object.defineProperty(LRUCacheNode$1, "__esModule", { value: !0 });
LRUCacheNode$1.LRUCacheNode = void 0;
class LRUCacheNode {
  constructor(ar, cr, ur) {
    const { entryExpirationTimeInMS: fr = null, next: dr = null, prev: gr = null, onEntryEvicted: mr, onEntryMarkedAsMostRecentlyUsed: vr, clone: yr, cloneFn: kr } = ur != null ? ur : {};
    if (typeof fr == "number" && (fr <= 0 || Number.isNaN(fr)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.clone = yr != null ? yr : !1, this.cloneFn = kr != null ? kr : this.defaultClone, this.key = ar, this.internalValue = this.clone ? this.cloneFn(cr) : cr, this.created = Date.now(), this.entryExpirationTimeInMS = fr, this.next = dr, this.prev = gr, this.onEntryEvicted = mr, this.onEntryMarkedAsMostRecentlyUsed = vr;
  }
  get value() {
    return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;
  }
  get isExpired() {
    return typeof this.entryExpirationTimeInMS == "number" && Date.now() - this.created > this.entryExpirationTimeInMS;
  }
  invokeOnEvicted() {
    if (this.onEntryEvicted) {
      const { key: ar, value: cr, isExpired: ur } = this;
      this.onEntryEvicted({ key: ar, value: cr, isExpired: ur });
    }
  }
  invokeOnEntryMarkedAsMostRecentlyUsed() {
    if (this.onEntryMarkedAsMostRecentlyUsed) {
      const { key: ar, value: cr } = this;
      this.onEntryMarkedAsMostRecentlyUsed({ key: ar, value: cr });
    }
  }
  defaultClone(ar) {
    return typeof ar == "boolean" || typeof ar == "string" || typeof ar == "number" ? ar : JSON.parse(JSON.stringify(ar));
  }
}
LRUCacheNode$1.LRUCacheNode = LRUCacheNode;
Object.defineProperty(LRUCache$1, "__esModule", { value: !0 });
LRUCache$1.LRUCache = void 0;
const LRUCacheNode_1 = LRUCacheNode$1;
class LRUCache {
  /**
   * Creates a new instance of the LRUCache.
   *
   * @param options Additional configuration options for the LRUCache.
   *
   * @example
   * ```typescript
   * // No options.
   * const cache = new LRUCache();
   *
   * // With options.
   * const cache = new LRUCache({
   *  entryExpirationTimeInMS: 10000
   * });
   * ```
   */
  constructor(ar) {
    this.lookupTable = /* @__PURE__ */ new Map(), this.head = null, this.tail = null;
    const { maxSize: cr = 25, entryExpirationTimeInMS: ur = null, onEntryEvicted: fr, onEntryMarkedAsMostRecentlyUsed: dr, cloneFn: gr, clone: mr } = ar != null ? ar : {};
    if (Number.isNaN(cr) || cr <= 0)
      throw new Error("maxSize must be greater than 0.");
    if (typeof ur == "number" && (ur <= 0 || Number.isNaN(ur)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.maxSizeInternal = cr, this.entryExpirationTimeInMS = ur, this.onEntryEvicted = fr, this.onEntryMarkedAsMostRecentlyUsed = dr, this.clone = mr, this.cloneFn = gr;
  }
  /**
   * Returns the number of entries in the LRUCache object.
   * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.
   *
   * @returns The number of entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * cache.set('testKey', 'testValue');
   *
   * const size = cache.size;
   *
   * // Will log 1
   * console.log(size);
   * ```
   */
  get size() {
    return this.cleanCache(), this.lookupTable.size;
  }
  /**
   * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.
   *
   * @returns The number of entries that can still be added without evicting existing entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const remainingSize = cache.remainingSize;
   *
   * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.
   * console.log(remainingSize);
   * ```
   */
  get remainingSize() {
    return this.maxSizeInternal - this.size;
  }
  /**
   * Returns the most recently used (newest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the newest node is expired, it will be removed.
   *
   * @returns The most recently used (newest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const newest = cache.newest;
   *
   * // Will log testValue
   * console.log(newest.value);
   *
   * // Will log testKey
   * console.log(newest.key);
   * ```
   */
  get newest() {
    return this.head ? this.head.isExpired ? (this.removeNodeFromListAndLookupTable(this.head), this.newest) : this.mapNodeToEntry(this.head) : null;
  }
  /**
   * Returns the least recently used (oldest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the oldest node is expired, it will be removed.
   *
   * @returns The least recently used (oldest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const oldest = cache.oldest;
   *
   * // Will log testValue
   * console.log(oldest.value);
   *
   * // Will log testKey
   * console.log(oldest.key);
   * ```
   */
  get oldest() {
    return this.tail ? this.tail.isExpired ? (this.removeNodeFromListAndLookupTable(this.tail), this.oldest) : this.mapNodeToEntry(this.tail) : null;
  }
  /**
   * Gets or sets the maxSize of the cache.
   * This will evict the least recently used entries if needed to reach new maxSize.
   *
   * @param value The new value for maxSize. Must be greater than 0.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * // Will be 10
   * const maxSize = cache.maxSize;
   *
   * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.
   * cache.maxSize = 5;
   * ```
   */
  get maxSize() {
    return this.maxSizeInternal;
  }
  set maxSize(ar) {
    if (Number.isNaN(ar) || ar <= 0)
      throw new Error("maxSize must be greater than 0.");
    this.maxSizeInternal = ar, this.enforceSizeLimit();
  }
  /**
   * Sets the value for the key in the LRUCache object. Returns the LRUCache object.
   * This marks the newly added entry as the most recently used entry.
   * If adding the new entry makes the cache size go above maxSize,
   * this will evict the least recently used entries until size is equal to maxSize.
   *
   * @param key The key of the entry.
   * @param value The value to set for the key.
   * @param entryOptions Additional configuration options for the cache entry.
   *
   * @returns The LRUCache instance.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Set the key key2 to value value2. Pass in optional options.
   * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });
   * ```
   */
  set(ar, cr, ur) {
    const fr = this.lookupTable.get(ar);
    fr && this.removeNodeFromListAndLookupTable(fr);
    const dr = new LRUCacheNode_1.LRUCacheNode(ar, cr, {
      entryExpirationTimeInMS: this.entryExpirationTimeInMS,
      onEntryEvicted: this.onEntryEvicted,
      onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,
      clone: this.clone,
      cloneFn: this.cloneFn,
      ...ur
    });
    return this.setNodeAsHead(dr), this.lookupTable.set(ar, dr), this.enforceSizeLimit(), this;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'. Entry will now be most recently used.
   * const item1 = cache.get('testKey');
   *
   * // Will be null
   * const item2 = cache.get('keyNotInCache');
   * ```
   */
  get(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), null) : (this.setNodeAsHead(cr), cr.value) : null;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this will not mark the entry as most recently accessed.
   * Useful if a value is needed but the order of the cache should not be changed.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'
   * const item1 = cache.peek('testKey');
   *
   * // Will be null
   * const item2 = cache.peek('keyNotInCache');
   * ```
   */
  peek(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), null) : cr.value : null;
  }
  /**
   * Deletes the entry for the passed in key.
   *
   * @param key The key of the entry to delete
   *
   * @returns True if an element in the LRUCache object existed and has been removed,
   * or false if the element does not exist.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.delete('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.delete('keyNotInCache');
   * ```
   */
  delete(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? this.removeNodeFromListAndLookupTable(cr) : !1;
  }
  /**
   * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.
   * This does not mark the entry as recently used.
   * If the cache has a key but the entry is expired, it will be removed and false will be returned.
   *
   * @param key The key of the entry to check if exists
   *
   * @returns true if the cache contains the supplied key. False if not.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.has('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.has('keyNotInCache');
   * ```
   */
  has(ar) {
    const cr = this.lookupTable.get(ar);
    return cr ? cr.isExpired ? (this.removeNodeFromListAndLookupTable(cr), !1) : !0 : !1;
  }
  /**
   * Removes all entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Clear cache.
   * cache.clear();
   * ```
   */
  clear() {
    this.head = null, this.tail = null, this.lookupTable.clear();
  }
  /**
   * Searches the cache for an entry matching the passed in condition.
   * Expired entries will be skipped (and removed).
   * If multiply entries in the cache match the condition, the most recently used entry will be returned.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param condition The condition to apply to each entry in the
   *
   * @returns The first cache entry to match the condition. Null if none match.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // item will be { key: 'testKey', value: 'testValue }
   * const item = cache.find(entry => {
   *   const { key, value } = entry;
   *
   *   if (key === 'testKey' || value === 'something') {
   *     return true;
   *   }
   *
   *   return false;
   * });
   *
   * // item2 will be null
   * const item2 = cache.find(entry => entry.key === 'notInCache');
   * ```
   */
  find(ar) {
    let cr = this.head;
    for (; cr; ) {
      if (cr.isExpired) {
        const fr = cr.next;
        this.removeNodeFromListAndLookupTable(cr), cr = fr;
        continue;
      }
      const ur = this.mapNodeToEntry(cr);
      if (ar(ur))
        return this.setNodeAsHead(cr), ur;
      cr = cr.next;
    }
    return null;
  }
  /**
   * Iterates over and applies the callback function to each entry in the cache.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as recently used.
   *
   * @param callback the callback function to apply to the entry
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * cache.forEach((key, value, index) => {
   *   // do something with key, value, and/or index
   * });
   * ```
   */
  forEach(ar) {
    let cr = this.head, ur = 0;
    for (; cr; ) {
      if (cr.isExpired) {
        const fr = cr.next;
        this.removeNodeFromListAndLookupTable(cr), cr = fr;
        continue;
      }
      ar(cr.value, cr.key, ur), cr = cr.next, ur++;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache values.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache values.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const value of cache.values()) {
   *   // do something with the value
   * }
   * ```
   */
  *values() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield ar.value, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache keys.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const key of cache.keys()) {
   *   // do something with the key
   * }
   * ```
   */
  *keys() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield ar.key, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache.entries()) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *entries() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *[Symbol.iterator]() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const cr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = cr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  enforceSizeLimit() {
    let ar = this.tail;
    for (; ar !== null && this.size > this.maxSizeInternal; ) {
      const cr = ar.prev;
      this.removeNodeFromListAndLookupTable(ar), ar = cr;
    }
  }
  mapNodeToEntry({ key: ar, value: cr }) {
    return {
      key: ar,
      value: cr
    };
  }
  setNodeAsHead(ar) {
    this.removeNodeFromList(ar), this.head ? (ar.next = this.head, this.head.prev = ar, this.head = ar) : (this.head = ar, this.tail = ar), ar.invokeOnEntryMarkedAsMostRecentlyUsed();
  }
  removeNodeFromList(ar) {
    ar.prev !== null && (ar.prev.next = ar.next), ar.next !== null && (ar.next.prev = ar.prev), this.head === ar && (this.head = ar.next), this.tail === ar && (this.tail = ar.prev), ar.next = null, ar.prev = null;
  }
  removeNodeFromListAndLookupTable(ar) {
    return ar.invokeOnEvicted(), this.removeNodeFromList(ar), this.lookupTable.delete(ar.key);
  }
  cleanCache() {
    if (!this.entryExpirationTimeInMS)
      return;
    const ar = [];
    for (const cr of this.lookupTable.values())
      cr.isExpired && ar.push(cr);
    ar.forEach((cr) => this.removeNodeFromListAndLookupTable(cr));
  }
}
LRUCache$1.LRUCache = LRUCache;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr);
    var mr = Object.getOwnPropertyDescriptor(fr, dr);
    (!mr || ("get" in mr ? !fr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return fr[dr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, fr, dr, gr) {
    gr === void 0 && (gr = dr), ur[gr] = fr[dr];
  }), cr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, fr) {
    for (var dr in ur)
      dr !== "default" && !Object.prototype.hasOwnProperty.call(fr, dr) && ar(fr, ur, dr);
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), cr(LRUCache$1, lr);
})(dist$9);
var lib$1 = {};
(function(lr) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.bytes = lr.stringToBytes = lr.str = lr.bytesToString = lr.hex = lr.utf8 = lr.bech32m = lr.bech32 = lr.base58check = lr.base58xmr = lr.base58xrp = lr.base58flickr = lr.base58 = lr.base64url = lr.base64 = lr.base32crockford = lr.base32hex = lr.base32 = lr.base16 = lr.utils = lr.assertNumber = void 0;
  function ar(Qr) {
    if (!Number.isSafeInteger(Qr))
      throw new Error(`Wrong integer: ${Qr}`);
  }
  lr.assertNumber = ar;
  function cr(...Qr) {
    const ei = (fi, gi) => (Ci) => fi(gi(Ci)), ui = Array.from(Qr).reverse().reduce((fi, gi) => fi ? ei(fi, gi.encode) : gi.encode, void 0), Ai = Qr.reduce((fi, gi) => fi ? ei(fi, gi.decode) : gi.decode, void 0);
    return { encode: ui, decode: Ai };
  }
  function ur(Qr) {
    return {
      encode: (ei) => {
        if (!Array.isArray(ei) || ei.length && typeof ei[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return ei.map((ui) => {
          if (ar(ui), ui < 0 || ui >= Qr.length)
            throw new Error(`Digit index outside alphabet: ${ui} (alphabet: ${Qr.length})`);
          return Qr[ui];
        });
      },
      decode: (ei) => {
        if (!Array.isArray(ei) || ei.length && typeof ei[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return ei.map((ui) => {
          if (typeof ui != "string")
            throw new Error(`alphabet.decode: not string element=${ui}`);
          const Ai = Qr.indexOf(ui);
          if (Ai === -1)
            throw new Error(`Unknown letter: "${ui}". Allowed: ${Qr}`);
          return Ai;
        });
      }
    };
  }
  function fr(Qr = "") {
    if (typeof Qr != "string")
      throw new Error("join separator should be string");
    return {
      encode: (ei) => {
        if (!Array.isArray(ei) || ei.length && typeof ei[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let ui of ei)
          if (typeof ui != "string")
            throw new Error(`join.encode: non-string input=${ui}`);
        return ei.join(Qr);
      },
      decode: (ei) => {
        if (typeof ei != "string")
          throw new Error("join.decode input should be string");
        return ei.split(Qr);
      }
    };
  }
  function dr(Qr, ei = "=") {
    if (ar(Qr), typeof ei != "string")
      throw new Error("padding chr should be string");
    return {
      encode(ui) {
        if (!Array.isArray(ui) || ui.length && typeof ui[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let Ai of ui)
          if (typeof Ai != "string")
            throw new Error(`padding.encode: non-string input=${Ai}`);
        for (; ui.length * Qr % 8; )
          ui.push(ei);
        return ui;
      },
      decode(ui) {
        if (!Array.isArray(ui) || ui.length && typeof ui[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let fi of ui)
          if (typeof fi != "string")
            throw new Error(`padding.decode: non-string input=${fi}`);
        let Ai = ui.length;
        if (Ai * Qr % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; Ai > 0 && ui[Ai - 1] === ei; Ai--)
          if (!((Ai - 1) * Qr % 8))
            throw new Error("Invalid padding: string has too much padding");
        return ui.slice(0, Ai);
      }
    };
  }
  function gr(Qr) {
    if (typeof Qr != "function")
      throw new Error("normalize fn should be function");
    return { encode: (ei) => ei, decode: (ei) => Qr(ei) };
  }
  function mr(Qr, ei, ui) {
    if (ei < 2)
      throw new Error(`convertRadix: wrong from=${ei}, base cannot be less than 2`);
    if (ui < 2)
      throw new Error(`convertRadix: wrong to=${ui}, base cannot be less than 2`);
    if (!Array.isArray(Qr))
      throw new Error("convertRadix: data should be array");
    if (!Qr.length)
      return [];
    let Ai = 0;
    const fi = [], gi = Array.from(Qr);
    for (gi.forEach((Ci) => {
      if (ar(Ci), Ci < 0 || Ci >= ei)
        throw new Error(`Wrong integer: ${Ci}`);
    }); ; ) {
      let Ci = 0, mi = !0;
      for (let vi = Ai; vi < gi.length; vi++) {
        const Ri = gi[vi], di = ei * Ci + Ri;
        if (!Number.isSafeInteger(di) || ei * Ci / ei !== Ci || di - Ri !== ei * Ci)
          throw new Error("convertRadix: carry overflow");
        if (Ci = di % ui, gi[vi] = Math.floor(di / ui), !Number.isSafeInteger(gi[vi]) || gi[vi] * ui + Ci !== di)
          throw new Error("convertRadix: carry overflow");
        if (mi)
          gi[vi] ? mi = !1 : Ai = vi;
        else
          continue;
      }
      if (fi.push(Ci), mi)
        break;
    }
    for (let Ci = 0; Ci < Qr.length - 1 && Qr[Ci] === 0; Ci++)
      fi.push(0);
    return fi.reverse();
  }
  const vr = (Qr, ei) => ei ? vr(ei, Qr % ei) : Qr, yr = (Qr, ei) => Qr + (ei - vr(Qr, ei));
  function kr(Qr, ei, ui, Ai) {
    if (!Array.isArray(Qr))
      throw new Error("convertRadix2: data should be array");
    if (ei <= 0 || ei > 32)
      throw new Error(`convertRadix2: wrong from=${ei}`);
    if (ui <= 0 || ui > 32)
      throw new Error(`convertRadix2: wrong to=${ui}`);
    if (yr(ei, ui) > 32)
      throw new Error(`convertRadix2: carry overflow from=${ei} to=${ui} carryBits=${yr(ei, ui)}`);
    let fi = 0, gi = 0;
    const Ci = 2 ** ui - 1, mi = [];
    for (const vi of Qr) {
      if (ar(vi), vi >= 2 ** ei)
        throw new Error(`convertRadix2: invalid data word=${vi} from=${ei}`);
      if (fi = fi << ei | vi, gi + ei > 32)
        throw new Error(`convertRadix2: carry overflow pos=${gi} from=${ei}`);
      for (gi += ei; gi >= ui; gi -= ui)
        mi.push((fi >> gi - ui & Ci) >>> 0);
      fi &= 2 ** gi - 1;
    }
    if (fi = fi << ui - gi & Ci, !Ai && gi >= ei)
      throw new Error("Excess padding");
    if (!Ai && fi)
      throw new Error(`Non-zero padding: ${fi}`);
    return Ai && gi > 0 && mi.push(fi >>> 0), mi;
  }
  function _r(Qr) {
    return ar(Qr), {
      encode: (ei) => {
        if (!(ei instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return mr(Array.from(ei), 2 ** 8, Qr);
      },
      decode: (ei) => {
        if (!Array.isArray(ei) || ei.length && typeof ei[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(mr(ei, Qr, 2 ** 8));
      }
    };
  }
  function xr(Qr, ei = !1) {
    if (ar(Qr), Qr <= 0 || Qr > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (yr(8, Qr) > 32 || yr(Qr, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (ui) => {
        if (!(ui instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return kr(Array.from(ui), 8, Qr, !ei);
      },
      decode: (ui) => {
        if (!Array.isArray(ui) || ui.length && typeof ui[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(kr(ui, Qr, 8, ei));
      }
    };
  }
  function Sr(Qr) {
    if (typeof Qr != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...ei) {
      try {
        return Qr.apply(null, ei);
      } catch (ui) {
      }
    };
  }
  function Er(Qr, ei) {
    if (ar(Qr), typeof ei != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(ui) {
        if (!(ui instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const Ai = ei(ui).slice(0, Qr), fi = new Uint8Array(ui.length + Qr);
        return fi.set(ui), fi.set(Ai, ui.length), fi;
      },
      decode(ui) {
        if (!(ui instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const Ai = ui.slice(0, -Qr), fi = ei(Ai).slice(0, Qr), gi = ui.slice(-Qr);
        for (let Ci = 0; Ci < Qr; Ci++)
          if (fi[Ci] !== gi[Ci])
            throw new Error("Invalid checksum");
        return Ai;
      }
    };
  }
  lr.utils = { alphabet: ur, chain: cr, checksum: Er, radix: _r, radix2: xr, join: fr, padding: dr }, lr.base16 = cr(xr(4), ur("0123456789ABCDEF"), fr("")), lr.base32 = cr(xr(5), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), dr(5), fr("")), lr.base32hex = cr(xr(5), ur("0123456789ABCDEFGHIJKLMNOPQRSTUV"), dr(5), fr("")), lr.base32crockford = cr(xr(5), ur("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), fr(""), gr((Qr) => Qr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), lr.base64 = cr(xr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), dr(6), fr("")), lr.base64url = cr(xr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), dr(6), fr(""));
  const Cr = (Qr) => cr(_r(58), ur(Qr), fr(""));
  lr.base58 = Cr("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), lr.base58flickr = Cr("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), lr.base58xrp = Cr("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const Tr = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  lr.base58xmr = {
    encode(Qr) {
      let ei = "";
      for (let ui = 0; ui < Qr.length; ui += 8) {
        const Ai = Qr.subarray(ui, ui + 8);
        ei += lr.base58.encode(Ai).padStart(Tr[Ai.length], "1");
      }
      return ei;
    },
    decode(Qr) {
      let ei = [];
      for (let ui = 0; ui < Qr.length; ui += 11) {
        const Ai = Qr.slice(ui, ui + 11), fi = Tr.indexOf(Ai.length), gi = lr.base58.decode(Ai);
        for (let Ci = 0; Ci < gi.length - fi; Ci++)
          if (gi[Ci] !== 0)
            throw new Error("base58xmr: wrong padding");
        ei = ei.concat(Array.from(gi.slice(gi.length - fi)));
      }
      return Uint8Array.from(ei);
    }
  };
  const Ar = (Qr) => cr(Er(4, (ei) => Qr(Qr(ei))), lr.base58);
  lr.base58check = Ar;
  const Ir = cr(ur("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), fr("")), Mr = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function Hr(Qr) {
    const ei = Qr >> 25;
    let ui = (Qr & 33554431) << 5;
    for (let Ai = 0; Ai < Mr.length; Ai++)
      (ei >> Ai & 1) === 1 && (ui ^= Mr[Ai]);
    return ui;
  }
  function Br(Qr, ei, ui = 1) {
    const Ai = Qr.length;
    let fi = 1;
    for (let gi = 0; gi < Ai; gi++) {
      const Ci = Qr.charCodeAt(gi);
      if (Ci < 33 || Ci > 126)
        throw new Error(`Invalid prefix (${Qr})`);
      fi = Hr(fi) ^ Ci >> 5;
    }
    fi = Hr(fi);
    for (let gi = 0; gi < Ai; gi++)
      fi = Hr(fi) ^ Qr.charCodeAt(gi) & 31;
    for (let gi of ei)
      fi = Hr(fi) ^ gi;
    for (let gi = 0; gi < 6; gi++)
      fi = Hr(fi);
    return fi ^= ui, Ir.encode(kr([fi % 2 ** 30], 30, 5, !1));
  }
  function zr(Qr) {
    const ei = Qr === "bech32" ? 1 : 734539939, ui = xr(5), Ai = ui.decode, fi = ui.encode, gi = Sr(Ai);
    function Ci(di, Ti, qi = 90) {
      if (typeof di != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof di}`);
      if (!Array.isArray(Ti) || Ti.length && typeof Ti[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof Ti}`);
      const ki = di.length + 7 + Ti.length;
      if (qi !== !1 && ki > qi)
        throw new TypeError(`Length ${ki} exceeds limit ${qi}`);
      return di = di.toLowerCase(), `${di}1${Ir.encode(Ti)}${Br(di, Ti, ei)}`;
    }
    function mi(di, Ti = 90) {
      if (typeof di != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof di}`);
      if (di.length < 8 || Ti !== !1 && di.length > Ti)
        throw new TypeError(`Wrong string length: ${di.length} (${di}). Expected (8..${Ti})`);
      const qi = di.toLowerCase();
      if (di !== qi && di !== di.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      di = qi;
      const ki = di.lastIndexOf("1");
      if (ki === 0 || ki === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const Ji = di.slice(0, ki), Bi = di.slice(ki + 1);
      if (Bi.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const Ni = Ir.decode(Bi).slice(0, -6), Mi = Br(Ji, Ni, ei);
      if (!Bi.endsWith(Mi))
        throw new Error(`Invalid checksum in ${di}: expected "${Mi}"`);
      return { prefix: Ji, words: Ni };
    }
    const vi = Sr(mi);
    function Ri(di) {
      const { prefix: Ti, words: qi } = mi(di, !1);
      return { prefix: Ti, words: qi, bytes: Ai(qi) };
    }
    return { encode: Ci, decode: mi, decodeToBytes: Ri, decodeUnsafe: vi, fromWords: Ai, fromWordsUnsafe: gi, toWords: fi };
  }
  lr.bech32 = zr("bech32"), lr.bech32m = zr("bech32m"), lr.utf8 = {
    encode: (Qr) => new TextDecoder().decode(Qr),
    decode: (Qr) => new TextEncoder().encode(Qr)
  }, lr.hex = cr(xr(4), ur("0123456789abcdef"), fr(""), gr((Qr) => {
    if (typeof Qr != "string" || Qr.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof Qr} with length ${Qr.length}`);
    return Qr.toLowerCase();
  }));
  const Gr = {
    utf8: lr.utf8,
    hex: lr.hex,
    base16: lr.base16,
    base32: lr.base32,
    base64: lr.base64,
    base64url: lr.base64url,
    base58: lr.base58,
    base58xmr: lr.base58xmr
  }, Xr = `Invalid encoding type. Available types: ${Object.keys(Gr).join(", ")}`, Jr = (Qr, ei) => {
    if (typeof Qr != "string" || !Gr.hasOwnProperty(Qr))
      throw new TypeError(Xr);
    if (!(ei instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return Gr[Qr].encode(ei);
  };
  lr.bytesToString = Jr, lr.str = lr.bytesToString;
  const li = (Qr, ei) => {
    if (!Gr.hasOwnProperty(Qr))
      throw new TypeError(Xr);
    if (typeof ei != "string")
      throw new TypeError("stringToBytes() expects string");
    return Gr[Qr].decode(ei);
  };
  lr.stringToBytes = li, lr.bytes = lr.stringToBytes;
})(lib$1);
BigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);
BigInt("2100000000000000000");
BigInt(1e11);
const TAGCODES = {
  payment_hash: 1,
  payment_secret: 16,
  description: 13,
  payee: 19,
  description_hash: 23,
  // commit to longer descriptions (used by lnurl-pay)
  expiry: 6,
  // default: 3600 (1 hour)
  min_final_cltv_expiry: 24,
  // default: 9
  fallback_address: 9,
  route_hint: 3,
  // for extra routing info (private etc.)
  feature_bits: 5,
  metadata: 27
};
for (let lr = 0, ar = Object.keys(TAGCODES); lr < ar.length; lr++)
  ar[lr], TAGCODES[ar[lr]].toString();
var NDKRelayConnectivity = class {
  constructor(lr) {
    ji(this, "ndkRelay");
    ji(this, "_status");
    ji(this, "relay");
    ji(this, "connectedAt");
    ji(this, "_connectionStats", {
      attempts: 0,
      success: 0,
      durations: []
    });
    ji(this, "debug");
    /**
     * Utility functions to update the connection stats.
     */
    ji(this, "updateConnectionStats", {
      connected: () => {
        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();
      },
      disconnected: () => {
        this._connectionStats.connectedAt && (this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;
      },
      attempt: () => {
        this._connectionStats.attempts++;
      }
    });
    this.ndkRelay = lr, this._status = 3, this.relay = relayInit(this.ndkRelay.url), this.debug = this.ndkRelay.debug.extend("connectivity"), this.relay.on("notice", (ar) => this.handleNotice(ar));
  }
  async connect() {
    const lr = () => {
      this.updateConnectionStats.connected(), this._status = 1, this.ndkRelay.emit("connect");
    }, ar = () => {
      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.ndkRelay.emit("disconnect");
    };
    try {
      this.updateConnectionStats.attempt(), this._status = 0, this.relay.off("connect", lr), this.relay.off("disconnect", ar), this.relay.on("connect", lr), this.relay.on("disconnect", ar), await this.relay.connect();
    } catch (cr) {
      throw this.debug("Failed to connect", cr), this._status = 3, cr;
    }
  }
  disconnect() {
    this._status = 2, this.relay.close();
  }
  get status() {
    return this._status;
  }
  isAvailable() {
    return this._status === 1;
  }
  /**
   * Evaluates the connection stats to determine if the relay is flapping.
   */
  isFlapping() {
    const lr = this._connectionStats.durations;
    if (lr.length % 3 !== 0)
      return !1;
    const cr = lr.reduce((gr, mr) => gr + mr, 0) / lr.length, ur = lr.map((gr) => Math.pow(gr - cr, 2)).reduce((gr, mr) => gr + mr, 0) / lr.length;
    return Math.sqrt(ur) < 1e3;
  }
  async handleNotice(lr) {
    (lr.includes("oo many") || lr.includes("aximum")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, "Relay complaining?", lr)), this.ndkRelay.emit("notice", this, lr);
  }
  /**
   * Called when the relay is unexpectedly disconnected.
   */
  handleReconnection(lr = 0) {
    if (this.isFlapping()) {
      this.ndkRelay.emit("flapping", this, this._connectionStats), this._status = 5;
      return;
    }
    const ar = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 0;
    setTimeout(() => {
      this._status = 4, this.connect().then(() => {
        this.debug("Reconnected");
      }).catch((cr) => {
        this.debug("Reconnect failed", cr), lr < 5 ? setTimeout(() => {
          this.handleReconnection(lr + 1);
        }, 6e4) : this.debug("Reconnect failed after 5 attempts");
      });
    }, ar);
  }
  /**
   * Returns the connection stats.
   */
  get connectionStats() {
    return this._connectionStats;
  }
}, NDKRelayPublisher = class {
  constructor(lr) {
    ji(this, "ndkRelay");
    this.ndkRelay = lr;
  }
  /**
   * Published an event to the relay; if the relay is not connected, it will
   * wait for the relay to connect before publishing the event.
   *
   * If the relay does not connect within the timeout, the publish operation
   * will fail.
   * @param event  The event to publish
   * @param timeoutMs  The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(lr, ar = 2500) {
    const cr = () => new Promise((mr, vr) => {
      try {
        this.publishEvent(lr, ar).then((yr) => mr(yr)).catch((yr) => vr(yr));
      } catch (yr) {
        vr(yr);
      }
    }), ur = new Promise((mr, vr) => {
      setTimeout(() => vr(new Error("Timeout")), ar);
    }), fr = () => {
      cr().then((mr) => dr(mr)).catch((mr) => gr(mr));
    };
    let dr, gr;
    return this.ndkRelay.status === 1 ? Promise.race([cr(), ur]) : Promise.race([
      new Promise((mr, vr) => {
        dr = mr, gr = vr, this.ndkRelay.once("connect", fr);
      }),
      ur
    ]).finally(() => {
      this.ndkRelay.removeListener("connect", fr);
    });
  }
  async publishEvent(lr, ar) {
    const cr = await lr.toNostrEvent(), ur = this.ndkRelay.connectivity.relay.publish(cr);
    let fr;
    const dr = new Promise((mr, vr) => {
      ur.then(() => {
        clearTimeout(fr), this.ndkRelay.emit("published", lr), mr(!0);
      }).catch((yr) => {
        clearTimeout(fr), this.ndkRelay.debug("Publish failed", yr, lr.id), this.ndkRelay.emit("publish:failed", lr, yr), vr(yr);
      });
    });
    if (!ar || lr.isEphemeral())
      return dr;
    const gr = new Promise((mr, vr) => {
      fr = setTimeout(() => {
        this.ndkRelay.debug("Publish timed out", lr.rawEvent()), this.ndkRelay.emit("publish:failed", lr, "Timeout"), vr(new Error("Publish operation timed out"));
      }, ar);
    });
    return Promise.race([dr, gr]);
  }
};
function calculateGroupableId(lr) {
  const ar = [];
  for (const cr of lr) {
    if (cr.since || cr.until)
      return null;
    const fr = Object.keys(cr || {}).sort().join("-");
    ar.push(fr);
  }
  return ar.join("|");
}
function mergeFilters(lr) {
  const ar = {};
  return lr.forEach((cr) => {
    Object.entries(cr).forEach(([ur, fr]) => {
      Array.isArray(fr) ? ar[ur] === void 0 ? ar[ur] = [...fr] : ar[ur] = Array.from(/* @__PURE__ */ new Set([...ar[ur], ...fr])) : ar[ur] = fr;
    });
  }), ar;
}
var MAX_SUBID_LENGTH = 20;
function queryFullyFilled(lr) {
  return !!(filterIncludesIds(lr.filter) && resultHasAllRequestedIds(lr));
}
function compareFilter(lr, ar) {
  if (Object.keys(lr).length !== Object.keys(ar).length)
    return !1;
  for (const [cr, ur] of Object.entries(lr)) {
    const fr = ar[cr];
    if (!fr)
      return !1;
    if (Array.isArray(ur) && Array.isArray(fr)) {
      const dr = ur;
      for (const gr of fr) {
        const mr = gr;
        if (!dr.includes(mr))
          return !1;
      }
    } else if (fr !== ur)
      return !1;
  }
  return !0;
}
function filterIncludesIds(lr) {
  return !!lr.ids;
}
function resultHasAllRequestedIds(lr) {
  const ar = lr.filter.ids;
  return !!ar && ar.length === lr.eventFirstSeen.size;
}
function generateSubId(lr, ar) {
  var mr;
  const cr = lr.map((vr) => vr.subId).filter(Boolean), ur = [], fr = /* @__PURE__ */ new Set(), dr = /* @__PURE__ */ new Set();
  if (cr.length > 0)
    ur.push(Array.from(new Set(cr)).join(","));
  else {
    for (const vr of ar)
      for (const yr of Object.keys(vr))
        yr === "kinds" ? (mr = vr.kinds) == null || mr.forEach((kr) => dr.add(kr)) : fr.add(yr);
    dr.size > 0 && ur.push("kinds:" + Array.from(dr).join(",")), fr.size > 0 && ur.push(Array.from(fr).join(","));
  }
  let gr = ur.join("-");
  return gr.length > MAX_SUBID_LENGTH && (gr = gr.substring(0, MAX_SUBID_LENGTH)), cr.length !== 1 && (gr += "-" + Math.floor(Math.random() * 999).toString()), gr;
}
function filterFromId(lr) {
  let ar;
  if (lr.match(NIP33_A_REGEX)) {
    const [cr, ur, fr] = lr.split(":"), dr = {
      authors: [ur],
      kinds: [parseInt(cr)]
    };
    return fr && (dr["#d"] = [fr]), dr;
  }
  try {
    switch (ar = nip19_exports$2.decode(lr), ar.type) {
      case "nevent":
        return { ids: [ar.data.id] };
      case "note":
        return { ids: [ar.data] };
      case "naddr":
        return {
          authors: [ar.data.pubkey],
          "#d": [ar.data.identifier],
          kinds: [ar.data.kind]
        };
    }
  } catch (cr) {
  }
  return { ids: [lr] };
}
function isNip33AValue(lr) {
  return lr.match(NIP33_A_REGEX) !== null;
}
var NIP33_A_REGEX = /^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/;
function relaysFromBech32(lr) {
  try {
    const ar = nip19_exports$2.decode(lr);
    if (["naddr", "nevent"].includes(ar == null ? void 0 : ar.type)) {
      const cr = ar.data;
      if (cr != null && cr.relays)
        return cr.relays.map((ur) => new NDKRelay(ur));
    }
  } catch (ar) {
  }
  return [];
}
var NDKGroupedSubscriptions = class extends lib$2.EventEmitter {
  constructor(ar, cr) {
    super();
    ji(this, "subscriptions");
    ji(this, "req");
    ji(this, "debug");
    this.subscriptions = ar, this.debug = cr || this.subscriptions[0].subscription.debug.extend("grouped");
    for (const ur of ar)
      this.handleSubscriptionClosure(ur);
  }
  /**
   * Adds a subscription to this group.
   * @param subscription
   */
  addSubscription(ar) {
    this.subscriptions.push(ar), this.handleSubscriptionClosure(ar);
  }
  eventReceived(ar) {
    for (const cr of this.subscriptions)
      cr.eventReceived(ar);
  }
  eoseReceived(ar) {
    Array.from(this.subscriptions).forEach(async (ur) => {
      ur.subscription.eoseReceived(ar);
    });
  }
  handleSubscriptionClosure(ar) {
    ar.subscription.on("close", () => {
      const cr = this.subscriptions.findIndex(
        (ur) => ur.subscription === ar.subscription
      );
      this.subscriptions.splice(cr, 1), this.subscriptions.length <= 0 && this.emit("close");
    });
  }
  /**
   * Maps each subscription through a transformation function.
   * @param fn - The transformation function.
   * @returns A new array with each subscription transformed by fn.
   */
  map(ar) {
    return this.subscriptions.map(ar);
  }
  [Symbol.iterator]() {
    let ar = 0;
    const cr = this.subscriptions;
    return {
      next() {
        return ar < cr.length ? { value: cr[ar++], done: !1 } : { value: null, done: !0 };
      }
    };
  }
}, NDKSubscriptionFilters = class {
  constructor(lr, ar, cr) {
    ji(this, "subscription");
    ji(this, "filters", []);
    ji(this, "ndkRelay");
    this.subscription = lr, this.filters = ar, this.ndkRelay = cr;
  }
  eventReceived(lr) {
    this.eventMatchesLocalFilter(lr) && this.subscription.eventReceived(lr, this.ndkRelay, !1);
  }
  eventMatchesLocalFilter(lr) {
    const ar = lr.rawEvent();
    return this.filters.some((cr) => matchFilter$1(cr, ar));
  }
};
function findMatchingActiveSubscriptions(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length && compareFilter(lr[cr], ar[cr]); cr++)
    return lr[cr];
}
var NDKRelaySubscriptions = class {
  constructor(lr) {
    ji(this, "ndkRelay");
    ji(this, "delayedItems", /* @__PURE__ */ new Map());
    ji(this, "delayedTimers", /* @__PURE__ */ new Map());
    /**
     * Active subscriptions this relay is connected to
     */
    ji(this, "activeSubscriptions", /* @__PURE__ */ new Map());
    ji(this, "activeSubscriptionsByGroupId", /* @__PURE__ */ new Map());
    ji(this, "debug");
    ji(this, "groupingDebug");
    ji(this, "conn");
    this.ndkRelay = lr, this.conn = lr.connectivity, this.debug = lr.debug.extend("subscriptions"), this.groupingDebug = lr.debug.extend("grouping");
  }
  /**
   * Creates or queues a subscription to the relay.
   */
  subscribe(lr, ar) {
    const cr = calculateGroupableId(ar), ur = new NDKSubscriptionFilters(
      lr,
      ar,
      this.ndkRelay
    );
    if (!cr || !lr.isGroupable()) {
      this.groupingDebug("No groupable ID for filters", ar), this.executeSubscriptions(
        cr,
        // hacky
        new NDKGroupedSubscriptions([ur]),
        ar
      );
      return;
    }
    const fr = this.activeSubscriptionsByGroupId.get(cr);
    if (fr && findMatchingActiveSubscriptions(
      fr.filters,
      ar
    )) {
      const vr = this.activeSubscriptions.get(fr.sub);
      vr == null || vr.addSubscription(
        new NDKSubscriptionFilters(lr, ar, this.ndkRelay)
      );
      return;
    }
    let dr = this.delayedItems.get(cr);
    dr ? dr.addSubscription(ur) : (dr = new NDKGroupedSubscriptions([ur]), this.delayedItems.set(cr, dr), dr.once("close", () => {
      this.delayedItems.get(cr) && this.delayedItems.delete(cr);
    }));
    const gr = setTimeout(() => {
      this.executeGroup(cr, lr);
    }, lr.opts.groupableDelay);
    this.delayedTimers.has(cr) ? this.delayedTimers.get(cr).push(gr) : this.delayedTimers.set(cr, [gr]);
  }
  /**
   * Executes a delayed subscription via its groupable ID.
   * @param groupableId
   */
  executeGroup(lr, ar) {
    const cr = this.delayedItems.get(lr);
    this.delayedItems.delete(lr);
    const ur = this.delayedTimers.get(lr);
    if (this.delayedTimers.delete(lr), ur)
      for (const fr of ur)
        clearTimeout(fr);
    if (cr) {
      const fr = cr.subscriptions[0].filters.length, dr = [];
      for (let gr = 0; gr < fr; gr++) {
        const mr = cr.map((vr) => vr.filters[gr]);
        dr.push(mergeFilters(mr));
      }
      this.executeSubscriptions(lr, cr, dr);
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * If the relay is not connected, subscriptions will be queued
   * until the relay connects.
   *
   * @param groupableId
   * @param subscriptionFilters
   * @param mergedFilters
   */
  executeSubscriptions(lr, ar, cr) {
    if (this.conn.isAvailable())
      this.executeSubscriptionsConnected(lr, ar, cr);
    else {
      const ur = () => {
        this.debug("new relay coming online for active subscription", {
          relay: this.ndkRelay.url,
          mergeFilters
        }), this.executeSubscriptionsConnected(
          lr,
          ar,
          cr
        );
      };
      this.ndkRelay.once("connect", ur), ar.once("close", () => {
        this.ndkRelay.removeListener("connect", ur);
      });
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * When there are more than one subscription, results
   * will be sent to the right subscription
   *
   * @param subscriptions
   * @param filters The filters as they should be sent to the relay
   */
  executeSubscriptionsConnected(lr, ar, cr) {
    const ur = [];
    for (const { subscription: gr } of ar)
      ur.push(gr);
    const fr = generateSubId(ur, cr);
    ar.req = cr;
    const dr = this.conn.relay.sub(cr, { id: fr });
    return this.activeSubscriptions.set(dr, ar), lr && this.activeSubscriptionsByGroupId.set(lr, { filters: cr, sub: dr }), dr.on("event", (gr) => {
      const mr = new NDKEvent(void 0, gr);
      mr.relay = this.ndkRelay;
      const vr = this.activeSubscriptions.get(dr);
      vr == null || vr.eventReceived(mr);
    }), dr.on("eose", () => {
      const gr = this.activeSubscriptions.get(dr);
      gr == null || gr.eoseReceived(this.ndkRelay);
    }), ar.once("close", () => {
      dr.unsub(), this.activeSubscriptions.delete(dr), lr && this.activeSubscriptionsByGroupId.delete(lr);
    }), dr;
  }
  executedFilters() {
    const lr = /* @__PURE__ */ new Map();
    for (const [, ar] of this.activeSubscriptions)
      lr.set(
        ar.req,
        ar.map((cr) => cr.subscription)
      );
    return lr;
  }
}, NDKRelay = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    ji(this, "url");
    ji(this, "scores");
    ji(this, "connectivity");
    ji(this, "subs");
    ji(this, "publisher");
    ji(this, "complaining", !1);
    ji(this, "debug");
    this.url = ar, this.scores = /* @__PURE__ */ new Map(), this.debug = _debug(`ndk:relay:${ar}`), this.connectivity = new NDKRelayConnectivity(this), this.subs = new NDKRelaySubscriptions(this), this.publisher = new NDKRelayPublisher(this);
  }
  get status() {
    return this.connectivity.status;
  }
  get connectionStats() {
    return this.connectivity.connectionStats;
  }
  /**
   * Connects to the relay.
   */
  async connect() {
    return this.connectivity.connect();
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    this.connectivity.disconnect();
  }
  /**
   * Queues or executes the subscription of a specific set of filters
   * within this relay.
   *
   * @param subscription NDKSubscription this filters belong to.
   * @param filters Filters to execute
   */
  subscribe(ar, cr) {
    this.subs.subscribe(ar, cr);
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(ar, cr = 2500) {
    return this.publisher.publish(ar, cr);
  }
  /**
   * Called when this relay has responded with an event but
   * wasn't the fastest one.
   * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  scoreSlowerEvent(ar) {
  }
  /** @deprecated Use referenceTags instead. */
  tagReference(ar) {
    const cr = ["r", this.url];
    return ar && cr.push(ar), cr;
  }
  referenceTags() {
    return [["r", this.url]];
  }
  activeSubscriptions() {
    return this.subs.executedFilters();
  }
}, NDKRelaySet = class {
  constructor(lr, ar) {
    ji(this, "relays");
    ji(this, "debug");
    ji(this, "ndk");
    this.relays = lr, this.ndk = ar, this.debug = ar.debug.extend("relayset");
  }
  /**
   * Adds a relay to this set.
   */
  addRelay(lr) {
    this.relays.add(lr);
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * If no connection to the relay is found in the pool it will temporarily
   * connect to it.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @returns NDKRelaySet
   */
  static fromRelayUrls(lr, ar) {
    const cr = /* @__PURE__ */ new Set();
    for (const ur of lr) {
      const fr = ar.pool.relays.get(ur);
      if (fr)
        cr.add(fr);
      else {
        const dr = new NDKRelay(ur);
        ar.pool.useTemporaryRelay(dr), cr.add(dr);
      }
    }
    return new NDKRelaySet(new Set(cr), ar);
  }
  /**
   * Publish an event to all relays in this set. Returns the number of relays that have received the event.
   * @param event
   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
   * @returns A set where the event was successfully published to
   */
  async publish(lr, ar) {
    const cr = /* @__PURE__ */ new Set(), ur = lr.isEphemeral(), fr = Array.from(this.relays).map((dr) => new Promise((gr) => {
      dr.publish(lr, ar).then(() => {
        cr.add(dr), gr();
      }).catch((mr) => {
        ur || this.debug("error publishing to relay", {
          relay: dr.url,
          err: mr
        }), gr();
      });
    }));
    if (await Promise.all(fr), cr.size === 0 && !ur)
      throw new Error("No relay was able to receive the event");
    return cr;
  }
  size() {
    return this.relays.size;
  }
};
function calculateRelaySetFromEvent(lr, ar) {
  var ur;
  const cr = /* @__PURE__ */ new Set();
  return (ur = lr.pool) == null || ur.relays.forEach((fr) => cr.add(fr)), new NDKRelaySet(cr, lr);
}
function getWriteRelaysFor(lr, ar) {
  var cr;
  if (lr.outboxTracker)
    return (cr = lr.outboxTracker.data.get(ar)) == null ? void 0 : cr.writeRelays;
}
function calculateRelaySetsFromFilter(lr, ar) {
  var fr, dr;
  const cr = /* @__PURE__ */ new Map(), ur = /* @__PURE__ */ new Set();
  if (ar.forEach((gr) => {
    gr.authors && gr.authors.forEach((mr) => ur.add(mr));
  }), ur.size > 0) {
    const gr = /* @__PURE__ */ new Map();
    for (const mr of ur) {
      const vr = getWriteRelaysFor(lr, mr);
      vr && vr.size > 0 ? (lr.debug(`Adding ${vr.size} relays for ${mr}`), vr.forEach((yr) => {
        const kr = gr.get(yr) || [];
        kr.push(mr), gr.set(yr, kr);
      })) : (fr = lr.explicitRelayUrls) == null || fr.forEach((yr) => {
        const kr = gr.get(yr) || [];
        kr.push(mr), gr.set(yr, kr);
      });
    }
    for (const mr of gr.keys())
      cr.set(mr, []);
    for (const mr of ar)
      if (mr.authors)
        for (const [vr, yr] of gr.entries())
          cr.set(vr, [...cr.get(vr), { ...mr, authors: yr }]);
      else
        for (const vr of gr.keys())
          cr.set(vr, [...cr.get(vr), mr]);
  } else
    (dr = lr.explicitRelayUrls) == null || dr.forEach((gr) => {
      cr.set(gr, ar);
    });
  return cr;
}
function calculateRelaySetsFromFilters(lr, ar) {
  return calculateRelaySetsFromFilter(lr, ar);
}
var DEFAULT_RELAYS = [
  "wss://nos.lol",
  "wss://relay.nostr.band",
  "wss://relay.f7z.io",
  "wss://relay.damus.io",
  "wss://nostr.mom",
  "wss://no.str.cr"
], Zap$1 = class extends lib$2.EventEmitter {
  constructor(cr) {
    var ur;
    super();
    ji(this, "ndk");
    ji(this, "zappedEvent");
    ji(this, "zappedUser");
    this.ndk = cr.ndk, this.zappedEvent = cr.zappedEvent, this.zappedUser = cr.zappedUser || this.ndk.getUser({ hexpubkey: (ur = this.zappedEvent) == null ? void 0 : ur.pubkey });
  }
  async getZapEndpoint() {
    let cr, ur, fr, dr;
    if (this.zappedUser && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), cr = (this.zappedUser.profile || {}).lud06, ur = (this.zappedUser.profile || {}).lud16), ur && !ur.startsWith("LNURL")) {
      const [vr, yr] = ur.split("@");
      fr = `https://${yr}/.well-known/lnurlp/${vr}`;
    } else if (cr) {
      const { words: vr } = bech32$3.decode(cr, 1e3), yr = bech32$3.fromWords(vr);
      fr = new TextDecoder("utf-8").decode(yr);
    }
    if (!fr)
      throw new Error("No zap endpoint found");
    const mr = await (await fetch(fr)).json();
    return mr != null && mr.allowsNostr && (mr != null && mr.nostrPubkey || mr != null && mr.nostrPubKey) && (dr = mr.callback), dr;
  }
  /**
   * Generates a kind:9734 zap request and returns the payment request
   * @param amount amount to zap in millisatoshis
   * @param comment optional comment to include in the zap request
   * @param extraTags optional extra tags to include in the zap request
   * @param relays optional relays to ask zapper to publish the zap to
   * @returns the payment request
   */
  async createZapRequest(cr, ur, fr, dr, gr) {
    const mr = await this.generateZapRequest(cr, ur, fr, dr);
    if (!mr)
      return null;
    const { event: vr, zapEndpoint: yr } = mr;
    if (!vr)
      throw new Error("No zap request event found");
    return await vr.sign(gr), await this.getInvoice(vr, cr, yr);
  }
  async getInvoice(cr, ur, fr) {
    return (await (await fetch(
      `${fr}?` + new URLSearchParams({
        amount: ur.toString(),
        nostr: JSON.stringify(cr.rawEvent())
      })
    )).json()).pr;
  }
  async generateZapRequest(cr, ur, fr, dr, gr) {
    const mr = await this.getZapEndpoint();
    if (!mr)
      throw new Error("No zap endpoint found");
    if (!this.zappedEvent && !this.zappedUser)
      throw new Error("No zapped event or user found");
    const vr = nip57_exports$2.makeZapRequest({
      profile: this.zappedUser.pubkey,
      // set the event to null since nostr-tools doesn't support nip-33 zaps
      event: null,
      amount: cr,
      comment: ur || "",
      relays: dr != null ? dr : this.relays()
    });
    if (this.zappedEvent) {
      const kr = this.zappedEvent.referenceTags();
      vr.tags.push(...kr);
    }
    vr.tags.push(["lnurl", mr]);
    const yr = new NDKEvent(this.ndk, vr);
    return fr && (yr.tags = yr.tags.concat(fr)), { event: yr, zapEndpoint: mr };
  }
  /**
   * @returns the relays to use for the zap request
   */
  relays() {
    var ur, fr;
    let cr = [];
    return (fr = (ur = this.ndk) == null ? void 0 : ur.pool) != null && fr.relays && (cr = this.ndk.pool.urls()), cr.length || (cr = DEFAULT_RELAYS), cr;
  }
};
function mergeTags(lr, ar) {
  const cr = /* @__PURE__ */ new Map(), ur = (gr) => gr.join(","), fr = (gr, mr) => gr.every((vr, yr) => vr === mr[yr]), dr = (gr) => {
    for (let [mr, vr] of cr)
      if (fr(vr, gr) || fr(gr, vr)) {
        gr.length >= vr.length && cr.set(mr, gr);
        return;
      }
    cr.set(ur(gr), gr);
  };
  return lr.concat(ar).forEach(dr), Array.from(cr.values());
}
async function generateContentTags(lr, ar = []) {
  const cr = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g, ur = /#(\w+)/g;
  let fr = [];
  const dr = (gr) => {
    ar.find((mr) => mr[0] === gr[0] && mr[1] === gr[1]) || ar.push(gr);
  };
  return lr = lr.replace(cr, (gr) => {
    try {
      const mr = gr.split(/(@|nostr:)/)[2], { type: vr, data: yr } = nip19_exports$2.decode(mr);
      let kr;
      switch (vr) {
        case "npub":
          kr = ["p", yr];
          break;
        case "nprofile":
          kr = ["p", yr.pubkey];
          break;
        case "note":
          fr.push(
            new Promise(async (_r) => {
              dr([
                "e",
                yr,
                await maybeGetEventRelayUrl(mr),
                "mention"
              ]), _r();
            })
          );
          break;
        case "nevent":
          fr.push(
            new Promise(async (_r) => {
              let { id: xr, relays: Sr, author: Er } = yr;
              (!Sr || Sr.length === 0) && (Sr = [await maybeGetEventRelayUrl(mr)]), dr(["e", xr, Sr[0], "mention"]), Er && dr(["p", Er]), _r();
            })
          );
          break;
        case "naddr":
          fr.push(
            new Promise(async (_r) => {
              var Er;
              const xr = [yr.kind, yr.pubkey, yr.identifier].join(":");
              let Sr = (Er = yr.relays) != null ? Er : [];
              Sr.length === 0 && (Sr = [await maybeGetEventRelayUrl(mr)]), dr(["a", xr, Sr[0], "mention"]), dr(["p", yr.pubkey]), _r();
            })
          );
          break;
        default:
          return gr;
      }
      return kr && dr(kr), `nostr:${mr}`;
    } catch (mr) {
      return gr;
    }
  }), await Promise.all(fr), lr = lr.replace(ur, (gr, mr) => {
    const vr = ["t", mr];
    return ar.find((yr) => yr[0] === vr[0] && yr[1] === vr[1]) || ar.push(vr), gr;
  }), { content: lr, tags: ar };
}
async function maybeGetEventRelayUrl(lr) {
  return "";
}
function isReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 1e4 && this.kind < 2e4;
}
function isEphemeral() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 2e4 && this.kind < 3e4;
}
function isParamReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}
var NDKKind = /* @__PURE__ */ ((lr) => (lr[lr.Metadata = 0] = "Metadata", lr[lr.Text = 1] = "Text", lr[lr.RecommendRelay = 2] = "RecommendRelay", lr[lr.Contacts = 3] = "Contacts", lr[lr.EncryptedDirectMessage = 4] = "EncryptedDirectMessage", lr[lr.EventDeletion = 5] = "EventDeletion", lr[lr.Repost = 6] = "Repost", lr[lr.Reaction = 7] = "Reaction", lr[lr.BadgeAward = 8] = "BadgeAward", lr[lr.GroupChat = 9] = "GroupChat", lr[lr.GroupNote = 11] = "GroupNote", lr[lr.GenericRepost = 16] = "GenericRepost", lr[lr.ChannelCreation = 40] = "ChannelCreation", lr[lr.ChannelMetadata = 41] = "ChannelMetadata", lr[lr.ChannelMessage = 42] = "ChannelMessage", lr[lr.ChannelHideMessage = 43] = "ChannelHideMessage", lr[lr.ChannelMuteUser = 44] = "ChannelMuteUser", lr[lr.Report = 1984] = "Report", lr[lr.Label = 1985] = "Label", lr[lr.DVMReqTextExtraction = 5e3] = "DVMReqTextExtraction", lr[lr.DVMReqTextSummarization = 5001] = "DVMReqTextSummarization", lr[lr.DVMReqTextTranslation = 5002] = "DVMReqTextTranslation", lr[lr.DVMReqTextGeneration = 5050] = "DVMReqTextGeneration", lr[lr.DVMReqImageGeneration = 5100] = "DVMReqImageGeneration", lr[lr.DVMReqDiscoveryNostrContent = 5300] = "DVMReqDiscoveryNostrContent", lr[lr.DVMReqDiscoveryNostrPeople = 5301] = "DVMReqDiscoveryNostrPeople", lr[lr.DVMReqTimestamping = 5900] = "DVMReqTimestamping", lr[lr.DVMJobFeedback = 7e3] = "DVMJobFeedback", lr[lr.MuteList = 1e4] = "MuteList", lr[lr.PinList = 10001] = "PinList", lr[lr.RelayList = 10002] = "RelayList", lr[lr.BookmarkList = 10003] = "BookmarkList", lr[lr.CommunityList = 10004] = "CommunityList", lr[lr.PublicChatList = 10005] = "PublicChatList", lr[lr.BlockRelayList = 10006] = "BlockRelayList", lr[lr.SearchRelayList = 10007] = "SearchRelayList", lr[lr.InterestList = 10015] = "InterestList", lr[lr.EmojiList = 10030] = "EmojiList", lr[lr.FollowSet = 3e4] = "FollowSet", lr[
  lr.CategorizedPeopleList = 3e4
  /* FollowSet */
] = "CategorizedPeopleList", lr[lr.CategorizedBookmarkList = 30001] = "CategorizedBookmarkList", lr[lr.RelaySet = 30002] = "RelaySet", lr[
  lr.CategorizedRelayList = 30002
  /* RelaySet */
] = "CategorizedRelayList", lr[lr.BookmarkSet = 30003] = "BookmarkSet", lr[lr.CurationSet = 30004] = "CurationSet", lr[lr.InterestSet = 30015] = "InterestSet", lr[
  lr.InterestsList = 30015
  /* InterestSet */
] = "InterestsList", lr[lr.EmojiSet = 30030] = "EmojiSet", lr[lr.HighlightSet = 39802] = "HighlightSet", lr[
  lr.CategorizedHighlightList = 39802
  /* HighlightSet */
] = "CategorizedHighlightList", lr[lr.ZapRequest = 9734] = "ZapRequest", lr[lr.Zap = 9735] = "Zap", lr[lr.Highlight = 9802] = "Highlight", lr[lr.ClientAuth = 22242] = "ClientAuth", lr[lr.NostrConnect = 24133] = "NostrConnect", lr[lr.ProfileBadge = 30008] = "ProfileBadge", lr[lr.BadgeDefinition = 30009] = "BadgeDefinition", lr[lr.MarketStall = 30017] = "MarketStall", lr[lr.MarketProduct = 30018] = "MarketProduct", lr[lr.Article = 30023] = "Article", lr[lr.AppSpecificData = 30078] = "AppSpecificData", lr[lr.Classified = 30402] = "Classified", lr[lr.AppRecommendation = 31989] = "AppRecommendation", lr[lr.AppHandler = 31990] = "AppHandler", lr))(NDKKind || {});
async function encrypt$2(lr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  if (ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), !lr) {
    const cr = this.getMatchingTags("p");
    if (cr.length !== 1)
      throw new Error(
        "No recipient could be determined and no explicit recipient was provided"
      );
    lr = this.ndk.getUser({ hexpubkey: cr[0][1] });
  }
  this.content = await (ar == null ? void 0 : ar.encrypt(lr, this.content));
}
async function decrypt$2(lr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), lr || (lr = this.author), this.content = await (ar == null ? void 0 : ar.decrypt(lr, this.content));
}
function encode$2() {
  return this.isParamReplaceable() ? nip19_exports$2.naddrEncode({
    kind: this.kind,
    pubkey: this.pubkey,
    identifier: this.replaceableDTag(),
    relays: this.relay ? [this.relay.url] : []
  }) : this.relay ? nip19_exports$2.neventEncode({
    id: this.tagId(),
    relays: [this.relay.url],
    author: this.pubkey
  }) : nip19_exports$2.noteEncode(this.tagId());
}
async function repost(lr = !0, ar) {
  if (!ar && lr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner(), ar = this.ndk.signer;
  }
  const cr = new NDKEvent(this.ndk, {
    kind: getKind(this),
    content: ""
  });
  return cr.tag(this), cr.kind === 16 && cr.tags.push(["k", `${this.kind}`]), ar && await cr.sign(ar), lr && await cr.publish(), cr;
}
function getKind(lr) {
  return lr.kind === 1 ? 6 : 16;
}
var NDKEvent = class extends lib$2.EventEmitter {
  constructor(ar, cr) {
    super();
    ji(this, "ndk");
    ji(this, "created_at");
    ji(this, "content", "");
    ji(this, "tags", []);
    ji(this, "kind");
    ji(this, "id", "");
    ji(this, "sig");
    ji(this, "pubkey", "");
    ji(this, "_author");
    /**
     * The relay that this event was first received from.
     */
    ji(this, "relay");
    ji(this, "isReplaceable", isReplaceable.bind(this));
    ji(this, "isEphemeral", isEphemeral.bind(this));
    ji(this, "isParamReplaceable", isParamReplaceable.bind(this));
    /**
     * Encodes a bech32 id.
     *
     * @returns {string} - Encoded naddr, note or nevent.
     */
    ji(this, "encode", encode$2.bind(this));
    ji(this, "encrypt", encrypt$2.bind(this));
    ji(this, "decrypt", decrypt$2.bind(this));
    /**
     * NIP-18 reposting event.
     *
     * @param publish Whether to publish the reposted event automatically
     * @param signer The signer to use for signing the reposted event
     * @returns The reposted event
     *
     * @function
     */
    ji(this, "repost", repost.bind(this));
    this.ndk = ar, this.created_at = cr == null ? void 0 : cr.created_at, this.content = (cr == null ? void 0 : cr.content) || "", this.tags = (cr == null ? void 0 : cr.tags) || [], this.id = (cr == null ? void 0 : cr.id) || "", this.sig = cr == null ? void 0 : cr.sig, this.pubkey = (cr == null ? void 0 : cr.pubkey) || "", this.kind = cr == null ? void 0 : cr.kind;
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(ar) {
    this.pubkey = ar.hexpubkey, this._author = void 0;
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    if (this._author)
      return this._author;
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = this.ndk.getUser({ hexpubkey: this.pubkey });
    return this._author = ar, ar;
  }
  tag(ar, cr) {
    const ur = (ar == null ? void 0 : ar.pubkey) === this.pubkey, fr = ar.referenceTags(cr, ur);
    if (this.tags = mergeTags(this.tags, fr), ar instanceof NDKEvent)
      for (const dr of ar.getMatchingTags("p"))
        dr[1] !== this.pubkey && (this.tags.find((gr) => gr[0] === "p" && gr[1] === dr[1]) || this.tags.push(["p", dr[1]]));
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(ar) {
    var dr, gr;
    if (!ar && this.pubkey === "") {
      const mr = await ((gr = (dr = this.ndk) == null ? void 0 : dr.signer) == null ? void 0 : gr.user());
      this.pubkey = (mr == null ? void 0 : mr.hexpubkey) || "";
    }
    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));
    const cr = this.rawEvent(), { content: ur, tags: fr } = await this.generateTags();
    cr.content = ur || "", cr.tags = fr;
    try {
      this.id = getEventHash$2(cr);
    } catch (mr) {
    }
    return this.id && (cr.id = this.id), this.sig && (cr.sig = this.sig), cr;
  }
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(ar) {
    return this.tags.filter((cr) => cr[0] === ar);
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(ar) {
    const cr = this.getMatchingTags(ar);
    if (cr.length !== 0)
      return cr[0][1];
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name to search for and remove
   * @returns {void}
   */
  removeTag(ar) {
    this.tags = this.tags.filter((cr) => cr[0] !== ar);
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(ar) {
    var ur;
    ar ? this.author = await ar.user() : ((ur = this.ndk) == null || ur.assertSigner(), ar = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));
    const cr = await this.toNostrEvent();
    return this.sig = await ar.sign(cr), this.sig;
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(ar, cr) {
    if (this.sig || await this.sign(), !this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    return ar || (ar = this.ndk.devWriteRelaySet || calculateRelaySetFromEvent(this.ndk)), ar.publish(this, cr);
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  async generateTags() {
    var fr, dr, gr;
    let ar = [];
    const cr = await generateContentTags(this.content, this.tags), ur = cr.content;
    if (ar = cr.tags, this.kind && this.isParamReplaceable() && !this.getMatchingTags("d")[0]) {
      const vr = this.tagValue("title");
      let kr = [...Array(vr ? 6 : 16)].map(() => Math.random().toString(36)[2]).join("");
      vr && vr.length > 0 && (kr = vr.replace(/[^a-z0-9]+/gi, "-").replace(/^-|-$/g, "") + "-" + kr), ar.push(["d", kr]);
    }
    if (((fr = this.ndk) != null && fr.clientName || (dr = this.ndk) != null && dr.clientNip89) && !this.tagValue("client")) {
      const mr = ["client", (gr = this.ndk.clientName) != null ? gr : ""];
      this.ndk.clientNip89 && mr.push(this.ndk.clientNip89), ar.push(mr);
    }
    return { content: ur || "", tags: ar };
  }
  muted() {
    var fr, dr;
    const ar = (fr = this.ndk) == null ? void 0 : fr.mutedIds.get(this.pubkey);
    if (ar && ar === "p")
      return "author";
    const cr = this.tagReference(), ur = (dr = this.ndk) == null ? void 0 : dr.mutedIds.get(cr[1]);
    return ur && ur === cr[0] ? "event" : null;
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const ar = this.getMatchingTags("d")[0];
      return ar ? ar[1] : "";
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Provides a deduplication key for the event.
   *
   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
   * For all other kinds this will be the event id
   */
  deduplicationKey() {
    return this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4 ? `${this.kind}:${this.pubkey}` : this.tagId();
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    return this.isParamReplaceable() ? this.tagAddress() : this.id;
  }
  /**
   * Returns the "reference" value ("<kind>:<author-pubkey>:<d-tag>") for this replaceable event.
   * @returns {string} The id
   */
  tagAddress() {
    if (!this.isParamReplaceable())
      throw new Error("This must only be called on replaceable events");
    const ar = this.replaceableDTag();
    return `${this.kind}:${this.pubkey}:${ar}`;
  }
  /**
   * Get the tag that can be used to reference this event from another event.
   *
   * Consider using referenceTags() instead (unless you have a good reason to use this)
   *
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference(ar) {
    let cr;
    return this.isParamReplaceable() ? cr = ["a", this.tagAddress()] : cr = ["e", this.tagId()], this.relay ? cr.push(this.relay.url) : cr.push(""), ar && cr.push(ar), cr;
  }
  /**
   * Get the tags that can be used to reference this event from another event
   * @param marker The marker to use in the tag
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.referenceTags(); // [["e", "parent-id"]]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  referenceTags(ar, cr) {
    var fr;
    let ur = [];
    return this.isParamReplaceable() ? ur = [
      ["a", this.tagAddress()],
      ["e", this.id]
    ] : ur = [["e", this.id]], (fr = this.relay) != null && fr.url ? ur = ur.map((dr) => {
      var gr;
      return dr.push((gr = this.relay) == null ? void 0 : gr.url), dr;
    }) : ar && (ur = ur.map((dr) => (dr.push(""), dr))), ar && ur.forEach((dr) => dr.push(ar)), cr || ur.push(...this.author.referenceTags()), ur;
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    return this.isParamReplaceable() ? { "#a": [this.tagId()] } : { "#e": [this.tagId()] };
  }
  /**
   * Create a zap request for an existing event
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param recipient The zap recipient (optional for events)
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(ar, cr, ur, fr, dr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    dr || this.ndk.assertSigner();
    const gr = new Zap$1({
      ndk: this.ndk,
      zappedEvent: this,
      zappedUser: fr
    }), mr = Array.from(this.ndk.pool.relays.keys());
    return await gr.createZapRequest(
      ar,
      cr,
      ur,
      mr,
      dr
    );
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @returns The deletion event
   */
  async delete(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const cr = new NDKEvent(this.ndk, {
      kind: 5,
      content: ar || ""
    });
    return cr.tag(this), await cr.publish(), cr;
  }
  /**
   * React to an existing event
   *
   * @param content The content of the reaction
   */
  async react(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const cr = new NDKEvent(this.ndk, {
      kind: 7,
      content: ar
    });
    return cr.tag(this), await cr.publish(), cr;
  }
}, READ_MARKER = "read", WRITE_MARKER = "write", NDKRelayList = class extends NDKEvent {
  constructor(lr, ar) {
    var cr;
    super(lr, ar), (cr = this.kind) != null || (this.kind = 10002);
  }
  static from(lr) {
    return new NDKRelayList(lr.ndk, lr.rawEvent());
  }
  get readRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2] || lr[2] && lr[2] === READ_MARKER).map((lr) => lr[1]);
  }
  set readRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar, READ_MARKER]);
  }
  get writeRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2] || lr[2] && lr[2] === WRITE_MARKER).map((lr) => lr[1]);
  }
  set writeRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar, WRITE_MARKER]);
  }
  get bothRelayUrls() {
    return this.getMatchingTags("r").filter((lr) => !lr[2]).map((lr) => lr[1]);
  }
  set bothRelayUrls(lr) {
    for (const ar of lr)
      this.tags.push(["r", ar]);
  }
  get relays() {
    return this.getMatchingTags("r").map((lr) => lr[1]);
  }
}, defaultOpts = {
  closeOnEose: !1,
  cacheUsage: "CACHE_FIRST",
  groupable: !0,
  groupableDelay: 100
}, NDKSubscription = class extends lib$2.EventEmitter {
  constructor(ar, cr, ur, fr, dr) {
    var gr;
    super();
    ji(this, "subId");
    ji(this, "filters");
    ji(this, "opts");
    ji(this, "pool");
    /**
     * Tracks the filters as they are executed on each relay
     */
    ji(this, "relayFilters");
    ji(this, "relaySet");
    ji(this, "ndk");
    ji(this, "debug");
    ji(this, "eoseDebug");
    /**
     * Events that have been seen by the subscription, with the time they were first seen.
     */
    ji(this, "eventFirstSeen", /* @__PURE__ */ new Map());
    /**
     * Relays that have sent an EOSE.
     */
    ji(this, "eosesSeen", /* @__PURE__ */ new Set());
    /**
     * Events that have been seen by the subscription per relay.
     */
    ji(this, "eventsPerRelay", /* @__PURE__ */ new Map());
    /**
     * The time the last event was received by the subscription.
     * This is used to calculate when EOSE should be emitted.
     */
    ji(this, "lastEventReceivedAt");
    ji(this, "internalId");
    // EOSE handling
    ji(this, "eoseTimeout");
    if (this.ndk = ar, this.pool = (ur == null ? void 0 : ur.pool) || ar.pool, this.opts = { ...defaultOpts, ...ur || {} }, this.filters = cr instanceof Array ? cr : [cr], this.subId = dr || (ur == null ? void 0 : ur.subId), this.internalId = Math.random().toString(36).substring(7), this.relaySet = fr, this.debug = ar.debug.extend(`subscription[${(gr = ur == null ? void 0 : ur.subId) != null ? gr : this.internalId}]`), this.eoseDebug = this.debug.extend("eose"), this.opts.closeOnEose || this.debug(
      "Creating a permanent subscription",
      this.opts,
      JSON.stringify(this.filters)
    ), this.opts.cacheUsage === "ONLY_CACHE" && !this.opts.closeOnEose)
      throw new Error("Cannot use cache-only options with a persistent subscription");
  }
  /**
   * Provides access to the first filter of the subscription for
   * backwards compatibility.
   */
  get filter() {
    return this.filters[0];
  }
  isGroupable() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.groupable) || !1;
  }
  shouldQueryCache() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_RELAY";
  }
  shouldQueryRelays() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_CACHE";
  }
  shouldWaitForCache() {
    var ar;
    return (
      // Must want to close on EOSE; subscriptions
      // that want to receive further updates must
      // always hit the relay
      this.opts.closeOnEose && // Cache adapter must claim to be fast
      !!((ar = this.ndk.cacheAdapter) != null && ar.locking) && // If explicitly told to run in parallel, then
      // we should not wait for the cache
      this.opts.cacheUsage !== "PARALLEL"
    );
  }
  /**
   * Start the subscription. This is the main method that should be called
   * after creating a subscription.
   */
  async start() {
    let ar;
    if (this.shouldQueryCache() && (ar = this.startWithCache(), this.shouldWaitForCache() && (await ar, queryFullyFilled(this)))) {
      this.emit("eose", this);
      return;
    }
    this.shouldQueryRelays() ? this.startWithRelays() : this.emit("eose", this);
  }
  stop() {
    this.emit("close", this), this.removeAllListeners();
  }
  /**
   * @returns Whether the subscription has an authors filter.
   */
  hasAuthorsFilter() {
    return this.filters.some((ar) => {
      var cr;
      return (cr = ar.authors) == null ? void 0 : cr.length;
    });
  }
  async startWithCache() {
    var ar;
    if ((ar = this.ndk.cacheAdapter) != null && ar.query) {
      const cr = this.ndk.cacheAdapter.query(this);
      this.ndk.cacheAdapter.locking && await cr;
    }
  }
  /**
   * Send REQ to relays
   */
  startWithRelays() {
    if (!this.relaySet)
      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters);
    else {
      this.relayFilters = /* @__PURE__ */ new Map();
      for (const ar of this.relaySet.relays)
        this.relayFilters.set(ar.url, this.filters);
    }
    for (const [ar, cr] of this.relayFilters)
      this.pool.getRelay(ar).subscribe(this, cr);
  }
  // EVENT handling
  /**
   * Called when an event is received from a relay or the cache
   * @param event
   * @param relay
   * @param fromCache Whether the event was received from the cache
   */
  eventReceived(ar, cr, ur = !1) {
    if (cr && (ar.relay = cr), cr || (cr = ar.relay), !ur && cr) {
      let fr = this.eventsPerRelay.get(cr);
      if (fr || (fr = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(cr, fr)), fr.add(ar.id), this.eventFirstSeen.has(ar.id)) {
        const gr = Date.now() - (this.eventFirstSeen.get(ar.id) || 0);
        cr.scoreSlowerEvent(gr), this.emit("event:dup", ar, cr, gr, this);
        return;
      }
      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(ar, this.filters[0], cr), this.eventFirstSeen.set(ar.id, Date.now());
    } else
      this.eventFirstSeen.set(ar.id, 0);
    ar.ndk || (ar.ndk = this.ndk), this.emit("event", ar, cr, this), this.lastEventReceivedAt = Date.now();
  }
  eoseReceived(ar) {
    var dr, gr, mr;
    this.eosesSeen.add(ar), this.eoseDebug(`received from ${ar.url}`);
    let cr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;
    const ur = this.eosesSeen.size === ((dr = this.relayFilters) == null ? void 0 : dr.size);
    if (queryFullyFilled(this))
      this.emit("eose"), this.eoseDebug("Query fully filled"), (gr = this.opts) != null && gr.closeOnEose && this.stop();
    else if (ur)
      this.emit("eose"), this.eoseDebug("All EOSEs seen"), (mr = this.opts) != null && mr.closeOnEose && this.stop();
    else {
      let vr = 1e3;
      const yr = this.eosesSeen.size / this.relayFilters.size;
      if (this.eosesSeen.size >= 2 && yr >= 0.5) {
        vr = vr * (1 - yr), this.eoseTimeout && clearTimeout(this.eoseTimeout);
        const kr = () => {
          var _r;
          cr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0, cr !== void 0 && cr < 20 ? this.eoseTimeout = setTimeout(kr, vr) : (this.emit("eose"), (_r = this.opts) != null && _r.closeOnEose && this.stop());
        };
        this.eoseTimeout = setTimeout(kr, vr);
      }
    }
  }
};
async function follows(lr, ar, cr = 3) {
  if (!this.ndk)
    throw new Error("NDK not set");
  const ur = Array.from(
    await this.ndk.fetchEvents(
      {
        kinds: [cr],
        authors: [this.pubkey]
      },
      lr || { groupable: !1 }
    )
  )[0];
  if (ur) {
    const fr = /* @__PURE__ */ new Set();
    return ur.tags.forEach((dr) => {
      var gr, mr;
      if (dr[0] === "p")
        try {
          fr.add(dr[1]), ar && ((mr = (gr = this.ndk) == null ? void 0 : gr.outboxTracker) == null || mr.trackUsers([dr[1]]));
        } catch (vr) {
        }
    }), [...fr].reduce((dr, gr) => {
      const mr = new NDKUser({ pubkey: gr });
      return mr.ndk = this.ndk, dr.add(mr), dr;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}
function profileFromEvent(lr) {
  const ar = {}, cr = JSON.parse(lr.content);
  return Object.keys(cr).forEach((ur) => {
    switch (ur) {
      case "name":
        ar.name = cr.name;
        break;
      case "display_name":
        ar.displayName = cr.display_name;
        break;
      case "image":
      case "picture":
        ar.image = cr.image || cr.picture;
        break;
      case "banner":
        ar.banner = cr.banner;
        break;
      case "bio":
        ar.bio = cr.bio;
        break;
      case "nip05":
        ar.nip05 = cr.nip05;
        break;
      case "lud06":
        ar.lud06 = cr.lud06;
        break;
      case "lud16":
        ar.lud16 = cr.lud16;
        break;
      case "about":
        ar.about = cr.about;
        break;
      case "zapService":
        ar.zapService = cr.zapService;
        break;
      case "website":
        ar.website = cr.website;
        break;
      default:
        ar[ur] = cr[ur];
        break;
    }
  }), ar;
}
function serializeProfile(lr) {
  const ar = {};
  for (const [cr, ur] of Object.entries(lr))
    switch (cr) {
      case "username":
      case "name":
        ar.name = ur;
        break;
      case "displayName":
        ar.display_name = ur;
        break;
      case "image":
      case "picture":
        ar.picture = ur;
        break;
      case "bio":
      case "about":
        ar.about = ur;
        break;
      default:
        ar[cr] = ur;
        break;
    }
  return JSON.stringify(ar);
}
var NDKList = class extends NDKEvent {
  constructor(ar, cr) {
    var ur;
    super(ar, cr);
    ji(this, "_encryptedTags");
    /**
     * Stores the number of bytes the content was before decryption
     * to expire the cache when the content changes.
     */
    ji(this, "encryptedTagsLength");
    (ur = this.kind) != null || (this.kind = 30001);
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ar) {
    return new NDKList(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns the title of the list. Falls back on fetching the name tag value.
   */
  get title() {
    const ar = this.tagValue("title") || this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the title of the list.
   */
  set title(ar) {
    if (this.removeTag("title"), this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Title cannot be empty");
  }
  /**
   * Returns the name of the list.
   * @deprecated Please use "title" instead.
   */
  get name() {
    const ar = this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the name of the list.
   * @deprecated Please use "title" instead. This method will use the `title` tag instead.
   */
  set name(ar) {
    if (this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Name cannot be empty");
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(ar) {
    ar ? this.tags.push(["description", ar]) : this.removeTag("description");
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(ar = !0) {
    if (ar && this.isEncryptedTagsCacheValid())
      return this._encryptedTags;
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    const cr = await this.ndk.signer.user();
    try {
      if (this.content.length > 0)
        try {
          const ur = await this.ndk.signer.decrypt(cr, this.content), fr = JSON.parse(ur);
          return fr && fr[0] ? (this.encryptedTagsLength = this.content.length, this._encryptedTags = fr) : (this.encryptedTagsLength = this.content.length, this._encryptedTags = []);
        } catch (ur) {
          console.log(`error decrypting ${this.content}`);
        }
    } catch (ur) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(ar) {
    return !0;
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((ar) => ![
      "d",
      "L",
      "l",
      "title",
      "name",
      "description",
      "summary",
      "image",
      "thumb",
      "alt",
      "expiration",
      "subject"
    ].includes(ar[0]));
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   */
  async addItem(ar, cr = void 0, ur = !1) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    let fr;
    if (ar instanceof NDKEvent)
      fr = ar.referenceTags();
    else if (ar instanceof NDKUser)
      fr = ar.referenceTags();
    else if (ar instanceof NDKRelay)
      fr = ar.referenceTags();
    else if (Array.isArray(ar))
      fr = [ar];
    else
      throw new Error("Invalid object type");
    if (cr && fr[0].push(cr), ur) {
      const dr = await this.ndk.signer.user(), gr = await this.encryptedTags();
      gr.push(...fr), this._encryptedTags = gr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(gr), await this.encrypt(dr);
    } else
      this.tags.push(...fr);
    this.created_at = Math.floor(Date.now() / 1e3), this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(ar, cr) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    if (cr) {
      const ur = await this.ndk.signer.user(), fr = await this.encryptedTags();
      fr.splice(ar, 1), this._encryptedTags = fr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(fr), await this.encrypt(ur);
    } else
      this.tags.splice(ar, 1);
    return this.created_at = Math.floor(Date.now() / 1e3), this.emit("change"), this;
  }
}, lists_default = NDKList;
async function pin(lr, ar, cr) {
  if (!this.ndk)
    throw new Error("No NDK instance found");
  if (this.ndk.assertSigner(), !ar) {
    const fr = await this.ndk.fetchEvents(
      { kinds: [10001], authors: [this.pubkey] },
      {
        cacheUsage: "ONLY_RELAY"
        /* ONLY_RELAY */
      }
    );
    fr.size > 0 ? ar = lists_default.from(Array.from(fr)[0]) : ar = new NDKEvent(this.ndk, {
      kind: 10001
    });
  }
  return ar.tag(lr), cr && await ar.publish(), ar;
}
var NDKUser = class {
  constructor(lr) {
    ji(this, "ndk");
    ji(this, "profile");
    ji(this, "_npub");
    ji(this, "_pubkey");
    ji(this, "relayUrls", []);
    /**
     * Returns a set of users that this user follows.
     */
    ji(this, "follows", follows.bind(this));
    /**
     * Pins a user or an event
     */
    ji(this, "pin", pin.bind(this));
    lr.npub && (this._npub = lr.npub), lr.hexpubkey && (this._pubkey = lr.hexpubkey), lr.pubkey && (this._pubkey = lr.pubkey), lr.relayUrls && (this.relayUrls = lr.relayUrls);
  }
  get npub() {
    if (!this._npub) {
      if (!this._pubkey)
        throw new Error("hexpubkey not set");
      this._npub = nip19_exports$2.npubEncode(this.pubkey);
    }
    return this._npub;
  }
  set npub(lr) {
    this._npub = lr;
  }
  /**
   * Get the user's hexpubkey
   * @returns {Hexpubkey} The user's hexpubkey
   *
   * @deprecated Use `pubkey` instead
   */
  get hexpubkey() {
    return this.pubkey;
  }
  /**
   * Set the user's hexpubkey
   * @param pubkey {Hexpubkey} The user's hexpubkey
   * @deprecated Use `pubkey` instead
   */
  set hexpubkey(lr) {
    this._pubkey = lr;
  }
  /**
   * Get the user's pubkey
   * @returns {string} The user's pubkey
   */
  get pubkey() {
    if (!this._pubkey) {
      if (!this._npub)
        throw new Error("npub not set");
      this._pubkey = nip19_exports$2.decode(this.npub).data;
    }
    return this._pubkey;
  }
  /**
   * Set the user's pubkey
   * @param pubkey {string} The user's pubkey
   */
  set pubkey(lr) {
    this._pubkey = lr;
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(lr) {
    const ar = await nip05_exports$2.queryProfile(lr);
    if (ar)
      return new NDKUser({
        pubkey: ar.pubkey,
        relayUrls: ar.relays
      });
  }
  /**
   * Fetch a user's profile
   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
   * @returns User Profile
   */
  async fetchProfile(lr) {
    if (!this.ndk)
      throw new Error("NDK not set");
    this.profile || (this.profile = {});
    let ar = null;
    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && (lr == null ? void 0 : lr.cacheUsage) !== "ONLY_RELAY") {
      const ur = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);
      if (ur)
        return this.profile = ur, ur;
    }
    !lr && // if no options have been set
    this.ndk.cacheAdapter && // and we have a cache
    this.ndk.cacheAdapter.locking && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      {
        cacheUsage: "ONLY_CACHE",
        closeOnEose: !0,
        groupable: !1
      }
    ), lr = {
      cacheUsage: "ONLY_RELAY",
      closeOnEose: !0,
      groupable: !0,
      groupableDelay: 250
    }), (!ar || ar.size === 0) && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      lr
    ));
    const cr = Array.from(ar).sort(
      (ur, fr) => ur.created_at - fr.created_at
    );
    return cr.length === 0 ? null : (this.profile = profileFromEvent(cr[0]), this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile && this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile), this.profile);
  }
  /**
   * Returns a set of relay list events for a user.
   * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.
   */
  async relayList() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const lr = this.ndk.outboxPool || this.ndk.pool, ar = /* @__PURE__ */ new Set();
    for (const fr of lr.relays.values())
      ar.add(fr);
    const cr = new NDKRelaySet(ar, this.ndk), ur = await this.ndk.fetchEvent(
      {
        kinds: [10002],
        authors: [this.pubkey]
      },
      {
        closeOnEose: !0,
        pool: lr,
        groupable: !0,
        subId: `relay-list-${this.pubkey.slice(0, 6)}`
      },
      cr
    );
    return ur ? NDKRelayList.from(ur) : await this.relayListFromKind3();
  }
  async relayListFromKind3() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const lr = await this.ndk.fetchEvent({
      kinds: [3],
      authors: [this.pubkey]
    });
    if (lr)
      try {
        const ar = JSON.parse(lr.content), cr = new NDKRelayList(this.ndk), ur = /* @__PURE__ */ new Set(), fr = /* @__PURE__ */ new Set();
        for (const [dr, gr] of Object.entries(ar))
          if (!gr)
            ur.add(dr), fr.add(dr);
          else {
            const mr = gr;
            mr.write && fr.add(dr), mr.read && ur.add(dr);
          }
        return cr.readRelayUrls = Array.from(ur), cr.writeRelayUrls = Array.from(fr), cr;
      } catch (ar) {
      }
  }
  /** @deprecated Use referenceTags instead. */
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.pubkey];
  }
  /**
   * Get the tags that can be used to reference this user in an event
   * @returns {NDKTag[]} an array of NDKTag
   */
  referenceTags(lr) {
    const ar = [["p", this.pubkey]];
    return lr && ar[0].push("", lr), ar;
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (!this.profile)
      throw new Error("No profile available");
    this.ndk.assertSigner(), await new NDKEvent(this.ndk, {
      kind: 0,
      content: serializeProfile(this.profile)
    }).publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(lr, ar, cr = 3) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (this.ndk.assertSigner(), ar || (ar = await this.follows(void 0, void 0, cr)), ar.has(lr))
      return !1;
    ar.add(lr);
    const ur = new NDKEvent(this.ndk, { kind: cr });
    for (const fr of ar)
      ur.tag(fr);
    return await ur.publish(), !0;
  }
  /**
   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
   *
   * @param nip05Id The NIP-05 string to validate
   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
   * False if the NIP-05 is found but doesn't match this user's pubkey,
   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
   */
  async validateNip05(lr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = await nip05_exports$2.queryProfile(lr);
    return ar === null ? null : ar.pubkey === this.pubkey;
  }
  /**
   * Zap a user
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(lr, ar, cr, ur) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    ur || this.ndk.assertSigner();
    const fr = new Zap$1({
      ndk: this.ndk,
      zappedUser: this
    }), dr = Array.from(this.ndk.pool.relays.keys());
    return await fr.createZapRequest(
      lr,
      ar,
      cr,
      dr,
      ur
    );
  }
}, NDKRepost = class extends NDKEvent {
  constructor(ar, cr) {
    super(ar, cr);
    ji(this, "_repostedEvents");
  }
  static from(ar) {
    return new NDKRepost(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns all reposted events by the current event.
   *
   * @param klass Optional class to convert the events to.
   * @returns
   */
  async repostedEvents(ar, cr) {
    const ur = [];
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (this._repostedEvents !== void 0)
      return this._repostedEvents;
    for (const fr of this.repostedEventIds()) {
      const dr = filterForId(fr), gr = await this.ndk.fetchEvent(dr, cr);
      gr && ur.push(ar ? ar.from(gr) : gr);
    }
    return ur;
  }
  /**
   * Returns the reposted event IDs.
   */
  repostedEventIds() {
    return this.tags.filter((ar) => ar[0] === "e" || ar[0] === "a").map((ar) => ar[1]);
  }
};
function filterForId(lr) {
  if (lr.match(/:/)) {
    const [ar, cr, ur] = lr.split(":");
    return {
      kinds: [parseInt(ar)],
      authors: [cr],
      "#d": [ur]
    };
  } else
    return { ids: [lr] };
}
var NDKNip07Signer = class {
  /**
   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available
   */
  constructor(lr = 1e3) {
    ji(this, "_userPromise");
    ji(this, "nip04Queue", []);
    ji(this, "nip04Processing", !1);
    ji(this, "debug");
    ji(this, "waitTimeout");
    this.debug = _debug("ndk:nip07"), this.waitTimeout = lr;
  }
  async blockUntilReady() {
    await this.waitForExtension();
    const lr = await window.nostr.getPublicKey();
    if (!lr)
      throw new Error("User rejected access");
    return new NDKUser({ hexpubkey: lr });
  }
  /**
   * Getter for the user property.
   * @returns The NDKUser instance.
   */
  async user() {
    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;
  }
  /**
   * Signs the given Nostr event.
   * @param event - The Nostr event to be signed.
   * @returns The signature of the signed event.
   * @throws Error if the NIP-07 is not available on the window object.
   */
  async sign(lr) {
    return await this.waitForExtension(), (await window.nostr.signEvent(lr)).sig;
  }
  async relays() {
    var cr, ur;
    await this.waitForExtension();
    const lr = await ((ur = (cr = window.nostr).getRelays) == null ? void 0 : ur.call(cr)) || {}, ar = [];
    for (const fr of Object.keys(lr))
      lr[fr].read && lr[fr].write && ar.push(fr);
    return ar.map((fr) => new NDKRelay(fr));
  }
  async encrypt(lr, ar) {
    await this.waitForExtension();
    const cr = lr.hexpubkey;
    return this.queueNip04("encrypt", cr, ar);
  }
  async decrypt(lr, ar) {
    await this.waitForExtension();
    const cr = lr.hexpubkey;
    return this.queueNip04("decrypt", cr, ar);
  }
  async queueNip04(lr, ar, cr) {
    return new Promise((ur, fr) => {
      this.nip04Queue.push({
        type: lr,
        counterpartyHexpubkey: ar,
        value: cr,
        resolve: ur,
        reject: fr
      }), this.nip04Processing || this.processNip04Queue();
    });
  }
  async processNip04Queue(lr, ar = 0) {
    if (!lr && this.nip04Queue.length === 0) {
      this.nip04Processing = !1;
      return;
    }
    this.nip04Processing = !0;
    const { type: cr, counterpartyHexpubkey: ur, value: fr, resolve: dr, reject: gr } = lr || this.nip04Queue.shift();
    this.debug("Processing encryption queue item", {
      type: cr,
      counterpartyHexpubkey: ur,
      value: fr
    });
    try {
      let mr;
      cr === "encrypt" ? mr = await window.nostr.nip04.encrypt(ur, fr) : mr = await window.nostr.nip04.decrypt(ur, fr), dr(mr);
    } catch (mr) {
      if (mr.message && mr.message.includes("call already executing") && ar < 5) {
        this.debug("Retrying encryption queue item", {
          type: cr,
          counterpartyHexpubkey: ur,
          value: fr,
          retries: ar
        }), setTimeout(() => {
          this.processNip04Queue(lr, ar + 1);
        }, 50 * ar);
        return;
      }
      gr(mr);
    }
    this.processNip04Queue();
  }
  waitForExtension() {
    return new Promise((lr, ar) => {
      if (window.nostr) {
        lr();
        return;
      }
      let cr;
      const ur = setInterval(() => {
        window.nostr && (clearTimeout(cr), clearInterval(ur), lr());
      }, 100);
      cr = setTimeout(() => {
        clearInterval(ur), ar(new Error("NIP-07 extension not available"));
      }, this.waitTimeout);
    });
  }
}, NDKPrivateKeySigner = class {
  constructor(lr) {
    ji(this, "_user");
    ji(this, "privateKey");
    lr && (this.privateKey = lr, this._user = new NDKUser({
      hexpubkey: getPublicKey$1(this.privateKey)
    }));
  }
  static generate() {
    const lr = generatePrivateKey();
    return new NDKPrivateKeySigner(lr);
  }
  async blockUntilReady() {
    if (!this._user)
      throw new Error("NDKUser not initialized");
    return this._user;
  }
  async user() {
    return await this.blockUntilReady(), this._user;
  }
  async sign(lr) {
    if (!this.privateKey)
      throw Error("Attempted to sign without a private key");
    return getSignature$1(lr, this.privateKey);
  }
  async encrypt(lr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to encrypt without a private key");
    const cr = lr.hexpubkey;
    return await nip04_exports$2.encrypt(this.privateKey, cr, ar);
  }
  async decrypt(lr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to decrypt without a private key");
    const cr = lr.hexpubkey;
    return await nip04_exports$2.decrypt(this.privateKey, cr, ar);
  }
};
function dedup(lr, ar) {
  return lr.created_at > ar.created_at ? lr : ar;
}
var OutboxItem = class {
  constructor(lr) {
    /**
     * Type of item
     */
    ji(this, "type");
    /**
     * The relay URLs that are of interest to this item
     */
    ji(this, "relayUrlScores");
    ji(this, "readRelays");
    ji(this, "writeRelays");
    this.type = lr, this.relayUrlScores = /* @__PURE__ */ new Map(), this.readRelays = /* @__PURE__ */ new Set(), this.writeRelays = /* @__PURE__ */ new Set();
  }
}, OutboxTracker = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    ji(this, "data");
    ji(this, "ndk");
    ji(this, "debug");
    this.ndk = ar, this.debug = ar.debug.extend("outbox-tracker"), this.data = new dist$9.LRUCache({
      maxSize: 1e5,
      entryExpirationTimeInMS: 5e3
    });
  }
  trackUsers(ar) {
    for (const cr of ar) {
      const ur = getKeyFromItem(cr);
      if (this.data.has(ur))
        continue;
      const fr = this.track(cr, "user"), dr = cr instanceof NDKUser ? cr : new NDKUser({ hexpubkey: cr });
      dr.ndk = this.ndk, dr.relayList().then((gr) => {
        if (gr) {
          fr.readRelays = new Set(gr.readRelayUrls), fr.writeRelays = new Set(gr.writeRelayUrls);
          for (const mr of fr.readRelays)
            this.ndk.pool.blacklistRelayUrls.has(mr) && (this.debug(`removing blacklisted relay ${mr} from read relays`), fr.readRelays.delete(mr));
          for (const mr of fr.writeRelays)
            this.ndk.pool.blacklistRelayUrls.has(mr) && (this.debug(`removing blacklisted relay ${mr} from write relays`), fr.writeRelays.delete(mr));
          this.data.set(ur, fr), this.debug(
            `Adding ${fr.readRelays.size} read relays and ${fr.writeRelays.size} write relays for ${dr.hexpubkey}`
          );
        }
      });
    }
  }
  /**
   *
   * @param key
   * @param score
   */
  track(ar, cr) {
    const ur = getKeyFromItem(ar);
    cr != null || (cr = getTypeFromItem(ar));
    let fr = this.data.get(ur);
    return fr || (fr = new OutboxItem(cr)), this.data.set(ur, fr), fr;
  }
};
function getKeyFromItem(lr) {
  return lr instanceof NDKUser ? lr.hexpubkey : lr;
}
function getTypeFromItem(lr) {
  return lr instanceof NDKUser ? "user" : "kind";
}
var NDKPool = class extends lib$2.EventEmitter {
  constructor(ar = [], cr = [], ur, fr) {
    super();
    // TODO: This should probably be an LRU cache
    ji(this, "relays", /* @__PURE__ */ new Map());
    ji(this, "blacklistRelayUrls");
    ji(this, "debug");
    ji(this, "temporaryRelayTimers", /* @__PURE__ */ new Map());
    ji(this, "flappingRelays", /* @__PURE__ */ new Set());
    // A map to store timeouts for each flapping relay.
    ji(this, "backoffTimes", /* @__PURE__ */ new Map());
    this.debug = fr != null ? fr : ur.debug.extend("pool");
    for (const dr of ar) {
      const gr = new NDKRelay(dr);
      this.addRelay(gr, !1);
    }
    this.blacklistRelayUrls = new Set(cr);
  }
  /**
   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.
   * @param relay - The relay to add to the pool.
   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.
   */
  useTemporaryRelay(ar, cr = 6e5) {
    const ur = this.relays.has(ar.url);
    ur || this.addRelay(ar);
    const fr = this.temporaryRelayTimers.get(ar.url);
    if (fr && clearTimeout(fr), !ur || fr) {
      const dr = setTimeout(() => {
        this.removeRelay(ar.url);
      }, cr);
      this.temporaryRelayTimers.set(ar.url, dr);
    }
  }
  /**
   * Adds a relay to the pool.
   *
   * @param relay - The relay to add to the pool.
   * @param connect - Whether or not to connect to the relay.
   */
  addRelay(ar, cr = !0) {
    var fr;
    const ur = ar.url;
    if ((fr = this.blacklistRelayUrls) != null && fr.has(ur)) {
      this.debug(`Relay ${ur} is blacklisted`);
      return;
    }
    ar.on("notice", async (dr, gr) => this.emit("notice", dr, gr)), ar.on("connect", () => this.handleRelayConnect(ur)), ar.on("disconnect", async () => this.emit("relay:disconnect", ar)), ar.on("flapping", () => this.handleFlapping(ar)), this.relays.set(ur, ar), cr && ar.connect().catch((dr) => {
      this.debug(`Failed to connect to relay ${ur}`, dr);
    });
  }
  /**
   * Removes a relay from the pool.
   * @param relayUrl - The URL of the relay to remove.
   * @returns {boolean} True if the relay was removed, false if it was not found.
   */
  removeRelay(ar) {
    const cr = this.relays.get(ar);
    if (cr)
      return cr.disconnect(), this.relays.delete(ar), this.emit("relay:disconnect", cr), !0;
    const ur = this.temporaryRelayTimers.get(ar);
    return ur && (clearTimeout(ur), this.temporaryRelayTimers.delete(ar)), !1;
  }
  /**
   * Fetches a relay from the pool, or creates a new one if it does not exist.
   *
   * New relays will be attempted to be connected.
   */
  getRelay(ar) {
    let cr = this.relays.get(ar);
    return cr || (cr = new NDKRelay(ar), this.addRelay(cr)), cr;
  }
  handleRelayConnect(ar) {
    this.debug(`Relay ${ar} connected`), this.emit("relay:connect", this.relays.get(ar)), this.stats().connected === this.relays.size && this.emit("connect");
  }
  /**
   * Attempts to establish a connection to each relay in the pool.
   *
   * @async
   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
   * @throws {Error} If any of the connection attempts result in an error or timeout.
   */
  async connect(ar) {
    const cr = [];
    this.debug(
      `Connecting to ${this.relays.size} relays${ar ? `, timeout ${ar}...` : ""}`
    );
    for (const ur of this.relays.values())
      if (ar) {
        const fr = new Promise((dr, gr) => {
          setTimeout(() => gr(`Timed out after ${ar}ms`), ar);
        });
        cr.push(
          Promise.race([ur.connect(), fr]).catch((dr) => {
            this.debug(
              `Failed to connect to relay ${ur.url}: ${dr != null ? dr : "No reason specified"}`
            );
          })
        );
      } else
        cr.push(ur.connect());
    ar && setTimeout(() => {
      const ur = this.stats().connected === this.relays.size, fr = this.stats().connected > 0;
      !ur && fr && this.emit("connect");
    }, ar), await Promise.all(cr);
  }
  checkOnFlappingRelays() {
    const ar = this.flappingRelays.size, cr = this.relays.size;
    if (ar / cr >= 0.8)
      for (const ur of this.flappingRelays)
        this.backoffTimes.set(ur, 0);
  }
  handleFlapping(ar) {
    this.debug(`Relay ${ar.url} is flapping`);
    let cr = this.backoffTimes.get(ar.url) || 5e3;
    cr = cr * 2, this.backoffTimes.set(ar.url, cr), this.debug(`Backoff time for ${ar.url} is ${cr}ms`), setTimeout(() => {
      this.debug(`Attempting to reconnect to ${ar.url}`), ar.connect(), this.checkOnFlappingRelays();
    }, cr), ar.disconnect(), this.emit("flapping", ar);
  }
  size() {
    return this.relays.size;
  }
  /**
   * Returns the status of each relay in the pool.
   * @returns {NDKPoolStats} An object containing the number of relays in each status.
   */
  stats() {
    const ar = {
      total: 0,
      connected: 0,
      disconnected: 0,
      connecting: 0
    };
    for (const cr of this.relays.values())
      ar.total++, cr.status === 1 ? ar.connected++ : cr.status === 3 ? ar.disconnected++ : cr.status === 0 && ar.connecting++;
    return ar;
  }
  connectedRelays() {
    return Array.from(this.relays.values()).filter(
      (ar) => ar.status === 1
      /* CONNECTED */
    );
  }
  /**
   * Get a list of all relay urls in the pool.
   */
  urls() {
    return Array.from(this.relays.keys());
  }
};
function correctRelaySet(lr, ar) {
  const cr = ar.connectedRelays();
  if (!Array.from(lr.relays).some((fr) => cr.map((dr) => dr.url).includes(fr.url)))
    for (const fr of cr)
      lr.addRelay(fr);
  if (cr.length === 0)
    for (const fr of ar.relays.values())
      lr.addRelay(fr);
  return lr;
}
var DEFAULT_OUTBOX_RELAYS = ["wss://purplepag.es", "wss://relay.snort.social"], DEFAULT_BLACKLISTED_RELAYS = [
  "wss://brb.io"
  // BRB
], NDK = class extends lib$2.EventEmitter {
  constructor(ar = {}) {
    var cr, ur;
    super();
    ji(this, "explicitRelayUrls");
    ji(this, "pool");
    ji(this, "outboxPool");
    ji(this, "_signer");
    ji(this, "_activeUser");
    ji(this, "cacheAdapter");
    ji(this, "debug");
    ji(this, "devWriteRelaySet");
    ji(this, "outboxTracker");
    ji(this, "mutedIds");
    ji(this, "clientName");
    ji(this, "clientNip89");
    ji(this, "autoConnectUserRelays", !0);
    ji(this, "autoFetchUserMutelist", !0);
    this.debug = ar.debug || _debug("ndk"), this.explicitRelayUrls = ar.explicitRelayUrls, this.pool = new NDKPool(ar.explicitRelayUrls || [], ar.blacklistRelayUrls, this), this.debug(`Starting with explicit relays: ${JSON.stringify(this.explicitRelayUrls)}`), this.autoConnectUserRelays = (cr = ar.autoConnectUserRelays) != null ? cr : !0, this.autoFetchUserMutelist = (ur = ar.autoFetchUserMutelist) != null ? ur : !0, this.clientName = ar.clientName, this.clientNip89 = ar.clientNip89, ar.enableOutboxModel && (this.outboxPool = new NDKPool(
      ar.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,
      ar.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS,
      this,
      this.debug.extend("outbox-pool")
    ), this.outboxTracker = new OutboxTracker(this)), this.signer = ar.signer, this.cacheAdapter = ar.cacheAdapter, this.mutedIds = ar.mutedIds || /* @__PURE__ */ new Map(), ar.devWriteRelayUrls && (this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(ar.devWriteRelayUrls, this));
  }
  toJSON() {
    return { relayCount: this.pool.relays.size }.toString();
  }
  get activeUser() {
    return this._activeUser;
  }
  /**
   * Sets the active user for this NDK instance, typically this will be
   * called when assigning a signer to the NDK instance.
   *
   * This function will automatically connect to the user's relays if
   * `autoConnectUserRelays` is set to true.
   *
   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.
   */
  set activeUser(ar) {
    const cr = this._activeUser !== ar;
    if (this._activeUser = ar, ar && cr) {
      const ur = async (vr) => {
        const yr = await vr.relayList();
        if (!yr) {
          this.debug("No relay list found for user", { npub: vr.npub });
          return;
        }
        this.debug("Connecting to user relays", {
          npub: vr.npub,
          relays: yr.relays
        });
        for (const kr of yr.relays) {
          let _r = this.pool.relays.get(kr);
          _r || (_r = new NDKRelay(kr), this.pool.addRelay(_r));
        }
      }, fr = async (vr) => {
        const yr = await this.fetchEvents([
          { kinds: [
            1e4
            /* MuteList */
          ], authors: [vr.pubkey] },
          {
            kinds: [
              3e4
              /* FollowSet */
            ],
            authors: [vr.pubkey],
            "#d": ["mute"],
            limit: 1
          }
        ]);
        if (!yr) {
          this.debug("No mute list found for user", { npub: vr.npub });
          return;
        }
        for (const kr of yr) {
          const _r = lists_default.from(kr);
          for (const xr of _r.items)
            this.mutedIds.set(xr[1], xr[0]);
        }
      }, dr = [];
      this.autoConnectUserRelays && dr.push(ur), this.autoFetchUserMutelist && dr.push(fr);
      const gr = async (vr) => {
        for (const yr of dr)
          await yr(vr);
      }, mr = this.outboxPool || this.pool;
      mr.connectedRelays.length > 0 ? gr(ar) : (this.debug("Waiting for connection to main relays"), mr.once("relay:connect", (vr) => {
        this.debug("New relay came online", vr), gr(ar);
      }));
    } else
      ar || (this.mutedIds = /* @__PURE__ */ new Map());
  }
  get signer() {
    return this._signer;
  }
  set signer(ar) {
    this._signer = ar, this.debug("setting signer", this.autoConnectUserRelays), ar == null || ar.user().then((cr) => {
      cr.ndk = this, this.activeUser = cr;
    });
  }
  /**
   * Connect to relays with optional timeout.
   * If the timeout is reached, the connection will be continued to be established in the background.
   */
  async connect(ar) {
    this._signer && this.autoConnectUserRelays && (this.debug("Attempting to connect to user relays specified by signer"), this._signer.relays && (await this._signer.relays()).forEach((fr) => this.pool.addRelay(fr)));
    const cr = [this.pool.connect(ar)];
    return this.outboxPool && cr.push(this.outboxPool.connect(ar)), this.debug("Connecting to relays", { timeoutMs: ar }), Promise.allSettled(cr).then(() => {
    });
  }
  /**
   * Get a NDKUser object
   *
   * @param opts
   * @returns
   */
  getUser(ar) {
    const cr = new NDKUser(ar);
    return cr.ndk = this, cr;
  }
  /**
   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)
   *
   * @param filters
   * @param opts
   * @param relaySet explicit relay set to use
   * @param autoStart automatically start the subscription
   * @returns NDKSubscription
   */
  subscribe(ar, cr, ur, fr = !0) {
    var gr;
    const dr = new NDKSubscription(this, ar, cr, ur);
    if (ur)
      for (const mr of ur.relays)
        this.pool.useTemporaryRelay(mr);
    if (this.outboxPool && dr.hasAuthorsFilter()) {
      const mr = dr.filters.filter((vr) => {
        var yr;
        return vr.authors && ((yr = vr.authors) == null ? void 0 : yr.length) > 0;
      }).map((vr) => vr.authors).flat();
      (gr = this.outboxTracker) == null || gr.trackUsers(mr);
    }
    return fr && dr.start(), dr;
  }
  /**
   * Publish an event to a relay
   * @param event event to publish
   * @param relaySet explicit relay set to use
   * @param timeoutMs timeout in milliseconds to wait for the event to be published
   * @returns The relays the event was published to
   *
   * @deprecated Use `event.publish()` instead
   */
  async publish(ar, cr, ur) {
    return this.debug("Deprecated: Use `event.publish()` instead"), ar.publish(cr, ur);
  }
  /**
   * Fetch a single event.
   *
   * @param idOrFilter event id in bech32 format or filter
   * @param opts subscription options
   * @param relaySet explicit relay set to use
   */
  async fetchEvent(ar, cr, ur) {
    let fr;
    if (!ur && typeof ar == "string" && !isNip33AValue(ar)) {
      const dr = relaysFromBech32(ar);
      dr.length > 0 && (ur = new NDKRelaySet(new Set(dr), this), ur = correctRelaySet(ur, this.pool));
    }
    if (typeof ar == "string" ? fr = filterFromId(ar) : fr = ar, !fr)
      throw new Error(`Invalid filter: ${JSON.stringify(ar)}`);
    return new Promise((dr) => {
      const gr = this.subscribe(
        fr,
        { ...cr || {}, closeOnEose: !0 },
        ur,
        !1
      );
      gr.on("event", (mr) => {
        mr.ndk = this, dr(mr);
      }), gr.on("eose", () => {
        dr(null);
      }), gr.start();
    });
  }
  /**
   * Fetch events
   */
  async fetchEvents(ar, cr, ur) {
    return new Promise((fr) => {
      const dr = /* @__PURE__ */ new Map(), gr = this.subscribe(
        ar,
        { ...cr || {}, closeOnEose: !0 },
        ur,
        !1
      ), mr = (vr) => {
        const yr = vr.deduplicationKey(), kr = dr.get(yr);
        kr && (vr = dedup(kr, vr)), vr.ndk = this, dr.set(yr, vr);
      };
      gr.on("event", mr), gr.on("event:dup", mr), gr.on("eose", () => {
        fr(new Set(dr.values()));
      }), gr.start();
    });
  }
  /**
   * Ensures that a signer is available to sign an event.
   */
  assertSigner() {
    if (!this.signer)
      throw this.emit("signerRequired"), new Error("Signer required");
  }
}, NDKSvelte = class extends NDK {
  constructor(lr) {
    super(lr);
  }
  createEventStore(lr) {
    const ar = writable([]);
    return {
      refCount: 0,
      filters: lr,
      subscription: void 0,
      set: ar.set,
      update: ar.update,
      subscribe: ar.subscribe,
      unsubscribe: () => {
      },
      onEose: (cr) => {
      },
      startSubscription: () => {
        throw new Error("not implemented");
      },
      ref: () => {
        throw new Error("not implemented");
      },
      unref: () => {
        throw new Error("not implemented");
      },
      empty: () => {
        throw new Error("not implemented");
      },
      changeFilters: (cr) => {
        throw new Error("not implemented");
      }
    };
  }
  eventIsRepost(lr) {
    return [NDKKind.Repost, NDKKind.GenericRepost].includes(lr.kind);
  }
  eventIsLabel(lr) {
    return [NDKKind.Label].includes(lr.kind);
  }
  storeSubscribe(lr, ar, cr) {
    var _r;
    let ur = /* @__PURE__ */ new Set(), fr = [];
    const dr = this.createEventStore(
      Array.isArray(lr) ? lr : [lr]
    ), gr = (_r = ar == null ? void 0 : ar.autoStart) != null ? _r : !0, mr = ar == null ? void 0 : ar.relaySet, vr = (xr) => {
      console.log("handle event label", xr.rawEvent()), yr(xr);
    }, yr = (xr) => {
      const Sr = NDKRepost.from(xr);
      Sr.ndk = this;
      const Er = (Cr) => {
        Cr.repostedByEvents ? Cr.repostedByEvents.push(xr) : Cr.repostedByEvents = [xr], dr.set(fr);
      };
      for (const Cr of Sr.repostedEventIds()) {
        const Tr = fr.find((Ar) => Ar.id === Cr);
        Tr ? Er(Tr) : Sr.repostedEvents(cr).then((Ar) => {
          for (const Ir of Ar)
            Ir instanceof NDKEvent && kr(Ir);
        });
      }
    }, kr = (xr) => {
      if (dr.filters && this.eventIsRepost(xr)) {
        yr(xr);
        return;
      }
      if (this.eventIsLabel(xr)) {
        vr(xr);
        return;
      }
      let Sr = xr;
      cr && (Sr = cr.from(xr), Sr.relay = xr.relay), Sr.ndk = this;
      const Er = xr.deduplicationKey();
      if (ur.has(Er)) {
        const Tr = fr.find((Ar) => Ar.deduplicationKey() === Er);
        if (Tr && Tr.created_at < xr.created_at) {
          const Ar = fr.findIndex((Ir) => Ir.deduplicationKey() === Er);
          fr.splice(Ar, 1);
        } else
          return;
      }
      ur.add(Er);
      const Cr = fr.findIndex((Tr) => Tr.created_at < xr.created_at);
      Cr === -1 ? fr.push(Sr) : fr.splice(Cr === -1 ? fr.length : Cr, 0, Sr), dr.set(fr);
    };
    return dr.ref = () => (dr.refCount++, dr.refCount === 1 && dr.startSubscription(), dr.refCount), dr.unref = () => (--dr.refCount !== 0 || (ar != null && ar.unrefUnsubscribeTimeout ? setTimeout(() => {
      dr.refCount === 0 && dr.unsubscribe();
    }, ar.unrefUnsubscribeTimeout) : dr.unsubscribe()), dr.refCount), dr.empty = () => {
      dr.set([]), fr = [], ur = /* @__PURE__ */ new Set(), dr.unsubscribe();
    }, dr.changeFilters = (xr) => {
      dr.filters = xr, dr.empty(), dr.refCount > 0 && dr.startSubscription();
    }, dr.startSubscription = () => {
      if (!dr.filters)
        throw new Error("no filters");
      const xr = dr.filters;
      ar != null && ar.repostsFilters && xr.push(...ar.repostsFilters), dr.subscription = this.subscribe(xr, ar, mr), dr.subscription.on("event", (Sr, Er) => {
        kr(Sr);
      }), dr.unsubscribe = () => {
        var Sr;
        (Sr = dr.subscription) == null || Sr.stop(), dr.subscription = void 0;
      }, dr.onEose = (Sr) => {
        var Er;
        (Er = dr.subscription) == null || Er.on("eose", Sr);
      };
    }, gr && dr.startSubscription(), dr;
  }
}, src_default = NDKSvelte;
const crypto$3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$3 = (lr) => lr instanceof Uint8Array, createView$2 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$2 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$2)
  throw new Error("Non little-endian hardware is not supported");
const hexes$2 = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$2(lr) {
  if (!u8a$3(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$2[lr[cr]];
  return ar;
}
function hexToBytes$3(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function utf8ToBytes$3(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$2(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$3(lr)), !u8a$3(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$3(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$3(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(lr) {
  const ar = (ur) => lr().update(toBytes$2(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$2(lr = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues == "function")
    return crypto$3.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$2(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool$1(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes$2(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$2(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$2(lr.outputLen), number$2(lr.blockLen);
}
function exists$2(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(lr, ar) {
  bytes$2(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert$1 = {
  number: number$2,
  bool: bool$1,
  bytes: bytes$2,
  hash: hash$2,
  exists: exists$2,
  output: output$2
};
function setBigUint64$2(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
let SHA2$2 = class extends Hash$2 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$2(this.buffer);
  }
  update(ar) {
    assert$1.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$2(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView$2(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64$2(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView$2(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$3 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$2 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$2 = new Uint32Array(64);
let SHA256$2 = class extends SHA2$2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$2[0] | 0, this.B = IV$2[1] | 0, this.C = IV$2[2] | 0, this.D = IV$2[3] | 0, this.E = IV$2[4] | 0, this.F = IV$2[5] | 0, this.G = IV$2[6] | 0, this.H = IV$2[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W$2[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W$2[_r - 15], Sr = SHA256_W$2[_r - 2], Er = rotr$2(xr, 7) ^ rotr$2(xr, 18) ^ xr >>> 3, Cr = rotr$2(Sr, 17) ^ rotr$2(Sr, 19) ^ Sr >>> 10;
      SHA256_W$2[_r] = Cr + SHA256_W$2[_r - 7] + Er + SHA256_W$2[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr$2(mr, 6) ^ rotr$2(mr, 11) ^ rotr$2(mr, 25), Sr = kr + xr + Chi$3(mr, vr, yr) + SHA256_K$2[_r] + SHA256_W$2[_r] | 0, Cr = (rotr$2(ur, 2) ^ rotr$2(ur, 13) ^ rotr$2(ur, 22)) + Maj$2(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$2 = wrapConstructor$2(() => new SHA256$2());
wrapConstructor$2(() => new SHA224$1());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$1(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain$1(...lr) {
  const ar = (fr, dr) => (gr) => fr(dr(gr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet$1(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber$1(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$2(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding$1(lr, ar = "=") {
  if (assertNumber$1(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize$1(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix$1(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((gr) => {
    if (assertNumber$1(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const yr = dr[vr], kr = ar * gr + yr;
      if (!Number.isSafeInteger(kr) || ar * gr / ar !== gr || kr - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = kr % cr, dr[vr] = Math.floor(kr / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + gr !== kr)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        dr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < lr.length - 1 && lr[gr] === 0; gr++)
    fr.push(0);
  return fr.reverse();
}
const gcd$1 = (lr, ar) => ar ? gcd$1(ar, lr % ar) : lr, radix2carry$1 = (lr, ar) => lr + (ar - gcd$1(lr, ar));
function convertRadix2$1(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry$1(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry$1(ar, cr)}`);
  let fr = 0, dr = 0;
  const gr = 2 ** cr - 1, mr = [];
  for (const vr of lr) {
    if (assertNumber$1(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      mr.push((fr >> dr - cr & gr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & gr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && mr.push(fr >>> 0), mr;
}
function radix$1(lr) {
  return assertNumber$1(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$1(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$1(ar, lr, 2 ** 8));
    }
  };
}
function radix2$1(lr, ar = !1) {
  if (assertNumber$1(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$1(8, lr) > 32 || radix2carry$1(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$1(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$1(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper$1(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16$1 = chain$1(radix2$1(4), alphabet$1("0123456789ABCDEF"), join$2("")), base32$1 = chain$1(radix2$1(5), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$2(""), normalize$1((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$1(6), join$2("")), base64url$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$1(6), join$2("")), genBase58$1 = (lr) => chain$1(radix$1(58), alphabet$1(lr), join$2("")), base58$1 = genBase58$1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$1("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$1("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$1 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$1 = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58$1.encode(ur).padStart(XMR_BLOCK_LEN$1[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN$1.indexOf(ur.length), dr = base58$1.decode(ur);
      for (let gr = 0; gr < dr.length - fr; gr++)
        if (dr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$1 = chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$2("")), POLYMOD_GENERATORS$1 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$1(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$1.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS$1[ur]);
  return cr;
}
function bechChecksum$1(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const gr = lr.charCodeAt(dr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod$1(fr) ^ gr >> 5;
  }
  fr = bech32Polymod$1(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod$1(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod$1(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod$1(fr);
  return fr ^= cr, BECH_ALPHABET$1.encode(convertRadix2$1([fr % 2 ** 30], 30, 5, !1));
}
function genBech32$1(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2$1(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper$1(ur);
  function gr(kr, _r, xr = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof kr}`);
    if (!Array.isArray(_r) || _r.length && typeof _r[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof _r}`);
    const Sr = kr.length + 7 + _r.length;
    if (xr !== !1 && Sr > xr)
      throw new TypeError(`Length ${Sr} exceeds limit ${xr}`);
    return kr = kr.toLowerCase(), `${kr}1${BECH_ALPHABET$1.encode(_r)}${bechChecksum$1(kr, _r, ar)}`;
  }
  function mr(kr, _r = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof kr}`);
    if (kr.length < 8 || _r !== !1 && kr.length > _r)
      throw new TypeError(`Wrong string length: ${kr.length} (${kr}). Expected (8..${_r})`);
    const xr = kr.toLowerCase();
    if (kr !== xr && kr !== kr.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    kr = xr;
    const Sr = kr.lastIndexOf("1");
    if (Sr === 0 || Sr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = kr.slice(0, Sr), Cr = kr.slice(Sr + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET$1.decode(Cr).slice(0, -6), Ar = bechChecksum$1(Er, Tr, ar);
    if (!Cr.endsWith(Ar))
      throw new Error(`Invalid checksum in ${kr}: expected "${Ar}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper$1(mr);
  function yr(kr) {
    const { prefix: _r, words: xr } = mr(kr, !1);
    return { prefix: _r, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32$2 = genBech32$1("bech32");
genBech32$1("bech32m");
const utf8$1 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex$1 = chain$1(radix2$1(4), alphabet$1("0123456789abcdef"), join$2(""), normalize$1((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS$1 = {
  utf8: utf8$1,
  hex: hex$1,
  base16: base16$1,
  base32: base32$1,
  base64: base64$1,
  base64url: base64url$1,
  base58: base58$1,
  base58xmr: base58xmr$1
};
`${Object.keys(CODERS$1).join(", ")}`;
let HMAC$2 = class extends Hash$2 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert$1.hash(ar);
    const ur = toBytes$2(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert$1.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$2 = (lr, ar, cr) => new HMAC$2(lr, ar).update(cr).digest();
hmac$2.create = (lr, ar) => new HMAC$2(lr, ar);
function extract$1(lr, ar, cr) {
  return assert$1.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac$2(lr, toBytes$2(cr), toBytes$2(ar));
}
const HKDF_COUNTER$1 = new Uint8Array([0]), EMPTY_BUFFER$1 = new Uint8Array();
function expand$1(lr, ar, cr, ur = 32) {
  if (assert$1.hash(lr), assert$1.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER$1);
  const dr = new Uint8Array(fr * lr.outputLen), gr = hmac$2.create(lr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < fr; yr++)
    HKDF_COUNTER$1[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER$1 : vr).update(cr).update(HKDF_COUNTER$1).digestInto(vr), dr.set(vr, lr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER$1.fill(0), dr.slice(0, ur);
}
const hkdf = (lr, ar, cr, ur, fr) => expand$1(lr, extract$1(lr, ar, cr), ur, fr);
var __defProp$1 = Object.defineProperty, __export$1 = (lr, ar) => {
  for (var cr in ar)
    __defProp$1(lr, cr, { get: ar[cr], enumerable: !0 });
};
function getPublicKey(lr) {
  return bytesToHex$2(schnorr$1.getPublicKey(lr));
}
var utils_exports$1 = {};
__export$1(utils_exports$1, {
  MessageNode: () => MessageNode,
  MessageQueue: () => MessageQueue,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$1,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$1,
  normalizeURL: () => normalizeURL$1,
  utf8Decoder: () => utf8Decoder$1,
  utf8Encoder: () => utf8Encoder$1
});
var utf8Decoder$1 = new TextDecoder("utf-8"), utf8Encoder$1 = new TextEncoder();
function normalizeURL$1(lr) {
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$1(lr, ar) {
  var gr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at < lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at >= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at > ar.created_at)
        cr = fr;
      else if (lr[fr].created_at < ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((gr = lr[dr]) == null ? void 0 : gr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
function insertEventIntoAscendingList$1(lr, ar) {
  var gr;
  let cr = 0, ur = lr.length - 1, fr, dr = cr;
  if (ur < 0)
    dr = 0;
  else if (ar.created_at > lr[ur].created_at)
    dr = ur + 1;
  else if (ar.created_at <= lr[cr].created_at)
    dr = cr;
  else
    for (; ; ) {
      if (ur <= cr + 1) {
        dr = ur;
        break;
      }
      if (fr = Math.floor(cr + (ur - cr) / 2), lr[fr].created_at < ar.created_at)
        cr = fr;
      else if (lr[fr].created_at > ar.created_at)
        ur = fr;
      else {
        dr = fr;
        break;
      }
    }
  return ((gr = lr[dr]) == null ? void 0 : gr.id) !== ar.id ? [...lr.slice(0, dr), ar, ...lr.slice(dr)] : lr;
}
var MessageNode = class {
  constructor(lr) {
    ji(this, "_value");
    ji(this, "_next");
    this._value = lr, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(lr) {
    this._value = lr;
  }
  get next() {
    return this._next;
  }
  set next(lr) {
    this._next = lr;
  }
}, MessageQueue = class {
  constructor() {
    ji(this, "_first");
    ji(this, "_last");
    ji(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(lr) {
    this._first = lr;
  }
  get last() {
    return this._last;
  }
  set last(lr) {
    this._last = lr;
  }
  get size() {
    return this._size;
  }
  set size(lr) {
    this._size = lr;
  }
  enqueue(lr) {
    const ar = new MessageNode(lr);
    return this._size === 0 || !this._last ? (this._first = ar, this._last = ar) : (this._last.next = ar, this._last = ar), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let lr = this._first;
    return this._first = lr.next, lr.next = null, this._size--, lr.value;
  }
}, verifiedSymbol$1 = Symbol("verified");
function getBlankEvent(lr = 255) {
  return {
    kind: lr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent(lr, ar) {
  const cr = lr;
  return cr.pubkey = getPublicKey(ar), cr.id = getEventHash$1(cr), cr.sig = getSignature(cr, ar), cr[verifiedSymbol$1] = !0, cr;
}
function serializeEvent$1(lr) {
  if (!validateEvent$1(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash$1(lr) {
  let ar = sha256$2(utf8Encoder$1.encode(serializeEvent$1(lr)));
  return bytesToHex$2(ar);
}
var isRecord$1 = (lr) => lr instanceof Object;
function validateEvent$1(lr) {
  if (!isRecord$1(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature(lr) {
  if (typeof lr[verifiedSymbol$1] == "boolean")
    return lr[verifiedSymbol$1];
  const ar = getEventHash$1(lr);
  if (ar !== lr.id)
    return lr[verifiedSymbol$1] = !1;
  try {
    return lr[verifiedSymbol$1] = schnorr$1.verify(lr.sig, ar, lr.pubkey);
  } catch (cr) {
    return lr[verifiedSymbol$1] = !1;
  }
}
function getSignature(lr, ar) {
  return bytesToHex$2(schnorr$1.sign(getEventHash$1(lr), ar));
}
function matchFilter(lr, ar) {
  if (lr.ids && lr.ids.indexOf(ar.id) === -1 && !lr.ids.some((cr) => ar.id.startsWith(cr)) || lr.kinds && lr.kinds.indexOf(ar.kind) === -1 || lr.authors && lr.authors.indexOf(ar.pubkey) === -1 && !lr.authors.some((cr) => ar.pubkey.startsWith(cr)))
    return !1;
  for (let cr in lr)
    if (cr[0] === "#") {
      let ur = cr.slice(1), fr = lr[`#${ur}`];
      if (fr && !ar.tags.find(([dr, gr]) => dr === cr.slice(1) && fr.indexOf(gr) !== -1))
        return !1;
    }
  return !(lr.since && ar.created_at < lr.since || lr.until && ar.created_at > lr.until);
}
var fakejson_exports$1 = {};
__export$1(fakejson_exports$1, {
  getHex64: () => getHex64$1,
  getInt: () => getInt$1,
  getSubscriptionId: () => getSubscriptionId$1,
  matchEventId: () => matchEventId$1,
  matchEventKind: () => matchEventKind$1,
  matchEventPubkey: () => matchEventPubkey$1
});
function getHex64$1(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt$1(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId$1(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId$1(lr, ar) {
  return ar === getHex64$1(lr, "id");
}
function matchEventPubkey$1(lr, ar) {
  return ar === getHex64$1(lr, "pubkey");
}
function matchEventKind$1(lr, ar) {
  return ar === getInt$1(lr, "kind");
}
var nip19_exports$1 = {};
__export$1(nip19_exports$1, {
  BECH32_REGEX: () => BECH32_REGEX$1,
  decode: () => decode$2,
  naddrEncode: () => naddrEncode$1,
  neventEncode: () => neventEncode$1,
  noteEncode: () => noteEncode$1,
  nprofileEncode: () => nprofileEncode$1,
  npubEncode: () => npubEncode$1,
  nrelayEncode: () => nrelayEncode$1,
  nsecEncode: () => nsecEncode$1
});
var Bech32MaxSize$1 = 5e3, BECH32_REGEX$1 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$1(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$2(lr) {
  var fr, dr, gr, mr, vr, yr, kr, _r;
  let { prefix: ar, words: cr } = bech32$2.decode(lr, Bech32MaxSize$1), ur = new Uint8Array(bech32$2.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV$1(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$2(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$1.decode(Sr)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV$1(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$2(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$1.decode(Sr)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex$2(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex$2(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV$1(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((kr = xr[3]) != null && kr[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$1.decode(xr[0][0]),
          pubkey: bytesToHex$2(xr[2][0]),
          kind: parseInt(bytesToHex$2(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder$1.decode(Sr)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV$1(ur);
      if (!((_r = xr[0]) != null && _r[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$1.decode(xr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$2(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$1(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1];
    if (!fr)
      throw new Error(`malformed TLV ${ur}`);
    let dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode$1(lr) {
  return encodeBytes$1("nsec", lr);
}
function npubEncode$1(lr) {
  return encodeBytes$1("npub", lr);
}
function noteEncode$1(lr) {
  return encodeBytes$1("note", lr);
}
function encodeBech32$1(lr, ar) {
  let cr = bech32$2.toWords(ar);
  return bech32$2.encode(lr, cr, Bech32MaxSize$1);
}
function encodeBytes$1(lr, ar) {
  let cr = hexToBytes$3(ar);
  return encodeBech32$1(lr, cr);
}
function nprofileEncode$1(lr) {
  let ar = encodeTLV$1({
    0: [hexToBytes$3(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder$1.encode(cr))
  });
  return encodeBech32$1("nprofile", ar);
}
function neventEncode$1(lr) {
  let ar;
  lr.kind != null && (ar = integerToUint8Array$1(lr.kind));
  let cr = encodeTLV$1({
    0: [hexToBytes$3(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: lr.author ? [hexToBytes$3(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$1("nevent", cr);
}
function naddrEncode$1(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV$1({
    0: [utf8Encoder$1.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: [hexToBytes$3(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$1("naddr", cr);
}
function nrelayEncode$1(lr) {
  let ar = encodeTLV$1({
    0: [utf8Encoder$1.encode(lr)]
  });
  return encodeBech32$1("nrelay", ar);
}
function encodeTLV$1(lr) {
  let ar = [];
  return Object.entries(lr).forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes$3(...ar);
}
var nip04_exports$1 = {};
__export$1(nip04_exports$1, {
  decrypt: () => decrypt$1,
  encrypt: () => encrypt$1
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$1(lr, ar, cr) {
  const ur = secp256k1$1.getSharedSecret(lr, "02" + ar), fr = getNormalizedX$1(ur);
  let dr = Uint8Array.from(randomBytes$2(16)), gr = utf8Encoder$1.encode(cr), mr = await crypto.subtle.importKey("raw", fr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: dr }, mr, gr), yr = base64$1.encode(new Uint8Array(vr)), kr = base64$1.encode(new Uint8Array(dr.buffer));
  return `${yr}?iv=${kr}`;
}
async function decrypt$1(lr, ar, cr) {
  let [ur, fr] = cr.split("?iv="), dr = secp256k1$1.getSharedSecret(lr, "02" + ar), gr = getNormalizedX$1(dr), mr = await crypto.subtle.importKey("raw", gr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$1.decode(ur), yr = base64$1.decode(fr), kr = await crypto.subtle.decrypt({ name: "AES-CBC", iv: yr }, mr, vr);
  return utf8Decoder$1.decode(kr);
}
function getNormalizedX$1(lr) {
  return lr.slice(1, 33);
}
var nip05_exports$1 = {};
__export$1(nip05_exports$1, {
  NIP05_REGEX: () => NIP05_REGEX$1,
  queryProfile: () => queryProfile$1,
  searchDomain: () => searchDomain$1,
  useFetchImplementation: () => useFetchImplementation$1
});
var NIP05_REGEX$1 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$1;
try {
  _fetch$1 = fetch;
} catch (lr) {
}
function useFetchImplementation$1(lr) {
  _fetch$1 = lr;
}
async function searchDomain$1(lr, ar = "") {
  try {
    return (await (await _fetch$1(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile$1(lr) {
  const ar = lr.match(NIP05_REGEX$1);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch$1(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result$1(await dr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result$1(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip06_exports = {};
__export$1(nip06_exports, {
  generateSeedWords: () => generateSeedWords,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords,
  validateWords: () => validateWords
});
function privateKeyFromSeedWords(lr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(lr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$2(ur);
}
function generateSeedWords() {
  return generateMnemonic(wordlist);
}
function validateWords(lr) {
  return validateMnemonic(lr, wordlist);
}
var nip10_exports$1 = {};
__export$1(nip10_exports$1, {
  parse: () => parse$1
});
function parse$1(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, gr, mr, vr] = fr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, kr = ur === 0, _r = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (kr) {
      ar.root = yr;
      continue;
    }
    if (_r) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip13_exports$1 = {};
__export$1(nip13_exports$1, {
  getPow: () => getPow$1,
  minePow: () => minePow$1
});
function getPow$1(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$1(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash$1(ur), getPow$1(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$1 = {};
__export$1(nip18_exports$1, {
  finishRepostEvent: () => finishRepostEvent$1,
  getRepostedEvent: () => getRepostedEvent$1,
  getRepostedEventPointer: () => getRepostedEventPointer$1
});
function finishRepostEvent$1(lr, ar, cr, ur) {
  var fr;
  return finishEvent(
    {
      kind: 6,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$1(lr) {
  if (lr.kind !== 6)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent$1(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer$1(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifySignature(ur)))
    return ur;
}
var nip21_exports$1 = {};
__export$1(nip21_exports$1, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$1,
  parse: () => parse2$1,
  test: () => test$1
});
var NOSTR_URI_REGEX$1 = new RegExp(`nostr:(${BECH32_REGEX$1.source})`);
function test$1(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX$1.source}$`).test(lr);
}
function parse2$1(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX$1.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$2(ar[1])
  };
}
var nip25_exports$1 = {};
__export$1(nip25_exports$1, {
  finishReactionEvent: () => finishReactionEvent$1,
  getReactedEventPointer: () => getReactedEventPointer$1
});
function finishReactionEvent$1(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finishEvent(
    {
      ...lr,
      kind: 7,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer$1(lr) {
  if (lr.kind !== 7)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip26_exports = {};
__export$1(nip26_exports, {
  createDelegation: () => createDelegation,
  getDelegator: () => getDelegator
});
function createDelegation(lr, ar) {
  let cr = [];
  (ar.kind || -1) >= 0 && cr.push(`kind=${ar.kind}`), ar.until && cr.push(`created_at<${ar.until}`), ar.since && cr.push(`created_at>${ar.since}`);
  let ur = cr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let fr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), dr = bytesToHex$2(schnorr$1.sign(fr, lr));
  return {
    from: getPublicKey(lr),
    to: ar.pubkey,
    cond: ur,
    sig: dr
  };
}
function getDelegator(lr) {
  let ar = lr.tags.find((mr) => mr[0] === "delegation" && mr.length >= 4);
  if (!ar)
    return null;
  let cr = ar[1], ur = ar[2], fr = ar[3], dr = ur.split("&");
  for (let mr = 0; mr < dr.length; mr++) {
    let [vr, yr, kr] = dr[mr].split(/\b/);
    if (!(vr === "kind" && yr === "=" && lr.kind === parseInt(kr))) {
      if (vr === "created_at" && yr === "<" && lr.created_at < parseInt(kr))
        continue;
      if (vr === "created_at" && yr === ">" && lr.created_at > parseInt(kr))
        continue;
      return null;
    }
  }
  let gr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${lr.pubkey}:${ur}`));
  return schnorr$1.verify(fr, gr, cr) ? cr : null;
}
var nip27_exports$1 = {};
__export$1(nip27_exports$1, {
  matchAll: () => matchAll$1,
  regex: () => regex$1,
  replaceAll: () => replaceAll$1
});
var regex$1 = () => new RegExp(`\\b${NOSTR_URI_REGEX$1.source}\\b`, "g");
function* matchAll$1(lr) {
  const ar = lr.matchAll(regex$1());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$2(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$1(lr, ar) {
  return lr.replaceAll(regex$1(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$2(ur)
  }));
}
var nip28_exports$1 = {};
__export$1(nip28_exports$1, {
  channelCreateEvent: () => channelCreateEvent$1,
  channelHideMessageEvent: () => channelHideMessageEvent$1,
  channelMessageEvent: () => channelMessageEvent$1,
  channelMetadataEvent: () => channelMetadataEvent$1,
  channelMuteUserEvent: () => channelMuteUserEvent$1
});
var channelCreateEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 40,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 41,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent$1 = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finishEvent(
    {
      kind: 42,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 43,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent$1 = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finishEvent(
    {
      kind: 44,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip39_exports$1 = {};
__export$1(nip39_exports$1, {
  useFetchImplementation: () => useFetchImplementation2$1,
  validateGithub: () => validateGithub$1
});
var _fetch2$1;
try {
  _fetch2$1 = fetch;
} catch (lr) {
}
function useFetchImplementation2$1(lr) {
  _fetch2$1 = lr;
}
async function validateGithub$1(lr, ar, cr) {
  try {
    return await (await _fetch2$1(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$1 = {};
__export$1(nip42_exports$1, {
  authenticate: () => authenticate
});
var authenticate = async ({
  challenge: lr,
  relay: ar,
  sign: cr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", lr]
    ],
    content: ""
  };
  return ar.auth(await cr(ur));
}, nip44_exports$1 = {};
__export$1(nip44_exports$1, {
  decrypt: () => decrypt2$1,
  encrypt: () => encrypt2$1,
  utils: () => utils$1
});
var utils$1 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(lr, ar) {
      return secp256k1$1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(lr, ar) {
      const cr = hkdf(sha256$2, lr, ar, "nip44-v2", 76);
      return {
        encryption: cr.subarray(0, 32),
        nonce: cr.subarray(32, 44),
        auth: cr.subarray(44, 76)
      };
    },
    calcPadding(lr) {
      if (!Number.isSafeInteger(lr) || lr < 0)
        throw new Error("expected positive integer");
      if (lr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
      return cr * (Math.floor((lr - 1) / cr) + 1);
    },
    pad(lr) {
      const ar = utf8Encoder$1.encode(lr), cr = ar.length;
      if (cr < 1 || cr >= utils$1.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$1.v2.calcPadding(cr), fr = new Uint8Array(ur - cr), dr = new Uint8Array(2);
      return new DataView(dr.buffer).setUint16(0, cr), concatBytes$3(dr, ar, fr);
    },
    unpad(lr) {
      const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
      if (ar === 0 || cr.length !== ar || lr.length !== 2 + utils$1.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$1.decode(cr);
    }
  }
};
function encrypt2$1(lr, ar, cr = {}) {
  var yr, kr;
  const ur = (yr = cr.version) != null ? yr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const fr = (kr = cr.salt) != null ? kr : randomBytes$2(32);
  ensureBytes$1(fr, 32);
  const dr = utils$1.v2.getMessageKeys(lr, fr), gr = utils$1.v2.pad(ar), mr = chacha20(dr.encryption, dr.nonce, gr), vr = hmac$2(sha256$2, dr.auth, mr);
  return base64$1.encode(concatBytes$3(new Uint8Array([ur]), fr, mr, vr));
}
function decrypt2$1(lr, ar) {
  const cr = utils$1.v2;
  ensureBytes$1(lr, 32);
  const ur = ar.length;
  if (ur < cr.minCiphertextSize || ur >= cr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let fr;
  try {
    fr = base64$1.decode(ar);
  } catch (xr) {
    throw new Error("invalid base64: " + xr.message);
  }
  const dr = fr.subarray(0, 1)[0];
  if (dr !== 2)
    throw new Error("unknown encryption version " + dr);
  const gr = fr.subarray(1, 33), mr = fr.subarray(33, -32), vr = fr.subarray(-32), yr = cr.getMessageKeys(lr, gr), kr = hmac$2(sha256$2, yr.auth, mr);
  if (!equalBytes$1(kr, vr))
    throw new Error("invalid MAC");
  const _r = chacha20(yr.encryption, yr.nonce, mr);
  return cr.unpad(_r);
}
var nip47_exports$1 = {};
__export$1(nip47_exports$1, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$1,
  parseConnectionString: () => parseConnectionString$1
});
function parseConnectionString$1(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent$1({
  pubkey: lr,
  secret: ar,
  invoice: cr
}) {
  const fr = await encrypt$1(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finishEvent(dr, ar);
}
var nip57_exports$1 = {};
__export$1(nip57_exports$1, {
  getZapEndpoint: () => getZapEndpoint$1,
  makeZapReceipt: () => makeZapReceipt$1,
  makeZapRequest: () => makeZapRequest$1,
  useFetchImplementation: () => useFetchImplementation3$1,
  validateZapRequest: () => validateZapRequest$1
});
var _fetch3$1;
try {
  _fetch3$1 = fetch;
} catch (lr) {
}
function useFetchImplementation3$1(lr) {
  _fetch3$1 = lr;
}
async function getZapEndpoint$1(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: gr } = bech32$2.decode(cr, 1e3), mr = bech32$2.fromWords(gr);
      ar = utf8Decoder$1.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = `https://${mr}/.well-known/lnurlp/${gr}`;
    } else
      return null;
    let dr = await (await _fetch3$1(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$1({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest$1(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$1(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, gr]) => dr === "p" && gr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, gr]) => dr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, gr]) => dr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$1({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let dr = JSON.parse(lr).tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["bolt11", cr], ["description", lr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports$1 = {};
__export$1(nip98_exports$1, {
  getToken: () => getToken$1,
  unpackEventFromToken: () => unpackEventFromToken$1,
  validateEvent: () => validateEvent2$1,
  validateToken: () => validateToken$1
});
var _authorizationScheme$1 = "Nostr ";
async function getToken$1(lr, ar, cr, ur = !1) {
  if (!lr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const fr = getBlankEvent(
    27235
    /* HttpAuth */
  );
  fr.tags = [
    ["u", lr],
    ["method", ar]
  ], fr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const dr = await cr(fr);
  return (ur ? _authorizationScheme$1 : "") + base64$1.encode(utf8Encoder$1.encode(JSON.stringify(dr)));
}
async function validateToken$1(lr, ar, cr) {
  const ur = await unpackEventFromToken$1(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2$1(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken$1(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme$1, "");
  const ar = utf8Decoder$1.decode(base64$1.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$1(lr, ar, cr) {
  if (!lr)
    throw new Error("Invalid nostr event");
  if (!verifySignature(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (lr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!lr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = lr.tags.find((dr) => dr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const fr = lr.tags.find((dr) => dr[0] === "method");
  if ((fr == null ? void 0 : fr.length) !== 1 && (fr == null ? void 0 : fr[1].toLowerCase()) !== cr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
const e = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : global, t = Object.keys, n = Array.isArray;
function r(lr, ar) {
  return typeof ar != "object" || t(ar).forEach(function(cr) {
    lr[cr] = ar[cr];
  }), lr;
}
typeof Promise == "undefined" || e.Promise || (e.Promise = Promise);
const s = Object.getPrototypeOf, i$1 = {}.hasOwnProperty;
function o(lr, ar) {
  return i$1.call(lr, ar);
}
function a(lr, ar) {
  typeof ar == "function" && (ar = ar(s(lr))), (typeof Reflect == "undefined" ? t : Reflect.ownKeys)(ar).forEach((cr) => {
    l(lr, cr, ar[cr]);
  });
}
const u$1 = Object.defineProperty;
function l(lr, ar, cr, ur) {
  u$1(lr, ar, r(cr && o(cr, "get") && typeof cr.get == "function" ? { get: cr.get, set: cr.set, configurable: !0 } : { value: cr, configurable: !0, writable: !0 }, ur));
}
function c(lr) {
  return { from: function(ar) {
    return lr.prototype = Object.create(ar.prototype), l(lr.prototype, "constructor", lr), { extend: a.bind(null, lr.prototype) };
  } };
}
const h$1 = Object.getOwnPropertyDescriptor;
function d(lr, ar) {
  let cr;
  return h$1(lr, ar) || (cr = s(lr)) && d(cr, ar);
}
const f = [].slice;
function p(lr, ar, cr) {
  return f.call(lr, ar, cr);
}
function y(lr, ar) {
  return ar(lr);
}
function m(lr) {
  if (!lr)
    throw new Error("Assertion Failed");
}
function v(lr) {
  e.setImmediate ? setImmediate(lr) : setTimeout(lr, 0);
}
function g(lr, ar) {
  return lr.reduce((cr, ur, fr) => {
    var dr = ar(ur, fr);
    return dr && (cr[dr[0]] = dr[1]), cr;
  }, {});
}
function b(lr, ar) {
  if (o(lr, ar))
    return lr[ar];
  if (!ar)
    return lr;
  if (typeof ar != "string") {
    for (var cr = [], ur = 0, fr = ar.length; ur < fr; ++ur) {
      var dr = b(lr, ar[ur]);
      cr.push(dr);
    }
    return cr;
  }
  var gr = ar.indexOf(".");
  if (gr !== -1) {
    var mr = lr[ar.substr(0, gr)];
    return mr === void 0 ? void 0 : b(mr, ar.substr(gr + 1));
  }
}
function _(lr, ar, cr) {
  if (lr && ar !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(lr)))
    if (typeof ar != "string" && "length" in ar) {
      m(typeof cr != "string" && "length" in cr);
      for (var ur = 0, fr = ar.length; ur < fr; ++ur)
        _(lr, ar[ur], cr[ur]);
    } else {
      var dr = ar.indexOf(".");
      if (dr !== -1) {
        var gr = ar.substr(0, dr), mr = ar.substr(dr + 1);
        if (mr === "")
          cr === void 0 ? n(lr) && !isNaN(parseInt(gr)) ? lr.splice(gr, 1) : delete lr[gr] : lr[gr] = cr;
        else {
          var vr = lr[gr];
          vr && o(lr, gr) || (vr = lr[gr] = {}), _(vr, mr, cr);
        }
      } else
        cr === void 0 ? n(lr) && !isNaN(parseInt(ar)) ? lr.splice(ar, 1) : delete lr[ar] : lr[ar] = cr;
    }
}
function w(lr) {
  var ar = {};
  for (var cr in lr)
    o(lr, cr) && (ar[cr] = lr[cr]);
  return ar;
}
const x = [].concat;
function k(lr) {
  return x.apply([], lr);
}
const E = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k([8, 16, 32, 64].map((lr) => ["Int", "Uint", "Float"].map((ar) => ar + lr + "Array")))).filter((lr) => e[lr]), P = E.map((lr) => e[lr]);
g(E, (lr) => [lr, !0]);
let K = null;
function O(lr) {
  K = typeof WeakMap != "undefined" && /* @__PURE__ */ new WeakMap();
  const ar = S(lr);
  return K = null, ar;
}
function S(lr) {
  if (!lr || typeof lr != "object")
    return lr;
  let ar = K && K.get(lr);
  if (ar)
    return ar;
  if (n(lr)) {
    ar = [], K && K.set(lr, ar);
    for (var cr = 0, ur = lr.length; cr < ur; ++cr)
      ar.push(S(lr[cr]));
  } else if (P.indexOf(lr.constructor) >= 0)
    ar = lr;
  else {
    const dr = s(lr);
    for (var fr in ar = dr === Object.prototype ? {} : Object.create(dr), K && K.set(lr, ar), lr)
      o(lr, fr) && (ar[fr] = S(lr[fr]));
  }
  return ar;
}
const { toString: A } = {};
function C(lr) {
  return A.call(lr).slice(8, -1);
}
const j = typeof Symbol != "undefined" ? Symbol.iterator : "@@iterator", D = typeof j == "symbol" ? function(lr) {
  var ar;
  return lr != null && (ar = lr[j]) && ar.apply(lr);
} : function() {
  return null;
}, I = {};
function B(lr) {
  var ar, cr, ur, fr;
  if (arguments.length === 1) {
    if (n(lr))
      return lr.slice();
    if (this === I && typeof lr == "string")
      return [lr];
    if (fr = D(lr)) {
      for (cr = []; !(ur = fr.next()).done; )
        cr.push(ur.value);
      return cr;
    }
    if (lr == null)
      return [lr];
    if (typeof (ar = lr.length) == "number") {
      for (cr = new Array(ar); ar--; )
        cr[ar] = lr[ar];
      return cr;
    }
    return [lr];
  }
  for (ar = arguments.length, cr = new Array(ar); ar--; )
    cr[ar] = arguments[ar];
  return cr;
}
const T = typeof Symbol != "undefined" ? (lr) => lr[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var R = typeof location != "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function F(lr, ar) {
  R = lr, M = ar;
}
var M = () => !0;
const N = !new Error("").stack;
function q() {
  if (N)
    try {
      throw q.arguments, new Error();
    } catch (lr) {
      return lr;
    }
  return new Error();
}
function $(lr, ar) {
  var cr = lr.stack;
  return cr ? (ar = ar || 0, cr.indexOf(lr.name) === 0 && (ar += (lr.name + lr.message).split(`
`).length), cr.split(`
`).slice(ar).filter(M).map((ur) => `
` + ur).join("")) : "";
}
var U = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], L = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(U), V = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function W(lr, ar) {
  this._e = q(), this.name = lr, this.message = ar;
}
function Y(lr, ar) {
  return lr + ". Errors: " + Object.keys(ar).map((cr) => ar[cr].toString()).filter((cr, ur, fr) => fr.indexOf(cr) === ur).join(`
`);
}
function z(lr, ar, cr, ur) {
  this._e = q(), this.failures = ar, this.failedKeys = ur, this.successCount = cr, this.message = Y(lr, ar);
}
function G(lr, ar) {
  this._e = q(), this.name = "BulkError", this.failures = Object.keys(ar).map((cr) => ar[cr]), this.failuresByPos = ar, this.message = Y(lr, ar);
}
c(W).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), c(z).from(W), c(G).from(W);
var H = L.reduce((lr, ar) => (lr[ar] = ar + "Error", lr), {});
const Q = W;
var X = L.reduce((lr, ar) => {
  var cr = ar + "Error";
  function ur(fr, dr) {
    this._e = q(), this.name = cr, fr ? typeof fr == "string" ? (this.message = `${fr}${dr ? `
 ` + dr : ""}`, this.inner = dr || null) : typeof fr == "object" && (this.message = `${fr.name} ${fr.message}`, this.inner = fr) : (this.message = V[ar] || cr, this.inner = null);
  }
  return c(ur).from(Q), lr[ar] = ur, lr;
}, {});
X.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;
var J = U.reduce((lr, ar) => (lr[ar + "Error"] = X[ar], lr), {}), Z = L.reduce((lr, ar) => (["Syntax", "Type", "Range"].indexOf(ar) === -1 && (lr[ar + "Error"] = X[ar]), lr), {});
function ee$1() {
}
function te(lr) {
  return lr;
}
function ne$1(lr, ar) {
  return lr == null || lr === te ? ar : function(cr) {
    return ar(lr(cr));
  };
}
function re(lr, ar) {
  return function() {
    lr.apply(this, arguments), ar.apply(this, arguments);
  };
}
function se(lr, ar) {
  return lr === ee$1 ? ar : function() {
    var cr = lr.apply(this, arguments);
    cr !== void 0 && (arguments[0] = cr);
    var ur = this.onsuccess, fr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var dr = ar.apply(this, arguments);
    return ur && (this.onsuccess = this.onsuccess ? re(ur, this.onsuccess) : ur), fr && (this.onerror = this.onerror ? re(fr, this.onerror) : fr), dr !== void 0 ? dr : cr;
  };
}
function ie(lr, ar) {
  return lr === ee$1 ? ar : function() {
    lr.apply(this, arguments);
    var cr = this.onsuccess, ur = this.onerror;
    this.onsuccess = this.onerror = null, ar.apply(this, arguments), cr && (this.onsuccess = this.onsuccess ? re(cr, this.onsuccess) : cr), ur && (this.onerror = this.onerror ? re(ur, this.onerror) : ur);
  };
}
function oe(lr, ar) {
  return lr === ee$1 ? ar : function(cr) {
    var ur = lr.apply(this, arguments);
    r(cr, ur);
    var fr = this.onsuccess, dr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var gr = ar.apply(this, arguments);
    return fr && (this.onsuccess = this.onsuccess ? re(fr, this.onsuccess) : fr), dr && (this.onerror = this.onerror ? re(dr, this.onerror) : dr), ur === void 0 ? gr === void 0 ? void 0 : gr : r(ur, gr);
  };
}
function ae(lr, ar) {
  return lr === ee$1 ? ar : function() {
    return ar.apply(this, arguments) !== !1 && lr.apply(this, arguments);
  };
}
function ue(lr, ar) {
  return lr === ee$1 ? ar : function() {
    var cr = lr.apply(this, arguments);
    if (cr && typeof cr.then == "function") {
      for (var ur = this, fr = arguments.length, dr = new Array(fr); fr--; )
        dr[fr] = arguments[fr];
      return cr.then(function() {
        return ar.apply(ur, dr);
      });
    }
    return ar.apply(this, arguments);
  };
}
Z.ModifyError = z, Z.DexieError = W, Z.BulkError = G;
var le$1 = {};
const ce = 100, [he, de, fe$1] = typeof Promise == "undefined" ? [] : (() => {
  let lr = Promise.resolve();
  if (typeof crypto == "undefined" || !crypto.subtle)
    return [lr, s(lr), lr];
  const ar = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [ar, s(ar), lr];
})(), pe = de && de.then, ye = he && he.constructor, me = !!fe$1;
var ve = !1, ge$2 = fe$1 ? () => {
  fe$1.then($e);
} : e.setImmediate ? setImmediate.bind(null, $e) : e.MutationObserver ? () => {
  var lr = document.createElement("div");
  new MutationObserver(() => {
    $e(), lr = null;
  }).observe(lr, { attributes: !0 }), lr.setAttribute("i", "1");
} : () => {
  setTimeout($e, 0);
}, be = function(lr, ar) {
  Se.push([lr, ar]), we && (ge$2(), we = !1);
}, _e = !0, we = !0, xe = [], ke = [], Ee = null, Pe = te, Ke = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: dt, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((lr) => {
    try {
      dt(lr[0], lr[1]);
    } catch (ar) {
    }
  });
} }, Oe = Ke, Se = [], Ae = 0, Ce = [];
function je(lr) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = ee$1, this._lib = !1;
  var ar = this._PSD = Oe;
  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), typeof lr != "function") {
    if (lr !== le$1)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Te(this, this._value));
  }
  this._state = null, this._value = null, ++ar.ref, Be(this, lr);
}
const De = { get: function() {
  var lr = Oe, ar = Xe;
  function cr(ur, fr) {
    var dr = !lr.global && (lr !== Oe || ar !== Xe);
    const gr = dr && !tt();
    var mr = new je((vr, yr) => {
      Fe(this, new Ie(lt$3(ur, lr, dr, gr), lt$3(fr, lr, dr, gr), vr, yr, lr));
    });
    return R && qe(mr, this), mr;
  }
  return cr.prototype = le$1, cr;
}, set: function(lr) {
  l(this, "then", lr && lr.prototype === le$1 ? De : { get: function() {
    return lr;
  }, set: De.set });
} };
function Ie(lr, ar, cr, ur, fr) {
  this.onFulfilled = typeof lr == "function" ? lr : null, this.onRejected = typeof ar == "function" ? ar : null, this.resolve = cr, this.reject = ur, this.psd = fr;
}
function Be(lr, ar) {
  try {
    ar((cr) => {
      if (lr._state === null) {
        if (cr === lr)
          throw new TypeError("A promise cannot be resolved with itself.");
        var ur = lr._lib && Ue();
        cr && typeof cr.then == "function" ? Be(lr, (fr, dr) => {
          cr instanceof je ? cr._then(fr, dr) : cr.then(fr, dr);
        }) : (lr._state = !0, lr._value = cr, Re$1(lr)), ur && Le();
      }
    }, Te.bind(null, lr));
  } catch (cr) {
    Te(lr, cr);
  }
}
function Te(lr, ar) {
  if (ke.push(ar), lr._state === null) {
    var cr = lr._lib && Ue();
    ar = Pe(ar), lr._state = !1, lr._value = ar, R && ar !== null && typeof ar == "object" && !ar._promise && function(ur, fr, dr) {
      try {
        ur.apply(null, dr);
      } catch (gr) {
        fr && fr(gr);
      }
    }(() => {
      var ur = d(ar, "stack");
      ar._promise = lr, l(ar, "stack", { get: () => ve ? ur && (ur.get ? ur.get.apply(ar) : ur.value) : lr.stack });
    }), function(ur) {
      xe.some((fr) => fr._value === ur._value) || xe.push(ur);
    }(lr), Re$1(lr), cr && Le();
  }
}
function Re$1(lr) {
  var ar = lr._listeners;
  lr._listeners = [];
  for (var cr = 0, ur = ar.length; cr < ur; ++cr)
    Fe(lr, ar[cr]);
  var fr = lr._PSD;
  --fr.ref || fr.finalize(), Ae === 0 && (++Ae, be(() => {
    --Ae == 0 && Ve();
  }, []));
}
function Fe(lr, ar) {
  if (lr._state !== null) {
    var cr = lr._state ? ar.onFulfilled : ar.onRejected;
    if (cr === null)
      return (lr._state ? ar.resolve : ar.reject)(lr._value);
    ++ar.psd.ref, ++Ae, be(Me, [cr, lr, ar]);
  } else
    lr._listeners.push(ar);
}
function Me(lr, ar, cr) {
  try {
    Ee = ar;
    var ur, fr = ar._value;
    ar._state ? ur = lr(fr) : (ke.length && (ke = []), ur = lr(fr), ke.indexOf(fr) === -1 && function(dr) {
      for (var gr = xe.length; gr; )
        if (xe[--gr]._value === dr._value)
          return void xe.splice(gr, 1);
    }(ar)), cr.resolve(ur);
  } catch (dr) {
    cr.reject(dr);
  } finally {
    Ee = null, --Ae == 0 && Ve(), --cr.psd.ref || cr.psd.finalize();
  }
}
function Ne(lr, ar, cr) {
  if (ar.length === cr)
    return ar;
  var ur = "";
  if (lr._state === !1) {
    var fr, dr, gr = lr._value;
    gr != null ? (fr = gr.name || "Error", dr = gr.message || gr, ur = $(gr, 0)) : (fr = gr, dr = ""), ar.push(fr + (dr ? ": " + dr : "") + ur);
  }
  return R && ((ur = $(lr._stackHolder, 2)) && ar.indexOf(ur) === -1 && ar.push(ur), lr._prev && Ne(lr._prev, ar, cr)), ar;
}
function qe(lr, ar) {
  var cr = ar ? ar._numPrev + 1 : 0;
  cr < 100 && (lr._prev = ar, lr._numPrev = cr);
}
function $e() {
  Ue() && Le();
}
function Ue() {
  var lr = _e;
  return _e = !1, we = !1, lr;
}
function Le() {
  var lr, ar, cr;
  do
    for (; Se.length > 0; )
      for (lr = Se, Se = [], cr = lr.length, ar = 0; ar < cr; ++ar) {
        var ur = lr[ar];
        ur[0].apply(null, ur[1]);
      }
  while (Se.length > 0);
  _e = !0, we = !0;
}
function Ve() {
  var lr = xe;
  xe = [], lr.forEach((ur) => {
    ur._PSD.onunhandled.call(null, ur._value, ur);
  });
  for (var ar = Ce.slice(0), cr = ar.length; cr; )
    ar[--cr]();
}
function We(lr) {
  return new je(le$1, !1, lr);
}
function Ye(lr, ar) {
  var cr = Oe;
  return function() {
    var ur = Ue(), fr = Oe;
    try {
      return it$1(cr, !0), lr.apply(this, arguments);
    } catch (dr) {
      ar && ar(dr);
    } finally {
      it$1(fr, !1), ur && Le();
    }
  };
}
a(je.prototype, { then: De, _then: function(lr, ar) {
  Fe(this, new Ie(null, null, lr, ar, Oe));
}, catch: function(lr) {
  if (arguments.length === 1)
    return this.then(null, lr);
  var ar = arguments[0], cr = arguments[1];
  return typeof ar == "function" ? this.then(null, (ur) => ur instanceof ar ? cr(ur) : We(ur)) : this.then(null, (ur) => ur && ur.name === ar ? cr(ur) : We(ur));
}, finally: function(lr) {
  return this.then((ar) => (lr(), ar), (ar) => (lr(), We(ar)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    ve = !0;
    var lr = Ne(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = lr), lr;
  } finally {
    ve = !1;
  }
} }, timeout: function(lr, ar) {
  return lr < 1 / 0 ? new je((cr, ur) => {
    var fr = setTimeout(() => ur(new X.Timeout(ar)), lr);
    this.then(cr, ur).finally(clearTimeout.bind(null, fr));
  }) : this;
} }), typeof Symbol != "undefined" && Symbol.toStringTag && l(je.prototype, Symbol.toStringTag, "Dexie.Promise"), Ke.env = ot(), a(je, { all: function() {
  var lr = B.apply(null, arguments).map(nt);
  return new je(function(ar, cr) {
    lr.length === 0 && ar([]);
    var ur = lr.length;
    lr.forEach((fr, dr) => je.resolve(fr).then((gr) => {
      lr[dr] = gr, --ur || ar(lr);
    }, cr));
  });
}, resolve: (lr) => {
  if (lr instanceof je)
    return lr;
  if (lr && typeof lr.then == "function")
    return new je((cr, ur) => {
      lr.then(cr, ur);
    });
  var ar = new je(le$1, !0, lr);
  return qe(ar, Ee), ar;
}, reject: We, race: function() {
  var lr = B.apply(null, arguments).map(nt);
  return new je((ar, cr) => {
    lr.map((ur) => je.resolve(ur).then(ar, cr));
  });
}, PSD: { get: () => Oe, set: (lr) => Oe = lr }, totalEchoes: { get: () => Xe }, newPSD: Ze, usePSD: at, scheduler: { get: () => be, set: (lr) => {
  be = lr;
} }, rejectionMapper: { get: () => Pe, set: (lr) => {
  Pe = lr;
} }, follow: (lr, ar) => new je((cr, ur) => Ze((fr, dr) => {
  var gr = Oe;
  gr.unhandleds = [], gr.onunhandled = dr, gr.finalize = re(function() {
    (function(mr) {
      function vr() {
        mr(), Ce.splice(Ce.indexOf(vr), 1);
      }
      Ce.push(vr), ++Ae, be(() => {
        --Ae == 0 && Ve();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? fr() : dr(this.unhandleds[0]);
    });
  }, gr.finalize), lr();
}, ar, cr, ur)) }), ye && (ye.allSettled && l(je, "allSettled", function() {
  const lr = B.apply(null, arguments).map(nt);
  return new je((ar) => {
    lr.length === 0 && ar([]);
    let cr = lr.length;
    const ur = new Array(cr);
    lr.forEach((fr, dr) => je.resolve(fr).then((gr) => ur[dr] = { status: "fulfilled", value: gr }, (gr) => ur[dr] = { status: "rejected", reason: gr }).then(() => --cr || ar(ur)));
  });
}), ye.any && typeof AggregateError != "undefined" && l(je, "any", function() {
  const lr = B.apply(null, arguments).map(nt);
  return new je((ar, cr) => {
    lr.length === 0 && cr(new AggregateError([]));
    let ur = lr.length;
    const fr = new Array(ur);
    lr.forEach((dr, gr) => je.resolve(dr).then((mr) => ar(mr), (mr) => {
      fr[gr] = mr, --ur || cr(new AggregateError(fr));
    }));
  });
}));
const ze = { awaits: 0, echoes: 0, id: 0 };
var Ge = 0, He = [], Qe = 0, Xe = 0, Je = 0;
function Ze(lr, ar, cr, ur) {
  var fr = Oe, dr = Object.create(fr);
  dr.parent = fr, dr.ref = 0, dr.global = !1, dr.id = ++Je;
  var gr = Ke.env;
  dr.env = me ? { Promise: je, PromiseProp: { value: je, configurable: !0, writable: !0 }, all: je.all, race: je.race, allSettled: je.allSettled, any: je.any, resolve: je.resolve, reject: je.reject, nthen: ct(gr.nthen, dr), gthen: ct(gr.gthen, dr) } : {}, ar && r(dr, ar), ++fr.ref, dr.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var mr = at(dr, lr, cr, ur);
  return dr.ref === 0 && dr.finalize(), mr;
}
function et() {
  return ze.id || (ze.id = ++Ge), ++ze.awaits, ze.echoes += ce, ze.id;
}
function tt() {
  return !!ze.awaits && (--ze.awaits == 0 && (ze.id = 0), ze.echoes = ze.awaits * ce, !0);
}
function nt(lr) {
  return ze.echoes && lr && lr.constructor === ye ? (et(), lr.then((ar) => (tt(), ar), (ar) => (tt(), ft(ar)))) : lr;
}
function rt(lr) {
  ++Xe, ze.echoes && --ze.echoes != 0 || (ze.echoes = ze.id = 0), He.push(Oe), it$1(lr, !0);
}
function st() {
  var lr = He[He.length - 1];
  He.pop(), it$1(lr, !1);
}
function it$1(lr, ar) {
  var cr = Oe;
  if ((ar ? !ze.echoes || Qe++ && lr === Oe : !Qe || --Qe && lr === Oe) || ut$1(ar ? rt.bind(null, lr) : st), lr !== Oe && (Oe = lr, cr === Ke && (Ke.env = ot()), me)) {
    var ur = Ke.env.Promise, fr = lr.env;
    de.then = fr.nthen, ur.prototype.then = fr.gthen, (cr.global || lr.global) && (Object.defineProperty(e, "Promise", fr.PromiseProp), ur.all = fr.all, ur.race = fr.race, ur.resolve = fr.resolve, ur.reject = fr.reject, fr.allSettled && (ur.allSettled = fr.allSettled), fr.any && (ur.any = fr.any));
  }
}
function ot() {
  var lr = e.Promise;
  return me ? { Promise: lr, PromiseProp: Object.getOwnPropertyDescriptor(e, "Promise"), all: lr.all, race: lr.race, allSettled: lr.allSettled, any: lr.any, resolve: lr.resolve, reject: lr.reject, nthen: de.then, gthen: lr.prototype.then } : {};
}
function at(lr, ar, cr, ur, fr) {
  var dr = Oe;
  try {
    return it$1(lr, !0), ar(cr, ur, fr);
  } finally {
    it$1(dr, !1);
  }
}
function ut$1(lr) {
  pe.call(he, lr);
}
function lt$3(lr, ar, cr, ur) {
  return typeof lr != "function" ? lr : function() {
    var fr = Oe;
    cr && et(), it$1(ar, !0);
    try {
      return lr.apply(this, arguments);
    } finally {
      it$1(fr, !1), ur && ut$1(tt);
    }
  };
}
function ct(lr, ar) {
  return function(cr, ur) {
    return lr.call(this, lt$3(cr, ar), lt$3(ur, ar));
  };
}
("" + pe).indexOf("[native code]") === -1 && (et = tt = ee$1);
const ht = "unhandledrejection";
function dt(lr, ar) {
  var cr;
  try {
    cr = ar.onuncatched(lr);
  } catch (dr) {
  }
  if (cr !== !1)
    try {
      var ur, fr = { promise: ar, reason: lr };
      if (e.document && document.createEvent ? ((ur = document.createEvent("Event")).initEvent(ht, !0, !0), r(ur, fr)) : e.CustomEvent && r(ur = new CustomEvent(ht, { detail: fr }), fr), ur && e.dispatchEvent && (dispatchEvent(ur), !e.PromiseRejectionEvent && e.onunhandledrejection))
        try {
          e.onunhandledrejection(ur);
        } catch (dr) {
        }
      R && ur && !ur.defaultPrevented && console.warn(`Unhandled rejection: ${lr.stack || lr}`);
    } catch (dr) {
    }
}
var ft = je.reject;
function pt(lr, ar, cr, ur) {
  if (lr.idbdb && (lr._state.openComplete || Oe.letThrough || lr._vip)) {
    var fr = lr._createTransaction(ar, cr, lr._dbSchema);
    try {
      fr.create(), lr._state.PR1398_maxLoop = 3;
    } catch (dr) {
      return dr.name === H.InvalidState && lr.isOpen() && --lr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), lr._close(), lr.open().then(() => pt(lr, ar, cr, ur))) : ft(dr);
    }
    return fr._promise(ar, (dr, gr) => Ze(() => (Oe.trans = fr, ur(dr, gr, fr)))).then((dr) => fr._completion.then(() => dr));
  }
  if (lr._state.openComplete)
    return ft(new X.DatabaseClosed(lr._state.dbOpenError));
  if (!lr._state.isBeingOpened) {
    if (!lr._options.autoOpen)
      return ft(new X.DatabaseClosed());
    lr.open().catch(ee$1);
  }
  return lr._state.dbReadyPromise.then(() => pt(lr, ar, cr, ur));
}
const yt = "3.2.4", mt = String.fromCharCode(65535), vt = -1 / 0, gt$3 = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", bt = "String expected.", _t = [], wt = typeof navigator != "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), xt = wt, kt = wt, Et = (lr) => !/(dexie\.js|dexie\.min\.js)/.test(lr), Pt = "__dbnames", Kt = "readonly", Ot = "readwrite";
function St(lr, ar) {
  return lr ? ar ? function() {
    return lr.apply(this, arguments) && ar.apply(this, arguments);
  } : lr : ar;
}
const At = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Ct(lr) {
  return typeof lr != "string" || /\./.test(lr) ? (ar) => ar : (ar) => (ar[lr] === void 0 && lr in ar && delete (ar = O(ar))[lr], ar);
}
class jt {
  _trans(ar, cr, ur) {
    const fr = this._tx || Oe.trans, dr = this.name;
    function gr(vr, yr, kr) {
      if (!kr.schema[dr])
        throw new X.NotFound("Table " + dr + " not part of transaction");
      return cr(kr.idbtrans, kr);
    }
    const mr = Ue();
    try {
      return fr && fr.db === this.db ? fr === Oe.trans ? fr._promise(ar, gr, ur) : Ze(() => fr._promise(ar, gr, ur), { trans: fr, transless: Oe.transless || Oe }) : pt(this.db, ar, [this.name], gr);
    } finally {
      mr && Le();
    }
  }
  get(ar, cr) {
    return ar && ar.constructor === Object ? this.where(ar).first(cr) : this._trans("readonly", (ur) => this.core.get({ trans: ur, key: ar }).then((fr) => this.hook.reading.fire(fr))).then(cr);
  }
  where(ar) {
    if (typeof ar == "string")
      return new this.db.WhereClause(this, ar);
    if (n(ar))
      return new this.db.WhereClause(this, `[${ar.join("+")}]`);
    const cr = t(ar);
    if (cr.length === 1)
      return this.where(cr[0]).equals(ar[cr[0]]);
    const ur = this.schema.indexes.concat(this.schema.primKey).filter((yr) => yr.compound && cr.every((kr) => yr.keyPath.indexOf(kr) >= 0) && yr.keyPath.every((kr) => cr.indexOf(kr) >= 0))[0];
    if (ur && this.db._maxKey !== mt)
      return this.where(ur.name).equals(ur.keyPath.map((yr) => ar[yr]));
    !ur && R && console.warn(`The query ${JSON.stringify(ar)} on ${this.name} would benefit of a compound index [${cr.join("+")}]`);
    const { idxByName: fr } = this.schema, dr = this.db._deps.indexedDB;
    function gr(yr, kr) {
      try {
        return dr.cmp(yr, kr) === 0;
      } catch (_r) {
        return !1;
      }
    }
    const [mr, vr] = cr.reduce(([yr, kr], _r) => {
      const xr = fr[_r], Sr = ar[_r];
      return [yr || xr, yr || !xr ? St(kr, xr && xr.multi ? (Er) => {
        const Cr = b(Er, _r);
        return n(Cr) && Cr.some((Tr) => gr(Sr, Tr));
      } : (Er) => gr(Sr, b(Er, _r))) : kr];
    }, [null, null]);
    return mr ? this.where(mr.name).equals(ar[mr.keyPath]).filter(vr) : ur ? this.filter(vr) : this.where(cr).equals("");
  }
  filter(ar) {
    return this.toCollection().and(ar);
  }
  count(ar) {
    return this.toCollection().count(ar);
  }
  offset(ar) {
    return this.toCollection().offset(ar);
  }
  limit(ar) {
    return this.toCollection().limit(ar);
  }
  each(ar) {
    return this.toCollection().each(ar);
  }
  toArray(ar) {
    return this.toCollection().toArray(ar);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(ar) {
    return new this.db.Collection(new this.db.WhereClause(this, n(ar) ? `[${ar.join("+")}]` : ar));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(ar) {
    this.schema.mappedClass = ar;
    const cr = (ur) => {
      if (!ur)
        return ur;
      const fr = Object.create(ar.prototype);
      for (var dr in ur)
        if (o(ur, dr))
          try {
            fr[dr] = ur[dr];
          } catch (gr) {
          }
      return fr;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = cr, this.hook("reading", cr), ar;
  }
  defineClass() {
    return this.mapToClass(function(ar) {
      r(this, ar);
    });
  }
  add(ar, cr) {
    const { auto: ur, keyPath: fr } = this.schema.primKey;
    let dr = ar;
    return fr && ur && (dr = Ct(fr)(ar)), this._trans("readwrite", (gr) => this.core.mutate({ trans: gr, type: "add", keys: cr != null ? [cr] : null, values: [dr] })).then((gr) => gr.numFailures ? je.reject(gr.failures[0]) : gr.lastResult).then((gr) => {
      if (fr)
        try {
          _(ar, fr, gr);
        } catch (mr) {
        }
      return gr;
    });
  }
  update(ar, cr) {
    if (typeof ar != "object" || n(ar))
      return this.where(":id").equals(ar).modify(cr);
    {
      const ur = b(ar, this.schema.primKey.keyPath);
      if (ur === void 0)
        return ft(new X.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof cr != "function" ? t(cr).forEach((fr) => {
          _(ar, fr, cr[fr]);
        }) : cr(ar, { value: ar, primKey: ur });
      } catch (fr) {
      }
      return this.where(":id").equals(ur).modify(cr);
    }
  }
  put(ar, cr) {
    const { auto: ur, keyPath: fr } = this.schema.primKey;
    let dr = ar;
    return fr && ur && (dr = Ct(fr)(ar)), this._trans("readwrite", (gr) => this.core.mutate({ trans: gr, type: "put", values: [dr], keys: cr != null ? [cr] : null })).then((gr) => gr.numFailures ? je.reject(gr.failures[0]) : gr.lastResult).then((gr) => {
      if (fr)
        try {
          _(ar, fr, gr);
        } catch (mr) {
        }
      return gr;
    });
  }
  delete(ar) {
    return this._trans("readwrite", (cr) => this.core.mutate({ trans: cr, type: "delete", keys: [ar] })).then((cr) => cr.numFailures ? je.reject(cr.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (ar) => this.core.mutate({ trans: ar, type: "deleteRange", range: At })).then((ar) => ar.numFailures ? je.reject(ar.failures[0]) : void 0);
  }
  bulkGet(ar) {
    return this._trans("readonly", (cr) => this.core.getMany({ keys: ar, trans: cr }).then((ur) => ur.map((fr) => this.hook.reading.fire(fr))));
  }
  bulkAdd(ar, cr, ur) {
    const fr = Array.isArray(cr) ? cr : void 0, dr = (ur = ur || (fr ? void 0 : cr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (gr) => {
      const { auto: mr, keyPath: vr } = this.schema.primKey;
      if (vr && fr)
        throw new X.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (fr && fr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const yr = ar.length;
      let kr = vr && mr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: gr, type: "add", keys: fr, values: kr, wantResults: dr }).then(({ numFailures: _r, results: xr, lastResult: Sr, failures: Er }) => {
        if (_r === 0)
          return dr ? xr : Sr;
        throw new G(`${this.name}.bulkAdd(): ${_r} of ${yr} operations failed`, Er);
      });
    });
  }
  bulkPut(ar, cr, ur) {
    const fr = Array.isArray(cr) ? cr : void 0, dr = (ur = ur || (fr ? void 0 : cr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (gr) => {
      const { auto: mr, keyPath: vr } = this.schema.primKey;
      if (vr && fr)
        throw new X.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (fr && fr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const yr = ar.length;
      let kr = vr && mr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: gr, type: "put", keys: fr, values: kr, wantResults: dr }).then(({ numFailures: _r, results: xr, lastResult: Sr, failures: Er }) => {
        if (_r === 0)
          return dr ? xr : Sr;
        throw new G(`${this.name}.bulkPut(): ${_r} of ${yr} operations failed`, Er);
      });
    });
  }
  bulkDelete(ar) {
    const cr = ar.length;
    return this._trans("readwrite", (ur) => this.core.mutate({ trans: ur, type: "delete", keys: ar })).then(({ numFailures: ur, lastResult: fr, failures: dr }) => {
      if (ur === 0)
        return fr;
      throw new G(`${this.name}.bulkDelete(): ${ur} of ${cr} operations failed`, dr);
    });
  }
}
function Dt(lr) {
  var ar = {}, cr = function(gr, mr) {
    if (mr) {
      for (var vr = arguments.length, yr = new Array(vr - 1); --vr; )
        yr[vr - 1] = arguments[vr];
      return ar[gr].subscribe.apply(null, yr), lr;
    }
    if (typeof gr == "string")
      return ar[gr];
  };
  cr.addEventType = dr;
  for (var ur = 1, fr = arguments.length; ur < fr; ++ur)
    dr(arguments[ur]);
  return cr;
  function dr(gr, mr, vr) {
    if (typeof gr != "object") {
      var yr;
      mr || (mr = ae), vr || (vr = ee$1);
      var kr = { subscribers: [], fire: vr, subscribe: function(_r) {
        kr.subscribers.indexOf(_r) === -1 && (kr.subscribers.push(_r), kr.fire = mr(kr.fire, _r));
      }, unsubscribe: function(_r) {
        kr.subscribers = kr.subscribers.filter(function(xr) {
          return xr !== _r;
        }), kr.fire = kr.subscribers.reduce(mr, vr);
      } };
      return ar[gr] = cr[gr] = kr, kr;
    }
    t(yr = gr).forEach(function(_r) {
      var xr = yr[_r];
      if (n(xr))
        dr(_r, yr[_r][0], yr[_r][1]);
      else {
        if (xr !== "asap")
          throw new X.InvalidArgument("Invalid event config");
        var Sr = dr(_r, te, function() {
          for (var Er = arguments.length, Cr = new Array(Er); Er--; )
            Cr[Er] = arguments[Er];
          Sr.subscribers.forEach(function(Tr) {
            v(function() {
              Tr.apply(null, Cr);
            });
          });
        });
      }
    });
  }
}
function It(lr, ar) {
  return c(ar).from({ prototype: lr }), ar;
}
function Bt(lr, ar) {
  return !(lr.filter || lr.algorithm || lr.or) && (ar ? lr.justLimit : !lr.replayFilter);
}
function Tt(lr, ar) {
  lr.filter = St(lr.filter, ar);
}
function Rt(lr, ar, cr) {
  var ur = lr.replayFilter;
  lr.replayFilter = ur ? () => St(ur(), ar()) : ar, lr.justLimit = cr && !ur;
}
function Ft(lr, ar) {
  if (lr.isPrimKey)
    return ar.primaryKey;
  const cr = ar.getIndexByKeyPath(lr.index);
  if (!cr)
    throw new X.Schema("KeyPath " + lr.index + " on object store " + ar.name + " is not indexed");
  return cr;
}
function Mt(lr, ar, cr) {
  const ur = Ft(lr, ar.schema);
  return ar.openCursor({ trans: cr, values: !lr.keysOnly, reverse: lr.dir === "prev", unique: !!lr.unique, query: { index: ur, range: lr.range } });
}
function Nt(lr, ar, cr, ur) {
  const fr = lr.replayFilter ? St(lr.filter, lr.replayFilter()) : lr.filter;
  if (lr.or) {
    const dr = {}, gr = (mr, vr, yr) => {
      if (!fr || fr(vr, yr, (xr) => vr.stop(xr), (xr) => vr.fail(xr))) {
        var kr = vr.primaryKey, _r = "" + kr;
        _r === "[object ArrayBuffer]" && (_r = "" + new Uint8Array(kr)), o(dr, _r) || (dr[_r] = !0, ar(mr, vr, yr));
      }
    };
    return Promise.all([lr.or._iterate(gr, cr), qt(Mt(lr, ur, cr), lr.algorithm, gr, !lr.keysOnly && lr.valueMapper)]);
  }
  return qt(Mt(lr, ur, cr), St(lr.algorithm, fr), ar, !lr.keysOnly && lr.valueMapper);
}
function qt(lr, ar, cr, ur) {
  var fr = Ye(ur ? (dr, gr, mr) => cr(ur(dr), gr, mr) : cr);
  return lr.then((dr) => {
    if (dr)
      return dr.start(() => {
        var gr = () => dr.continue();
        ar && !ar(dr, (mr) => gr = mr, (mr) => {
          dr.stop(mr), gr = ee$1;
        }, (mr) => {
          dr.fail(mr), gr = ee$1;
        }) || fr(dr.value, dr, (mr) => gr = mr), gr();
      });
  });
}
function $t(lr, ar) {
  try {
    const cr = Ut(lr), ur = Ut(ar);
    if (cr !== ur)
      return cr === "Array" ? 1 : ur === "Array" ? -1 : cr === "binary" ? 1 : ur === "binary" ? -1 : cr === "string" ? 1 : ur === "string" ? -1 : cr === "Date" ? 1 : ur !== "Date" ? NaN : -1;
    switch (cr) {
      case "number":
      case "Date":
      case "string":
        return lr > ar ? 1 : lr < ar ? -1 : 0;
      case "binary":
        return function(fr, dr) {
          const gr = fr.length, mr = dr.length, vr = gr < mr ? gr : mr;
          for (let yr = 0; yr < vr; ++yr)
            if (fr[yr] !== dr[yr])
              return fr[yr] < dr[yr] ? -1 : 1;
          return gr === mr ? 0 : gr < mr ? -1 : 1;
        }(Lt$1(lr), Lt$1(ar));
      case "Array":
        return function(fr, dr) {
          const gr = fr.length, mr = dr.length, vr = gr < mr ? gr : mr;
          for (let yr = 0; yr < vr; ++yr) {
            const kr = $t(fr[yr], dr[yr]);
            if (kr !== 0)
              return kr;
          }
          return gr === mr ? 0 : gr < mr ? -1 : 1;
        }(lr, ar);
    }
  } catch (cr) {
  }
  return NaN;
}
function Ut(lr) {
  const ar = typeof lr;
  if (ar !== "object")
    return ar;
  if (ArrayBuffer.isView(lr))
    return "binary";
  const cr = C(lr);
  return cr === "ArrayBuffer" ? "binary" : cr;
}
function Lt$1(lr) {
  return lr instanceof Uint8Array ? lr : ArrayBuffer.isView(lr) ? new Uint8Array(lr.buffer, lr.byteOffset, lr.byteLength) : new Uint8Array(lr);
}
class Vt {
  _read(ar, cr) {
    var ur = this._ctx;
    return ur.error ? ur.table._trans(null, ft.bind(null, ur.error)) : ur.table._trans("readonly", ar).then(cr);
  }
  _write(ar) {
    var cr = this._ctx;
    return cr.error ? cr.table._trans(null, ft.bind(null, cr.error)) : cr.table._trans("readwrite", ar, "locked");
  }
  _addAlgorithm(ar) {
    var cr = this._ctx;
    cr.algorithm = St(cr.algorithm, ar);
  }
  _iterate(ar, cr) {
    return Nt(this._ctx, ar, cr, this._ctx.table.core);
  }
  clone(ar) {
    var cr = Object.create(this.constructor.prototype), ur = Object.create(this._ctx);
    return ar && r(ur, ar), cr._ctx = ur, cr;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(ar) {
    var cr = this._ctx;
    return this._read((ur) => Nt(cr, ar, ur, cr.table.core));
  }
  count(ar) {
    return this._read((cr) => {
      const ur = this._ctx, fr = ur.table.core;
      if (Bt(ur, !0))
        return fr.count({ trans: cr, query: { index: Ft(ur, fr.schema), range: ur.range } }).then((gr) => Math.min(gr, ur.limit));
      var dr = 0;
      return Nt(ur, () => (++dr, !1), cr, fr).then(() => dr);
    }).then(ar);
  }
  sortBy(ar, cr) {
    const ur = ar.split(".").reverse(), fr = ur[0], dr = ur.length - 1;
    function gr(yr, kr) {
      return kr ? gr(yr[ur[kr]], kr - 1) : yr[fr];
    }
    var mr = this._ctx.dir === "next" ? 1 : -1;
    function vr(yr, kr) {
      var _r = gr(yr, dr), xr = gr(kr, dr);
      return _r < xr ? -mr : _r > xr ? mr : 0;
    }
    return this.toArray(function(yr) {
      return yr.sort(vr);
    }).then(cr);
  }
  toArray(ar) {
    return this._read((cr) => {
      var ur = this._ctx;
      if (ur.dir === "next" && Bt(ur, !0) && ur.limit > 0) {
        const { valueMapper: fr } = ur, dr = Ft(ur, ur.table.core.schema);
        return ur.table.core.query({ trans: cr, limit: ur.limit, values: !0, query: { index: dr, range: ur.range } }).then(({ result: gr }) => fr ? gr.map(fr) : gr);
      }
      {
        const fr = [];
        return Nt(ur, (dr) => fr.push(dr), cr, ur.table.core).then(() => fr);
      }
    }, ar);
  }
  offset(ar) {
    var cr = this._ctx;
    return ar <= 0 || (cr.offset += ar, Bt(cr) ? Rt(cr, () => {
      var ur = ar;
      return (fr, dr) => ur === 0 || (ur === 1 ? (--ur, !1) : (dr(() => {
        fr.advance(ur), ur = 0;
      }), !1));
    }) : Rt(cr, () => {
      var ur = ar;
      return () => --ur < 0;
    })), this;
  }
  limit(ar) {
    return this._ctx.limit = Math.min(this._ctx.limit, ar), Rt(this._ctx, () => {
      var cr = ar;
      return function(ur, fr, dr) {
        return --cr <= 0 && fr(dr), cr >= 0;
      };
    }, !0), this;
  }
  until(ar, cr) {
    return Tt(this._ctx, function(ur, fr, dr) {
      return !ar(ur.value) || (fr(dr), cr);
    }), this;
  }
  first(ar) {
    return this.limit(1).toArray(function(cr) {
      return cr[0];
    }).then(ar);
  }
  last(ar) {
    return this.reverse().first(ar);
  }
  filter(ar) {
    var cr, ur;
    return Tt(this._ctx, function(fr) {
      return ar(fr.value);
    }), cr = this._ctx, ur = ar, cr.isMatch = St(cr.isMatch, ur), this;
  }
  and(ar) {
    return this.filter(ar);
  }
  or(ar) {
    return new this.db.WhereClause(this._ctx.table, ar, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(ar) {
    var cr = this._ctx;
    return cr.keysOnly = !cr.isMatch, this.each(function(ur, fr) {
      ar(fr.key, fr);
    });
  }
  eachUniqueKey(ar) {
    return this._ctx.unique = "unique", this.eachKey(ar);
  }
  eachPrimaryKey(ar) {
    var cr = this._ctx;
    return cr.keysOnly = !cr.isMatch, this.each(function(ur, fr) {
      ar(fr.primaryKey, fr);
    });
  }
  keys(ar) {
    var cr = this._ctx;
    cr.keysOnly = !cr.isMatch;
    var ur = [];
    return this.each(function(fr, dr) {
      ur.push(dr.key);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  primaryKeys(ar) {
    var cr = this._ctx;
    if (cr.dir === "next" && Bt(cr, !0) && cr.limit > 0)
      return this._read((fr) => {
        var dr = Ft(cr, cr.table.core.schema);
        return cr.table.core.query({ trans: fr, values: !1, limit: cr.limit, query: { index: dr, range: cr.range } });
      }).then(({ result: fr }) => fr).then(ar);
    cr.keysOnly = !cr.isMatch;
    var ur = [];
    return this.each(function(fr, dr) {
      ur.push(dr.primaryKey);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  uniqueKeys(ar) {
    return this._ctx.unique = "unique", this.keys(ar);
  }
  firstKey(ar) {
    return this.limit(1).keys(function(cr) {
      return cr[0];
    }).then(ar);
  }
  lastKey(ar) {
    return this.reverse().firstKey(ar);
  }
  distinct() {
    var ar = this._ctx, cr = ar.index && ar.table.schema.idxByName[ar.index];
    if (!cr || !cr.multi)
      return this;
    var ur = {};
    return Tt(this._ctx, function(fr) {
      var dr = fr.primaryKey.toString(), gr = o(ur, dr);
      return ur[dr] = !0, !gr;
    }), this;
  }
  modify(ar) {
    var cr = this._ctx;
    return this._write((ur) => {
      var fr;
      if (typeof ar == "function")
        fr = ar;
      else {
        var dr = t(ar), gr = dr.length;
        fr = function(Cr) {
          for (var Tr = !1, Ar = 0; Ar < gr; ++Ar) {
            var Ir = dr[Ar], Mr = ar[Ir];
            b(Cr, Ir) !== Mr && (_(Cr, Ir, Mr), Tr = !0);
          }
          return Tr;
        };
      }
      const mr = cr.table.core, { outbound: vr, extractKey: yr } = mr.schema.primaryKey, kr = this.db._options.modifyChunkSize || 200, _r = [];
      let xr = 0;
      const Sr = [], Er = (Cr, Tr) => {
        const { failures: Ar, numFailures: Ir } = Tr;
        xr += Cr - Ir;
        for (let Mr of t(Ar))
          _r.push(Ar[Mr]);
      };
      return this.clone().primaryKeys().then((Cr) => {
        const Tr = (Ar) => {
          const Ir = Math.min(kr, Cr.length - Ar);
          return mr.getMany({ trans: ur, keys: Cr.slice(Ar, Ar + Ir), cache: "immutable" }).then((Mr) => {
            const Hr = [], Br = [], zr = vr ? [] : null, Gr = [];
            for (let Jr = 0; Jr < Ir; ++Jr) {
              const li = Mr[Jr], Qr = { value: O(li), primKey: Cr[Ar + Jr] };
              fr.call(Qr, Qr.value, Qr) !== !1 && (Qr.value == null ? Gr.push(Cr[Ar + Jr]) : vr || $t(yr(li), yr(Qr.value)) === 0 ? (Br.push(Qr.value), vr && zr.push(Cr[Ar + Jr])) : (Gr.push(Cr[Ar + Jr]), Hr.push(Qr.value)));
            }
            const Xr = Bt(cr) && cr.limit === 1 / 0 && (typeof ar != "function" || ar === Wt) && { index: cr.index, range: cr.range };
            return Promise.resolve(Hr.length > 0 && mr.mutate({ trans: ur, type: "add", values: Hr }).then((Jr) => {
              for (let li in Jr.failures)
                Gr.splice(parseInt(li), 1);
              Er(Hr.length, Jr);
            })).then(() => (Br.length > 0 || Xr && typeof ar == "object") && mr.mutate({ trans: ur, type: "put", keys: zr, values: Br, criteria: Xr, changeSpec: typeof ar != "function" && ar }).then((Jr) => Er(Br.length, Jr))).then(() => (Gr.length > 0 || Xr && ar === Wt) && mr.mutate({ trans: ur, type: "delete", keys: Gr, criteria: Xr }).then((Jr) => Er(Gr.length, Jr))).then(() => Cr.length > Ar + Ir && Tr(Ar + kr));
          });
        };
        return Tr(0).then(() => {
          if (_r.length > 0)
            throw new z("Error modifying one or more objects", _r, xr, Sr);
          return Cr.length;
        });
      });
    });
  }
  delete() {
    var ar = this._ctx, cr = ar.range;
    return Bt(ar) && (ar.isPrimKey && !kt || cr.type === 3) ? this._write((ur) => {
      const { primaryKey: fr } = ar.table.core.schema, dr = cr;
      return ar.table.core.count({ trans: ur, query: { index: fr, range: dr } }).then((gr) => ar.table.core.mutate({ trans: ur, type: "deleteRange", range: dr }).then(({ failures: mr, lastResult: vr, results: yr, numFailures: kr }) => {
        if (kr)
          throw new z("Could not delete some values", Object.keys(mr).map((_r) => mr[_r]), gr - kr);
        return gr - kr;
      }));
    }) : this.modify(Wt);
  }
}
const Wt = (lr, ar) => ar.value = null;
function Yt(lr, ar) {
  return lr < ar ? -1 : lr === ar ? 0 : 1;
}
function zt(lr, ar) {
  return lr > ar ? -1 : lr === ar ? 0 : 1;
}
function Gt$1(lr, ar, cr) {
  var ur = lr instanceof en ? new lr.Collection(lr) : lr;
  return ur._ctx.error = cr ? new cr(ar) : new TypeError(ar), ur;
}
function Ht(lr) {
  return new lr.Collection(lr, () => Zt("")).limit(0);
}
function Qt(lr, ar, cr, ur, fr, dr) {
  for (var gr = Math.min(lr.length, ur.length), mr = -1, vr = 0; vr < gr; ++vr) {
    var yr = ar[vr];
    if (yr !== ur[vr])
      return fr(lr[vr], cr[vr]) < 0 ? lr.substr(0, vr) + cr[vr] + cr.substr(vr + 1) : fr(lr[vr], ur[vr]) < 0 ? lr.substr(0, vr) + ur[vr] + cr.substr(vr + 1) : mr >= 0 ? lr.substr(0, mr) + ar[mr] + cr.substr(mr + 1) : null;
    fr(lr[vr], yr) < 0 && (mr = vr);
  }
  return gr < ur.length && dr === "next" ? lr + cr.substr(lr.length) : gr < lr.length && dr === "prev" ? lr.substr(0, cr.length) : mr < 0 ? null : lr.substr(0, mr) + ur[mr] + cr.substr(mr + 1);
}
function Xt(lr, ar, cr, ur) {
  var fr, dr, gr, mr, vr, yr, kr, _r = cr.length;
  if (!cr.every((Cr) => typeof Cr == "string"))
    return Gt$1(lr, bt);
  function xr(Cr) {
    fr = function(Ar) {
      return Ar === "next" ? (Ir) => Ir.toUpperCase() : (Ir) => Ir.toLowerCase();
    }(Cr), dr = function(Ar) {
      return Ar === "next" ? (Ir) => Ir.toLowerCase() : (Ir) => Ir.toUpperCase();
    }(Cr), gr = Cr === "next" ? Yt : zt;
    var Tr = cr.map(function(Ar) {
      return { lower: dr(Ar), upper: fr(Ar) };
    }).sort(function(Ar, Ir) {
      return gr(Ar.lower, Ir.lower);
    });
    mr = Tr.map(function(Ar) {
      return Ar.upper;
    }), vr = Tr.map(function(Ar) {
      return Ar.lower;
    }), yr = Cr, kr = Cr === "next" ? "" : ur;
  }
  xr("next");
  var Sr = new lr.Collection(lr, () => Jt(mr[0], vr[_r - 1] + ur));
  Sr._ondirectionchange = function(Cr) {
    xr(Cr);
  };
  var Er = 0;
  return Sr._addAlgorithm(function(Cr, Tr, Ar) {
    var Ir = Cr.key;
    if (typeof Ir != "string")
      return !1;
    var Mr = dr(Ir);
    if (ar(Mr, vr, Er))
      return !0;
    for (var Hr = null, Br = Er; Br < _r; ++Br) {
      var zr = Qt(Ir, Mr, mr[Br], vr[Br], gr, yr);
      zr === null && Hr === null ? Er = Br + 1 : (Hr === null || gr(Hr, zr) > 0) && (Hr = zr);
    }
    return Tr(Hr !== null ? function() {
      Cr.continue(Hr + kr);
    } : Ar), !1;
  }), Sr;
}
function Jt(lr, ar, cr, ur) {
  return { type: 2, lower: lr, upper: ar, lowerOpen: cr, upperOpen: ur };
}
function Zt(lr) {
  return { type: 1, lower: lr, upper: lr };
}
class en {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(ar, cr, ur, fr) {
    ur = ur !== !1, fr = fr === !0;
    try {
      return this._cmp(ar, cr) > 0 || this._cmp(ar, cr) === 0 && (ur || fr) && (!ur || !fr) ? Ht(this) : new this.Collection(this, () => Jt(ar, cr, !ur, !fr));
    } catch (dr) {
      return Gt$1(this, gt$3);
    }
  }
  equals(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Zt(ar));
  }
  above(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !0));
  }
  aboveOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !1));
  }
  below(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar, !1, !0));
  }
  belowOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar));
  }
  startsWith(ar) {
    return typeof ar != "string" ? Gt$1(this, bt) : this.between(ar, ar + mt, !0, !0);
  }
  startsWithIgnoreCase(ar) {
    return ar === "" ? this.startsWith(ar) : Xt(this, (cr, ur) => cr.indexOf(ur[0]) === 0, [ar], mt);
  }
  equalsIgnoreCase(ar) {
    return Xt(this, (cr, ur) => cr === ur[0], [ar], "");
  }
  anyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (cr, ur) => ur.indexOf(cr) !== -1, ar, "");
  }
  startsWithAnyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (cr, ur) => ur.some((fr) => cr.indexOf(fr) === 0), ar, mt);
  }
  anyOf() {
    const ar = B.apply(I, arguments);
    let cr = this._cmp;
    try {
      ar.sort(cr);
    } catch (dr) {
      return Gt$1(this, gt$3);
    }
    if (ar.length === 0)
      return Ht(this);
    const ur = new this.Collection(this, () => Jt(ar[0], ar[ar.length - 1]));
    ur._ondirectionchange = (dr) => {
      cr = dr === "next" ? this._ascending : this._descending, ar.sort(cr);
    };
    let fr = 0;
    return ur._addAlgorithm((dr, gr, mr) => {
      const vr = dr.key;
      for (; cr(vr, ar[fr]) > 0; )
        if (++fr, fr === ar.length)
          return gr(mr), !1;
      return cr(vr, ar[fr]) === 0 || (gr(() => {
        dr.continue(ar[fr]);
      }), !1);
    }), ur;
  }
  notEqual(ar) {
    return this.inAnyRange([[vt, ar], [ar, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const ar = B.apply(I, arguments);
    if (ar.length === 0)
      return new this.Collection(this);
    try {
      ar.sort(this._ascending);
    } catch (ur) {
      return Gt$1(this, gt$3);
    }
    const cr = ar.reduce((ur, fr) => ur ? ur.concat([[ur[ur.length - 1][1], fr]]) : [[vt, fr]], null);
    return cr.push([ar[ar.length - 1], this.db._maxKey]), this.inAnyRange(cr, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(ar, cr) {
    const ur = this._cmp, fr = this._ascending, dr = this._descending, gr = this._min, mr = this._max;
    if (ar.length === 0)
      return Ht(this);
    if (!ar.every((Ir) => Ir[0] !== void 0 && Ir[1] !== void 0 && fr(Ir[0], Ir[1]) <= 0))
      return Gt$1(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", X.InvalidArgument);
    const vr = !cr || cr.includeLowers !== !1, yr = cr && cr.includeUppers === !0;
    let kr, _r = fr;
    function xr(Ir, Mr) {
      return _r(Ir[0], Mr[0]);
    }
    try {
      kr = ar.reduce(function(Ir, Mr) {
        let Hr = 0, Br = Ir.length;
        for (; Hr < Br; ++Hr) {
          const zr = Ir[Hr];
          if (ur(Mr[0], zr[1]) < 0 && ur(Mr[1], zr[0]) > 0) {
            zr[0] = gr(zr[0], Mr[0]), zr[1] = mr(zr[1], Mr[1]);
            break;
          }
        }
        return Hr === Br && Ir.push(Mr), Ir;
      }, []), kr.sort(xr);
    } catch (Ir) {
      return Gt$1(this, gt$3);
    }
    let Sr = 0;
    const Er = yr ? (Ir) => fr(Ir, kr[Sr][1]) > 0 : (Ir) => fr(Ir, kr[Sr][1]) >= 0, Cr = vr ? (Ir) => dr(Ir, kr[Sr][0]) > 0 : (Ir) => dr(Ir, kr[Sr][0]) >= 0;
    let Tr = Er;
    const Ar = new this.Collection(this, () => Jt(kr[0][0], kr[kr.length - 1][1], !vr, !yr));
    return Ar._ondirectionchange = (Ir) => {
      Ir === "next" ? (Tr = Er, _r = fr) : (Tr = Cr, _r = dr), kr.sort(xr);
    }, Ar._addAlgorithm((Ir, Mr, Hr) => {
      for (var Br = Ir.key; Tr(Br); )
        if (++Sr, Sr === kr.length)
          return Mr(Hr), !1;
      return !!function(zr) {
        return !Er(zr) && !Cr(zr);
      }(Br) || (this._cmp(Br, kr[Sr][1]) === 0 || this._cmp(Br, kr[Sr][0]) === 0 || Mr(() => {
        _r === fr ? Ir.continue(kr[Sr][0]) : Ir.continue(kr[Sr][1]);
      }), !1);
    }), Ar;
  }
  startsWithAnyOf() {
    const ar = B.apply(I, arguments);
    return ar.every((cr) => typeof cr == "string") ? ar.length === 0 ? Ht(this) : this.inAnyRange(ar.map((cr) => [cr, cr + mt])) : Gt$1(this, "startsWithAnyOf() only works with strings");
  }
}
function tn(lr) {
  return Ye(function(ar) {
    return nn(ar), lr(ar.target.error), !1;
  });
}
function nn(lr) {
  lr.stopPropagation && lr.stopPropagation(), lr.preventDefault && lr.preventDefault();
}
const rn = "storagemutated", sn = "x-storagemutated-1", on$1 = Dt(null, rn);
class an {
  _lock() {
    return m(!Oe.global), ++this._reculock, this._reculock !== 1 || Oe.global || (Oe.lockOwnerFor = this), this;
  }
  _unlock() {
    if (m(!Oe.global), --this._reculock == 0)
      for (Oe.global || (Oe.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var ar = this._blockedFuncs.shift();
        try {
          at(ar[1], ar[0]);
        } catch (cr) {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Oe.lockOwnerFor !== this;
  }
  create(ar) {
    if (!this.mode)
      return this;
    const cr = this.db.idbdb, ur = this.db._state.dbOpenError;
    if (m(!this.idbtrans), !ar && !cr)
      switch (ur && ur.name) {
        case "DatabaseClosedError":
          throw new X.DatabaseClosed(ur);
        case "MissingAPIError":
          throw new X.MissingAPI(ur.message, ur);
        default:
          throw new X.OpenFailed(ur);
      }
    if (!this.active)
      throw new X.TransactionInactive();
    return m(this._completion._state === null), (ar = this.idbtrans = ar || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : cr.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Ye((fr) => {
      nn(fr), this._reject(ar.error);
    }), ar.onabort = Ye((fr) => {
      nn(fr), this.active && this._reject(new X.Abort(ar.error)), this.active = !1, this.on("abort").fire(fr);
    }), ar.oncomplete = Ye(() => {
      this.active = !1, this._resolve(), "mutatedParts" in ar && on$1.storagemutated.fire(ar.mutatedParts);
    }), this;
  }
  _promise(ar, cr, ur) {
    if (ar === "readwrite" && this.mode !== "readwrite")
      return ft(new X.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ft(new X.TransactionInactive());
    if (this._locked())
      return new je((dr, gr) => {
        this._blockedFuncs.push([() => {
          this._promise(ar, cr, ur).then(dr, gr);
        }, Oe]);
      });
    if (ur)
      return Ze(() => {
        var dr = new je((gr, mr) => {
          this._lock();
          const vr = cr(gr, mr, this);
          vr && vr.then && vr.then(gr, mr);
        });
        return dr.finally(() => this._unlock()), dr._lib = !0, dr;
      });
    var fr = new je((dr, gr) => {
      var mr = cr(dr, gr, this);
      mr && mr.then && mr.then(dr, gr);
    });
    return fr._lib = !0, fr;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(ar) {
    var cr = this._root();
    const ur = je.resolve(ar);
    if (cr._waitingFor)
      cr._waitingFor = cr._waitingFor.then(() => ur);
    else {
      cr._waitingFor = ur, cr._waitingQueue = [];
      var fr = cr.idbtrans.objectStore(cr.storeNames[0]);
      (function gr() {
        for (++cr._spinCount; cr._waitingQueue.length; )
          cr._waitingQueue.shift()();
        cr._waitingFor && (fr.get(-1 / 0).onsuccess = gr);
      })();
    }
    var dr = cr._waitingFor;
    return new je((gr, mr) => {
      ur.then((vr) => cr._waitingQueue.push(Ye(gr.bind(null, vr))), (vr) => cr._waitingQueue.push(Ye(mr.bind(null, vr)))).finally(() => {
        cr._waitingFor === dr && (cr._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));
  }
  table(ar) {
    const cr = this._memoizedTables || (this._memoizedTables = {});
    if (o(cr, ar))
      return cr[ar];
    const ur = this.schema[ar];
    if (!ur)
      throw new X.NotFound("Table " + ar + " not part of transaction");
    const fr = new this.db.Table(ar, ur, this);
    return fr.core = this.db.core.table(ar), cr[ar] = fr, fr;
  }
}
function un(lr, ar, cr, ur, fr, dr, gr) {
  return { name: lr, keyPath: ar, unique: cr, multi: ur, auto: fr, compound: dr, src: (cr && !gr ? "&" : "") + (ur ? "*" : "") + (fr ? "++" : "") + ln(ar) };
}
function ln(lr) {
  return typeof lr == "string" ? lr : lr ? "[" + [].join.call(lr, "+") + "]" : "";
}
function cn(lr, ar, cr) {
  return { name: lr, primKey: ar, indexes: cr, mappedClass: null, idxByName: g(cr, (ur) => [ur.name, ur]) };
}
let hn = (lr) => {
  try {
    return lr.only([[]]), hn = () => [[]], [[]];
  } catch (ar) {
    return hn = () => mt, mt;
  }
};
function dn(lr) {
  return lr == null ? () => {
  } : typeof lr == "string" ? function(ar) {
    return ar.split(".").length === 1 ? (ur) => ur[ar] : (ur) => b(ur, ar);
  }(lr) : (ar) => b(ar, lr);
}
function fn(lr) {
  return [].slice.call(lr);
}
let pn = 0;
function yn(lr) {
  return lr == null ? ":id" : typeof lr == "string" ? lr : `[${lr.join("+")}]`;
}
function mn(lr, ar, cr) {
  function ur(vr) {
    if (vr.type === 3)
      return null;
    if (vr.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: yr, upper: kr, lowerOpen: _r, upperOpen: xr } = vr;
    return yr === void 0 ? kr === void 0 ? null : ar.upperBound(kr, !!xr) : kr === void 0 ? ar.lowerBound(yr, !!_r) : ar.bound(yr, kr, !!_r, !!xr);
  }
  const { schema: fr, hasGetAll: dr } = function(vr, yr) {
    const kr = fn(vr.objectStoreNames);
    return { schema: { name: vr.name, tables: kr.map((_r) => yr.objectStore(_r)).map((_r) => {
      const { keyPath: xr, autoIncrement: Sr } = _r, Er = n(xr), Cr = xr == null, Tr = {}, Ar = { name: _r.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: Cr, compound: Er, keyPath: xr, autoIncrement: Sr, unique: !0, extractKey: dn(xr) }, indexes: fn(_r.indexNames).map((Ir) => _r.index(Ir)).map((Ir) => {
        const { name: Mr, unique: Hr, multiEntry: Br, keyPath: zr } = Ir, Gr = { name: Mr, compound: n(zr), keyPath: zr, unique: Hr, multiEntry: Br, extractKey: dn(zr) };
        return Tr[yn(zr)] = Gr, Gr;
      }), getIndexByKeyPath: (Ir) => Tr[yn(Ir)] };
      return Tr[":id"] = Ar.primaryKey, xr != null && (Tr[yn(xr)] = Ar.primaryKey), Ar;
    }) }, hasGetAll: kr.length > 0 && "getAll" in yr.objectStore(kr[0]) && !(typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(lr, cr), gr = fr.tables.map((vr) => function(yr) {
    const kr = yr.name;
    return { name: kr, schema: yr, mutate: function({ trans: _r, type: xr, keys: Sr, values: Er, range: Cr }) {
      return new Promise((Tr, Ar) => {
        Tr = Ye(Tr);
        const Ir = _r.objectStore(kr), Mr = Ir.keyPath == null, Hr = xr === "put" || xr === "add";
        if (!Hr && xr !== "delete" && xr !== "deleteRange")
          throw new Error("Invalid operation type: " + xr);
        const { length: Br } = Sr || Er || { length: 1 };
        if (Sr && Er && Sr.length !== Er.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (Br === 0)
          return Tr({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let zr;
        const Gr = [], Xr = [];
        let Jr = 0;
        const li = (ei) => {
          ++Jr, nn(ei);
        };
        if (xr === "deleteRange") {
          if (Cr.type === 4)
            return Tr({ numFailures: Jr, failures: Xr, results: [], lastResult: void 0 });
          Cr.type === 3 ? Gr.push(zr = Ir.clear()) : Gr.push(zr = Ir.delete(ur(Cr)));
        } else {
          const [ei, ui] = Hr ? Mr ? [Er, Sr] : [Er, null] : [Sr, null];
          if (Hr)
            for (let Ai = 0; Ai < Br; ++Ai)
              Gr.push(zr = ui && ui[Ai] !== void 0 ? Ir[xr](ei[Ai], ui[Ai]) : Ir[xr](ei[Ai])), zr.onerror = li;
          else
            for (let Ai = 0; Ai < Br; ++Ai)
              Gr.push(zr = Ir[xr](ei[Ai])), zr.onerror = li;
        }
        const Qr = (ei) => {
          const ui = ei.target.result;
          Gr.forEach((Ai, fi) => Ai.error != null && (Xr[fi] = Ai.error)), Tr({ numFailures: Jr, failures: Xr, results: xr === "delete" ? Sr : Gr.map((Ai) => Ai.result), lastResult: ui });
        };
        zr.onerror = (ei) => {
          li(ei), Qr(ei);
        }, zr.onsuccess = Qr;
      });
    }, getMany: ({ trans: _r, keys: xr }) => new Promise((Sr, Er) => {
      Sr = Ye(Sr);
      const Cr = _r.objectStore(kr), Tr = xr.length, Ar = new Array(Tr);
      let Ir, Mr = 0, Hr = 0;
      const Br = (Gr) => {
        const Xr = Gr.target;
        Ar[Xr._pos] = Xr.result, ++Hr === Mr && Sr(Ar);
      }, zr = tn(Er);
      for (let Gr = 0; Gr < Tr; ++Gr)
        xr[Gr] != null && (Ir = Cr.get(xr[Gr]), Ir._pos = Gr, Ir.onsuccess = Br, Ir.onerror = zr, ++Mr);
      Mr === 0 && Sr(Ar);
    }), get: ({ trans: _r, key: xr }) => new Promise((Sr, Er) => {
      Sr = Ye(Sr);
      const Cr = _r.objectStore(kr).get(xr);
      Cr.onsuccess = (Tr) => Sr(Tr.target.result), Cr.onerror = tn(Er);
    }), query: function(_r) {
      return (xr) => new Promise((Sr, Er) => {
        Sr = Ye(Sr);
        const { trans: Cr, values: Tr, limit: Ar, query: Ir } = xr, Mr = Ar === 1 / 0 ? void 0 : Ar, { index: Hr, range: Br } = Ir, zr = Cr.objectStore(kr), Gr = Hr.isPrimaryKey ? zr : zr.index(Hr.name), Xr = ur(Br);
        if (Ar === 0)
          return Sr({ result: [] });
        if (_r) {
          const Jr = Tr ? Gr.getAll(Xr, Mr) : Gr.getAllKeys(Xr, Mr);
          Jr.onsuccess = (li) => Sr({ result: li.target.result }), Jr.onerror = tn(Er);
        } else {
          let Jr = 0;
          const li = Tr || !("openKeyCursor" in Gr) ? Gr.openCursor(Xr) : Gr.openKeyCursor(Xr), Qr = [];
          li.onsuccess = (ei) => {
            const ui = li.result;
            return ui ? (Qr.push(Tr ? ui.value : ui.primaryKey), ++Jr === Ar ? Sr({ result: Qr }) : void ui.continue()) : Sr({ result: Qr });
          }, li.onerror = tn(Er);
        }
      });
    }(dr), openCursor: function({ trans: _r, values: xr, query: Sr, reverse: Er, unique: Cr }) {
      return new Promise((Tr, Ar) => {
        Tr = Ye(Tr);
        const { index: Ir, range: Mr } = Sr, Hr = _r.objectStore(kr), Br = Ir.isPrimaryKey ? Hr : Hr.index(Ir.name), zr = Er ? Cr ? "prevunique" : "prev" : Cr ? "nextunique" : "next", Gr = xr || !("openKeyCursor" in Br) ? Br.openCursor(ur(Mr), zr) : Br.openKeyCursor(ur(Mr), zr);
        Gr.onerror = tn(Ar), Gr.onsuccess = Ye((Xr) => {
          const Jr = Gr.result;
          if (!Jr)
            return void Tr(null);
          Jr.___id = ++pn, Jr.done = !1;
          const li = Jr.continue.bind(Jr);
          let Qr = Jr.continuePrimaryKey;
          Qr && (Qr = Qr.bind(Jr));
          const ei = Jr.advance.bind(Jr), ui = () => {
            throw new Error("Cursor not stopped");
          };
          Jr.trans = _r, Jr.stop = Jr.continue = Jr.continuePrimaryKey = Jr.advance = () => {
            throw new Error("Cursor not started");
          }, Jr.fail = Ye(Ar), Jr.next = function() {
            let Ai = 1;
            return this.start(() => Ai-- ? this.continue() : this.stop()).then(() => this);
          }, Jr.start = (Ai) => {
            const fi = new Promise((Ci, mi) => {
              Ci = Ye(Ci), Gr.onerror = tn(mi), Jr.fail = mi, Jr.stop = (vi) => {
                Jr.stop = Jr.continue = Jr.continuePrimaryKey = Jr.advance = ui, Ci(vi);
              };
            }), gi = () => {
              if (Gr.result)
                try {
                  Ai();
                } catch (Ci) {
                  Jr.fail(Ci);
                }
              else
                Jr.done = !0, Jr.start = () => {
                  throw new Error("Cursor behind last entry");
                }, Jr.stop();
            };
            return Gr.onsuccess = Ye((Ci) => {
              Gr.onsuccess = gi, gi();
            }), Jr.continue = li, Jr.continuePrimaryKey = Qr, Jr.advance = ei, gi(), fi;
          }, Tr(Jr);
        }, Ar);
      });
    }, count({ query: _r, trans: xr }) {
      const { index: Sr, range: Er } = _r;
      return new Promise((Cr, Tr) => {
        const Ar = xr.objectStore(kr), Ir = Sr.isPrimaryKey ? Ar : Ar.index(Sr.name), Mr = ur(Er), Hr = Mr ? Ir.count(Mr) : Ir.count();
        Hr.onsuccess = Ye((Br) => Cr(Br.target.result)), Hr.onerror = tn(Tr);
      });
    } };
  }(vr)), mr = {};
  return gr.forEach((vr) => mr[vr.name] = vr), { stack: "dbcore", transaction: lr.transaction.bind(lr), table(vr) {
    if (!mr[vr])
      throw new Error(`Table '${vr}' not found`);
    return mr[vr];
  }, MIN_KEY: -1 / 0, MAX_KEY: hn(ar), schema: fr };
}
function vn({ _novip: lr }, ar) {
  const cr = ar.db, ur = function(fr, dr, { IDBKeyRange: gr, indexedDB: mr }, vr) {
    return { dbcore: function(kr, _r) {
      return _r.reduce((xr, { create: Sr }) => ({ ...xr, ...Sr(xr) }), kr);
    }(mn(dr, gr, vr), fr.dbcore) };
  }(lr._middlewares, cr, lr._deps, ar);
  lr.core = ur.dbcore, lr.tables.forEach((fr) => {
    const dr = fr.name;
    lr.core.schema.tables.some((gr) => gr.name === dr) && (fr.core = lr.core.table(dr), lr[dr] instanceof lr.Table && (lr[dr].core = fr.core));
  });
}
function gn({ _novip: lr }, ar, cr, ur) {
  cr.forEach((fr) => {
    const dr = ur[fr];
    ar.forEach((gr) => {
      const mr = d(gr, fr);
      (!mr || "value" in mr && mr.value === void 0) && (gr === lr.Transaction.prototype || gr instanceof lr.Transaction ? l(gr, fr, { get() {
        return this.table(fr);
      }, set(vr) {
        u$1(this, fr, { value: vr, writable: !0, configurable: !0, enumerable: !0 });
      } }) : gr[fr] = new lr.Table(fr, dr));
    });
  });
}
function bn({ _novip: lr }, ar) {
  ar.forEach((cr) => {
    for (let ur in cr)
      cr[ur] instanceof lr.Table && delete cr[ur];
  });
}
function _n(lr, ar) {
  return lr._cfg.version - ar._cfg.version;
}
function wn(lr, ar, cr, ur) {
  const fr = lr._dbSchema, dr = lr._createTransaction("readwrite", lr._storeNames, fr);
  dr.create(cr), dr._completion.catch(ur);
  const gr = dr._reject.bind(dr), mr = Oe.transless || Oe;
  Ze(() => {
    Oe.trans = dr, Oe.transless = mr, ar === 0 ? (t(fr).forEach((vr) => {
      kn(cr, vr, fr[vr].primKey, fr[vr].indexes);
    }), vn(lr, cr), je.follow(() => lr.on.populate.fire(dr)).catch(gr)) : function({ _novip: vr }, yr, kr, _r) {
      const xr = [], Sr = vr._versions;
      let Er = vr._dbSchema = Pn(vr, vr.idbdb, _r), Cr = !1;
      const Tr = Sr.filter((Ir) => Ir._cfg.version >= yr);
      function Ar() {
        return xr.length ? je.resolve(xr.shift()(kr.idbtrans)).then(Ar) : je.resolve();
      }
      return Tr.forEach((Ir) => {
        xr.push(() => {
          const Mr = Er, Hr = Ir._cfg.dbschema;
          Kn(vr, Mr, _r), Kn(vr, Hr, _r), Er = vr._dbSchema = Hr;
          const Br = xn(Mr, Hr);
          Br.add.forEach((Gr) => {
            kn(_r, Gr[0], Gr[1].primKey, Gr[1].indexes);
          }), Br.change.forEach((Gr) => {
            if (Gr.recreate)
              throw new X.Upgrade("Not yet support for changing primary key");
            {
              const Xr = _r.objectStore(Gr.name);
              Gr.add.forEach((Jr) => En(Xr, Jr)), Gr.change.forEach((Jr) => {
                Xr.deleteIndex(Jr.name), En(Xr, Jr);
              }), Gr.del.forEach((Jr) => Xr.deleteIndex(Jr));
            }
          });
          const zr = Ir._cfg.contentUpgrade;
          if (zr && Ir._cfg.version > yr) {
            vn(vr, _r), kr._memoizedTables = {}, Cr = !0;
            let Gr = w(Hr);
            Br.del.forEach((Qr) => {
              Gr[Qr] = Mr[Qr];
            }), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], t(Gr), Gr), kr.schema = Gr;
            const Xr = T(zr);
            let Jr;
            Xr && et();
            const li = je.follow(() => {
              if (Jr = zr(kr), Jr && Xr) {
                var Qr = tt.bind(null, null);
                Jr.then(Qr, Qr);
              }
            });
            return Jr && typeof Jr.then == "function" ? je.resolve(Jr) : li.then(() => Jr);
          }
        }), xr.push((Mr) => {
          (!Cr || !xt) && function(Hr, Br) {
            [].slice.call(Br.db.objectStoreNames).forEach((zr) => Hr[zr] == null && Br.db.deleteObjectStore(zr));
          }(Ir._cfg.dbschema, Mr), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], vr._storeNames, vr._dbSchema), kr.schema = vr._dbSchema;
        });
      }), Ar().then(() => {
        var Ir, Mr;
        Mr = _r, t(Ir = Er).forEach((Hr) => {
          Mr.db.objectStoreNames.contains(Hr) || kn(Mr, Hr, Ir[Hr].primKey, Ir[Hr].indexes);
        });
      });
    }(lr, ar, dr, cr).catch(gr);
  });
}
function xn(lr, ar) {
  const cr = { del: [], add: [], change: [] };
  let ur;
  for (ur in lr)
    ar[ur] || cr.del.push(ur);
  for (ur in ar) {
    const fr = lr[ur], dr = ar[ur];
    if (fr) {
      const gr = { name: ur, def: dr, recreate: !1, del: [], add: [], change: [] };
      if ("" + (fr.primKey.keyPath || "") != "" + (dr.primKey.keyPath || "") || fr.primKey.auto !== dr.primKey.auto && !wt)
        gr.recreate = !0, cr.change.push(gr);
      else {
        const mr = fr.idxByName, vr = dr.idxByName;
        let yr;
        for (yr in mr)
          vr[yr] || gr.del.push(yr);
        for (yr in vr) {
          const kr = mr[yr], _r = vr[yr];
          kr ? kr.src !== _r.src && gr.change.push(_r) : gr.add.push(_r);
        }
        (gr.del.length > 0 || gr.add.length > 0 || gr.change.length > 0) && cr.change.push(gr);
      }
    } else
      cr.add.push([ur, dr]);
  }
  return cr;
}
function kn(lr, ar, cr, ur) {
  const fr = lr.db.createObjectStore(ar, cr.keyPath ? { keyPath: cr.keyPath, autoIncrement: cr.auto } : { autoIncrement: cr.auto });
  return ur.forEach((dr) => En(fr, dr)), fr;
}
function En(lr, ar) {
  lr.createIndex(ar.name, ar.keyPath, { unique: ar.unique, multiEntry: ar.multi });
}
function Pn(lr, ar, cr) {
  const ur = {};
  return p(ar.objectStoreNames, 0).forEach((fr) => {
    const dr = cr.objectStore(fr);
    let gr = dr.keyPath;
    const mr = un(ln(gr), gr || "", !1, !1, !!dr.autoIncrement, gr && typeof gr != "string", !0), vr = [];
    for (let kr = 0; kr < dr.indexNames.length; ++kr) {
      const _r = dr.index(dr.indexNames[kr]);
      gr = _r.keyPath;
      var yr = un(_r.name, gr, !!_r.unique, !!_r.multiEntry, !1, gr && typeof gr != "string", !1);
      vr.push(yr);
    }
    ur[fr] = cn(fr, mr, vr);
  }), ur;
}
function Kn({ _novip: lr }, ar, cr) {
  const ur = cr.db.objectStoreNames;
  for (let fr = 0; fr < ur.length; ++fr) {
    const dr = ur[fr], gr = cr.objectStore(dr);
    lr._hasGetAll = "getAll" in gr;
    for (let mr = 0; mr < gr.indexNames.length; ++mr) {
      const vr = gr.indexNames[mr], yr = gr.index(vr).keyPath, kr = typeof yr == "string" ? yr : "[" + p(yr).join("+") + "]";
      if (ar[dr]) {
        const _r = ar[dr].idxByName[kr];
        _r && (_r.name = vr, delete ar[dr].idxByName[kr], ar[dr].idxByName[vr] = _r);
      }
    }
  }
  typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (lr._hasGetAll = !1);
}
class On {
  _parseStoresSpec(ar, cr) {
    t(ar).forEach((ur) => {
      if (ar[ur] !== null) {
        var fr = ar[ur].split(",").map((gr, mr) => {
          const vr = (gr = gr.trim()).replace(/([&*]|\+\+)/g, ""), yr = /^\[/.test(vr) ? vr.match(/^\[(.*)\]$/)[1].split("+") : vr;
          return un(vr, yr || null, /\&/.test(gr), /\*/.test(gr), /\+\+/.test(gr), n(yr), mr === 0);
        }), dr = fr.shift();
        if (dr.multi)
          throw new X.Schema("Primary key cannot be multi-valued");
        fr.forEach((gr) => {
          if (gr.auto)
            throw new X.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!gr.keyPath)
            throw new X.Schema("Index must have a name and cannot be an empty string");
        }), cr[ur] = cn(ur, dr, fr);
      }
    });
  }
  stores(ar) {
    const cr = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, ar) : ar;
    const ur = cr._versions, fr = {};
    let dr = {};
    return ur.forEach((gr) => {
      r(fr, gr._cfg.storesSource), dr = gr._cfg.dbschema = {}, gr._parseStoresSpec(fr, dr);
    }), cr._dbSchema = dr, bn(cr, [cr._allTables, cr, cr.Transaction.prototype]), gn(cr, [cr._allTables, cr, cr.Transaction.prototype, this._cfg.tables], t(dr), dr), cr._storeNames = t(dr), this;
  }
  upgrade(ar) {
    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee$1, ar), this;
  }
}
function Sn(lr, ar) {
  let cr = lr._dbNamesDB;
  return cr || (cr = lr._dbNamesDB = new Xn(Pt, { addons: [], indexedDB: lr, IDBKeyRange: ar }), cr.version(1).stores({ dbnames: "name" })), cr.table("dbnames");
}
function An(lr) {
  return lr && typeof lr.databases == "function";
}
function Cn(lr) {
  return Ze(function() {
    return Oe.letThrough = !0, lr();
  });
}
function jn() {
  var lr;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ar) {
    var cr = function() {
      return indexedDB.databases().finally(ar);
    };
    lr = setInterval(cr, 100), cr();
  }).finally(function() {
    return clearInterval(lr);
  }) : Promise.resolve();
}
function Dn(lr) {
  const ar = lr._state, { indexedDB: cr } = lr._deps;
  if (ar.isBeingOpened || lr.idbdb)
    return ar.dbReadyPromise.then(() => ar.dbOpenError ? ft(ar.dbOpenError) : lr);
  R && (ar.openCanceller._stackHolder = q()), ar.isBeingOpened = !0, ar.dbOpenError = null, ar.openComplete = !1;
  const ur = ar.openCanceller;
  function fr() {
    if (ar.openCanceller !== ur)
      throw new X.DatabaseClosed("db.open() was cancelled");
  }
  let dr = ar.dbReadyResolve, gr = null, mr = !1;
  return je.race([ur, (typeof navigator == "undefined" ? je.resolve() : jn()).then(() => new je((vr, yr) => {
    if (fr(), !cr)
      throw new X.MissingAPI();
    const kr = lr.name, _r = ar.autoSchema ? cr.open(kr) : cr.open(kr, Math.round(10 * lr.verno));
    if (!_r)
      throw new X.MissingAPI();
    _r.onerror = tn(yr), _r.onblocked = Ye(lr._fireOnBlocked), _r.onupgradeneeded = Ye((xr) => {
      if (gr = _r.transaction, ar.autoSchema && !lr._options.allowEmptyDB) {
        _r.onerror = nn, gr.abort(), _r.result.close();
        const Er = cr.deleteDatabase(kr);
        Er.onsuccess = Er.onerror = Ye(() => {
          yr(new X.NoSuchDatabase(`Database ${kr} doesnt exist`));
        });
      } else {
        gr.onerror = tn(yr);
        var Sr = xr.oldVersion > Math.pow(2, 62) ? 0 : xr.oldVersion;
        mr = Sr < 1, lr._novip.idbdb = _r.result, wn(lr, Sr / 10, gr, yr);
      }
    }, yr), _r.onsuccess = Ye(() => {
      gr = null;
      const xr = lr._novip.idbdb = _r.result, Sr = p(xr.objectStoreNames);
      if (Sr.length > 0)
        try {
          const Cr = xr.transaction((Er = Sr).length === 1 ? Er[0] : Er, "readonly");
          ar.autoSchema ? function({ _novip: Tr }, Ar, Ir) {
            Tr.verno = Ar.version / 10;
            const Mr = Tr._dbSchema = Pn(0, Ar, Ir);
            Tr._storeNames = p(Ar.objectStoreNames, 0), gn(Tr, [Tr._allTables], t(Mr), Mr);
          }(lr, xr, Cr) : (Kn(lr, lr._dbSchema, Cr), function(Tr, Ar) {
            const Ir = xn(Pn(0, Tr.idbdb, Ar), Tr._dbSchema);
            return !(Ir.add.length || Ir.change.some((Mr) => Mr.add.length || Mr.change.length));
          }(lr, Cr) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), vn(lr, Cr);
        } catch (Cr) {
        }
      var Er;
      _t.push(lr), xr.onversionchange = Ye((Cr) => {
        ar.vcFired = !0, lr.on("versionchange").fire(Cr);
      }), xr.onclose = Ye((Cr) => {
        lr.on("close").fire(Cr);
      }), mr && function({ indexedDB: Cr, IDBKeyRange: Tr }, Ar) {
        !An(Cr) && Ar !== Pt && Sn(Cr, Tr).put({ name: Ar }).catch(ee$1);
      }(lr._deps, kr), vr();
    }, yr);
  }))]).then(() => (fr(), ar.onReadyBeingFired = [], je.resolve(Cn(() => lr.on.ready.fire(lr.vip))).then(function vr() {
    if (ar.onReadyBeingFired.length > 0) {
      let yr = ar.onReadyBeingFired.reduce(ue, ee$1);
      return ar.onReadyBeingFired = [], je.resolve(Cn(() => yr(lr.vip))).then(vr);
    }
  }))).finally(() => {
    ar.onReadyBeingFired = null, ar.isBeingOpened = !1;
  }).then(() => lr).catch((vr) => {
    ar.dbOpenError = vr;
    try {
      gr && gr.abort();
    } catch (yr) {
    }
    return ur === ar.openCanceller && lr._close(), ft(vr);
  }).finally(() => {
    ar.openComplete = !0, dr();
  });
}
function In(lr) {
  var ar = (dr) => lr.next(dr), cr = fr(ar), ur = fr((dr) => lr.throw(dr));
  function fr(dr) {
    return (gr) => {
      var mr = dr(gr), vr = mr.value;
      return mr.done ? vr : vr && typeof vr.then == "function" ? vr.then(cr, ur) : n(vr) ? Promise.all(vr).then(cr, ur) : cr(vr);
    };
  }
  return fr(ar)();
}
function Bn(lr, ar, cr) {
  var ur = arguments.length;
  if (ur < 2)
    throw new X.InvalidArgument("Too few arguments");
  for (var fr = new Array(ur - 1); --ur; )
    fr[ur - 1] = arguments[ur];
  return cr = fr.pop(), [lr, k(fr), cr];
}
function Tn(lr, ar, cr, ur, fr) {
  return je.resolve().then(() => {
    const dr = Oe.transless || Oe, gr = lr._createTransaction(ar, cr, lr._dbSchema, ur), mr = { trans: gr, transless: dr };
    if (ur)
      gr.idbtrans = ur.idbtrans;
    else
      try {
        gr.create(), lr._state.PR1398_maxLoop = 3;
      } catch (_r) {
        return _r.name === H.InvalidState && lr.isOpen() && --lr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), lr._close(), lr.open().then(() => Tn(lr, ar, cr, null, fr))) : ft(_r);
      }
    const vr = T(fr);
    let yr;
    vr && et();
    const kr = je.follow(() => {
      if (yr = fr.call(gr, gr), yr)
        if (vr) {
          var _r = tt.bind(null, null);
          yr.then(_r, _r);
        } else
          typeof yr.next == "function" && typeof yr.throw == "function" && (yr = In(yr));
    }, mr);
    return (yr && typeof yr.then == "function" ? je.resolve(yr).then((_r) => gr.active ? _r : ft(new X.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : kr.then(() => yr)).then((_r) => (ur && gr._resolve(), gr._completion.then(() => _r))).catch((_r) => (gr._reject(_r), ft(_r)));
  });
}
function Rn(lr, ar, cr) {
  const ur = n(lr) ? lr.slice() : [lr];
  for (let fr = 0; fr < cr; ++fr)
    ur.push(ar);
  return ur;
}
const Fn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(lr) {
  return { ...lr, table(ar) {
    const cr = lr.table(ar), { schema: ur } = cr, fr = {}, dr = [];
    function gr(kr, _r, xr) {
      const Sr = yn(kr), Er = fr[Sr] = fr[Sr] || [], Cr = kr == null ? 0 : typeof kr == "string" ? 1 : kr.length, Tr = _r > 0, Ar = { ...xr, isVirtual: Tr, keyTail: _r, keyLength: Cr, extractKey: dn(kr), unique: !Tr && xr.unique };
      return Er.push(Ar), Ar.isPrimaryKey || dr.push(Ar), Cr > 1 && gr(Cr === 2 ? kr[0] : kr.slice(0, Cr - 1), _r + 1, xr), Er.sort((Ir, Mr) => Ir.keyTail - Mr.keyTail), Ar;
    }
    const mr = gr(ur.primaryKey.keyPath, 0, ur.primaryKey);
    fr[":id"] = [mr];
    for (const kr of ur.indexes)
      gr(kr.keyPath, 0, kr);
    function vr(kr) {
      const _r = kr.query.index;
      return _r.isVirtual ? { ...kr, query: { index: _r, range: (xr = kr.query.range, Sr = _r.keyTail, { type: xr.type === 1 ? 2 : xr.type, lower: Rn(xr.lower, xr.lowerOpen ? lr.MAX_KEY : lr.MIN_KEY, Sr), lowerOpen: !0, upper: Rn(xr.upper, xr.upperOpen ? lr.MIN_KEY : lr.MAX_KEY, Sr), upperOpen: !0 }) } } : kr;
      var xr, Sr;
    }
    return { ...cr, schema: { ...ur, primaryKey: mr, indexes: dr, getIndexByKeyPath: function(kr) {
      const _r = fr[yn(kr)];
      return _r && _r[0];
    } }, count: (kr) => cr.count(vr(kr)), query: (kr) => cr.query(vr(kr)), openCursor(kr) {
      const { keyTail: _r, isVirtual: xr, keyLength: Sr } = kr.query.index;
      return xr ? cr.openCursor(vr(kr)).then((Er) => Er && function(Cr) {
        return Object.create(Cr, { continue: { value: function(Ar) {
          Ar != null ? Cr.continue(Rn(Ar, kr.reverse ? lr.MAX_KEY : lr.MIN_KEY, _r)) : kr.unique ? Cr.continue(Cr.key.slice(0, Sr).concat(kr.reverse ? lr.MIN_KEY : lr.MAX_KEY, _r)) : Cr.continue();
        } }, continuePrimaryKey: { value(Ar, Ir) {
          Cr.continuePrimaryKey(Rn(Ar, lr.MAX_KEY, _r), Ir);
        } }, primaryKey: { get: () => Cr.primaryKey }, key: { get() {
          const Ar = Cr.key;
          return Sr === 1 ? Ar[0] : Ar.slice(0, Sr);
        } }, value: { get: () => Cr.value } });
      }(Er)) : cr.openCursor(kr);
    } };
  } };
} };
function Mn(lr, ar, cr, ur) {
  return cr = cr || {}, ur = ur || "", t(lr).forEach((fr) => {
    if (o(ar, fr)) {
      var dr = lr[fr], gr = ar[fr];
      if (typeof dr == "object" && typeof gr == "object" && dr && gr) {
        const mr = C(dr);
        mr !== C(gr) ? cr[ur + fr] = ar[fr] : mr === "Object" ? Mn(dr, gr, cr, ur + fr + ".") : dr !== gr && (cr[ur + fr] = ar[fr]);
      } else
        dr !== gr && (cr[ur + fr] = ar[fr]);
    } else
      cr[ur + fr] = void 0;
  }), t(ar).forEach((fr) => {
    o(lr, fr) || (cr[ur + fr] = ar[fr]);
  }), cr;
}
const Nn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (lr) => ({ ...lr, table(ar) {
  const cr = lr.table(ar), { primaryKey: ur } = cr.schema;
  return { ...cr, mutate(dr) {
    const gr = Oe.trans, { deleting: mr, creating: vr, updating: yr } = gr.table(ar).hook;
    switch (dr.type) {
      case "add":
        if (vr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => kr(dr), !0);
      case "put":
        if (vr.fire === ee$1 && yr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => kr(dr), !0);
      case "delete":
        if (mr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => kr(dr), !0);
      case "deleteRange":
        if (mr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => function(xr) {
          return _r(xr.trans, xr.range, 1e4);
        }(dr), !0);
    }
    return cr.mutate(dr);
    function kr(xr) {
      const Sr = Oe.trans, Er = xr.keys || function(Cr, Tr) {
        return Tr.type === "delete" ? Tr.keys : Tr.keys || Tr.values.map(Cr.extractKey);
      }(ur, xr);
      if (!Er)
        throw new Error("Keys missing");
      return (xr = xr.type === "add" || xr.type === "put" ? { ...xr, keys: Er } : { ...xr }).type !== "delete" && (xr.values = [...xr.values]), xr.keys && (xr.keys = [...xr.keys]), function(Cr, Tr, Ar) {
        return Tr.type === "add" ? Promise.resolve([]) : Cr.getMany({ trans: Tr.trans, keys: Ar, cache: "immutable" });
      }(cr, xr, Er).then((Cr) => {
        const Tr = Er.map((Ar, Ir) => {
          const Mr = Cr[Ir], Hr = { onerror: null, onsuccess: null };
          if (xr.type === "delete")
            mr.fire.call(Hr, Ar, Mr, Sr);
          else if (xr.type === "add" || Mr === void 0) {
            const Br = vr.fire.call(Hr, Ar, xr.values[Ir], Sr);
            Ar == null && Br != null && (Ar = Br, xr.keys[Ir] = Ar, ur.outbound || _(xr.values[Ir], ur.keyPath, Ar));
          } else {
            const Br = Mn(Mr, xr.values[Ir]), zr = yr.fire.call(Hr, Br, Ar, Mr, Sr);
            if (zr) {
              const Gr = xr.values[Ir];
              Object.keys(zr).forEach((Xr) => {
                o(Gr, Xr) ? Gr[Xr] = zr[Xr] : _(Gr, Xr, zr[Xr]);
              });
            }
          }
          return Hr;
        });
        return cr.mutate(xr).then(({ failures: Ar, results: Ir, numFailures: Mr, lastResult: Hr }) => {
          for (let Br = 0; Br < Er.length; ++Br) {
            const zr = Ir ? Ir[Br] : Er[Br], Gr = Tr[Br];
            zr == null ? Gr.onerror && Gr.onerror(Ar[Br]) : Gr.onsuccess && Gr.onsuccess(xr.type === "put" && Cr[Br] ? xr.values[Br] : zr);
          }
          return { failures: Ar, results: Ir, numFailures: Mr, lastResult: Hr };
        }).catch((Ar) => (Tr.forEach((Ir) => Ir.onerror && Ir.onerror(Ar)), Promise.reject(Ar)));
      });
    }
    function _r(xr, Sr, Er) {
      return cr.query({ trans: xr, values: !1, query: { index: ur, range: Sr }, limit: Er }).then(({ result: Cr }) => kr({ type: "delete", keys: Cr, trans: xr }).then((Tr) => Tr.numFailures > 0 ? Promise.reject(Tr.failures[0]) : Cr.length < Er ? { failures: [], numFailures: 0, lastResult: void 0 } : _r(xr, { ...Sr, lower: Cr[Cr.length - 1], lowerOpen: !0 }, Er)));
    }
  } };
} }) };
function qn(lr, ar, cr) {
  try {
    if (!ar || ar.keys.length < lr.length)
      return null;
    const ur = [];
    for (let fr = 0, dr = 0; fr < ar.keys.length && dr < lr.length; ++fr)
      $t(ar.keys[fr], lr[dr]) === 0 && (ur.push(cr ? O(ar.values[fr]) : ar.values[fr]), ++dr);
    return ur.length === lr.length ? ur : null;
  } catch (ur) {
    return null;
  }
}
const $n = { stack: "dbcore", level: -1, create: (lr) => ({ table: (ar) => {
  const cr = lr.table(ar);
  return { ...cr, getMany: (ur) => {
    if (!ur.cache)
      return cr.getMany(ur);
    const fr = qn(ur.keys, ur.trans._cache, ur.cache === "clone");
    return fr ? je.resolve(fr) : cr.getMany(ur).then((dr) => (ur.trans._cache = { keys: ur.keys, values: ur.cache === "clone" ? O(dr) : dr }, dr));
  }, mutate: (ur) => (ur.type !== "add" && (ur.trans._cache = null), cr.mutate(ur)) };
} }) };
function Un(lr) {
  return !("from" in lr);
}
const Ln = function(lr, ar) {
  if (!this) {
    const cr = new Ln();
    return lr && "d" in lr && r(cr, lr), cr;
  }
  r(this, arguments.length ? { d: 1, from: lr, to: arguments.length > 1 ? ar : lr } : { d: 0 });
};
function Vn(lr, ar, cr) {
  const ur = $t(ar, cr);
  if (isNaN(ur))
    return;
  if (ur > 0)
    throw RangeError();
  if (Un(lr))
    return r(lr, { from: ar, to: cr, d: 1 });
  const fr = lr.l, dr = lr.r;
  if ($t(cr, lr.from) < 0)
    return fr ? Vn(fr, ar, cr) : lr.l = { from: ar, to: cr, d: 1, l: null, r: null }, Gn(lr);
  if ($t(ar, lr.to) > 0)
    return dr ? Vn(dr, ar, cr) : lr.r = { from: ar, to: cr, d: 1, l: null, r: null }, Gn(lr);
  $t(ar, lr.from) < 0 && (lr.from = ar, lr.l = null, lr.d = dr ? dr.d + 1 : 1), $t(cr, lr.to) > 0 && (lr.to = cr, lr.r = null, lr.d = lr.l ? lr.l.d + 1 : 1);
  const gr = !lr.r;
  fr && !lr.l && Wn(lr, fr), dr && gr && Wn(lr, dr);
}
function Wn(lr, ar) {
  Un(ar) || function cr(ur, { from: fr, to: dr, l: gr, r: mr }) {
    Vn(ur, fr, dr), gr && cr(ur, gr), mr && cr(ur, mr);
  }(lr, ar);
}
function Yn(lr, ar) {
  const cr = zn(ar);
  let ur = cr.next();
  if (ur.done)
    return !1;
  let fr = ur.value;
  const dr = zn(lr);
  let gr = dr.next(fr.from), mr = gr.value;
  for (; !ur.done && !gr.done; ) {
    if ($t(mr.from, fr.to) <= 0 && $t(mr.to, fr.from) >= 0)
      return !0;
    $t(fr.from, mr.from) < 0 ? fr = (ur = cr.next(mr.from)).value : mr = (gr = dr.next(fr.from)).value;
  }
  return !1;
}
function zn(lr) {
  let ar = Un(lr) ? null : { s: 0, n: lr };
  return { next(cr) {
    const ur = arguments.length > 0;
    for (; ar; )
      switch (ar.s) {
        case 0:
          if (ar.s = 1, ur)
            for (; ar.n.l && $t(cr, ar.n.from) < 0; )
              ar = { up: ar, n: ar.n.l, s: 1 };
          else
            for (; ar.n.l; )
              ar = { up: ar, n: ar.n.l, s: 1 };
        case 1:
          if (ar.s = 2, !ur || $t(cr, ar.n.to) <= 0)
            return { value: ar.n, done: !1 };
        case 2:
          if (ar.n.r) {
            ar.s = 3, ar = { up: ar, n: ar.n.r, s: 0 };
            continue;
          }
        case 3:
          ar = ar.up;
      }
    return { done: !0 };
  } };
}
function Gn(lr) {
  var ar, cr;
  const ur = (((ar = lr.r) === null || ar === void 0 ? void 0 : ar.d) || 0) - (((cr = lr.l) === null || cr === void 0 ? void 0 : cr.d) || 0), fr = ur > 1 ? "r" : ur < -1 ? "l" : "";
  if (fr) {
    const dr = fr === "r" ? "l" : "r", gr = { ...lr }, mr = lr[fr];
    lr.from = mr.from, lr.to = mr.to, lr[fr] = mr[fr], gr[fr] = mr[dr], lr[dr] = gr, gr.d = Hn(gr);
  }
  lr.d = Hn(lr);
}
function Hn({ r: lr, l: ar }) {
  return (lr ? ar ? Math.max(lr.d, ar.d) : lr.d : ar ? ar.d : 0) + 1;
}
a(Ln.prototype, { add(lr) {
  return Wn(this, lr), this;
}, addKey(lr) {
  return Vn(this, lr, lr), this;
}, addKeys(lr) {
  return lr.forEach((ar) => Vn(this, ar, ar)), this;
}, [j]() {
  return zn(this);
} });
const Qn = { stack: "dbcore", level: 0, create: (lr) => {
  const ar = lr.schema.name, cr = new Ln(lr.MIN_KEY, lr.MAX_KEY);
  return { ...lr, table: (ur) => {
    const fr = lr.table(ur), { schema: dr } = fr, { primaryKey: gr } = dr, { extractKey: mr, outbound: vr } = gr, yr = { ...fr, mutate: (xr) => {
      const Sr = xr.trans, Er = Sr.mutatedParts || (Sr.mutatedParts = {}), Cr = (zr) => {
        const Gr = `idb://${ar}/${ur}/${zr}`;
        return Er[Gr] || (Er[Gr] = new Ln());
      }, Tr = Cr(""), Ar = Cr(":dels"), { type: Ir } = xr;
      let [Mr, Hr] = xr.type === "deleteRange" ? [xr.range] : xr.type === "delete" ? [xr.keys] : xr.values.length < 50 ? [[], xr.values] : [];
      const Br = xr.trans._cache;
      return fr.mutate(xr).then((zr) => {
        if (n(Mr)) {
          Ir !== "delete" && (Mr = zr.results), Tr.addKeys(Mr);
          const Gr = qn(Mr, Br);
          Gr || Ir === "add" || Ar.addKeys(Mr), (Gr || Hr) && function(Xr, Jr, li, Qr) {
            function ei(ui) {
              const Ai = Xr(ui.name || "");
              function fi(Ci) {
                return Ci != null ? ui.extractKey(Ci) : null;
              }
              const gi = (Ci) => ui.multiEntry && n(Ci) ? Ci.forEach((mi) => Ai.addKey(mi)) : Ai.addKey(Ci);
              (li || Qr).forEach((Ci, mi) => {
                const vi = li && fi(li[mi]), Ri = Qr && fi(Qr[mi]);
                $t(vi, Ri) !== 0 && (vi != null && gi(vi), Ri != null && gi(Ri));
              });
            }
            Jr.indexes.forEach(ei);
          }(Cr, dr, Gr, Hr);
        } else if (Mr) {
          const Gr = { from: Mr.lower, to: Mr.upper };
          Ar.add(Gr), Tr.add(Gr);
        } else
          Tr.add(cr), Ar.add(cr), dr.indexes.forEach((Gr) => Cr(Gr.name).add(cr));
        return zr;
      });
    } }, kr = ({ query: { index: xr, range: Sr } }) => {
      var Er, Cr;
      return [xr, new Ln((Er = Sr.lower) !== null && Er !== void 0 ? Er : lr.MIN_KEY, (Cr = Sr.upper) !== null && Cr !== void 0 ? Cr : lr.MAX_KEY)];
    }, _r = { get: (xr) => [gr, new Ln(xr.key)], getMany: (xr) => [gr, new Ln().addKeys(xr.keys)], count: kr, query: kr, openCursor: kr };
    return t(_r).forEach((xr) => {
      yr[xr] = function(Sr) {
        const { subscr: Er } = Oe;
        if (Er) {
          const Cr = (Hr) => {
            const Br = `idb://${ar}/${ur}/${Hr}`;
            return Er[Br] || (Er[Br] = new Ln());
          }, Tr = Cr(""), Ar = Cr(":dels"), [Ir, Mr] = _r[xr](Sr);
          if (Cr(Ir.name || "").add(Mr), !Ir.isPrimaryKey) {
            if (xr !== "count") {
              const Hr = xr === "query" && vr && Sr.values && fr.query({ ...Sr, values: !1 });
              return fr[xr].apply(this, arguments).then((Br) => {
                if (xr === "query") {
                  if (vr && Sr.values)
                    return Hr.then(({ result: Gr }) => (Tr.addKeys(Gr), Br));
                  const zr = Sr.values ? Br.result.map(mr) : Br.result;
                  Sr.values ? Tr.addKeys(zr) : Ar.addKeys(zr);
                } else if (xr === "openCursor") {
                  const zr = Br, Gr = Sr.values;
                  return zr && Object.create(zr, { key: { get: () => (Ar.addKey(zr.primaryKey), zr.key) }, primaryKey: { get() {
                    const Xr = zr.primaryKey;
                    return Ar.addKey(Xr), Xr;
                  } }, value: { get: () => (Gr && Tr.addKey(zr.primaryKey), zr.value) } });
                }
                return Br;
              });
            }
            Ar.add(cr);
          }
        }
        return fr[xr].apply(this, arguments);
      };
    }), yr;
  } };
} };
class Xn {
  constructor(ar, cr) {
    this._middlewares = {}, this.verno = 0;
    const ur = Xn.dependencies;
    this._options = cr = { addons: Xn.addons, autoOpen: !0, indexedDB: ur.indexedDB, IDBKeyRange: ur.IDBKeyRange, ...cr }, this._deps = { indexedDB: cr.indexedDB, IDBKeyRange: cr.IDBKeyRange };
    const { addons: fr } = cr;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const dr = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: ee$1, dbReadyPromise: null, cancelOpen: ee$1, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var gr;
    dr.dbReadyPromise = new je((mr) => {
      dr.dbReadyResolve = mr;
    }), dr.openCanceller = new je((mr, vr) => {
      dr.cancelOpen = vr;
    }), this._state = dr, this.name = ar, this.on = Dt(this, "populate", "blocked", "versionchange", "close", { ready: [ue, ee$1] }), this.on.ready.subscribe = y(this.on.ready.subscribe, (mr) => (vr, yr) => {
      Xn.vip(() => {
        const kr = this._state;
        if (kr.openComplete)
          kr.dbOpenError || je.resolve().then(vr), yr && mr(vr);
        else if (kr.onReadyBeingFired)
          kr.onReadyBeingFired.push(vr), yr && mr(vr);
        else {
          mr(vr);
          const _r = this;
          yr || mr(function xr() {
            _r.on.ready.unsubscribe(vr), _r.on.ready.unsubscribe(xr);
          });
        }
      });
    }), this.Collection = (gr = this, It(Vt.prototype, function(mr, vr) {
      this.db = gr;
      let yr = At, kr = null;
      if (vr)
        try {
          yr = vr();
        } catch (Er) {
          kr = Er;
        }
      const _r = mr._ctx, xr = _r.table, Sr = xr.hook.reading.fire;
      this._ctx = { table: xr, index: _r.index, isPrimKey: !_r.index || xr.schema.primKey.keyPath && _r.index === xr.schema.primKey.name, range: yr, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: kr, or: _r.or, valueMapper: Sr !== te ? Sr : null };
    })), this.Table = function(mr) {
      return It(jt.prototype, function(vr, yr, kr) {
        this.db = mr, this._tx = kr, this.name = vr, this.schema = yr, this.hook = mr._allTables[vr] ? mr._allTables[vr].hook : Dt(null, { creating: [se, ee$1], reading: [ne$1, te], updating: [oe, ee$1], deleting: [ie, ee$1] });
      });
    }(this), this.Transaction = function(mr) {
      return It(an.prototype, function(vr, yr, kr, _r, xr) {
        this.db = mr, this.mode = vr, this.storeNames = yr, this.schema = kr, this.chromeTransactionDurability = _r, this.idbtrans = null, this.on = Dt(this, "complete", "error", "abort"), this.parent = xr || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je((Sr, Er) => {
          this._resolve = Sr, this._reject = Er;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (Sr) => {
          var Er = this.active;
          return this.active = !1, this.on.error.fire(Sr), this.parent ? this.parent._reject(Sr) : Er && this.idbtrans && this.idbtrans.abort(), ft(Sr);
        });
      });
    }(this), this.Version = function(mr) {
      return It(On.prototype, function(vr) {
        this.db = mr, this._cfg = { version: vr, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(mr) {
      return It(en.prototype, function(vr, yr, kr) {
        this.db = mr, this._ctx = { table: vr, index: yr === ":id" ? null : yr, or: kr };
        const _r = mr._deps.indexedDB;
        if (!_r)
          throw new X.MissingAPI();
        this._cmp = this._ascending = _r.cmp.bind(_r), this._descending = (xr, Sr) => _r.cmp(Sr, xr), this._max = (xr, Sr) => _r.cmp(xr, Sr) > 0 ? xr : Sr, this._min = (xr, Sr) => _r.cmp(xr, Sr) < 0 ? xr : Sr, this._IDBKeyRange = mr._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (mr) => {
      mr.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (mr) => {
      !mr.newVersion || mr.newVersion < mr.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${mr.oldVersion / 10}`);
    }), this._maxKey = hn(cr.IDBKeyRange), this._createTransaction = (mr, vr, yr, kr) => new this.Transaction(mr, vr, yr, this._options.chromeTransactionDurability, kr), this._fireOnBlocked = (mr) => {
      this.on("blocked").fire(mr), _t.filter((vr) => vr.name === this.name && vr !== this && !vr._state.vcFired).map((vr) => vr.on("versionchange").fire(mr));
    }, this.use(Fn), this.use(Nn), this.use(Qn), this.use($n), this.vip = Object.create(this, { _vip: { value: !0 } }), fr.forEach((mr) => mr(this));
  }
  version(ar) {
    if (isNaN(ar) || ar < 0.1)
      throw new X.Type("Given version is not a positive number");
    if (ar = Math.round(10 * ar) / 10, this.idbdb || this._state.isBeingOpened)
      throw new X.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, ar);
    const cr = this._versions;
    var ur = cr.filter((fr) => fr._cfg.version === ar)[0];
    return ur || (ur = new this.Version(ar), cr.push(ur), cr.sort(_n), ur.stores({}), this._state.autoSchema = !1, ur);
  }
  _whenReady(ar) {
    return this.idbdb && (this._state.openComplete || Oe.letThrough || this._vip) ? ar() : new je((cr, ur) => {
      if (this._state.openComplete)
        return ur(new X.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void ur(new X.DatabaseClosed());
        this.open().catch(ee$1);
      }
      this._state.dbReadyPromise.then(cr, ur);
    }).then(ar);
  }
  use({ stack: ar, create: cr, level: ur, name: fr }) {
    fr && this.unuse({ stack: ar, name: fr });
    const dr = this._middlewares[ar] || (this._middlewares[ar] = []);
    return dr.push({ stack: ar, create: cr, level: ur == null ? 10 : ur, name: fr }), dr.sort((gr, mr) => gr.level - mr.level), this;
  }
  unuse({ stack: ar, name: cr, create: ur }) {
    return ar && this._middlewares[ar] && (this._middlewares[ar] = this._middlewares[ar].filter((fr) => ur ? fr.create !== ur : !!cr && fr.name !== cr)), this;
  }
  open() {
    return Dn(this);
  }
  _close() {
    const ar = this._state, cr = _t.indexOf(this);
    if (cr >= 0 && _t.splice(cr, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch (ur) {
      }
      this._novip.idbdb = null;
    }
    ar.dbReadyPromise = new je((ur) => {
      ar.dbReadyResolve = ur;
    }), ar.openCanceller = new je((ur, fr) => {
      ar.cancelOpen = fr;
    });
  }
  close() {
    this._close();
    const ar = this._state;
    this._options.autoOpen = !1, ar.dbOpenError = new X.DatabaseClosed(), ar.isBeingOpened && ar.cancelOpen(ar.dbOpenError);
  }
  delete() {
    const ar = arguments.length > 0, cr = this._state;
    return new je((ur, fr) => {
      const dr = () => {
        this.close();
        var gr = this._deps.indexedDB.deleteDatabase(this.name);
        gr.onsuccess = Ye(() => {
          (function({ indexedDB: mr, IDBKeyRange: vr }, yr) {
            !An(mr) && yr !== Pt && Sn(mr, vr).delete(yr).catch(ee$1);
          })(this._deps, this.name), ur();
        }), gr.onerror = tn(fr), gr.onblocked = this._fireOnBlocked;
      };
      if (ar)
        throw new X.InvalidArgument("Arguments not allowed in db.delete()");
      cr.isBeingOpened ? cr.dbReadyPromise.then(dr) : dr();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const ar = this._state.dbOpenError;
    return ar && ar.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return t(this._allTables).map((ar) => this._allTables[ar]);
  }
  transaction() {
    const ar = Bn.apply(this, arguments);
    return this._transaction.apply(this, ar);
  }
  _transaction(ar, cr, ur) {
    let fr = Oe.trans;
    fr && fr.db === this && ar.indexOf("!") === -1 || (fr = null);
    const dr = ar.indexOf("?") !== -1;
    let gr, mr;
    ar = ar.replace("!", "").replace("?", "");
    try {
      if (mr = cr.map((yr) => {
        var kr = yr instanceof this.Table ? yr.name : yr;
        if (typeof kr != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return kr;
      }), ar == "r" || ar === Kt)
        gr = Kt;
      else {
        if (ar != "rw" && ar != Ot)
          throw new X.InvalidArgument("Invalid transaction mode: " + ar);
        gr = Ot;
      }
      if (fr) {
        if (fr.mode === Kt && gr === Ot) {
          if (!dr)
            throw new X.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          fr = null;
        }
        fr && mr.forEach((yr) => {
          if (fr && fr.storeNames.indexOf(yr) === -1) {
            if (!dr)
              throw new X.SubTransaction("Table " + yr + " not included in parent transaction.");
            fr = null;
          }
        }), dr && fr && !fr.active && (fr = null);
      }
    } catch (yr) {
      return fr ? fr._promise(null, (kr, _r) => {
        _r(yr);
      }) : ft(yr);
    }
    const vr = Tn.bind(null, this, gr, mr, fr, ur);
    return fr ? fr._promise(gr, vr, "lock") : Oe.trans ? at(Oe.transless, () => this._whenReady(vr)) : this._whenReady(vr);
  }
  table(ar) {
    if (!o(this._allTables, ar))
      throw new X.InvalidTable(`Table ${ar} does not exist`);
    return this._allTables[ar];
  }
}
const Jn = typeof Symbol != "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Zn {
  constructor(ar) {
    this._subscribe = ar;
  }
  subscribe(ar, cr, ur) {
    return this._subscribe(ar && typeof ar != "function" ? ar : { next: ar, error: cr, complete: ur });
  }
  [Jn]() {
    return this;
  }
}
function er(lr, ar) {
  return t(ar).forEach((cr) => {
    Wn(lr[cr] || (lr[cr] = new Ln()), ar[cr]);
  }), lr;
}
function tr(lr) {
  let ar, cr = !1;
  const ur = new Zn((fr) => {
    const dr = T(lr);
    let gr = !1, mr = {}, vr = {};
    const yr = { get closed() {
      return gr;
    }, unsubscribe: () => {
      gr = !0, on$1.storagemutated.unsubscribe(Sr);
    } };
    fr.start && fr.start(yr);
    let kr = !1, _r = !1;
    function xr() {
      return t(vr).some((Cr) => mr[Cr] && Yn(mr[Cr], vr[Cr]));
    }
    const Sr = (Cr) => {
      er(mr, Cr), xr() && Er();
    }, Er = () => {
      if (kr || gr)
        return;
      mr = {};
      const Cr = {}, Tr = function(Ar) {
        dr && et();
        const Ir = () => Ze(lr, { subscr: Ar, trans: null }), Mr = Oe.trans ? at(Oe.transless, Ir) : Ir();
        return dr && Mr.then(tt, tt), Mr;
      }(Cr);
      _r || (on$1(rn, Sr), _r = !0), kr = !0, Promise.resolve(Tr).then((Ar) => {
        cr = !0, ar = Ar, kr = !1, gr || (xr() ? Er() : (mr = {}, vr = Cr, fr.next && fr.next(Ar)));
      }, (Ar) => {
        kr = !1, cr = !1, fr.error && fr.error(Ar), yr.unsubscribe();
      });
    };
    return Er(), yr;
  });
  return ur.hasValue = () => cr, ur.getValue = () => ar, ur;
}
let nr;
try {
  nr = { indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB, IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange };
} catch (lr) {
  nr = { indexedDB: null, IDBKeyRange: null };
}
const rr = Xn;
function sr(lr) {
  let ar = ir;
  try {
    ir = !0, on$1.storagemutated.fire(lr);
  } finally {
    ir = ar;
  }
}
a(rr, { ...Z, delete: (lr) => new rr(lr, { addons: [] }).delete(), exists: (lr) => new rr(lr, { addons: [] }).open().then((ar) => (ar.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(lr) {
  try {
    return function({ indexedDB: ar, IDBKeyRange: cr }) {
      return An(ar) ? Promise.resolve(ar.databases()).then((ur) => ur.map((fr) => fr.name).filter((fr) => fr !== Pt)) : Sn(ar, cr).toCollection().primaryKeys();
    }(rr.dependencies).then(lr);
  } catch (ar) {
    return ft(new X.MissingAPI());
  }
}, defineClass: () => function(lr) {
  r(this, lr);
}, ignoreTransaction: (lr) => Oe.trans ? at(Oe.transless, lr) : lr(), vip: Cn, async: function(lr) {
  return function() {
    try {
      var ar = In(lr.apply(this, arguments));
      return ar && typeof ar.then == "function" ? ar : je.resolve(ar);
    } catch (cr) {
      return ft(cr);
    }
  };
}, spawn: function(lr, ar, cr) {
  try {
    var ur = In(lr.apply(cr, ar || []));
    return ur && typeof ur.then == "function" ? ur : je.resolve(ur);
  } catch (fr) {
    return ft(fr);
  }
}, currentTransaction: { get: () => Oe.trans || null }, waitFor: function(lr, ar) {
  const cr = je.resolve(typeof lr == "function" ? rr.ignoreTransaction(lr) : lr).timeout(ar || 6e4);
  return Oe.trans ? Oe.trans.waitFor(cr) : cr;
}, Promise: je, debug: { get: () => R, set: (lr) => {
  F(lr, lr === "dexie" ? () => !0 : Et);
} }, derive: c, extend: r, props: a, override: y, Events: Dt, on: on$1, liveQuery: tr, extendObservabilitySet: er, getByKeyPath: b, setByKeyPath: _, delByKeyPath: function(lr, ar) {
  typeof ar == "string" ? _(lr, ar, void 0) : "length" in ar && [].map.call(ar, function(cr) {
    _(lr, cr, void 0);
  });
}, shallowClone: w, deepClone: O, getObjectDiff: Mn, cmp: $t, asap: v, minKey: vt, addons: [], connections: _t, errnames: H, dependencies: nr, semVer: yt, version: yt.split(".").map((lr) => parseInt(lr)).reduce((lr, ar, cr) => lr + ar / Math.pow(10, 2 * cr)) }), rr.maxKey = hn(rr.dependencies.IDBKeyRange), typeof dispatchEvent != "undefined" && typeof addEventListener != "undefined" && (on$1(rn, (lr) => {
  if (!ir) {
    let ar;
    wt ? (ar = document.createEvent("CustomEvent"), ar.initCustomEvent(sn, !0, !0, lr)) : ar = new CustomEvent(sn, { detail: lr }), ir = !0, dispatchEvent(ar), ir = !1;
  }
}), addEventListener(sn, ({ detail: lr }) => {
  ir || sr(lr);
}));
let ir = !1;
if (typeof BroadcastChannel != "undefined") {
  const lr = new BroadcastChannel(sn);
  typeof lr.unref == "function" && lr.unref(), on$1(rn, (ar) => {
    ir || lr.postMessage(ar);
  }), lr.onmessage = (ar) => {
    ar.data && sr(ar.data);
  };
} else if (typeof self != "undefined" && typeof navigator != "undefined") {
  on$1(rn, (ar) => {
    try {
      ir || (typeof localStorage != "undefined" && localStorage.setItem(sn, JSON.stringify({ trig: Math.random(), changedParts: ar })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((cr) => cr.postMessage({ type: sn, changedParts: ar })));
    } catch (cr) {
    }
  }), typeof addEventListener != "undefined" && addEventListener("storage", (ar) => {
    if (ar.key === sn) {
      const cr = JSON.parse(ar.newValue);
      cr && sr(cr.changedParts);
    }
  });
  const lr = self.document && navigator.serviceWorker;
  lr && lr.addEventListener("message", function({ data: ar }) {
    ar && ar.type === sn && sr(ar.changedParts);
  });
}
je.rejectionMapper = function(lr, ar) {
  if (!lr || lr instanceof W || lr instanceof TypeError || lr instanceof SyntaxError || !lr.name || !J[lr.name])
    return lr;
  var cr = new J[lr.name](ar || lr.message, lr);
  return "stack" in lr && l(cr, "stack", { get: function() {
    return this.inner.stack;
  } }), cr;
}, F(R, Et);
var Database = class extends Xn {
  constructor(ar) {
    super(ar);
    ji(this, "users");
    ji(this, "events");
    ji(this, "eventTags");
    this.version(4).stores({
      users: "&pubkey, profile, createdAt",
      events: "&id, pubkey, content, kind, createdAt, relay, [kind+pubkey]",
      eventTags: "id, tagValue, tag, value, eventId"
    });
  }
}, db;
function createDatabase(lr) {
  db = new Database(lr);
}
var NDKCacheAdapterDexie = class {
  constructor(lr = {}) {
    ji(this, "debug");
    ji(this, "expirationTime");
    ji(this, "locking");
    ji(this, "profiles");
    ji(this, "dirtyProfiles", /* @__PURE__ */ new Set());
    createDatabase(lr.dbName || "ndk"), this.debug = lr.debug || _debug("ndk:dexie-adapter"), this.locking = !0, this.expirationTime = lr.expirationTime || 3600, lr.profileCacheSize !== "disabled" && (this.profiles = new dist$9.LRUCache({
      maxSize: lr.profileCacheSize || 1e5
    }), setInterval(() => {
      this.dumpProfiles();
    }, 1e3 * 10));
  }
  async query(lr) {
    Promise.allSettled(
      lr.filters.map((ar) => this.processFilter(ar, lr))
    );
  }
  async fetchProfile(lr) {
    if (!this.profiles)
      return null;
    let ar = this.profiles.get(lr);
    if (!ar) {
      const cr = await db.users.get({ pubkey: lr });
      cr && (ar = cr.profile, this.profiles.set(lr, ar));
    }
    return ar;
  }
  saveProfile(lr, ar) {
    this.profiles && (this.profiles.set(lr, ar), this.dirtyProfiles.add(lr));
  }
  async processFilter(lr, ar) {
    const cr = { ...lr };
    delete cr.limit;
    const ur = Object.keys(cr || {}).sort();
    try {
      await this.byKindAndAuthor(ur, lr, ar) || await this.byAuthors(ur, lr, ar) || await this.byKinds(ur, lr, ar) || await this.byIdsQuery(ur, lr, ar) || await this.byNip33Query(ur, lr, ar) || await this.byTagsAndOptionallyKinds(ur, lr, ar);
    } catch (fr) {
      console.error(fr);
    }
  }
  async setEvent(lr, ar, cr) {
    if (lr.kind === 0) {
      if (!this.profiles)
        return;
      const ur = profileFromEvent(lr);
      this.profiles.set(lr.pubkey, ur);
    } else {
      let ur = !0;
      if (lr.isParamReplaceable()) {
        const fr = `${lr.kind}:${lr.pubkey}:${lr.tagId()}`, dr = await db.events.where({ id: fr }).first();
        dr && lr.created_at && dr.createdAt > lr.created_at && (ur = !1);
      }
      ur && (db.events.put({
        id: lr.tagId(),
        pubkey: lr.pubkey,
        content: lr.content,
        kind: lr.kind,
        createdAt: lr.created_at,
        relay: cr == null ? void 0 : cr.url,
        event: JSON.stringify(lr.rawEvent())
      }), lr.kind !== 3 && lr.tags.forEach((fr) => {
        fr[0].length === 1 && db.eventTags.put({
          id: `${lr.id}:${fr[0]}:${fr[1]}`,
          eventId: lr.id,
          tag: fr[0],
          value: fr[1],
          tagValue: fr[0] + fr[1]
        });
      }));
    }
  }
  /**
   * Searches by authors
   */
  async byAuthors(lr, ar, cr) {
    const ur = ["authors"], fr = lr.length === ur.length && ur.every((gr) => lr.includes(gr));
    let dr = !1;
    if (fr && ar.authors)
      for (const gr of ar.authors) {
        const mr = await db.events.where({ pubkey: gr }).toArray();
        for (const vr of mr) {
          let yr;
          try {
            yr = JSON.parse(vr.event);
          } catch (xr) {
            console.log("failed to parse event", xr);
            continue;
          }
          const kr = new NDKEvent(void 0, yr), _r = vr.relay ? new NDKRelay(vr.relay) : void 0;
          cr.eventReceived(kr, _r, !0), dr = !0;
        }
      }
    return dr;
  }
  /**
   * Searches by kinds
   */
  async byKinds(lr, ar, cr) {
    const ur = ["kinds"], fr = lr.length === ur.length && ur.every((gr) => lr.includes(gr));
    let dr = !1;
    if (fr && ar.kinds)
      for (const gr of ar.kinds) {
        const mr = await db.events.where({ kind: gr }).toArray();
        for (const vr of mr) {
          let yr;
          try {
            yr = JSON.parse(vr.event);
          } catch (xr) {
            console.log("failed to parse event", xr);
            continue;
          }
          const kr = new NDKEvent(void 0, yr), _r = vr.relay ? new NDKRelay(vr.relay) : void 0;
          cr.eventReceived(kr, _r, !0), dr = !0;
        }
      }
    return dr;
  }
  /**
   * Searches by ids
   */
  async byIdsQuery(lr, ar, cr) {
    const ur = ["ids"];
    if (lr.length === ur.length && ur.every((dr) => lr.includes(dr)) && ar.ids) {
      for (const dr of ar.ids) {
        const gr = await db.events.where({ id: dr }).first();
        if (!gr)
          continue;
        let mr;
        try {
          mr = JSON.parse(gr.event);
        } catch (kr) {
          console.log("failed to parse event", kr);
          continue;
        }
        const vr = new NDKEvent(void 0, mr), yr = gr.relay ? new NDKRelay(gr.relay) : void 0;
        cr.eventReceived(vr, yr, !0);
      }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by NIP-33
   */
  async byNip33Query(lr, ar, cr) {
    const ur = ["#d", "authors", "kinds"];
    if (lr.length === ur.length && ur.every((dr) => lr.includes(dr)) && ar.kinds && ar.authors) {
      for (const dr of ar.kinds)
        if (dr >= 3e4 && dr < 4e4)
          for (const mr of ar.authors)
            for (const vr of ar["#d"]) {
              const yr = `${dr}:${mr}:${vr}`, kr = await db.events.where({ id: yr }).first();
              if (!kr)
                continue;
              let _r;
              try {
                _r = JSON.parse(kr.event);
              } catch (Er) {
                console.log("failed to parse event", Er);
                continue;
              }
              const xr = new NDKEvent(void 0, _r), Sr = kr.relay ? new NDKRelay(kr.relay) : void 0;
              cr.eventReceived(xr, Sr, !0);
            }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by kind & author
   */
  async byKindAndAuthor(lr, ar, cr) {
    const ur = ["authors", "kinds"], fr = lr.length === ur.length && ur.every((gr) => lr.includes(gr));
    let dr = !1;
    if (!fr)
      return !1;
    if (ar.kinds && ar.authors)
      for (const gr of ar.kinds)
        for (const mr of ar.authors) {
          const vr = await db.events.where({ kind: gr, pubkey: mr }).toArray();
          for (const yr of vr) {
            let kr;
            try {
              kr = JSON.parse(yr.event);
            } catch (Sr) {
              console.log("failed to parse event", Sr);
              continue;
            }
            const _r = new NDKEvent(void 0, kr), xr = yr.relay ? new NDKRelay(yr.relay) : void 0;
            cr.eventReceived(_r, xr, !0), dr = !0;
          }
        }
    return dr;
  }
  /**
   * Searches by tags and optionally filters by tags
   */
  async byTagsAndOptionallyKinds(lr, ar, cr) {
    for (const dr of lr) {
      const gr = dr === "kinds", mr = dr.startsWith("#") && dr.length === 2;
      if (!gr && !mr)
        return !1;
    }
    const ur = await this.filterByTag(lr, ar), fr = ar.kinds;
    for (const dr of ur)
      fr != null && fr.includes(dr.kind) && cr.eventReceived(dr, void 0, !0);
    return !1;
  }
  async filterByTag(lr, ar) {
    const cr = [];
    for (const ur of lr) {
      if (ur.length !== 2)
        continue;
      const fr = ur.slice(1), dr = [];
      for (const [gr, mr] of Object.entries(ar))
        gr === ur && dr.push(mr);
      for (const gr of dr) {
        const mr = await db.eventTags.where({ tagValue: fr + gr }).toArray();
        if (!mr.length)
          continue;
        const vr = mr.map((kr) => kr.eventId), yr = await db.events.where("id").anyOf(vr).toArray();
        for (const kr of yr) {
          let _r;
          try {
            if (_r = JSON.parse(kr.event), !matchFilter(ar, _r))
              continue;
          } catch (Er) {
            console.log("failed to parse event", Er);
            continue;
          }
          const xr = new NDKEvent(void 0, _r), Sr = kr.relay ? new NDKRelay(kr.relay) : void 0;
          xr.relay = Sr, cr.push(xr);
        }
      }
    }
    return cr;
  }
  async dumpProfiles() {
    const lr = [];
    if (this.profiles) {
      for (const ar of this.dirtyProfiles) {
        const cr = this.profiles.get(ar);
        cr && lr.push({
          pubkey: ar,
          profile: cr,
          createdAt: Date.now()
        });
      }
      lr.length && await db.users.bulkPut(lr), this.dirtyProfiles.clear();
    }
  }
};
let cacheAdapter;
const defaulRelaysUrls = [
  "wss://purplepag.es",
  "wss://relay.nostr.band",
  "wss://nos.lol",
  "wss://offchain.pub/",
  "wss://nostr-pub.wellorder.net",
  "wss://nostr.mutinywallet.com "
];
window && (cacheAdapter = new NDKCacheAdapterDexie({
  dbName: "walletScrutiny",
  expirationTime: 3600 * 24 * 2
}));
const ndk = new src_default({
  explicitRelayUrls: defaulRelaysUrls,
  cacheAdapter
}), ndkStore = writable(ndk), profileImageUrl = "https://api.dicebear.com/5.x/identicon/svg?seed=", kindNotes = 1, kindOpinion = 30023, kindDelete = 5, kindReaction = 7, uploadUrl = "https://void.cat", DEFAULT_RELAY_URLS = {
  read: defaulRelaysUrls,
  write: defaulRelaysUrls
}, opinionHeaderSeparator = `
<!--HEADER END-->
`, opinionFooterSeparator = `
<!--FOOTER START-->



`, opinionHeaderRegex = new RegExp(`^[\\s\\S]*${opinionHeaderSeparator}`), opinionFooterRegex = new RegExp(`${opinionFooterSeparator}[\\s\\S]*$`);
var dist$8 = {};
Object.defineProperty(dist$8, "__esModule", { value: !0 });
dist$8.bech32m = bech32$1 = dist$8.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let lr = 0; lr < ALPHABET.length; lr++) {
  const ar = ALPHABET.charAt(lr);
  ALPHABET_MAP[ar] = lr;
}
function polymodStep(lr) {
  const ar = lr >> 25;
  return (lr & 33554431) << 5 ^ -(ar >> 0 & 1) & 996825010 ^ -(ar >> 1 & 1) & 642813549 ^ -(ar >> 2 & 1) & 513874426 ^ -(ar >> 3 & 1) & 1027748829 ^ -(ar >> 4 & 1) & 705979059;
}
function prefixChk(lr) {
  let ar = 1;
  for (let cr = 0; cr < lr.length; ++cr) {
    const ur = lr.charCodeAt(cr);
    if (ur < 33 || ur > 126)
      return "Invalid prefix (" + lr + ")";
    ar = polymodStep(ar) ^ ur >> 5;
  }
  ar = polymodStep(ar);
  for (let cr = 0; cr < lr.length; ++cr) {
    const ur = lr.charCodeAt(cr);
    ar = polymodStep(ar) ^ ur & 31;
  }
  return ar;
}
function convert(lr, ar, cr, ur) {
  let fr = 0, dr = 0;
  const gr = (1 << cr) - 1, mr = [];
  for (let vr = 0; vr < lr.length; ++vr)
    for (fr = fr << ar | lr[vr], dr += ar; dr >= cr; )
      dr -= cr, mr.push(fr >> dr & gr);
  if (ur)
    dr > 0 && mr.push(fr << cr - dr & gr);
  else {
    if (dr >= ar)
      return "Excess padding";
    if (fr << cr - dr & gr)
      return "Non-zero padding";
  }
  return mr;
}
function toWords(lr) {
  return convert(lr, 8, 5, !0);
}
function fromWordsUnsafe(lr) {
  const ar = convert(lr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
}
function fromWords(lr) {
  const ar = convert(lr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
  throw new Error(ar);
}
function getLibraryFromEncoding(lr) {
  let ar;
  lr === "bech32" ? ar = 1 : ar = 734539939;
  function cr(gr, mr, vr) {
    if (vr = vr || 90, gr.length + 7 + mr.length > vr)
      throw new TypeError("Exceeds length limit");
    gr = gr.toLowerCase();
    let yr = prefixChk(gr);
    if (typeof yr == "string")
      throw new Error(yr);
    let kr = gr + "1";
    for (let _r = 0; _r < mr.length; ++_r) {
      const xr = mr[_r];
      if (xr >> 5)
        throw new Error("Non 5-bit word");
      yr = polymodStep(yr) ^ xr, kr += ALPHABET.charAt(xr);
    }
    for (let _r = 0; _r < 6; ++_r)
      yr = polymodStep(yr);
    yr ^= ar;
    for (let _r = 0; _r < 6; ++_r) {
      const xr = yr >> (5 - _r) * 5 & 31;
      kr += ALPHABET.charAt(xr);
    }
    return kr;
  }
  function ur(gr, mr) {
    if (mr = mr || 90, gr.length < 8)
      return gr + " too short";
    if (gr.length > mr)
      return "Exceeds length limit";
    const vr = gr.toLowerCase(), yr = gr.toUpperCase();
    if (gr !== vr && gr !== yr)
      return "Mixed-case string " + gr;
    gr = vr;
    const kr = gr.lastIndexOf("1");
    if (kr === -1)
      return "No separator character for " + gr;
    if (kr === 0)
      return "Missing prefix for " + gr;
    const _r = gr.slice(0, kr), xr = gr.slice(kr + 1);
    if (xr.length < 6)
      return "Data too short";
    let Sr = prefixChk(_r);
    if (typeof Sr == "string")
      return Sr;
    const Er = [];
    for (let Cr = 0; Cr < xr.length; ++Cr) {
      const Tr = xr.charAt(Cr), Ar = ALPHABET_MAP[Tr];
      if (Ar === void 0)
        return "Unknown character " + Tr;
      Sr = polymodStep(Sr) ^ Ar, !(Cr + 6 >= xr.length) && Er.push(Ar);
    }
    return Sr !== ar ? "Invalid checksum for " + gr : { prefix: _r, words: Er };
  }
  function fr(gr, mr) {
    const vr = ur(gr, mr);
    if (typeof vr == "object")
      return vr;
  }
  function dr(gr, mr) {
    const vr = ur(gr, mr);
    if (typeof vr == "object")
      return vr;
    throw new Error(vr);
  }
  return {
    decodeUnsafe: fr,
    decode: dr,
    encode: cr,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
var bech32$1 = dist$8.bech32 = getLibraryFromEncoding("bech32");
dist$8.bech32m = getLibraryFromEncoding("bech32m");
function hexToBytes$2(lr) {
  const ar = new Uint8Array(lr.length / 2);
  for (let cr = 0; cr < ar.length; cr++)
    ar[cr] = parseInt(lr.substring(cr * 2, cr * 2 + 2), 16);
  return ar;
}
function convertNostrPubKeyToBech32(lr, ar = "npub") {
  const cr = hexToBytes$2(lr);
  return bech32$1.encode(ar, bech32$1.toWords(cr));
}
async function fetchUserProfile(lr) {
  try {
    if (window) {
      const ar = await db.users.where({ pubkey: lr }).first();
      if (ar)
        return ar.profile;
      {
        const ur = get_store_value(ndkStore).getUser({ pubkey: lr });
        return await ur.fetchProfile({
          closeOnEose: !0,
          groupable: !1,
          groupableDelay: 200
        }), ur.profile;
      }
    } else
      return {};
  } catch (ar) {
    throw console.error(ar), ar;
  }
}
function logout() {
  ndkUser.set(null), isNip05Valid.set({
    isNip05Valid: null,
    Nip05address: void 0,
    UserNpub: void 0,
    Vanity: void 0,
    UserIdentifier: void 0
  }), activeProfile.set(null), localStore.update(() => ({
    lastUserLogged: void 0,
    pk: void 0
  }));
}
async function NDKlogin() {
  try {
    const lr = get_store_value(ndkStore), ar = new NDKNip07Signer();
    lr.signer = ar, ndkStore.set(lr);
    const cr = await ar.user(), ur = lr.getUser({
      pubkey: cr.pubkey,
      npub: cr.npub
    });
    return ndkUser.set(ur), localStore.set({ lastUserLogged: cr.npub, pk: void 0 }), ur;
  } catch (lr) {
    return;
  }
}
async function privkeyLogin(lr) {
  if (lr)
    try {
      const ar = get_store_value(ndkStore), cr = new NDKPrivateKeySigner(lr);
      ar.signer = cr, ndkStore.set(ar);
      const ur = await cr.user(), fr = ar.getUser({
        pubkey: ur.pubkey,
        npub: ur.npub
      });
      return ndkUser.set(fr), localStore.set({ lastUserLogged: ur.npub, pk: lr }), fr;
    } catch (ar) {
      return;
    }
}
function calculateRelativeTime(lr) {
  const ar = /* @__PURE__ */ new Date(), cr = new Date(lr * 1e3), ur = Math.floor((ar.valueOf() - cr.valueOf()) / 1e3);
  return ur < 60 ? `${ur} seconds ago` : ur < 3600 ? `${Math.floor(ur / 60)} minutes ago` : ur < 86400 ? `${Math.floor(ur / 3600)} hours ago` : `${Math.floor(ur / 86400)} days ago`;
}
function number$1(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bytes$1(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash$1(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(lr.outputLen), number$1(lr.blockLen);
}
function exists$1(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(lr, ar) {
  bytes$1(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const crypto$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$2 = (lr) => lr instanceof Uint8Array, createView$1 = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr$1 = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes$1(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes$2(lr)), !u8a$2(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes$2(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$2(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
let Hash$1 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(lr) {
  const ar = (ur) => lr().update(toBytes$1(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes$1(lr = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues == "function")
    return crypto$2.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
let SHA2$1 = class extends Hash$1 {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$1(this.buffer);
  }
  update(ar) {
    exists$1(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes$1(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView$1(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$1(this), output$1(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64$1(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView$1(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
};
const Chi$2 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj$1 = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class extends SHA2$1 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W$1[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W$1[_r - 15], Sr = SHA256_W$1[_r - 2], Er = rotr$1(xr, 7) ^ rotr$1(xr, 18) ^ xr >>> 3, Cr = rotr$1(Sr, 17) ^ rotr$1(Sr, 19) ^ Sr >>> 10;
      SHA256_W$1[_r] = Cr + SHA256_W$1[_r - 7] + Er + SHA256_W$1[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr$1(mr, 6) ^ rotr$1(mr, 11) ^ rotr$1(mr, 25), Sr = kr + xr + Chi$2(mr, vr, yr) + SHA256_K$1[_r] + SHA256_W$1[_r] | 0, Cr = (rotr$1(ur, 2) ^ rotr$1(ur, 13) ^ rotr$1(ur, 22)) + Maj$1(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a$1 = (lr) => lr instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$1(lr) {
  if (!u8a$1(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes$1[lr[cr]];
  return ar;
}
function numberToHexUnpadded(lr) {
  const ar = lr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  return BigInt(lr === "" ? "0" : `0x${lr}`);
}
function hexToBytes$1(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function bytesToNumberBE(lr) {
  return hexToNumber(bytesToHex$1(lr));
}
function bytesToNumberLE(lr) {
  if (!u8a$1(lr))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(lr).reverse()));
}
function numberToBytesBE(lr, ar) {
  return hexToBytes$1(lr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE(lr, ar) {
  return numberToBytesBE(lr, ar).reverse();
}
function numberToVarBytesBE(lr) {
  return hexToBytes$1(numberToHexUnpadded(lr));
}
function ensureBytes(lr, ar, cr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$1(ar);
    } catch (dr) {
      throw new Error(`${lr} must be valid hex string, got "${ar}". Cause: ${dr}`);
    }
  else if (u8a$1(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${lr} must be hex string or Uint8Array`);
  const fr = ur.length;
  if (typeof cr == "number" && fr !== cr)
    throw new Error(`${lr} expected ${cr} bytes, got ${fr}`);
  return ur;
}
function concatBytes$1(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a$1(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
function equalBytes(lr, ar) {
  if (lr.length !== ar.length)
    return !1;
  for (let cr = 0; cr < lr.length; cr++)
    if (lr[cr] !== ar[cr])
      return !1;
  return !0;
}
function utf8ToBytes$1(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function bitLen(lr) {
  let ar;
  for (ar = 0; lr > _0n$4; lr >>= _1n$4, ar += 1)
    ;
  return ar;
}
function bitGet(lr, ar) {
  return lr >> BigInt(ar) & _1n$4;
}
const bitSet = (lr, ar, cr) => lr | (cr ? _1n$4 : _0n$4) << BigInt(ar), bitMask = (lr) => (_2n$2 << BigInt(lr - 1)) - _1n$4, u8n = (lr) => new Uint8Array(lr), u8fr = (lr) => Uint8Array.from(lr);
function createHmacDrbg(lr, ar, cr) {
  if (typeof lr != "number" || lr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof cr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n(lr), fr = u8n(lr), dr = 0;
  const gr = () => {
    ur.fill(1), fr.fill(0), dr = 0;
  }, mr = (..._r) => cr(fr, ur, ..._r), vr = (_r = u8n()) => {
    fr = mr(u8fr([0]), _r), ur = mr(), _r.length !== 0 && (fr = mr(u8fr([1]), _r), ur = mr());
  }, yr = () => {
    if (dr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let _r = 0;
    const xr = [];
    for (; _r < ar; ) {
      ur = mr();
      const Sr = ur.slice();
      xr.push(Sr), _r += ur.length;
    }
    return concatBytes$1(...xr);
  };
  return (_r, xr) => {
    gr(), vr(_r);
    let Sr;
    for (; !(Sr = xr(yr())); )
      vr();
    return gr(), Sr;
  };
}
const validatorFns = {
  bigint: (lr) => typeof lr == "bigint",
  function: (lr) => typeof lr == "function",
  boolean: (lr) => typeof lr == "boolean",
  string: (lr) => typeof lr == "string",
  stringOrUint8Array: (lr) => typeof lr == "string" || lr instanceof Uint8Array,
  isSafeInteger: (lr) => Number.isSafeInteger(lr),
  array: (lr) => Array.isArray(lr),
  field: (lr, ar) => ar.Fp.isValid(lr),
  hash: (lr) => typeof lr == "function" && Number.isSafeInteger(lr.outputLen)
};
function validateObject(lr, ar, cr = {}) {
  const ur = (fr, dr, gr) => {
    const mr = validatorFns[dr];
    if (typeof mr != "function")
      throw new Error(`Invalid validator "${dr}", expected function`);
    const vr = lr[fr];
    if (!(gr && vr === void 0) && !mr(vr, lr))
      throw new Error(`Invalid param ${String(fr)}=${vr} (${typeof vr}), expected ${dr}`);
  };
  for (const [fr, dr] of Object.entries(ar))
    ur(fr, dr, !1);
  for (const [fr, dr] of Object.entries(cr))
    ur(fr, dr, !0);
  return lr;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes: concatBytes$1,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes: hexToBytes$1,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(lr, ar) {
  const cr = lr % ar;
  return cr >= _0n$3 ? cr : ar + cr;
}
function pow(lr, ar, cr) {
  if (cr <= _0n$3 || ar < _0n$3)
    throw new Error("Expected power/modulo > 0");
  if (cr === _1n$3)
    return _0n$3;
  let ur = _1n$3;
  for (; ar > _0n$3; )
    ar & _1n$3 && (ur = ur * lr % cr), lr = lr * lr % cr, ar >>= _1n$3;
  return ur;
}
function pow2(lr, ar, cr) {
  let ur = lr;
  for (; ar-- > _0n$3; )
    ur *= ur, ur %= cr;
  return ur;
}
function invert(lr, ar) {
  if (lr === _0n$3 || ar <= _0n$3)
    throw new Error(`invert: expected positive integers, got n=${lr} mod=${ar}`);
  let cr = mod(lr, ar), ur = ar, fr = _0n$3, dr = _1n$3;
  for (; cr !== _0n$3; ) {
    const mr = ur / cr, vr = ur % cr, yr = fr - dr * mr;
    ur = cr, cr = vr, fr = dr, dr = yr;
  }
  if (ur !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(fr, ar);
}
function tonelliShanks(lr) {
  const ar = (lr - _1n$3) / _2n$1;
  let cr, ur, fr;
  for (cr = lr - _1n$3, ur = 0; cr % _2n$1 === _0n$3; cr /= _2n$1, ur++)
    ;
  for (fr = _2n$1; fr < lr && pow(fr, ar, lr) !== lr - _1n$3; fr++)
    ;
  if (ur === 1) {
    const gr = (lr + _1n$3) / _4n;
    return function(vr, yr) {
      const kr = vr.pow(yr, gr);
      if (!vr.eql(vr.sqr(kr), yr))
        throw new Error("Cannot find square root");
      return kr;
    };
  }
  const dr = (cr + _1n$3) / _2n$1;
  return function(mr, vr) {
    if (mr.pow(vr, ar) === mr.neg(mr.ONE))
      throw new Error("Cannot find square root");
    let yr = ur, kr = mr.pow(mr.mul(mr.ONE, fr), cr), _r = mr.pow(vr, dr), xr = mr.pow(vr, cr);
    for (; !mr.eql(xr, mr.ONE); ) {
      if (mr.eql(xr, mr.ZERO))
        return mr.ZERO;
      let Sr = 1;
      for (let Cr = mr.sqr(xr); Sr < yr && !mr.eql(Cr, mr.ONE); Sr++)
        Cr = mr.sqr(Cr);
      const Er = mr.pow(kr, _1n$3 << BigInt(yr - Sr - 1));
      kr = mr.sqr(Er), _r = mr.mul(_r, Er), xr = mr.mul(xr, kr), yr = Sr;
    }
    return _r;
  };
}
function FpSqrt(lr) {
  if (lr % _4n === _3n$1) {
    const ar = (lr + _1n$3) / _4n;
    return function(ur, fr) {
      const dr = ur.pow(fr, ar);
      if (!ur.eql(ur.sqr(dr), fr))
        throw new Error("Cannot find square root");
      return dr;
    };
  }
  if (lr % _8n === _5n) {
    const ar = (lr - _5n) / _8n;
    return function(ur, fr) {
      const dr = ur.mul(fr, _2n$1), gr = ur.pow(dr, ar), mr = ur.mul(fr, gr), vr = ur.mul(ur.mul(mr, _2n$1), gr), yr = ur.mul(mr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(yr), fr))
        throw new Error("Cannot find square root");
      return yr;
    };
  }
  return tonelliShanks(lr);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(lr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, cr = FIELD_FIELDS.reduce((ur, fr) => (ur[fr] = "function", ur), ar);
  return validateObject(lr, cr);
}
function FpPow(lr, ar, cr) {
  if (cr < _0n$3)
    throw new Error("Expected power > 0");
  if (cr === _0n$3)
    return lr.ONE;
  if (cr === _1n$3)
    return ar;
  let ur = lr.ONE, fr = ar;
  for (; cr > _0n$3; )
    cr & _1n$3 && (ur = lr.mul(ur, fr)), fr = lr.sqr(fr), cr >>= _1n$3;
  return ur;
}
function FpInvertBatch(lr, ar) {
  const cr = new Array(ar.length), ur = ar.reduce((dr, gr, mr) => lr.is0(gr) ? dr : (cr[mr] = dr, lr.mul(dr, gr)), lr.ONE), fr = lr.inv(ur);
  return ar.reduceRight((dr, gr, mr) => lr.is0(gr) ? dr : (cr[mr] = lr.mul(dr, cr[mr]), lr.mul(dr, gr)), fr), cr;
}
function nLength(lr, ar) {
  const cr = ar !== void 0 ? ar : lr.toString(2).length, ur = Math.ceil(cr / 8);
  return { nBitLength: cr, nByteLength: ur };
}
function Field(lr, ar, cr = !1, ur = {}) {
  if (lr <= _0n$3)
    throw new Error(`Expected Field ORDER > 0, got ${lr}`);
  const { nBitLength: fr, nByteLength: dr } = nLength(lr, ar);
  if (dr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const gr = FpSqrt(lr), mr = Object.freeze({
    ORDER: lr,
    BITS: fr,
    BYTES: dr,
    MASK: bitMask(fr),
    ZERO: _0n$3,
    ONE: _1n$3,
    create: (vr) => mod(vr, lr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$3 <= vr && vr < lr;
    },
    is0: (vr) => vr === _0n$3,
    isOdd: (vr) => (vr & _1n$3) === _1n$3,
    neg: (vr) => mod(-vr, lr),
    eql: (vr, yr) => vr === yr,
    sqr: (vr) => mod(vr * vr, lr),
    add: (vr, yr) => mod(vr + yr, lr),
    sub: (vr, yr) => mod(vr - yr, lr),
    mul: (vr, yr) => mod(vr * yr, lr),
    pow: (vr, yr) => FpPow(mr, vr, yr),
    div: (vr, yr) => mod(vr * invert(yr, lr), lr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, yr) => vr + yr,
    subN: (vr, yr) => vr - yr,
    mulN: (vr, yr) => vr * yr,
    inv: (vr) => invert(vr, lr),
    sqrt: ur.sqrt || ((vr) => gr(mr, vr)),
    invertBatch: (vr) => FpInvertBatch(mr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, yr, kr) => kr ? yr : vr,
    toBytes: (vr) => cr ? numberToBytesLE(vr, dr) : numberToBytesBE(vr, dr),
    fromBytes: (vr) => {
      if (vr.length !== dr)
        throw new Error(`Fp.fromBytes: expected ${dr}, got ${vr.length}`);
      return cr ? bytesToNumberLE(vr) : bytesToNumberBE(vr);
    }
  });
  return Object.freeze(mr);
}
function getFieldBytesLength(lr) {
  if (typeof lr != "bigint")
    throw new Error("field order must be bigint");
  const ar = lr.toString(2).length;
  return Math.ceil(ar / 8);
}
function getMinHashLength(lr) {
  const ar = getFieldBytesLength(lr);
  return ar + Math.ceil(ar / 2);
}
function mapHashToField(lr, ar, cr = !1) {
  const ur = lr.length, fr = getFieldBytesLength(ar), dr = getMinHashLength(ar);
  if (ur < 16 || ur < dr || ur > 1024)
    throw new Error(`expected ${dr}-1024 bytes of input, got ${ur}`);
  const gr = cr ? bytesToNumberBE(lr) : bytesToNumberLE(lr), mr = mod(gr, ar - _1n$3) + _1n$3;
  return cr ? numberToBytesLE(mr, fr) : numberToBytesBE(mr, fr);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(lr, ar) {
  const cr = (fr, dr) => {
    const gr = dr.negate();
    return fr ? gr : dr;
  }, ur = (fr) => {
    const dr = Math.ceil(ar / fr) + 1, gr = 2 ** (fr - 1);
    return { windows: dr, windowSize: gr };
  };
  return {
    constTimeNegate: cr,
    // non-const time multiplication ladder
    unsafeLadder(fr, dr) {
      let gr = lr.ZERO, mr = fr;
      for (; dr > _0n$2; )
        dr & _1n$2 && (gr = gr.add(mr)), mr = mr.double(), dr >>= _1n$2;
      return gr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(fr, dr) {
      const { windows: gr, windowSize: mr } = ur(dr), vr = [];
      let yr = fr, kr = yr;
      for (let _r = 0; _r < gr; _r++) {
        kr = yr, vr.push(kr);
        for (let xr = 1; xr < mr; xr++)
          kr = kr.add(yr), vr.push(kr);
        yr = kr.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(fr, dr, gr) {
      const { windows: mr, windowSize: vr } = ur(fr);
      let yr = lr.ZERO, kr = lr.BASE;
      const _r = BigInt(2 ** fr - 1), xr = 2 ** fr, Sr = BigInt(fr);
      for (let Er = 0; Er < mr; Er++) {
        const Cr = Er * vr;
        let Tr = Number(gr & _r);
        gr >>= Sr, Tr > vr && (Tr -= xr, gr += _1n$2);
        const Ar = Cr, Ir = Cr + Math.abs(Tr) - 1, Mr = Er % 2 !== 0, Hr = Tr < 0;
        Tr === 0 ? kr = kr.add(cr(Mr, dr[Ar])) : yr = yr.add(cr(Hr, dr[Ir]));
      }
      return { p: yr, f: kr };
    },
    wNAFCached(fr, dr, gr, mr) {
      const vr = fr._WINDOW_SIZE || 1;
      let yr = dr.get(fr);
      return yr || (yr = this.precomputeWindow(fr, vr), vr !== 1 && dr.set(fr, mr(yr))), this.wNAF(vr, yr, gr);
    }
  };
}
function validateBasic(lr) {
  return validateField(lr.Fp), validateObject(lr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(lr.n, lr.nBitLength),
    ...lr,
    p: lr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(lr) {
  const ar = validateBasic(lr);
  validateObject(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: cr, Fp: ur, a: fr } = ar;
  if (cr) {
    if (!ur.eql(fr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof cr != "object" || typeof cr.beta != "bigint" || typeof cr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(lr) {
    const { Err: ar } = DER;
    if (lr.length < 2 || lr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const cr = lr[1], ur = lr.subarray(2, cr + 2);
    if (!cr || ur.length !== cr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(ur), l: lr.subarray(cr + 2) };
  },
  toSig(lr) {
    const { Err: ar } = DER, cr = typeof lr == "string" ? h2b(lr) : lr;
    if (!(cr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = cr.length;
    if (ur < 2 || cr[0] != 48)
      throw new ar("Invalid signature tag");
    if (cr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: fr, l: dr } = DER._parseInt(cr.subarray(2)), { d: gr, l: mr } = DER._parseInt(dr);
    if (mr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: fr, s: gr };
  },
  hexFromSig(lr) {
    const ar = (yr) => Number.parseInt(yr[0], 16) & 8 ? "00" + yr : yr, cr = (yr) => {
      const kr = yr.toString(16);
      return kr.length & 1 ? `0${kr}` : kr;
    }, ur = ar(cr(lr.s)), fr = ar(cr(lr.r)), dr = ur.length / 2, gr = fr.length / 2, mr = cr(dr), vr = cr(gr);
    return `30${cr(gr + dr + 4)}02${vr}${fr}02${mr}${ur}`;
  }
}, _0n$1 = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(lr) {
  const ar = validatePointOpts(lr), { Fp: cr } = ar, ur = ar.toBytes || ((Er, Cr, Tr) => {
    const Ar = Cr.toAffine();
    return concatBytes$1(Uint8Array.from([4]), cr.toBytes(Ar.x), cr.toBytes(Ar.y));
  }), fr = ar.fromBytes || ((Er) => {
    const Cr = Er.subarray(1), Tr = cr.fromBytes(Cr.subarray(0, cr.BYTES)), Ar = cr.fromBytes(Cr.subarray(cr.BYTES, 2 * cr.BYTES));
    return { x: Tr, y: Ar };
  });
  function dr(Er) {
    const { a: Cr, b: Tr } = ar, Ar = cr.sqr(Er), Ir = cr.mul(Ar, Er);
    return cr.add(cr.add(Ir, cr.mul(Er, Cr)), Tr);
  }
  if (!cr.eql(cr.sqr(ar.Gy), dr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function gr(Er) {
    return typeof Er == "bigint" && _0n$1 < Er && Er < ar.n;
  }
  function mr(Er) {
    if (!gr(Er))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(Er) {
    const { allowedPrivateKeyLengths: Cr, nByteLength: Tr, wrapPrivateKey: Ar, n: Ir } = ar;
    if (Cr && typeof Er != "bigint") {
      if (Er instanceof Uint8Array && (Er = bytesToHex$1(Er)), typeof Er != "string" || !Cr.includes(Er.length))
        throw new Error("Invalid key");
      Er = Er.padStart(Tr * 2, "0");
    }
    let Mr;
    try {
      Mr = typeof Er == "bigint" ? Er : bytesToNumberBE(ensureBytes("private key", Er, Tr));
    } catch (Hr) {
      throw new Error(`private key must be ${Tr} bytes, hex or bigint, not ${typeof Er}`);
    }
    return Ar && (Mr = mod(Mr, Ir)), mr(Mr), Mr;
  }
  const yr = /* @__PURE__ */ new Map();
  function kr(Er) {
    if (!(Er instanceof _r))
      throw new Error("ProjectivePoint expected");
  }
  class _r {
    constructor(Cr, Tr, Ar) {
      if (this.px = Cr, this.py = Tr, this.pz = Ar, Cr == null || !cr.isValid(Cr))
        throw new Error("x required");
      if (Tr == null || !cr.isValid(Tr))
        throw new Error("y required");
      if (Ar == null || !cr.isValid(Ar))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Cr) {
      const { x: Tr, y: Ar } = Cr || {};
      if (!Cr || !cr.isValid(Tr) || !cr.isValid(Ar))
        throw new Error("invalid affine point");
      if (Cr instanceof _r)
        throw new Error("projective point not allowed");
      const Ir = (Mr) => cr.eql(Mr, cr.ZERO);
      return Ir(Tr) && Ir(Ar) ? _r.ZERO : new _r(Tr, Ar, cr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Cr) {
      const Tr = cr.invertBatch(Cr.map((Ar) => Ar.pz));
      return Cr.map((Ar, Ir) => Ar.toAffine(Tr[Ir])).map(_r.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Cr) {
      const Tr = _r.fromAffine(fr(ensureBytes("pointHex", Cr)));
      return Tr.assertValidity(), Tr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Cr) {
      return _r.BASE.multiply(vr(Cr));
    }
    // "Private method", don't use it directly
    _setWindowSize(Cr) {
      this._WINDOW_SIZE = Cr, yr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint && !cr.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Cr, y: Tr } = this.toAffine();
      if (!cr.isValid(Cr) || !cr.isValid(Tr))
        throw new Error("bad point: x or y not FE");
      const Ar = cr.sqr(Tr), Ir = dr(Cr);
      if (!cr.eql(Ar, Ir))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Cr } = this.toAffine();
      if (cr.isOdd)
        return !cr.isOdd(Cr);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Cr) {
      kr(Cr);
      const { px: Tr, py: Ar, pz: Ir } = this, { px: Mr, py: Hr, pz: Br } = Cr, zr = cr.eql(cr.mul(Tr, Br), cr.mul(Mr, Ir)), Gr = cr.eql(cr.mul(Ar, Br), cr.mul(Hr, Ir));
      return zr && Gr;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new _r(this.px, cr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Cr, b: Tr } = ar, Ar = cr.mul(Tr, _3n), { px: Ir, py: Mr, pz: Hr } = this;
      let Br = cr.ZERO, zr = cr.ZERO, Gr = cr.ZERO, Xr = cr.mul(Ir, Ir), Jr = cr.mul(Mr, Mr), li = cr.mul(Hr, Hr), Qr = cr.mul(Ir, Mr);
      return Qr = cr.add(Qr, Qr), Gr = cr.mul(Ir, Hr), Gr = cr.add(Gr, Gr), Br = cr.mul(Cr, Gr), zr = cr.mul(Ar, li), zr = cr.add(Br, zr), Br = cr.sub(Jr, zr), zr = cr.add(Jr, zr), zr = cr.mul(Br, zr), Br = cr.mul(Qr, Br), Gr = cr.mul(Ar, Gr), li = cr.mul(Cr, li), Qr = cr.sub(Xr, li), Qr = cr.mul(Cr, Qr), Qr = cr.add(Qr, Gr), Gr = cr.add(Xr, Xr), Xr = cr.add(Gr, Xr), Xr = cr.add(Xr, li), Xr = cr.mul(Xr, Qr), zr = cr.add(zr, Xr), li = cr.mul(Mr, Hr), li = cr.add(li, li), Xr = cr.mul(li, Qr), Br = cr.sub(Br, Xr), Gr = cr.mul(li, Jr), Gr = cr.add(Gr, Gr), Gr = cr.add(Gr, Gr), new _r(Br, zr, Gr);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Cr) {
      kr(Cr);
      const { px: Tr, py: Ar, pz: Ir } = this, { px: Mr, py: Hr, pz: Br } = Cr;
      let zr = cr.ZERO, Gr = cr.ZERO, Xr = cr.ZERO;
      const Jr = ar.a, li = cr.mul(ar.b, _3n);
      let Qr = cr.mul(Tr, Mr), ei = cr.mul(Ar, Hr), ui = cr.mul(Ir, Br), Ai = cr.add(Tr, Ar), fi = cr.add(Mr, Hr);
      Ai = cr.mul(Ai, fi), fi = cr.add(Qr, ei), Ai = cr.sub(Ai, fi), fi = cr.add(Tr, Ir);
      let gi = cr.add(Mr, Br);
      return fi = cr.mul(fi, gi), gi = cr.add(Qr, ui), fi = cr.sub(fi, gi), gi = cr.add(Ar, Ir), zr = cr.add(Hr, Br), gi = cr.mul(gi, zr), zr = cr.add(ei, ui), gi = cr.sub(gi, zr), Xr = cr.mul(Jr, fi), zr = cr.mul(li, ui), Xr = cr.add(zr, Xr), zr = cr.sub(ei, Xr), Xr = cr.add(ei, Xr), Gr = cr.mul(zr, Xr), ei = cr.add(Qr, Qr), ei = cr.add(ei, Qr), ui = cr.mul(Jr, ui), fi = cr.mul(li, fi), ei = cr.add(ei, ui), ui = cr.sub(Qr, ui), ui = cr.mul(Jr, ui), fi = cr.add(fi, ui), Qr = cr.mul(ei, fi), Gr = cr.add(Gr, Qr), Qr = cr.mul(gi, fi), zr = cr.mul(Ai, zr), zr = cr.sub(zr, Qr), Qr = cr.mul(Ai, ei), Xr = cr.mul(gi, Xr), Xr = cr.add(Xr, Qr), new _r(zr, Gr, Xr);
    }
    subtract(Cr) {
      return this.add(Cr.negate());
    }
    is0() {
      return this.equals(_r.ZERO);
    }
    wNAF(Cr) {
      return Sr.wNAFCached(this, yr, Cr, (Tr) => {
        const Ar = cr.invertBatch(Tr.map((Ir) => Ir.pz));
        return Tr.map((Ir, Mr) => Ir.toAffine(Ar[Mr])).map(_r.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Cr) {
      const Tr = _r.ZERO;
      if (Cr === _0n$1)
        return Tr;
      if (mr(Cr), Cr === _1n$1)
        return this;
      const { endo: Ar } = ar;
      if (!Ar)
        return Sr.unsafeLadder(this, Cr);
      let { k1neg: Ir, k1: Mr, k2neg: Hr, k2: Br } = Ar.splitScalar(Cr), zr = Tr, Gr = Tr, Xr = this;
      for (; Mr > _0n$1 || Br > _0n$1; )
        Mr & _1n$1 && (zr = zr.add(Xr)), Br & _1n$1 && (Gr = Gr.add(Xr)), Xr = Xr.double(), Mr >>= _1n$1, Br >>= _1n$1;
      return Ir && (zr = zr.negate()), Hr && (Gr = Gr.negate()), Gr = new _r(cr.mul(Gr.px, Ar.beta), Gr.py, Gr.pz), zr.add(Gr);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Cr) {
      mr(Cr);
      let Tr = Cr, Ar, Ir;
      const { endo: Mr } = ar;
      if (Mr) {
        const { k1neg: Hr, k1: Br, k2neg: zr, k2: Gr } = Mr.splitScalar(Tr);
        let { p: Xr, f: Jr } = this.wNAF(Br), { p: li, f: Qr } = this.wNAF(Gr);
        Xr = Sr.constTimeNegate(Hr, Xr), li = Sr.constTimeNegate(zr, li), li = new _r(cr.mul(li.px, Mr.beta), li.py, li.pz), Ar = Xr.add(li), Ir = Jr.add(Qr);
      } else {
        const { p: Hr, f: Br } = this.wNAF(Tr);
        Ar = Hr, Ir = Br;
      }
      return _r.normalizeZ([Ar, Ir])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Cr, Tr, Ar) {
      const Ir = _r.BASE, Mr = (Br, zr) => zr === _0n$1 || zr === _1n$1 || !Br.equals(Ir) ? Br.multiplyUnsafe(zr) : Br.multiply(zr), Hr = Mr(this, Tr).add(Mr(Cr, Ar));
      return Hr.is0() ? void 0 : Hr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(Cr) {
      const { px: Tr, py: Ar, pz: Ir } = this, Mr = this.is0();
      Cr == null && (Cr = Mr ? cr.ONE : cr.inv(Ir));
      const Hr = cr.mul(Tr, Cr), Br = cr.mul(Ar, Cr), zr = cr.mul(Ir, Cr);
      if (Mr)
        return { x: cr.ZERO, y: cr.ZERO };
      if (!cr.eql(zr, cr.ONE))
        throw new Error("invZ was invalid");
      return { x: Hr, y: Br };
    }
    isTorsionFree() {
      const { h: Cr, isTorsionFree: Tr } = ar;
      if (Cr === _1n$1)
        return !0;
      if (Tr)
        return Tr(_r, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Cr, clearCofactor: Tr } = ar;
      return Cr === _1n$1 ? this : Tr ? Tr(_r, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Cr = !0) {
      return this.assertValidity(), ur(_r, this, Cr);
    }
    toHex(Cr = !0) {
      return bytesToHex$1(this.toRawBytes(Cr));
    }
  }
  _r.BASE = new _r(ar.Gx, ar.Gy, cr.ONE), _r.ZERO = new _r(cr.ZERO, cr.ONE, cr.ZERO);
  const xr = ar.nBitLength, Sr = wNAF(_r, ar.endo ? Math.ceil(xr / 2) : xr);
  return {
    CURVE: ar,
    ProjectivePoint: _r,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: dr,
    isWithinCurveOrder: gr
  };
}
function validateOpts(lr) {
  const ar = validateBasic(lr);
  return validateObject(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass(lr) {
  const ar = validateOpts(lr), { Fp: cr, n: ur } = ar, fr = cr.BYTES + 1, dr = 2 * cr.BYTES + 1;
  function gr(fi) {
    return _0n$1 < fi && fi < cr.ORDER;
  }
  function mr(fi) {
    return mod(fi, ur);
  }
  function vr(fi) {
    return invert(fi, ur);
  }
  const { ProjectivePoint: yr, normPrivateKeyToScalar: kr, weierstrassEquation: _r, isWithinCurveOrder: xr } = weierstrassPoints({
    ...ar,
    toBytes(fi, gi, Ci) {
      const mi = gi.toAffine(), vi = cr.toBytes(mi.x), Ri = concatBytes$1;
      return Ci ? Ri(Uint8Array.from([gi.hasEvenY() ? 2 : 3]), vi) : Ri(Uint8Array.from([4]), vi, cr.toBytes(mi.y));
    },
    fromBytes(fi) {
      const gi = fi.length, Ci = fi[0], mi = fi.subarray(1);
      if (gi === fr && (Ci === 2 || Ci === 3)) {
        const vi = bytesToNumberBE(mi);
        if (!gr(vi))
          throw new Error("Point is not on curve");
        const Ri = _r(vi);
        let di = cr.sqrt(Ri);
        const Ti = (di & _1n$1) === _1n$1;
        return (Ci & 1) === 1 !== Ti && (di = cr.neg(di)), { x: vi, y: di };
      } else if (gi === dr && Ci === 4) {
        const vi = cr.fromBytes(mi.subarray(0, cr.BYTES)), Ri = cr.fromBytes(mi.subarray(cr.BYTES, 2 * cr.BYTES));
        return { x: vi, y: Ri };
      } else
        throw new Error(`Point of length ${gi} was invalid. Expected ${fr} compressed bytes or ${dr} uncompressed bytes`);
    }
  }), Sr = (fi) => bytesToHex$1(numberToBytesBE(fi, ar.nByteLength));
  function Er(fi) {
    const gi = ur >> _1n$1;
    return fi > gi;
  }
  function Cr(fi) {
    return Er(fi) ? mr(-fi) : fi;
  }
  const Tr = (fi, gi, Ci) => bytesToNumberBE(fi.slice(gi, Ci));
  class Ar {
    constructor(gi, Ci, mi) {
      this.r = gi, this.s = Ci, this.recovery = mi, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(gi) {
      const Ci = ar.nByteLength;
      return gi = ensureBytes("compactSignature", gi, Ci * 2), new Ar(Tr(gi, 0, Ci), Tr(gi, Ci, 2 * Ci));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(gi) {
      const { r: Ci, s: mi } = DER.toSig(ensureBytes("DER", gi));
      return new Ar(Ci, mi);
    }
    assertValidity() {
      if (!xr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!xr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(gi) {
      return new Ar(this.r, this.s, gi);
    }
    recoverPublicKey(gi) {
      const { r: Ci, s: mi, recovery: vi } = this, Ri = Gr(ensureBytes("msgHash", gi));
      if (vi == null || ![0, 1, 2, 3].includes(vi))
        throw new Error("recovery id invalid");
      const di = vi === 2 || vi === 3 ? Ci + ar.n : Ci;
      if (di >= cr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ti = vi & 1 ? "03" : "02", qi = yr.fromHex(Ti + Sr(di)), ki = vr(di), Ji = mr(-Ri * ki), Bi = mr(mi * ki), Ni = yr.BASE.multiplyAndAddUnsafe(qi, Ji, Bi);
      if (!Ni)
        throw new Error("point at infinify");
      return Ni.assertValidity(), Ni;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return Er(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ar(this.r, mr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return Sr(this.r) + Sr(this.s);
    }
  }
  const Ir = {
    isValidPrivateKey(fi) {
      try {
        return kr(fi), !0;
      } catch (gi) {
        return !1;
      }
    },
    normPrivateKeyToScalar: kr,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const fi = getMinHashLength(ar.n);
      return mapHashToField(ar.randomBytes(fi), ar.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(fi = 8, gi = yr.BASE) {
      return gi._setWindowSize(fi), gi.multiply(BigInt(3)), gi;
    }
  };
  function Mr(fi, gi = !0) {
    return yr.fromPrivateKey(fi).toRawBytes(gi);
  }
  function Hr(fi) {
    const gi = fi instanceof Uint8Array, Ci = typeof fi == "string", mi = (gi || Ci) && fi.length;
    return gi ? mi === fr || mi === dr : Ci ? mi === 2 * fr || mi === 2 * dr : fi instanceof yr;
  }
  function Br(fi, gi, Ci = !0) {
    if (Hr(fi))
      throw new Error("first arg must be private key");
    if (!Hr(gi))
      throw new Error("second arg must be public key");
    return yr.fromHex(gi).multiply(kr(fi)).toRawBytes(Ci);
  }
  const zr = ar.bits2int || function(fi) {
    const gi = bytesToNumberBE(fi), Ci = fi.length * 8 - ar.nBitLength;
    return Ci > 0 ? gi >> BigInt(Ci) : gi;
  }, Gr = ar.bits2int_modN || function(fi) {
    return mr(zr(fi));
  }, Xr = bitMask(ar.nBitLength);
  function Jr(fi) {
    if (typeof fi != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$1 <= fi && fi < Xr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE(fi, ar.nByteLength);
  }
  function li(fi, gi, Ci = Qr) {
    if (["recovered", "canonical"].some((bi) => bi in Ci))
      throw new Error("sign() legacy options not supported");
    const { hash: mi, randomBytes: vi } = ar;
    let { lowS: Ri, prehash: di, extraEntropy: Ti } = Ci;
    Ri == null && (Ri = !0), fi = ensureBytes("msgHash", fi), di && (fi = ensureBytes("prehashed msgHash", mi(fi)));
    const qi = Gr(fi), ki = kr(gi), Ji = [Jr(ki), Jr(qi)];
    if (Ti != null) {
      const bi = Ti === !0 ? vi(cr.BYTES) : Ti;
      Ji.push(ensureBytes("extraEntropy", bi));
    }
    const Bi = concatBytes$1(...Ji), Ni = qi;
    function Mi(bi) {
      const Ei = zr(bi);
      if (!xr(Ei))
        return;
      const Si = vr(Ei), Vi = yr.BASE.multiply(Ei).toAffine(), Di = mr(Vi.x);
      if (Di === _0n$1)
        return;
      const sa = mr(Si * mr(Ni + Di * ki));
      if (sa === _0n$1)
        return;
      let ra = (Vi.x === Di ? 0 : 2) | Number(Vi.y & _1n$1), fa = sa;
      return Ri && Er(sa) && (fa = Cr(sa), ra ^= 1), new Ar(Di, fa, ra);
    }
    return { seed: Bi, k2sig: Mi };
  }
  const Qr = { lowS: ar.lowS, prehash: !1 }, ei = { lowS: ar.lowS, prehash: !1 };
  function ui(fi, gi, Ci = Qr) {
    const { seed: mi, k2sig: vi } = li(fi, gi, Ci), Ri = ar;
    return createHmacDrbg(Ri.hash.outputLen, Ri.nByteLength, Ri.hmac)(mi, vi);
  }
  yr.BASE._setWindowSize(8);
  function Ai(fi, gi, Ci, mi = ei) {
    var Vi;
    const vi = fi;
    if (gi = ensureBytes("msgHash", gi), Ci = ensureBytes("publicKey", Ci), "strict" in mi)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Ri, prehash: di } = mi;
    let Ti, qi;
    try {
      if (typeof vi == "string" || vi instanceof Uint8Array)
        try {
          Ti = Ar.fromDER(vi);
        } catch (Di) {
          if (!(Di instanceof DER.Err))
            throw Di;
          Ti = Ar.fromCompact(vi);
        }
      else if (typeof vi == "object" && typeof vi.r == "bigint" && typeof vi.s == "bigint") {
        const { r: Di, s: sa } = vi;
        Ti = new Ar(Di, sa);
      } else
        throw new Error("PARSE");
      qi = yr.fromHex(Ci);
    } catch (Di) {
      if (Di.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Ri && Ti.hasHighS())
      return !1;
    di && (gi = ar.hash(gi));
    const { r: ki, s: Ji } = Ti, Bi = Gr(gi), Ni = vr(Ji), Mi = mr(Bi * Ni), bi = mr(ki * Ni), Ei = (Vi = yr.BASE.multiplyAndAddUnsafe(qi, Mi, bi)) == null ? void 0 : Vi.toAffine();
    return Ei ? mr(Ei.x) === ki : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Mr,
    getSharedSecret: Br,
    sign: ui,
    verify: Ai,
    ProjectivePoint: yr,
    Signature: Ar,
    utils: Ir
  };
}
let HMAC$1 = class extends Hash$1 {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(ar);
    const ur = toBytes$1(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return exists$1(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$1(this), bytes$1(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$1 = (lr, ar, cr) => new HMAC$1(lr, ar).update(cr).digest();
hmac$1.create = (lr, ar) => new HMAC$1(lr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(lr) {
  return {
    hash: lr,
    hmac: (ar, ...cr) => hmac$1(lr, ar, concatBytes$2(...cr)),
    randomBytes: randomBytes$1
  };
}
function createCurve(lr, ar) {
  const cr = (ur) => weierstrass({ ...lr, ...getHash(ur) });
  return Object.freeze({ ...cr(ar), create: cr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (lr, ar) => (lr + ar / _2n) / ar;
function sqrtMod(lr) {
  const ar = secp256k1P, cr = BigInt(3), ur = BigInt(6), fr = BigInt(11), dr = BigInt(22), gr = BigInt(23), mr = BigInt(44), vr = BigInt(88), yr = lr * lr * lr % ar, kr = yr * yr * lr % ar, _r = pow2(kr, cr, ar) * kr % ar, xr = pow2(_r, cr, ar) * kr % ar, Sr = pow2(xr, _2n, ar) * yr % ar, Er = pow2(Sr, fr, ar) * Sr % ar, Cr = pow2(Er, dr, ar) * Er % ar, Tr = pow2(Cr, mr, ar) * Cr % ar, Ar = pow2(Tr, vr, ar) * Tr % ar, Ir = pow2(Ar, mr, ar) * Cr % ar, Mr = pow2(Ir, cr, ar) * kr % ar, Hr = pow2(Mr, gr, ar) * Er % ar, Br = pow2(Hr, ur, ar) * yr % ar, zr = pow2(Br, _2n, ar);
  if (!Fp.eql(Fp.sqr(zr), lr))
    throw new Error("Cannot find square root");
  return zr;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (lr) => {
      const ar = secp256k1N, cr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), fr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), dr = cr, gr = BigInt("0x100000000000000000000000000000000"), mr = divNearest(dr * lr, ar), vr = divNearest(-ur * lr, ar);
      let yr = mod(lr - mr * cr - vr * fr, ar), kr = mod(-mr * ur - vr * dr, ar);
      const _r = yr > gr, xr = kr > gr;
      if (_r && (yr = ar - yr), xr && (kr = ar - kr), yr > gr || kr > gr)
        throw new Error("splitScalar: Endomorphism failed, k=" + lr);
      return { k1neg: _r, k1: yr, k2neg: xr, k2: kr };
    }
  }
}, sha256$1), _0n = BigInt(0), fe = (lr) => typeof lr == "bigint" && _0n < lr && lr < secp256k1P, ge$1 = (lr) => typeof lr == "bigint" && _0n < lr && lr < secp256k1N, TAGGED_HASH_PREFIXES = {};
function taggedHash(lr, ...ar) {
  let cr = TAGGED_HASH_PREFIXES[lr];
  if (cr === void 0) {
    const ur = sha256$1(Uint8Array.from(lr, (fr) => fr.charCodeAt(0)));
    cr = concatBytes$1(ur, ur), TAGGED_HASH_PREFIXES[lr] = cr;
  }
  return sha256$1(concatBytes$1(cr, ...ar));
}
const pointToBytes = (lr) => lr.toRawBytes(!0).slice(1), numTo32b = (lr) => numberToBytesBE(lr, 32), modP = (lr) => mod(lr, secp256k1P), modN = (lr) => mod(lr, secp256k1N), Point = secp256k1.ProjectivePoint, GmulAdd = (lr, ar, cr) => Point.BASE.multiplyAndAddUnsafe(lr, ar, cr);
function schnorrGetExtPubKey(lr) {
  let ar = secp256k1.utils.normPrivateKeyToScalar(lr), cr = Point.fromPrivateKey(ar);
  return { scalar: cr.hasEvenY() ? ar : modN(-ar), bytes: pointToBytes(cr) };
}
function lift_x(lr) {
  if (!fe(lr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP(lr * lr), cr = modP(ar * lr + BigInt(7));
  let ur = sqrtMod(cr);
  ur % _2n !== _0n && (ur = modP(-ur));
  const fr = new Point(lr, ur, _1n);
  return fr.assertValidity(), fr;
}
function challenge(...lr) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...lr)));
}
function schnorrGetPublicKey(lr) {
  return schnorrGetExtPubKey(lr).bytes;
}
function schnorrSign(lr, ar, cr = randomBytes$1(32)) {
  const ur = ensureBytes("message", lr), { bytes: fr, scalar: dr } = schnorrGetExtPubKey(ar), gr = ensureBytes("auxRand", cr, 32), mr = numTo32b(dr ^ bytesToNumberBE(taggedHash("BIP0340/aux", gr))), vr = taggedHash("BIP0340/nonce", mr, fr, ur), yr = modN(bytesToNumberBE(vr));
  if (yr === _0n)
    throw new Error("sign failed: k is zero");
  const { bytes: kr, scalar: _r } = schnorrGetExtPubKey(yr), xr = challenge(kr, fr, ur), Sr = new Uint8Array(64);
  if (Sr.set(kr, 0), Sr.set(numTo32b(modN(_r + xr * dr)), 32), !schnorrVerify(Sr, ur, fr))
    throw new Error("sign: Invalid signature produced");
  return Sr;
}
function schnorrVerify(lr, ar, cr) {
  const ur = ensureBytes("signature", lr, 64), fr = ensureBytes("message", ar), dr = ensureBytes("publicKey", cr, 32);
  try {
    const gr = lift_x(bytesToNumberBE(dr)), mr = bytesToNumberBE(ur.subarray(0, 32));
    if (!fe(mr))
      return !1;
    const vr = bytesToNumberBE(ur.subarray(32, 64));
    if (!ge$1(vr))
      return !1;
    const yr = challenge(numTo32b(mr), pointToBytes(gr), fr), kr = GmulAdd(gr, vr, modN(-yr));
    return !(!kr || !kr.hasEvenY() || kr.toAffine().x !== mr);
  } catch (gr) {
    return !1;
  }
}
const schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))(), crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (lr) => lr instanceof Uint8Array, createView = (lr) => new DataView(lr.buffer, lr.byteOffset, lr.byteLength), rotr = (lr, ar) => lr << 32 - ar | lr >>> ar, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const hexes = Array.from({ length: 256 }, (lr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex(lr) {
  if (!u8a(lr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let cr = 0; cr < lr.length; cr++)
    ar += hexes[lr[cr]];
  return ar;
}
function hexToBytes(lr) {
  if (typeof lr != "string")
    throw new Error("hex string expected, got " + typeof lr);
  const ar = lr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const cr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = ur * 2, dr = lr.slice(fr, fr + 2), gr = Number.parseInt(dr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    cr[ur] = gr;
  }
  return cr;
}
function utf8ToBytes(lr) {
  if (typeof lr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof lr}`);
  return new Uint8Array(new TextEncoder().encode(lr));
}
function toBytes(lr) {
  if (typeof lr == "string" && (lr = utf8ToBytes(lr)), !u8a(lr))
    throw new Error(`expected Uint8Array, got ${typeof lr}`);
  return lr;
}
function concatBytes(...lr) {
  const ar = new Uint8Array(lr.reduce((ur, fr) => ur + fr.length, 0));
  let cr = 0;
  return lr.forEach((ur) => {
    if (!u8a(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, cr), cr += ur.length;
  }), ar;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(lr) {
  const ar = (ur) => lr().update(toBytes(ur)).digest(), cr = lr();
  return ar.outputLen = cr.outputLen, ar.blockLen = cr.blockLen, ar.create = () => lr(), ar;
}
function randomBytes(lr = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(lr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number(lr) {
  if (!Number.isSafeInteger(lr) || lr < 0)
    throw new Error(`Wrong positive integer: ${lr}`);
}
function bool(lr) {
  if (typeof lr != "boolean")
    throw new Error(`Expected boolean, not ${lr}`);
}
function bytes(lr, ...ar) {
  if (!(lr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(lr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${lr.length}`);
}
function hash(lr) {
  if (typeof lr != "function" || typeof lr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(lr.outputLen), number(lr.blockLen);
}
function exists(lr, ar = !0) {
  if (lr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && lr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(lr, ar) {
  bytes(lr);
  const cr = ar.outputLen;
  if (lr.length < cr)
    throw new Error(`digestInto() expects output buffer of length at least ${cr}`);
}
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
function setBigUint64(lr, ar, cr, ur) {
  if (typeof lr.setBigUint64 == "function")
    return lr.setBigUint64(ar, cr, ur);
  const fr = BigInt(32), dr = BigInt(4294967295), gr = Number(cr >> fr & dr), mr = Number(cr & dr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  lr.setUint32(ar + vr, gr, ur), lr.setUint32(ar + yr, mr, ur);
}
class SHA2 extends Hash {
  constructor(ar, cr, ur, fr) {
    super(), this.blockLen = ar, this.outputLen = cr, this.padOffset = ur, this.isLE = fr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView(this.buffer);
  }
  update(ar) {
    assert.exists(this);
    const { view: cr, buffer: ur, blockLen: fr } = this;
    ar = toBytes(ar);
    const dr = ar.length;
    for (let gr = 0; gr < dr; ) {
      const mr = Math.min(fr - this.pos, dr - gr);
      if (mr === fr) {
        const vr = createView(ar);
        for (; fr <= dr - gr; gr += fr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === fr && (this.process(cr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.output(ar, this), this.finished = !0;
    const { buffer: cr, view: ur, blockLen: fr, isLE: dr } = this;
    let { pos: gr } = this;
    cr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > fr - gr && (this.process(ur, 0), gr = 0);
    for (let _r = gr; _r < fr; _r++)
      cr[_r] = 0;
    setBigUint64(ur, fr - 8, BigInt(this.length * 8), dr), this.process(ur, 0);
    const mr = createView(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, kr = this.get();
    if (yr > kr.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let _r = 0; _r < yr; _r++)
      mr.setUint32(4 * _r, kr[_r], dr);
  }
  digest() {
    const { buffer: ar, outputLen: cr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, cr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: cr, buffer: ur, length: fr, finished: dr, destroyed: gr, pos: mr } = this;
    return ar.length = fr, ar.pos = mr, ar.finished = dr, ar.destroyed = gr, fr % cr && ar.buffer.set(ur), ar;
  }
}
const Chi$1 = (lr, ar, cr) => lr & ar ^ ~lr & cr, Maj = (lr, ar, cr) => lr & ar ^ lr & cr ^ ar & cr, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: ar, B: cr, C: ur, D: fr, E: dr, F: gr, G: mr, H: vr } = this;
    return [ar, cr, ur, fr, dr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, cr, ur, fr, dr, gr, mr, vr) {
    this.A = ar | 0, this.B = cr | 0, this.C = ur | 0, this.D = fr | 0, this.E = dr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, cr) {
    for (let _r = 0; _r < 16; _r++, cr += 4)
      SHA256_W[_r] = ar.getUint32(cr, !1);
    for (let _r = 16; _r < 64; _r++) {
      const xr = SHA256_W[_r - 15], Sr = SHA256_W[_r - 2], Er = rotr(xr, 7) ^ rotr(xr, 18) ^ xr >>> 3, Cr = rotr(Sr, 17) ^ rotr(Sr, 19) ^ Sr >>> 10;
      SHA256_W[_r] = Cr + SHA256_W[_r - 7] + Er + SHA256_W[_r - 16] | 0;
    }
    let { A: ur, B: fr, C: dr, D: gr, E: mr, F: vr, G: yr, H: kr } = this;
    for (let _r = 0; _r < 64; _r++) {
      const xr = rotr(mr, 6) ^ rotr(mr, 11) ^ rotr(mr, 25), Sr = kr + xr + Chi$1(mr, vr, yr) + SHA256_K[_r] + SHA256_W[_r] | 0, Cr = (rotr(ur, 2) ^ rotr(ur, 13) ^ rotr(ur, 22)) + Maj(ur, fr, dr) | 0;
      kr = yr, yr = vr, vr = mr, mr = gr + Sr | 0, gr = dr, dr = fr, fr = ur, ur = Sr + Cr | 0;
    }
    ur = ur + this.A | 0, fr = fr + this.B | 0, dr = dr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, kr = kr + this.H | 0, this.set(ur, fr, dr, gr, mr, vr, yr, kr);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const sha256 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber(lr) {
  if (!Number.isSafeInteger(lr))
    throw new Error(`Wrong integer: ${lr}`);
}
function chain(...lr) {
  const ar = (fr, dr) => (gr) => fr(dr(gr)), cr = Array.from(lr).reverse().reduce((fr, dr) => fr ? ar(fr, dr.encode) : dr.encode, void 0), ur = lr.reduce((fr, dr) => fr ? ar(fr, dr.decode) : dr.decode, void 0);
  return { encode: cr, decode: ur };
}
function alphabet(lr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((cr) => {
        if (assertNumber(cr), cr < 0 || cr >= lr.length)
          throw new Error(`Digit index outside alphabet: ${cr} (alphabet: ${lr.length})`);
        return lr[cr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((cr) => {
        if (typeof cr != "string")
          throw new Error(`alphabet.decode: not string element=${cr}`);
        const ur = lr.indexOf(cr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${cr}". Allowed: ${lr}`);
        return ur;
      });
    }
  };
}
function join$1(lr = "") {
  if (typeof lr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let cr of ar)
        if (typeof cr != "string")
          throw new Error(`join.encode: non-string input=${cr}`);
      return ar.join(lr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(lr);
    }
  };
}
function padding(lr, ar = "=") {
  if (assertNumber(lr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of cr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; cr.length * lr % 8; )
        cr.push(ar);
      return cr;
    },
    decode(cr) {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let fr of cr)
        if (typeof fr != "string")
          throw new Error(`padding.decode: non-string input=${fr}`);
      let ur = cr.length;
      if (ur * lr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && cr[ur - 1] === ar; ur--)
        if (!((ur - 1) * lr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return cr.slice(0, ur);
    }
  };
}
function normalize(lr) {
  if (typeof lr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => lr(ar) };
}
function convertRadix(lr, ar, cr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (cr < 2)
    throw new Error(`convertRadix: wrong to=${cr}, base cannot be less than 2`);
  if (!Array.isArray(lr))
    throw new Error("convertRadix: data should be array");
  if (!lr.length)
    return [];
  let ur = 0;
  const fr = [], dr = Array.from(lr);
  for (dr.forEach((gr) => {
    if (assertNumber(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < dr.length; vr++) {
      const yr = dr[vr], kr = ar * gr + yr;
      if (!Number.isSafeInteger(kr) || ar * gr / ar !== gr || kr - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = kr % cr, dr[vr] = Math.floor(kr / cr), !Number.isSafeInteger(dr[vr]) || dr[vr] * cr + gr !== kr)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        dr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (fr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < lr.length - 1 && lr[gr] === 0; gr++)
    fr.push(0);
  return fr.reverse();
}
const gcd = (lr, ar) => ar ? gcd(ar, lr % ar) : lr, radix2carry = (lr, ar) => lr + (ar - gcd(lr, ar));
function convertRadix2(lr, ar, cr, ur) {
  if (!Array.isArray(lr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (cr <= 0 || cr > 32)
    throw new Error(`convertRadix2: wrong to=${cr}`);
  if (radix2carry(ar, cr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${cr} carryBits=${radix2carry(ar, cr)}`);
  let fr = 0, dr = 0;
  const gr = 2 ** cr - 1, mr = [];
  for (const vr of lr) {
    if (assertNumber(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (fr = fr << ar | vr, dr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${dr} from=${ar}`);
    for (dr += ar; dr >= cr; dr -= cr)
      mr.push((fr >> dr - cr & gr) >>> 0);
    fr &= 2 ** dr - 1;
  }
  if (fr = fr << cr - dr & gr, !ur && dr >= ar)
    throw new Error("Excess padding");
  if (!ur && fr)
    throw new Error(`Non-zero padding: ${fr}`);
  return ur && dr > 0 && mr.push(fr >>> 0), mr;
}
function radix(lr) {
  return assertNumber(lr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(ar), 2 ** 8, lr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(ar, lr, 2 ** 8));
    }
  };
}
function radix2(lr, ar = !1) {
  if (assertNumber(lr), lr <= 0 || lr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, lr) > 32 || radix2carry(lr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (cr) => {
      if (!(cr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(cr), 8, lr, !ar);
    },
    decode: (cr) => {
      if (!Array.isArray(cr) || cr.length && typeof cr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(cr, lr, 8, ar));
    }
  };
}
function unsafeWrapper(lr) {
  if (typeof lr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return lr.apply(null, ar);
    } catch (cr) {
    }
  };
}
const base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join$1("")), base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$1(""), normalize((lr) => lr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join$1("")), base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join$1("")), genBase58 = (lr) => chain(radix(58), alphabet(lr), join$1("")), base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr = {
  encode(lr) {
    let ar = "";
    for (let cr = 0; cr < lr.length; cr += 8) {
      const ur = lr.subarray(cr, cr + 8);
      ar += base58.encode(ur).padStart(XMR_BLOCK_LEN[ur.length], "1");
    }
    return ar;
  },
  decode(lr) {
    let ar = [];
    for (let cr = 0; cr < lr.length; cr += 11) {
      const ur = lr.slice(cr, cr + 11), fr = XMR_BLOCK_LEN.indexOf(ur.length), dr = base58.decode(ur);
      for (let gr = 0; gr < dr.length - fr; gr++)
        if (dr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(dr.slice(dr.length - fr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$1("")), POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(lr) {
  const ar = lr >> 25;
  let cr = (lr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS.length; ur++)
    (ar >> ur & 1) === 1 && (cr ^= POLYMOD_GENERATORS[ur]);
  return cr;
}
function bechChecksum(lr, ar, cr = 1) {
  const ur = lr.length;
  let fr = 1;
  for (let dr = 0; dr < ur; dr++) {
    const gr = lr.charCodeAt(dr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${lr})`);
    fr = bech32Polymod(fr) ^ gr >> 5;
  }
  fr = bech32Polymod(fr);
  for (let dr = 0; dr < ur; dr++)
    fr = bech32Polymod(fr) ^ lr.charCodeAt(dr) & 31;
  for (let dr of ar)
    fr = bech32Polymod(fr) ^ dr;
  for (let dr = 0; dr < 6; dr++)
    fr = bech32Polymod(fr);
  return fr ^= cr, BECH_ALPHABET.encode(convertRadix2([fr % 2 ** 30], 30, 5, !1));
}
function genBech32(lr) {
  const ar = lr === "bech32" ? 1 : 734539939, cr = radix2(5), ur = cr.decode, fr = cr.encode, dr = unsafeWrapper(ur);
  function gr(kr, _r, xr = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof kr}`);
    if (!Array.isArray(_r) || _r.length && typeof _r[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof _r}`);
    const Sr = kr.length + 7 + _r.length;
    if (xr !== !1 && Sr > xr)
      throw new TypeError(`Length ${Sr} exceeds limit ${xr}`);
    return kr = kr.toLowerCase(), `${kr}1${BECH_ALPHABET.encode(_r)}${bechChecksum(kr, _r, ar)}`;
  }
  function mr(kr, _r = 90) {
    if (typeof kr != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof kr}`);
    if (kr.length < 8 || _r !== !1 && kr.length > _r)
      throw new TypeError(`Wrong string length: ${kr.length} (${kr}). Expected (8..${_r})`);
    const xr = kr.toLowerCase();
    if (kr !== xr && kr !== kr.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    kr = xr;
    const Sr = kr.lastIndexOf("1");
    if (Sr === 0 || Sr === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = kr.slice(0, Sr), Cr = kr.slice(Sr + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET.decode(Cr).slice(0, -6), Ar = bechChecksum(Er, Tr, ar);
    if (!Cr.endsWith(Ar))
      throw new Error(`Invalid checksum in ${kr}: expected "${Ar}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper(mr);
  function yr(kr) {
    const { prefix: _r, words: xr } = mr(kr, !1);
    return { prefix: _r, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: dr, toWords: fr };
}
const bech32 = genBech32("bech32");
genBech32("bech32m");
const utf8 = {
  encode: (lr) => new TextDecoder().decode(lr),
  decode: (lr) => new TextEncoder().encode(lr)
}, hex = chain(radix2(4), alphabet("0123456789abcdef"), join$1(""), normalize((lr) => {
  if (typeof lr != "string" || lr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof lr} with length ${lr.length}`);
  return lr.toLowerCase();
})), CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
`${Object.keys(CODERS).join(", ")}`;
class HMAC extends Hash {
  constructor(ar, cr) {
    super(), this.finished = !1, this.destroyed = !1, assert.hash(ar);
    const ur = toBytes(cr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const fr = this.blockLen, dr = new Uint8Array(fr);
    dr.set(ur.length > fr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 54;
    this.iHash.update(dr), this.oHash = ar.create();
    for (let gr = 0; gr < dr.length; gr++)
      dr[gr] ^= 106;
    this.oHash.update(dr), dr.fill(0);
  }
  update(ar) {
    return assert.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: cr, iHash: ur, finished: fr, destroyed: dr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = fr, ar.destroyed = dr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = cr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (lr, ar, cr) => new HMAC(lr, ar).update(cr).digest();
hmac.create = (lr, ar) => new HMAC(lr, ar);
function extract(lr, ar, cr) {
  return assert.hash(lr), cr === void 0 && (cr = new Uint8Array(lr.outputLen)), hmac(lr, toBytes(cr), toBytes(ar));
}
const HKDF_COUNTER = new Uint8Array([0]), EMPTY_BUFFER = new Uint8Array();
function expand(lr, ar, cr, ur = 32) {
  if (assert.hash(lr), assert.number(ur), ur > 255 * lr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const fr = Math.ceil(ur / lr.outputLen);
  cr === void 0 && (cr = EMPTY_BUFFER);
  const dr = new Uint8Array(fr * lr.outputLen), gr = hmac.create(lr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < fr; yr++)
    HKDF_COUNTER[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER : vr).update(cr).update(HKDF_COUNTER).digestInto(vr), dr.set(vr, lr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER.fill(0), dr.slice(0, ur);
}
var __defProp = Object.defineProperty, __export = (lr, ar) => {
  for (var cr in ar)
    __defProp(lr, cr, { get: ar[cr], enumerable: !0 });
}, verifiedSymbol = Symbol("verified"), isRecord = (lr) => lr instanceof Object;
function validateEvent(lr) {
  if (!isRecord(lr) || typeof lr.kind != "number" || typeof lr.content != "string" || typeof lr.created_at != "number" || typeof lr.pubkey != "string" || !lr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(lr.tags))
    return !1;
  for (let ar = 0; ar < lr.tags.length; ar++) {
    let cr = lr.tags[ar];
    if (!Array.isArray(cr))
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (typeof cr[ur] == "object")
        return !1;
  }
  return !0;
}
var utils_exports = {};
__export(utils_exports, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8"), utf8Encoder = new TextEncoder();
function normalizeURL(lr) {
  lr.indexOf("://") === -1 && (lr = "wss://" + lr);
  let ar = new URL(lr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList(lr, ar) {
  const [cr, ur] = binarySearch(lr, (fr) => ar.id === fr.id ? 0 : ar.created_at === fr.created_at ? -1 : fr.created_at - ar.created_at);
  return ur || lr.splice(cr, 0, ar), lr;
}
function insertEventIntoAscendingList(lr, ar) {
  const [cr, ur] = binarySearch(lr, (fr) => ar.id === fr.id ? 0 : ar.created_at === fr.created_at ? -1 : ar.created_at - fr.created_at);
  return ur || lr.splice(cr, 0, ar), lr;
}
function binarySearch(lr, ar) {
  let cr = 0, ur = lr.length - 1;
  for (; cr <= ur; ) {
    const fr = Math.floor((cr + ur) / 2), dr = ar(lr[fr]);
    if (dr === 0)
      return [fr, !0];
    dr < 0 ? ur = fr - 1 : cr = fr + 1;
  }
  return [cr, !1];
}
var QueueNode = class {
  constructor(lr) {
    ji(this, "value");
    ji(this, "next", null);
    ji(this, "prev", null);
    this.value = lr;
  }
}, Queue = class {
  constructor() {
    ji(this, "first");
    ji(this, "last");
    this.first = null, this.last = null;
  }
  enqueue(lr) {
    const ar = new QueueNode(lr);
    return this.last ? this.last === this.first ? (this.last = ar, this.last.prev = this.first, this.first.next = ar) : (ar.prev = this.last, this.last.next = ar, this.last = ar) : (this.first = ar, this.last = ar), !0;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const ar = this.first;
      return this.first = null, this.last = null, ar.value;
    }
    const lr = this.first;
    return this.first = lr.next, lr.value;
  }
}, JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(lr) {
    return bytesToHex(schnorr.getPublicKey(lr));
  }
  finalizeEvent(lr, ar) {
    const cr = lr;
    return cr.pubkey = bytesToHex(schnorr.getPublicKey(ar)), cr.id = getEventHash(cr), cr.sig = bytesToHex(schnorr.sign(getEventHash(cr), ar)), cr[verifiedSymbol] = !0, cr;
  }
  verifyEvent(lr) {
    if (typeof lr[verifiedSymbol] == "boolean")
      return lr[verifiedSymbol];
    const ar = getEventHash(lr);
    if (ar !== lr.id)
      return lr[verifiedSymbol] = !1, !1;
    try {
      const cr = schnorr.verify(lr.sig, ar, lr.pubkey);
      return lr[verifiedSymbol] = cr, cr;
    } catch (cr) {
      return lr[verifiedSymbol] = !1, !1;
    }
  }
};
function serializeEvent(lr) {
  if (!validateEvent(lr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, lr.pubkey, lr.created_at, lr.kind, lr.tags, lr.content]);
}
function getEventHash(lr) {
  let ar = sha256(utf8Encoder.encode(serializeEvent(lr)));
  return bytesToHex(ar);
}
var i = new JS();
i.generateSecretKey;
i.getPublicKey;
var finalizeEvent = i.finalizeEvent, verifyEvent = i.verifyEvent, kinds_exports = {};
__export(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EncryptedDirectMessages: () => EncryptedDirectMessages,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isEphemeralKind: () => isEphemeralKind,
  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(lr) {
  return 1e3 <= lr && lr < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(lr);
}
function isReplaceableKind(lr) {
  return [0, 3].includes(lr) || 1e4 <= lr && lr < 2e4;
}
function isEphemeralKind(lr) {
  return 2e4 <= lr && lr < 3e4;
}
function isParameterizedReplaceableKind(lr) {
  return 3e4 <= lr && lr < 4e4;
}
function classifyKind(lr) {
  return isRegularKind(lr) ? "regular" : isReplaceableKind(lr) ? "replaceable" : isEphemeralKind(lr) ? "ephemeral" : isParameterizedReplaceableKind(lr) ? "parameterized" : "unknown";
}
var Metadata = 0, ShortTextNote = 1, RecommendRelay = 2, Contacts = 3, EncryptedDirectMessage = 4, EncryptedDirectMessages = 4, EventDeletion = 5, Repost = 6, Reaction = 7, BadgeAward = 8, GenericRepost = 16, ChannelCreation = 40, ChannelMetadata = 41, ChannelMessage = 42, ChannelHideMessage = 43, ChannelMuteUser = 44, OpenTimestamps = 1040, FileMetadata = 1063, LiveChatMessage = 1311, ProblemTracker = 1971, Report = 1984, Reporting = 1984, Label = 1985, CommunityPostApproval = 4550, JobRequest = 5999, JobResult = 6999, JobFeedback = 7e3, ZapGoal = 9041, ZapRequest = 9734, Zap = 9735, Highlights = 9802, Mutelist = 1e4, Pinlist = 10001, RelayList = 10002, BookmarkList = 10003, CommunitiesList = 10004, PublicChatsList = 10005, BlockedRelaysList = 10006, SearchRelaysList = 10007, InterestsList = 10015, UserEmojiList = 10030, FileServerPreference = 10096, NWCWalletInfo = 13194, LightningPubRPC = 21e3, ClientAuth = 22242, NWCWalletRequest = 23194, NWCWalletResponse = 23195, NostrConnect = 24133, HTTPAuth = 27235, Followsets = 3e4, Genericlists = 30001, Relaysets = 30002, Bookmarksets = 30003, Curationsets = 30004, ProfileBadges = 30008, BadgeDefinition = 30009, Interestsets = 30015, CreateOrUpdateStall = 30017, CreateOrUpdateProduct = 30018, LongFormArticle = 30023, DraftLong = 30024, Emojisets = 30030, Application = 30078, LiveEvent = 30311, UserStatuses = 30315, ClassifiedListing = 30402, DraftClassifiedListing = 30403, Date2 = 31922, Time = 31923, Calendar = 31924, CalendarEventRSVP = 31925, Handlerrecommendation = 31989, Handlerinformation = 31990, CommunityDefinition = 34550, fakejson_exports = {};
__export(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(lr, ar) {
  let cr = ar.length + 3, ur = lr.indexOf(`"${ar}":`) + cr, fr = lr.slice(ur).indexOf('"') + ur + 1;
  return lr.slice(fr, fr + 64);
}
function getInt(lr, ar) {
  let cr = ar.length, ur = lr.indexOf(`"${ar}":`) + cr + 3, fr = lr.slice(ur), dr = Math.min(fr.indexOf(","), fr.indexOf("}"));
  return parseInt(fr.slice(0, dr), 10);
}
function getSubscriptionId(lr) {
  let ar = lr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let cr = lr.slice(ar + 7 + 1).indexOf('"');
  if (cr === -1)
    return null;
  let ur = ar + 7 + 1 + cr, fr = lr.slice(ur + 1, 80).indexOf('"');
  if (fr === -1)
    return null;
  let dr = ur + 1 + fr;
  return lr.slice(ur + 1, dr);
}
function matchEventId(lr, ar) {
  return ar === getHex64(lr, "id");
}
function matchEventPubkey(lr, ar) {
  return ar === getHex64(lr, "pubkey");
}
function matchEventKind(lr, ar) {
  return ar === getInt(lr, "kind");
}
var nip42_exports = {};
__export(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(lr, ar) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", lr],
      ["challenge", ar]
    ],
    content: ""
  };
}
var nip19_exports = {};
__export(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  decode: () => decode$1,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nrelayEncode: () => nrelayEncode,
  nsecEncode: () => nsecEncode
});
var Bech32MaxSize = 5e3, BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(lr) {
  const ar = new Uint8Array(4);
  return ar[0] = lr >> 24 & 255, ar[1] = lr >> 16 & 255, ar[2] = lr >> 8 & 255, ar[3] = lr & 255, ar;
}
function decode$1(lr) {
  var fr, dr, gr, mr, vr, yr, kr, _r;
  let { prefix: ar, words: cr } = bech32.decode(lr, Bech32MaxSize), ur = new Uint8Array(bech32.fromWords(cr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder.decode(Sr)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex(xr[0][0]),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder.decode(Sr)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((kr = xr[3]) != null && kr[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(xr[0][0]),
          pubkey: bytesToHex(xr[2][0]),
          kind: parseInt(bytesToHex(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Sr) => utf8Decoder.decode(Sr)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV(ur);
      if (!((_r = xr[0]) != null && _r[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder.decode(xr[0][0])
      };
    }
    case "nsec":
      return { type: ar, data: ur };
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV(lr) {
  let ar = {}, cr = lr;
  for (; cr.length > 0; ) {
    let ur = cr[0], fr = cr[1], dr = cr.slice(2, 2 + fr);
    if (cr = cr.slice(2 + fr), dr.length < fr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(dr);
  }
  return ar;
}
function nsecEncode(lr) {
  return encodeBytes("nsec", lr);
}
function npubEncode(lr) {
  return encodeBytes("npub", hexToBytes(lr));
}
function noteEncode(lr) {
  return encodeBytes("note", hexToBytes(lr));
}
function encodeBech32(lr, ar) {
  let cr = bech32.toWords(ar);
  return bech32.encode(lr, cr, Bech32MaxSize);
}
function encodeBytes(lr, ar) {
  return encodeBech32(lr, ar);
}
function nprofileEncode(lr) {
  let ar = encodeTLV({
    0: [hexToBytes(lr.pubkey)],
    1: (lr.relays || []).map((cr) => utf8Encoder.encode(cr))
  });
  return encodeBech32("nprofile", ar);
}
function neventEncode(lr) {
  let ar;
  lr.kind !== void 0 && (ar = integerToUint8Array(lr.kind));
  let cr = encodeTLV({
    0: [hexToBytes(lr.id)],
    1: (lr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: lr.author ? [hexToBytes(lr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32("nevent", cr);
}
function naddrEncode(lr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, lr.kind, !1);
  let cr = encodeTLV({
    0: [utf8Encoder.encode(lr.identifier)],
    1: (lr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: [hexToBytes(lr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32("naddr", cr);
}
function nrelayEncode(lr) {
  let ar = encodeTLV({
    0: [utf8Encoder.encode(lr)]
  });
  return encodeBech32("nrelay", ar);
}
function encodeTLV(lr) {
  let ar = [];
  return Object.entries(lr).reverse().forEach(([cr, ur]) => {
    ur.forEach((fr) => {
      let dr = new Uint8Array(fr.length + 2);
      dr.set([parseInt(cr)], 0), dr.set([fr.length], 1), dr.set(fr, 2), ar.push(dr);
    });
  }), concatBytes(...ar);
}
var nip04_exports = {};
__export(nip04_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt(lr, ar, cr) {
  const ur = lr instanceof Uint8Array ? bytesToHex(lr) : lr, fr = secp256k1.getSharedSecret(ur, "02" + ar), dr = getNormalizedX(fr);
  let gr = Uint8Array.from(randomBytes(16)), mr = utf8Encoder.encode(cr), vr = await crypto.subtle.importKey("raw", dr, { name: "AES-CBC" }, !1, ["encrypt"]), yr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: gr }, vr, mr), kr = base64.encode(new Uint8Array(yr)), _r = base64.encode(new Uint8Array(gr.buffer));
  return `${kr}?iv=${_r}`;
}
async function decrypt(lr, ar, cr) {
  const ur = lr instanceof Uint8Array ? bytesToHex(lr) : lr;
  let [fr, dr] = cr.split("?iv="), gr = secp256k1.getSharedSecret(ur, "02" + ar), mr = getNormalizedX(gr), vr = await crypto.subtle.importKey("raw", mr, { name: "AES-CBC" }, !1, ["decrypt"]), yr = base64.decode(fr), kr = base64.decode(dr), _r = await crypto.subtle.decrypt({ name: "AES-CBC", iv: kr }, vr, yr);
  return utf8Decoder.decode(_r);
}
function getNormalizedX(lr) {
  return lr.slice(1, 33);
}
var nip05_exports = {};
__export(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch;
try {
  _fetch = fetch;
} catch (lr) {
}
function useFetchImplementation(lr) {
  _fetch = lr;
}
async function searchDomain(lr, ar = "") {
  try {
    return (await (await _fetch(`https://${lr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (cr) {
    return {};
  }
}
async function queryProfile(lr) {
  const ar = lr.match(NIP05_REGEX);
  if (!ar)
    return null;
  const [cr, ur = "_", fr] = ar;
  try {
    const dr = await _fetch(`https://${fr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result(await dr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (dr) {
    return null;
  }
}
function parseNIP05Result(lr) {
  const ar = {
    names: {}
  };
  for (const [cr, ur] of Object.entries(lr.names))
    typeof cr == "string" && typeof ur == "string" && (ar.names[cr] = ur);
  if (lr.relays) {
    ar.relays = {};
    for (const [cr, ur] of Object.entries(lr.relays))
      typeof cr == "string" && Array.isArray(ur) && (ar.relays[cr] = ur.filter((fr) => typeof fr == "string"));
  }
  return ar;
}
var nip10_exports = {};
__export(nip10_exports, {
  parse: () => parse
});
function parse(lr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, cr = [];
  for (const ur of lr.tags)
    ur[0] === "e" && ur[1] && cr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < cr.length; ur++) {
    const fr = cr[ur], [dr, gr, mr, vr] = fr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, kr = ur === 0, _r = ur === cr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (kr) {
      ar.root = yr;
      continue;
    }
    if (_r) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip11_exports = {};
__export(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch (lr) {
}
function useFetchImplementation2(lr) {
  _fetch2 = lr;
}
async function fetchRelayInformation(lr) {
  return await (await fetch(lr.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export(nip13_exports, {
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(lr) {
  let ar = 0;
  for (let cr = 0; cr < lr.length; cr++) {
    const ur = parseInt(lr[cr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow(lr, ar) {
  let cr = 0;
  const ur = lr, fr = ["nonce", cr.toString(), ar.toString()];
  for (ur.tags.push(fr); ; ) {
    const dr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (dr !== ur.created_at && (cr = 0, ur.created_at = dr), fr[1] = (++cr).toString(), ur.id = getEventHash(ur), getPow(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports = {};
__export(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(lr, ar, cr, ur) {
  var fr;
  return finalizeEvent(
    {
      kind: Repost,
      tags: [...(fr = lr.tags) != null ? fr : [], ["e", ar.id, cr], ["p", ar.pubkey]],
      content: lr.content === "" ? "" : JSON.stringify(ar),
      created_at: lr.created_at
    },
    ur
  );
}
function getRepostedEventPointer(lr) {
  if (lr.kind !== Repost)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], cr == null ? void 0 : cr[2]].filter((ur) => typeof ur == "string"),
      author: cr == null ? void 0 : cr[1]
    };
}
function getRepostedEvent(lr, { skipVerification: ar } = {}) {
  const cr = getRepostedEventPointer(lr);
  if (cr === void 0 || lr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(lr.content);
  } catch (fr) {
    return;
  }
  if (ur.id === cr.id && !(!ar && !verifyEvent(ur)))
    return ur;
}
var nip21_exports = {};
__export(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(lr) {
  return typeof lr == "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(lr);
}
function parse2(lr) {
  const ar = lr.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${lr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$1(ar[1])
  };
}
var nip25_exports = {};
__export(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(lr, ar, cr) {
  var fr, dr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finalizeEvent(
    {
      ...lr,
      kind: Reaction,
      tags: [...(fr = lr.tags) != null ? fr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (dr = lr.content) != null ? dr : "+"
    },
    cr
  );
}
function getReactedEventPointer(lr) {
  if (lr.kind !== Reaction)
    return;
  let ar, cr;
  for (let ur = lr.tags.length - 1; ur >= 0 && (ar === void 0 || cr === void 0); ur--) {
    const fr = lr.tags[ur];
    fr.length >= 2 && (fr[0] === "e" && ar === void 0 ? ar = fr : fr[0] === "p" && cr === void 0 && (cr = fr));
  }
  if (!(ar === void 0 || cr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], cr[2]].filter((ur) => ur !== void 0),
      author: cr[1]
    };
}
var nip27_exports = {};
__export(nip27_exports, {
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
function* matchAll(lr) {
  const ar = lr.matchAll(regex());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        uri: ur,
        value: fr,
        decoded: decode$1(fr),
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll(lr, ar) {
  return lr.replaceAll(regex(), (cr, ur) => ar({
    uri: cr,
    value: ur,
    decoded: decode$1(ur)
  }));
}
var nip28_exports = {};
__export(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMetadataEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", lr.channel_create_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMessageEvent = (lr, ar) => {
  var ur;
  const cr = [["e", lr.channel_create_event_id, lr.relay_url, "root"]];
  return lr.reply_to_channel_message_event_id && cr.push(["e", lr.reply_to_channel_message_event_id, lr.relay_url, "reply"]), finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...cr, ...(ur = lr.tags) != null ? ur : []],
      content: lr.content,
      created_at: lr.created_at
    },
    ar
  );
}, channelHideMessageEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", lr.channel_message_event_id], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, channelMuteUserEvent = (lr, ar) => {
  var ur;
  let cr;
  if (typeof lr.content == "object")
    cr = JSON.stringify(lr.content);
  else if (typeof lr.content == "string")
    cr = lr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", lr.pubkey_to_mute], ...(ur = lr.tags) != null ? ur : []],
      content: cr,
      created_at: lr.created_at
    },
    ar
  );
}, nip30_exports = {};
__export(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll2,
  regex: () => regex2,
  replaceAll: () => replaceAll2
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/, regex2 = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll2(lr) {
  const ar = lr.matchAll(regex2());
  for (const cr of ar)
    try {
      const [ur, fr] = cr;
      yield {
        shortcode: ur,
        name: fr,
        start: cr.index,
        end: cr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll2(lr, ar) {
  return lr.replaceAll(regex2(), (cr, ur) => ar({
    shortcode: cr,
    name: ur
  }));
}
var nip39_exports = {};
__export(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch (lr) {
}
function useFetchImplementation3(lr) {
  _fetch3 = lr;
}
async function validateGithub(lr, ar, cr) {
  try {
    return await (await _fetch3(`https://gist.github.com/${ar}/${cr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${lr}`;
  } catch (ur) {
    return !1;
  }
}
var nip44_exports = {};
__export(nip44_exports, {
  default: () => nip44_default,
  v2: () => v2
});
var decoder = new TextDecoder(), u = {
  minPlaintextSize: 1,
  maxPlaintextSize: 65535,
  utf8Encode: utf8ToBytes,
  utf8Decode(lr) {
    return decoder.decode(lr);
  },
  getConversationKey(lr, ar) {
    const cr = secp256k1.getSharedSecret(lr, "02" + ar).subarray(1, 33);
    return extract(sha256, cr, "nip44-v2");
  },
  getMessageKeys(lr, ar) {
    ensureBytes$1(lr, 32), ensureBytes$1(ar, 32);
    const cr = expand(sha256, lr, ar, 76);
    return {
      chacha_key: cr.subarray(0, 32),
      chacha_nonce: cr.subarray(32, 44),
      hmac_key: cr.subarray(44, 76)
    };
  },
  calcPaddedLen(lr) {
    if (!Number.isSafeInteger(lr) || lr < 1)
      throw new Error("expected positive integer");
    if (lr <= 32)
      return 32;
    const ar = 1 << Math.floor(Math.log2(lr - 1)) + 1, cr = ar <= 256 ? 32 : ar / 8;
    return cr * (Math.floor((lr - 1) / cr) + 1);
  },
  writeU16BE(lr) {
    if (!Number.isSafeInteger(lr) || lr < u.minPlaintextSize || lr > u.maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const ar = new Uint8Array(2);
    return new DataView(ar.buffer).setUint16(0, lr, !1), ar;
  },
  pad(lr) {
    const ar = u.utf8Encode(lr), cr = ar.length, ur = u.writeU16BE(cr), fr = new Uint8Array(u.calcPaddedLen(cr) - cr);
    return concatBytes(ur, ar, fr);
  },
  unpad(lr) {
    const ar = new DataView(lr.buffer).getUint16(0), cr = lr.subarray(2, 2 + ar);
    if (ar < u.minPlaintextSize || ar > u.maxPlaintextSize || cr.length !== ar || lr.length !== 2 + u.calcPaddedLen(ar))
      throw new Error("invalid padding");
    return u.utf8Decode(cr);
  },
  hmacAad(lr, ar, cr) {
    if (cr.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const ur = concatBytes(cr, ar);
    return hmac(sha256, lr, ur);
  },
  decodePayload(lr) {
    if (typeof lr != "string")
      throw new Error("payload must be a valid string");
    const ar = lr.length;
    if (ar < 132 || ar > 87472)
      throw new Error("invalid payload length: " + ar);
    if (lr[0] === "#")
      throw new Error("unknown encryption version");
    let cr;
    try {
      cr = base64.decode(lr);
    } catch (dr) {
      throw new Error("invalid base64: " + dr.message);
    }
    const ur = cr.length;
    if (ur < 99 || ur > 65603)
      throw new Error("invalid data length: " + ur);
    const fr = cr[0];
    if (fr !== 2)
      throw new Error("unknown encryption version " + fr);
    return {
      nonce: cr.subarray(1, 33),
      ciphertext: cr.subarray(33, -32),
      mac: cr.subarray(-32)
    };
  }
};
function encrypt2(lr, ar, cr = randomBytes(32)) {
  const { chacha_key: ur, chacha_nonce: fr, hmac_key: dr } = u.getMessageKeys(ar, cr), gr = u.pad(lr), mr = chacha20(ur, fr, gr), vr = u.hmacAad(dr, mr, cr);
  return base64.encode(concatBytes(new Uint8Array([2]), cr, mr, vr));
}
function decrypt2(lr, ar) {
  const { nonce: cr, ciphertext: ur, mac: fr } = u.decodePayload(lr), { chacha_key: dr, chacha_nonce: gr, hmac_key: mr } = u.getMessageKeys(ar, cr), vr = u.hmacAad(mr, ur, cr);
  if (!equalBytes$1(vr, fr))
    throw new Error("invalid MAC");
  const yr = chacha20(dr, gr, ur);
  return u.unpad(yr);
}
var v2 = {
  utils: u,
  encrypt: encrypt2,
  decrypt: decrypt2
}, nip44_default = { v2 }, nip47_exports = {};
__export(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(lr) {
  const { pathname: ar, searchParams: cr } = new URL(lr), ur = ar, fr = cr.get("relay"), dr = cr.get("secret");
  if (!ur || !fr || !dr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: fr, secret: dr };
}
async function makeNwcRequestEvent(lr, ar, cr) {
  const fr = await encrypt(ar, lr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: cr
    }
  })), dr = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [["p", lr]]
  };
  return finalizeEvent(dr, ar);
}
var nip57_exports = {};
__export(nip57_exports, {
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch (lr) {
}
function useFetchImplementation4(lr) {
  _fetch4 = lr;
}
async function getZapEndpoint(lr) {
  try {
    let ar = "", { lud06: cr, lud16: ur } = JSON.parse(lr.content);
    if (cr) {
      let { words: gr } = bech32.decode(cr, 1e3), mr = bech32.fromWords(gr);
      ar = utf8Decoder.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = new URL(`/.well-known/lnurlp/${gr}`, `https://${mr}`).toString();
    } else
      return null;
    let dr = await (await _fetch4(ar)).json();
    if (dr.allowsNostr && dr.nostrPubkey)
      return dr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest({
  profile: lr,
  event: ar,
  amount: cr,
  relays: ur,
  comment: fr = ""
}) {
  if (!cr)
    throw new Error("amount not given");
  if (!lr)
    throw new Error("profile not given");
  let dr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: fr,
    tags: [
      ["p", lr],
      ["amount", cr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && dr.tags.push(["e", ar]), dr;
}
function validateZapRequest(lr) {
  let ar;
  try {
    ar = JSON.parse(lr);
  } catch (dr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(ar))
    return "Invalid signature on zap request.";
  let cr = ar.tags.find(([dr, gr]) => dr === "p" && gr);
  if (!cr)
    return "Zap request doesn't have a 'p' tag.";
  if (!cr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([dr, gr]) => dr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([dr, gr]) => dr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt({
  zapRequest: lr,
  preimage: ar,
  bolt11: cr,
  paidAt: ur
}) {
  let fr = JSON.parse(lr), dr = fr.tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...dr, ["P", fr.pubkey], ["bolt11", cr], ["description", lr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports = {};
__export(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(lr, ar, cr, ur = !1, fr) {
  const dr = {
    kind: HTTPAuth,
    tags: [
      ["u", lr],
      ["method", ar]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  fr && dr.tags.push(["payload", hashPayload(fr)]);
  const gr = await cr(dr);
  return (ur ? _authorizationScheme : "") + base64.encode(utf8Encoder.encode(JSON.stringify(gr)));
}
async function validateToken(lr, ar, cr) {
  const ur = await unpackEventFromToken(lr).catch((dr) => {
    throw dr;
  });
  return await validateEvent2(ur, ar, cr).catch((dr) => {
    throw dr;
  });
}
async function unpackEventFromToken(lr) {
  if (!lr)
    throw new Error("Missing token");
  lr = lr.replace(_authorizationScheme, "");
  const ar = utf8Decoder.decode(base64.decode(lr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
function validateEventTimestamp(lr) {
  return lr.created_at ? Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - lr.created_at < 60 : !1;
}
function validateEventKind(lr) {
  return lr.kind === HTTPAuth;
}
function validateEventUrlTag(lr, ar) {
  const cr = lr.tags.find((ur) => ur[0] === "u");
  return cr ? cr.length > 0 && cr[1] === ar : !1;
}
function validateEventMethodTag(lr, ar) {
  const cr = lr.tags.find((ur) => ur[0] === "method");
  return cr ? cr.length > 0 && cr[1].toLowerCase() === ar.toLowerCase() : !1;
}
function hashPayload(lr) {
  const ar = sha256(utf8Encoder.encode(JSON.stringify(lr)));
  return bytesToHex(ar);
}
function validateEventPayloadTag(lr, ar) {
  const cr = lr.tags.find((fr) => fr[0] === "payload");
  if (!cr)
    return !1;
  const ur = hashPayload(ar);
  return cr.length > 0 && cr[1] === ur;
}
async function validateEvent2(lr, ar, cr, ur) {
  if (!verifyEvent(lr))
    throw new Error("Invalid nostr event, signature invalid");
  if (!validateEventKind(lr))
    throw new Error("Invalid nostr event, kind invalid");
  if (!validateEventTimestamp(lr))
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  if (!validateEventUrlTag(lr, ar))
    throw new Error("Invalid nostr event, url tag invalid");
  if (!validateEventMethodTag(lr, cr))
    throw new Error("Invalid nostr event, method tag invalid");
  if (ur && typeof ur == "object" && Object.keys(ur).length > 0 && !validateEventPayloadTag(lr, ur))
    throw new Error("Invalid nostr event, payload tag does not match request body hash");
  return !0;
}
function add_css$a(lr) {
  append_styles(lr, "svelte-1xutw13", 'h3.svelte-1xutw13.svelte-1xutw13,h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13,input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13,button.svelte-1xutw13.svelte-1xutw13{font-family:sans-serif}h3.svelte-1xutw13.svelte-1xutw13{font-size:1.5em;color:#767676;margin-top:0}form.svelte-1xutw13.svelte-1xutw13{padding-right:1.5rem}h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13{color:#767676}input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13{color:#333;background-color:#f8f8f8;margin-bottom:1em;width:100%;display:block;border:1px solid #888;padding:0.5em;font-size:1.1em;border-radius:0.3rem}input[type="text"].svelte-1xutw13.svelte-1xutw13{height:50px}textarea.svelte-1xutw13.svelte-1xutw13{height:120px}button.svelte-1xutw13.svelte-1xutw13{background-color:#4DA84D;color:white;border:none;padding:12px 18px;cursor:pointer;font-size:1.1em;border-radius:5px}.copy-key-button.svelte-1xutw13.svelte-1xutw13,.continue-button.svelte-1xutw13.svelte-1xutw13{margin-top:0.5em}.continue-button.svelte-1xutw13.svelte-1xutw13{background-color:#6c757d;border:2px solid #565e66}.key-container.svelte-1xutw13.svelte-1xutw13{background-color:#eaeaea;padding:1em;border-radius:4px;border:1px solid #ccc}.key-container.svelte-1xutw13 input.svelte-1xutw13{background-color:#fff;border:1px solid #888;border-radius:4px;padding:1em;width:100%;box-sizing:border-box;font-size:1.1em}');
}
function create_else_block$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr;
  return {
    c() {
      ar = element("div"), cr = element("p"), cr.innerHTML = "We use <strong>Nostr</strong> to store opinions. You can post and access your posts via your unique private key. Copy your key and keep it in a safe place.", ur = space(), fr = element("div"), dr = element("input"), gr = space(), mr = element("button"), mr.textContent = "Copy my key", vr = space(), yr = element("button"), yr.textContent = "Continue", attr(cr, "class", "svelte-1xutw13"), attr(dr, "id", "privkey"), attr(dr, "type", "text"), dr.readOnly = !0, attr(dr, "class", "svelte-1xutw13"), attr(mr, "class", "copy-key-button svelte-1xutw13"), attr(fr, "class", "key-container svelte-1xutw13"), attr(yr, "class", "continue-button svelte-1xutw13");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, cr), append(ar, ur), append(ar, fr), append(fr, dr), set_input_value(
        dr,
        /*nsec*/
        lr[0]
      ), append(fr, gr), append(fr, mr), append(ar, vr), append(ar, yr), _r = !0, xr || (Sr = [
        listen(
          dr,
          "input",
          /*input_input_handler*/
          lr[12]
        ),
        listen(
          mr,
          "click",
          /*copyToClipboard*/
          lr[6]
        ),
        listen(
          yr,
          "click",
          /*click_handler*/
          lr[13]
        )
      ], xr = !0);
    },
    p(Er, Cr) {
      Cr & /*nsec*/
      1 && dr.value !== /*nsec*/
      Er[0] && set_input_value(
        dr,
        /*nsec*/
        Er[0]
      );
    },
    i(Er) {
      _r || (Er && add_render_callback(() => {
        _r && (kr || (kr = create_bidirectional_transition(ar, slide, {}, !0)), kr.run(1));
      }), _r = !0);
    },
    o(Er) {
      Er && (kr || (kr = create_bidirectional_transition(ar, slide, {}, !1)), kr.run(0)), _r = !1;
    },
    d(Er) {
      Er && detach(ar), Er && kr && kr.end(), xr = !1, run_all(Sr);
    }
  };
}
function create_if_block$4(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr;
  return {
    c() {
      ar = element("form"), cr = element("h2"), cr.textContent = "Set up your profile", ur = space(), fr = element("p"), fr.textContent = "This information will be shown with your comments. To upload images, use a service like Piccy.", dr = space(), gr = element("input"), mr = space(), vr = element("textarea"), yr = space(), kr = element("input"), _r = space(), xr = element("button"), xr.textContent = "Save profile", attr(cr, "class", "svelte-1xutw13"), attr(fr, "class", "svelte-1xutw13"), attr(gr, "type", "text"), attr(gr, "placeholder", "Enter your name..."), gr.required = !0, attr(gr, "class", "svelte-1xutw13"), attr(vr, "placeholder", "Share a bit about yourself..."), vr.required = !0, attr(vr, "class", "svelte-1xutw13"), attr(kr, "type", "text"), attr(kr, "placeholder", "Link to a profile image..."), attr(kr, "class", "svelte-1xutw13"), attr(xr, "type", "submit"), attr(xr, "class", "svelte-1xutw13"), attr(ar, "class", "svelte-1xutw13");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), append(ar, gr), set_input_value(
        gr,
        /*name*/
        lr[2]
      ), append(ar, mr), append(ar, vr), set_input_value(
        vr,
        /*about*/
        lr[3]
      ), append(ar, yr), append(ar, kr), set_input_value(
        kr,
        /*imageUrl*/
        lr[4]
      ), append(ar, _r), append(ar, xr), Er = !0, Cr || (Tr = [
        listen(
          gr,
          "input",
          /*input0_input_handler*/
          lr[9]
        ),
        listen(
          vr,
          "input",
          /*textarea_input_handler*/
          lr[10]
        ),
        listen(
          kr,
          "input",
          /*input1_input_handler*/
          lr[11]
        ),
        listen(ar, "submit", prevent_default(
          /*saveProfile*/
          lr[5]
        ))
      ], Cr = !0);
    },
    p(Ar, Ir) {
      Ir & /*name*/
      4 && gr.value !== /*name*/
      Ar[2] && set_input_value(
        gr,
        /*name*/
        Ar[2]
      ), Ir & /*about*/
      8 && set_input_value(
        vr,
        /*about*/
        Ar[3]
      ), Ir & /*imageUrl*/
      16 && kr.value !== /*imageUrl*/
      Ar[4] && set_input_value(
        kr,
        /*imageUrl*/
        Ar[4]
      );
    },
    i(Ar) {
      Er || (Ar && add_render_callback(() => {
        Er && (Sr || (Sr = create_bidirectional_transition(ar, slide, {}, !0)), Sr.run(1));
      }), Er = !0);
    },
    o(Ar) {
      Ar && (Sr || (Sr = create_bidirectional_transition(ar, slide, {}, !1)), Sr.run(0)), Er = !1;
    },
    d(Ar) {
      Ar && detach(ar), Ar && Sr && Sr.end(), Cr = !1, run_all(Tr);
    }
  };
}
function create_fragment$k(lr) {
  let ar, cr, ur, fr, dr;
  const gr = [create_if_block$4, create_else_block$3], mr = [];
  function vr(yr, kr) {
    return (
      /*showProfileSetup*/
      yr[1] ? 0 : 1
    );
  }
  return ur = vr(lr), fr = mr[ur] = gr[ur](lr), {
    c() {
      ar = element("h3"), ar.textContent = "Register", cr = space(), fr.c(), dr = empty$1(), attr(ar, "class", "svelte-1xutw13");
    },
    m(yr, kr) {
      insert(yr, ar, kr), insert(yr, cr, kr), mr[ur].m(yr, kr), insert(yr, dr, kr);
    },
    p(yr, [kr]) {
      let _r = ur;
      ur = vr(yr), ur === _r ? mr[ur].p(yr, kr) : (group_outros(), transition_out(mr[_r], 1, 1, () => {
        mr[_r] = null;
      }), check_outros(), fr = mr[ur], fr ? fr.p(yr, kr) : (fr = mr[ur] = gr[ur](yr), fr.c()), transition_in(fr, 1), fr.m(dr.parentNode, dr));
    },
    i(yr) {
      transition_in(fr);
    },
    o(yr) {
      transition_out(fr);
    },
    d(yr) {
      yr && (detach(ar), detach(cr), detach(dr)), mr[ur].d(yr);
    }
  };
}
let pubkey = "";
function instance$b(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkUser, (Br) => cr(16, ur = Br)), component_subscribe(lr, ndkStore, (Br) => cr(17, fr = Br));
  let dr = "", gr = "", mr = !1, vr = "", yr = "", kr = "", _r, { profiles: xr = {} } = ar, { showNewOpinion: Sr } = ar;
  onMount(() => {
    _r = NDKPrivateKeySigner.generate(), gr = _r.privateKey, cr(0, dr = nip19_exports.nsecEncode(hexToBytes$2(gr)));
  });
  const Er = async () => {
    if (!dr)
      return;
    (kr == "" || !kr) && cr(4, kr = profileImageUrl + pubkey);
    const Br = { name: vr, about: yr, image: kr, pubkey: "" };
    set_store_value(ndkStore, fr.signer = _r, fr), set_store_value(ndkUser, ur = await fr.signer.user(), ur), set_store_value(ndkUser, ur.ndk = fr, ur);
    let zr = Br;
    zr = { ...zr, pubkey: ur.pubkey }, set_store_value(ndkUser, ur.profile = Br, ur), cr(7, xr[ur.pubkey] = { content: zr }, xr), cr(8, Sr = !1), await ur.publish(), await privkeyLogin(gr);
  }, Cr = () => {
    navigator.clipboard.writeText(dr).then(
      () => {
        alert("Private Key copied");
      },
      (Br) => {
        console.error("Could not copy text: ", Br);
      }
    );
  };
  function Tr() {
    vr = this.value, cr(2, vr);
  }
  function Ar() {
    yr = this.value, cr(3, yr);
  }
  function Ir() {
    kr = this.value, cr(4, kr);
  }
  function Mr() {
    dr = this.value, cr(0, dr);
  }
  const Hr = () => cr(1, mr = !mr);
  return lr.$$set = (Br) => {
    "profiles" in Br && cr(7, xr = Br.profiles), "showNewOpinion" in Br && cr(8, Sr = Br.showNewOpinion);
  }, [
    dr,
    mr,
    vr,
    yr,
    kr,
    Er,
    Cr,
    xr,
    Sr,
    Tr,
    Ar,
    Ir,
    Mr,
    Hr
  ];
}
class Register extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$b, create_fragment$k, safe_not_equal, { profiles: 7, showNewOpinion: 8 }, add_css$a);
  }
  get profiles() {
    return this.$$.ctx[7];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[8];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
create_custom_element(Register, { profiles: {}, showNewOpinion: {} }, [], [], !0);
function add_css$9(lr) {
  append_styles(lr, "svelte-19w231", ".container.svelte-19w231{max-width:600px;text-align:left;font-family:sans-serif}.heading.svelte-19w231{font-size:24px;margin-bottom:8px}.text.svelte-19w231{margin-bottom:24px}.input.svelte-19w231{padding:10px;margin-bottom:16px;border:2px solid #ccc;border-radius:4px;width:100%;display:block}.button.svelte-19w231{background-color:#4DA84D;color:white;border:none;font-size:16px;cursor:pointer;padding:10px;margin-bottom:16px}");
}
function create_else_block$2(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr = window && create_if_block_1$2(lr);
  return {
    c() {
      ar = element("div"), cr = element("h2"), cr.textContent = "Log in", ur = space(), fr = element("p"), fr.innerHTML = `You have two options to log in. You can connect with an authentication tool like Alby that
				supports Nostr. Or you can enter your private key (<a href="/" class="text svelte-19w231">view associated risks</a>).`, dr = space(), kr && kr.c(), gr = space(), mr = element("button"), mr.textContent = "Connect using private key", attr(cr, "class", "heading svelte-19w231"), attr(fr, "class", "text svelte-19w231"), attr(mr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(_r, xr) {
      insert(_r, ar, xr), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), kr && kr.m(ar, null), append(ar, gr), append(ar, mr), vr || (yr = listen(
        mr,
        "click",
        /*click_handler_2*/
        lr[10]
      ), vr = !0);
    },
    p(_r, xr) {
      window && kr.p(_r, xr);
    },
    i: noop$1,
    o: noop$1,
    d(_r) {
      _r && detach(ar), kr && kr.d(), vr = !1, yr();
    }
  };
}
function create_if_block$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr;
  return {
    c() {
      ar = element("div"), cr = element("h2"), cr.textContent = "Log in", ur = space(), fr = element("p"), fr.innerHTML = `Enter your <strong>Nostr</strong> private key below to be able to post an opinion.<br/>
				Don&#39;t have a key? <a href="/" class="text svelte-19w231">Register</a>.`, dr = space(), gr = element("input"), mr = space(), vr = element("button"), vr.textContent = "Log in", attr(cr, "class", "heading svelte-19w231"), attr(fr, "class", "text svelte-19w231"), attr(gr, "id", "privkey"), attr(gr, "type", "text"), attr(gr, "placeholder", "Your private key..."), attr(gr, "class", "input svelte-19w231"), attr(vr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(Sr, Er) {
      insert(Sr, ar, Er), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), append(ar, gr), set_input_value(
        gr,
        /*nsec*/
        lr[1]
      ), append(ar, mr), append(ar, vr), kr = !0, _r || (xr = [
        listen(
          gr,
          "input",
          /*input_input_handler*/
          lr[7]
        ),
        listen(
          vr,
          "click",
          /*click_handler*/
          lr[8]
        )
      ], _r = !0);
    },
    p(Sr, Er) {
      Er & /*nsec*/
      2 && gr.value !== /*nsec*/
      Sr[1] && set_input_value(
        gr,
        /*nsec*/
        Sr[1]
      );
    },
    i(Sr) {
      kr || (Sr && add_render_callback(() => {
        kr && (yr || (yr = create_bidirectional_transition(ar, slide, {}, !0)), yr.run(1));
      }), kr = !0);
    },
    o(Sr) {
      Sr && (yr || (yr = create_bidirectional_transition(ar, slide, {}, !1)), yr.run(0)), kr = !1;
    },
    d(Sr) {
      Sr && detach(ar), Sr && yr && yr.end(), _r = !1, run_all(xr);
    }
  };
}
function create_if_block_1$2(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = element("button"), ar.textContent = "Connect using browser extension", attr(ar, "class", "button svelte-19w231");
    },
    m(fr, dr) {
      insert(fr, ar, dr), cr || (ur = listen(
        ar,
        "click",
        /*click_handler_1*/
        lr[9]
      ), cr = !0);
    },
    p: noop$1,
    d(fr) {
      fr && detach(ar), cr = !1, ur();
    }
  };
}
function create_fragment$j(lr) {
  let ar, cr, ur, fr, dr;
  const gr = [create_if_block$3, create_else_block$2], mr = [];
  function vr(yr, kr) {
    return (
      /*showPrivateKeyInput*/
      yr[0] ? 0 : 1
    );
  }
  return cr = vr(lr), ur = mr[cr] = gr[cr](lr), {
    c() {
      ar = element("div"), ur.c();
    },
    m(yr, kr) {
      insert(yr, ar, kr), mr[cr].m(ar, null), dr = !0;
    },
    p(yr, [kr]) {
      let _r = cr;
      cr = vr(yr), cr === _r ? mr[cr].p(yr, kr) : (group_outros(), transition_out(mr[_r], 1, 1, () => {
        mr[_r] = null;
      }), check_outros(), ur = mr[cr], ur ? ur.p(yr, kr) : (ur = mr[cr] = gr[cr](yr), ur.c()), transition_in(ur, 1), ur.m(ar, null));
    },
    i(yr) {
      dr || (transition_in(ur), yr && add_render_callback(() => {
        dr && (fr || (fr = create_bidirectional_transition(ar, slide, {}, !0)), fr.run(1));
      }), dr = !0);
    },
    o(yr) {
      transition_out(ur), yr && (fr || (fr = create_bidirectional_transition(ar, slide, {}, !1)), fr.run(0)), dr = !1;
    },
    d(yr) {
      yr && detach(ar), mr[cr].d(), yr && fr && fr.end();
    }
  };
}
function instance$a(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkUser, (Tr) => cr(11, ur = Tr)), component_subscribe(lr, ndkStore, (Tr) => cr(12, fr = Tr));
  let dr = !1, gr = "", { profiles: mr = {} } = ar, { opinionContent: vr } = ar, { subject: yr } = ar, { showNewOpinion: kr } = ar;
  const _r = async (Tr) => {
    if (!Tr)
      return;
    let Ar;
    switch (Tr) {
      case "pk":
        Ar = await privkeyLogin(nip19_exports.decode(gr).data);
        break;
      case "nip07":
        Ar = await NDKlogin();
        break;
    }
    if (!Ar) {
      console.log("Something went wrong while login!!");
      return;
    }
    if (!ur) {
      console.log("Can't proceed. $ndkUser is null");
      return;
    }
    let Ir = await fetchUserProfile(ur.pubkey);
    Ir || (Ir = {
      image: profileImageUrl + ur.pubkey,
      pubkey: ur.pubkey
    }), Ir.image || (Ir.image = profileImageUrl + ur.pubkey), Ir.pubkey || (Ir.pubkey = ur.pubkey), cr(5, kr = !1);
    const Mr = {
      kinds: [kindOpinion],
      "#d": [yr],
      authors: [ur.pubkey]
    };
    let Hr = await fr.fetchEvent(Mr, { closeOnEose: !0 });
    cr(3, mr[ur.pubkey] = { content: Ir }, mr), Hr && Hr.content && cr(4, vr = Hr.content);
  };
  function xr() {
    gr = this.value, cr(1, gr);
  }
  const Sr = () => {
    _r("pk");
  }, Er = () => {
    _r("nip07");
  }, Cr = () => cr(0, dr = !dr);
  return lr.$$set = (Tr) => {
    "profiles" in Tr && cr(3, mr = Tr.profiles), "opinionContent" in Tr && cr(4, vr = Tr.opinionContent), "subject" in Tr && cr(6, yr = Tr.subject), "showNewOpinion" in Tr && cr(5, kr = Tr.showNewOpinion);
  }, [
    dr,
    gr,
    _r,
    mr,
    vr,
    kr,
    yr,
    xr,
    Sr,
    Er,
    Cr
  ];
}
class Login extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$a,
      create_fragment$j,
      safe_not_equal,
      {
        profiles: 3,
        opinionContent: 4,
        subject: 6,
        showNewOpinion: 5
      },
      add_css$9
    );
  }
  get profiles() {
    return this.$$.ctx[3];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[4];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[6];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[5];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
customElements.define("nostr-opinion-login", create_custom_element(Login, { profiles: {}, opinionContent: {}, subject: {}, showNewOpinion: {} }, [], [], !0));
var dist$7 = {}, dist$6, hasRequiredDist$6;
function requireDist$6() {
  if (hasRequiredDist$6)
    return dist$6;
  hasRequiredDist$6 = 1;
  function lr(ar) {
    this.content = ar;
  }
  return lr.prototype = {
    constructor: lr,
    find: function(ar) {
      for (var cr = 0; cr < this.content.length; cr += 2)
        if (this.content[cr] === ar)
          return cr;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(ar) {
      var cr = this.find(ar);
      return cr == -1 ? void 0 : this.content[cr + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(ar, cr, ur) {
      var fr = ur && ur != ar ? this.remove(ur) : this, dr = fr.find(ar), gr = fr.content.slice();
      return dr == -1 ? gr.push(ur || ar, cr) : (gr[dr + 1] = cr, ur && (gr[dr] = ur)), new lr(gr);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(ar) {
      var cr = this.find(ar);
      if (cr == -1)
        return this;
      var ur = this.content.slice();
      return ur.splice(cr, 2), new lr(ur);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(ar, cr) {
      return new lr([ar, cr].concat(this.remove(ar).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(ar, cr) {
      var ur = this.remove(ar).content.slice();
      return ur.push(ar, cr), new lr(ur);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(ar, cr, ur) {
      var fr = this.remove(cr), dr = fr.content.slice(), gr = fr.find(ar);
      return dr.splice(gr == -1 ? dr.length : gr, 0, cr, ur), new lr(dr);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(ar) {
      for (var cr = 0; cr < this.content.length; cr += 2)
        ar(this.content[cr], this.content[cr + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(ar) {
      return ar = lr.from(ar), ar.size ? new lr(ar.content.concat(this.subtract(ar).content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(ar) {
      return ar = lr.from(ar), ar.size ? new lr(this.subtract(ar).content.concat(ar.content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(ar) {
      var cr = this;
      ar = lr.from(ar);
      for (var ur = 0; ur < ar.content.length; ur += 2)
        cr = cr.remove(ar.content[ur]);
      return cr;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var ar = {};
      return this.forEach(function(cr, ur) {
        ar[cr] = ur;
      }), ar;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  }, lr.from = function(ar) {
    if (ar instanceof lr)
      return ar;
    var cr = [];
    if (ar)
      for (var ur in ar)
        cr.push(ur, ar[ur]);
    return new lr(cr);
  }, dist$6 = lr, dist$6;
}
var hasRequiredDist$5;
function requireDist$5() {
  if (hasRequiredDist$5)
    return dist$7;
  hasRequiredDist$5 = 1;
  function lr(ci, ti) {
    return dr(ci) || fr(ci, ti) || cr(ci, ti) || ar();
  }
  function ar() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function cr(ci, ti) {
    if (ci) {
      if (typeof ci == "string")
        return ur(ci, ti);
      var Ur = Object.prototype.toString.call(ci).slice(8, -1);
      if (Ur === "Object" && ci.constructor && (Ur = ci.constructor.name), Ur === "Map" || Ur === "Set")
        return Array.from(ci);
      if (Ur === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Ur))
        return ur(ci, ti);
    }
  }
  function ur(ci, ti) {
    (ti == null || ti > ci.length) && (ti = ci.length);
    for (var Ur = 0, qr = new Array(ti); Ur < ti; Ur++)
      qr[Ur] = ci[Ur];
    return qr;
  }
  function fr(ci, ti) {
    var Ur = ci == null ? null : typeof Symbol != "undefined" && ci[Symbol.iterator] || ci["@@iterator"];
    if (Ur != null) {
      var qr = [], Yr = !0, si = !1, yi, Ii;
      try {
        for (Ur = Ur.call(ci); !(Yr = (yi = Ur.next()).done) && (qr.push(yi.value), !(ti && qr.length === ti)); Yr = !0)
          ;
      } catch (Ki) {
        si = !0, Ii = Ki;
      } finally {
        try {
          !Yr && Ur.return != null && Ur.return();
        } finally {
          if (si)
            throw Ii;
        }
      }
      return qr;
    }
  }
  function dr(ci) {
    if (Array.isArray(ci))
      return ci;
  }
  function gr() {
    return typeof Reflect != "undefined" && Reflect.get ? gr = Reflect.get : gr = function(ti, Ur, qr) {
      var Yr = mr(ti, Ur);
      if (Yr) {
        var si = Object.getOwnPropertyDescriptor(Yr, Ur);
        return si.get ? si.get.call(arguments.length < 3 ? ti : qr) : si.value;
      }
    }, gr.apply(this, arguments);
  }
  function mr(ci, ti) {
    for (; !Object.prototype.hasOwnProperty.call(ci, ti) && (ci = Ar(ci), ci !== null); )
      ;
    return ci;
  }
  function vr(ci, ti) {
    if (typeof ti != "function" && ti !== null)
      throw new TypeError("Super expression must either be null or a function");
    ci.prototype = Object.create(ti && ti.prototype, { constructor: { value: ci, writable: !0, configurable: !0 } }), Object.defineProperty(ci, "prototype", { writable: !1 }), ti && Tr(ci, ti);
  }
  function yr(ci) {
    var ti = Er();
    return function() {
      var qr = Ar(ci), Yr;
      if (ti) {
        var si = Ar(this).constructor;
        Yr = Reflect.construct(qr, arguments, si);
      } else
        Yr = qr.apply(this, arguments);
      return kr(this, Yr);
    };
  }
  function kr(ci, ti) {
    if (ti && (Br(ti) === "object" || typeof ti == "function"))
      return ti;
    if (ti !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _r(ci);
  }
  function _r(ci) {
    if (ci === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return ci;
  }
  function xr(ci) {
    var ti = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return xr = function(qr) {
      if (qr === null || !Cr(qr))
        return qr;
      if (typeof qr != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof ti != "undefined") {
        if (ti.has(qr))
          return ti.get(qr);
        ti.set(qr, Yr);
      }
      function Yr() {
        return Sr(qr, arguments, Ar(this).constructor);
      }
      return Yr.prototype = Object.create(qr.prototype, { constructor: { value: Yr, enumerable: !1, writable: !0, configurable: !0 } }), Tr(Yr, qr);
    }, xr(ci);
  }
  function Sr(ci, ti, Ur) {
    return Er() ? Sr = Reflect.construct : Sr = function(Yr, si, yi) {
      var Ii = [null];
      Ii.push.apply(Ii, si);
      var Ki = Function.bind.apply(Yr, Ii), ta = new Ki();
      return yi && Tr(ta, yi.prototype), ta;
    }, Sr.apply(null, arguments);
  }
  function Er() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (ci) {
      return !1;
    }
  }
  function Cr(ci) {
    return Function.toString.call(ci).indexOf("[native code]") !== -1;
  }
  function Tr(ci, ti) {
    return Tr = Object.setPrototypeOf || function(qr, Yr) {
      return qr.__proto__ = Yr, qr;
    }, Tr(ci, ti);
  }
  function Ar(ci) {
    return Ar = Object.setPrototypeOf ? Object.getPrototypeOf : function(Ur) {
      return Ur.__proto__ || Object.getPrototypeOf(Ur);
    }, Ar(ci);
  }
  function Ir(ci, ti) {
    if (!(ci instanceof ti))
      throw new TypeError("Cannot call a class as a function");
  }
  function Mr(ci, ti) {
    for (var Ur = 0; Ur < ti.length; Ur++) {
      var qr = ti[Ur];
      qr.enumerable = qr.enumerable || !1, qr.configurable = !0, "value" in qr && (qr.writable = !0), Object.defineProperty(ci, qr.key, qr);
    }
  }
  function Hr(ci, ti, Ur) {
    return ti && Mr(ci.prototype, ti), Ur && Mr(ci, Ur), Object.defineProperty(ci, "prototype", { writable: !1 }), ci;
  }
  function Br(ci) {
    "@babel/helpers - typeof";
    return Br = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ti) {
      return typeof ti;
    } : function(ti) {
      return ti && typeof Symbol == "function" && ti.constructor === Symbol && ti !== Symbol.prototype ? "symbol" : typeof ti;
    }, Br(ci);
  }
  Object.defineProperty(dist$7, "__esModule", {
    value: !0
  });
  var zr = requireDist$6();
  function Gr(ci) {
    return ci && Br(ci) === "object" && "default" in ci ? ci : {
      default: ci
    };
  }
  var Xr = Gr(zr);
  function Jr(ci, ti, Ur) {
    for (var qr = 0; ; qr++) {
      if (qr == ci.childCount || qr == ti.childCount)
        return ci.childCount == ti.childCount ? null : Ur;
      var Yr = ci.child(qr), si = ti.child(qr);
      if (Yr == si) {
        Ur += Yr.nodeSize;
        continue;
      }
      if (!Yr.sameMarkup(si))
        return Ur;
      if (Yr.isText && Yr.text != si.text) {
        for (var yi = 0; Yr.text[yi] == si.text[yi]; yi++)
          Ur++;
        return Ur;
      }
      if (Yr.content.size || si.content.size) {
        var Ii = Jr(Yr.content, si.content, Ur + 1);
        if (Ii != null)
          return Ii;
      }
      Ur += Yr.nodeSize;
    }
  }
  function li(ci, ti, Ur, qr) {
    for (var Yr = ci.childCount, si = ti.childCount; ; ) {
      if (Yr == 0 || si == 0)
        return Yr == si ? null : {
          a: Ur,
          b: qr
        };
      var yi = ci.child(--Yr), Ii = ti.child(--si), Ki = yi.nodeSize;
      if (yi == Ii) {
        Ur -= Ki, qr -= Ki;
        continue;
      }
      if (!yi.sameMarkup(Ii))
        return {
          a: Ur,
          b: qr
        };
      if (yi.isText && yi.text != Ii.text) {
        for (var ta = 0, va = Math.min(yi.text.length, Ii.text.length); ta < va && yi.text[yi.text.length - ta - 1] == Ii.text[Ii.text.length - ta - 1]; )
          ta++, Ur--, qr--;
        return {
          a: Ur,
          b: qr
        };
      }
      if (yi.content.size || Ii.content.size) {
        var ua = li(yi.content, Ii.content, Ur - 1, qr - 1);
        if (ua)
          return ua;
      }
      Ur -= Ki, qr -= Ki;
    }
  }
  var Qr = function() {
    function ci(ti, Ur) {
      if (Ir(this, ci), this.content = ti, this.size = Ur || 0, Ur == null)
        for (var qr = 0; qr < ti.length; qr++)
          this.size += ti[qr].nodeSize;
    }
    return Hr(ci, [{
      key: "nodesBetween",
      value: function(Ur, qr, Yr) {
        for (var si = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, yi = arguments.length > 4 ? arguments[4] : void 0, Ii = 0, Ki = 0; Ki < qr; Ii++) {
          var ta = this.content[Ii], va = Ki + ta.nodeSize;
          if (va > Ur && Yr(ta, si + Ki, yi || null, Ii) !== !1 && ta.content.size) {
            var ua = Ki + 1;
            ta.nodesBetween(Math.max(0, Ur - ua), Math.min(ta.content.size, qr - ua), Yr, si + ua);
          }
          Ki = va;
        }
      }
    }, {
      key: "descendants",
      value: function(Ur) {
        this.nodesBetween(0, this.size, Ur);
      }
    }, {
      key: "textBetween",
      value: function(Ur, qr, Yr, si) {
        var yi = "", Ii = !0;
        return this.nodesBetween(Ur, qr, function(Ki, ta) {
          Ki.isText ? (yi += Ki.text.slice(Math.max(Ur, ta) - ta, qr - ta), Ii = !Yr) : Ki.isLeaf ? (si ? yi += typeof si == "function" ? si(Ki) : si : Ki.type.spec.leafText && (yi += Ki.type.spec.leafText(Ki)), Ii = !Yr) : !Ii && Ki.isBlock && (yi += Yr, Ii = !0);
        }, 0), yi;
      }
    }, {
      key: "append",
      value: function(Ur) {
        if (!Ur.size)
          return this;
        if (!this.size)
          return Ur;
        var qr = this.lastChild, Yr = Ur.firstChild, si = this.content.slice(), yi = 0;
        for (qr.isText && qr.sameMarkup(Yr) && (si[si.length - 1] = qr.withText(qr.text + Yr.text), yi = 1); yi < Ur.content.length; yi++)
          si.push(Ur.content[yi]);
        return new ci(si, this.size + Ur.size);
      }
    }, {
      key: "cut",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
        if (Ur == 0 && qr == this.size)
          return this;
        var Yr = [], si = 0;
        if (qr > Ur)
          for (var yi = 0, Ii = 0; Ii < qr; yi++) {
            var Ki = this.content[yi], ta = Ii + Ki.nodeSize;
            ta > Ur && ((Ii < Ur || ta > qr) && (Ki.isText ? Ki = Ki.cut(Math.max(0, Ur - Ii), Math.min(Ki.text.length, qr - Ii)) : Ki = Ki.cut(Math.max(0, Ur - Ii - 1), Math.min(Ki.content.size, qr - Ii - 1))), Yr.push(Ki), si += Ki.nodeSize), Ii = ta;
          }
        return new ci(Yr, si);
      }
    }, {
      key: "cutByIndex",
      value: function(Ur, qr) {
        return Ur == qr ? ci.empty : Ur == 0 && qr == this.content.length ? this : new ci(this.content.slice(Ur, qr));
      }
    }, {
      key: "replaceChild",
      value: function(Ur, qr) {
        var Yr = this.content[Ur];
        if (Yr == qr)
          return this;
        var si = this.content.slice(), yi = this.size + qr.nodeSize - Yr.nodeSize;
        return si[Ur] = qr, new ci(si, yi);
      }
    }, {
      key: "addToStart",
      value: function(Ur) {
        return new ci([Ur].concat(this.content), this.size + Ur.nodeSize);
      }
    }, {
      key: "addToEnd",
      value: function(Ur) {
        return new ci(this.content.concat(Ur), this.size + Ur.nodeSize);
      }
    }, {
      key: "eq",
      value: function(Ur) {
        if (this.content.length != Ur.content.length)
          return !1;
        for (var qr = 0; qr < this.content.length; qr++)
          if (!this.content[qr].eq(Ur.content[qr]))
            return !1;
        return !0;
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.length ? this.content[0] : null;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.length;
      }
    }, {
      key: "child",
      value: function(Ur) {
        var qr = this.content[Ur];
        if (!qr)
          throw new RangeError("Index " + Ur + " out of range for " + this);
        return qr;
      }
    }, {
      key: "maybeChild",
      value: function(Ur) {
        return this.content[Ur] || null;
      }
    }, {
      key: "forEach",
      value: function(Ur) {
        for (var qr = 0, Yr = 0; qr < this.content.length; qr++) {
          var si = this.content[qr];
          Ur(si, Yr, qr), Yr += si.nodeSize;
        }
      }
    }, {
      key: "findDiffStart",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Jr(this, Ur, qr);
      }
    }, {
      key: "findDiffEnd",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size, Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ur.size;
        return li(this, Ur, qr, Yr);
      }
    }, {
      key: "findIndex",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (Ur == 0)
          return ui(0, Ur);
        if (Ur == this.size)
          return ui(this.content.length, Ur);
        if (Ur > this.size || Ur < 0)
          throw new RangeError("Position ".concat(Ur, " outside of fragment (").concat(this, ")"));
        for (var Yr = 0, si = 0; ; Yr++) {
          var yi = this.child(Yr), Ii = si + yi.nodeSize;
          if (Ii >= Ur)
            return Ii == Ur || qr > 0 ? ui(Yr + 1, Ii) : ui(Yr, si);
          si = Ii;
        }
      }
    }, {
      key: "toString",
      value: function() {
        return "<" + this.toStringInner() + ">";
      }
    }, {
      key: "toStringInner",
      value: function() {
        return this.content.join(", ");
      }
    }, {
      key: "toJSON",
      value: function() {
        return this.content.length ? this.content.map(function(Ur) {
          return Ur.toJSON();
        }) : null;
      }
    }], [{
      key: "fromJSON",
      value: function(Ur, qr) {
        if (!qr)
          return ci.empty;
        if (!Array.isArray(qr))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new ci(qr.map(Ur.nodeFromJSON));
      }
    }, {
      key: "fromArray",
      value: function(Ur) {
        if (!Ur.length)
          return ci.empty;
        for (var qr, Yr = 0, si = 0; si < Ur.length; si++) {
          var yi = Ur[si];
          Yr += yi.nodeSize, si && yi.isText && Ur[si - 1].sameMarkup(yi) ? (qr || (qr = Ur.slice(0, si)), qr[qr.length - 1] = yi.withText(qr[qr.length - 1].text + yi.text)) : qr && qr.push(yi);
        }
        return new ci(qr || Ur, Yr);
      }
    }, {
      key: "from",
      value: function(Ur) {
        if (!Ur)
          return ci.empty;
        if (Ur instanceof ci)
          return Ur;
        if (Array.isArray(Ur))
          return this.fromArray(Ur);
        if (Ur.attrs)
          return new ci([Ur], Ur.nodeSize);
        throw new RangeError("Can not convert " + Ur + " to a Fragment" + (Ur.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }]), ci;
  }();
  Qr.empty = new Qr([], 0);
  var ei = {
    index: 0,
    offset: 0
  };
  function ui(ci, ti) {
    return ei.index = ci, ei.offset = ti, ei;
  }
  function Ai(ci, ti) {
    if (ci === ti)
      return !0;
    if (!(ci && Br(ci) == "object") || !(ti && Br(ti) == "object"))
      return !1;
    var Ur = Array.isArray(ci);
    if (Array.isArray(ti) != Ur)
      return !1;
    if (Ur) {
      if (ci.length != ti.length)
        return !1;
      for (var qr = 0; qr < ci.length; qr++)
        if (!Ai(ci[qr], ti[qr]))
          return !1;
    } else {
      for (var Yr in ci)
        if (!(Yr in ti) || !Ai(ci[Yr], ti[Yr]))
          return !1;
      for (var si in ti)
        if (!(si in ci))
          return !1;
    }
    return !0;
  }
  var fi = function() {
    function ci(ti, Ur) {
      Ir(this, ci), this.type = ti, this.attrs = Ur;
    }
    return Hr(ci, [{
      key: "addToSet",
      value: function(Ur) {
        for (var qr, Yr = !1, si = 0; si < Ur.length; si++) {
          var yi = Ur[si];
          if (this.eq(yi))
            return Ur;
          if (this.type.excludes(yi.type))
            qr || (qr = Ur.slice(0, si));
          else {
            if (yi.type.excludes(this.type))
              return Ur;
            !Yr && yi.type.rank > this.type.rank && (qr || (qr = Ur.slice(0, si)), qr.push(this), Yr = !0), qr && qr.push(yi);
          }
        }
        return qr || (qr = Ur.slice()), Yr || qr.push(this), qr;
      }
    }, {
      key: "removeFromSet",
      value: function(Ur) {
        for (var qr = 0; qr < Ur.length; qr++)
          if (this.eq(Ur[qr]))
            return Ur.slice(0, qr).concat(Ur.slice(qr + 1));
        return Ur;
      }
    }, {
      key: "isInSet",
      value: function(Ur) {
        for (var qr = 0; qr < Ur.length; qr++)
          if (this.eq(Ur[qr]))
            return !0;
        return !1;
      }
    }, {
      key: "eq",
      value: function(Ur) {
        return this == Ur || this.type == Ur.type && Ai(this.attrs, Ur.attrs);
      }
    }, {
      key: "toJSON",
      value: function() {
        var Ur = {
          type: this.type.name
        };
        for (var qr in this.attrs) {
          Ur.attrs = this.attrs;
          break;
        }
        return Ur;
      }
    }], [{
      key: "fromJSON",
      value: function(Ur, qr) {
        if (!qr)
          throw new RangeError("Invalid input for Mark.fromJSON");
        var Yr = Ur.marks[qr.type];
        if (!Yr)
          throw new RangeError("There is no mark type ".concat(qr.type, " in this schema"));
        return Yr.create(qr.attrs);
      }
    }, {
      key: "sameSet",
      value: function(Ur, qr) {
        if (Ur == qr)
          return !0;
        if (Ur.length != qr.length)
          return !1;
        for (var Yr = 0; Yr < Ur.length; Yr++)
          if (!Ur[Yr].eq(qr[Yr]))
            return !1;
        return !0;
      }
    }, {
      key: "setFrom",
      value: function(Ur) {
        if (!Ur || Array.isArray(Ur) && Ur.length == 0)
          return ci.none;
        if (Ur instanceof ci)
          return [Ur];
        var qr = Ur.slice();
        return qr.sort(function(Yr, si) {
          return Yr.type.rank - si.type.rank;
        }), qr;
      }
    }]), ci;
  }();
  fi.none = [];
  var gi = function(ci) {
    vr(Ur, ci);
    var ti = yr(Ur);
    function Ur() {
      return Ir(this, Ur), ti.apply(this, arguments);
    }
    return Hr(Ur);
  }(xr(Error)), Ci = function() {
    function ci(ti, Ur, qr) {
      Ir(this, ci), this.content = ti, this.openStart = Ur, this.openEnd = qr;
    }
    return Hr(ci, [{
      key: "size",
      get: function() {
        return this.content.size - this.openStart - this.openEnd;
      }
    }, {
      key: "insertAt",
      value: function(Ur, qr) {
        var Yr = vi(this.content, Ur + this.openStart, qr);
        return Yr && new ci(Yr, this.openStart, this.openEnd);
      }
    }, {
      key: "removeBetween",
      value: function(Ur, qr) {
        return new ci(mi(this.content, Ur + this.openStart, qr + this.openStart), this.openStart, this.openEnd);
      }
    }, {
      key: "eq",
      value: function(Ur) {
        return this.content.eq(Ur.content) && this.openStart == Ur.openStart && this.openEnd == Ur.openEnd;
      }
    }, {
      key: "toString",
      value: function() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
    }, {
      key: "toJSON",
      value: function() {
        if (!this.content.size)
          return null;
        var Ur = {
          content: this.content.toJSON()
        };
        return this.openStart > 0 && (Ur.openStart = this.openStart), this.openEnd > 0 && (Ur.openEnd = this.openEnd), Ur;
      }
    }], [{
      key: "fromJSON",
      value: function(Ur, qr) {
        if (!qr)
          return ci.empty;
        var Yr = qr.openStart || 0, si = qr.openEnd || 0;
        if (typeof Yr != "number" || typeof si != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new ci(Qr.fromJSON(Ur, qr.content), Yr, si);
      }
    }, {
      key: "maxOpen",
      value: function(Ur) {
        for (var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Yr = 0, si = 0, yi = Ur.firstChild; yi && !yi.isLeaf && (qr || !yi.type.spec.isolating); yi = yi.firstChild)
          Yr++;
        for (var Ii = Ur.lastChild; Ii && !Ii.isLeaf && (qr || !Ii.type.spec.isolating); Ii = Ii.lastChild)
          si++;
        return new ci(Ur, Yr, si);
      }
    }]), ci;
  }();
  Ci.empty = new Ci(Qr.empty, 0, 0);
  function mi(ci, ti, Ur) {
    var qr = ci.findIndex(ti), Yr = qr.index, si = qr.offset, yi = ci.maybeChild(Yr), Ii = ci.findIndex(Ur), Ki = Ii.index, ta = Ii.offset;
    if (si == ti || yi.isText) {
      if (ta != Ur && !ci.child(Ki).isText)
        throw new RangeError("Removing non-flat range");
      return ci.cut(0, ti).append(ci.cut(Ur));
    }
    if (Yr != Ki)
      throw new RangeError("Removing non-flat range");
    return ci.replaceChild(Yr, yi.copy(mi(yi.content, ti - si - 1, Ur - si - 1)));
  }
  function vi(ci, ti, Ur, qr) {
    var Yr = ci.findIndex(ti), si = Yr.index, yi = Yr.offset, Ii = ci.maybeChild(si);
    if (yi == ti || Ii.isText)
      return qr && !qr.canReplace(si, si, Ur) ? null : ci.cut(0, ti).append(Ur).append(ci.cut(ti));
    var Ki = vi(Ii.content, ti - yi - 1, Ur);
    return Ki && ci.replaceChild(si, Ii.copy(Ki));
  }
  function Ri(ci, ti, Ur) {
    if (Ur.openStart > ci.depth)
      throw new gi("Inserted content deeper than insertion position");
    if (ci.depth - Ur.openStart != ti.depth - Ur.openEnd)
      throw new gi("Inconsistent open depths");
    return di(ci, ti, Ur, 0);
  }
  function di(ci, ti, Ur, qr) {
    var Yr = ci.index(qr), si = ci.node(qr);
    if (Yr == ti.index(qr) && qr < ci.depth - Ur.openStart) {
      var yi = di(ci, ti, Ur, qr + 1);
      return si.copy(si.content.replaceChild(Yr, yi));
    } else if (Ur.content.size)
      if (!Ur.openStart && !Ur.openEnd && ci.depth == qr && ti.depth == qr) {
        var Ii = ci.parent, Ki = Ii.content;
        return Bi(Ii, Ki.cut(0, ci.parentOffset).append(Ur.content).append(Ki.cut(ti.parentOffset)));
      } else {
        var ta = bi(Ur, ci), va = ta.start, ua = ta.end;
        return Bi(si, Ni(ci, va, ua, ti, qr));
      }
    else
      return Bi(si, Mi(ci, ti, qr));
  }
  function Ti(ci, ti) {
    if (!ti.type.compatibleContent(ci.type))
      throw new gi("Cannot join " + ti.type.name + " onto " + ci.type.name);
  }
  function qi(ci, ti, Ur) {
    var qr = ci.node(Ur);
    return Ti(qr, ti.node(Ur)), qr;
  }
  function ki(ci, ti) {
    var Ur = ti.length - 1;
    Ur >= 0 && ci.isText && ci.sameMarkup(ti[Ur]) ? ti[Ur] = ci.withText(ti[Ur].text + ci.text) : ti.push(ci);
  }
  function Ji(ci, ti, Ur, qr) {
    var Yr = (ti || ci).node(Ur), si = 0, yi = ti ? ti.index(Ur) : Yr.childCount;
    ci && (si = ci.index(Ur), ci.depth > Ur ? si++ : ci.textOffset && (ki(ci.nodeAfter, qr), si++));
    for (var Ii = si; Ii < yi; Ii++)
      ki(Yr.child(Ii), qr);
    ti && ti.depth == Ur && ti.textOffset && ki(ti.nodeBefore, qr);
  }
  function Bi(ci, ti) {
    return ci.type.checkContent(ti), ci.copy(ti);
  }
  function Ni(ci, ti, Ur, qr, Yr) {
    var si = ci.depth > Yr && qi(ci, ti, Yr + 1), yi = qr.depth > Yr && qi(Ur, qr, Yr + 1), Ii = [];
    return Ji(null, ci, Yr, Ii), si && yi && ti.index(Yr) == Ur.index(Yr) ? (Ti(si, yi), ki(Bi(si, Ni(ci, ti, Ur, qr, Yr + 1)), Ii)) : (si && ki(Bi(si, Mi(ci, ti, Yr + 1)), Ii), Ji(ti, Ur, Yr, Ii), yi && ki(Bi(yi, Mi(Ur, qr, Yr + 1)), Ii)), Ji(qr, null, Yr, Ii), new Qr(Ii);
  }
  function Mi(ci, ti, Ur) {
    var qr = [];
    if (Ji(null, ci, Ur, qr), ci.depth > Ur) {
      var Yr = qi(ci, ti, Ur + 1);
      ki(Bi(Yr, Mi(ci, ti, Ur + 1)), qr);
    }
    return Ji(ti, null, Ur, qr), new Qr(qr);
  }
  function bi(ci, ti) {
    for (var Ur = ti.depth - ci.openStart, qr = ti.node(Ur), Yr = qr.copy(ci.content), si = Ur - 1; si >= 0; si--)
      Yr = ti.node(si).copy(Qr.from(Yr));
    return {
      start: Yr.resolveNoCache(ci.openStart + Ur),
      end: Yr.resolveNoCache(Yr.content.size - ci.openEnd - Ur)
    };
  }
  var Ei = function() {
    function ci(ti, Ur, qr) {
      Ir(this, ci), this.pos = ti, this.path = Ur, this.parentOffset = qr, this.depth = Ur.length / 3 - 1;
    }
    return Hr(ci, [{
      key: "resolveDepth",
      value: function(Ur) {
        return Ur == null ? this.depth : Ur < 0 ? this.depth + Ur : Ur;
      }
    }, {
      key: "parent",
      get: function() {
        return this.node(this.depth);
      }
    }, {
      key: "doc",
      get: function() {
        return this.node(0);
      }
    }, {
      key: "node",
      value: function(Ur) {
        return this.path[this.resolveDepth(Ur) * 3];
      }
    }, {
      key: "index",
      value: function(Ur) {
        return this.path[this.resolveDepth(Ur) * 3 + 1];
      }
    }, {
      key: "indexAfter",
      value: function(Ur) {
        return Ur = this.resolveDepth(Ur), this.index(Ur) + (Ur == this.depth && !this.textOffset ? 0 : 1);
      }
    }, {
      key: "start",
      value: function(Ur) {
        return Ur = this.resolveDepth(Ur), Ur == 0 ? 0 : this.path[Ur * 3 - 1] + 1;
      }
    }, {
      key: "end",
      value: function(Ur) {
        return Ur = this.resolveDepth(Ur), this.start(Ur) + this.node(Ur).content.size;
      }
    }, {
      key: "before",
      value: function(Ur) {
        if (Ur = this.resolveDepth(Ur), !Ur)
          throw new RangeError("There is no position before the top-level node");
        return Ur == this.depth + 1 ? this.pos : this.path[Ur * 3 - 1];
      }
    }, {
      key: "after",
      value: function(Ur) {
        if (Ur = this.resolveDepth(Ur), !Ur)
          throw new RangeError("There is no position after the top-level node");
        return Ur == this.depth + 1 ? this.pos : this.path[Ur * 3 - 1] + this.path[Ur * 3].nodeSize;
      }
    }, {
      key: "textOffset",
      get: function() {
        return this.pos - this.path[this.path.length - 1];
      }
    }, {
      key: "nodeAfter",
      get: function() {
        var Ur = this.parent, qr = this.index(this.depth);
        if (qr == Ur.childCount)
          return null;
        var Yr = this.pos - this.path[this.path.length - 1], si = Ur.child(qr);
        return Yr ? Ur.child(qr).cut(Yr) : si;
      }
    }, {
      key: "nodeBefore",
      get: function() {
        var Ur = this.index(this.depth), qr = this.pos - this.path[this.path.length - 1];
        return qr ? this.parent.child(Ur).cut(0, qr) : Ur == 0 ? null : this.parent.child(Ur - 1);
      }
    }, {
      key: "posAtIndex",
      value: function(Ur, qr) {
        qr = this.resolveDepth(qr);
        for (var Yr = this.path[qr * 3], si = qr == 0 ? 0 : this.path[qr * 3 - 1] + 1, yi = 0; yi < Ur; yi++)
          si += Yr.child(yi).nodeSize;
        return si;
      }
    }, {
      key: "marks",
      value: function() {
        var Ur = this.parent, qr = this.index();
        if (Ur.content.size == 0)
          return fi.none;
        if (this.textOffset)
          return Ur.child(qr).marks;
        var Yr = Ur.maybeChild(qr - 1), si = Ur.maybeChild(qr);
        if (!Yr) {
          var yi = Yr;
          Yr = si, si = yi;
        }
        for (var Ii = Yr.marks, Ki = 0; Ki < Ii.length; Ki++)
          Ii[Ki].type.spec.inclusive === !1 && (!si || !Ii[Ki].isInSet(si.marks)) && (Ii = Ii[Ki--].removeFromSet(Ii));
        return Ii;
      }
    }, {
      key: "marksAcross",
      value: function(Ur) {
        var qr = this.parent.maybeChild(this.index());
        if (!qr || !qr.isInline)
          return null;
        for (var Yr = qr.marks, si = Ur.parent.maybeChild(Ur.index()), yi = 0; yi < Yr.length; yi++)
          Yr[yi].type.spec.inclusive === !1 && (!si || !Yr[yi].isInSet(si.marks)) && (Yr = Yr[yi--].removeFromSet(Yr));
        return Yr;
      }
    }, {
      key: "sharedDepth",
      value: function(Ur) {
        for (var qr = this.depth; qr > 0; qr--)
          if (this.start(qr) <= Ur && this.end(qr) >= Ur)
            return qr;
        return 0;
      }
    }, {
      key: "blockRange",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this, qr = arguments.length > 1 ? arguments[1] : void 0;
        if (Ur.pos < this.pos)
          return Ur.blockRange(this);
        for (var Yr = this.depth - (this.parent.inlineContent || this.pos == Ur.pos ? 1 : 0); Yr >= 0; Yr--)
          if (Ur.pos <= this.end(Yr) && (!qr || qr(this.node(Yr))))
            return new sa(this, Ur, Yr);
        return null;
      }
    }, {
      key: "sameParent",
      value: function(Ur) {
        return this.pos - this.parentOffset == Ur.pos - Ur.parentOffset;
      }
    }, {
      key: "max",
      value: function(Ur) {
        return Ur.pos > this.pos ? Ur : this;
      }
    }, {
      key: "min",
      value: function(Ur) {
        return Ur.pos < this.pos ? Ur : this;
      }
    }, {
      key: "toString",
      value: function() {
        for (var Ur = "", qr = 1; qr <= this.depth; qr++)
          Ur += (Ur ? "/" : "") + this.node(qr).type.name + "_" + this.index(qr - 1);
        return Ur + ":" + this.parentOffset;
      }
    }], [{
      key: "resolve",
      value: function(Ur, qr) {
        if (!(qr >= 0 && qr <= Ur.content.size))
          throw new RangeError("Position " + qr + " out of range");
        for (var Yr = [], si = 0, yi = qr, Ii = Ur; ; ) {
          var Ki = Ii.content.findIndex(yi), ta = Ki.index, va = Ki.offset, ua = yi - va;
          if (Yr.push(Ii, ta, si + va), !ua || (Ii = Ii.child(ta), Ii.isText))
            break;
          yi = ua - 1, si += va + 1;
        }
        return new ci(qr, Yr, yi);
      }
    }, {
      key: "resolveCached",
      value: function(Ur, qr) {
        for (var Yr = 0; Yr < Si.length; Yr++) {
          var si = Si[Yr];
          if (si.pos == qr && si.doc == Ur)
            return si;
        }
        var yi = Si[Vi] = ci.resolve(Ur, qr);
        return Vi = (Vi + 1) % Di, yi;
      }
    }]), ci;
  }(), Si = [], Vi = 0, Di = 12, sa = function() {
    function ci(ti, Ur, qr) {
      Ir(this, ci), this.$from = ti, this.$to = Ur, this.depth = qr;
    }
    return Hr(ci, [{
      key: "start",
      get: function() {
        return this.$from.before(this.depth + 1);
      }
    }, {
      key: "end",
      get: function() {
        return this.$to.after(this.depth + 1);
      }
    }, {
      key: "parent",
      get: function() {
        return this.$from.node(this.depth);
      }
    }, {
      key: "startIndex",
      get: function() {
        return this.$from.index(this.depth);
      }
    }, {
      key: "endIndex",
      get: function() {
        return this.$to.indexAfter(this.depth);
      }
    }]), ci;
  }(), ra = /* @__PURE__ */ Object.create(null), fa = function() {
    function ci(ti, Ur, qr) {
      var Yr = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fi.none;
      Ir(this, ci), this.type = ti, this.attrs = Ur, this.marks = Yr, this.content = qr || Qr.empty;
    }
    return Hr(ci, [{
      key: "nodeSize",
      get: function() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.childCount;
      }
    }, {
      key: "child",
      value: function(Ur) {
        return this.content.child(Ur);
      }
    }, {
      key: "maybeChild",
      value: function(Ur) {
        return this.content.maybeChild(Ur);
      }
    }, {
      key: "forEach",
      value: function(Ur) {
        this.content.forEach(Ur);
      }
    }, {
      key: "nodesBetween",
      value: function(Ur, qr, Yr) {
        var si = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        this.content.nodesBetween(Ur, qr, Yr, si, this);
      }
    }, {
      key: "descendants",
      value: function(Ur) {
        this.nodesBetween(0, this.content.size, Ur);
      }
    }, {
      key: "textContent",
      get: function() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
    }, {
      key: "textBetween",
      value: function(Ur, qr, Yr, si) {
        return this.content.textBetween(Ur, qr, Yr, si);
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.firstChild;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.lastChild;
      }
    }, {
      key: "eq",
      value: function(Ur) {
        return this == Ur || this.sameMarkup(Ur) && this.content.eq(Ur.content);
      }
    }, {
      key: "sameMarkup",
      value: function(Ur) {
        return this.hasMarkup(Ur.type, Ur.attrs, Ur.marks);
      }
    }, {
      key: "hasMarkup",
      value: function(Ur, qr, Yr) {
        return this.type == Ur && Ai(this.attrs, qr || Ur.defaultAttrs || ra) && fi.sameSet(this.marks, Yr || fi.none);
      }
    }, {
      key: "copy",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return Ur == this.content ? this : new ci(this.type, this.attrs, Ur, this.marks);
      }
    }, {
      key: "mark",
      value: function(Ur) {
        return Ur == this.marks ? this : new ci(this.type, this.attrs, this.content, Ur);
      }
    }, {
      key: "cut",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
        return Ur == 0 && qr == this.content.size ? this : this.copy(this.content.cut(Ur, qr));
      }
    }, {
      key: "slice",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size, Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (Ur == qr)
          return Ci.empty;
        var si = this.resolve(Ur), yi = this.resolve(qr), Ii = Yr ? 0 : si.sharedDepth(qr), Ki = si.start(Ii), ta = si.node(Ii), va = ta.content.cut(si.pos - Ki, yi.pos - Ki);
        return new Ci(va, si.depth - Ii, yi.depth - Ii);
      }
    }, {
      key: "replace",
      value: function(Ur, qr, Yr) {
        return Ri(this.resolve(Ur), this.resolve(qr), Yr);
      }
    }, {
      key: "nodeAt",
      value: function(Ur) {
        for (var qr = this; ; ) {
          var Yr = qr.content.findIndex(Ur), si = Yr.index, yi = Yr.offset;
          if (qr = qr.maybeChild(si), !qr)
            return null;
          if (yi == Ur || qr.isText)
            return qr;
          Ur -= yi + 1;
        }
      }
    }, {
      key: "childAfter",
      value: function(Ur) {
        var qr = this.content.findIndex(Ur), Yr = qr.index, si = qr.offset;
        return {
          node: this.content.maybeChild(Yr),
          index: Yr,
          offset: si
        };
      }
    }, {
      key: "childBefore",
      value: function(Ur) {
        if (Ur == 0)
          return {
            node: null,
            index: 0,
            offset: 0
          };
        var qr = this.content.findIndex(Ur), Yr = qr.index, si = qr.offset;
        if (si < Ur)
          return {
            node: this.content.child(Yr),
            index: Yr,
            offset: si
          };
        var yi = this.content.child(Yr - 1);
        return {
          node: yi,
          index: Yr - 1,
          offset: si - yi.nodeSize
        };
      }
    }, {
      key: "resolve",
      value: function(Ur) {
        return Ei.resolveCached(this, Ur);
      }
    }, {
      key: "resolveNoCache",
      value: function(Ur) {
        return Ei.resolve(this, Ur);
      }
    }, {
      key: "rangeHasMark",
      value: function(Ur, qr, Yr) {
        var si = !1;
        return qr > Ur && this.nodesBetween(Ur, qr, function(yi) {
          return Yr.isInSet(yi.marks) && (si = !0), !si;
        }), si;
      }
    }, {
      key: "isBlock",
      get: function() {
        return this.type.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.type.isTextblock;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.type.inlineContent;
      }
    }, {
      key: "isInline",
      get: function() {
        return this.type.isInline;
      }
    }, {
      key: "isText",
      get: function() {
        return this.type.isText;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.type.isLeaf;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.type.isAtom;
      }
    }, {
      key: "toString",
      value: function() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        var Ur = this.type.name;
        return this.content.size && (Ur += "(" + this.content.toStringInner() + ")"), Ua(this.marks, Ur);
      }
    }, {
      key: "contentMatchAt",
      value: function(Ur) {
        var qr = this.type.contentMatch.matchFragment(this.content, 0, Ur);
        if (!qr)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return qr;
      }
    }, {
      key: "canReplace",
      value: function(Ur, qr) {
        var Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Qr.empty, si = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, yi = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Yr.childCount, Ii = this.contentMatchAt(Ur).matchFragment(Yr, si, yi), Ki = Ii && Ii.matchFragment(this.content, qr);
        if (!Ki || !Ki.validEnd)
          return !1;
        for (var ta = si; ta < yi; ta++)
          if (!this.type.allowsMarks(Yr.child(ta).marks))
            return !1;
        return !0;
      }
    }, {
      key: "canReplaceWith",
      value: function(Ur, qr, Yr, si) {
        if (si && !this.type.allowsMarks(si))
          return !1;
        var yi = this.contentMatchAt(Ur).matchType(Yr), Ii = yi && yi.matchFragment(this.content, qr);
        return Ii ? Ii.validEnd : !1;
      }
    }, {
      key: "canAppend",
      value: function(Ur) {
        return Ur.content.size ? this.canReplace(this.childCount, this.childCount, Ur.content) : this.type.compatibleContent(Ur.type);
      }
    }, {
      key: "check",
      value: function() {
        this.type.checkContent(this.content);
        for (var Ur = fi.none, qr = 0; qr < this.marks.length; qr++)
          Ur = this.marks[qr].addToSet(Ur);
        if (!fi.sameSet(Ur, this.marks))
          throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(Yr) {
            return Yr.type.name;
          })));
        this.content.forEach(function(Yr) {
          return Yr.check();
        });
      }
    }, {
      key: "toJSON",
      value: function() {
        var Ur = {
          type: this.type.name
        };
        for (var qr in this.attrs) {
          Ur.attrs = this.attrs;
          break;
        }
        return this.content.size && (Ur.content = this.content.toJSON()), this.marks.length && (Ur.marks = this.marks.map(function(Yr) {
          return Yr.toJSON();
        })), Ur;
      }
    }], [{
      key: "fromJSON",
      value: function(Ur, qr) {
        if (!qr)
          throw new RangeError("Invalid input for Node.fromJSON");
        var Yr = null;
        if (qr.marks) {
          if (!Array.isArray(qr.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          Yr = qr.marks.map(Ur.markFromJSON);
        }
        if (qr.type == "text") {
          if (typeof qr.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return Ur.text(qr.text, Yr);
        }
        var si = Qr.fromJSON(Ur, qr.content);
        return Ur.nodeType(qr.type).create(qr.attrs, si, Yr);
      }
    }]), ci;
  }();
  fa.prototype.text = void 0;
  var ba = function(ci) {
    vr(Ur, ci);
    var ti = yr(Ur);
    function Ur(qr, Yr, si, yi) {
      var Ii;
      if (Ir(this, Ur), Ii = ti.call(this, qr, Yr, null, yi), !si)
        throw new RangeError("Empty text nodes are not allowed");
      return Ii.text = si, Ii;
    }
    return Hr(Ur, [{
      key: "toString",
      value: function() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Ua(this.marks, JSON.stringify(this.text));
      }
    }, {
      key: "textContent",
      get: function() {
        return this.text;
      }
    }, {
      key: "textBetween",
      value: function(Yr, si) {
        return this.text.slice(Yr, si);
      }
    }, {
      key: "nodeSize",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "mark",
      value: function(Yr) {
        return Yr == this.marks ? this : new Ur(this.type, this.attrs, this.text, Yr);
      }
    }, {
      key: "withText",
      value: function(Yr) {
        return Yr == this.text ? this : new Ur(this.type, this.attrs, Yr, this.marks);
      }
    }, {
      key: "cut",
      value: function() {
        var Yr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, si = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
        return Yr == 0 && si == this.text.length ? this : this.withText(this.text.slice(Yr, si));
      }
    }, {
      key: "eq",
      value: function(Yr) {
        return this.sameMarkup(Yr) && this.text == Yr.text;
      }
    }, {
      key: "toJSON",
      value: function() {
        var Yr = gr(Ar(Ur.prototype), "toJSON", this).call(this);
        return Yr.text = this.text, Yr;
      }
    }]), Ur;
  }(fa);
  function Ua(ci, ti) {
    for (var Ur = ci.length - 1; Ur >= 0; Ur--)
      ti = ci[Ur].type.name + "(" + ti + ")";
    return ti;
  }
  var Va = function() {
    function ci(ti) {
      Ir(this, ci), this.validEnd = ti, this.next = [], this.wrapCache = [];
    }
    return Hr(ci, [{
      key: "matchType",
      value: function(Ur) {
        for (var qr = 0; qr < this.next.length; qr++)
          if (this.next[qr].type == Ur)
            return this.next[qr].next;
        return null;
      }
    }, {
      key: "matchFragment",
      value: function(Ur) {
        for (var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ur.childCount, si = this, yi = qr; si && yi < Yr; yi++)
          si = si.matchType(Ur.child(yi).type);
        return si;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
    }, {
      key: "defaultType",
      get: function() {
        for (var Ur = 0; Ur < this.next.length; Ur++) {
          var qr = this.next[Ur].type;
          if (!(qr.isText || qr.hasRequiredAttrs()))
            return qr;
        }
        return null;
      }
    }, {
      key: "compatible",
      value: function(Ur) {
        for (var qr = 0; qr < this.next.length; qr++)
          for (var Yr = 0; Yr < Ur.next.length; Yr++)
            if (this.next[qr].type == Ur.next[Yr].type)
              return !0;
        return !1;
      }
    }, {
      key: "fillBefore",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, si = [this];
        function yi(Ii, Ki) {
          var ta = Ii.matchFragment(Ur, Yr);
          if (ta && (!qr || ta.validEnd))
            return Qr.from(Ki.map(function(_o) {
              return _o.createAndFill();
            }));
          for (var va = 0; va < Ii.next.length; va++) {
            var ua = Ii.next[va], ma = ua.type, Fa = ua.next;
            if (!(ma.isText || ma.hasRequiredAttrs()) && si.indexOf(Fa) == -1) {
              si.push(Fa);
              var fo = yi(Fa, Ki.concat(ma));
              if (fo)
                return fo;
            }
          }
          return null;
        }
        return yi(this, []);
      }
    }, {
      key: "findWrapping",
      value: function(Ur) {
        for (var qr = 0; qr < this.wrapCache.length; qr += 2)
          if (this.wrapCache[qr] == Ur)
            return this.wrapCache[qr + 1];
        var Yr = this.computeWrapping(Ur);
        return this.wrapCache.push(Ur, Yr), Yr;
      }
    }, {
      key: "computeWrapping",
      value: function(Ur) {
        for (var qr = /* @__PURE__ */ Object.create(null), Yr = [{
          match: this,
          type: null,
          via: null
        }]; Yr.length; ) {
          var si = Yr.shift(), yi = si.match;
          if (yi.matchType(Ur)) {
            for (var Ii = [], Ki = si; Ki.type; Ki = Ki.via)
              Ii.push(Ki.type);
            return Ii.reverse();
          }
          for (var ta = 0; ta < yi.next.length; ta++) {
            var va = yi.next[ta], ua = va.type, ma = va.next;
            !ua.isLeaf && !ua.hasRequiredAttrs() && !(ua.name in qr) && (!si.type || ma.validEnd) && (Yr.push({
              match: ua.contentMatch,
              type: ua,
              via: si
            }), qr[ua.name] = !0);
          }
        }
        return null;
      }
    }, {
      key: "edgeCount",
      get: function() {
        return this.next.length;
      }
    }, {
      key: "edge",
      value: function(Ur) {
        if (Ur >= this.next.length)
          throw new RangeError("There's no ".concat(Ur, "th edge in this content match"));
        return this.next[Ur];
      }
    }, {
      key: "toString",
      value: function() {
        var Ur = [];
        function qr(Yr) {
          Ur.push(Yr);
          for (var si = 0; si < Yr.next.length; si++)
            Ur.indexOf(Yr.next[si].next) == -1 && qr(Yr.next[si].next);
        }
        return qr(this), Ur.map(function(Yr, si) {
          for (var yi = si + (Yr.validEnd ? "*" : " ") + " ", Ii = 0; Ii < Yr.next.length; Ii++)
            yi += (Ii ? ", " : "") + Yr.next[Ii].type.name + "->" + Ur.indexOf(Yr.next[Ii].next);
          return yi;
        }).join(`
`);
      }
    }], [{
      key: "parse",
      value: function(Ur, qr) {
        var Yr = new Ma(Ur, qr);
        if (Yr.next == null)
          return ci.empty;
        var si = Fi(Yr);
        Yr.next && Yr.err("Unexpected trailing text");
        var yi = Oa(pa(si));
        return Ja(yi, Yr), yi;
      }
    }]), ci;
  }();
  Va.empty = new Va(!0);
  var Ma = function() {
    function ci(ti, Ur) {
      Ir(this, ci), this.string = ti, this.nodeTypes = Ur, this.inline = null, this.pos = 0, this.tokens = ti.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    return Hr(ci, [{
      key: "next",
      get: function() {
        return this.tokens[this.pos];
      }
    }, {
      key: "eat",
      value: function(Ur) {
        return this.next == Ur && (this.pos++ || !0);
      }
    }, {
      key: "err",
      value: function(Ur) {
        throw new SyntaxError(Ur + " (in content expression '" + this.string + "')");
      }
    }]), ci;
  }();
  function Fi(ci) {
    var ti = [];
    do
      ti.push(na(ci));
    while (ci.eat("|"));
    return ti.length == 1 ? ti[0] : {
      type: "choice",
      exprs: ti
    };
  }
  function na(ci) {
    var ti = [];
    do
      ti.push(Gi(ci));
    while (ci.next && ci.next != ")" && ci.next != "|");
    return ti.length == 1 ? ti[0] : {
      type: "seq",
      exprs: ti
    };
  }
  function Gi(ci) {
    for (var ti = ga(ci); ; )
      if (ci.eat("+"))
        ti = {
          type: "plus",
          expr: ti
        };
      else if (ci.eat("*"))
        ti = {
          type: "star",
          expr: ti
        };
      else if (ci.eat("?"))
        ti = {
          type: "opt",
          expr: ti
        };
      else if (ci.eat("{"))
        ti = $a(ci, ti);
      else
        break;
    return ti;
  }
  function Ca(ci) {
    /\D/.test(ci.next) && ci.err("Expected number, got '" + ci.next + "'");
    var ti = Number(ci.next);
    return ci.pos++, ti;
  }
  function $a(ci, ti) {
    var Ur = Ca(ci), qr = Ur;
    return ci.eat(",") && (ci.next != "}" ? qr = Ca(ci) : qr = -1), ci.eat("}") || ci.err("Unclosed braced range"), {
      type: "range",
      min: Ur,
      max: qr,
      expr: ti
    };
  }
  function no(ci, ti) {
    var Ur = ci.nodeTypes, qr = Ur[ti];
    if (qr)
      return [qr];
    var Yr = [];
    for (var si in Ur) {
      var yi = Ur[si];
      yi.groups.indexOf(ti) > -1 && Yr.push(yi);
    }
    return Yr.length == 0 && ci.err("No node type or group '" + ti + "' found"), Yr;
  }
  function ga(ci) {
    if (ci.eat("(")) {
      var ti = Fi(ci);
      return ci.eat(")") || ci.err("Missing closing paren"), ti;
    } else if (/\W/.test(ci.next))
      ci.err("Unexpected token '" + ci.next + "'");
    else {
      var Ur = no(ci, ci.next).map(function(qr) {
        return ci.inline == null ? ci.inline = qr.isInline : ci.inline != qr.isInline && ci.err("Mixing inline and block content"), {
          type: "name",
          value: qr
        };
      });
      return ci.pos++, Ur.length == 1 ? Ur[0] : {
        type: "choice",
        exprs: Ur
      };
    }
  }
  function pa(ci) {
    var ti = [[]];
    return Yr(si(ci, 0), Ur()), ti;
    function Ur() {
      return ti.push([]) - 1;
    }
    function qr(yi, Ii, Ki) {
      var ta = {
        term: Ki,
        to: Ii
      };
      return ti[yi].push(ta), ta;
    }
    function Yr(yi, Ii) {
      yi.forEach(function(Ki) {
        return Ki.to = Ii;
      });
    }
    function si(yi, Ii) {
      if (yi.type == "choice")
        return yi.exprs.reduce(function(Bo, Po) {
          return Bo.concat(si(Po, Ii));
        }, []);
      if (yi.type == "seq")
        for (var Ki = 0; ; Ki++) {
          var ta = si(yi.exprs[Ki], Ii);
          if (Ki == yi.exprs.length - 1)
            return ta;
          Yr(ta, Ii = Ur());
        }
      else if (yi.type == "star") {
        var va = Ur();
        return qr(Ii, va), Yr(si(yi.expr, va), va), [qr(va)];
      } else if (yi.type == "plus") {
        var ua = Ur();
        return Yr(si(yi.expr, Ii), ua), Yr(si(yi.expr, ua), ua), [qr(ua)];
      } else {
        if (yi.type == "opt")
          return [qr(Ii)].concat(si(yi.expr, Ii));
        if (yi.type == "range") {
          for (var ma = Ii, Fa = 0; Fa < yi.min; Fa++) {
            var fo = Ur();
            Yr(si(yi.expr, ma), fo), ma = fo;
          }
          if (yi.max == -1)
            Yr(si(yi.expr, ma), ma);
          else
            for (var _o = yi.min; _o < yi.max; _o++) {
              var No = Ur();
              qr(ma, No), Yr(si(yi.expr, ma), No), ma = No;
            }
          return [qr(ma)];
        } else {
          if (yi.type == "name")
            return [qr(Ii, void 0, yi.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function Sa(ci, ti) {
    return ti - ci;
  }
  function Na(ci, ti) {
    var Ur = [];
    return qr(ti), Ur.sort(Sa);
    function qr(Yr) {
      var si = ci[Yr];
      if (si.length == 1 && !si[0].term)
        return qr(si[0].to);
      Ur.push(Yr);
      for (var yi = 0; yi < si.length; yi++) {
        var Ii = si[yi], Ki = Ii.term, ta = Ii.to;
        !Ki && Ur.indexOf(ta) == -1 && qr(ta);
      }
    }
  }
  function Oa(ci) {
    var ti = /* @__PURE__ */ Object.create(null);
    return Ur(Na(ci, 0));
    function Ur(qr) {
      var Yr = [];
      qr.forEach(function(Ki) {
        ci[Ki].forEach(function(ta) {
          var va = ta.term, ua = ta.to;
          if (va) {
            for (var ma, Fa = 0; Fa < Yr.length; Fa++)
              Yr[Fa][0] == va && (ma = Yr[Fa][1]);
            Na(ci, ua).forEach(function(fo) {
              ma || Yr.push([va, ma = []]), ma.indexOf(fo) == -1 && ma.push(fo);
            });
          }
        });
      });
      for (var si = ti[qr.join(",")] = new Va(qr.indexOf(ci.length - 1) > -1), yi = 0; yi < Yr.length; yi++) {
        var Ii = Yr[yi][1].sort(Sa);
        si.next.push({
          type: Yr[yi][0],
          next: ti[Ii.join(",")] || Ur(Ii)
        });
      }
      return si;
    }
  }
  function Ja(ci, ti) {
    for (var Ur = 0, qr = [ci]; Ur < qr.length; Ur++) {
      for (var Yr = qr[Ur], si = !Yr.validEnd, yi = [], Ii = 0; Ii < Yr.next.length; Ii++) {
        var Ki = Yr.next[Ii], ta = Ki.type, va = Ki.next;
        yi.push(ta.name), si && !(ta.isText || ta.hasRequiredAttrs()) && (si = !1), qr.indexOf(va) == -1 && qr.push(va);
      }
      si && ti.err("Only non-generatable nodes (" + yi.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function za(ci) {
    var ti = /* @__PURE__ */ Object.create(null);
    for (var Ur in ci) {
      var qr = ci[Ur];
      if (!qr.hasDefault)
        return null;
      ti[Ur] = qr.default;
    }
    return ti;
  }
  function Ia(ci, ti) {
    var Ur = /* @__PURE__ */ Object.create(null);
    for (var qr in ci) {
      var Yr = ti && ti[qr];
      if (Yr === void 0) {
        var si = ci[qr];
        if (si.hasDefault)
          Yr = si.default;
        else
          throw new RangeError("No value supplied for attribute " + qr);
      }
      Ur[qr] = Yr;
    }
    return Ur;
  }
  function Yi(ci) {
    var ti = /* @__PURE__ */ Object.create(null);
    if (ci)
      for (var Ur in ci)
        ti[Ur] = new Ka(ci[Ur]);
    return ti;
  }
  var La = function() {
    function ci(ti, Ur, qr) {
      Ir(this, ci), this.name = ti, this.schema = Ur, this.spec = qr, this.markSet = null, this.groups = qr.group ? qr.group.split(" ") : [], this.attrs = Yi(qr.attrs), this.defaultAttrs = za(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(qr.inline || ti == "text"), this.isText = ti == "text";
    }
    return Hr(ci, [{
      key: "isInline",
      get: function() {
        return !this.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.isBlock && this.inlineContent;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.contentMatch == Va.empty;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.isLeaf || !!this.spec.atom;
      }
    }, {
      key: "whitespace",
      get: function() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
    }, {
      key: "hasRequiredAttrs",
      value: function() {
        for (var Ur in this.attrs)
          if (this.attrs[Ur].isRequired)
            return !0;
        return !1;
      }
    }, {
      key: "compatibleContent",
      value: function(Ur) {
        return this == Ur || this.contentMatch.compatible(Ur.contentMatch);
      }
    }, {
      key: "computeAttrs",
      value: function(Ur) {
        return !Ur && this.defaultAttrs ? this.defaultAttrs : Ia(this.attrs, Ur);
      }
    }, {
      key: "create",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, qr = arguments.length > 1 ? arguments[1] : void 0, Yr = arguments.length > 2 ? arguments[2] : void 0;
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new fa(this, this.computeAttrs(Ur), Qr.from(qr), fi.setFrom(Yr));
      }
    }, {
      key: "createChecked",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, qr = arguments.length > 1 ? arguments[1] : void 0, Yr = arguments.length > 2 ? arguments[2] : void 0;
        return qr = Qr.from(qr), this.checkContent(qr), new fa(this, this.computeAttrs(Ur), qr, fi.setFrom(Yr));
      }
    }, {
      key: "createAndFill",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, qr = arguments.length > 1 ? arguments[1] : void 0, Yr = arguments.length > 2 ? arguments[2] : void 0;
        if (Ur = this.computeAttrs(Ur), qr = Qr.from(qr), qr.size) {
          var si = this.contentMatch.fillBefore(qr);
          if (!si)
            return null;
          qr = si.append(qr);
        }
        var yi = this.contentMatch.matchFragment(qr), Ii = yi && yi.fillBefore(Qr.empty, !0);
        return Ii ? new fa(this, Ur, qr.append(Ii), fi.setFrom(Yr)) : null;
      }
    }, {
      key: "validContent",
      value: function(Ur) {
        var qr = this.contentMatch.matchFragment(Ur);
        if (!qr || !qr.validEnd)
          return !1;
        for (var Yr = 0; Yr < Ur.childCount; Yr++)
          if (!this.allowsMarks(Ur.child(Yr).marks))
            return !1;
        return !0;
      }
    }, {
      key: "checkContent",
      value: function(Ur) {
        if (!this.validContent(Ur))
          throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(Ur.toString().slice(0, 50)));
      }
    }, {
      key: "allowsMarkType",
      value: function(Ur) {
        return this.markSet == null || this.markSet.indexOf(Ur) > -1;
      }
    }, {
      key: "allowsMarks",
      value: function(Ur) {
        if (this.markSet == null)
          return !0;
        for (var qr = 0; qr < Ur.length; qr++)
          if (!this.allowsMarkType(Ur[qr].type))
            return !1;
        return !0;
      }
    }, {
      key: "allowedMarks",
      value: function(Ur) {
        if (this.markSet == null)
          return Ur;
        for (var qr, Yr = 0; Yr < Ur.length; Yr++)
          this.allowsMarkType(Ur[Yr].type) ? qr && qr.push(Ur[Yr]) : qr || (qr = Ur.slice(0, Yr));
        return qr ? qr.length ? qr : fi.none : Ur;
      }
    }], [{
      key: "compile",
      value: function(Ur, qr) {
        var Yr = /* @__PURE__ */ Object.create(null);
        Ur.forEach(function(Ii, Ki) {
          return Yr[Ii] = new ci(Ii, qr, Ki);
        });
        var si = qr.spec.topNode || "doc";
        if (!Yr[si])
          throw new RangeError("Schema is missing its top node type ('" + si + "')");
        if (!Yr.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (var yi in Yr.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return Yr;
      }
    }]), ci;
  }(), Ka = function() {
    function ci(ti) {
      Ir(this, ci), this.hasDefault = Object.prototype.hasOwnProperty.call(ti, "default"), this.default = ti.default;
    }
    return Hr(ci, [{
      key: "isRequired",
      get: function() {
        return !this.hasDefault;
      }
    }]), ci;
  }(), Qa = function() {
    function ci(ti, Ur, qr, Yr) {
      Ir(this, ci), this.name = ti, this.rank = Ur, this.schema = qr, this.spec = Yr, this.attrs = Yi(Yr.attrs), this.excluded = null;
      var si = za(this.attrs);
      this.instance = si ? new fi(this, si) : null;
    }
    return Hr(ci, [{
      key: "create",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return !Ur && this.instance ? this.instance : new fi(this, Ia(this.attrs, Ur));
      }
    }, {
      key: "removeFromSet",
      value: function(Ur) {
        for (var qr = 0; qr < Ur.length; qr++)
          Ur[qr].type == this && (Ur = Ur.slice(0, qr).concat(Ur.slice(qr + 1)), qr--);
        return Ur;
      }
    }, {
      key: "isInSet",
      value: function(Ur) {
        for (var qr = 0; qr < Ur.length; qr++)
          if (Ur[qr].type == this)
            return Ur[qr];
      }
    }, {
      key: "excludes",
      value: function(Ur) {
        return this.excluded.indexOf(Ur) > -1;
      }
    }], [{
      key: "compile",
      value: function(Ur, qr) {
        var Yr = /* @__PURE__ */ Object.create(null), si = 0;
        return Ur.forEach(function(yi, Ii) {
          return Yr[yi] = new ci(yi, si++, qr, Ii);
        }), Yr;
      }
    }]), ci;
  }(), Hi = function() {
    function ci(ti) {
      Ir(this, ci), this.cached = /* @__PURE__ */ Object.create(null);
      var Ur = this.spec = {};
      for (var qr in ti)
        Ur[qr] = ti[qr];
      Ur.nodes = Xr.default.from(ti.nodes), Ur.marks = Xr.default.from(ti.marks || {}), this.nodes = La.compile(this.spec.nodes, this), this.marks = Qa.compile(this.spec.marks, this);
      var Yr = /* @__PURE__ */ Object.create(null);
      for (var si in this.nodes) {
        if (si in this.marks)
          throw new RangeError(si + " can not be both a node and a mark");
        var yi = this.nodes[si], Ii = yi.spec.content || "", Ki = yi.spec.marks;
        yi.contentMatch = Yr[Ii] || (Yr[Ii] = Va.parse(Ii, this.nodes)), yi.inlineContent = yi.contentMatch.inlineContent, yi.markSet = Ki == "_" ? null : Ki ? da(this, Ki.split(" ")) : Ki == "" || !yi.inlineContent ? [] : null;
      }
      for (var ta in this.marks) {
        var va = this.marks[ta], ua = va.spec.excludes;
        va.excluded = ua == null ? [va] : ua == "" ? [] : da(this, ua.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    return Hr(ci, [{
      key: "node",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Yr = arguments.length > 2 ? arguments[2] : void 0, si = arguments.length > 3 ? arguments[3] : void 0;
        if (typeof Ur == "string")
          Ur = this.nodeType(Ur);
        else if (Ur instanceof La) {
          if (Ur.schema != this)
            throw new RangeError("Node type from different schema used (" + Ur.name + ")");
        } else
          throw new RangeError("Invalid node type: " + Ur);
        return Ur.createChecked(qr, Yr, si);
      }
    }, {
      key: "text",
      value: function(Ur, qr) {
        var Yr = this.nodes.text;
        return new ba(Yr, Yr.defaultAttrs, Ur, fi.setFrom(qr));
      }
    }, {
      key: "mark",
      value: function(Ur, qr) {
        return typeof Ur == "string" && (Ur = this.marks[Ur]), Ur.create(qr);
      }
    }, {
      key: "nodeFromJSON",
      value: function(Ur) {
        return fa.fromJSON(this, Ur);
      }
    }, {
      key: "markFromJSON",
      value: function(Ur) {
        return fi.fromJSON(this, Ur);
      }
    }, {
      key: "nodeType",
      value: function(Ur) {
        var qr = this.nodes[Ur];
        if (!qr)
          throw new RangeError("Unknown node type: " + Ur);
        return qr;
      }
    }]), ci;
  }();
  function da(ci, ti) {
    for (var Ur = [], qr = 0; qr < ti.length; qr++) {
      var Yr = ti[qr], si = ci.marks[Yr], yi = si;
      if (si)
        Ur.push(si);
      else
        for (var Ii in ci.marks) {
          var Ki = ci.marks[Ii];
          (Yr == "_" || Ki.spec.group && Ki.spec.group.split(" ").indexOf(Yr) > -1) && Ur.push(yi = Ki);
        }
      if (!yi)
        throw new SyntaxError("Unknown mark type: '" + ti[qr] + "'");
    }
    return Ur;
  }
  var aa = function() {
    function ci(ti, Ur) {
      var qr = this;
      Ir(this, ci), this.schema = ti, this.rules = Ur, this.tags = [], this.styles = [], Ur.forEach(function(Yr) {
        Yr.tag ? qr.tags.push(Yr) : Yr.style && qr.styles.push(Yr);
      }), this.normalizeLists = !this.tags.some(function(Yr) {
        if (!/^(ul|ol)\b/.test(Yr.tag) || !Yr.node)
          return !1;
        var si = ti.nodes[Yr.node];
        return si.contentMatch.matchType(si);
      });
    }
    return Hr(ci, [{
      key: "parse",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Yr = new lo(this, qr, !1);
        return Yr.addAll(Ur, qr.from, qr.to), Yr.finish();
      }
    }, {
      key: "parseSlice",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Yr = new lo(this, qr, !0);
        return Yr.addAll(Ur, qr.from, qr.to), Ci.maxOpen(Yr.finish());
      }
    }, {
      key: "matchTag",
      value: function(Ur, qr, Yr) {
        for (var si = Yr ? this.tags.indexOf(Yr) + 1 : 0; si < this.tags.length; si++) {
          var yi = this.tags[si];
          if (ho(Ur, yi.tag) && (yi.namespace === void 0 || Ur.namespaceURI == yi.namespace) && (!yi.context || qr.matchesContext(yi.context))) {
            if (yi.getAttrs) {
              var Ii = yi.getAttrs(Ur);
              if (Ii === !1)
                continue;
              yi.attrs = Ii || void 0;
            }
            return yi;
          }
        }
      }
    }, {
      key: "matchStyle",
      value: function(Ur, qr, Yr, si) {
        for (var yi = si ? this.styles.indexOf(si) + 1 : 0; yi < this.styles.length; yi++) {
          var Ii = this.styles[yi], Ki = Ii.style;
          if (!(Ki.indexOf(Ur) != 0 || Ii.context && !Yr.matchesContext(Ii.context) || Ki.length > Ur.length && (Ki.charCodeAt(Ur.length) != 61 || Ki.slice(Ur.length + 1) != qr))) {
            if (Ii.getAttrs) {
              var ta = Ii.getAttrs(qr);
              if (ta === !1)
                continue;
              Ii.attrs = ta || void 0;
            }
            return Ii;
          }
        }
      }
    }], [{
      key: "schemaRules",
      value: function(Ur) {
        var qr = [];
        function Yr(ta) {
          for (var va = ta.priority == null ? 50 : ta.priority, ua = 0; ua < qr.length; ua++) {
            var ma = qr[ua], Fa = ma.priority == null ? 50 : ma.priority;
            if (Fa < va)
              break;
          }
          qr.splice(ua, 0, ta);
        }
        var si = function(va) {
          var ua = Ur.marks[va].spec.parseDOM;
          ua && ua.forEach(function(ma) {
            Yr(ma = Mo(ma)), ma.mark || ma.ignore || ma.clearMark || (ma.mark = va);
          });
        };
        for (var yi in Ur.marks)
          si(yi);
        var Ii = function(va) {
          var ua = Ur.nodes[va].spec.parseDOM;
          ua && ua.forEach(function(ma) {
            Yr(ma = Mo(ma)), ma.node || ma.ignore || ma.mark || (ma.node = va);
          });
        };
        for (var Ki in Ur.nodes)
          Ii(Ki);
        return qr;
      }
    }, {
      key: "fromSchema",
      value: function(Ur) {
        return Ur.cached.domParser || (Ur.cached.domParser = new ci(Ur, ci.schemaRules(Ur)));
      }
    }]), ci;
  }(), oa = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  }, ja = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
  }, Ga = {
    ol: !0,
    ul: !0
  }, xa = 1, qa = 2, Ya = 4;
  function Za(ci, ti, Ur) {
    return ti != null ? (ti ? xa : 0) | (ti === "full" ? qa : 0) : ci && ci.whitespace == "pre" ? xa | qa : Ur & ~Ya;
  }
  var ko = function() {
    function ci(ti, Ur, qr, Yr, si, yi, Ii) {
      Ir(this, ci), this.type = ti, this.attrs = Ur, this.marks = qr, this.pendingMarks = Yr, this.solid = si, this.options = Ii, this.content = [], this.activeMarks = fi.none, this.stashMarks = [], this.match = yi || (Ii & Ya ? null : ti.contentMatch);
    }
    return Hr(ci, [{
      key: "findWrapping",
      value: function(Ur) {
        if (!this.match) {
          if (!this.type)
            return [];
          var qr = this.type.contentMatch.fillBefore(Qr.from(Ur));
          if (qr)
            this.match = this.type.contentMatch.matchFragment(qr);
          else {
            var Yr = this.type.contentMatch, si;
            return (si = Yr.findWrapping(Ur.type)) ? (this.match = Yr, si) : null;
          }
        }
        return this.match.findWrapping(Ur.type);
      }
    }, {
      key: "finish",
      value: function(Ur) {
        if (!(this.options & xa)) {
          var qr = this.content[this.content.length - 1], Yr;
          if (qr && qr.isText && (Yr = /[ \t\r\n\u000c]+$/.exec(qr.text))) {
            var si = qr;
            qr.text.length == Yr[0].length ? this.content.pop() : this.content[this.content.length - 1] = si.withText(si.text.slice(0, si.text.length - Yr[0].length));
          }
        }
        var yi = Qr.from(this.content);
        return !Ur && this.match && (yi = yi.append(this.match.fillBefore(Qr.empty, !0))), this.type ? this.type.create(this.attrs, yi, this.marks) : yi;
      }
    }, {
      key: "popFromStashMark",
      value: function(Ur) {
        for (var qr = this.stashMarks.length - 1; qr >= 0; qr--)
          if (Ur.eq(this.stashMarks[qr]))
            return this.stashMarks.splice(qr, 1)[0];
      }
    }, {
      key: "applyPending",
      value: function(Ur) {
        for (var qr = 0, Yr = this.pendingMarks; qr < Yr.length; qr++) {
          var si = Yr[qr];
          (this.type ? this.type.allowsMarkType(si.type) : Co(si.type, Ur)) && !si.isInSet(this.activeMarks) && (this.activeMarks = si.addToSet(this.activeMarks), this.pendingMarks = si.removeFromSet(this.pendingMarks));
        }
      }
    }, {
      key: "inlineContext",
      value: function(Ur) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : Ur.parentNode && !oa.hasOwnProperty(Ur.parentNode.nodeName.toLowerCase());
      }
    }]), ci;
  }(), lo = function() {
    function ci(ti, Ur, qr) {
      Ir(this, ci), this.parser = ti, this.options = Ur, this.isOpen = qr, this.open = 0;
      var Yr = Ur.topNode, si, yi = Za(null, Ur.preserveWhitespace, 0) | (qr ? Ya : 0);
      Yr ? si = new ko(Yr.type, Yr.attrs, fi.none, fi.none, !0, Ur.topMatch || Yr.type.contentMatch, yi) : qr ? si = new ko(null, null, fi.none, fi.none, !0, null, yi) : si = new ko(ti.schema.topNodeType, null, fi.none, fi.none, !0, null, yi), this.nodes = [si], this.find = Ur.findPositions, this.needsBlock = !1;
    }
    return Hr(ci, [{
      key: "top",
      get: function() {
        return this.nodes[this.open];
      }
    }, {
      key: "addDOM",
      value: function(Ur) {
        Ur.nodeType == 3 ? this.addTextNode(Ur) : Ur.nodeType == 1 && this.addElement(Ur);
      }
    }, {
      key: "withStyleRules",
      value: function(Ur, qr) {
        var Yr = Ur.getAttribute("style");
        if (!Yr)
          return qr();
        var si = this.readStyles(Ro(Yr));
        if (si) {
          for (var yi = lr(si, 2), Ii = yi[0], Ki = yi[1], ta = this.top, va = 0; va < Ki.length; va++)
            this.removePendingMark(Ki[va], ta);
          for (var ua = 0; ua < Ii.length; ua++)
            this.addPendingMark(Ii[ua]);
          qr();
          for (var ma = 0; ma < Ii.length; ma++)
            this.removePendingMark(Ii[ma], ta);
          for (var Fa = 0; Fa < Ki.length; Fa++)
            this.addPendingMark(Ki[Fa]);
        }
      }
    }, {
      key: "addTextNode",
      value: function(Ur) {
        var qr = Ur.nodeValue, Yr = this.top;
        if (Yr.options & qa || Yr.inlineContext(Ur) || /[^ \t\r\n\u000c]/.test(qr)) {
          if (Yr.options & xa)
            Yr.options & qa ? qr = qr.replace(/\r\n?/g, `
`) : qr = qr.replace(/\r?\n|\r/g, " ");
          else if (qr = qr.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(qr) && this.open == this.nodes.length - 1) {
            var si = Yr.content[Yr.content.length - 1], yi = Ur.previousSibling;
            (!si || yi && yi.nodeName == "BR" || si.isText && /[ \t\r\n\u000c]$/.test(si.text)) && (qr = qr.slice(1));
          }
          qr && this.insertNode(this.parser.schema.text(qr)), this.findInText(Ur);
        } else
          this.findInside(Ur);
      }
    }, {
      key: "addElement",
      value: function(Ur, qr) {
        var Yr = this, si = Ur.nodeName.toLowerCase(), yi;
        Ga.hasOwnProperty(si) && this.parser.normalizeLists && so(Ur);
        var Ii = this.options.ruleFromNode && this.options.ruleFromNode(Ur) || (yi = this.parser.matchTag(Ur, this, qr));
        if (Ii ? Ii.ignore : ja.hasOwnProperty(si))
          this.findInside(Ur), this.ignoreFallback(Ur);
        else if (!Ii || Ii.skip || Ii.closeParent) {
          Ii && Ii.closeParent ? this.open = Math.max(0, this.open - 1) : Ii && Ii.skip.nodeType && (Ur = Ii.skip);
          var Ki, ta = this.top, va = this.needsBlock;
          if (oa.hasOwnProperty(si))
            ta.content.length && ta.content[0].isInline && this.open && (this.open--, ta = this.top), Ki = !0, ta.type || (this.needsBlock = !0);
          else if (!Ur.firstChild) {
            this.leafFallback(Ur);
            return;
          }
          Ii && Ii.skip ? this.addAll(Ur) : this.withStyleRules(Ur, function() {
            return Yr.addAll(Ur);
          }), Ki && this.sync(ta), this.needsBlock = va;
        } else
          this.withStyleRules(Ur, function() {
            Yr.addElementByRule(Ur, Ii, Ii.consuming === !1 ? yi : void 0);
          });
      }
    }, {
      key: "leafFallback",
      value: function(Ur) {
        Ur.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(Ur.ownerDocument.createTextNode(`
`));
      }
    }, {
      key: "ignoreFallback",
      value: function(Ur) {
        Ur.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
      }
    }, {
      key: "readStyles",
      value: function(Ur) {
        for (var qr = this, Yr = fi.none, si = fi.none, yi = 0; yi < Ur.length; yi += 2)
          for (var Ii = function(ua) {
            var ma = qr.parser.matchStyle(Ur[yi], Ur[yi + 1], qr, ua);
            if (!ma)
              return Ki = ua, "break";
            if (ma.ignore)
              return Ki = ua, {
                v: null
              };
            if (ma.clearMark ? qr.top.pendingMarks.concat(qr.top.activeMarks).forEach(function(Fa) {
              ma.clearMark(Fa) && (si = Fa.addToSet(si));
            }) : Yr = qr.parser.schema.marks[ma.mark].create(ma.attrs).addToSet(Yr), ma.consuming === !1)
              ua = ma;
            else
              return Ki = ua, "break";
            Ki = ua;
          }, Ki = void 0; ; ) {
            var ta = Ii(Ki);
            if (ta === "break")
              break;
            if (Br(ta) === "object")
              return ta.v;
          }
        return [Yr, si];
      }
    }, {
      key: "addElementByRule",
      value: function(Ur, qr, Yr) {
        var si = this, yi, Ii, Ki;
        if (qr.node)
          Ii = this.parser.schema.nodes[qr.node], Ii.isLeaf ? this.insertNode(Ii.create(qr.attrs)) || this.leafFallback(Ur) : yi = this.enter(Ii, qr.attrs || null, qr.preserveWhitespace);
        else {
          var ta = this.parser.schema.marks[qr.mark];
          Ki = ta.create(qr.attrs), this.addPendingMark(Ki);
        }
        var va = this.top;
        if (Ii && Ii.isLeaf)
          this.findInside(Ur);
        else if (Yr)
          this.addElement(Ur, Yr);
        else if (qr.getContent)
          this.findInside(Ur), qr.getContent(Ur, this.parser.schema).forEach(function(ma) {
            return si.insertNode(ma);
          });
        else {
          var ua = Ur;
          typeof qr.contentElement == "string" ? ua = Ur.querySelector(qr.contentElement) : typeof qr.contentElement == "function" ? ua = qr.contentElement(Ur) : qr.contentElement && (ua = qr.contentElement), this.findAround(Ur, ua, !0), this.addAll(ua);
        }
        yi && this.sync(va) && this.open--, Ki && this.removePendingMark(Ki, va);
      }
    }, {
      key: "addAll",
      value: function(Ur, qr, Yr) {
        for (var si = qr || 0, yi = qr ? Ur.childNodes[qr] : Ur.firstChild, Ii = Yr == null ? null : Ur.childNodes[Yr]; yi != Ii; yi = yi.nextSibling, ++si)
          this.findAtPoint(Ur, si), this.addDOM(yi);
        this.findAtPoint(Ur, si);
      }
    }, {
      key: "findPlace",
      value: function(Ur) {
        for (var qr, Yr, si = this.open; si >= 0; si--) {
          var yi = this.nodes[si], Ii = yi.findWrapping(Ur);
          if (Ii && (!qr || qr.length > Ii.length) && (qr = Ii, Yr = yi, !Ii.length) || yi.solid)
            break;
        }
        if (!qr)
          return !1;
        this.sync(Yr);
        for (var Ki = 0; Ki < qr.length; Ki++)
          this.enterInner(qr[Ki], null, !1);
        return !0;
      }
    }, {
      key: "insertNode",
      value: function(Ur) {
        if (Ur.isInline && this.needsBlock && !this.top.type) {
          var qr = this.textblockFromContext();
          qr && this.enterInner(qr);
        }
        if (this.findPlace(Ur)) {
          this.closeExtra();
          var Yr = this.top;
          Yr.applyPending(Ur.type), Yr.match && (Yr.match = Yr.match.matchType(Ur.type));
          for (var si = Yr.activeMarks, yi = 0; yi < Ur.marks.length; yi++)
            (!Yr.type || Yr.type.allowsMarkType(Ur.marks[yi].type)) && (si = Ur.marks[yi].addToSet(si));
          return Yr.content.push(Ur.mark(si)), !0;
        }
        return !1;
      }
    }, {
      key: "enter",
      value: function(Ur, qr, Yr) {
        var si = this.findPlace(Ur.create(qr));
        return si && this.enterInner(Ur, qr, !0, Yr), si;
      }
    }, {
      key: "enterInner",
      value: function(Ur) {
        var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, si = arguments.length > 3 ? arguments[3] : void 0;
        this.closeExtra();
        var yi = this.top;
        yi.applyPending(Ur), yi.match = yi.match && yi.match.matchType(Ur);
        var Ii = Za(Ur, si, yi.options);
        yi.options & Ya && yi.content.length == 0 && (Ii |= Ya), this.nodes.push(new ko(Ur, qr, yi.activeMarks, yi.pendingMarks, Yr, null, Ii)), this.open++;
      }
    }, {
      key: "closeExtra",
      value: function() {
        var Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, qr = this.nodes.length - 1;
        if (qr > this.open) {
          for (; qr > this.open; qr--)
            this.nodes[qr - 1].content.push(this.nodes[qr].finish(Ur));
          this.nodes.length = this.open + 1;
        }
      }
    }, {
      key: "finish",
      value: function() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
      }
    }, {
      key: "sync",
      value: function(Ur) {
        for (var qr = this.open; qr >= 0; qr--)
          if (this.nodes[qr] == Ur)
            return this.open = qr, !0;
        return !1;
      }
    }, {
      key: "currentPos",
      get: function() {
        this.closeExtra();
        for (var Ur = 0, qr = this.open; qr >= 0; qr--) {
          for (var Yr = this.nodes[qr].content, si = Yr.length - 1; si >= 0; si--)
            Ur += Yr[si].nodeSize;
          qr && Ur++;
        }
        return Ur;
      }
    }, {
      key: "findAtPoint",
      value: function(Ur, qr) {
        if (this.find)
          for (var Yr = 0; Yr < this.find.length; Yr++)
            this.find[Yr].node == Ur && this.find[Yr].offset == qr && (this.find[Yr].pos = this.currentPos);
      }
    }, {
      key: "findInside",
      value: function(Ur) {
        if (this.find)
          for (var qr = 0; qr < this.find.length; qr++)
            this.find[qr].pos == null && Ur.nodeType == 1 && Ur.contains(this.find[qr].node) && (this.find[qr].pos = this.currentPos);
      }
    }, {
      key: "findAround",
      value: function(Ur, qr, Yr) {
        if (Ur != qr && this.find) {
          for (var si = 0; si < this.find.length; si++)
            if (this.find[si].pos == null && Ur.nodeType == 1 && Ur.contains(this.find[si].node)) {
              var yi = qr.compareDocumentPosition(this.find[si].node);
              yi & (Yr ? 2 : 4) && (this.find[si].pos = this.currentPos);
            }
        }
      }
    }, {
      key: "findInText",
      value: function(Ur) {
        if (this.find)
          for (var qr = 0; qr < this.find.length; qr++)
            this.find[qr].node == Ur && (this.find[qr].pos = this.currentPos - (Ur.nodeValue.length - this.find[qr].offset));
      }
    }, {
      key: "matchesContext",
      value: function(Ur) {
        var qr = this;
        if (Ur.indexOf("|") > -1)
          return Ur.split(/\s*\|\s*/).some(this.matchesContext, this);
        var Yr = Ur.split("/"), si = this.options.context, yi = !this.isOpen && (!si || si.parent.type == this.nodes[0].type), Ii = -(si ? si.depth + 1 : 0) + (yi ? 0 : 1), Ki = function ta(va, ua) {
          for (; va >= 0; va--) {
            var ma = Yr[va];
            if (ma == "") {
              if (va == Yr.length - 1 || va == 0)
                continue;
              for (; ua >= Ii; ua--)
                if (ta(va - 1, ua))
                  return !0;
              return !1;
            } else {
              var Fa = ua > 0 || ua == 0 && yi ? qr.nodes[ua].type : si && ua >= Ii ? si.node(ua - Ii).type : null;
              if (!Fa || Fa.name != ma && Fa.groups.indexOf(ma) == -1)
                return !1;
              ua--;
            }
          }
          return !0;
        };
        return Ki(Yr.length - 1, this.open);
      }
    }, {
      key: "textblockFromContext",
      value: function() {
        var Ur = this.options.context;
        if (Ur)
          for (var qr = Ur.depth; qr >= 0; qr--) {
            var Yr = Ur.node(qr).contentMatchAt(Ur.indexAfter(qr)).defaultType;
            if (Yr && Yr.isTextblock && Yr.defaultAttrs)
              return Yr;
          }
        for (var si in this.parser.schema.nodes) {
          var yi = this.parser.schema.nodes[si];
          if (yi.isTextblock && yi.defaultAttrs)
            return yi;
        }
      }
    }, {
      key: "addPendingMark",
      value: function(Ur) {
        var qr = uo(Ur, this.top.pendingMarks);
        qr && this.top.stashMarks.push(qr), this.top.pendingMarks = Ur.addToSet(this.top.pendingMarks);
      }
    }, {
      key: "removePendingMark",
      value: function(Ur, qr) {
        for (var Yr = this.open; Yr >= 0; Yr--) {
          var si = this.nodes[Yr], yi = si.pendingMarks.lastIndexOf(Ur);
          if (yi > -1)
            si.pendingMarks = Ur.removeFromSet(si.pendingMarks);
          else {
            si.activeMarks = Ur.removeFromSet(si.activeMarks);
            var Ii = si.popFromStashMark(Ur);
            Ii && si.type && si.type.allowsMarkType(Ii.type) && (si.activeMarks = Ii.addToSet(si.activeMarks));
          }
          if (si == qr)
            break;
        }
      }
    }]), ci;
  }();
  function so(ci) {
    for (var ti = ci.firstChild, Ur = null; ti; ti = ti.nextSibling) {
      var qr = ti.nodeType == 1 ? ti.nodeName.toLowerCase() : null;
      qr && Ga.hasOwnProperty(qr) && Ur ? (Ur.appendChild(ti), ti = Ur) : qr == "li" ? Ur = ti : qr && (Ur = null);
    }
  }
  function ho(ci, ti) {
    return (ci.matches || ci.msMatchesSelector || ci.webkitMatchesSelector || ci.mozMatchesSelector).call(ci, ti);
  }
  function Ro(ci) {
    for (var ti = /\s*([\w-]+)\s*:\s*([^;]+)/g, Ur, qr = []; Ur = ti.exec(ci); )
      qr.push(Ur[1], Ur[2].trim());
    return qr;
  }
  function Mo(ci) {
    var ti = {};
    for (var Ur in ci)
      ti[Ur] = ci[Ur];
    return ti;
  }
  function Co(ci, ti) {
    var Ur = ti.schema.nodes, qr = function(Ii) {
      var Ki = Ur[Ii];
      if (!Ki.allowsMarkType(ci))
        return "continue";
      var ta = [], va = function ua(ma) {
        ta.push(ma);
        for (var Fa = 0; Fa < ma.edgeCount; Fa++) {
          var fo = ma.edge(Fa), _o = fo.type, No = fo.next;
          if (_o == ti || ta.indexOf(No) < 0 && ua(No))
            return !0;
        }
      };
      if (va(Ki.contentMatch))
        return {
          v: !0
        };
    };
    for (var Yr in Ur) {
      var si = qr(Yr);
      if (si !== "continue" && Br(si) === "object")
        return si.v;
    }
  }
  function uo(ci, ti) {
    for (var Ur = 0; Ur < ti.length; Ur++)
      if (ci.eq(ti[Ur]))
        return ti[Ur];
  }
  var wa = function() {
    function ci(ti, Ur) {
      Ir(this, ci), this.nodes = ti, this.marks = Ur;
    }
    return Hr(ci, [{
      key: "serializeFragment",
      value: function(Ur) {
        var qr = this, Yr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, si = arguments.length > 2 ? arguments[2] : void 0;
        si || (si = ca(Yr).createDocumentFragment());
        var yi = si, Ii = [];
        return Ur.forEach(function(Ki) {
          if (Ii.length || Ki.marks.length) {
            for (var ta = 0, va = 0; ta < Ii.length && va < Ki.marks.length; ) {
              var ua = Ki.marks[va];
              if (!qr.marks[ua.type.name]) {
                va++;
                continue;
              }
              if (!ua.eq(Ii[ta][0]) || ua.type.spec.spanning === !1)
                break;
              ta++, va++;
            }
            for (; ta < Ii.length; )
              yi = Ii.pop()[1];
            for (; va < Ki.marks.length; ) {
              var ma = Ki.marks[va++], Fa = qr.serializeMark(ma, Ki.isInline, Yr);
              Fa && (Ii.push([ma, yi]), yi.appendChild(Fa.dom), yi = Fa.contentDOM || Fa.dom);
            }
          }
          yi.appendChild(qr.serializeNodeInner(Ki, Yr));
        }), si;
      }
    }, {
      key: "serializeNodeInner",
      value: function(Ur, qr) {
        var Yr = ci.renderSpec(ca(qr), this.nodes[Ur.type.name](Ur)), si = Yr.dom, yi = Yr.contentDOM;
        if (yi) {
          if (Ur.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(Ur.content, qr, yi);
        }
        return si;
      }
    }, {
      key: "serializeNode",
      value: function(Ur) {
        for (var qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Yr = this.serializeNodeInner(Ur, qr), si = Ur.marks.length - 1; si >= 0; si--) {
          var yi = this.serializeMark(Ur.marks[si], Ur.isInline, qr);
          yi && ((yi.contentDOM || yi.dom).appendChild(Yr), Yr = yi.dom);
        }
        return Yr;
      }
    }, {
      key: "serializeMark",
      value: function(Ur, qr) {
        var Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, si = this.marks[Ur.type.name];
        return si && ci.renderSpec(ca(Yr), si(Ur, qr));
      }
    }], [{
      key: "renderSpec",
      value: function(Ur, qr) {
        var Yr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (typeof qr == "string")
          return {
            dom: Ur.createTextNode(qr)
          };
        if (qr.nodeType != null)
          return {
            dom: qr
          };
        if (qr.dom && qr.dom.nodeType != null)
          return qr;
        var si = qr[0], yi = si.indexOf(" ");
        yi > 0 && (Yr = si.slice(0, yi), si = si.slice(yi + 1));
        var Ii, Ki = Yr ? Ur.createElementNS(Yr, si) : Ur.createElement(si), ta = qr[1], va = 1;
        if (ta && Br(ta) == "object" && ta.nodeType == null && !Array.isArray(ta)) {
          va = 2;
          for (var ua in ta)
            if (ta[ua] != null) {
              var ma = ua.indexOf(" ");
              ma > 0 ? Ki.setAttributeNS(ua.slice(0, ma), ua.slice(ma + 1), ta[ua]) : Ki.setAttribute(ua, ta[ua]);
            }
        }
        for (var Fa = va; Fa < qr.length; Fa++) {
          var fo = qr[Fa];
          if (fo === 0) {
            if (Fa < qr.length - 1 || Fa > va)
              throw new RangeError("Content hole must be the only child of its parent node");
            return {
              dom: Ki,
              contentDOM: Ki
            };
          } else {
            var _o = ci.renderSpec(Ur, fo, Yr), No = _o.dom, Bo = _o.contentDOM;
            if (Ki.appendChild(No), Bo) {
              if (Ii)
                throw new RangeError("Multiple content holes");
              Ii = Bo;
            }
          }
        }
        return {
          dom: Ki,
          contentDOM: Ii
        };
      }
    }, {
      key: "fromSchema",
      value: function(Ur) {
        return Ur.cached.domSerializer || (Ur.cached.domSerializer = new ci(this.nodesFromSchema(Ur), this.marksFromSchema(Ur)));
      }
    }, {
      key: "nodesFromSchema",
      value: function(Ur) {
        var qr = $i(Ur.nodes);
        return qr.text || (qr.text = function(Yr) {
          return Yr.text;
        }), qr;
      }
    }, {
      key: "marksFromSchema",
      value: function(Ur) {
        return $i(Ur.marks);
      }
    }]), ci;
  }();
  function $i(ci) {
    var ti = {};
    for (var Ur in ci) {
      var qr = ci[Ur].spec.toDOM;
      qr && (ti[Ur] = qr);
    }
    return ti;
  }
  function ca(ci) {
    return ci.document || window.document;
  }
  return dist$7.ContentMatch = Va, dist$7.DOMParser = aa, dist$7.DOMSerializer = wa, dist$7.Fragment = Qr, dist$7.Mark = fi, dist$7.MarkType = Qa, dist$7.Node = fa, dist$7.NodeRange = sa, dist$7.NodeType = La, dist$7.ReplaceError = gi, dist$7.ResolvedPos = Ei, dist$7.Schema = Hi, dist$7.Slice = Ci, dist$7;
}
var distExports$5 = requireDist$5(), dist$5 = {}, dist$4 = {};
const lower16 = 65535, factor16 = Math.pow(2, 16);
function makeRecover(lr, ar) {
  return lr + ar * factor16;
}
function recoverIndex(lr) {
  return lr & lower16;
}
function recoverOffset(lr) {
  return (lr - (lr & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(ar, cr, ur) {
    this.pos = ar, this.delInfo = cr, this.recover = ur;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ar, cr = !1) {
    if (this.ranges = ar, this.inverted = cr, !ar.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(ar) {
    let cr = 0, ur = recoverIndex(ar);
    if (!this.inverted)
      for (let fr = 0; fr < ur; fr++)
        cr += this.ranges[fr * 3 + 2] - this.ranges[fr * 3 + 1];
    return this.ranges[ur * 3] + cr + recoverOffset(ar);
  }
  mapResult(ar, cr = 1) {
    return this._map(ar, cr, !1);
  }
  map(ar, cr = 1) {
    return this._map(ar, cr, !0);
  }
  /**
  @internal
  */
  _map(ar, cr, ur) {
    let fr = 0, dr = this.inverted ? 2 : 1, gr = this.inverted ? 1 : 2;
    for (let mr = 0; mr < this.ranges.length; mr += 3) {
      let vr = this.ranges[mr] - (this.inverted ? fr : 0);
      if (vr > ar)
        break;
      let yr = this.ranges[mr + dr], kr = this.ranges[mr + gr], _r = vr + yr;
      if (ar <= _r) {
        let xr = yr ? ar == vr ? -1 : ar == _r ? 1 : cr : cr, Sr = vr + fr + (xr < 0 ? 0 : kr);
        if (ur)
          return Sr;
        let Er = ar == (cr < 0 ? vr : _r) ? null : makeRecover(mr / 3, ar - vr), Cr = ar == vr ? DEL_AFTER : ar == _r ? DEL_BEFORE : DEL_ACROSS;
        return (cr < 0 ? ar != vr : ar != _r) && (Cr |= DEL_SIDE), new MapResult(Sr, Cr, Er);
      }
      fr += kr - yr;
    }
    return ur ? ar + fr : new MapResult(ar + fr, 0, null);
  }
  /**
  @internal
  */
  touches(ar, cr) {
    let ur = 0, fr = recoverIndex(cr), dr = this.inverted ? 2 : 1, gr = this.inverted ? 1 : 2;
    for (let mr = 0; mr < this.ranges.length; mr += 3) {
      let vr = this.ranges[mr] - (this.inverted ? ur : 0);
      if (vr > ar)
        break;
      let yr = this.ranges[mr + dr], kr = vr + yr;
      if (ar <= kr && mr == fr * 3)
        return !0;
      ur += this.ranges[mr + gr] - yr;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(ar) {
    let cr = this.inverted ? 2 : 1, ur = this.inverted ? 1 : 2;
    for (let fr = 0, dr = 0; fr < this.ranges.length; fr += 3) {
      let gr = this.ranges[fr], mr = gr - (this.inverted ? dr : 0), vr = gr + (this.inverted ? 0 : dr), yr = this.ranges[fr + cr], kr = this.ranges[fr + ur];
      ar(mr, mr + yr, vr, vr + kr), dr += kr - yr;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(ar) {
    return ar == 0 ? StepMap.empty : new StepMap(ar < 0 ? [0, -ar, 0] : [0, 0, ar]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(ar = [], cr, ur = 0, fr = ar.length) {
    this.maps = ar, this.mirror = cr, this.from = ur, this.to = fr;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(ar = 0, cr = this.maps.length) {
    return new Mapping(this.maps, this.mirror, ar, cr);
  }
  /**
  @internal
  */
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(ar, cr) {
    this.to = this.maps.push(ar), cr != null && this.setMirror(this.maps.length - 1, cr);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(ar) {
    for (let cr = 0, ur = this.maps.length; cr < ar.maps.length; cr++) {
      let fr = ar.getMirror(cr);
      this.appendMap(ar.maps[cr], fr != null && fr < cr ? ur + fr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(ar) {
    if (this.mirror) {
      for (let cr = 0; cr < this.mirror.length; cr++)
        if (this.mirror[cr] == ar)
          return this.mirror[cr + (cr % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(ar, cr) {
    this.mirror || (this.mirror = []), this.mirror.push(ar, cr);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(ar) {
    for (let cr = ar.maps.length - 1, ur = this.maps.length + ar.maps.length; cr >= 0; cr--) {
      let fr = ar.getMirror(cr);
      this.appendMap(ar.maps[cr].invert(), fr != null && fr > cr ? ur - fr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let ar = new Mapping();
    return ar.appendMappingInverted(this), ar;
  }
  /**
  Map a position through this mapping.
  */
  map(ar, cr = 1) {
    if (this.mirror)
      return this._map(ar, cr, !0);
    for (let ur = this.from; ur < this.to; ur++)
      ar = this.maps[ur].map(ar, cr);
    return ar;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(ar, cr = 1) {
    return this._map(ar, cr, !1);
  }
  /**
  @internal
  */
  _map(ar, cr, ur) {
    let fr = 0;
    for (let dr = this.from; dr < this.to; dr++) {
      let gr = this.maps[dr], mr = gr.mapResult(ar, cr);
      if (mr.recover != null) {
        let vr = this.getMirror(dr);
        if (vr != null && vr > dr && vr < this.to) {
          dr = vr, ar = this.maps[vr].recover(mr.recover);
          continue;
        }
      }
      fr |= mr.delInfo, ar = mr.pos;
    }
    return ur ? ar : new MapResult(ar, fr, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(ar) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(ar, cr) {
    if (!cr || !cr.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let ur = stepsByID[cr.stepType];
    if (!ur)
      throw new RangeError(`No step type ${cr.stepType} defined`);
    return ur.fromJSON(ar, cr);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(ar, cr) {
    if (ar in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + ar);
    return stepsByID[ar] = cr, cr.prototype.jsonID = ar, cr;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(ar, cr) {
    this.doc = ar, this.failed = cr;
  }
  /**
  Create a successful step result.
  */
  static ok(ar) {
    return new StepResult(ar, null);
  }
  /**
  Create a failed step result.
  */
  static fail(ar) {
    return new StepResult(null, ar);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(ar, cr, ur, fr) {
    try {
      return StepResult.ok(ar.replace(cr, ur, fr));
    } catch (dr) {
      if (dr instanceof distExports$5.ReplaceError)
        return StepResult.fail(dr.message);
      throw dr;
    }
  }
}
function mapFragment(lr, ar, cr) {
  let ur = [];
  for (let fr = 0; fr < lr.childCount; fr++) {
    let dr = lr.child(fr);
    dr.content.size && (dr = dr.copy(mapFragment(dr.content, ar, dr))), dr.isInline && (dr = ar(dr, cr, fr)), ur.push(dr);
  }
  return distExports$5.Fragment.fromArray(ur);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(ar, cr, ur) {
    super(), this.from = ar, this.to = cr, this.mark = ur;
  }
  apply(ar) {
    let cr = ar.slice(this.from, this.to), ur = ar.resolve(this.from), fr = ur.node(ur.sharedDepth(this.to)), dr = new distExports$5.Slice(mapFragment(cr.content, (gr, mr) => !gr.isAtom || !mr.type.allowsMarkType(this.mark.type) ? gr : gr.mark(this.mark.addToSet(gr.marks)), fr), cr.openStart, cr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, dr);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deleted && ur.deleted || cr.pos >= ur.pos ? null : new AddMarkStep(cr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof AddMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new AddMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(cr.from, cr.to, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, cr, ur) {
    super(), this.from = ar, this.to = cr, this.mark = ur;
  }
  apply(ar) {
    let cr = ar.slice(this.from, this.to), ur = new distExports$5.Slice(mapFragment(cr.content, (fr) => fr.mark(this.mark.removeFromSet(fr.marks)), ar), cr.openStart, cr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, ur);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deleted && ur.deleted || cr.pos >= ur.pos ? null : new RemoveMarkStep(cr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof RemoveMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new RemoveMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(cr.from, cr.to, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(ar, cr) {
    super(), this.pos = ar, this.mark = cr;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at mark step's position");
    let ur = cr.type.create(cr.attrs, null, this.mark.addToSet(cr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, cr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let cr = ar.nodeAt(this.pos);
    if (cr) {
      let ur = this.mark.addToSet(cr.marks);
      if (ur.length == cr.marks.length) {
        for (let fr = 0; fr < cr.marks.length; fr++)
          if (!cr.marks[fr].isInSet(ur))
            return new AddNodeMarkStep(this.pos, cr.marks[fr]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new AddNodeMarkStep(cr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(cr.pos, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, cr) {
    super(), this.pos = ar, this.mark = cr;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at mark step's position");
    let ur = cr.type.create(cr.attrs, null, this.mark.removeFromSet(cr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, cr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let cr = ar.nodeAt(this.pos);
    return !cr || !this.mark.isInSet(cr.marks) ? this : new AddNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new RemoveNodeMarkStep(cr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(cr.pos, ar.markFromJSON(cr.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(ar, cr, ur, fr = !1) {
    super(), this.from = ar, this.to = cr, this.slice = ur, this.structure = fr;
  }
  apply(ar) {
    return this.structure && contentBetween(ar, this.from, this.to) ? StepResult.fail("Structure replace would overwrite content") : StepResult.fromReplace(ar, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(ar) {
    return new ReplaceStep(this.from, this.from + this.slice.size, ar.slice(this.from, this.to));
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return cr.deletedAcross && ur.deletedAcross ? null : new ReplaceStep(cr.pos, Math.max(cr.pos, ur.pos), this.slice);
  }
  merge(ar) {
    if (!(ar instanceof ReplaceStep) || ar.structure || this.structure)
      return null;
    if (this.from + this.slice.size == ar.from && !this.slice.openEnd && !ar.slice.openStart) {
      let cr = this.slice.size + ar.slice.size == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(this.slice.content.append(ar.slice.content), this.slice.openStart, ar.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (ar.to - ar.from), cr, this.structure);
    } else if (ar.to == this.from && !this.slice.openStart && !ar.slice.openEnd) {
      let cr = this.slice.size + ar.slice.size == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(ar.slice.content.append(this.slice.content), ar.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(ar.from, this.to, cr, this.structure);
    } else
      return null;
  }
  toJSON() {
    let ar = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(cr.from, cr.to, distExports$5.Slice.fromJSON(ar, cr.slice), !!cr.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(ar, cr, ur, fr, dr, gr, mr = !1) {
    super(), this.from = ar, this.to = cr, this.gapFrom = ur, this.gapTo = fr, this.slice = dr, this.insert = gr, this.structure = mr;
  }
  apply(ar) {
    if (this.structure && (contentBetween(ar, this.from, this.gapFrom) || contentBetween(ar, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let cr = ar.slice(this.gapFrom, this.gapTo);
    if (cr.openStart || cr.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let ur = this.slice.insertAt(this.insert, cr.content);
    return ur ? StepResult.fromReplace(ar, this.from, this.to, ur) : StepResult.fail("Content does not fit in gap");
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(ar) {
    let cr = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + cr, this.from + this.insert, this.from + this.insert + cr, ar.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(ar) {
    let cr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1), fr = ar.map(this.gapFrom, -1), dr = ar.map(this.gapTo, 1);
    return cr.deletedAcross && ur.deletedAcross || fr < cr.pos || dr > ur.pos ? null : new ReplaceAroundStep(cr.pos, ur.pos, fr, dr, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let ar = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, cr) {
    if (typeof cr.from != "number" || typeof cr.to != "number" || typeof cr.gapFrom != "number" || typeof cr.gapTo != "number" || typeof cr.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(cr.from, cr.to, cr.gapFrom, cr.gapTo, distExports$5.Slice.fromJSON(ar, cr.slice), cr.insert, !!cr.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(lr, ar, cr) {
  let ur = lr.resolve(ar), fr = cr - ar, dr = ur.depth;
  for (; fr > 0 && dr > 0 && ur.indexAfter(dr) == ur.node(dr).childCount; )
    dr--, fr--;
  if (fr > 0) {
    let gr = ur.node(dr).maybeChild(ur.indexAfter(dr));
    for (; fr > 0; ) {
      if (!gr || gr.isLeaf)
        return !0;
      gr = gr.firstChild, fr--;
    }
  }
  return !1;
}
function addMark(lr, ar, cr, ur) {
  let fr = [], dr = [], gr, mr;
  lr.doc.nodesBetween(ar, cr, (vr, yr, kr) => {
    if (!vr.isInline)
      return;
    let _r = vr.marks;
    if (!ur.isInSet(_r) && kr.type.allowsMarkType(ur.type)) {
      let xr = Math.max(yr, ar), Sr = Math.min(yr + vr.nodeSize, cr), Er = ur.addToSet(_r);
      for (let Cr = 0; Cr < _r.length; Cr++)
        _r[Cr].isInSet(Er) || (gr && gr.to == xr && gr.mark.eq(_r[Cr]) ? gr.to = Sr : fr.push(gr = new RemoveMarkStep(xr, Sr, _r[Cr])));
      mr && mr.to == xr ? mr.to = Sr : dr.push(mr = new AddMarkStep(xr, Sr, ur));
    }
  }), fr.forEach((vr) => lr.step(vr)), dr.forEach((vr) => lr.step(vr));
}
function removeMark(lr, ar, cr, ur) {
  let fr = [], dr = 0;
  lr.doc.nodesBetween(ar, cr, (gr, mr) => {
    if (!gr.isInline)
      return;
    dr++;
    let vr = null;
    if (ur instanceof distExports$5.MarkType) {
      let yr = gr.marks, kr;
      for (; kr = ur.isInSet(yr); )
        (vr || (vr = [])).push(kr), yr = kr.removeFromSet(yr);
    } else
      ur ? ur.isInSet(gr.marks) && (vr = [ur]) : vr = gr.marks;
    if (vr && vr.length) {
      let yr = Math.min(mr + gr.nodeSize, cr);
      for (let kr = 0; kr < vr.length; kr++) {
        let _r = vr[kr], xr;
        for (let Sr = 0; Sr < fr.length; Sr++) {
          let Er = fr[Sr];
          Er.step == dr - 1 && _r.eq(fr[Sr].style) && (xr = Er);
        }
        xr ? (xr.to = yr, xr.step = dr) : fr.push({ style: _r, from: Math.max(mr, ar), to: yr, step: dr });
      }
    }
  }), fr.forEach((gr) => lr.step(new RemoveMarkStep(gr.from, gr.to, gr.style)));
}
function clearIncompatible(lr, ar, cr, ur = cr.contentMatch) {
  let fr = lr.doc.nodeAt(ar), dr = [], gr = ar + 1;
  for (let mr = 0; mr < fr.childCount; mr++) {
    let vr = fr.child(mr), yr = gr + vr.nodeSize, kr = ur.matchType(vr.type);
    if (!kr)
      dr.push(new ReplaceStep(gr, yr, distExports$5.Slice.empty));
    else {
      ur = kr;
      for (let _r = 0; _r < vr.marks.length; _r++)
        cr.allowsMarkType(vr.marks[_r].type) || lr.step(new RemoveMarkStep(gr, yr, vr.marks[_r]));
      if (vr.isText && !cr.spec.code) {
        let _r, xr = /\r?\n|\r/g, Sr;
        for (; _r = xr.exec(vr.text); )
          Sr || (Sr = new distExports$5.Slice(distExports$5.Fragment.from(cr.schema.text(" ", cr.allowedMarks(vr.marks))), 0, 0)), dr.push(new ReplaceStep(gr + _r.index, gr + _r.index + _r[0].length, Sr));
      }
    }
    gr = yr;
  }
  if (!ur.validEnd) {
    let mr = ur.fillBefore(distExports$5.Fragment.empty, !0);
    lr.replace(gr, gr, new distExports$5.Slice(mr, 0, 0));
  }
  for (let mr = dr.length - 1; mr >= 0; mr--)
    lr.step(dr[mr]);
}
function canCut(lr, ar, cr) {
  return (ar == 0 || lr.canReplace(ar, lr.childCount)) && (cr == lr.childCount || lr.canReplace(0, cr));
}
function liftTarget(lr) {
  let cr = lr.parent.content.cutByIndex(lr.startIndex, lr.endIndex);
  for (let ur = lr.depth; ; --ur) {
    let fr = lr.$from.node(ur), dr = lr.$from.index(ur), gr = lr.$to.indexAfter(ur);
    if (ur < lr.depth && fr.canReplace(dr, gr, cr))
      return ur;
    if (ur == 0 || fr.type.spec.isolating || !canCut(fr, dr, gr))
      break;
  }
  return null;
}
function lift(lr, ar, cr) {
  let { $from: ur, $to: fr, depth: dr } = ar, gr = ur.before(dr + 1), mr = fr.after(dr + 1), vr = gr, yr = mr, kr = distExports$5.Fragment.empty, _r = 0;
  for (let Er = dr, Cr = !1; Er > cr; Er--)
    Cr || ur.index(Er) > 0 ? (Cr = !0, kr = distExports$5.Fragment.from(ur.node(Er).copy(kr)), _r++) : vr--;
  let xr = distExports$5.Fragment.empty, Sr = 0;
  for (let Er = dr, Cr = !1; Er > cr; Er--)
    Cr || fr.after(Er + 1) < fr.end(Er) ? (Cr = !0, xr = distExports$5.Fragment.from(fr.node(Er).copy(xr)), Sr++) : yr++;
  lr.step(new ReplaceAroundStep(vr, yr, gr, mr, new distExports$5.Slice(kr.append(xr), _r, Sr), kr.size - _r, !0));
}
function findWrapping(lr, ar, cr = null, ur = lr) {
  let fr = findWrappingOutside$1(lr, ar), dr = fr && findWrappingInside$1(ur, ar);
  return dr ? fr.map(withAttrs).concat({ type: ar, attrs: cr }).concat(dr.map(withAttrs)) : null;
}
function withAttrs(lr) {
  return { type: lr, attrs: null };
}
function findWrappingOutside$1(lr, ar) {
  let { parent: cr, startIndex: ur, endIndex: fr } = lr, dr = cr.contentMatchAt(ur).findWrapping(ar);
  if (!dr)
    return null;
  let gr = dr.length ? dr[0] : ar;
  return cr.canReplaceWith(ur, fr, gr) ? dr : null;
}
function findWrappingInside$1(lr, ar) {
  let { parent: cr, startIndex: ur, endIndex: fr } = lr, dr = cr.child(ur), gr = ar.contentMatch.findWrapping(dr.type);
  if (!gr)
    return null;
  let vr = (gr.length ? gr[gr.length - 1] : ar).contentMatch;
  for (let yr = ur; vr && yr < fr; yr++)
    vr = vr.matchType(cr.child(yr).type);
  return !vr || !vr.validEnd ? null : gr;
}
function wrap(lr, ar, cr) {
  let ur = distExports$5.Fragment.empty;
  for (let gr = cr.length - 1; gr >= 0; gr--) {
    if (ur.size) {
      let mr = cr[gr].type.contentMatch.matchFragment(ur);
      if (!mr || !mr.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    ur = distExports$5.Fragment.from(cr[gr].type.create(cr[gr].attrs, ur));
  }
  let fr = ar.start, dr = ar.end;
  lr.step(new ReplaceAroundStep(fr, dr, fr, dr, new distExports$5.Slice(ur, 0, 0), cr.length, !0));
}
function setBlockType$1(lr, ar, cr, ur, fr) {
  if (!ur.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let dr = lr.steps.length;
  lr.doc.nodesBetween(ar, cr, (gr, mr) => {
    if (gr.isTextblock && !gr.hasMarkup(ur, fr) && canChangeType(lr.doc, lr.mapping.slice(dr).map(mr), ur)) {
      lr.clearIncompatible(lr.mapping.slice(dr).map(mr, 1), ur);
      let vr = lr.mapping.slice(dr), yr = vr.map(mr, 1), kr = vr.map(mr + gr.nodeSize, 1);
      return lr.step(new ReplaceAroundStep(yr, kr, yr + 1, kr - 1, new distExports$5.Slice(distExports$5.Fragment.from(ur.create(fr, null, gr.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function canChangeType(lr, ar, cr) {
  let ur = lr.resolve(ar), fr = ur.index();
  return ur.parent.canReplaceWith(fr, fr + 1, cr);
}
function setNodeMarkup(lr, ar, cr, ur, fr) {
  let dr = lr.doc.nodeAt(ar);
  if (!dr)
    throw new RangeError("No node at given position");
  cr || (cr = dr.type);
  let gr = cr.create(ur, null, fr || dr.marks);
  if (dr.isLeaf)
    return lr.replaceWith(ar, ar + dr.nodeSize, gr);
  if (!cr.validContent(dr.content))
    throw new RangeError("Invalid content for node type " + cr.name);
  lr.step(new ReplaceAroundStep(ar, ar + dr.nodeSize, ar + 1, ar + dr.nodeSize - 1, new distExports$5.Slice(distExports$5.Fragment.from(gr), 0, 0), 1, !0));
}
function canSplit(lr, ar, cr = 1, ur) {
  let fr = lr.resolve(ar), dr = fr.depth - cr, gr = ur && ur[ur.length - 1] || fr.parent;
  if (dr < 0 || fr.parent.type.spec.isolating || !fr.parent.canReplace(fr.index(), fr.parent.childCount) || !gr.type.validContent(fr.parent.content.cutByIndex(fr.index(), fr.parent.childCount)))
    return !1;
  for (let yr = fr.depth - 1, kr = cr - 2; yr > dr; yr--, kr--) {
    let _r = fr.node(yr), xr = fr.index(yr);
    if (_r.type.spec.isolating)
      return !1;
    let Sr = _r.content.cutByIndex(xr, _r.childCount), Er = ur && ur[kr + 1];
    Er && (Sr = Sr.replaceChild(0, Er.type.create(Er.attrs)));
    let Cr = ur && ur[kr] || _r;
    if (!_r.canReplace(xr + 1, _r.childCount) || !Cr.type.validContent(Sr))
      return !1;
  }
  let mr = fr.indexAfter(dr), vr = ur && ur[0];
  return fr.node(dr).canReplaceWith(mr, mr, vr ? vr.type : fr.node(dr + 1).type);
}
function split(lr, ar, cr = 1, ur) {
  let fr = lr.doc.resolve(ar), dr = distExports$5.Fragment.empty, gr = distExports$5.Fragment.empty;
  for (let mr = fr.depth, vr = fr.depth - cr, yr = cr - 1; mr > vr; mr--, yr--) {
    dr = distExports$5.Fragment.from(fr.node(mr).copy(dr));
    let kr = ur && ur[yr];
    gr = distExports$5.Fragment.from(kr ? kr.type.create(kr.attrs, gr) : fr.node(mr).copy(gr));
  }
  lr.step(new ReplaceStep(ar, ar, new distExports$5.Slice(dr.append(gr), cr, cr), !0));
}
function canJoin(lr, ar) {
  let cr = lr.resolve(ar), ur = cr.index();
  return joinable(cr.nodeBefore, cr.nodeAfter) && cr.parent.canReplace(ur, ur + 1);
}
function joinable(lr, ar) {
  return !!(lr && ar && !lr.isLeaf && lr.canAppend(ar));
}
function joinPoint(lr, ar, cr = -1) {
  let ur = lr.resolve(ar);
  for (let fr = ur.depth; ; fr--) {
    let dr, gr, mr = ur.index(fr);
    if (fr == ur.depth ? (dr = ur.nodeBefore, gr = ur.nodeAfter) : cr > 0 ? (dr = ur.node(fr + 1), mr++, gr = ur.node(fr).maybeChild(mr)) : (dr = ur.node(fr).maybeChild(mr - 1), gr = ur.node(fr + 1)), dr && !dr.isTextblock && joinable(dr, gr) && ur.node(fr).canReplace(mr, mr + 1))
      return ar;
    if (fr == 0)
      break;
    ar = cr < 0 ? ur.before(fr) : ur.after(fr);
  }
}
function join(lr, ar, cr) {
  let ur = new ReplaceStep(ar - cr, ar + cr, distExports$5.Slice.empty, !0);
  lr.step(ur);
}
function insertPoint(lr, ar, cr) {
  let ur = lr.resolve(ar);
  if (ur.parent.canReplaceWith(ur.index(), ur.index(), cr))
    return ar;
  if (ur.parentOffset == 0)
    for (let fr = ur.depth - 1; fr >= 0; fr--) {
      let dr = ur.index(fr);
      if (ur.node(fr).canReplaceWith(dr, dr, cr))
        return ur.before(fr + 1);
      if (dr > 0)
        return null;
    }
  if (ur.parentOffset == ur.parent.content.size)
    for (let fr = ur.depth - 1; fr >= 0; fr--) {
      let dr = ur.indexAfter(fr);
      if (ur.node(fr).canReplaceWith(dr, dr, cr))
        return ur.after(fr + 1);
      if (dr < ur.node(fr).childCount)
        return null;
    }
  return null;
}
function dropPoint(lr, ar, cr) {
  let ur = lr.resolve(ar);
  if (!cr.content.size)
    return ar;
  let fr = cr.content;
  for (let dr = 0; dr < cr.openStart; dr++)
    fr = fr.firstChild.content;
  for (let dr = 1; dr <= (cr.openStart == 0 && cr.size ? 2 : 1); dr++)
    for (let gr = ur.depth; gr >= 0; gr--) {
      let mr = gr == ur.depth ? 0 : ur.pos <= (ur.start(gr + 1) + ur.end(gr + 1)) / 2 ? -1 : 1, vr = ur.index(gr) + (mr > 0 ? 1 : 0), yr = ur.node(gr), kr = !1;
      if (dr == 1)
        kr = yr.canReplace(vr, vr, fr);
      else {
        let _r = yr.contentMatchAt(vr).findWrapping(fr.firstChild.type);
        kr = _r && yr.canReplaceWith(vr, vr, _r[0]);
      }
      if (kr)
        return mr == 0 ? ur.pos : mr < 0 ? ur.before(gr + 1) : ur.after(gr + 1);
    }
  return null;
}
function replaceStep(lr, ar, cr = ar, ur = distExports$5.Slice.empty) {
  if (ar == cr && !ur.size)
    return null;
  let fr = lr.resolve(ar), dr = lr.resolve(cr);
  return fitsTrivially(fr, dr, ur) ? new ReplaceStep(ar, cr, ur) : new Fitter(fr, dr, ur).fit();
}
function fitsTrivially(lr, ar, cr) {
  return !cr.openStart && !cr.openEnd && lr.start() == ar.start() && lr.parent.canReplace(lr.index(), ar.index(), cr.content);
}
class Fitter {
  constructor(ar, cr, ur) {
    this.$from = ar, this.$to = cr, this.unplaced = ur, this.frontier = [], this.placed = distExports$5.Fragment.empty;
    for (let fr = 0; fr <= ar.depth; fr++) {
      let dr = ar.node(fr);
      this.frontier.push({
        type: dr.type,
        match: dr.contentMatchAt(ar.indexAfter(fr))
      });
    }
    for (let fr = ar.depth; fr > 0; fr--)
      this.placed = distExports$5.Fragment.from(ar.node(fr).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let yr = this.findFittable();
      yr ? this.placeNodes(yr) : this.openMore() || this.dropNode();
    }
    let ar = this.mustMoveInline(), cr = this.placed.size - this.depth - this.$from.depth, ur = this.$from, fr = this.close(ar < 0 ? this.$to : ur.doc.resolve(ar));
    if (!fr)
      return null;
    let dr = this.placed, gr = ur.depth, mr = fr.depth;
    for (; gr && mr && dr.childCount == 1; )
      dr = dr.firstChild.content, gr--, mr--;
    let vr = new distExports$5.Slice(dr, gr, mr);
    return ar > -1 ? new ReplaceAroundStep(ur.pos, ar, this.$to.pos, this.$to.end(), vr, cr) : vr.size || ur.pos != this.$to.pos ? new ReplaceStep(ur.pos, fr.pos, vr) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let ar = this.unplaced.openStart;
    for (let cr = this.unplaced.content, ur = 0, fr = this.unplaced.openEnd; ur < ar; ur++) {
      let dr = cr.firstChild;
      if (cr.childCount > 1 && (fr = 0), dr.type.spec.isolating && fr <= ur) {
        ar = ur;
        break;
      }
      cr = dr.content;
    }
    for (let cr = 1; cr <= 2; cr++)
      for (let ur = cr == 1 ? ar : this.unplaced.openStart; ur >= 0; ur--) {
        let fr, dr = null;
        ur ? (dr = contentAt(this.unplaced.content, ur - 1).firstChild, fr = dr.content) : fr = this.unplaced.content;
        let gr = fr.firstChild;
        for (let mr = this.depth; mr >= 0; mr--) {
          let { type: vr, match: yr } = this.frontier[mr], kr, _r = null;
          if (cr == 1 && (gr ? yr.matchType(gr.type) || (_r = yr.fillBefore(distExports$5.Fragment.from(gr), !1)) : dr && vr.compatibleContent(dr.type)))
            return { sliceDepth: ur, frontierDepth: mr, parent: dr, inject: _r };
          if (cr == 2 && gr && (kr = yr.findWrapping(gr.type)))
            return { sliceDepth: ur, frontierDepth: mr, parent: dr, wrap: kr };
          if (dr && yr.matchType(dr.type))
            break;
        }
      }
  }
  openMore() {
    let { content: ar, openStart: cr, openEnd: ur } = this.unplaced, fr = contentAt(ar, cr);
    return !fr.childCount || fr.firstChild.isLeaf ? !1 : (this.unplaced = new distExports$5.Slice(ar, cr + 1, Math.max(ur, fr.size + cr >= ar.size - ur ? cr + 1 : 0)), !0);
  }
  dropNode() {
    let { content: ar, openStart: cr, openEnd: ur } = this.unplaced, fr = contentAt(ar, cr);
    if (fr.childCount <= 1 && cr > 0) {
      let dr = ar.size - cr <= cr + fr.size;
      this.unplaced = new distExports$5.Slice(dropFromFragment(ar, cr - 1, 1), cr - 1, dr ? cr - 1 : ur);
    } else
      this.unplaced = new distExports$5.Slice(dropFromFragment(ar, cr, 1), cr, ur);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: ar, frontierDepth: cr, parent: ur, inject: fr, wrap: dr }) {
    for (; this.depth > cr; )
      this.closeFrontierNode();
    if (dr)
      for (let Cr = 0; Cr < dr.length; Cr++)
        this.openFrontierNode(dr[Cr]);
    let gr = this.unplaced, mr = ur ? ur.content : gr.content, vr = gr.openStart - ar, yr = 0, kr = [], { match: _r, type: xr } = this.frontier[cr];
    if (fr) {
      for (let Cr = 0; Cr < fr.childCount; Cr++)
        kr.push(fr.child(Cr));
      _r = _r.matchFragment(fr);
    }
    let Sr = mr.size + ar - (gr.content.size - gr.openEnd);
    for (; yr < mr.childCount; ) {
      let Cr = mr.child(yr), Tr = _r.matchType(Cr.type);
      if (!Tr)
        break;
      yr++, (yr > 1 || vr == 0 || Cr.content.size) && (_r = Tr, kr.push(closeNodeStart(Cr.mark(xr.allowedMarks(Cr.marks)), yr == 1 ? vr : 0, yr == mr.childCount ? Sr : -1)));
    }
    let Er = yr == mr.childCount;
    Er || (Sr = -1), this.placed = addToFragment(this.placed, cr, distExports$5.Fragment.from(kr)), this.frontier[cr].match = _r, Er && Sr < 0 && ur && ur.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let Cr = 0, Tr = mr; Cr < Sr; Cr++) {
      let Ar = Tr.lastChild;
      this.frontier.push({ type: Ar.type, match: Ar.contentMatchAt(Ar.childCount) }), Tr = Ar.content;
    }
    this.unplaced = Er ? ar == 0 ? distExports$5.Slice.empty : new distExports$5.Slice(dropFromFragment(gr.content, ar - 1, 1), ar - 1, Sr < 0 ? gr.openEnd : ar - 1) : new distExports$5.Slice(dropFromFragment(gr.content, ar, yr), gr.openStart, gr.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let ar = this.frontier[this.depth], cr;
    if (!ar.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, ar.type, ar.match, !1) || this.$to.depth == this.depth && (cr = this.findCloseLevel(this.$to)) && cr.depth == this.depth)
      return -1;
    let { depth: ur } = this.$to, fr = this.$to.after(ur);
    for (; ur > 1 && fr == this.$to.end(--ur); )
      ++fr;
    return fr;
  }
  findCloseLevel(ar) {
    e:
      for (let cr = Math.min(this.depth, ar.depth); cr >= 0; cr--) {
        let { match: ur, type: fr } = this.frontier[cr], dr = cr < ar.depth && ar.end(cr + 1) == ar.pos + (ar.depth - (cr + 1)), gr = contentAfterFits(ar, cr, fr, ur, dr);
        if (gr) {
          for (let mr = cr - 1; mr >= 0; mr--) {
            let { match: vr, type: yr } = this.frontier[mr], kr = contentAfterFits(ar, mr, yr, vr, !0);
            if (!kr || kr.childCount)
              continue e;
          }
          return { depth: cr, fit: gr, move: dr ? ar.doc.resolve(ar.after(cr + 1)) : ar };
        }
      }
  }
  close(ar) {
    let cr = this.findCloseLevel(ar);
    if (!cr)
      return null;
    for (; this.depth > cr.depth; )
      this.closeFrontierNode();
    cr.fit.childCount && (this.placed = addToFragment(this.placed, cr.depth, cr.fit)), ar = cr.move;
    for (let ur = cr.depth + 1; ur <= ar.depth; ur++) {
      let fr = ar.node(ur), dr = fr.type.contentMatch.fillBefore(fr.content, !0, ar.index(ur));
      this.openFrontierNode(fr.type, fr.attrs, dr);
    }
    return ar;
  }
  openFrontierNode(ar, cr = null, ur) {
    let fr = this.frontier[this.depth];
    fr.match = fr.match.matchType(ar), this.placed = addToFragment(this.placed, this.depth, distExports$5.Fragment.from(ar.create(cr, ur))), this.frontier.push({ type: ar, match: ar.contentMatch });
  }
  closeFrontierNode() {
    let cr = this.frontier.pop().match.fillBefore(distExports$5.Fragment.empty, !0);
    cr.childCount && (this.placed = addToFragment(this.placed, this.frontier.length, cr));
  }
}
function dropFromFragment(lr, ar, cr) {
  return ar == 0 ? lr.cutByIndex(cr, lr.childCount) : lr.replaceChild(0, lr.firstChild.copy(dropFromFragment(lr.firstChild.content, ar - 1, cr)));
}
function addToFragment(lr, ar, cr) {
  return ar == 0 ? lr.append(cr) : lr.replaceChild(lr.childCount - 1, lr.lastChild.copy(addToFragment(lr.lastChild.content, ar - 1, cr)));
}
function contentAt(lr, ar) {
  for (let cr = 0; cr < ar; cr++)
    lr = lr.firstChild.content;
  return lr;
}
function closeNodeStart(lr, ar, cr) {
  if (ar <= 0)
    return lr;
  let ur = lr.content;
  return ar > 1 && (ur = ur.replaceChild(0, closeNodeStart(ur.firstChild, ar - 1, ur.childCount == 1 ? cr - 1 : 0))), ar > 0 && (ur = lr.type.contentMatch.fillBefore(ur).append(ur), cr <= 0 && (ur = ur.append(lr.type.contentMatch.matchFragment(ur).fillBefore(distExports$5.Fragment.empty, !0)))), lr.copy(ur);
}
function contentAfterFits(lr, ar, cr, ur, fr) {
  let dr = lr.node(ar), gr = fr ? lr.indexAfter(ar) : lr.index(ar);
  if (gr == dr.childCount && !cr.compatibleContent(dr.type))
    return null;
  let mr = ur.fillBefore(dr.content, !0, gr);
  return mr && !invalidMarks(cr, dr.content, gr) ? mr : null;
}
function invalidMarks(lr, ar, cr) {
  for (let ur = cr; ur < ar.childCount; ur++)
    if (!lr.allowsMarks(ar.child(ur).marks))
      return !0;
  return !1;
}
function definesContent(lr) {
  return lr.spec.defining || lr.spec.definingForContent;
}
function replaceRange(lr, ar, cr, ur) {
  if (!ur.size)
    return lr.deleteRange(ar, cr);
  let fr = lr.doc.resolve(ar), dr = lr.doc.resolve(cr);
  if (fitsTrivially(fr, dr, ur))
    return lr.step(new ReplaceStep(ar, cr, ur));
  let gr = coveredDepths(fr, lr.doc.resolve(cr));
  gr[gr.length - 1] == 0 && gr.pop();
  let mr = -(fr.depth + 1);
  gr.unshift(mr);
  for (let xr = fr.depth, Sr = fr.pos - 1; xr > 0; xr--, Sr--) {
    let Er = fr.node(xr).type.spec;
    if (Er.defining || Er.definingAsContext || Er.isolating)
      break;
    gr.indexOf(xr) > -1 ? mr = xr : fr.before(xr) == Sr && gr.splice(1, 0, -xr);
  }
  let vr = gr.indexOf(mr), yr = [], kr = ur.openStart;
  for (let xr = ur.content, Sr = 0; ; Sr++) {
    let Er = xr.firstChild;
    if (yr.push(Er), Sr == ur.openStart)
      break;
    xr = Er.content;
  }
  for (let xr = kr - 1; xr >= 0; xr--) {
    let Sr = yr[xr], Er = definesContent(Sr.type);
    if (Er && !Sr.sameMarkup(fr.node(Math.abs(mr) - 1)))
      kr = xr;
    else if (Er || !Sr.type.isTextblock)
      break;
  }
  for (let xr = ur.openStart; xr >= 0; xr--) {
    let Sr = (xr + kr + 1) % (ur.openStart + 1), Er = yr[Sr];
    if (Er)
      for (let Cr = 0; Cr < gr.length; Cr++) {
        let Tr = gr[(Cr + vr) % gr.length], Ar = !0;
        Tr < 0 && (Ar = !1, Tr = -Tr);
        let Ir = fr.node(Tr - 1), Mr = fr.index(Tr - 1);
        if (Ir.canReplaceWith(Mr, Mr, Er.type, Er.marks))
          return lr.replace(fr.before(Tr), Ar ? dr.after(Tr) : cr, new distExports$5.Slice(closeFragment(ur.content, 0, ur.openStart, Sr), Sr, ur.openEnd));
      }
  }
  let _r = lr.steps.length;
  for (let xr = gr.length - 1; xr >= 0 && (lr.replace(ar, cr, ur), !(lr.steps.length > _r)); xr--) {
    let Sr = gr[xr];
    Sr < 0 || (ar = fr.before(Sr), cr = dr.after(Sr));
  }
}
function closeFragment(lr, ar, cr, ur, fr) {
  if (ar < cr) {
    let dr = lr.firstChild;
    lr = lr.replaceChild(0, dr.copy(closeFragment(dr.content, ar + 1, cr, ur, dr)));
  }
  if (ar > ur) {
    let dr = fr.contentMatchAt(0), gr = dr.fillBefore(lr).append(lr);
    lr = gr.append(dr.matchFragment(gr).fillBefore(distExports$5.Fragment.empty, !0));
  }
  return lr;
}
function replaceRangeWith(lr, ar, cr, ur) {
  if (!ur.isInline && ar == cr && lr.doc.resolve(ar).parent.content.size) {
    let fr = insertPoint(lr.doc, ar, ur.type);
    fr != null && (ar = cr = fr);
  }
  lr.replaceRange(ar, cr, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, 0));
}
function deleteRange(lr, ar, cr) {
  let ur = lr.doc.resolve(ar), fr = lr.doc.resolve(cr), dr = coveredDepths(ur, fr);
  for (let gr = 0; gr < dr.length; gr++) {
    let mr = dr[gr], vr = gr == dr.length - 1;
    if (vr && mr == 0 || ur.node(mr).type.contentMatch.validEnd)
      return lr.delete(ur.start(mr), fr.end(mr));
    if (mr > 0 && (vr || ur.node(mr - 1).canReplace(ur.index(mr - 1), fr.indexAfter(mr - 1))))
      return lr.delete(ur.before(mr), fr.after(mr));
  }
  for (let gr = 1; gr <= ur.depth && gr <= fr.depth; gr++)
    if (ar - ur.start(gr) == ur.depth - gr && cr > ur.end(gr) && fr.end(gr) - cr != fr.depth - gr)
      return lr.delete(ur.before(gr), cr);
  lr.delete(ar, cr);
}
function coveredDepths(lr, ar) {
  let cr = [], ur = Math.min(lr.depth, ar.depth);
  for (let fr = ur; fr >= 0; fr--) {
    let dr = lr.start(fr);
    if (dr < lr.pos - (lr.depth - fr) || ar.end(fr) > ar.pos + (ar.depth - fr) || lr.node(fr).type.spec.isolating || ar.node(fr).type.spec.isolating)
      break;
    (dr == ar.start(fr) || fr == lr.depth && fr == ar.depth && lr.parent.inlineContent && ar.parent.inlineContent && fr && ar.start(fr - 1) == dr - 1) && cr.push(fr);
  }
  return cr;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, cr, ur) {
    super(), this.pos = ar, this.attr = cr, this.value = ur;
  }
  apply(ar) {
    let cr = ar.nodeAt(this.pos);
    if (!cr)
      return StepResult.fail("No node at attribute step's position");
    let ur = /* @__PURE__ */ Object.create(null);
    for (let dr in cr.attrs)
      ur[dr] = cr.attrs[dr];
    ur[this.attr] = this.value;
    let fr = cr.type.create(ur, null, cr.marks);
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new distExports$5.Slice(distExports$5.Fragment.from(fr), 0, cr.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new AttrStep(this.pos, this.attr, ar.nodeAt(this.pos).attrs[this.attr]);
  }
  map(ar) {
    let cr = ar.mapResult(this.pos, 1);
    return cr.deletedAfter ? null : new AttrStep(cr.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(ar, cr) {
    if (typeof cr.pos != "number" || typeof cr.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(cr.pos, cr.attr, cr.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, cr) {
    super(), this.attr = ar, this.value = cr;
  }
  apply(ar) {
    let cr = /* @__PURE__ */ Object.create(null);
    for (let fr in ar.attrs)
      cr[fr] = ar.attrs[fr];
    cr[this.attr] = this.value;
    let ur = ar.type.create(cr, ar.content, ar.marks);
    return StepResult.ok(ur);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new DocAttrStep(this.attr, ar.attrs[this.attr]);
  }
  map(ar) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(ar, cr) {
    if (typeof cr.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(cr.attr, cr.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function lr(ar) {
  let cr = Error.call(this, ar);
  return cr.__proto__ = lr.prototype, cr;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(ar) {
    this.doc = ar, this.steps = [], this.docs = [], this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(ar) {
    let cr = this.maybeStep(ar);
    if (cr.failed)
      throw new TransformError(cr.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(ar) {
    let cr = ar.apply(this.doc);
    return cr.failed || this.addStep(ar, cr.doc), cr;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(ar, cr) {
    this.docs.push(this.doc), this.steps.push(ar), this.mapping.appendMap(ar.getMap()), this.doc = cr;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(ar, cr = ar, ur = distExports$5.Slice.empty) {
    let fr = replaceStep(this.doc, ar, cr, ur);
    return fr && this.step(fr), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(ar, cr, ur) {
    return this.replace(ar, cr, new distExports$5.Slice(distExports$5.Fragment.from(ur), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(ar, cr) {
    return this.replace(ar, cr, distExports$5.Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(ar, cr) {
    return this.replaceWith(ar, ar, cr);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(ar, cr, ur) {
    return replaceRange(this, ar, cr, ur), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(ar, cr, ur) {
    return replaceRangeWith(this, ar, cr, ur), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(ar, cr) {
    return deleteRange(this, ar, cr), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(ar, cr) {
    return lift(this, ar, cr), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(ar, cr = 1) {
    return join(this, ar, cr), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(ar, cr) {
    return wrap(this, ar, cr), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(ar, cr = ar, ur, fr = null) {
    return setBlockType$1(this, ar, cr, ur, fr), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(ar, cr, ur = null, fr) {
    return setNodeMarkup(this, ar, cr, ur, fr), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(ar, cr, ur) {
    return this.step(new AttrStep(ar, cr, ur)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(ar, cr) {
    return this.step(new DocAttrStep(ar, cr)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(ar, cr) {
    return this.step(new AddNodeMarkStep(ar, cr)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(ar, cr) {
    if (!(cr instanceof distExports$5.Mark)) {
      let ur = this.doc.nodeAt(ar);
      if (!ur)
        throw new RangeError("No node at position " + ar);
      if (cr = cr.isInSet(ur.marks), !cr)
        return this;
    }
    return this.step(new RemoveNodeMarkStep(ar, cr)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(ar, cr = 1, ur) {
    return split(this, ar, cr, ur), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(ar, cr, ur) {
    return addMark(this, ar, cr, ur), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(ar, cr, ur) {
    return removeMark(this, ar, cr, ur), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(ar, cr, ur) {
    return clearIncompatible(this, ar, cr, ur), this;
  }
}
const dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddMarkStep,
  AddNodeMarkStep,
  AttrStep,
  DocAttrStep,
  MapResult,
  Mapping,
  RemoveMarkStep,
  RemoveNodeMarkStep,
  ReplaceAroundStep,
  ReplaceStep,
  Step,
  StepMap,
  StepResult,
  Transform,
  get TransformError() {
    return TransformError;
  },
  canJoin,
  canSplit,
  dropPoint,
  findWrapping,
  insertPoint,
  joinPoint,
  liftTarget,
  replaceStep
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
var hasRequiredDist$4;
function requireDist$4() {
  if (hasRequiredDist$4)
    return dist$4;
  hasRequiredDist$4 = 1;
  function lr(Bi) {
    "@babel/helpers - typeof";
    return lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ni) {
      return typeof Ni;
    } : function(Ni) {
      return Ni && typeof Symbol == "function" && Ni.constructor === Symbol && Ni !== Symbol.prototype ? "symbol" : typeof Ni;
    }, lr(Bi);
  }
  function ar() {
    return typeof Reflect != "undefined" && Reflect.get ? ar = Reflect.get : ar = function(Ni, Mi, bi) {
      var Ei = cr(Ni, Mi);
      if (Ei) {
        var Si = Object.getOwnPropertyDescriptor(Ei, Mi);
        return Si.get ? Si.get.call(arguments.length < 3 ? Ni : bi) : Si.value;
      }
    }, ar.apply(this, arguments);
  }
  function cr(Bi, Ni) {
    for (; !Object.prototype.hasOwnProperty.call(Bi, Ni) && (Bi = yr(Bi), Bi !== null); )
      ;
    return Bi;
  }
  function ur(Bi, Ni) {
    if (typeof Ni != "function" && Ni !== null)
      throw new TypeError("Super expression must either be null or a function");
    Bi.prototype = Object.create(Ni && Ni.prototype, { constructor: { value: Bi, writable: !0, configurable: !0 } }), Object.defineProperty(Bi, "prototype", { writable: !1 }), Ni && fr(Bi, Ni);
  }
  function fr(Bi, Ni) {
    return fr = Object.setPrototypeOf || function(bi, Ei) {
      return bi.__proto__ = Ei, bi;
    }, fr(Bi, Ni);
  }
  function dr(Bi) {
    var Ni = vr();
    return function() {
      var bi = yr(Bi), Ei;
      if (Ni) {
        var Si = yr(this).constructor;
        Ei = Reflect.construct(bi, arguments, Si);
      } else
        Ei = bi.apply(this, arguments);
      return gr(this, Ei);
    };
  }
  function gr(Bi, Ni) {
    if (Ni && (lr(Ni) === "object" || typeof Ni == "function"))
      return Ni;
    if (Ni !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return mr(Bi);
  }
  function mr(Bi) {
    if (Bi === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Bi;
  }
  function vr() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (Bi) {
      return !1;
    }
  }
  function yr(Bi) {
    return yr = Object.setPrototypeOf ? Object.getPrototypeOf : function(Mi) {
      return Mi.__proto__ || Object.getPrototypeOf(Mi);
    }, yr(Bi);
  }
  function kr(Bi, Ni) {
    if (!(Bi instanceof Ni))
      throw new TypeError("Cannot call a class as a function");
  }
  function _r(Bi, Ni) {
    for (var Mi = 0; Mi < Ni.length; Mi++) {
      var bi = Ni[Mi];
      bi.enumerable = bi.enumerable || !1, bi.configurable = !0, "value" in bi && (bi.writable = !0), Object.defineProperty(Bi, bi.key, bi);
    }
  }
  function xr(Bi, Ni, Mi) {
    return Ni && _r(Bi.prototype, Ni), Mi && _r(Bi, Mi), Object.defineProperty(Bi, "prototype", { writable: !1 }), Bi;
  }
  Object.defineProperty(dist$4, "__esModule", {
    value: !0
  });
  var Sr = requireDist$5(), Er = require$$1$2, Cr = /* @__PURE__ */ Object.create(null), Tr = function() {
    function Bi(Ni, Mi, bi) {
      kr(this, Bi), this.$anchor = Ni, this.$head = Mi, this.ranges = bi || [new Ar(Ni.min(Mi), Ni.max(Mi))];
    }
    return xr(Bi, [{
      key: "anchor",
      get: function() {
        return this.$anchor.pos;
      }
    }, {
      key: "head",
      get: function() {
        return this.$head.pos;
      }
    }, {
      key: "from",
      get: function() {
        return this.$from.pos;
      }
    }, {
      key: "to",
      get: function() {
        return this.$to.pos;
      }
    }, {
      key: "$from",
      get: function() {
        return this.ranges[0].$from;
      }
    }, {
      key: "$to",
      get: function() {
        return this.ranges[0].$to;
      }
    }, {
      key: "empty",
      get: function() {
        for (var Mi = this.ranges, bi = 0; bi < Mi.length; bi++)
          if (Mi[bi].$from.pos != Mi[bi].$to.pos)
            return !1;
        return !0;
      }
    }, {
      key: "content",
      value: function() {
        return this.$from.doc.slice(this.from, this.to, !0);
      }
    }, {
      key: "replace",
      value: function(Mi) {
        for (var bi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Sr.Slice.empty, Ei = bi.content.lastChild, Si = null, Vi = 0; Vi < bi.openEnd; Vi++)
          Si = Ei, Ei = Ei.lastChild;
        for (var Di = Mi.steps.length, sa = this.ranges, ra = 0; ra < sa.length; ra++) {
          var fa = sa[ra], ba = fa.$from, Ua = fa.$to, Va = Mi.mapping.slice(Di);
          Mi.replaceRange(Va.map(ba.pos), Va.map(Ua.pos), ra ? Sr.Slice.empty : bi), ra == 0 && Qr(Mi, Di, (Ei ? Ei.isInline : Si && Si.isTextblock) ? -1 : 1);
        }
      }
    }, {
      key: "replaceWith",
      value: function(Mi, bi) {
        for (var Ei = Mi.steps.length, Si = this.ranges, Vi = 0; Vi < Si.length; Vi++) {
          var Di = Si[Vi], sa = Di.$from, ra = Di.$to, fa = Mi.mapping.slice(Ei), ba = fa.map(sa.pos), Ua = fa.map(ra.pos);
          Vi ? Mi.deleteRange(ba, Ua) : (Mi.replaceRangeWith(ba, Ua, bi), Qr(Mi, Ei, bi.isInline ? -1 : 1));
        }
      }
    }, {
      key: "getBookmark",
      value: function() {
        return Hr.between(this.$anchor, this.$head).getBookmark();
      }
    }], [{
      key: "findFrom",
      value: function(Mi, bi) {
        var Ei = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, Si = Mi.parent.inlineContent ? new Hr(Mi) : li(Mi.node(0), Mi.parent, Mi.pos, Mi.index(), bi, Ei);
        if (Si)
          return Si;
        for (var Vi = Mi.depth - 1; Vi >= 0; Vi--) {
          var Di = bi < 0 ? li(Mi.node(0), Mi.node(Vi), Mi.before(Vi + 1), Mi.index(Vi), bi, Ei) : li(Mi.node(0), Mi.node(Vi), Mi.after(Vi + 1), Mi.index(Vi) + 1, bi, Ei);
          if (Di)
            return Di;
        }
        return null;
      }
    }, {
      key: "near",
      value: function(Mi) {
        var bi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return this.findFrom(Mi, bi) || this.findFrom(Mi, -bi) || new Xr(Mi.node(0));
      }
    }, {
      key: "atStart",
      value: function(Mi) {
        return li(Mi, Mi, 0, 0, 1) || new Xr(Mi);
      }
    }, {
      key: "atEnd",
      value: function(Mi) {
        return li(Mi, Mi, Mi.content.size, Mi.childCount, -1) || new Xr(Mi);
      }
    }, {
      key: "fromJSON",
      value: function(Mi, bi) {
        if (!bi || !bi.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        var Ei = Cr[bi.type];
        if (!Ei)
          throw new RangeError("No selection type ".concat(bi.type, " defined"));
        return Ei.fromJSON(Mi, bi);
      }
    }, {
      key: "jsonID",
      value: function(Mi, bi) {
        if (Mi in Cr)
          throw new RangeError("Duplicate use of selection JSON ID " + Mi);
        return Cr[Mi] = bi, bi.prototype.jsonID = Mi, bi;
      }
    }]), Bi;
  }();
  Tr.prototype.visible = !0;
  var Ar = xr(function Bi(Ni, Mi) {
    kr(this, Bi), this.$from = Ni, this.$to = Mi;
  }), Ir = !1;
  function Mr(Bi) {
    !Ir && !Bi.parent.inlineContent && (Ir = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + Bi.parent.type.name + ")"));
  }
  var Hr = function(Bi) {
    ur(Mi, Bi);
    var Ni = dr(Mi);
    function Mi(bi) {
      var Ei = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : bi;
      return kr(this, Mi), Mr(bi), Mr(Ei), Ni.call(this, bi, Ei);
    }
    return xr(Mi, [{
      key: "$cursor",
      get: function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
    }, {
      key: "map",
      value: function(Ei, Si) {
        var Vi = Ei.resolve(Si.map(this.head));
        if (!Vi.parent.inlineContent)
          return Tr.near(Vi);
        var Di = Ei.resolve(Si.map(this.anchor));
        return new Mi(Di.parent.inlineContent ? Di : Vi, Vi);
      }
    }, {
      key: "replace",
      value: function(Ei) {
        var Si = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Sr.Slice.empty;
        if (ar(yr(Mi.prototype), "replace", this).call(this, Ei, Si), Si == Sr.Slice.empty) {
          var Vi = this.$from.marksAcross(this.$to);
          Vi && Ei.ensureMarks(Vi);
        }
      }
    }, {
      key: "eq",
      value: function(Ei) {
        return Ei instanceof Mi && Ei.anchor == this.anchor && Ei.head == this.head;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new Br(this.anchor, this.head);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "text",
          anchor: this.anchor,
          head: this.head
        };
      }
    }], [{
      key: "fromJSON",
      value: function(Ei, Si) {
        if (typeof Si.anchor != "number" || typeof Si.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new Mi(Ei.resolve(Si.anchor), Ei.resolve(Si.head));
      }
    }, {
      key: "create",
      value: function(Ei, Si) {
        var Vi = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Si, Di = Ei.resolve(Si);
        return new this(Di, Vi == Si ? Di : Ei.resolve(Vi));
      }
    }, {
      key: "between",
      value: function(Ei, Si, Vi) {
        var Di = Ei.pos - Si.pos;
        if ((!Vi || Di) && (Vi = Di >= 0 ? 1 : -1), !Si.parent.inlineContent) {
          var sa = Tr.findFrom(Si, Vi, !0) || Tr.findFrom(Si, -Vi, !0);
          if (sa)
            Si = sa.$head;
          else
            return Tr.near(Si, Vi);
        }
        return Ei.parent.inlineContent || (Di == 0 ? Ei = Si : (Ei = (Tr.findFrom(Ei, -Vi, !0) || Tr.findFrom(Ei, Vi, !0)).$anchor, Ei.pos < Si.pos != Di < 0 && (Ei = Si))), new Mi(Ei, Si);
      }
    }]), Mi;
  }(Tr);
  Tr.jsonID("text", Hr);
  var Br = function() {
    function Bi(Ni, Mi) {
      kr(this, Bi), this.anchor = Ni, this.head = Mi;
    }
    return xr(Bi, [{
      key: "map",
      value: function(Mi) {
        return new Bi(Mi.map(this.anchor), Mi.map(this.head));
      }
    }, {
      key: "resolve",
      value: function(Mi) {
        return Hr.between(Mi.resolve(this.anchor), Mi.resolve(this.head));
      }
    }]), Bi;
  }(), zr = function(Bi) {
    ur(Mi, Bi);
    var Ni = dr(Mi);
    function Mi(bi) {
      var Ei;
      kr(this, Mi);
      var Si = bi.nodeAfter, Vi = bi.node(0).resolve(bi.pos + Si.nodeSize);
      return Ei = Ni.call(this, bi, Vi), Ei.node = Si, Ei;
    }
    return xr(Mi, [{
      key: "map",
      value: function(Ei, Si) {
        var Vi = Si.mapResult(this.anchor), Di = Vi.deleted, sa = Vi.pos, ra = Ei.resolve(sa);
        return Di ? Tr.near(ra) : new Mi(ra);
      }
    }, {
      key: "content",
      value: function() {
        return new Sr.Slice(Sr.Fragment.from(this.node), 0, 0);
      }
    }, {
      key: "eq",
      value: function(Ei) {
        return Ei instanceof Mi && Ei.anchor == this.anchor;
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "node",
          anchor: this.anchor
        };
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new Gr(this.anchor);
      }
    }], [{
      key: "fromJSON",
      value: function(Ei, Si) {
        if (typeof Si.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new Mi(Ei.resolve(Si.anchor));
      }
    }, {
      key: "create",
      value: function(Ei, Si) {
        return new Mi(Ei.resolve(Si));
      }
    }, {
      key: "isSelectable",
      value: function(Ei) {
        return !Ei.isText && Ei.type.spec.selectable !== !1;
      }
    }]), Mi;
  }(Tr);
  zr.prototype.visible = !1, Tr.jsonID("node", zr);
  var Gr = function() {
    function Bi(Ni) {
      kr(this, Bi), this.anchor = Ni;
    }
    return xr(Bi, [{
      key: "map",
      value: function(Mi) {
        var bi = Mi.mapResult(this.anchor), Ei = bi.deleted, Si = bi.pos;
        return Ei ? new Br(Si, Si) : new Bi(Si);
      }
    }, {
      key: "resolve",
      value: function(Mi) {
        var bi = Mi.resolve(this.anchor), Ei = bi.nodeAfter;
        return Ei && zr.isSelectable(Ei) ? new zr(bi) : Tr.near(bi);
      }
    }]), Bi;
  }(), Xr = function(Bi) {
    ur(Mi, Bi);
    var Ni = dr(Mi);
    function Mi(bi) {
      return kr(this, Mi), Ni.call(this, bi.resolve(0), bi.resolve(bi.content.size));
    }
    return xr(Mi, [{
      key: "replace",
      value: function(Ei) {
        var Si = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Sr.Slice.empty;
        if (Si == Sr.Slice.empty) {
          Ei.delete(0, Ei.doc.content.size);
          var Vi = Tr.atStart(Ei.doc);
          Vi.eq(Ei.selection) || Ei.setSelection(Vi);
        } else
          ar(yr(Mi.prototype), "replace", this).call(this, Ei, Si);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "all"
        };
      }
    }, {
      key: "map",
      value: function(Ei) {
        return new Mi(Ei);
      }
    }, {
      key: "eq",
      value: function(Ei) {
        return Ei instanceof Mi;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return Jr;
      }
    }], [{
      key: "fromJSON",
      value: function(Ei) {
        return new Mi(Ei);
      }
    }]), Mi;
  }(Tr);
  Tr.jsonID("all", Xr);
  var Jr = {
    map: function() {
      return this;
    },
    resolve: function(Ni) {
      return new Xr(Ni);
    }
  };
  function li(Bi, Ni, Mi, bi, Ei) {
    var Si = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
    if (Ni.inlineContent)
      return Hr.create(Bi, Mi);
    for (var Vi = bi - (Ei > 0 ? 0 : 1); Ei > 0 ? Vi < Ni.childCount : Vi >= 0; Vi += Ei) {
      var Di = Ni.child(Vi);
      if (Di.isAtom) {
        if (!Si && zr.isSelectable(Di))
          return zr.create(Bi, Mi - (Ei < 0 ? Di.nodeSize : 0));
      } else {
        var sa = li(Bi, Di, Mi + Ei, Ei < 0 ? Di.childCount : 0, Ei, Si);
        if (sa)
          return sa;
      }
      Mi += Di.nodeSize * Ei;
    }
    return null;
  }
  function Qr(Bi, Ni, Mi) {
    var bi = Bi.steps.length - 1;
    if (!(bi < Ni)) {
      var Ei = Bi.steps[bi];
      if (Ei instanceof Er.ReplaceStep || Ei instanceof Er.ReplaceAroundStep) {
        var Si = Bi.mapping.maps[bi], Vi;
        Si.forEach(function(Di, sa, ra, fa) {
          Vi == null && (Vi = fa);
        }), Bi.setSelection(Tr.near(Bi.doc.resolve(Vi), Mi));
      }
    }
  }
  var ei = 1, ui = 2, Ai = 4, fi = function(Bi) {
    ur(Mi, Bi);
    var Ni = dr(Mi);
    function Mi(bi) {
      var Ei;
      return kr(this, Mi), Ei = Ni.call(this, bi.doc), Ei.curSelectionFor = 0, Ei.updated = 0, Ei.meta = /* @__PURE__ */ Object.create(null), Ei.time = Date.now(), Ei.curSelection = bi.selection, Ei.storedMarks = bi.storedMarks, Ei;
    }
    return xr(Mi, [{
      key: "selection",
      get: function() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
    }, {
      key: "setSelection",
      value: function(Ei) {
        if (Ei.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = Ei, this.curSelectionFor = this.steps.length, this.updated = (this.updated | ei) & ~ui, this.storedMarks = null, this;
      }
    }, {
      key: "selectionSet",
      get: function() {
        return (this.updated & ei) > 0;
      }
    }, {
      key: "setStoredMarks",
      value: function(Ei) {
        return this.storedMarks = Ei, this.updated |= ui, this;
      }
    }, {
      key: "ensureMarks",
      value: function(Ei) {
        return Sr.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), Ei) || this.setStoredMarks(Ei), this;
      }
    }, {
      key: "addStoredMark",
      value: function(Ei) {
        return this.ensureMarks(Ei.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "removeStoredMark",
      value: function(Ei) {
        return this.ensureMarks(Ei.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "storedMarksSet",
      get: function() {
        return (this.updated & ui) > 0;
      }
    }, {
      key: "addStep",
      value: function(Ei, Si) {
        ar(yr(Mi.prototype), "addStep", this).call(this, Ei, Si), this.updated = this.updated & ~ui, this.storedMarks = null;
      }
    }, {
      key: "setTime",
      value: function(Ei) {
        return this.time = Ei, this;
      }
    }, {
      key: "replaceSelection",
      value: function(Ei) {
        return this.selection.replace(this, Ei), this;
      }
    }, {
      key: "replaceSelectionWith",
      value: function(Ei) {
        var Si = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Vi = this.selection;
        return Si && (Ei = Ei.mark(this.storedMarks || (Vi.empty ? Vi.$from.marks() : Vi.$from.marksAcross(Vi.$to) || Sr.Mark.none))), Vi.replaceWith(this, Ei), this;
      }
    }, {
      key: "deleteSelection",
      value: function() {
        return this.selection.replace(this), this;
      }
    }, {
      key: "insertText",
      value: function(Ei, Si, Vi) {
        var Di = this.doc.type.schema;
        if (Si == null)
          return Ei ? this.replaceSelectionWith(Di.text(Ei), !0) : this.deleteSelection();
        if (Vi == null && (Vi = Si), Vi = Vi == null ? Si : Vi, !Ei)
          return this.deleteRange(Si, Vi);
        var sa = this.storedMarks;
        if (!sa) {
          var ra = this.doc.resolve(Si);
          sa = Vi == Si ? ra.marks() : ra.marksAcross(this.doc.resolve(Vi));
        }
        return this.replaceRangeWith(Si, Vi, Di.text(Ei, sa)), this.selection.empty || this.setSelection(Tr.near(this.selection.$to)), this;
      }
    }, {
      key: "setMeta",
      value: function(Ei, Si) {
        return this.meta[typeof Ei == "string" ? Ei : Ei.key] = Si, this;
      }
    }, {
      key: "getMeta",
      value: function(Ei) {
        return this.meta[typeof Ei == "string" ? Ei : Ei.key];
      }
    }, {
      key: "isGeneric",
      get: function() {
        for (var Ei in this.meta)
          return !1;
        return !0;
      }
    }, {
      key: "scrollIntoView",
      value: function() {
        return this.updated |= Ai, this;
      }
    }, {
      key: "scrolledIntoView",
      get: function() {
        return (this.updated & Ai) > 0;
      }
    }]), Mi;
  }(Er.Transform);
  function gi(Bi, Ni) {
    return !Ni || !Bi ? Bi : Bi.bind(Ni);
  }
  var Ci = xr(function Bi(Ni, Mi, bi) {
    kr(this, Bi), this.name = Ni, this.init = gi(Mi.init, bi), this.apply = gi(Mi.apply, bi);
  }), mi = [new Ci("doc", {
    init: function(Ni) {
      return Ni.doc || Ni.schema.topNodeType.createAndFill();
    },
    apply: function(Ni) {
      return Ni.doc;
    }
  }), new Ci("selection", {
    init: function(Ni, Mi) {
      return Ni.selection || Tr.atStart(Mi.doc);
    },
    apply: function(Ni) {
      return Ni.selection;
    }
  }), new Ci("storedMarks", {
    init: function(Ni) {
      return Ni.storedMarks || null;
    },
    apply: function(Ni, Mi, bi, Ei) {
      return Ei.selection.$cursor ? Ni.storedMarks : null;
    }
  }), new Ci("scrollToSelection", {
    init: function() {
      return 0;
    },
    apply: function(Ni, Mi) {
      return Ni.scrolledIntoView ? Mi + 1 : Mi;
    }
  })], vi = xr(function Bi(Ni, Mi) {
    var bi = this;
    kr(this, Bi), this.schema = Ni, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = mi.slice(), Mi && Mi.forEach(function(Ei) {
      if (bi.pluginsByKey[Ei.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + Ei.key + ")");
      bi.plugins.push(Ei), bi.pluginsByKey[Ei.key] = Ei, Ei.spec.state && bi.fields.push(new Ci(Ei.key, Ei.spec.state, Ei));
    });
  }), Ri = function() {
    function Bi(Ni) {
      kr(this, Bi), this.config = Ni;
    }
    return xr(Bi, [{
      key: "schema",
      get: function() {
        return this.config.schema;
      }
    }, {
      key: "plugins",
      get: function() {
        return this.config.plugins;
      }
    }, {
      key: "apply",
      value: function(Mi) {
        return this.applyTransaction(Mi).state;
      }
    }, {
      key: "filterTransaction",
      value: function(Mi) {
        for (var bi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, Ei = 0; Ei < this.config.plugins.length; Ei++)
          if (Ei != bi) {
            var Si = this.config.plugins[Ei];
            if (Si.spec.filterTransaction && !Si.spec.filterTransaction.call(Si, Mi, this))
              return !1;
          }
        return !0;
      }
    }, {
      key: "applyTransaction",
      value: function(Mi) {
        if (!this.filterTransaction(Mi))
          return {
            state: this,
            transactions: []
          };
        for (var bi = [Mi], Ei = this.applyInner(Mi), Si = null; ; ) {
          for (var Vi = !1, Di = 0; Di < this.config.plugins.length; Di++) {
            var sa = this.config.plugins[Di];
            if (sa.spec.appendTransaction) {
              var ra = Si ? Si[Di].n : 0, fa = Si ? Si[Di].state : this, ba = ra < bi.length && sa.spec.appendTransaction.call(sa, ra ? bi.slice(ra) : bi, fa, Ei);
              if (ba && Ei.filterTransaction(ba, Di)) {
                if (ba.setMeta("appendedTransaction", Mi), !Si) {
                  Si = [];
                  for (var Ua = 0; Ua < this.config.plugins.length; Ua++)
                    Si.push(Ua < Di ? {
                      state: Ei,
                      n: bi.length
                    } : {
                      state: this,
                      n: 0
                    });
                }
                bi.push(ba), Ei = Ei.applyInner(ba), Vi = !0;
              }
              Si && (Si[Di] = {
                state: Ei,
                n: bi.length
              });
            }
          }
          if (!Vi)
            return {
              state: Ei,
              transactions: bi
            };
        }
      }
    }, {
      key: "applyInner",
      value: function(Mi) {
        if (!Mi.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        for (var bi = new Bi(this.config), Ei = this.config.fields, Si = 0; Si < Ei.length; Si++) {
          var Vi = Ei[Si];
          bi[Vi.name] = Vi.apply(Mi, this[Vi.name], this, bi);
        }
        return bi;
      }
    }, {
      key: "tr",
      get: function() {
        return new fi(this);
      }
    }, {
      key: "reconfigure",
      value: function(Mi) {
        for (var bi = new vi(this.schema, Mi.plugins), Ei = bi.fields, Si = new Bi(bi), Vi = 0; Vi < Ei.length; Vi++) {
          var Di = Ei[Vi].name;
          Si[Di] = this.hasOwnProperty(Di) ? this[Di] : Ei[Vi].init(Mi, Si);
        }
        return Si;
      }
    }, {
      key: "toJSON",
      value: function(Mi) {
        var bi = {
          doc: this.doc.toJSON(),
          selection: this.selection.toJSON()
        };
        if (this.storedMarks && (bi.storedMarks = this.storedMarks.map(function(Di) {
          return Di.toJSON();
        })), Mi && lr(Mi) == "object")
          for (var Ei in Mi) {
            if (Ei == "doc" || Ei == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            var Si = Mi[Ei], Vi = Si.spec.state;
            Vi && Vi.toJSON && (bi[Ei] = Vi.toJSON.call(Si, this[Si.key]));
          }
        return bi;
      }
    }], [{
      key: "create",
      value: function(Mi) {
        for (var bi = new vi(Mi.doc ? Mi.doc.type.schema : Mi.schema, Mi.plugins), Ei = new Bi(bi), Si = 0; Si < bi.fields.length; Si++)
          Ei[bi.fields[Si].name] = bi.fields[Si].init(Mi, Ei);
        return Ei;
      }
    }, {
      key: "fromJSON",
      value: function(Mi, bi, Ei) {
        if (!bi)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!Mi.schema)
          throw new RangeError("Required config field 'schema' missing");
        var Si = new vi(Mi.schema, Mi.plugins), Vi = new Bi(Si);
        return Si.fields.forEach(function(Di) {
          if (Di.name == "doc")
            Vi.doc = Sr.Node.fromJSON(Mi.schema, bi.doc);
          else if (Di.name == "selection")
            Vi.selection = Tr.fromJSON(Vi.doc, bi.selection);
          else if (Di.name == "storedMarks")
            bi.storedMarks && (Vi.storedMarks = bi.storedMarks.map(Mi.schema.markFromJSON));
          else {
            if (Ei)
              for (var sa in Ei) {
                var ra = Ei[sa], fa = ra.spec.state;
                if (ra.key == Di.name && fa && fa.fromJSON && Object.prototype.hasOwnProperty.call(bi, sa)) {
                  Vi[Di.name] = fa.fromJSON.call(ra, Mi, bi[sa], Vi);
                  return;
                }
              }
            Vi[Di.name] = Di.init(Mi, Vi);
          }
        }), Vi;
      }
    }]), Bi;
  }();
  function di(Bi, Ni, Mi) {
    for (var bi in Bi) {
      var Ei = Bi[bi];
      Ei instanceof Function ? Ei = Ei.bind(Ni) : bi == "handleDOMEvents" && (Ei = di(Ei, Ni, {})), Mi[bi] = Ei;
    }
    return Mi;
  }
  var Ti = function() {
    function Bi(Ni) {
      kr(this, Bi), this.spec = Ni, this.props = {}, Ni.props && di(Ni.props, this, this.props), this.key = Ni.key ? Ni.key.key : ki("plugin");
    }
    return xr(Bi, [{
      key: "getState",
      value: function(Mi) {
        return Mi[this.key];
      }
    }]), Bi;
  }(), qi = /* @__PURE__ */ Object.create(null);
  function ki(Bi) {
    return Bi in qi ? Bi + "$" + ++qi[Bi] : (qi[Bi] = 0, Bi + "$");
  }
  var Ji = function() {
    function Bi() {
      var Ni = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
      kr(this, Bi), this.key = ki(Ni);
    }
    return xr(Bi, [{
      key: "get",
      value: function(Mi) {
        return Mi.config.pluginsByKey[this.key];
      }
    }, {
      key: "getState",
      value: function(Mi) {
        return Mi[this.key];
      }
    }]), Bi;
  }();
  return dist$4.AllSelection = Xr, dist$4.EditorState = Ri, dist$4.NodeSelection = zr, dist$4.Plugin = Ti, dist$4.PluginKey = Ji, dist$4.Selection = Tr, dist$4.SelectionRange = Ar, dist$4.TextSelection = Hr, dist$4.Transaction = fi, dist$4;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3)
    return dist$5;
  hasRequiredDist$3 = 1;
  function lr(Lr) {
    "@babel/helpers - typeof";
    return lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(jr) {
      return typeof jr;
    } : function(jr) {
      return jr && typeof Symbol == "function" && jr.constructor === Symbol && jr !== Symbol.prototype ? "symbol" : typeof jr;
    }, lr(Lr);
  }
  function ar(Lr, jr) {
    var Rr = typeof Symbol != "undefined" && Lr[Symbol.iterator] || Lr["@@iterator"];
    if (!Rr) {
      if (Array.isArray(Lr) || (Rr = cr(Lr)) || jr && Lr && typeof Lr.length == "number") {
        Rr && (Lr = Rr);
        var Fr = 0, Vr = function() {
        };
        return { s: Vr, n: function() {
          return Fr >= Lr.length ? { done: !0 } : { done: !1, value: Lr[Fr++] };
        }, e: function(wi) {
          throw wi;
        }, f: Vr };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Wr = !0, ri = !1, ai;
    return { s: function() {
      Rr = Rr.call(Lr);
    }, n: function() {
      var wi = Rr.next();
      return Wr = wi.done, wi;
    }, e: function(wi) {
      ri = !0, ai = wi;
    }, f: function() {
      try {
        !Wr && Rr.return != null && Rr.return();
      } finally {
        if (ri)
          throw ai;
      }
    } };
  }
  function cr(Lr, jr) {
    if (Lr) {
      if (typeof Lr == "string")
        return ur(Lr, jr);
      var Rr = Object.prototype.toString.call(Lr).slice(8, -1);
      if (Rr === "Object" && Lr.constructor && (Rr = Lr.constructor.name), Rr === "Map" || Rr === "Set")
        return Array.from(Lr);
      if (Rr === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Rr))
        return ur(Lr, jr);
    }
  }
  function ur(Lr, jr) {
    (jr == null || jr > Lr.length) && (jr = Lr.length);
    for (var Rr = 0, Fr = new Array(jr); Rr < jr; Rr++)
      Fr[Rr] = Lr[Rr];
    return Fr;
  }
  function fr() {
    return typeof Reflect != "undefined" && Reflect.get ? fr = Reflect.get : fr = function(jr, Rr, Fr) {
      var Vr = dr(jr, Rr);
      if (Vr) {
        var Wr = Object.getOwnPropertyDescriptor(Vr, Rr);
        return Wr.get ? Wr.get.call(arguments.length < 3 ? jr : Fr) : Wr.value;
      }
    }, fr.apply(this, arguments);
  }
  function dr(Lr, jr) {
    for (; !Object.prototype.hasOwnProperty.call(Lr, jr) && (Lr = xr(Lr), Lr !== null); )
      ;
    return Lr;
  }
  function gr(Lr, jr) {
    if (typeof jr != "function" && jr !== null)
      throw new TypeError("Super expression must either be null or a function");
    Lr.prototype = Object.create(jr && jr.prototype, { constructor: { value: Lr, writable: !0, configurable: !0 } }), Object.defineProperty(Lr, "prototype", { writable: !1 }), jr && mr(Lr, jr);
  }
  function mr(Lr, jr) {
    return mr = Object.setPrototypeOf || function(Fr, Vr) {
      return Fr.__proto__ = Vr, Fr;
    }, mr(Lr, jr);
  }
  function vr(Lr) {
    var jr = _r();
    return function() {
      var Fr = xr(Lr), Vr;
      if (jr) {
        var Wr = xr(this).constructor;
        Vr = Reflect.construct(Fr, arguments, Wr);
      } else
        Vr = Fr.apply(this, arguments);
      return yr(this, Vr);
    };
  }
  function yr(Lr, jr) {
    if (jr && (lr(jr) === "object" || typeof jr == "function"))
      return jr;
    if (jr !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return kr(Lr);
  }
  function kr(Lr) {
    if (Lr === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Lr;
  }
  function _r() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch (Lr) {
      return !1;
    }
  }
  function xr(Lr) {
    return xr = Object.setPrototypeOf ? Object.getPrototypeOf : function(Rr) {
      return Rr.__proto__ || Object.getPrototypeOf(Rr);
    }, xr(Lr);
  }
  function Sr(Lr, jr) {
    if (!(Lr instanceof jr))
      throw new TypeError("Cannot call a class as a function");
  }
  function Er(Lr, jr) {
    for (var Rr = 0; Rr < jr.length; Rr++) {
      var Fr = jr[Rr];
      Fr.enumerable = Fr.enumerable || !1, Fr.configurable = !0, "value" in Fr && (Fr.writable = !0), Object.defineProperty(Lr, Fr.key, Fr);
    }
  }
  function Cr(Lr, jr, Rr) {
    return jr && Er(Lr.prototype, jr), Rr && Er(Lr, Rr), Object.defineProperty(Lr, "prototype", { writable: !1 }), Lr;
  }
  var Tr = requireDist$4(), Ar = requireDist$5(), Ir = require$$1$2, Mr = function(jr) {
    for (var Rr = 0; ; Rr++)
      if (jr = jr.previousSibling, !jr)
        return Rr;
  }, Hr = function(jr) {
    var Rr = jr.assignedSlot || jr.parentNode;
    return Rr && Rr.nodeType == 11 ? Rr.host : Rr;
  }, Br = null, zr = function(jr, Rr, Fr) {
    var Vr = Br || (Br = document.createRange());
    return Vr.setEnd(jr, Fr == null ? jr.nodeValue.length : Fr), Vr.setStart(jr, Rr || 0), Vr;
  }, Gr = function(jr, Rr, Fr, Vr) {
    return Fr && (Jr(jr, Rr, Fr, Vr, -1) || Jr(jr, Rr, Fr, Vr, 1));
  }, Xr = /^(img|br|input|textarea|hr)$/i;
  function Jr(Lr, jr, Rr, Fr, Vr) {
    for (; ; ) {
      if (Lr == Rr && jr == Fr)
        return !0;
      if (jr == (Vr < 0 ? 0 : li(Lr))) {
        var Wr = Lr.parentNode;
        if (!Wr || Wr.nodeType != 1 || ei(Lr) || Xr.test(Lr.nodeName) || Lr.contentEditable == "false")
          return !1;
        jr = Mr(Lr) + (Vr < 0 ? 0 : 1), Lr = Wr;
      } else if (Lr.nodeType == 1) {
        if (Lr = Lr.childNodes[jr + (Vr < 0 ? -1 : 0)], Lr.contentEditable == "false")
          return !1;
        jr = Vr < 0 ? li(Lr) : 0;
      } else
        return !1;
    }
  }
  function li(Lr) {
    return Lr.nodeType == 3 ? Lr.nodeValue.length : Lr.childNodes.length;
  }
  function Qr(Lr, jr, Rr) {
    for (var Fr = jr == 0, Vr = jr == li(Lr); Fr || Vr; ) {
      if (Lr == Rr)
        return !0;
      var Wr = Mr(Lr);
      if (Lr = Lr.parentNode, !Lr)
        return !1;
      Fr = Fr && Wr == 0, Vr = Vr && Wr == li(Lr);
    }
  }
  function ei(Lr) {
    for (var jr, Rr = Lr; Rr && !(jr = Rr.pmViewDesc); Rr = Rr.parentNode)
      ;
    return jr && jr.node && jr.node.isBlock && (jr.dom == Lr || jr.contentDOM == Lr);
  }
  var ui = function(jr) {
    return jr.focusNode && Gr(jr.focusNode, jr.focusOffset, jr.anchorNode, jr.anchorOffset);
  };
  function Ai(Lr, jr) {
    var Rr = document.createEvent("Event");
    return Rr.initEvent("keydown", !0, !0), Rr.keyCode = Lr, Rr.key = Rr.code = jr, Rr;
  }
  function fi(Lr) {
    for (var jr = Lr.activeElement; jr && jr.shadowRoot; )
      jr = jr.shadowRoot.activeElement;
    return jr;
  }
  function gi(Lr, jr, Rr) {
    if (Lr.caretPositionFromPoint)
      try {
        var Fr = Lr.caretPositionFromPoint(jr, Rr);
        if (Fr)
          return {
            node: Fr.offsetNode,
            offset: Fr.offset
          };
      } catch (Wr) {
      }
    if (Lr.caretRangeFromPoint) {
      var Vr = Lr.caretRangeFromPoint(jr, Rr);
      if (Vr)
        return {
          node: Vr.startContainer,
          offset: Vr.startOffset
        };
    }
  }
  var Ci = typeof navigator != "undefined" ? navigator : null, mi = typeof document != "undefined" ? document : null, vi = Ci && Ci.userAgent || "", Ri = /Edge\/(\d+)/.exec(vi), di = /MSIE \d/.exec(vi), Ti = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(vi), qi = !!(di || Ti || Ri), ki = di ? document.documentMode : Ti ? +Ti[1] : Ri ? +Ri[1] : 0, Ji = !qi && /gecko\/(\d+)/i.test(vi);
  Ji && +(/Firefox\/(\d+)/.exec(vi) || [0, 0])[1];
  var Bi = !qi && /Chrome\/(\d+)/.exec(vi), Ni = !!Bi, Mi = Bi ? +Bi[1] : 0, bi = !qi && !!Ci && /Apple Computer/.test(Ci.vendor), Ei = bi && (/Mobile\/\w+/.test(vi) || !!Ci && Ci.maxTouchPoints > 2), Si = Ei || (Ci ? /Mac/.test(Ci.platform) : !1), Vi = Ci ? /Win/.test(Ci.platform) : !1, Di = /Android \d/.test(vi), sa = !!mi && "webkitFontSmoothing" in mi.documentElement.style, ra = sa ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function fa(Lr) {
    return {
      left: 0,
      right: Lr.documentElement.clientWidth,
      top: 0,
      bottom: Lr.documentElement.clientHeight
    };
  }
  function ba(Lr, jr) {
    return typeof Lr == "number" ? Lr : Lr[jr];
  }
  function Ua(Lr) {
    var jr = Lr.getBoundingClientRect(), Rr = jr.width / Lr.offsetWidth || 1, Fr = jr.height / Lr.offsetHeight || 1;
    return {
      left: jr.left,
      right: jr.left + Lr.clientWidth * Rr,
      top: jr.top,
      bottom: jr.top + Lr.clientHeight * Fr
    };
  }
  function Va(Lr, jr, Rr) {
    for (var Fr = Lr.someProp("scrollThreshold") || 0, Vr = Lr.someProp("scrollMargin") || 5, Wr = Lr.dom.ownerDocument, ri = Rr || Lr.dom; ri; ri = Hr(ri))
      if (ri.nodeType == 1) {
        var ai = ri, hi = ai == Wr.body, wi = hi ? fa(Wr) : Ua(ai), Oi = 0, Wi = 0;
        if (jr.top < wi.top + ba(Fr, "top") ? Wi = -(wi.top - jr.top + ba(Vr, "top")) : jr.bottom > wi.bottom - ba(Fr, "bottom") && (Wi = jr.bottom - jr.top > wi.bottom - wi.top ? jr.top + ba(Vr, "top") - wi.top : jr.bottom - wi.bottom + ba(Vr, "bottom")), jr.left < wi.left + ba(Fr, "left") ? Oi = -(wi.left - jr.left + ba(Vr, "left")) : jr.right > wi.right - ba(Fr, "right") && (Oi = jr.right - wi.right + ba(Vr, "right")), Oi || Wi)
          if (hi)
            Wr.defaultView.scrollBy(Oi, Wi);
          else {
            var zi = ai.scrollLeft, Qi = ai.scrollTop;
            Wi && (ai.scrollTop += Wi), Oi && (ai.scrollLeft += Oi);
            var ia = ai.scrollLeft - zi, Ta = ai.scrollTop - Qi;
            jr = {
              left: jr.left - ia,
              top: jr.top - Ta,
              right: jr.right - ia,
              bottom: jr.bottom - Ta
            };
          }
        if (hi || /^(fixed|sticky)$/.test(getComputedStyle(ri).position))
          break;
      }
  }
  function Ma(Lr) {
    for (var jr = Lr.dom.getBoundingClientRect(), Rr = Math.max(0, jr.top), Fr, Vr, Wr = (jr.left + jr.right) / 2, ri = Rr + 1; ri < Math.min(innerHeight, jr.bottom); ri += 5) {
      var ai = Lr.root.elementFromPoint(Wr, ri);
      if (!(!ai || ai == Lr.dom || !Lr.dom.contains(ai))) {
        var hi = ai.getBoundingClientRect();
        if (hi.top >= Rr - 20) {
          Fr = ai, Vr = hi.top;
          break;
        }
      }
    }
    return {
      refDOM: Fr,
      refTop: Vr,
      stack: Fi(Lr.dom)
    };
  }
  function Fi(Lr) {
    for (var jr = [], Rr = Lr.ownerDocument, Fr = Lr; Fr && (jr.push({
      dom: Fr,
      top: Fr.scrollTop,
      left: Fr.scrollLeft
    }), Lr != Rr); Fr = Hr(Fr))
      ;
    return jr;
  }
  function na(Lr) {
    var jr = Lr.refDOM, Rr = Lr.refTop, Fr = Lr.stack, Vr = jr ? jr.getBoundingClientRect().top : 0;
    Gi(Fr, Vr == 0 ? 0 : Vr - Rr);
  }
  function Gi(Lr, jr) {
    for (var Rr = 0; Rr < Lr.length; Rr++) {
      var Fr = Lr[Rr], Vr = Fr.dom, Wr = Fr.top, ri = Fr.left;
      Vr.scrollTop != Wr + jr && (Vr.scrollTop = Wr + jr), Vr.scrollLeft != ri && (Vr.scrollLeft = ri);
    }
  }
  var Ca = null;
  function $a(Lr) {
    if (Lr.setActive)
      return Lr.setActive();
    if (Ca)
      return Lr.focus(Ca);
    var jr = Fi(Lr);
    Lr.focus(Ca == null ? {
      get preventScroll() {
        return Ca = {
          preventScroll: !0
        }, !0;
      }
    } : void 0), Ca || (Ca = !1, Gi(jr, 0));
  }
  function no(Lr, jr) {
    for (var Rr, Fr = 2e8, Vr, Wr = 0, ri = jr.top, ai = jr.top, hi, wi, Oi = Lr.firstChild, Wi = 0; Oi; Oi = Oi.nextSibling, Wi++) {
      var zi = void 0;
      if (Oi.nodeType == 1)
        zi = Oi.getClientRects();
      else if (Oi.nodeType == 3)
        zi = zr(Oi).getClientRects();
      else
        continue;
      for (var Qi = 0; Qi < zi.length; Qi++) {
        var ia = zi[Qi];
        if (ia.top <= ri && ia.bottom >= ai) {
          ri = Math.max(ia.bottom, ri), ai = Math.min(ia.top, ai);
          var Ta = ia.left > jr.left ? ia.left - jr.left : ia.right < jr.left ? jr.left - ia.right : 0;
          if (Ta < Fr) {
            Rr = Oi, Fr = Ta, Vr = Ta && Rr.nodeType == 3 ? {
              left: ia.right < jr.left ? ia.right : ia.left,
              top: jr.top
            } : jr, Oi.nodeType == 1 && Ta && (Wr = Wi + (jr.left >= (ia.left + ia.right) / 2 ? 1 : 0));
            continue;
          }
        } else
          ia.top > jr.top && !hi && ia.left <= jr.left && ia.right >= jr.left && (hi = Oi, wi = {
            left: Math.max(ia.left, Math.min(ia.right, jr.left)),
            top: ia.top
          });
        !Rr && (jr.left >= ia.right && jr.top >= ia.top || jr.left >= ia.left && jr.top >= ia.bottom) && (Wr = Wi + 1);
      }
    }
    return !Rr && hi && (Rr = hi, Vr = wi, Fr = 0), Rr && Rr.nodeType == 3 ? ga(Rr, Vr) : !Rr || Fr && Rr.nodeType == 1 ? {
      node: Lr,
      offset: Wr
    } : no(Rr, Vr);
  }
  function ga(Lr, jr) {
    for (var Rr = Lr.nodeValue.length, Fr = document.createRange(), Vr = 0; Vr < Rr; Vr++) {
      Fr.setEnd(Lr, Vr + 1), Fr.setStart(Lr, Vr);
      var Wr = Yi(Fr, 1);
      if (Wr.top != Wr.bottom && pa(jr, Wr))
        return {
          node: Lr,
          offset: Vr + (jr.left >= (Wr.left + Wr.right) / 2 ? 1 : 0)
        };
    }
    return {
      node: Lr,
      offset: 0
    };
  }
  function pa(Lr, jr) {
    return Lr.left >= jr.left - 1 && Lr.left <= jr.right + 1 && Lr.top >= jr.top - 1 && Lr.top <= jr.bottom + 1;
  }
  function Sa(Lr, jr) {
    var Rr = Lr.parentNode;
    return Rr && /^li$/i.test(Rr.nodeName) && jr.left < Lr.getBoundingClientRect().left ? Rr : Lr;
  }
  function Na(Lr, jr, Rr) {
    var Fr = no(jr, Rr), Vr = Fr.node, Wr = Fr.offset, ri = -1;
    if (Vr.nodeType == 1 && !Vr.firstChild) {
      var ai = Vr.getBoundingClientRect();
      ri = ai.left != ai.right && Rr.left > (ai.left + ai.right) / 2 ? 1 : -1;
    }
    return Lr.docView.posFromDOM(Vr, Wr, ri);
  }
  function Oa(Lr, jr, Rr, Fr) {
    for (var Vr = -1, Wr = jr, ri = !1; Wr != Lr.dom; ) {
      var ai = Lr.docView.nearestDesc(Wr, !0);
      if (!ai)
        return null;
      if (ai.dom.nodeType == 1 && (ai.node.isBlock && ai.parent && !ri || !ai.contentDOM)) {
        var hi = ai.dom.getBoundingClientRect();
        if (ai.node.isBlock && ai.parent && !ri && (ri = !0, hi.left > Fr.left || hi.top > Fr.top ? Vr = ai.posBefore : (hi.right < Fr.left || hi.bottom < Fr.top) && (Vr = ai.posAfter)), !ai.contentDOM && Vr < 0 && !ai.node.isText) {
          var wi = ai.node.isBlock ? Fr.top < (hi.top + hi.bottom) / 2 : Fr.left < (hi.left + hi.right) / 2;
          return wi ? ai.posBefore : ai.posAfter;
        }
      }
      Wr = ai.dom.parentNode;
    }
    return Vr > -1 ? Vr : Lr.docView.posFromDOM(jr, Rr, -1);
  }
  function Ja(Lr, jr, Rr) {
    var Fr = Lr.childNodes.length;
    if (Fr && Rr.top < Rr.bottom)
      for (var Vr = Math.max(0, Math.min(Fr - 1, Math.floor(Fr * (jr.top - Rr.top) / (Rr.bottom - Rr.top)) - 2)), Wr = Vr; ; ) {
        var ri = Lr.childNodes[Wr];
        if (ri.nodeType == 1)
          for (var ai = ri.getClientRects(), hi = 0; hi < ai.length; hi++) {
            var wi = ai[hi];
            if (pa(jr, wi))
              return Ja(ri, jr, wi);
          }
        if ((Wr = (Wr + 1) % Fr) == Vr)
          break;
      }
    return Lr;
  }
  function za(Lr, jr) {
    var Rr = Lr.dom.ownerDocument, Fr, Vr = 0, Wr = gi(Rr, jr.left, jr.top);
    Wr && (Fr = Wr.node, Vr = Wr.offset);
    var ri = (Lr.root.elementFromPoint ? Lr.root : Rr).elementFromPoint(jr.left, jr.top), ai;
    if (!ri || !Lr.dom.contains(ri.nodeType != 1 ? ri.parentNode : ri)) {
      var hi = Lr.dom.getBoundingClientRect();
      if (!pa(jr, hi) || (ri = Ja(Lr.dom, jr, hi), !ri))
        return null;
    }
    if (bi)
      for (var wi = ri; Fr && wi; wi = Hr(wi))
        wi.draggable && (Fr = void 0);
    if (ri = Sa(ri, jr), Fr) {
      if (Ji && Fr.nodeType == 1 && (Vr = Math.min(Vr, Fr.childNodes.length), Vr < Fr.childNodes.length)) {
        var Oi = Fr.childNodes[Vr], Wi;
        Oi.nodeName == "IMG" && (Wi = Oi.getBoundingClientRect()).right <= jr.left && Wi.bottom > jr.top && Vr++;
      }
      var zi;
      sa && Vr && Fr.nodeType == 1 && (zi = Fr.childNodes[Vr - 1]).nodeType == 1 && zi.contentEditable == "false" && zi.getBoundingClientRect().top >= jr.top && Vr--, Fr == Lr.dom && Vr == Fr.childNodes.length - 1 && Fr.lastChild.nodeType == 1 && jr.top > Fr.lastChild.getBoundingClientRect().bottom ? ai = Lr.state.doc.content.size : (Vr == 0 || Fr.nodeType != 1 || Fr.childNodes[Vr - 1].nodeName != "BR") && (ai = Oa(Lr, Fr, Vr, jr));
    }
    ai == null && (ai = Na(Lr, ri, jr));
    var Qi = Lr.docView.nearestDesc(ri, !0);
    return {
      pos: ai,
      inside: Qi ? Qi.posAtStart - Qi.border : -1
    };
  }
  function Ia(Lr) {
    return Lr.top < Lr.bottom || Lr.left < Lr.right;
  }
  function Yi(Lr, jr) {
    var Rr = Lr.getClientRects();
    if (Rr.length) {
      var Fr = Rr[jr < 0 ? 0 : Rr.length - 1];
      if (Ia(Fr))
        return Fr;
    }
    return Array.prototype.find.call(Rr, Ia) || Lr.getBoundingClientRect();
  }
  var La = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function Ka(Lr, jr, Rr) {
    var Fr = Lr.docView.domFromPos(jr, Rr < 0 ? -1 : 1), Vr = Fr.node, Wr = Fr.offset, ri = Fr.atom, ai = sa || Ji;
    if (Vr.nodeType == 3)
      if (ai && (La.test(Vr.nodeValue) || (Rr < 0 ? !Wr : Wr == Vr.nodeValue.length))) {
        var hi = Yi(zr(Vr, Wr, Wr), Rr);
        if (Ji && Wr && /\s/.test(Vr.nodeValue[Wr - 1]) && Wr < Vr.nodeValue.length) {
          var wi = Yi(zr(Vr, Wr - 1, Wr - 1), -1);
          if (wi.top == hi.top) {
            var Oi = Yi(zr(Vr, Wr, Wr + 1), -1);
            if (Oi.top != hi.top)
              return Qa(Oi, Oi.left < wi.left);
          }
        }
        return hi;
      } else {
        var Wi = Wr, zi = Wr, Qi = Rr < 0 ? 1 : -1;
        return Rr < 0 && !Wr ? (zi++, Qi = -1) : Rr >= 0 && Wr == Vr.nodeValue.length ? (Wi--, Qi = 1) : Rr < 0 ? Wi-- : zi++, Qa(Yi(zr(Vr, Wi, zi), Qi), Qi < 0);
      }
    var ia = Lr.state.doc.resolve(jr - (ri || 0));
    if (!ia.parent.inlineContent) {
      if (ri == null && Wr && (Rr < 0 || Wr == li(Vr))) {
        var Ta = Vr.childNodes[Wr - 1];
        if (Ta.nodeType == 1)
          return Hi(Ta.getBoundingClientRect(), !1);
      }
      if (ri == null && Wr < li(Vr)) {
        var Da = Vr.childNodes[Wr];
        if (Da.nodeType == 1)
          return Hi(Da.getBoundingClientRect(), !0);
      }
      return Hi(Vr.getBoundingClientRect(), Rr >= 0);
    }
    if (ri == null && Wr && (Rr < 0 || Wr == li(Vr))) {
      var ha = Vr.childNodes[Wr - 1], co = ha.nodeType == 3 ? zr(ha, li(ha) - (ai ? 0 : 1)) : ha.nodeType == 1 && (ha.nodeName != "BR" || !ha.nextSibling) ? ha : null;
      if (co)
        return Qa(Yi(co, 1), !1);
    }
    if (ri == null && Wr < li(Vr)) {
      for (var Xa = Vr.childNodes[Wr]; Xa.pmViewDesc && Xa.pmViewDesc.ignoreForCoords; )
        Xa = Xa.nextSibling;
      var ao = Xa ? Xa.nodeType == 3 ? zr(Xa, 0, ai ? 0 : 1) : Xa.nodeType == 1 ? Xa : null : null;
      if (ao)
        return Qa(Yi(ao, -1), !0);
    }
    return Qa(Yi(Vr.nodeType == 3 ? zr(Vr) : Vr, -Rr), Rr >= 0);
  }
  function Qa(Lr, jr) {
    if (Lr.width == 0)
      return Lr;
    var Rr = jr ? Lr.left : Lr.right;
    return {
      top: Lr.top,
      bottom: Lr.bottom,
      left: Rr,
      right: Rr
    };
  }
  function Hi(Lr, jr) {
    if (Lr.height == 0)
      return Lr;
    var Rr = jr ? Lr.top : Lr.bottom;
    return {
      top: Rr,
      bottom: Rr,
      left: Lr.left,
      right: Lr.right
    };
  }
  function da(Lr, jr, Rr) {
    var Fr = Lr.state, Vr = Lr.root.activeElement;
    Fr != jr && Lr.updateState(jr), Vr != Lr.dom && Lr.focus();
    try {
      return Rr();
    } finally {
      Fr != jr && Lr.updateState(Fr), Vr != Lr.dom && Vr && Vr.focus();
    }
  }
  function aa(Lr, jr, Rr) {
    var Fr = jr.selection, Vr = Rr == "up" ? Fr.$from : Fr.$to;
    return da(Lr, jr, function() {
      for (var Wr = Lr.docView.domFromPos(Vr.pos, Rr == "up" ? -1 : 1), ri = Wr.node; ; ) {
        var ai = Lr.docView.nearestDesc(ri, !0);
        if (!ai)
          break;
        if (ai.node.isBlock) {
          ri = ai.contentDOM || ai.dom;
          break;
        }
        ri = ai.dom.parentNode;
      }
      for (var hi = Ka(Lr, Vr.pos, 1), wi = ri.firstChild; wi; wi = wi.nextSibling) {
        var Oi = void 0;
        if (wi.nodeType == 1)
          Oi = wi.getClientRects();
        else if (wi.nodeType == 3)
          Oi = zr(wi, 0, wi.nodeValue.length).getClientRects();
        else
          continue;
        for (var Wi = 0; Wi < Oi.length; Wi++) {
          var zi = Oi[Wi];
          if (zi.bottom > zi.top + 1 && (Rr == "up" ? hi.top - zi.top > (zi.bottom - hi.top) * 2 : zi.bottom - hi.bottom > (hi.bottom - zi.top) * 2))
            return !1;
        }
      }
      return !0;
    });
  }
  var oa = /[\u0590-\u08ac]/;
  function ja(Lr, jr, Rr) {
    var Fr = jr.selection.$head;
    if (!Fr.parent.isTextblock)
      return !1;
    var Vr = Fr.parentOffset, Wr = !Vr, ri = Vr == Fr.parent.content.size, ai = Lr.domSelection();
    return !oa.test(Fr.parent.textContent) || !ai.modify ? Rr == "left" || Rr == "backward" ? Wr : ri : da(Lr, jr, function() {
      var hi = Lr.domSelectionRange(), wi = hi.focusNode, Oi = hi.focusOffset, Wi = hi.anchorNode, zi = hi.anchorOffset, Qi = ai.caretBidiLevel;
      ai.modify("move", Rr, "character");
      var ia = Fr.depth ? Lr.docView.domAfterPos(Fr.before()) : Lr.dom, Ta = Lr.domSelectionRange(), Da = Ta.focusNode, ha = Ta.focusOffset, co = Da && !ia.contains(Da.nodeType == 1 ? Da : Da.parentNode) || wi == Da && Oi == ha;
      try {
        ai.collapse(Wi, zi), wi && (wi != Wi || Oi != zi) && ai.extend && ai.extend(wi, Oi);
      } catch (Xa) {
      }
      return Qi != null && (ai.caretBidiLevel = Qi), co;
    });
  }
  var Ga = null, xa = null, qa = !1;
  function Ya(Lr, jr, Rr) {
    return Ga == jr && xa == Rr ? qa : (Ga = jr, xa = Rr, qa = Rr == "up" || Rr == "down" ? aa(Lr, jr, Rr) : ja(Lr, jr, Rr));
  }
  var Za = 0, ko = 1, lo = 2, so = 3, ho = function() {
    function Lr(jr, Rr, Fr, Vr) {
      Sr(this, Lr), this.parent = jr, this.children = Rr, this.dom = Fr, this.contentDOM = Vr, this.dirty = Za, Fr.pmViewDesc = this;
    }
    return Cr(Lr, [{
      key: "matchesWidget",
      value: function(Rr) {
        return !1;
      }
    }, {
      key: "matchesMark",
      value: function(Rr) {
        return !1;
      }
    }, {
      key: "matchesNode",
      value: function(Rr, Fr, Vr) {
        return !1;
      }
    }, {
      key: "matchesHack",
      value: function(Rr) {
        return !1;
      }
    }, {
      key: "parseRule",
      value: function() {
        return null;
      }
    }, {
      key: "stopEvent",
      value: function(Rr) {
        return !1;
      }
    }, {
      key: "size",
      get: function() {
        for (var Rr = 0, Fr = 0; Fr < this.children.length; Fr++)
          Rr += this.children[Fr].size;
        return Rr;
      }
    }, {
      key: "border",
      get: function() {
        return 0;
      }
    }, {
      key: "destroy",
      value: function() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (var Rr = 0; Rr < this.children.length; Rr++)
          this.children[Rr].destroy();
      }
    }, {
      key: "posBeforeChild",
      value: function(Rr) {
        for (var Fr = 0, Vr = this.posAtStart; ; Fr++) {
          var Wr = this.children[Fr];
          if (Wr == Rr)
            return Vr;
          Vr += Wr.size;
        }
      }
    }, {
      key: "posBefore",
      get: function() {
        return this.parent.posBeforeChild(this);
      }
    }, {
      key: "posAtStart",
      get: function() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
    }, {
      key: "posAfter",
      get: function() {
        return this.posBefore + this.size;
      }
    }, {
      key: "posAtEnd",
      get: function() {
        return this.posAtStart + this.size - 2 * this.border;
      }
    }, {
      key: "localPosFromDOM",
      value: function(Rr, Fr, Vr) {
        if (this.contentDOM && this.contentDOM.contains(Rr.nodeType == 1 ? Rr : Rr.parentNode))
          if (Vr < 0) {
            var Wr, ri;
            if (Rr == this.contentDOM)
              Wr = Rr.childNodes[Fr - 1];
            else {
              for (; Rr.parentNode != this.contentDOM; )
                Rr = Rr.parentNode;
              Wr = Rr.previousSibling;
            }
            for (; Wr && !((ri = Wr.pmViewDesc) && ri.parent == this); )
              Wr = Wr.previousSibling;
            return Wr ? this.posBeforeChild(ri) + ri.size : this.posAtStart;
          } else {
            var ai, hi;
            if (Rr == this.contentDOM)
              ai = Rr.childNodes[Fr];
            else {
              for (; Rr.parentNode != this.contentDOM; )
                Rr = Rr.parentNode;
              ai = Rr.nextSibling;
            }
            for (; ai && !((hi = ai.pmViewDesc) && hi.parent == this); )
              ai = ai.nextSibling;
            return ai ? this.posBeforeChild(hi) : this.posAtEnd;
          }
        var wi;
        if (Rr == this.dom && this.contentDOM)
          wi = Fr > Mr(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          wi = Rr.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (Fr == 0)
            for (var Oi = Rr; ; Oi = Oi.parentNode) {
              if (Oi == this.dom) {
                wi = !1;
                break;
              }
              if (Oi.previousSibling)
                break;
            }
          if (wi == null && Fr == Rr.childNodes.length)
            for (var Wi = Rr; ; Wi = Wi.parentNode) {
              if (Wi == this.dom) {
                wi = !0;
                break;
              }
              if (Wi.nextSibling)
                break;
            }
        }
        return (wi == null ? Vr > 0 : wi) ? this.posAtEnd : this.posAtStart;
      }
    }, {
      key: "nearestDesc",
      value: function(Rr) {
        for (var Fr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, Vr = !0, Wr = Rr; Wr; Wr = Wr.parentNode) {
          var ri = this.getDesc(Wr), ai = void 0;
          if (ri && (!Fr || ri.node))
            if (Vr && (ai = ri.nodeDOM) && !(ai.nodeType == 1 ? ai.contains(Rr.nodeType == 1 ? Rr : Rr.parentNode) : ai == Rr))
              Vr = !1;
            else
              return ri;
        }
      }
    }, {
      key: "getDesc",
      value: function(Rr) {
        for (var Fr = Rr.pmViewDesc, Vr = Fr; Vr; Vr = Vr.parent)
          if (Vr == this)
            return Fr;
      }
    }, {
      key: "posFromDOM",
      value: function(Rr, Fr, Vr) {
        for (var Wr = Rr; Wr; Wr = Wr.parentNode) {
          var ri = this.getDesc(Wr);
          if (ri)
            return ri.localPosFromDOM(Rr, Fr, Vr);
        }
        return -1;
      }
    }, {
      key: "descAt",
      value: function(Rr) {
        for (var Fr = 0, Vr = 0; Fr < this.children.length; Fr++) {
          var Wr = this.children[Fr], ri = Vr + Wr.size;
          if (Vr == Rr && ri != Vr) {
            for (; !Wr.border && Wr.children.length; )
              Wr = Wr.children[0];
            return Wr;
          }
          if (Rr < ri)
            return Wr.descAt(Rr - Vr - Wr.border);
          Vr = ri;
        }
      }
    }, {
      key: "domFromPos",
      value: function(Rr, Fr) {
        if (!this.contentDOM)
          return {
            node: this.dom,
            offset: 0,
            atom: Rr + 1
          };
        for (var Vr = 0, Wr = 0, ri = 0; Vr < this.children.length; Vr++) {
          var ai = this.children[Vr], hi = ri + ai.size;
          if (hi > Rr || ai instanceof ca) {
            Wr = Rr - ri;
            break;
          }
          ri = hi;
        }
        if (Wr)
          return this.children[Vr].domFromPos(Wr - this.children[Vr].border, Fr);
        for (var wi; Vr && !(wi = this.children[Vr - 1]).size && wi instanceof Ro && wi.side >= 0; Vr--)
          ;
        if (Fr <= 0) {
          for (var Oi, Wi = !0; Oi = Vr ? this.children[Vr - 1] : null, !(!Oi || Oi.dom.parentNode == this.contentDOM); Vr--, Wi = !1)
            ;
          return Oi && Fr && Wi && !Oi.border && !Oi.domAtom ? Oi.domFromPos(Oi.size, Fr) : {
            node: this.contentDOM,
            offset: Oi ? Mr(Oi.dom) + 1 : 0
          };
        } else {
          for (var zi, Qi = !0; zi = Vr < this.children.length ? this.children[Vr] : null, !(!zi || zi.dom.parentNode == this.contentDOM); Vr++, Qi = !1)
            ;
          return zi && Qi && !zi.border && !zi.domAtom ? zi.domFromPos(0, Fr) : {
            node: this.contentDOM,
            offset: zi ? Mr(zi.dom) : this.contentDOM.childNodes.length
          };
        }
      }
    }, {
      key: "parseRange",
      value: function(Rr, Fr) {
        var Vr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        if (this.children.length == 0)
          return {
            node: this.contentDOM,
            from: Rr,
            to: Fr,
            fromOffset: 0,
            toOffset: this.contentDOM.childNodes.length
          };
        for (var Wr = -1, ri = -1, ai = Vr, hi = 0; ; hi++) {
          var wi = this.children[hi], Oi = ai + wi.size;
          if (Wr == -1 && Rr <= Oi) {
            var Wi = ai + wi.border;
            if (Rr >= Wi && Fr <= Oi - wi.border && wi.node && wi.contentDOM && this.contentDOM.contains(wi.contentDOM))
              return wi.parseRange(Rr, Fr, Wi);
            Rr = ai;
            for (var zi = hi; zi > 0; zi--) {
              var Qi = this.children[zi - 1];
              if (Qi.size && Qi.dom.parentNode == this.contentDOM && !Qi.emptyChildAt(1)) {
                Wr = Mr(Qi.dom) + 1;
                break;
              }
              Rr -= Qi.size;
            }
            Wr == -1 && (Wr = 0);
          }
          if (Wr > -1 && (Oi > Fr || hi == this.children.length - 1)) {
            Fr = Oi;
            for (var ia = hi + 1; ia < this.children.length; ia++) {
              var Ta = this.children[ia];
              if (Ta.size && Ta.dom.parentNode == this.contentDOM && !Ta.emptyChildAt(-1)) {
                ri = Mr(Ta.dom);
                break;
              }
              Fr += Ta.size;
            }
            ri == -1 && (ri = this.contentDOM.childNodes.length);
            break;
          }
          ai = Oi;
        }
        return {
          node: this.contentDOM,
          from: Rr,
          to: Fr,
          fromOffset: Wr,
          toOffset: ri
        };
      }
    }, {
      key: "emptyChildAt",
      value: function(Rr) {
        if (this.border || !this.contentDOM || !this.children.length)
          return !1;
        var Fr = this.children[Rr < 0 ? 0 : this.children.length - 1];
        return Fr.size == 0 || Fr.emptyChildAt(Rr);
      }
    }, {
      key: "domAfterPos",
      value: function(Rr) {
        var Fr = this.domFromPos(Rr, 0), Vr = Fr.node, Wr = Fr.offset;
        if (Vr.nodeType != 1 || Wr == Vr.childNodes.length)
          throw new RangeError("No node after pos " + Rr);
        return Vr.childNodes[Wr];
      }
    }, {
      key: "setSelection",
      value: function(Rr, Fr, Vr) {
        for (var Wr = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, ri = Math.min(Rr, Fr), ai = Math.max(Rr, Fr), hi = 0, wi = 0; hi < this.children.length; hi++) {
          var Oi = this.children[hi], Wi = wi + Oi.size;
          if (ri > wi && ai < Wi)
            return Oi.setSelection(Rr - wi - Oi.border, Fr - wi - Oi.border, Vr, Wr);
          wi = Wi;
        }
        var zi = this.domFromPos(Rr, Rr ? -1 : 1), Qi = Fr == Rr ? zi : this.domFromPos(Fr, Fr ? -1 : 1), ia = Vr.getSelection(), Ta = !1;
        if ((Ji || bi) && Rr == Fr) {
          var Da = zi, ha = Da.node, co = Da.offset;
          if (ha.nodeType == 3) {
            if (Ta = !!(co && ha.nodeValue[co - 1] == `
`), Ta && co == ha.nodeValue.length)
              for (var Xa = ha, ao; Xa; Xa = Xa.parentNode) {
                if (ao = Xa.nextSibling) {
                  ao.nodeName == "BR" && (zi = Qi = {
                    node: ao.parentNode,
                    offset: Mr(ao) + 1
                  });
                  break;
                }
                var Wa = Xa.pmViewDesc;
                if (Wa && Wa.node && Wa.node.isBlock)
                  break;
              }
          } else {
            var eo = ha.childNodes[co - 1];
            Ta = eo && (eo.nodeName == "BR" || eo.contentEditable == "false");
          }
        }
        if (Ji && ia.focusNode && ia.focusNode != Qi.node && ia.focusNode.nodeType == 1) {
          var mo = ia.focusNode.childNodes[ia.focusOffset];
          mo && mo.contentEditable == "false" && (Wr = !0);
        }
        if (!(!(Wr || Ta && bi) && Gr(zi.node, zi.offset, ia.anchorNode, ia.anchorOffset) && Gr(Qi.node, Qi.offset, ia.focusNode, ia.focusOffset))) {
          var Do = !1;
          if ((ia.extend || Rr == Fr) && !Ta) {
            ia.collapse(zi.node, zi.offset);
            try {
              Rr != Fr && ia.extend(Qi.node, Qi.offset), Do = !0;
            } catch (Zo) {
            }
          }
          if (!Do) {
            if (Rr > Fr) {
              var $o = zi;
              zi = Qi, Qi = $o;
            }
            var Ao = document.createRange();
            Ao.setEnd(Qi.node, Qi.offset), Ao.setStart(zi.node, zi.offset), ia.removeAllRanges(), ia.addRange(Ao);
          }
        }
      }
    }, {
      key: "ignoreMutation",
      value: function(Rr) {
        return !this.contentDOM && Rr.type != "selection";
      }
    }, {
      key: "contentLost",
      get: function() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
    }, {
      key: "markDirty",
      value: function(Rr, Fr) {
        for (var Vr = 0, Wr = 0; Wr < this.children.length; Wr++) {
          var ri = this.children[Wr], ai = Vr + ri.size;
          if (Vr == ai ? Rr <= ai && Fr >= Vr : Rr < ai && Fr > Vr) {
            var hi = Vr + ri.border, wi = ai - ri.border;
            if (Rr >= hi && Fr <= wi) {
              this.dirty = Rr == Vr || Fr == ai ? lo : ko, Rr == hi && Fr == wi && (ri.contentLost || ri.dom.parentNode != this.contentDOM) ? ri.dirty = so : ri.markDirty(Rr - hi, Fr - hi);
              return;
            } else
              ri.dirty = ri.dom == ri.contentDOM && ri.dom.parentNode == this.contentDOM && !ri.children.length ? lo : so;
          }
          Vr = ai;
        }
        this.dirty = lo;
      }
    }, {
      key: "markParentsDirty",
      value: function() {
        for (var Rr = 1, Fr = this.parent; Fr; Fr = Fr.parent, Rr++) {
          var Vr = Rr == 1 ? lo : ko;
          Fr.dirty < Vr && (Fr.dirty = Vr);
        }
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return !1;
      }
    }]), Lr;
  }(), Ro = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri) {
      var ai;
      Sr(this, Rr);
      var hi, wi = Vr.type.toDOM;
      if (typeof wi == "function" && (wi = wi(Wr, function() {
        if (!hi)
          return ri;
        if (hi.parent)
          return hi.parent.posBeforeChild(hi);
      })), !Vr.type.spec.raw) {
        if (wi.nodeType != 1) {
          var Oi = document.createElement("span");
          Oi.appendChild(wi), wi = Oi;
        }
        wi.contentEditable = "false", wi.classList.add("ProseMirror-widget");
      }
      return ai = jr.call(this, Fr, [], wi, null), ai.widget = Vr, ai.widget = Vr, hi = kr(ai), ai;
    }
    return Cr(Rr, [{
      key: "matchesWidget",
      value: function(Vr) {
        return this.dirty == Za && Vr.type.eq(this.widget.type);
      }
    }, {
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "stopEvent",
      value: function(Vr) {
        var Wr = this.widget.spec.stopEvent;
        return Wr ? Wr(Vr) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(Vr) {
        return Vr.type != "selection" || this.widget.spec.ignoreSelection;
      }
    }, {
      key: "destroy",
      value: function() {
        this.widget.type.destroy(this.dom), fr(xr(Rr.prototype), "destroy", this).call(this);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "side",
      get: function() {
        return this.widget.type.side;
      }
    }]), Rr;
  }(ho), Mo = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri) {
      var ai;
      return Sr(this, Rr), ai = jr.call(this, Fr, [], Vr, null), ai.textDOM = Wr, ai.text = ri, ai;
    }
    return Cr(Rr, [{
      key: "size",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "localPosFromDOM",
      value: function(Vr, Wr) {
        return Vr != this.textDOM ? this.posAtStart + (Wr ? this.size : 0) : this.posAtStart + Wr;
      }
    }, {
      key: "domFromPos",
      value: function(Vr) {
        return {
          node: this.textDOM,
          offset: Vr
        };
      }
    }, {
      key: "ignoreMutation",
      value: function(Vr) {
        return Vr.type === "characterData" && Vr.target.nodeValue == Vr.oldValue;
      }
    }]), Rr;
  }(ho), Co = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri) {
      var ai;
      return Sr(this, Rr), ai = jr.call(this, Fr, [], Wr, ri), ai.mark = Vr, ai;
    }
    return Cr(Rr, [{
      key: "parseRule",
      value: function() {
        return this.dirty & so || this.mark.type.spec.reparseInView ? null : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM
        };
      }
    }, {
      key: "matchesMark",
      value: function(Vr) {
        return this.dirty != so && this.mark.eq(Vr);
      }
    }, {
      key: "markDirty",
      value: function(Vr, Wr) {
        if (fr(xr(Rr.prototype), "markDirty", this).call(this, Vr, Wr), this.dirty != Za) {
          for (var ri = this.parent; !ri.node; )
            ri = ri.parent;
          ri.dirty < this.dirty && (ri.dirty = this.dirty), this.dirty = Za;
        }
      }
    }, {
      key: "slice",
      value: function(Vr, Wr, ri) {
        var ai = Rr.create(this.parent, this.mark, !0, ri), hi = this.children, wi = this.size;
        Wr < wi && (hi = Bo(hi, Wr, wi, ri)), Vr > 0 && (hi = Bo(hi, 0, Vr, ri));
        for (var Oi = 0; Oi < hi.length; Oi++)
          hi[Oi].parent = ai;
        return ai.children = hi, ai;
      }
    }], [{
      key: "create",
      value: function(Vr, Wr, ri, ai) {
        var hi = ai.nodeViews[Wr.type.name], wi = hi && hi(Wr, ai, ri);
        return (!wi || !wi.dom) && (wi = Ar.DOMSerializer.renderSpec(document, Wr.type.spec.toDOM(Wr, ri))), new Rr(Vr, Wr, wi.dom, wi.contentDOM || wi.dom);
      }
    }]), Rr;
  }(ho), uo = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri, ai, hi, wi, Oi, Wi) {
      var zi;
      return Sr(this, Rr), zi = jr.call(this, Fr, [], ai, hi), zi.node = Vr, zi.outerDeco = Wr, zi.innerDeco = ri, zi.nodeDOM = wi, zi;
    }
    return Cr(Rr, [{
      key: "parseRule",
      value: function() {
        var Vr = this;
        if (this.node.type.spec.reparseInView)
          return null;
        var Wr = {
          node: this.node.type.name,
          attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (Wr.preserveWhitespace = "full"), !this.contentDOM)
          Wr.getContent = function() {
            return Vr.node.content;
          };
        else if (!this.contentLost)
          Wr.contentElement = this.contentDOM;
        else {
          for (var ri = this.children.length - 1; ri >= 0; ri--) {
            var ai = this.children[ri];
            if (this.dom.contains(ai.dom.parentNode)) {
              Wr.contentElement = ai.dom.parentNode;
              break;
            }
          }
          Wr.contentElement || (Wr.getContent = function() {
            return Ar.Fragment.empty;
          });
        }
        return Wr;
      }
    }, {
      key: "matchesNode",
      value: function(Vr, Wr, ri) {
        return this.dirty == Za && Vr.eq(this.node) && Ki(Wr, this.outerDeco) && ri.eq(this.innerDeco);
      }
    }, {
      key: "size",
      get: function() {
        return this.node.nodeSize;
      }
    }, {
      key: "border",
      get: function() {
        return this.node.isLeaf ? 0 : 1;
      }
    }, {
      key: "updateChildren",
      value: function(Vr, Wr) {
        var ri = this, ai = this.node.inlineContent, hi = Wr, wi = Vr.composing ? this.localCompositionInfo(Vr, Wr) : null, Oi = wi && wi.pos > -1 ? wi : null, Wi = wi && wi.pos < 0, zi = new va(this, Oi && Oi.node, Vr);
        Fa(this.node, this.innerDeco, function(Qi, ia, Ta) {
          Qi.spec.marks ? zi.syncToMarks(Qi.spec.marks, ai, Vr) : Qi.type.side >= 0 && !Ta && zi.syncToMarks(ia == ri.node.childCount ? Ar.Mark.none : ri.node.child(ia).marks, ai, Vr), zi.placeWidget(Qi, Vr, hi);
        }, function(Qi, ia, Ta, Da) {
          zi.syncToMarks(Qi.marks, ai, Vr);
          var ha;
          zi.findNodeMatch(Qi, ia, Ta, Da) || Wi && Vr.state.selection.from > hi && Vr.state.selection.to < hi + Qi.nodeSize && (ha = zi.findIndexWithChild(wi.node)) > -1 && zi.updateNodeAt(Qi, ia, Ta, ha, Vr) || zi.updateNextNode(Qi, ia, Ta, Vr, Da, hi) || zi.addNode(Qi, ia, Ta, Vr, hi), hi += Qi.nodeSize;
        }), zi.syncToMarks([], ai, Vr), this.node.isTextblock && zi.addTextblockHacks(), zi.destroyRest(), (zi.changed || this.dirty == lo) && (Oi && this.protectLocalComposition(Vr, Oi), ti(this.contentDOM, this.children, Vr), Ei && fo(this.dom));
      }
    }, {
      key: "localCompositionInfo",
      value: function(Vr, Wr) {
        var ri = Vr.state.selection, ai = ri.from, hi = ri.to;
        if (!(Vr.state.selection instanceof Tr.TextSelection) || ai < Wr || hi > Wr + this.node.content.size)
          return null;
        var wi = Vr.domSelectionRange(), Oi = _o(wi.focusNode, wi.focusOffset);
        if (!Oi || !this.dom.contains(Oi.parentNode))
          return null;
        if (this.node.inlineContent) {
          var Wi = Oi.nodeValue, zi = No(this.node.content, Wi, ai - Wr, hi - Wr);
          return zi < 0 ? null : {
            node: Oi,
            pos: zi,
            text: Wi
          };
        } else
          return {
            node: Oi,
            pos: -1,
            text: ""
          };
      }
    }, {
      key: "protectLocalComposition",
      value: function(Vr, Wr) {
        var ri = Wr.node, ai = Wr.pos, hi = Wr.text;
        if (!this.getDesc(ri)) {
          for (var wi = ri; wi.parentNode != this.contentDOM; wi = wi.parentNode) {
            for (; wi.previousSibling; )
              wi.parentNode.removeChild(wi.previousSibling);
            for (; wi.nextSibling; )
              wi.parentNode.removeChild(wi.nextSibling);
            wi.pmViewDesc && (wi.pmViewDesc = void 0);
          }
          var Oi = new Mo(this, wi, ri, hi);
          Vr.input.compositionNodes.push(Oi), this.children = Bo(this.children, ai, ai + hi.length, Vr, Oi);
        }
      }
    }, {
      key: "update",
      value: function(Vr, Wr, ri, ai) {
        return this.dirty == so || !Vr.sameMarkup(this.node) ? !1 : (this.updateInner(Vr, Wr, ri, ai), !0);
      }
    }, {
      key: "updateInner",
      value: function(Vr, Wr, ri, ai) {
        this.updateOuterDeco(Wr), this.node = Vr, this.innerDeco = ri, this.contentDOM && this.updateChildren(ai, this.posAtStart), this.dirty = Za;
      }
    }, {
      key: "updateOuterDeco",
      value: function(Vr) {
        if (!Ki(Vr, this.outerDeco)) {
          var Wr = this.nodeDOM.nodeType != 1, ri = this.dom;
          this.dom = si(this.dom, this.nodeDOM, Yr(this.outerDeco, this.node, Wr), Yr(Vr, this.node, Wr)), this.dom != ri && (ri.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = Vr;
        }
      }
    }, {
      key: "selectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
      }
    }, {
      key: "domAtom",
      get: function() {
        return this.node.isAtom;
      }
    }], [{
      key: "create",
      value: function(Vr, Wr, ri, ai, hi, wi) {
        var Oi = hi.nodeViews[Wr.type.name], Wi, zi = Oi && Oi(Wr, hi, function() {
          if (!Wi)
            return wi;
          if (Wi.parent)
            return Wi.parent.posBeforeChild(Wi);
        }, ri, ai), Qi = zi && zi.dom, ia = zi && zi.contentDOM;
        if (Wr.isText) {
          if (!Qi)
            Qi = document.createTextNode(Wr.text);
          else if (Qi.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!Qi) {
          var Ta = Ar.DOMSerializer.renderSpec(document, Wr.type.spec.toDOM(Wr));
          Qi = Ta.dom, ia = Ta.contentDOM;
        }
        !ia && !Wr.isText && Qi.nodeName != "BR" && (Qi.hasAttribute("contenteditable") || (Qi.contentEditable = "false"), Wr.type.spec.draggable && (Qi.draggable = !0));
        var Da = Qi;
        return Qi = Ii(Qi, ri, Wr), zi ? Wi = new ci(Vr, Wr, ri, ai, Qi, ia || null, Da, zi, hi, wi + 1) : Wr.isText ? new $i(Vr, Wr, ri, ai, Qi, Da, hi) : new Rr(Vr, Wr, ri, ai, Qi, ia || null, Da);
      }
    }]), Rr;
  }(ho);
  function wa(Lr, jr, Rr, Fr, Vr) {
    Ii(Fr, jr, Lr);
    var Wr = new uo(void 0, Lr, jr, Rr, Fr, Fr, Fr, Vr, 0);
    return Wr.contentDOM && Wr.updateChildren(Vr, 0), Wr;
  }
  var $i = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri, ai, hi, wi) {
      return Sr(this, Rr), jr.call(this, Fr, Vr, Wr, ri, ai, null, hi, wi, 0);
    }
    return Cr(Rr, [{
      key: "parseRule",
      value: function() {
        for (var Vr = this.nodeDOM.parentNode; Vr && Vr != this.dom && !Vr.pmIsDeco; )
          Vr = Vr.parentNode;
        return {
          skip: Vr || !0
        };
      }
    }, {
      key: "update",
      value: function(Vr, Wr, ri, ai) {
        return this.dirty == so || this.dirty != Za && !this.inParent() || !Vr.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(Wr), (this.dirty != Za || Vr.text != this.node.text) && Vr.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = Vr.text, ai.trackWrites == this.nodeDOM && (ai.trackWrites = null)), this.node = Vr, this.dirty = Za, !0);
      }
    }, {
      key: "inParent",
      value: function() {
        for (var Vr = this.parent.contentDOM, Wr = this.nodeDOM; Wr; Wr = Wr.parentNode)
          if (Wr == Vr)
            return !0;
        return !1;
      }
    }, {
      key: "domFromPos",
      value: function(Vr) {
        return {
          node: this.nodeDOM,
          offset: Vr
        };
      }
    }, {
      key: "localPosFromDOM",
      value: function(Vr, Wr, ri) {
        return Vr == this.nodeDOM ? this.posAtStart + Math.min(Wr, this.node.text.length) : fr(xr(Rr.prototype), "localPosFromDOM", this).call(this, Vr, Wr, ri);
      }
    }, {
      key: "ignoreMutation",
      value: function(Vr) {
        return Vr.type != "characterData" && Vr.type != "selection";
      }
    }, {
      key: "slice",
      value: function(Vr, Wr, ri) {
        var ai = this.node.cut(Vr, Wr), hi = document.createTextNode(ai.text);
        return new Rr(this.parent, ai, this.outerDeco, this.innerDeco, hi, hi, ri);
      }
    }, {
      key: "markDirty",
      value: function(Vr, Wr) {
        fr(xr(Rr.prototype), "markDirty", this).call(this, Vr, Wr), this.dom != this.nodeDOM && (Vr == 0 || Wr == this.nodeDOM.nodeValue.length) && (this.dirty = so);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }]), Rr;
  }(uo), ca = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr() {
      return Sr(this, Rr), jr.apply(this, arguments);
    }
    return Cr(Rr, [{
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "matchesHack",
      value: function(Vr) {
        return this.dirty == Za && this.dom.nodeName == Vr;
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return this.dom.nodeName == "IMG";
      }
    }]), Rr;
  }(ho), ci = function(Lr) {
    gr(Rr, Lr);
    var jr = vr(Rr);
    function Rr(Fr, Vr, Wr, ri, ai, hi, wi, Oi, Wi, zi) {
      var Qi;
      return Sr(this, Rr), Qi = jr.call(this, Fr, Vr, Wr, ri, ai, hi, wi, Wi, zi), Qi.spec = Oi, Qi;
    }
    return Cr(Rr, [{
      key: "update",
      value: function(Vr, Wr, ri, ai) {
        if (this.dirty == so)
          return !1;
        if (this.spec.update) {
          var hi = this.spec.update(Vr, Wr, ri);
          return hi && this.updateInner(Vr, Wr, ri, ai), hi;
        } else
          return !this.contentDOM && !Vr.isLeaf ? !1 : fr(xr(Rr.prototype), "update", this).call(this, Vr, Wr, ri, ai);
      }
    }, {
      key: "selectNode",
      value: function() {
        this.spec.selectNode ? this.spec.selectNode() : fr(xr(Rr.prototype), "selectNode", this).call(this);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.spec.deselectNode ? this.spec.deselectNode() : fr(xr(Rr.prototype), "deselectNode", this).call(this);
      }
    }, {
      key: "setSelection",
      value: function(Vr, Wr, ri, ai) {
        this.spec.setSelection ? this.spec.setSelection(Vr, Wr, ri) : fr(xr(Rr.prototype), "setSelection", this).call(this, Vr, Wr, ri, ai);
      }
    }, {
      key: "destroy",
      value: function() {
        this.spec.destroy && this.spec.destroy(), fr(xr(Rr.prototype), "destroy", this).call(this);
      }
    }, {
      key: "stopEvent",
      value: function(Vr) {
        return this.spec.stopEvent ? this.spec.stopEvent(Vr) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(Vr) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(Vr) : fr(xr(Rr.prototype), "ignoreMutation", this).call(this, Vr);
      }
    }]), Rr;
  }(uo);
  function ti(Lr, jr, Rr) {
    for (var Fr = Lr.firstChild, Vr = !1, Wr = 0; Wr < jr.length; Wr++) {
      var ri = jr[Wr], ai = ri.dom;
      if (ai.parentNode == Lr) {
        for (; ai != Fr; )
          Fr = ta(Fr), Vr = !0;
        Fr = Fr.nextSibling;
      } else
        Vr = !0, Lr.insertBefore(ai, Fr);
      if (ri instanceof Co) {
        var hi = Fr ? Fr.previousSibling : Lr.lastChild;
        ti(ri.contentDOM, ri.children, Rr), Fr = hi ? hi.nextSibling : Lr.firstChild;
      }
    }
    for (; Fr; )
      Fr = ta(Fr), Vr = !0;
    Vr && Rr.trackWrites == Lr && (Rr.trackWrites = null);
  }
  var Ur = function(jr) {
    jr && (this.nodeName = jr);
  };
  Ur.prototype = /* @__PURE__ */ Object.create(null);
  var qr = [new Ur()];
  function Yr(Lr, jr, Rr) {
    if (Lr.length == 0)
      return qr;
    for (var Fr = Rr ? qr[0] : new Ur(), Vr = [Fr], Wr = 0; Wr < Lr.length; Wr++) {
      var ri = Lr[Wr].type.attrs;
      if (ri) {
        ri.nodeName && Vr.push(Fr = new Ur(ri.nodeName));
        for (var ai in ri) {
          var hi = ri[ai];
          hi != null && (Rr && Vr.length == 1 && Vr.push(Fr = new Ur(jr.isInline ? "span" : "div")), ai == "class" ? Fr.class = (Fr.class ? Fr.class + " " : "") + hi : ai == "style" ? Fr.style = (Fr.style ? Fr.style + ";" : "") + hi : ai != "nodeName" && (Fr[ai] = hi));
        }
      }
    }
    return Vr;
  }
  function si(Lr, jr, Rr, Fr) {
    if (Rr == qr && Fr == qr)
      return jr;
    for (var Vr = jr, Wr = 0; Wr < Fr.length; Wr++) {
      var ri = Fr[Wr], ai = Rr[Wr];
      if (Wr) {
        var hi = void 0;
        ai && ai.nodeName == ri.nodeName && Vr != Lr && (hi = Vr.parentNode) && hi.nodeName.toLowerCase() == ri.nodeName || (hi = document.createElement(ri.nodeName), hi.pmIsDeco = !0, hi.appendChild(Vr), ai = qr[0]), Vr = hi;
      }
      yi(Vr, ai || qr[0], ri);
    }
    return Vr;
  }
  function yi(Lr, jr, Rr) {
    for (var Fr in jr)
      Fr != "class" && Fr != "style" && Fr != "nodeName" && !(Fr in Rr) && Lr.removeAttribute(Fr);
    for (var Vr in Rr)
      Vr != "class" && Vr != "style" && Vr != "nodeName" && Rr[Vr] != jr[Vr] && Lr.setAttribute(Vr, Rr[Vr]);
    if (jr.class != Rr.class) {
      for (var Wr = jr.class ? jr.class.split(" ").filter(Boolean) : [], ri = Rr.class ? Rr.class.split(" ").filter(Boolean) : [], ai = 0; ai < Wr.length; ai++)
        ri.indexOf(Wr[ai]) == -1 && Lr.classList.remove(Wr[ai]);
      for (var hi = 0; hi < ri.length; hi++)
        Wr.indexOf(ri[hi]) == -1 && Lr.classList.add(ri[hi]);
      Lr.classList.length == 0 && Lr.removeAttribute("class");
    }
    if (jr.style != Rr.style) {
      if (jr.style)
        for (var wi = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, Oi; Oi = wi.exec(jr.style); )
          Lr.style.removeProperty(Oi[1]);
      Rr.style && (Lr.style.cssText += Rr.style);
    }
  }
  function Ii(Lr, jr, Rr) {
    return si(Lr, Lr, qr, Yr(jr, Rr, Lr.nodeType != 1));
  }
  function Ki(Lr, jr) {
    if (Lr.length != jr.length)
      return !1;
    for (var Rr = 0; Rr < Lr.length; Rr++)
      if (!Lr[Rr].type.eq(jr[Rr].type))
        return !1;
    return !0;
  }
  function ta(Lr) {
    var jr = Lr.nextSibling;
    return Lr.parentNode.removeChild(Lr), jr;
  }
  var va = function() {
    function Lr(jr, Rr, Fr) {
      Sr(this, Lr), this.lock = Rr, this.view = Fr, this.index = 0, this.stack = [], this.changed = !1, this.top = jr, this.preMatch = ua(jr.node.content, jr);
    }
    return Cr(Lr, [{
      key: "destroyBetween",
      value: function(Rr, Fr) {
        if (Rr != Fr) {
          for (var Vr = Rr; Vr < Fr; Vr++)
            this.top.children[Vr].destroy();
          this.top.children.splice(Rr, Fr - Rr), this.changed = !0;
        }
      }
    }, {
      key: "destroyRest",
      value: function() {
        this.destroyBetween(this.index, this.top.children.length);
      }
    }, {
      key: "syncToMarks",
      value: function(Rr, Fr, Vr) {
        for (var Wr = 0, ri = this.stack.length >> 1, ai = Math.min(ri, Rr.length); Wr < ai && (Wr == ri - 1 ? this.top : this.stack[Wr + 1 << 1]).matchesMark(Rr[Wr]) && Rr[Wr].type.spec.spanning !== !1; )
          Wr++;
        for (; Wr < ri; )
          this.destroyRest(), this.top.dirty = Za, this.index = this.stack.pop(), this.top = this.stack.pop(), ri--;
        for (; ri < Rr.length; ) {
          this.stack.push(this.top, this.index + 1);
          for (var hi = -1, wi = this.index; wi < Math.min(this.index + 3, this.top.children.length); wi++) {
            var Oi = this.top.children[wi];
            if (Oi.matchesMark(Rr[ri]) && !this.isLocked(Oi.dom)) {
              hi = wi;
              break;
            }
          }
          if (hi > -1)
            hi > this.index && (this.changed = !0, this.destroyBetween(this.index, hi)), this.top = this.top.children[this.index];
          else {
            var Wi = Co.create(this.top, Rr[ri], Fr, Vr);
            this.top.children.splice(this.index, 0, Wi), this.top = Wi, this.changed = !0;
          }
          this.index = 0, ri++;
        }
      }
    }, {
      key: "findNodeMatch",
      value: function(Rr, Fr, Vr, Wr) {
        var ri = -1, ai;
        if (Wr >= this.preMatch.index && (ai = this.preMatch.matches[Wr - this.preMatch.index]).parent == this.top && ai.matchesNode(Rr, Fr, Vr))
          ri = this.top.children.indexOf(ai, this.index);
        else
          for (var hi = this.index, wi = Math.min(this.top.children.length, hi + 5); hi < wi; hi++) {
            var Oi = this.top.children[hi];
            if (Oi.matchesNode(Rr, Fr, Vr) && !this.preMatch.matched.has(Oi)) {
              ri = hi;
              break;
            }
          }
        return ri < 0 ? !1 : (this.destroyBetween(this.index, ri), this.index++, !0);
      }
    }, {
      key: "updateNodeAt",
      value: function(Rr, Fr, Vr, Wr, ri) {
        var ai = this.top.children[Wr];
        return ai.dirty == so && ai.dom == ai.contentDOM && (ai.dirty = lo), ai.update(Rr, Fr, Vr, ri) ? (this.destroyBetween(this.index, Wr), this.index++, !0) : !1;
      }
    }, {
      key: "findIndexWithChild",
      value: function(Rr) {
        for (; ; ) {
          var Fr = Rr.parentNode;
          if (!Fr)
            return -1;
          if (Fr == this.top.contentDOM) {
            var Vr = Rr.pmViewDesc;
            if (Vr) {
              for (var Wr = this.index; Wr < this.top.children.length; Wr++)
                if (this.top.children[Wr] == Vr)
                  return Wr;
            }
            return -1;
          }
          Rr = Fr;
        }
      }
    }, {
      key: "updateNextNode",
      value: function(Rr, Fr, Vr, Wr, ri, ai) {
        for (var hi = this.index; hi < this.top.children.length; hi++) {
          var wi = this.top.children[hi];
          if (wi instanceof uo) {
            var Oi = this.preMatch.matched.get(wi);
            if (Oi != null && Oi != ri)
              return !1;
            var Wi = wi.dom, zi = void 0, Qi = this.isLocked(Wi) && !(Rr.isText && wi.node && wi.node.isText && wi.nodeDOM.nodeValue == Rr.text && wi.dirty != so && Ki(Fr, wi.outerDeco));
            if (!Qi && wi.update(Rr, Fr, Vr, Wr))
              return this.destroyBetween(this.index, hi), wi.dom != Wi && (this.changed = !0), this.index++, !0;
            if (!Qi && (zi = this.recreateWrapper(wi, Rr, Fr, Vr, Wr, ai)))
              return this.top.children[this.index] = zi, zi.contentDOM && (zi.dirty = lo, zi.updateChildren(Wr, ai + 1), zi.dirty = Za), this.changed = !0, this.index++, !0;
            break;
          }
        }
        return !1;
      }
    }, {
      key: "recreateWrapper",
      value: function(Rr, Fr, Vr, Wr, ri, ai) {
        if (Rr.dirty || Fr.isAtom || !Rr.children.length || !Rr.node.content.eq(Fr.content))
          return null;
        var hi = uo.create(this.top, Fr, Vr, Wr, ri, ai);
        if (hi.contentDOM) {
          hi.children = Rr.children, Rr.children = [];
          var wi = ar(hi.children), Oi;
          try {
            for (wi.s(); !(Oi = wi.n()).done; ) {
              var Wi = Oi.value;
              Wi.parent = hi;
            }
          } catch (zi) {
            wi.e(zi);
          } finally {
            wi.f();
          }
        }
        return Rr.destroy(), hi;
      }
    }, {
      key: "addNode",
      value: function(Rr, Fr, Vr, Wr, ri) {
        var ai = uo.create(this.top, Rr, Fr, Vr, Wr, ri);
        ai.contentDOM && ai.updateChildren(Wr, ri + 1), this.top.children.splice(this.index++, 0, ai), this.changed = !0;
      }
    }, {
      key: "placeWidget",
      value: function(Rr, Fr, Vr) {
        var Wr = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (Wr && Wr.matchesWidget(Rr) && (Rr == Wr.widget || !Wr.widget.type.toDOM.parentNode))
          this.index++;
        else {
          var ri = new Ro(this.top, Rr, Fr, Vr);
          this.top.children.splice(this.index++, 0, ri), this.changed = !0;
        }
      }
    }, {
      key: "addTextblockHacks",
      value: function() {
        for (var Rr = this.top.children[this.index - 1], Fr = this.top; Rr instanceof Co; )
          Fr = Rr, Rr = Fr.children[Fr.children.length - 1];
        (!Rr || !(Rr instanceof $i) || /\n$/.test(Rr.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(Rr.node.text)) && ((bi || Ni) && Rr && Rr.dom.contentEditable == "false" && this.addHackNode("IMG", Fr), this.addHackNode("BR", this.top));
      }
    }, {
      key: "addHackNode",
      value: function(Rr, Fr) {
        if (Fr == this.top && this.index < Fr.children.length && Fr.children[this.index].matchesHack(Rr))
          this.index++;
        else {
          var Vr = document.createElement(Rr);
          Rr == "IMG" && (Vr.className = "ProseMirror-separator", Vr.alt = ""), Rr == "BR" && (Vr.className = "ProseMirror-trailingBreak");
          var Wr = new ca(this.top, [], Vr, null);
          Fr != this.top ? Fr.children.push(Wr) : Fr.children.splice(this.index++, 0, Wr), this.changed = !0;
        }
      }
    }, {
      key: "isLocked",
      value: function(Rr) {
        return this.lock && (Rr == this.lock || Rr.nodeType == 1 && Rr.contains(this.lock.parentNode));
      }
    }]), Lr;
  }();
  function ua(Lr, jr) {
    var Rr = jr, Fr = Rr.children.length, Vr = Lr.childCount, Wr = /* @__PURE__ */ new Map(), ri = [];
    e:
      for (; Vr > 0; ) {
        for (var ai = void 0; ; )
          if (Fr) {
            var hi = Rr.children[Fr - 1];
            if (hi instanceof Co)
              Rr = hi, Fr = hi.children.length;
            else {
              ai = hi, Fr--;
              break;
            }
          } else {
            if (Rr == jr)
              break e;
            Fr = Rr.parent.children.indexOf(Rr), Rr = Rr.parent;
          }
        var wi = ai.node;
        if (wi) {
          if (wi != Lr.child(Vr - 1))
            break;
          --Vr, Wr.set(ai, Vr), ri.push(ai);
        }
      }
    return {
      index: Vr,
      matched: Wr,
      matches: ri.reverse()
    };
  }
  function ma(Lr, jr) {
    return Lr.type.side - jr.type.side;
  }
  function Fa(Lr, jr, Rr, Fr) {
    var Vr = jr.locals(Lr), Wr = 0;
    if (Vr.length == 0) {
      for (var ri = 0; ri < Lr.childCount; ri++) {
        var ai = Lr.child(ri);
        Fr(ai, Vr, jr.forChild(Wr, ai), ri), Wr += ai.nodeSize;
      }
      return;
    }
    for (var hi = 0, wi = [], Oi = null, Wi = 0; ; ) {
      for (var zi = void 0, Qi = void 0; hi < Vr.length && Vr[hi].to == Wr; ) {
        var ia = Vr[hi++];
        ia.widget && (zi ? (Qi || (Qi = [zi])).push(ia) : zi = ia);
      }
      if (zi)
        if (Qi) {
          Qi.sort(ma);
          for (var Ta = 0; Ta < Qi.length; Ta++)
            Rr(Qi[Ta], Wi, !!Oi);
        } else
          Rr(zi, Wi, !!Oi);
      var Da = void 0, ha = void 0;
      if (Oi)
        ha = -1, Da = Oi, Oi = null;
      else if (Wi < Lr.childCount)
        ha = Wi, Da = Lr.child(Wi++);
      else
        break;
      for (var co = 0; co < wi.length; co++)
        wi[co].to <= Wr && wi.splice(co--, 1);
      for (; hi < Vr.length && Vr[hi].from <= Wr && Vr[hi].to > Wr; )
        wi.push(Vr[hi++]);
      var Xa = Wr + Da.nodeSize;
      if (Da.isText) {
        var ao = Xa;
        hi < Vr.length && Vr[hi].from < ao && (ao = Vr[hi].from);
        for (var Wa = 0; Wa < wi.length; Wa++)
          wi[Wa].to < ao && (ao = wi[Wa].to);
        ao < Xa && (Oi = Da.cut(ao - Wr), Da = Da.cut(0, ao - Wr), Xa = ao, ha = -1);
      }
      var eo = Da.isInline && !Da.isLeaf ? wi.filter(function(mo) {
        return !mo.inline;
      }) : wi.slice();
      Fr(Da, eo, jr.forChild(Wr, Da), ha), Wr = Xa;
    }
  }
  function fo(Lr) {
    if (Lr.nodeName == "UL" || Lr.nodeName == "OL") {
      var jr = Lr.style.cssText;
      Lr.style.cssText = jr + "; list-style: square !important", window.getComputedStyle(Lr).listStyle, Lr.style.cssText = jr;
    }
  }
  function _o(Lr, jr) {
    for (; ; ) {
      if (Lr.nodeType == 3)
        return Lr;
      if (Lr.nodeType == 1 && jr > 0) {
        if (Lr.childNodes.length > jr && Lr.childNodes[jr].nodeType == 3)
          return Lr.childNodes[jr];
        Lr = Lr.childNodes[jr - 1], jr = li(Lr);
      } else if (Lr.nodeType == 1 && jr < Lr.childNodes.length)
        Lr = Lr.childNodes[jr], jr = 0;
      else
        return null;
    }
  }
  function No(Lr, jr, Rr, Fr) {
    for (var Vr = 0, Wr = 0; Vr < Lr.childCount && Wr <= Fr; ) {
      var ri = Lr.child(Vr++), ai = Wr;
      if (Wr += ri.nodeSize, !!ri.isText) {
        for (var hi = ri.text; Vr < Lr.childCount; ) {
          var wi = Lr.child(Vr++);
          if (Wr += wi.nodeSize, !wi.isText)
            break;
          hi += wi.text;
        }
        if (Wr >= Rr) {
          if (Wr >= Fr && hi.slice(Fr - jr.length - ai, Fr - ai) == jr)
            return Fr - jr.length;
          var Oi = ai < Fr ? hi.lastIndexOf(jr, Fr - ai - 1) : -1;
          if (Oi >= 0 && Oi + jr.length + ai >= Rr)
            return ai + Oi;
          if (Rr == Fr && hi.length >= Fr + jr.length - ai && hi.slice(Fr - ai, Fr - ai + jr.length) == jr)
            return Fr;
        }
      }
    }
    return -1;
  }
  function Bo(Lr, jr, Rr, Fr, Vr) {
    for (var Wr = [], ri = 0, ai = 0; ri < Lr.length; ri++) {
      var hi = Lr[ri], wi = ai, Oi = ai += hi.size;
      wi >= Rr || Oi <= jr ? Wr.push(hi) : (wi < jr && Wr.push(hi.slice(0, jr - wi, Fr)), Vr && (Wr.push(Vr), Vr = void 0), Oi > Rr && Wr.push(hi.slice(Rr - wi, hi.size, Fr)));
    }
    return Wr;
  }
  function Po(Lr) {
    var jr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Rr = Lr.domSelectionRange(), Fr = Lr.state.doc;
    if (!Rr.focusNode)
      return null;
    var Vr = Lr.docView.nearestDesc(Rr.focusNode), Wr = Vr && Vr.size == 0, ri = Lr.docView.posFromDOM(Rr.focusNode, Rr.focusOffset, 1);
    if (ri < 0)
      return null;
    var ai = Fr.resolve(ri), hi, wi;
    if (ui(Rr)) {
      for (hi = ai; Vr && !Vr.node; )
        Vr = Vr.parent;
      var Oi = Vr.node;
      if (Vr && Oi.isAtom && Tr.NodeSelection.isSelectable(Oi) && Vr.parent && !(Oi.isInline && Qr(Rr.focusNode, Rr.focusOffset, Vr.dom))) {
        var Wi = Vr.posBefore;
        wi = new Tr.NodeSelection(ri == Wi ? ai : Fr.resolve(Wi));
      }
    } else {
      var zi = Lr.docView.posFromDOM(Rr.anchorNode, Rr.anchorOffset, 1);
      if (zi < 0)
        return null;
      hi = Fr.resolve(zi);
    }
    if (!wi) {
      var Qi = jr == "pointer" || Lr.state.selection.head < ai.pos && !Wr ? 1 : -1;
      wi = Ls(Lr, hi, ai, Qi);
    }
    return wi;
  }
  function ds(Lr) {
    return Lr.editable ? Lr.hasFocus() : $s(Lr) && document.activeElement && document.activeElement.contains(Lr.dom);
  }
  function Ho(Lr) {
    var jr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, Rr = Lr.state.selection;
    if (qs(Lr, Rr), !!ds(Lr)) {
      if (!jr && Lr.input.mouseDown && Lr.input.mouseDown.allowDefault && Ni) {
        var Fr = Lr.domSelectionRange(), Vr = Lr.domObserver.currentSelection;
        if (Fr.anchorNode && Vr.anchorNode && Gr(Fr.anchorNode, Fr.anchorOffset, Vr.anchorNode, Vr.anchorOffset)) {
          Lr.input.mouseDown.delayedSelectionSync = !0, Lr.domObserver.setCurSelection();
          return;
        }
      }
      if (Lr.domObserver.disconnectSelection(), Lr.cursorWrapper)
        is(Lr);
      else {
        var Wr = Rr.anchor, ri = Rr.head, ai, hi;
        hs && !(Rr instanceof Tr.TextSelection) && (Rr.$from.parent.inlineContent || (ai = Fs(Lr, Rr.from)), !Rr.empty && !Rr.$from.parent.inlineContent && (hi = Fs(Lr, Rr.to))), Lr.docView.setSelection(Wr, ri, Lr.root, jr), hs && (ai && rs(ai), hi && rs(hi)), Rr.visible ? Lr.dom.classList.remove("ProseMirror-hideselection") : (Lr.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && ns(Lr));
      }
      Lr.domObserver.setCurSelection(), Lr.domObserver.connectSelection();
    }
  }
  var hs = bi || Ni && Mi < 63;
  function Fs(Lr, jr) {
    var Rr = Lr.docView.domFromPos(jr, 0), Fr = Rr.node, Vr = Rr.offset, Wr = Vr < Fr.childNodes.length ? Fr.childNodes[Vr] : null, ri = Vr ? Fr.childNodes[Vr - 1] : null;
    if (bi && Wr && Wr.contentEditable == "false")
      return ps(Wr);
    if ((!Wr || Wr.contentEditable == "false") && (!ri || ri.contentEditable == "false")) {
      if (Wr)
        return ps(Wr);
      if (ri)
        return ps(ri);
    }
  }
  function ps(Lr) {
    return Lr.contentEditable = "true", bi && Lr.draggable && (Lr.draggable = !1, Lr.wasDraggable = !0), Lr;
  }
  function rs(Lr) {
    Lr.contentEditable = "false", Lr.wasDraggable && (Lr.draggable = !0, Lr.wasDraggable = null);
  }
  function ns(Lr) {
    var jr = Lr.dom.ownerDocument;
    jr.removeEventListener("selectionchange", Lr.input.hideSelectionGuard);
    var Rr = Lr.domSelectionRange(), Fr = Rr.anchorNode, Vr = Rr.anchorOffset;
    jr.addEventListener("selectionchange", Lr.input.hideSelectionGuard = function() {
      (Rr.anchorNode != Fr || Rr.anchorOffset != Vr) && (jr.removeEventListener("selectionchange", Lr.input.hideSelectionGuard), setTimeout(function() {
        (!ds(Lr) || Lr.state.selection.visible) && Lr.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function is(Lr) {
    var jr = Lr.domSelection(), Rr = document.createRange(), Fr = Lr.cursorWrapper.dom, Vr = Fr.nodeName == "IMG";
    Vr ? Rr.setEnd(Fr.parentNode, Mr(Fr) + 1) : Rr.setEnd(Fr, 0), Rr.collapse(!1), jr.removeAllRanges(), jr.addRange(Rr), !Vr && !Lr.state.selection.visible && qi && ki <= 11 && (Fr.disabled = !0, Fr.disabled = !1);
  }
  function qs(Lr, jr) {
    if (jr instanceof Tr.NodeSelection) {
      var Rr = Lr.docView.descAt(jr.from);
      Rr != Lr.lastSelectedViewDesc && (js(Lr), Rr && Rr.selectNode(), Lr.lastSelectedViewDesc = Rr);
    } else
      js(Lr);
  }
  function js(Lr) {
    Lr.lastSelectedViewDesc && (Lr.lastSelectedViewDesc.parent && Lr.lastSelectedViewDesc.deselectNode(), Lr.lastSelectedViewDesc = void 0);
  }
  function Ls(Lr, jr, Rr, Fr) {
    return Lr.someProp("createSelectionBetween", function(Vr) {
      return Vr(Lr, jr, Rr);
    }) || Tr.TextSelection.between(jr, Rr, Fr);
  }
  function Rs(Lr) {
    return Lr.editable && !Lr.hasFocus() ? !1 : $s(Lr);
  }
  function $s(Lr) {
    var jr = Lr.domSelectionRange();
    if (!jr.anchorNode)
      return !1;
    try {
      return Lr.dom.contains(jr.anchorNode.nodeType == 3 ? jr.anchorNode.parentNode : jr.anchorNode) && (Lr.editable || Lr.dom.contains(jr.focusNode.nodeType == 3 ? jr.focusNode.parentNode : jr.focusNode));
    } catch (Rr) {
      return !1;
    }
  }
  function Vs(Lr) {
    var jr = Lr.docView.domFromPos(Lr.state.selection.anchor, 0), Rr = Lr.domSelectionRange();
    return Gr(jr.node, jr.offset, Rr.anchorNode, Rr.anchorOffset);
  }
  function gs(Lr, jr) {
    var Rr = Lr.selection, Fr = Rr.$anchor, Vr = Rr.$head, Wr = jr > 0 ? Fr.max(Vr) : Fr.min(Vr), ri = Wr.parent.inlineContent ? Wr.depth ? Lr.doc.resolve(jr > 0 ? Wr.after() : Wr.before()) : null : Wr;
    return ri && Tr.Selection.findFrom(ri, jr);
  }
  function To(Lr, jr) {
    return Lr.dispatch(Lr.state.tr.setSelection(jr).scrollIntoView()), !0;
  }
  function vs(Lr, jr, Rr) {
    var Fr = Lr.state.selection;
    if (Fr instanceof Tr.TextSelection)
      if (Rr.indexOf("s") > -1) {
        var Vr = Fr.$head, Wr = Vr.textOffset ? null : jr < 0 ? Vr.nodeBefore : Vr.nodeAfter;
        if (!Wr || Wr.isText || !Wr.isLeaf)
          return !1;
        var ri = Lr.state.doc.resolve(Vr.pos + Wr.nodeSize * (jr < 0 ? -1 : 1));
        return To(Lr, new Tr.TextSelection(Fr.$anchor, ri));
      } else if (Fr.empty) {
        if (Lr.endOfTextblock(jr > 0 ? "forward" : "backward")) {
          var ai = gs(Lr.state, jr);
          return ai && ai instanceof Tr.NodeSelection ? To(Lr, ai) : !1;
        } else if (!(Si && Rr.indexOf("m") > -1)) {
          var hi = Fr.$head, wi = hi.textOffset ? null : jr < 0 ? hi.nodeBefore : hi.nodeAfter, Oi;
          if (!wi || wi.isText)
            return !1;
          var Wi = jr < 0 ? hi.pos - wi.nodeSize : hi.pos;
          return wi.isAtom || (Oi = Lr.docView.descAt(Wi)) && !Oi.contentDOM ? Tr.NodeSelection.isSelectable(wi) ? To(Lr, new Tr.NodeSelection(jr < 0 ? Lr.state.doc.resolve(hi.pos - wi.nodeSize) : hi)) : sa ? To(Lr, new Tr.TextSelection(Lr.state.doc.resolve(jr < 0 ? Wi : Wi + wi.nodeSize))) : !1 : !1;
        }
      } else
        return !1;
    else {
      if (Fr instanceof Tr.NodeSelection && Fr.node.isInline)
        return To(Lr, new Tr.TextSelection(jr > 0 ? Fr.$to : Fr.$from));
      var zi = gs(Lr.state, jr);
      return zi ? To(Lr, zi) : !1;
    }
  }
  function as(Lr) {
    return Lr.nodeType == 3 ? Lr.nodeValue.length : Lr.childNodes.length;
  }
  function Uo(Lr, jr) {
    var Rr = Lr.pmViewDesc;
    return Rr && Rr.size == 0 && (jr < 0 || Lr.nextSibling || Lr.nodeName != "BR");
  }
  function ss(Lr, jr) {
    return jr < 0 ? wl(Lr) : ls(Lr);
  }
  function wl(Lr) {
    var jr = Lr.domSelectionRange(), Rr = jr.focusNode, Fr = jr.focusOffset;
    if (Rr) {
      var Vr, Wr, ri = !1;
      for (Ji && Rr.nodeType == 1 && Fr < as(Rr) && Uo(Rr.childNodes[Fr], -1) && (ri = !0); ; )
        if (Fr > 0) {
          if (Rr.nodeType != 1)
            break;
          var ai = Rr.childNodes[Fr - 1];
          if (Uo(ai, -1))
            Vr = Rr, Wr = --Fr;
          else if (ai.nodeType == 3)
            Rr = ai, Fr = Rr.nodeValue.length;
          else
            break;
        } else {
          if (Yo(Rr))
            break;
          for (var hi = Rr.previousSibling; hi && Uo(hi, -1); )
            Vr = Rr.parentNode, Wr = Mr(hi), hi = hi.previousSibling;
          if (hi)
            Rr = hi, Fr = as(Rr);
          else {
            if (Rr = Rr.parentNode, Rr == Lr.dom)
              break;
            Fr = 0;
          }
        }
      ri ? Ms(Lr, Rr, Fr) : Vr && Ms(Lr, Vr, Wr);
    }
  }
  function ls(Lr) {
    var jr = Lr.domSelectionRange(), Rr = jr.focusNode, Fr = jr.focusOffset;
    if (Rr) {
      for (var Vr = as(Rr), Wr, ri; ; )
        if (Fr < Vr) {
          if (Rr.nodeType != 1)
            break;
          var ai = Rr.childNodes[Fr];
          if (Uo(ai, 1))
            Wr = Rr, ri = ++Fr;
          else
            break;
        } else {
          if (Yo(Rr))
            break;
          for (var hi = Rr.nextSibling; hi && Uo(hi, 1); )
            Wr = hi.parentNode, ri = Mr(hi) + 1, hi = hi.nextSibling;
          if (hi)
            Rr = hi, Fr = 0, Vr = as(Rr);
          else {
            if (Rr = Rr.parentNode, Rr == Lr.dom)
              break;
            Fr = Vr = 0;
          }
        }
      Wr && Ms(Lr, Wr, ri);
    }
  }
  function Yo(Lr) {
    var jr = Lr.pmViewDesc;
    return jr && jr.node && jr.node.isBlock;
  }
  function xl(Lr, jr) {
    for (; Lr && jr == Lr.childNodes.length && !ei(Lr); )
      jr = Mr(Lr) + 1, Lr = Lr.parentNode;
    for (; Lr && jr < Lr.childNodes.length; ) {
      var Rr = Lr.childNodes[jr];
      if (Rr.nodeType == 3)
        return Rr;
      if (Rr.nodeType == 1 && Rr.contentEditable == "false")
        break;
      Lr = Rr, jr = 0;
    }
  }
  function Ks(Lr, jr) {
    for (; Lr && !jr && !ei(Lr); )
      jr = Mr(Lr), Lr = Lr.parentNode;
    for (; Lr && jr; ) {
      var Rr = Lr.childNodes[jr - 1];
      if (Rr.nodeType == 3)
        return Rr;
      if (Rr.nodeType == 1 && Rr.contentEditable == "false")
        break;
      Lr = Rr, jr = Lr.childNodes.length;
    }
  }
  function Ms(Lr, jr, Rr) {
    if (jr.nodeType != 3) {
      var Fr, Vr;
      (Vr = xl(jr, Rr)) ? (jr = Vr, Rr = 0) : (Fr = Ks(jr, Rr)) && (jr = Fr, Rr = Fr.nodeValue.length);
    }
    var Wr = Lr.domSelection();
    if (ui(Wr)) {
      var ri = document.createRange();
      ri.setEnd(jr, Rr), ri.setStart(jr, Rr), Wr.removeAllRanges(), Wr.addRange(ri);
    } else
      Wr.extend && Wr.extend(jr, Rr);
    Lr.domObserver.setCurSelection();
    var ai = Lr.state;
    setTimeout(function() {
      Lr.state == ai && Ho(Lr);
    }, 50);
  }
  function Gs(Lr, jr) {
    var Rr = Lr.state.doc.resolve(jr);
    if (!(Ni || Vi) && Rr.parent.inlineContent) {
      var Fr = Lr.coordsAtPos(jr);
      if (jr > Rr.start()) {
        var Vr = Lr.coordsAtPos(jr - 1), Wr = (Vr.top + Vr.bottom) / 2;
        if (Wr > Fr.top && Wr < Fr.bottom && Math.abs(Vr.left - Fr.left) > 1)
          return Vr.left < Fr.left ? "ltr" : "rtl";
      }
      if (jr < Rr.end()) {
        var ri = Lr.coordsAtPos(jr + 1), ai = (ri.top + ri.bottom) / 2;
        if (ai > Fr.top && ai < Fr.bottom && Math.abs(ri.left - Fr.left) > 1)
          return ri.left > Fr.left ? "ltr" : "rtl";
      }
    }
    var hi = getComputedStyle(Lr.dom).direction;
    return hi == "rtl" ? "rtl" : "ltr";
  }
  function bs(Lr, jr, Rr) {
    var Fr = Lr.state.selection;
    if (Fr instanceof Tr.TextSelection && !Fr.empty || Rr.indexOf("s") > -1 || Si && Rr.indexOf("m") > -1)
      return !1;
    var Vr = Fr.$from, Wr = Fr.$to;
    if (!Vr.parent.inlineContent || Lr.endOfTextblock(jr < 0 ? "up" : "down")) {
      var ri = gs(Lr.state, jr);
      if (ri && ri instanceof Tr.NodeSelection)
        return To(Lr, ri);
    }
    if (!Vr.parent.inlineContent) {
      var ai = jr < 0 ? Vr : Wr, hi = Fr instanceof Tr.AllSelection ? Tr.Selection.near(ai, jr) : Tr.Selection.findFrom(ai, jr);
      return hi ? To(Lr, hi) : !1;
    }
    return !1;
  }
  function Ns(Lr, jr) {
    if (!(Lr.state.selection instanceof Tr.TextSelection))
      return !0;
    var Rr = Lr.state.selection, Fr = Rr.$head, Vr = Rr.$anchor, Wr = Rr.empty;
    if (!Fr.sameParent(Vr))
      return !0;
    if (!Wr)
      return !1;
    if (Lr.endOfTextblock(jr > 0 ? "forward" : "backward"))
      return !0;
    var ri = !Fr.textOffset && (jr < 0 ? Fr.nodeBefore : Fr.nodeAfter);
    if (ri && !ri.isText) {
      var ai = Lr.state.tr;
      return jr < 0 ? ai.delete(Fr.pos - ri.nodeSize, Fr.pos) : ai.delete(Fr.pos, Fr.pos + ri.nodeSize), Lr.dispatch(ai), !0;
    }
    return !1;
  }
  function cl(Lr, jr, Rr) {
    Lr.domObserver.stop(), jr.contentEditable = Rr, Lr.domObserver.start();
  }
  function Fo(Lr) {
    if (!bi || Lr.state.selection.$head.parentOffset > 0)
      return !1;
    var jr = Lr.domSelectionRange(), Rr = jr.focusNode, Fr = jr.focusOffset;
    if (Rr && Rr.nodeType == 1 && Fr == 0 && Rr.firstChild && Rr.firstChild.contentEditable == "false") {
      var Vr = Rr.firstChild;
      cl(Lr, Vr, "true"), setTimeout(function() {
        return cl(Lr, Vr, "false");
      }, 20);
    }
    return !1;
  }
  function ul(Lr) {
    var jr = "";
    return Lr.ctrlKey && (jr += "c"), Lr.metaKey && (jr += "m"), Lr.altKey && (jr += "a"), Lr.shiftKey && (jr += "s"), jr;
  }
  function fl(Lr, jr) {
    var Rr = jr.keyCode, Fr = ul(jr);
    if (Rr == 8 || Si && Rr == 72 && Fr == "c")
      return Ns(Lr, -1) || ss(Lr, -1);
    if (Rr == 46 && !jr.shiftKey || Si && Rr == 68 && Fr == "c")
      return Ns(Lr, 1) || ss(Lr, 1);
    if (Rr == 13 || Rr == 27)
      return !0;
    if (Rr == 37 || Si && Rr == 66 && Fr == "c") {
      var Vr = Rr == 37 ? Gs(Lr, Lr.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return vs(Lr, Vr, Fr) || ss(Lr, Vr);
    } else if (Rr == 39 || Si && Rr == 70 && Fr == "c") {
      var Wr = Rr == 39 ? Gs(Lr, Lr.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return vs(Lr, Wr, Fr) || ss(Lr, Wr);
    } else {
      if (Rr == 38 || Si && Rr == 80 && Fr == "c")
        return bs(Lr, -1, Fr) || ss(Lr, -1);
      if (Rr == 40 || Si && Rr == 78 && Fr == "c")
        return Fo(Lr) || bs(Lr, 1, Fr) || ss(Lr, 1);
      if (Fr == (Si ? "m" : "c") && (Rr == 66 || Rr == 73 || Rr == 89 || Rr == 90))
        return !0;
    }
    return !1;
  }
  function Os(Lr, jr) {
    Lr.someProp("transformCopied", function(ha) {
      jr = ha(jr, Lr);
    });
    for (var Rr = [], Fr = jr, Vr = Fr.content, Wr = Fr.openStart, ri = Fr.openEnd; Wr > 1 && ri > 1 && Vr.childCount == 1 && Vr.firstChild.childCount == 1; ) {
      Wr--, ri--;
      var ai = Vr.firstChild;
      Rr.push(ai.type.name, ai.attrs != ai.type.defaultAttrs ? ai.attrs : null), Vr = ai.content;
    }
    var hi = Lr.someProp("clipboardSerializer") || Ar.DOMSerializer.fromSchema(Lr.state.schema), wi = Ra(), Oi = wi.createElement("div");
    Oi.appendChild(hi.serializeFragment(Vr, {
      document: wi
    }));
    for (var Wi = Oi.firstChild, zi, Qi = 0; Wi && Wi.nodeType == 1 && (zi = Zi[Wi.nodeName.toLowerCase()]); ) {
      for (var ia = zi.length - 1; ia >= 0; ia--) {
        for (var Ta = wi.createElement(zi[ia]); Oi.firstChild; )
          Ta.appendChild(Oi.firstChild);
        Oi.appendChild(Ta), Qi++;
      }
      Wi = Oi.firstChild;
    }
    Wi && Wi.nodeType == 1 && Wi.setAttribute("data-pm-slice", "".concat(Wr, " ").concat(ri).concat(Qi ? " -".concat(Qi) : "", " ").concat(JSON.stringify(Rr)));
    var Da = Lr.someProp("clipboardTextSerializer", function(ha) {
      return ha(jr, Lr);
    }) || jr.content.textBetween(0, jr.content.size, `

`);
    return {
      dom: Oi,
      text: Da
    };
  }
  function Ws(Lr, jr, Rr, Fr, Vr) {
    var Wr = Vr.parent.type.spec.code, ri, ai;
    if (!Rr && !jr)
      return null;
    var hi = jr && (Fr || Wr || !Rr);
    if (hi) {
      if (Lr.someProp("transformPastedText", function(eo) {
        jr = eo(jr, Wr || Fr, Lr);
      }), Wr)
        return jr ? new Ar.Slice(Ar.Fragment.from(Lr.state.schema.text(jr.replace(/\r\n?/g, `
`))), 0, 0) : Ar.Slice.empty;
      var wi = Lr.someProp("clipboardTextParser", function(eo) {
        return eo(jr, Vr, Fr, Lr);
      });
      if (wi)
        ai = wi;
      else {
        var Oi = Vr.marks(), Wi = Lr.state.schema, zi = Ar.DOMSerializer.fromSchema(Wi);
        ri = document.createElement("div"), jr.split(/(?:\r\n?|\n)+/).forEach(function(eo) {
          var mo = ri.appendChild(document.createElement("p"));
          eo && mo.appendChild(zi.serializeNode(Wi.text(eo, Oi)));
        });
      }
    } else
      Lr.someProp("transformPastedHTML", function(eo) {
        Rr = eo(Rr, Lr);
      }), ri = io(Rr), sa && wo(ri);
    var Qi = ri && ri.querySelector("[data-pm-slice]"), ia = Qi && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(Qi.getAttribute("data-pm-slice") || "");
    if (ia && ia[3])
      for (var Ta = +ia[3]; Ta > 0; Ta--) {
        for (var Da = ri.firstChild; Da && Da.nodeType != 1; )
          Da = Da.nextSibling;
        if (!Da)
          break;
        ri = Da;
      }
    if (!ai) {
      var ha = Lr.someProp("clipboardParser") || Lr.someProp("domParser") || Ar.DOMParser.fromSchema(Lr.state.schema);
      ai = ha.parseSlice(ri, {
        preserveWhitespace: !!(hi || ia),
        context: Vr,
        ruleFromNode: function(mo) {
          return mo.nodeName == "BR" && !mo.nextSibling && mo.parentNode && !ys.test(mo.parentNode.nodeName) ? {
            ignore: !0
          } : null;
        }
      });
    }
    if (ia)
      ai = xo(Ba(ai, +ia[1], +ia[2]), ia[4]);
    else if (ai = Ar.Slice.maxOpen(qo(ai.content, Vr), !0), ai.openStart || ai.openEnd) {
      for (var co = 0, Xa = 0, ao = ai.content.firstChild; co < ai.openStart && !ao.type.spec.isolating; co++, ao = ao.firstChild)
        ;
      for (var Wa = ai.content.lastChild; Xa < ai.openEnd && !Wa.type.spec.isolating; Xa++, Wa = Wa.lastChild)
        ;
      ai = Ba(ai, co, Xa);
    }
    return Lr.someProp("transformPasted", function(eo) {
      ai = eo(ai, Lr);
    }), ai;
  }
  var ys = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function qo(Lr, jr) {
    if (Lr.childCount < 2)
      return Lr;
    for (var Rr = function(ri) {
      var ai = jr.node(ri), hi = ai.contentMatchAt(jr.index(ri)), wi = void 0, Oi = [];
      if (Lr.forEach(function(Wi) {
        if (Oi) {
          var zi = hi.findWrapping(Wi.type), Qi;
          if (!zi)
            return Oi = null;
          if (Qi = Oi.length && wi.length && Xs(zi, wi, Wi, Oi[Oi.length - 1], 0))
            Oi[Oi.length - 1] = Qi;
          else {
            Oi.length && (Oi[Oi.length - 1] = Js(Oi[Oi.length - 1], wi.length));
            var ia = Zs(Wi, zi);
            Oi.push(ia), hi = hi.matchType(ia.type), wi = zi;
          }
        }
      }), Oi)
        return {
          v: Ar.Fragment.from(Oi)
        };
    }, Fr = jr.depth; Fr >= 0; Fr--) {
      var Vr = Rr(Fr);
      if (lr(Vr) === "object")
        return Vr.v;
    }
    return Lr;
  }
  function Zs(Lr, jr) {
    for (var Rr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, Fr = jr.length - 1; Fr >= Rr; Fr--)
      Lr = jr[Fr].create(null, Ar.Fragment.from(Lr));
    return Lr;
  }
  function Xs(Lr, jr, Rr, Fr, Vr) {
    if (Vr < Lr.length && Vr < jr.length && Lr[Vr] == jr[Vr]) {
      var Wr = Xs(Lr, jr, Rr, Fr.lastChild, Vr + 1);
      if (Wr)
        return Fr.copy(Fr.content.replaceChild(Fr.childCount - 1, Wr));
      var ri = Fr.contentMatchAt(Fr.childCount);
      if (ri.matchType(Vr == Lr.length - 1 ? Rr.type : Lr[Vr + 1]))
        return Fr.copy(Fr.content.append(Ar.Fragment.from(Zs(Rr, Lr, Vr + 1))));
    }
  }
  function Js(Lr, jr) {
    if (jr == 0)
      return Lr;
    var Rr = Lr.content.replaceChild(Lr.childCount - 1, Js(Lr.lastChild, jr - 1)), Fr = Lr.contentMatchAt(Lr.childCount).fillBefore(Ar.Fragment.empty, !0);
    return Lr.copy(Rr.append(Fr));
  }
  function Ys(Lr, jr, Rr, Fr, Vr, Wr) {
    var ri = jr < 0 ? Lr.firstChild : Lr.lastChild, ai = ri.content;
    return Lr.childCount > 1 && (Wr = 0), Vr < Fr - 1 && (ai = Ys(ai, jr, Rr, Fr, Vr + 1, Wr)), Vr >= Rr && (ai = jr < 0 ? ri.contentMatchAt(0).fillBefore(ai, Wr <= Vr).append(ai) : ai.append(ri.contentMatchAt(ri.childCount).fillBefore(Ar.Fragment.empty, !0))), Lr.replaceChild(jr < 0 ? 0 : Lr.childCount - 1, ri.copy(ai));
  }
  function Ba(Lr, jr, Rr) {
    return jr < Lr.openStart && (Lr = new Ar.Slice(Ys(Lr.content, -1, jr, Lr.openStart, 0, Lr.openEnd), jr, Lr.openEnd)), Rr < Lr.openEnd && (Lr = new Ar.Slice(Ys(Lr.content, 1, Rr, Lr.openEnd, 0, 0), Lr.openStart, Rr)), Lr;
  }
  var Zi = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  }, ya = null;
  function Ra() {
    return ya || (ya = document.implementation.createHTMLDocument("title"));
  }
  function io(Lr) {
    var jr = /^(\s*<meta [^>]*>)*/.exec(Lr);
    jr && (Lr = Lr.slice(jr[0].length));
    var Rr = Ra().createElement("div"), Fr = /<([a-z][^>\s]+)/i.exec(Lr), Vr;
    if ((Vr = Fr && Zi[Fr[1].toLowerCase()]) && (Lr = Vr.map(function(ri) {
      return "<" + ri + ">";
    }).join("") + Lr + Vr.map(function(ri) {
      return "</" + ri + ">";
    }).reverse().join("")), Rr.innerHTML = Lr, Vr)
      for (var Wr = 0; Wr < Vr.length; Wr++)
        Rr = Rr.querySelector(Vr[Wr]) || Rr;
    return Rr;
  }
  function wo(Lr) {
    for (var jr = Lr.querySelectorAll(Ni ? "span:not([class]):not([style])" : "span.Apple-converted-space"), Rr = 0; Rr < jr.length; Rr++) {
      var Fr = jr[Rr];
      Fr.childNodes.length == 1 && Fr.textContent == " " && Fr.parentNode && Fr.parentNode.replaceChild(Lr.ownerDocument.createTextNode(" "), Fr);
    }
  }
  function xo(Lr, jr) {
    if (!Lr.size)
      return Lr;
    var Rr = Lr.content.firstChild.type.schema, Fr;
    try {
      Fr = JSON.parse(jr);
    } catch (wi) {
      return Lr;
    }
    for (var Vr = Lr.content, Wr = Lr.openStart, ri = Lr.openEnd, ai = Fr.length - 2; ai >= 0; ai -= 2) {
      var hi = Rr.nodes[Fr[ai]];
      if (!hi || hi.hasRequiredAttrs())
        break;
      Vr = Ar.Fragment.from(hi.create(Fr[ai + 1], Vr)), Wr++, ri++;
    }
    return new Ar.Slice(Vr, Wr, ri);
  }
  var ro = {}, po = {}, ks = {
    touchstart: !0,
    touchmove: !0
  }, dl = Cr(function Lr() {
    Sr(this, Lr), this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = {
      time: 0,
      x: 0,
      y: 0,
      type: ""
    }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  });
  function El(Lr) {
    var jr = function(Vr) {
      var Wr = ro[Vr];
      Lr.dom.addEventListener(Vr, Lr.input.eventHandlers[Vr] = function(ri) {
        Rc(Lr, ri) && !Tl(Lr, ri) && (Lr.editable || !(ri.type in po)) && Wr(Lr, ri);
      }, ks[Vr] ? {
        passive: !0
      } : void 0);
    };
    for (var Rr in ro)
      jr(Rr);
    bi && Lr.dom.addEventListener("input", function() {
      return null;
    }), Cl(Lr);
  }
  function Qo(Lr, jr) {
    Lr.input.lastSelectionOrigin = jr, Lr.input.lastSelectionTime = Date.now();
  }
  function Lc(Lr) {
    Lr.domObserver.stop();
    for (var jr in Lr.input.eventHandlers)
      Lr.dom.removeEventListener(jr, Lr.input.eventHandlers[jr]);
    clearTimeout(Lr.input.composingTimeout), clearTimeout(Lr.input.lastIOSEnterFallbackTimeout);
  }
  function Cl(Lr) {
    Lr.someProp("handleDOMEvents", function(jr) {
      for (var Rr in jr)
        Lr.input.eventHandlers[Rr] || Lr.dom.addEventListener(Rr, Lr.input.eventHandlers[Rr] = function(Fr) {
          return Tl(Lr, Fr);
        });
    });
  }
  function Tl(Lr, jr) {
    return Lr.someProp("handleDOMEvents", function(Rr) {
      var Fr = Rr[jr.type];
      return Fr ? Fr(Lr, jr) || jr.defaultPrevented : !1;
    });
  }
  function Rc(Lr, jr) {
    if (!jr.bubbles)
      return !0;
    if (jr.defaultPrevented)
      return !1;
    for (var Rr = jr.target; Rr != Lr.dom; Rr = Rr.parentNode)
      if (!Rr || Rr.nodeType == 11 || Rr.pmViewDesc && Rr.pmViewDesc.stopEvent(jr))
        return !1;
    return !0;
  }
  function Mc(Lr, jr) {
    !Tl(Lr, jr) && ro[jr.type] && (Lr.editable || !(jr.type in po)) && ro[jr.type](Lr, jr);
  }
  po.keydown = function(Lr, jr) {
    var Rr = jr;
    if (Lr.input.shiftKey = Rr.keyCode == 16 || Rr.shiftKey, !Ul(Lr, Rr) && (Lr.input.lastKeyCode = Rr.keyCode, Lr.input.lastKeyCodeTime = Date.now(), !(Di && Ni && Rr.keyCode == 13)))
      if (Rr.keyCode != 229 && Lr.domObserver.forceFlush(), Ei && Rr.keyCode == 13 && !Rr.ctrlKey && !Rr.altKey && !Rr.metaKey) {
        var Fr = Date.now();
        Lr.input.lastIOSEnter = Fr, Lr.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          Lr.input.lastIOSEnter == Fr && (Lr.someProp("handleKeyDown", function(Vr) {
            return Vr(Lr, Ai(13, "Enter"));
          }), Lr.input.lastIOSEnter = 0);
        }, 200);
      } else
        Lr.someProp("handleKeyDown", function(Vr) {
          return Vr(Lr, Rr);
        }) || fl(Lr, Rr) ? Rr.preventDefault() : Qo(Lr, "key");
  }, po.keyup = function(Lr, jr) {
    jr.keyCode == 16 && (Lr.input.shiftKey = !1);
  }, po.keypress = function(Lr, jr) {
    var Rr = jr;
    if (!(Ul(Lr, Rr) || !Rr.charCode || Rr.ctrlKey && !Rr.altKey || Si && Rr.metaKey)) {
      if (Lr.someProp("handleKeyPress", function(Wr) {
        return Wr(Lr, Rr);
      })) {
        Rr.preventDefault();
        return;
      }
      var Fr = Lr.state.selection;
      if (!(Fr instanceof Tr.TextSelection) || !Fr.$from.sameParent(Fr.$to)) {
        var Vr = String.fromCharCode(Rr.charCode);
        !/[\r\n]/.test(Vr) && !Lr.someProp("handleTextInput", function(Wr) {
          return Wr(Lr, Fr.$from.pos, Fr.$to.pos, Vr);
        }) && Lr.dispatch(Lr.state.tr.insertText(Vr).scrollIntoView()), Rr.preventDefault();
      }
    }
  };
  function hl(Lr) {
    return {
      left: Lr.clientX,
      top: Lr.clientY
    };
  }
  function Nc(Lr, jr) {
    var Rr = jr.x - Lr.clientX, Fr = jr.y - Lr.clientY;
    return Rr * Rr + Fr * Fr < 100;
  }
  function Al(Lr, jr, Rr, Fr, Vr) {
    if (Fr == -1)
      return !1;
    for (var Wr = Lr.state.doc.resolve(Fr), ri = function(Oi) {
      if (Lr.someProp(jr, function(Wi) {
        return Oi > Wr.depth ? Wi(Lr, Rr, Wr.nodeAfter, Wr.before(Oi), Vr, !0) : Wi(Lr, Rr, Wr.node(Oi), Wr.before(Oi), Vr, !1);
      }))
        return {
          v: !0
        };
    }, ai = Wr.depth + 1; ai > 0; ai--) {
      var hi = ri(ai);
      if (lr(hi) === "object")
        return hi.v;
    }
    return !1;
  }
  function Ds(Lr, jr, Rr) {
    Lr.focused || Lr.focus();
    var Fr = Lr.state.tr.setSelection(jr);
    Rr == "pointer" && Fr.setMeta("pointer", !0), Lr.dispatch(Fr);
  }
  function Oc(Lr, jr) {
    if (jr == -1)
      return !1;
    var Rr = Lr.state.doc.resolve(jr), Fr = Rr.nodeAfter;
    return Fr && Fr.isAtom && Tr.NodeSelection.isSelectable(Fr) ? (Ds(Lr, new Tr.NodeSelection(Rr), "pointer"), !0) : !1;
  }
  function Dc(Lr, jr) {
    if (jr == -1)
      return !1;
    var Rr = Lr.state.selection, Fr, Vr;
    Rr instanceof Tr.NodeSelection && (Fr = Rr.node);
    for (var Wr = Lr.state.doc.resolve(jr), ri = Wr.depth + 1; ri > 0; ri--) {
      var ai = ri > Wr.depth ? Wr.nodeAfter : Wr.node(ri);
      if (Tr.NodeSelection.isSelectable(ai)) {
        Fr && Rr.$from.depth > 0 && ri >= Rr.$from.depth && Wr.before(Rr.$from.depth + 1) == Rr.$from.pos ? Vr = Wr.before(Rr.$from.depth) : Vr = Wr.before(ri);
        break;
      }
    }
    return Vr != null ? (Ds(Lr, Tr.NodeSelection.create(Lr.state.doc, Vr), "pointer"), !0) : !1;
  }
  function Bc(Lr, jr, Rr, Fr, Vr) {
    return Al(Lr, "handleClickOn", jr, Rr, Fr) || Lr.someProp("handleClick", function(Wr) {
      return Wr(Lr, jr, Fr);
    }) || (Vr ? Dc(Lr, Rr) : Oc(Lr, Rr));
  }
  function Pc(Lr, jr, Rr, Fr) {
    return Al(Lr, "handleDoubleClickOn", jr, Rr, Fr) || Lr.someProp("handleDoubleClick", function(Vr) {
      return Vr(Lr, jr, Fr);
    });
  }
  function Hc(Lr, jr, Rr, Fr) {
    return Al(Lr, "handleTripleClickOn", jr, Rr, Fr) || Lr.someProp("handleTripleClick", function(Vr) {
      return Vr(Lr, jr, Fr);
    }) || Uc(Lr, Rr, Fr);
  }
  function Uc(Lr, jr, Rr) {
    if (Rr.button != 0)
      return !1;
    var Fr = Lr.state.doc;
    if (jr == -1)
      return Fr.inlineContent ? (Ds(Lr, Tr.TextSelection.create(Fr, 0, Fr.content.size), "pointer"), !0) : !1;
    for (var Vr = Fr.resolve(jr), Wr = Vr.depth + 1; Wr > 0; Wr--) {
      var ri = Wr > Vr.depth ? Vr.nodeAfter : Vr.node(Wr), ai = Vr.before(Wr);
      if (ri.inlineContent)
        Ds(Lr, Tr.TextSelection.create(Fr, ai + 1, ai + 1 + ri.content.size), "pointer");
      else if (Tr.NodeSelection.isSelectable(ri))
        Ds(Lr, Tr.NodeSelection.create(Fr, ai), "pointer");
      else
        continue;
      return !0;
    }
  }
  function Sl(Lr) {
    return Qs(Lr);
  }
  var Hl = Si ? "metaKey" : "ctrlKey";
  ro.mousedown = function(Lr, jr) {
    var Rr = jr;
    Lr.input.shiftKey = Rr.shiftKey;
    var Fr = Sl(Lr), Vr = Date.now(), Wr = "singleClick";
    Vr - Lr.input.lastClick.time < 500 && Nc(Rr, Lr.input.lastClick) && !Rr[Hl] && (Lr.input.lastClick.type == "singleClick" ? Wr = "doubleClick" : Lr.input.lastClick.type == "doubleClick" && (Wr = "tripleClick")), Lr.input.lastClick = {
      time: Vr,
      x: Rr.clientX,
      y: Rr.clientY,
      type: Wr
    };
    var ri = Lr.posAtCoords(hl(Rr));
    ri && (Wr == "singleClick" ? (Lr.input.mouseDown && Lr.input.mouseDown.done(), Lr.input.mouseDown = new zc(Lr, ri, Rr, !!Fr)) : (Wr == "doubleClick" ? Pc : Hc)(Lr, ri.pos, ri.inside, Rr) ? Rr.preventDefault() : Qo(Lr, "pointer"));
  };
  var zc = function() {
    function Lr(jr, Rr, Fr, Vr) {
      var Wr = this;
      Sr(this, Lr), this.view = jr, this.pos = Rr, this.event = Fr, this.flushed = Vr, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = jr.state.doc, this.selectNode = !!Fr[Hl], this.allowDefault = Fr.shiftKey;
      var ri, ai;
      if (Rr.inside > -1)
        ri = jr.state.doc.nodeAt(Rr.inside), ai = Rr.inside;
      else {
        var hi = jr.state.doc.resolve(Rr.pos);
        ri = hi.parent, ai = hi.depth ? hi.before() : 0;
      }
      var wi = Vr ? null : Fr.target, Oi = wi ? jr.docView.nearestDesc(wi, !0) : null;
      this.target = Oi ? Oi.dom : null;
      var Wi = jr.state.selection;
      (Fr.button == 0 && ri.type.spec.draggable && ri.type.spec.selectable !== !1 || Wi instanceof Tr.NodeSelection && Wi.from <= ai && Wi.to > ai) && (this.mightDrag = {
        node: ri,
        pos: ai,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && Ji && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(function() {
        Wr.view.input.mouseDown == Wr && Wr.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), jr.root.addEventListener("mouseup", this.up = this.up.bind(this)), jr.root.addEventListener("mousemove", this.move = this.move.bind(this)), Qo(jr, "pointer");
    }
    return Cr(Lr, [{
      key: "done",
      value: function() {
        var Rr = this;
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(function() {
          return Ho(Rr.view);
        }), this.view.input.mouseDown = null;
      }
    }, {
      key: "up",
      value: function(Rr) {
        if (this.done(), !!this.view.dom.contains(Rr.target)) {
          var Fr = this.pos;
          this.view.state.doc != this.startDoc && (Fr = this.view.posAtCoords(hl(Rr))), this.updateAllowDefault(Rr), this.allowDefault || !Fr ? Qo(this.view, "pointer") : Bc(this.view, Fr.pos, Fr.inside, Rr, this.selectNode) ? Rr.preventDefault() : Rr.button == 0 && (this.flushed || bi && this.mightDrag && !this.mightDrag.node.isAtom || Ni && !this.view.state.selection.visible && Math.min(Math.abs(Fr.pos - this.view.state.selection.from), Math.abs(Fr.pos - this.view.state.selection.to)) <= 2) ? (Ds(this.view, Tr.Selection.near(this.view.state.doc.resolve(Fr.pos)), "pointer"), Rr.preventDefault()) : Qo(this.view, "pointer");
        }
      }
    }, {
      key: "move",
      value: function(Rr) {
        this.updateAllowDefault(Rr), Qo(this.view, "pointer"), Rr.buttons == 0 && this.done();
      }
    }, {
      key: "updateAllowDefault",
      value: function(Rr) {
        !this.allowDefault && (Math.abs(this.event.x - Rr.clientX) > 4 || Math.abs(this.event.y - Rr.clientY) > 4) && (this.allowDefault = !0);
      }
    }]), Lr;
  }();
  ro.touchstart = function(Lr) {
    Lr.input.lastTouch = Date.now(), Sl(Lr), Qo(Lr, "pointer");
  }, ro.touchmove = function(Lr) {
    Lr.input.lastTouch = Date.now(), Qo(Lr, "pointer");
  }, ro.contextmenu = function(Lr) {
    return Sl(Lr);
  };
  function Ul(Lr, jr) {
    return Lr.composing ? !0 : bi && Math.abs(jr.timeStamp - Lr.input.compositionEndedAt) < 500 ? (Lr.input.compositionEndedAt = -2e8, !0) : !1;
  }
  var Fc = Di ? 5e3 : -1;
  po.compositionstart = po.compositionupdate = function(Lr) {
    if (!Lr.composing) {
      Lr.domObserver.flush();
      var jr = Lr.state, Rr = jr.selection.$from;
      if (jr.selection.empty && (jr.storedMarks || !Rr.textOffset && Rr.parentOffset && Rr.nodeBefore.marks.some(function(ai) {
        return ai.type.spec.inclusive === !1;
      })))
        Lr.markCursor = Lr.state.storedMarks || Rr.marks(), Qs(Lr, !0), Lr.markCursor = null;
      else if (Qs(Lr), Ji && jr.selection.empty && Rr.parentOffset && !Rr.textOffset && Rr.nodeBefore.marks.length)
        for (var Fr = Lr.domSelectionRange(), Vr = Fr.focusNode, Wr = Fr.focusOffset; Vr && Vr.nodeType == 1 && Wr != 0; ) {
          var ri = Wr < 0 ? Vr.lastChild : Vr.childNodes[Wr - 1];
          if (!ri)
            break;
          if (ri.nodeType == 3) {
            Lr.domSelection().collapse(ri, ri.nodeValue.length);
            break;
          } else
            Vr = ri, Wr = -1;
        }
      Lr.input.composing = !0;
    }
    zl(Lr, Fc);
  }, po.compositionend = function(Lr, jr) {
    Lr.composing && (Lr.input.composing = !1, Lr.input.compositionEndedAt = jr.timeStamp, Lr.input.compositionPendingChanges = Lr.domObserver.pendingRecords().length ? Lr.input.compositionID : 0, Lr.input.compositionPendingChanges && Promise.resolve().then(function() {
      return Lr.domObserver.flush();
    }), Lr.input.compositionID++, zl(Lr, 20));
  };
  function zl(Lr, jr) {
    clearTimeout(Lr.input.composingTimeout), jr > -1 && (Lr.input.composingTimeout = setTimeout(function() {
      return Qs(Lr);
    }, jr));
  }
  function Fl(Lr) {
    for (Lr.composing && (Lr.input.composing = !1, Lr.input.compositionEndedAt = qc()); Lr.input.compositionNodes.length > 0; )
      Lr.input.compositionNodes.pop().markParentsDirty();
  }
  function qc() {
    var Lr = document.createEvent("Event");
    return Lr.initEvent("event", !0, !0), Lr.timeStamp;
  }
  function Qs(Lr) {
    var jr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!(Di && Lr.domObserver.flushingSoon >= 0)) {
      if (Lr.domObserver.forceFlush(), Fl(Lr), jr || Lr.docView && Lr.docView.dirty) {
        var Rr = Po(Lr);
        return Rr && !Rr.eq(Lr.state.selection) ? Lr.dispatch(Lr.state.tr.setSelection(Rr)) : Lr.updateState(Lr.state), !0;
      }
      return !1;
    }
  }
  function jc(Lr, jr) {
    if (Lr.dom.parentNode) {
      var Rr = Lr.dom.parentNode.appendChild(document.createElement("div"));
      Rr.appendChild(jr), Rr.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var Fr = getSelection(), Vr = document.createRange();
      Vr.selectNodeContents(jr), Lr.dom.blur(), Fr.removeAllRanges(), Fr.addRange(Vr), setTimeout(function() {
        Rr.parentNode && Rr.parentNode.removeChild(Rr), Lr.focus();
      }, 50);
    }
  }
  var tl = qi && ki < 15 || Ei && ra < 604;
  ro.copy = po.cut = function(Lr, jr) {
    var Rr = jr, Fr = Lr.state.selection, Vr = Rr.type == "cut";
    if (!Fr.empty) {
      var Wr = tl ? null : Rr.clipboardData, ri = Fr.content(), ai = Os(Lr, ri), hi = ai.dom, wi = ai.text;
      Wr ? (Rr.preventDefault(), Wr.clearData(), Wr.setData("text/html", hi.innerHTML), Wr.setData("text/plain", wi)) : jc(Lr, hi), Vr && Lr.dispatch(Lr.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  };
  function $c(Lr) {
    return Lr.openStart == 0 && Lr.openEnd == 0 && Lr.content.childCount == 1 ? Lr.content.firstChild : null;
  }
  function Vc(Lr, jr) {
    if (Lr.dom.parentNode) {
      var Rr = Lr.input.shiftKey || Lr.state.selection.$from.parent.type.spec.code, Fr = Lr.dom.parentNode.appendChild(document.createElement(Rr ? "textarea" : "div"));
      Rr || (Fr.contentEditable = "true"), Fr.style.cssText = "position: fixed; left: -10000px; top: 10px", Fr.focus();
      var Vr = Lr.input.shiftKey && Lr.input.lastKeyCode != 45;
      setTimeout(function() {
        Lr.focus(), Fr.parentNode && Fr.parentNode.removeChild(Fr), Rr ? rl(Lr, Fr.value, null, Vr, jr) : rl(Lr, Fr.textContent, Fr.innerHTML, Vr, jr);
      }, 50);
    }
  }
  function rl(Lr, jr, Rr, Fr, Vr) {
    var Wr = Ws(Lr, jr, Rr, Fr, Lr.state.selection.$from);
    if (Lr.someProp("handlePaste", function(hi) {
      return hi(Lr, Vr, Wr || Ar.Slice.empty);
    }))
      return !0;
    if (!Wr)
      return !1;
    var ri = $c(Wr), ai = ri ? Lr.state.tr.replaceSelectionWith(ri, Fr) : Lr.state.tr.replaceSelection(Wr);
    return Lr.dispatch(ai.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
  }
  function ql(Lr) {
    var jr = Lr.getData("text/plain") || Lr.getData("Text");
    if (jr)
      return jr;
    var Rr = Lr.getData("text/uri-list");
    return Rr ? Rr.replace(/\r?\n/g, " ") : "";
  }
  po.paste = function(Lr, jr) {
    var Rr = jr;
    if (!(Lr.composing && !Di)) {
      var Fr = tl ? null : Rr.clipboardData, Vr = Lr.input.shiftKey && Lr.input.lastKeyCode != 45;
      Fr && rl(Lr, ql(Fr), Fr.getData("text/html"), Vr, Rr) ? Rr.preventDefault() : Vc(Lr, Rr);
    }
  };
  var jl = Cr(function Lr(jr, Rr, Fr) {
    Sr(this, Lr), this.slice = jr, this.move = Rr, this.node = Fr;
  }), $l = Si ? "altKey" : "ctrlKey";
  ro.dragstart = function(Lr, jr) {
    var Rr = jr, Fr = Lr.input.mouseDown;
    if (Fr && Fr.done(), !!Rr.dataTransfer) {
      var Vr = Lr.state.selection, Wr = Vr.empty ? null : Lr.posAtCoords(hl(Rr)), ri;
      if (!(Wr && Wr.pos >= Vr.from && Wr.pos <= (Vr instanceof Tr.NodeSelection ? Vr.to - 1 : Vr.to))) {
        if (Fr && Fr.mightDrag)
          ri = Tr.NodeSelection.create(Lr.state.doc, Fr.mightDrag.pos);
        else if (Rr.target && Rr.target.nodeType == 1) {
          var ai = Lr.docView.nearestDesc(Rr.target, !0);
          ai && ai.node.type.spec.draggable && ai != Lr.docView && (ri = Tr.NodeSelection.create(Lr.state.doc, ai.posBefore));
        }
      }
      var hi = (ri || Lr.state.selection).content(), wi = Os(Lr, hi), Oi = wi.dom, Wi = wi.text;
      Rr.dataTransfer.clearData(), Rr.dataTransfer.setData(tl ? "Text" : "text/html", Oi.innerHTML), Rr.dataTransfer.effectAllowed = "copyMove", tl || Rr.dataTransfer.setData("text/plain", Wi), Lr.dragging = new jl(hi, !Rr[$l], ri);
    }
  }, ro.dragend = function(Lr) {
    var jr = Lr.dragging;
    window.setTimeout(function() {
      Lr.dragging == jr && (Lr.dragging = null);
    }, 50);
  }, po.dragover = po.dragenter = function(Lr, jr) {
    return jr.preventDefault();
  }, po.drop = function(Lr, jr) {
    var Rr = jr, Fr = Lr.dragging;
    if (Lr.dragging = null, !!Rr.dataTransfer) {
      var Vr = Lr.posAtCoords(hl(Rr));
      if (Vr) {
        var Wr = Lr.state.doc.resolve(Vr.pos), ri = Fr && Fr.slice;
        ri ? Lr.someProp("transformPasted", function(Da) {
          ri = Da(ri, Lr);
        }) : ri = Ws(Lr, ql(Rr.dataTransfer), tl ? null : Rr.dataTransfer.getData("text/html"), !1, Wr);
        var ai = !!(Fr && !Rr[$l]);
        if (Lr.someProp("handleDrop", function(Da) {
          return Da(Lr, Rr, ri || Ar.Slice.empty, ai);
        })) {
          Rr.preventDefault();
          return;
        }
        if (ri) {
          Rr.preventDefault();
          var hi = ri ? Ir.dropPoint(Lr.state.doc, Wr.pos, ri) : Wr.pos;
          hi == null && (hi = Wr.pos);
          var wi = Lr.state.tr;
          if (ai) {
            var Oi = Fr.node;
            Oi ? Oi.replace(wi) : wi.deleteSelection();
          }
          var Wi = wi.mapping.map(hi), zi = ri.openStart == 0 && ri.openEnd == 0 && ri.content.childCount == 1, Qi = wi.doc;
          if (zi ? wi.replaceRangeWith(Wi, Wi, ri.content.firstChild) : wi.replaceRange(Wi, Wi, ri), !wi.doc.eq(Qi)) {
            var ia = wi.doc.resolve(Wi);
            if (zi && Tr.NodeSelection.isSelectable(ri.content.firstChild) && ia.nodeAfter && ia.nodeAfter.sameMarkup(ri.content.firstChild))
              wi.setSelection(new Tr.NodeSelection(ia));
            else {
              var Ta = wi.mapping.map(hi);
              wi.mapping.maps[wi.mapping.maps.length - 1].forEach(function(Da, ha, co, Xa) {
                return Ta = Xa;
              }), wi.setSelection(Ls(Lr, ia, wi.doc.resolve(Ta)));
            }
            Lr.focus(), Lr.dispatch(wi.setMeta("uiEvent", "drop"));
          }
        }
      }
    }
  }, ro.focus = function(Lr) {
    Lr.input.lastFocus = Date.now(), Lr.focused || (Lr.domObserver.stop(), Lr.dom.classList.add("ProseMirror-focused"), Lr.domObserver.start(), Lr.focused = !0, setTimeout(function() {
      Lr.docView && Lr.hasFocus() && !Lr.domObserver.currentSelection.eq(Lr.domSelectionRange()) && Ho(Lr);
    }, 20));
  }, ro.blur = function(Lr, jr) {
    var Rr = jr;
    Lr.focused && (Lr.domObserver.stop(), Lr.dom.classList.remove("ProseMirror-focused"), Lr.domObserver.start(), Rr.relatedTarget && Lr.dom.contains(Rr.relatedTarget) && Lr.domObserver.currentSelection.clear(), Lr.focused = !1);
  }, ro.beforeinput = function(Lr, jr) {
    var Rr = jr;
    if (Ni && Di && Rr.inputType == "deleteContentBackward") {
      Lr.domObserver.flushSoon();
      var Fr = Lr.input.domChangeCount;
      setTimeout(function() {
        if (Lr.input.domChangeCount == Fr && (Lr.dom.blur(), Lr.focus(), !Lr.someProp("handleKeyDown", function(Wr) {
          return Wr(Lr, Ai(8, "Backspace"));
        }))) {
          var Vr = Lr.state.selection.$cursor;
          Vr && Vr.pos > 0 && Lr.dispatch(Lr.state.tr.delete(Vr.pos - 1, Vr.pos).scrollIntoView());
        }
      }, 50);
    }
  };
  for (var Vl in po)
    ro[Vl] = po[Vl];
  function nl(Lr, jr) {
    if (Lr == jr)
      return !0;
    for (var Rr in Lr)
      if (Lr[Rr] !== jr[Rr])
        return !1;
    for (var Fr in jr)
      if (!(Fr in Lr))
        return !1;
    return !0;
  }
  var Gl = function() {
    function Lr(jr, Rr) {
      Sr(this, Lr), this.toDOM = jr, this.spec = Rr || ws, this.side = this.spec.side || 0;
    }
    return Cr(Lr, [{
      key: "map",
      value: function(Rr, Fr, Vr, Wr) {
        var ri = Rr.mapResult(Fr.from + Wr, this.side < 0 ? -1 : 1), ai = ri.pos, hi = ri.deleted;
        return hi ? null : new _s(ai - Vr, ai - Vr, this);
      }
    }, {
      key: "valid",
      value: function() {
        return !0;
      }
    }, {
      key: "eq",
      value: function(Rr) {
        return this == Rr || Rr instanceof Lr && (this.spec.key && this.spec.key == Rr.spec.key || this.toDOM == Rr.toDOM && nl(this.spec, Rr.spec));
      }
    }, {
      key: "destroy",
      value: function(Rr) {
        this.spec.destroy && this.spec.destroy(Rr);
      }
    }]), Lr;
  }(), il = function() {
    function Lr(jr, Rr) {
      Sr(this, Lr), this.attrs = jr, this.spec = Rr || ws;
    }
    return Cr(Lr, [{
      key: "map",
      value: function(Rr, Fr, Vr, Wr) {
        var ri = Rr.map(Fr.from + Wr, this.spec.inclusiveStart ? -1 : 1) - Vr, ai = Rr.map(Fr.to + Wr, this.spec.inclusiveEnd ? 1 : -1) - Vr;
        return ri >= ai ? null : new _s(ri, ai, this);
      }
    }, {
      key: "valid",
      value: function(Rr, Fr) {
        return Fr.from < Fr.to;
      }
    }, {
      key: "eq",
      value: function(Rr) {
        return this == Rr || Rr instanceof Lr && nl(this.attrs, Rr.attrs) && nl(this.spec, Rr.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }], [{
      key: "is",
      value: function(Rr) {
        return Rr.type instanceof Lr;
      }
    }]), Lr;
  }(), Kc = function() {
    function Lr(jr, Rr) {
      Sr(this, Lr), this.attrs = jr, this.spec = Rr || ws;
    }
    return Cr(Lr, [{
      key: "map",
      value: function(Rr, Fr, Vr, Wr) {
        var ri = Rr.mapResult(Fr.from + Wr, 1);
        if (ri.deleted)
          return null;
        var ai = Rr.mapResult(Fr.to + Wr, -1);
        return ai.deleted || ai.pos <= ri.pos ? null : new _s(ri.pos - Vr, ai.pos - Vr, this);
      }
    }, {
      key: "valid",
      value: function(Rr, Fr) {
        var Vr = Rr.content.findIndex(Fr.from), Wr = Vr.index, ri = Vr.offset, ai;
        return ri == Fr.from && !(ai = Rr.child(Wr)).isText && ri + ai.nodeSize == Fr.to;
      }
    }, {
      key: "eq",
      value: function(Rr) {
        return this == Rr || Rr instanceof Lr && nl(this.attrs, Rr.attrs) && nl(this.spec, Rr.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }]), Lr;
  }(), _s = function() {
    function Lr(jr, Rr, Fr) {
      Sr(this, Lr), this.from = jr, this.to = Rr, this.type = Fr;
    }
    return Cr(Lr, [{
      key: "copy",
      value: function(Rr, Fr) {
        return new Lr(Rr, Fr, this.type);
      }
    }, {
      key: "eq",
      value: function(Rr) {
        var Fr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.type.eq(Rr.type) && this.from + Fr == Rr.from && this.to + Fr == Rr.to;
      }
    }, {
      key: "map",
      value: function(Rr, Fr, Vr) {
        return this.type.map(Rr, this, Fr, Vr);
      }
    }, {
      key: "spec",
      get: function() {
        return this.type.spec;
      }
    }, {
      key: "inline",
      get: function() {
        return this.type instanceof il;
      }
    }, {
      key: "widget",
      get: function() {
        return this.type instanceof Gl;
      }
    }], [{
      key: "widget",
      value: function(Rr, Fr, Vr) {
        return new Lr(Rr, Rr, new Gl(Fr, Vr));
      }
    }, {
      key: "inline",
      value: function(Rr, Fr, Vr, Wr) {
        return new Lr(Rr, Fr, new il(Vr, Wr));
      }
    }, {
      key: "node",
      value: function(Rr, Fr, Vr, Wr) {
        return new Lr(Rr, Fr, new Kc(Vr, Wr));
      }
    }]), Lr;
  }(), Bs = [], ws = {}, jo = function() {
    function Lr(jr, Rr) {
      Sr(this, Lr), this.local = jr.length ? jr : Bs, this.children = Rr.length ? Rr : Bs;
    }
    return Cr(Lr, [{
      key: "find",
      value: function(Rr, Fr, Vr) {
        var Wr = [];
        return this.findInner(Rr == null ? 0 : Rr, Fr == null ? 1e9 : Fr, Wr, 0, Vr), Wr;
      }
    }, {
      key: "findInner",
      value: function(Rr, Fr, Vr, Wr, ri) {
        for (var ai = 0; ai < this.local.length; ai++) {
          var hi = this.local[ai];
          hi.from <= Fr && hi.to >= Rr && (!ri || ri(hi.spec)) && Vr.push(hi.copy(hi.from + Wr, hi.to + Wr));
        }
        for (var wi = 0; wi < this.children.length; wi += 3)
          if (this.children[wi] < Fr && this.children[wi + 1] > Rr) {
            var Oi = this.children[wi] + 1;
            this.children[wi + 2].findInner(Rr - Oi, Fr - Oi, Vr, Wr + Oi, ri);
          }
      }
    }, {
      key: "map",
      value: function(Rr, Fr, Vr) {
        return this == Io || Rr.maps.length == 0 ? this : this.mapInner(Rr, Fr, 0, 0, Vr || ws);
      }
    }, {
      key: "mapInner",
      value: function(Rr, Fr, Vr, Wr, ri) {
        for (var ai, hi = 0; hi < this.local.length; hi++) {
          var wi = this.local[hi].map(Rr, Vr, Wr);
          wi && wi.type.valid(Fr, wi) ? (ai || (ai = [])).push(wi) : ri.onRemove && ri.onRemove(this.local[hi].spec);
        }
        return this.children.length ? Gc(this.children, ai || [], Rr, Fr, Vr, Wr, ri) : ai ? new Lr(ai.sort(xs), Bs) : Io;
      }
    }, {
      key: "add",
      value: function(Rr, Fr) {
        return Fr.length ? this == Io ? Lr.create(Rr, Fr) : this.addInner(Rr, Fr, 0) : this;
      }
    }, {
      key: "addInner",
      value: function(Rr, Fr, Vr) {
        var Wr = this, ri, ai = 0;
        Rr.forEach(function(Oi, Wi) {
          var zi = Wi + Vr, Qi;
          if (Qi = Xl(Fr, Oi, zi)) {
            for (ri || (ri = Wr.children.slice()); ai < ri.length && ri[ai] < Wi; )
              ai += 3;
            ri[ai] == Wi ? ri[ai + 2] = ri[ai + 2].addInner(Oi, Qi, zi + 1) : ri.splice(ai, 0, Wi, Wi + Oi.nodeSize, pl(Qi, Oi, zi + 1, ws)), ai += 3;
          }
        });
        for (var hi = Zl(ai ? Jl(Fr) : Fr, -Vr), wi = 0; wi < hi.length; wi++)
          hi[wi].type.valid(Rr, hi[wi]) || hi.splice(wi--, 1);
        return new Lr(hi.length ? this.local.concat(hi).sort(xs) : this.local, ri || this.children);
      }
    }, {
      key: "remove",
      value: function(Rr) {
        return Rr.length == 0 || this == Io ? this : this.removeInner(Rr, 0);
      }
    }, {
      key: "removeInner",
      value: function(Rr, Fr) {
        for (var Vr = this.children, Wr = this.local, ri = 0; ri < Vr.length; ri += 3) {
          for (var ai = void 0, hi = Vr[ri] + Fr, wi = Vr[ri + 1] + Fr, Oi = 0, Wi; Oi < Rr.length; Oi++)
            (Wi = Rr[Oi]) && Wi.from > hi && Wi.to < wi && (Rr[Oi] = null, (ai || (ai = [])).push(Wi));
          if (ai) {
            Vr == this.children && (Vr = this.children.slice());
            var zi = Vr[ri + 2].removeInner(ai, hi + 1);
            zi != Io ? Vr[ri + 2] = zi : (Vr.splice(ri, 3), ri -= 3);
          }
        }
        if (Wr.length) {
          for (var Qi = 0, ia; Qi < Rr.length; Qi++)
            if (ia = Rr[Qi])
              for (var Ta = 0; Ta < Wr.length; Ta++)
                Wr[Ta].eq(ia, Fr) && (Wr == this.local && (Wr = this.local.slice()), Wr.splice(Ta--, 1));
        }
        return Vr == this.children && Wr == this.local ? this : Wr.length || Vr.length ? new Lr(Wr, Vr) : Io;
      }
    }, {
      key: "forChild",
      value: function(Rr, Fr) {
        if (this == Io)
          return this;
        if (Fr.isLeaf)
          return Lr.empty;
        for (var Vr, Wr, ri = 0; ri < this.children.length; ri += 3)
          if (this.children[ri] >= Rr) {
            this.children[ri] == Rr && (Vr = this.children[ri + 2]);
            break;
          }
        for (var ai = Rr + 1, hi = ai + Fr.content.size, wi = 0; wi < this.local.length; wi++) {
          var Oi = this.local[wi];
          if (Oi.from < hi && Oi.to > ai && Oi.type instanceof il) {
            var Wi = Math.max(ai, Oi.from) - ai, zi = Math.min(hi, Oi.to) - ai;
            Wi < zi && (Wr || (Wr = [])).push(Oi.copy(Wi, zi));
          }
        }
        if (Wr) {
          var Qi = new Lr(Wr.sort(xs), Bs);
          return Vr ? new Wl([Qi, Vr]) : Qi;
        }
        return Vr || Io;
      }
    }, {
      key: "eq",
      value: function(Rr) {
        if (this == Rr)
          return !0;
        if (!(Rr instanceof Lr) || this.local.length != Rr.local.length || this.children.length != Rr.children.length)
          return !1;
        for (var Fr = 0; Fr < this.local.length; Fr++)
          if (!this.local[Fr].eq(Rr.local[Fr]))
            return !1;
        for (var Vr = 0; Vr < this.children.length; Vr += 3)
          if (this.children[Vr] != Rr.children[Vr] || this.children[Vr + 1] != Rr.children[Vr + 1] || !this.children[Vr + 2].eq(Rr.children[Vr + 2]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(Rr) {
        return Il(this.localsInner(Rr));
      }
    }, {
      key: "localsInner",
      value: function(Rr) {
        if (this == Io)
          return Bs;
        if (Rr.inlineContent || !this.local.some(il.is))
          return this.local;
        for (var Fr = [], Vr = 0; Vr < this.local.length; Vr++)
          this.local[Vr].type instanceof il || Fr.push(this.local[Vr]);
        return Fr;
      }
    }], [{
      key: "create",
      value: function(Rr, Fr) {
        return Fr.length ? pl(Fr, Rr, 0, ws) : Io;
      }
    }]), Lr;
  }();
  jo.empty = new jo([], []), jo.removeOverlap = Il;
  var Io = jo.empty, Wl = function() {
    function Lr(jr) {
      Sr(this, Lr), this.members = jr;
    }
    return Cr(Lr, [{
      key: "map",
      value: function(Rr, Fr) {
        var Vr = this.members.map(function(Wr) {
          return Wr.map(Rr, Fr, ws);
        });
        return Lr.from(Vr);
      }
    }, {
      key: "forChild",
      value: function(Rr, Fr) {
        if (Fr.isLeaf)
          return jo.empty;
        for (var Vr = [], Wr = 0; Wr < this.members.length; Wr++) {
          var ri = this.members[Wr].forChild(Rr, Fr);
          ri != Io && (ri instanceof Lr ? Vr = Vr.concat(ri.members) : Vr.push(ri));
        }
        return Lr.from(Vr);
      }
    }, {
      key: "eq",
      value: function(Rr) {
        if (!(Rr instanceof Lr) || Rr.members.length != this.members.length)
          return !1;
        for (var Fr = 0; Fr < this.members.length; Fr++)
          if (!this.members[Fr].eq(Rr.members[Fr]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(Rr) {
        for (var Fr, Vr = !0, Wr = 0; Wr < this.members.length; Wr++) {
          var ri = this.members[Wr].localsInner(Rr);
          if (ri.length)
            if (!Fr)
              Fr = ri;
            else {
              Vr && (Fr = Fr.slice(), Vr = !1);
              for (var ai = 0; ai < ri.length; ai++)
                Fr.push(ri[ai]);
            }
        }
        return Fr ? Il(Vr ? Fr : Fr.sort(xs)) : Bs;
      }
    }], [{
      key: "from",
      value: function(Rr) {
        switch (Rr.length) {
          case 0:
            return Io;
          case 1:
            return Rr[0];
          default:
            return new Lr(Rr.every(function(Fr) {
              return Fr instanceof jo;
            }) ? Rr : Rr.reduce(function(Fr, Vr) {
              return Fr.concat(Vr instanceof jo ? Vr : Vr.members);
            }, []));
        }
      }
    }]), Lr;
  }();
  function Gc(Lr, jr, Rr, Fr, Vr, Wr, ri) {
    for (var ai = Lr.slice(), hi = function(Ps, Xo) {
      var Hs = 0;
      Rr.maps[Ps].forEach(function(Vo, vo, fc, gu) {
        for (var ml = gu - fc - (vo - Vo), Es = 0; Es < ai.length; Es += 3) {
          var dc = ai[Es + 1];
          if (!(dc < 0 || Vo > dc + Xo - Hs)) {
            var hc = ai[Es] + Xo - Hs;
            vo >= hc ? ai[Es + 1] = Vo <= hc ? -2 : -1 : fc >= Vr && ml && (ai[Es] += ml, ai[Es + 1] += ml);
          }
        }
        Hs += ml;
      }), Xo = Rr.maps[Ps].map(Xo, -1), Oi = Xo;
    }, wi = 0, Oi = Wr; wi < Rr.maps.length; wi++)
      hi(wi, Oi);
    for (var Wi = !1, zi = 0; zi < ai.length; zi += 3)
      if (ai[zi + 1] < 0) {
        if (ai[zi + 1] == -2) {
          Wi = !0, ai[zi + 1] = -1;
          continue;
        }
        var Qi = Rr.map(Lr[zi] + Wr), ia = Qi - Vr;
        if (ia < 0 || ia >= Fr.content.size) {
          Wi = !0;
          continue;
        }
        var Ta = Rr.map(Lr[zi + 1] + Wr, -1), Da = Ta - Vr, ha = Fr.content.findIndex(ia), co = ha.index, Xa = ha.offset, ao = Fr.maybeChild(co);
        if (ao && Xa == ia && Xa + ao.nodeSize == Da) {
          var Wa = ai[zi + 2].mapInner(Rr, ao, Qi + 1, Lr[zi] + Wr + 1, ri);
          Wa != Io ? (ai[zi] = ia, ai[zi + 1] = Da, ai[zi + 2] = Wa) : (ai[zi + 1] = -2, Wi = !0);
        } else
          Wi = !0;
      }
    if (Wi) {
      var eo = Wc(ai, Lr, jr, Rr, Vr, Wr, ri), mo = pl(eo, Fr, 0, ri);
      jr = mo.local;
      for (var Do = 0; Do < ai.length; Do += 3)
        ai[Do + 1] < 0 && (ai.splice(Do, 3), Do -= 3);
      for (var $o = 0, Ao = 0; $o < mo.children.length; $o += 3) {
        for (var Zo = mo.children[$o]; Ao < ai.length && ai[Ao] < Zo; )
          Ao += 3;
        ai.splice(Ao, 0, mo.children[$o], mo.children[$o + 1], mo.children[$o + 2]);
      }
    }
    return new jo(jr.sort(xs), ai);
  }
  function Zl(Lr, jr) {
    if (!jr || !Lr.length)
      return Lr;
    for (var Rr = [], Fr = 0; Fr < Lr.length; Fr++) {
      var Vr = Lr[Fr];
      Rr.push(new _s(Vr.from + jr, Vr.to + jr, Vr.type));
    }
    return Rr;
  }
  function Wc(Lr, jr, Rr, Fr, Vr, Wr, ri) {
    function ai(wi, Oi) {
      for (var Wi = 0; Wi < wi.local.length; Wi++) {
        var zi = wi.local[Wi].map(Fr, Vr, Oi);
        zi ? Rr.push(zi) : ri.onRemove && ri.onRemove(wi.local[Wi].spec);
      }
      for (var Qi = 0; Qi < wi.children.length; Qi += 3)
        ai(wi.children[Qi + 2], wi.children[Qi] + Oi + 1);
    }
    for (var hi = 0; hi < Lr.length; hi += 3)
      Lr[hi + 1] == -1 && ai(Lr[hi + 2], jr[hi] + Wr + 1);
    return Rr;
  }
  function Xl(Lr, jr, Rr) {
    if (jr.isLeaf)
      return null;
    for (var Fr = Rr + jr.nodeSize, Vr = null, Wr = 0, ri; Wr < Lr.length; Wr++)
      (ri = Lr[Wr]) && ri.from > Rr && ri.to < Fr && ((Vr || (Vr = [])).push(ri), Lr[Wr] = null);
    return Vr;
  }
  function Jl(Lr) {
    for (var jr = [], Rr = 0; Rr < Lr.length; Rr++)
      Lr[Rr] != null && jr.push(Lr[Rr]);
    return jr;
  }
  function pl(Lr, jr, Rr, Fr) {
    var Vr = [], Wr = !1;
    jr.forEach(function(hi, wi) {
      var Oi = Xl(Lr, hi, wi + Rr);
      if (Oi) {
        Wr = !0;
        var Wi = pl(Oi, hi, Rr + wi + 1, Fr);
        Wi != Io && Vr.push(wi, wi + hi.nodeSize, Wi);
      }
    });
    for (var ri = Zl(Wr ? Jl(Lr) : Lr, -Rr).sort(xs), ai = 0; ai < ri.length; ai++)
      ri[ai].type.valid(jr, ri[ai]) || (Fr.onRemove && Fr.onRemove(ri[ai].spec), ri.splice(ai--, 1));
    return ri.length || Vr.length ? new jo(ri, Vr) : Io;
  }
  function xs(Lr, jr) {
    return Lr.from - jr.from || Lr.to - jr.to;
  }
  function Il(Lr) {
    for (var jr = Lr, Rr = 0; Rr < jr.length - 1; Rr++) {
      var Fr = jr[Rr];
      if (Fr.from != Fr.to)
        for (var Vr = Rr + 1; Vr < jr.length; Vr++) {
          var Wr = jr[Vr];
          if (Wr.from == Fr.from) {
            Wr.to != Fr.to && (jr == Lr && (jr = Lr.slice()), jr[Vr] = Wr.copy(Wr.from, Fr.to), Yl(jr, Vr + 1, Wr.copy(Fr.to, Wr.to)));
            continue;
          } else {
            Wr.from < Fr.to && (jr == Lr && (jr = Lr.slice()), jr[Rr] = Fr.copy(Fr.from, Wr.from), Yl(jr, Vr, Fr.copy(Wr.from, Fr.to)));
            break;
          }
        }
    }
    return jr;
  }
  function Yl(Lr, jr, Rr) {
    for (; jr < Lr.length && xs(Rr, Lr[jr]) > 0; )
      jr++;
    Lr.splice(jr, 0, Rr);
  }
  function Rl(Lr) {
    var jr = [];
    return Lr.someProp("decorations", function(Rr) {
      var Fr = Rr(Lr.state);
      Fr && Fr != Io && jr.push(Fr);
    }), Lr.cursorWrapper && jr.push(jo.create(Lr.state.doc, [Lr.cursorWrapper.deco])), Wl.from(jr);
  }
  var Zc = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  }, Xc = qi && ki <= 11, Jc = function() {
    function Lr() {
      Sr(this, Lr), this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    return Cr(Lr, [{
      key: "set",
      value: function(Rr) {
        this.anchorNode = Rr.anchorNode, this.anchorOffset = Rr.anchorOffset, this.focusNode = Rr.focusNode, this.focusOffset = Rr.focusOffset;
      }
    }, {
      key: "clear",
      value: function() {
        this.anchorNode = this.focusNode = null;
      }
    }, {
      key: "eq",
      value: function(Rr) {
        return Rr.anchorNode == this.anchorNode && Rr.anchorOffset == this.anchorOffset && Rr.focusNode == this.focusNode && Rr.focusOffset == this.focusOffset;
      }
    }]), Lr;
  }(), Yc = function() {
    function Lr(jr, Rr) {
      var Fr = this;
      Sr(this, Lr), this.view = jr, this.handleDOMChange = Rr, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Jc(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver(function(Vr) {
        for (var Wr = 0; Wr < Vr.length; Wr++)
          Fr.queue.push(Vr[Wr]);
        qi && ki <= 11 && Vr.some(function(ri) {
          return ri.type == "childList" && ri.removedNodes.length || ri.type == "characterData" && ri.oldValue.length > ri.target.nodeValue.length;
        }) ? Fr.flushSoon() : Fr.flush();
      }), Xc && (this.onCharData = function(Vr) {
        Fr.queue.push({
          target: Vr.target,
          type: "characterData",
          oldValue: Vr.prevValue
        }), Fr.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    return Cr(Lr, [{
      key: "flushSoon",
      value: function() {
        var Rr = this;
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(function() {
          Rr.flushingSoon = -1, Rr.flush();
        }, 20));
      }
    }, {
      key: "forceFlush",
      value: function() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
    }, {
      key: "start",
      value: function() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Zc)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
    }, {
      key: "stop",
      value: function() {
        var Rr = this;
        if (this.observer) {
          var Fr = this.observer.takeRecords();
          if (Fr.length) {
            for (var Vr = 0; Vr < Fr.length; Vr++)
              this.queue.push(Fr[Vr]);
            window.setTimeout(function() {
              return Rr.flush();
            }, 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
    }, {
      key: "connectSelection",
      value: function() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "disconnectSelection",
      value: function() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "suppressSelectionUpdates",
      value: function() {
        var Rr = this;
        this.suppressingSelectionUpdates = !0, setTimeout(function() {
          return Rr.suppressingSelectionUpdates = !1;
        }, 50);
      }
    }, {
      key: "onSelectionChange",
      value: function() {
        if (Rs(this.view)) {
          if (this.suppressingSelectionUpdates)
            return Ho(this.view);
          if (qi && ki <= 11 && !this.view.state.selection.empty) {
            var Rr = this.view.domSelectionRange();
            if (Rr.focusNode && Gr(Rr.focusNode, Rr.focusOffset, Rr.anchorNode, Rr.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
    }, {
      key: "setCurSelection",
      value: function() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
    }, {
      key: "ignoreSelectionChange",
      value: function(Rr) {
        if (!Rr.focusNode)
          return !0;
        for (var Fr = /* @__PURE__ */ new Set(), Vr, Wr = Rr.focusNode; Wr; Wr = Hr(Wr))
          Fr.add(Wr);
        for (var ri = Rr.anchorNode; ri; ri = Hr(ri))
          if (Fr.has(ri)) {
            Vr = ri;
            break;
          }
        var ai = Vr && this.view.docView.nearestDesc(Vr);
        if (ai && ai.ignoreMutation({
          type: "selection",
          target: Vr.nodeType == 3 ? Vr.parentNode : Vr
        }))
          return this.setCurSelection(), !0;
      }
    }, {
      key: "pendingRecords",
      value: function() {
        if (this.observer) {
          var Rr = ar(this.observer.takeRecords()), Fr;
          try {
            for (Rr.s(); !(Fr = Rr.n()).done; ) {
              var Vr = Fr.value;
              this.queue.push(Vr);
            }
          } catch (Wr) {
            Rr.e(Wr);
          } finally {
            Rr.f();
          }
        }
        return this.queue;
      }
    }, {
      key: "flush",
      value: function() {
        var Rr = this.view;
        if (!(!Rr.docView || this.flushingSoon > -1)) {
          var Fr = this.pendingRecords();
          Fr.length && (this.queue = []);
          var Vr = Rr.domSelectionRange(), Wr = !this.suppressingSelectionUpdates && !this.currentSelection.eq(Vr) && Rs(Rr) && !this.ignoreSelectionChange(Vr), ri = -1, ai = -1, hi = !1, wi = [];
          if (Rr.editable)
            for (var Oi = 0; Oi < Fr.length; Oi++) {
              var Wi = this.registerMutation(Fr[Oi], wi);
              Wi && (ri = ri < 0 ? Wi.from : Math.min(Wi.from, ri), ai = ai < 0 ? Wi.to : Math.max(Wi.to, ai), Wi.typeOver && (hi = !0));
            }
          if (Ji && wi.length > 1) {
            var zi = wi.filter(function(Da) {
              return Da.nodeName == "BR";
            });
            if (zi.length == 2) {
              var Qi = zi[0], ia = zi[1];
              Qi.parentNode && Qi.parentNode.parentNode == ia.parentNode ? ia.remove() : Qi.remove();
            }
          }
          var Ta = null;
          ri < 0 && Wr && Rr.input.lastFocus > Date.now() - 200 && Math.max(Rr.input.lastTouch, Rr.input.lastClick.time) < Date.now() - 300 && ui(Vr) && (Ta = Po(Rr)) && Ta.eq(Tr.Selection.near(Rr.state.doc.resolve(0), 1)) ? (Rr.input.lastFocus = 0, Ho(Rr), this.currentSelection.set(Vr), Rr.scrollToSelection()) : (ri > -1 || Wr) && (ri > -1 && (Rr.docView.markDirty(ri, ai), Qc(Rr)), this.handleDOMChange(ri, ai, hi, wi), Rr.docView && Rr.docView.dirty ? Rr.updateState(Rr.state) : this.currentSelection.eq(Vr) || Ho(Rr), this.currentSelection.set(Vr));
        }
      }
    }, {
      key: "registerMutation",
      value: function(Rr, Fr) {
        if (Fr.indexOf(Rr.target) > -1)
          return null;
        var Vr = this.view.docView.nearestDesc(Rr.target);
        if (Rr.type == "attributes" && (Vr == this.view.docView || Rr.attributeName == "contenteditable" || Rr.attributeName == "style" && !Rr.oldValue && !Rr.target.getAttribute("style")) || !Vr || Vr.ignoreMutation(Rr))
          return null;
        if (Rr.type == "childList") {
          for (var Wr = 0; Wr < Rr.addedNodes.length; Wr++)
            Fr.push(Rr.addedNodes[Wr]);
          if (Vr.contentDOM && Vr.contentDOM != Vr.dom && !Vr.contentDOM.contains(Rr.target))
            return {
              from: Vr.posBefore,
              to: Vr.posAfter
            };
          var ri = Rr.previousSibling, ai = Rr.nextSibling;
          if (qi && ki <= 11 && Rr.addedNodes.length)
            for (var hi = 0; hi < Rr.addedNodes.length; hi++) {
              var wi = Rr.addedNodes[hi], Oi = wi.previousSibling, Wi = wi.nextSibling;
              (!Oi || Array.prototype.indexOf.call(Rr.addedNodes, Oi) < 0) && (ri = Oi), (!Wi || Array.prototype.indexOf.call(Rr.addedNodes, Wi) < 0) && (ai = Wi);
            }
          var zi = ri && ri.parentNode == Rr.target ? Mr(ri) + 1 : 0, Qi = Vr.localPosFromDOM(Rr.target, zi, -1), ia = ai && ai.parentNode == Rr.target ? Mr(ai) : Rr.target.childNodes.length, Ta = Vr.localPosFromDOM(Rr.target, ia, 1);
          return {
            from: Qi,
            to: Ta
          };
        } else
          return Rr.type == "attributes" ? {
            from: Vr.posAtStart - Vr.border,
            to: Vr.posAtEnd + Vr.border
          } : {
            from: Vr.posAtStart,
            to: Vr.posAtEnd,
            typeOver: Rr.target.nodeValue == Rr.oldValue
          };
      }
    }]), Lr;
  }(), Ql = /* @__PURE__ */ new WeakMap(), ec = !1;
  function Qc(Lr) {
    if (!Ql.has(Lr) && (Ql.set(Lr, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(Lr.dom).whiteSpace) !== -1)) {
      if (Lr.requiresGeckoHackNode = Ji, ec)
        return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), ec = !0;
    }
  }
  function eu(Lr) {
    var jr;
    function Rr(wi) {
      wi.preventDefault(), wi.stopImmediatePropagation(), jr = wi.getTargetRanges()[0];
    }
    Lr.dom.addEventListener("beforeinput", Rr, !0), document.execCommand("indent"), Lr.dom.removeEventListener("beforeinput", Rr, !0);
    var Fr = jr.startContainer, Vr = jr.startOffset, Wr = jr.endContainer, ri = jr.endOffset, ai = Lr.domAtPos(Lr.state.selection.anchor);
    if (Gr(ai.node, ai.offset, Wr, ri)) {
      var hi = [Wr, ri, Fr, Vr];
      Fr = hi[0], Vr = hi[1], Wr = hi[2], ri = hi[3];
    }
    return {
      anchorNode: Fr,
      anchorOffset: Vr,
      focusNode: Wr,
      focusOffset: ri
    };
  }
  function tu(Lr, jr, Rr) {
    var Fr = Lr.docView.parseRange(jr, Rr), Vr = Fr.node, Wr = Fr.fromOffset, ri = Fr.toOffset, ai = Fr.from, hi = Fr.to, wi = Lr.domSelectionRange(), Oi, Wi = wi.anchorNode;
    if (Wi && Lr.dom.contains(Wi.nodeType == 1 ? Wi : Wi.parentNode) && (Oi = [{
      node: Wi,
      offset: wi.anchorOffset
    }], ui(wi) || Oi.push({
      node: wi.focusNode,
      offset: wi.focusOffset
    })), Ni && Lr.input.lastKeyCode === 8)
      for (var zi = ri; zi > Wr; zi--) {
        var Qi = Vr.childNodes[zi - 1], ia = Qi.pmViewDesc;
        if (Qi.nodeName == "BR" && !ia) {
          ri = zi;
          break;
        }
        if (!ia || ia.size)
          break;
      }
    var Ta = Lr.state.doc, Da = Lr.someProp("domParser") || Ar.DOMParser.fromSchema(Lr.state.schema), ha = Ta.resolve(ai), co = null, Xa = Da.parse(Vr, {
      topNode: ha.parent,
      topMatch: ha.parent.contentMatchAt(ha.index()),
      topOpen: !0,
      from: Wr,
      to: ri,
      preserveWhitespace: ha.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: Oi,
      ruleFromNode: ru,
      context: ha
    });
    if (Oi && Oi[0].pos != null) {
      var ao = Oi[0].pos, Wa = Oi[1] && Oi[1].pos;
      Wa == null && (Wa = ao), co = {
        anchor: ao + ai,
        head: Wa + ai
      };
    }
    return {
      doc: Xa,
      sel: co,
      from: ai,
      to: hi
    };
  }
  function ru(Lr) {
    var jr = Lr.pmViewDesc;
    if (jr)
      return jr.parseRule();
    if (Lr.nodeName == "BR" && Lr.parentNode) {
      if (bi && /^(ul|ol)$/i.test(Lr.parentNode.nodeName)) {
        var Rr = document.createElement("div");
        return Rr.appendChild(document.createElement("li")), {
          skip: Rr
        };
      } else if (Lr.parentNode.lastChild == Lr || bi && /^(tr|table)$/i.test(Lr.parentNode.nodeName))
        return {
          ignore: !0
        };
    } else if (Lr.nodeName == "IMG" && Lr.getAttribute("mark-placeholder"))
      return {
        ignore: !0
      };
    return null;
  }
  var iu = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function au(Lr, jr, Rr, Fr, Vr) {
    var Wr = Lr.input.compositionPendingChanges || (Lr.composing ? Lr.input.compositionID : 0);
    if (Lr.input.compositionPendingChanges = 0, jr < 0) {
      var ri = Lr.input.lastSelectionTime > Date.now() - 50 ? Lr.input.lastSelectionOrigin : null, ai = Po(Lr, ri);
      if (ai && !Lr.state.selection.eq(ai)) {
        if (Ni && Di && Lr.input.lastKeyCode === 13 && Date.now() - 100 < Lr.input.lastKeyCodeTime && Lr.someProp("handleKeyDown", function(vo) {
          return vo(Lr, Ai(13, "Enter"));
        }))
          return;
        var hi = Lr.state.tr.setSelection(ai);
        ri == "pointer" ? hi.setMeta("pointer", !0) : ri == "key" && hi.scrollIntoView(), Wr && hi.setMeta("composition", Wr), Lr.dispatch(hi);
      }
      return;
    }
    var wi = Lr.state.doc.resolve(jr), Oi = wi.sharedDepth(Rr);
    jr = wi.before(Oi + 1), Rr = Lr.state.doc.resolve(Rr).after(Oi + 1);
    var Wi = Lr.state.selection, zi = tu(Lr, jr, Rr), Qi = Lr.state.doc, ia = Qi.slice(zi.from, zi.to), Ta, Da;
    Lr.input.lastKeyCode === 8 && Date.now() - 100 < Lr.input.lastKeyCodeTime ? (Ta = Lr.state.selection.to, Da = "end") : (Ta = Lr.state.selection.from, Da = "start"), Lr.input.lastKeyCode = null;
    var ha = lu(ia.content, zi.doc.content, zi.from, Ta, Da);
    if ((Ei && Lr.input.lastIOSEnter > Date.now() - 225 || Di) && Vr.some(function(vo) {
      return vo.nodeType == 1 && !iu.test(vo.nodeName);
    }) && (!ha || ha.endA >= ha.endB) && Lr.someProp("handleKeyDown", function(vo) {
      return vo(Lr, Ai(13, "Enter"));
    })) {
      Lr.input.lastIOSEnter = 0;
      return;
    }
    if (!ha)
      if (Fr && Wi instanceof Tr.TextSelection && !Wi.empty && Wi.$head.sameParent(Wi.$anchor) && !Lr.composing && !(zi.sel && zi.sel.anchor != zi.sel.head))
        ha = {
          start: Wi.from,
          endA: Wi.to,
          endB: Wi.to
        };
      else {
        if (zi.sel) {
          var co = tc(Lr, Lr.state.doc, zi.sel);
          if (co && !co.eq(Lr.state.selection)) {
            var Xa = Lr.state.tr.setSelection(co);
            Wr && Xa.setMeta("composition", Wr), Lr.dispatch(Xa);
          }
        }
        return;
      }
    if (Ni && Lr.cursorWrapper && zi.sel && zi.sel.anchor == Lr.cursorWrapper.deco.from && zi.sel.head == zi.sel.anchor) {
      var ao = ha.endB - ha.start;
      zi.sel = {
        anchor: zi.sel.anchor + ao,
        head: zi.sel.anchor + ao
      };
    }
    Lr.input.domChangeCount++, Lr.state.selection.from < Lr.state.selection.to && ha.start == ha.endB && Lr.state.selection instanceof Tr.TextSelection && (ha.start > Lr.state.selection.from && ha.start <= Lr.state.selection.from + 2 && Lr.state.selection.from >= zi.from ? ha.start = Lr.state.selection.from : ha.endA < Lr.state.selection.to && ha.endA >= Lr.state.selection.to - 2 && Lr.state.selection.to <= zi.to && (ha.endB += Lr.state.selection.to - ha.endA, ha.endA = Lr.state.selection.to)), qi && ki <= 11 && ha.endB == ha.start + 1 && ha.endA == ha.start && ha.start > zi.from && zi.doc.textBetween(ha.start - zi.from - 1, ha.start - zi.from + 1) == "  " && (ha.start--, ha.endA--, ha.endB--);
    var Wa = zi.doc.resolveNoCache(ha.start - zi.from), eo = zi.doc.resolveNoCache(ha.endB - zi.from), mo = Qi.resolve(ha.start), Do = Wa.sameParent(eo) && Wa.parent.inlineContent && mo.end() >= ha.endA, $o;
    if ((Ei && Lr.input.lastIOSEnter > Date.now() - 225 && (!Do || Vr.some(function(vo) {
      return vo.nodeName == "DIV" || vo.nodeName == "P";
    })) || !Do && Wa.pos < zi.doc.content.size && !Wa.sameParent(eo) && ($o = Tr.Selection.findFrom(zi.doc.resolve(Wa.pos + 1), 1, !0)) && $o.head == eo.pos) && Lr.someProp("handleKeyDown", function(vo) {
      return vo(Lr, Ai(13, "Enter"));
    })) {
      Lr.input.lastIOSEnter = 0;
      return;
    }
    if (Lr.state.selection.anchor > ha.start && su(Qi, ha.start, ha.endA, Wa, eo) && Lr.someProp("handleKeyDown", function(vo) {
      return vo(Lr, Ai(8, "Backspace"));
    })) {
      Di && Ni && Lr.domObserver.suppressSelectionUpdates();
      return;
    }
    Ni && Di && ha.endB == ha.start && (Lr.input.lastAndroidDelete = Date.now()), Di && !Do && Wa.start() != eo.start() && eo.parentOffset == 0 && Wa.depth == eo.depth && zi.sel && zi.sel.anchor == zi.sel.head && zi.sel.head == ha.endA && (ha.endB -= 2, eo = zi.doc.resolveNoCache(ha.endB - zi.from), setTimeout(function() {
      Lr.someProp("handleKeyDown", function(vo) {
        return vo(Lr, Ai(13, "Enter"));
      });
    }, 20));
    var Ao = ha.start, Zo = ha.endA, Oo, Ps, Xo;
    if (Do) {
      if (Wa.pos == eo.pos)
        qi && ki <= 11 && Wa.parentOffset == 0 && (Lr.domObserver.suppressSelectionUpdates(), setTimeout(function() {
          return Ho(Lr);
        }, 20)), Oo = Lr.state.tr.delete(Ao, Zo), Ps = Qi.resolve(ha.start).marksAcross(Qi.resolve(ha.endA));
      else if (ha.endA == ha.endB && (Xo = ou(Wa.parent.content.cut(Wa.parentOffset, eo.parentOffset), mo.parent.content.cut(mo.parentOffset, ha.endA - mo.start()))))
        Oo = Lr.state.tr, Xo.type == "add" ? Oo.addMark(Ao, Zo, Xo.mark) : Oo.removeMark(Ao, Zo, Xo.mark);
      else if (Wa.parent.child(Wa.index()).isText && Wa.index() == eo.index() - (eo.textOffset ? 0 : 1)) {
        var Hs = Wa.parent.textBetween(Wa.parentOffset, eo.parentOffset);
        if (Lr.someProp("handleTextInput", function(vo) {
          return vo(Lr, Ao, Zo, Hs);
        }))
          return;
        Oo = Lr.state.tr.insertText(Hs, Ao, Zo);
      }
    }
    if (Oo || (Oo = Lr.state.tr.replace(Ao, Zo, zi.doc.slice(ha.start - zi.from, ha.endB - zi.from))), zi.sel) {
      var Vo = tc(Lr, Oo.doc, zi.sel);
      Vo && !(Ni && Di && Lr.composing && Vo.empty && (ha.start != ha.endB || Lr.input.lastAndroidDelete < Date.now() - 100) && (Vo.head == Ao || Vo.head == Oo.mapping.map(Zo) - 1) || qi && Vo.empty && Vo.head == Ao) && Oo.setSelection(Vo);
    }
    Ps && Oo.ensureMarks(Ps), Wr && Oo.setMeta("composition", Wr), Lr.dispatch(Oo.scrollIntoView());
  }
  function tc(Lr, jr, Rr) {
    return Math.max(Rr.anchor, Rr.head) > jr.content.size ? null : Ls(Lr, jr.resolve(Rr.anchor), jr.resolve(Rr.head));
  }
  function ou(Lr, jr) {
    for (var Rr = Lr.firstChild.marks, Fr = jr.firstChild.marks, Vr = Rr, Wr = Fr, ri, ai, hi, wi = 0; wi < Fr.length; wi++)
      Vr = Fr[wi].removeFromSet(Vr);
    for (var Oi = 0; Oi < Rr.length; Oi++)
      Wr = Rr[Oi].removeFromSet(Wr);
    if (Vr.length == 1 && Wr.length == 0)
      ai = Vr[0], ri = "add", hi = function(ia) {
        return ia.mark(ai.addToSet(ia.marks));
      };
    else if (Vr.length == 0 && Wr.length == 1)
      ai = Wr[0], ri = "remove", hi = function(ia) {
        return ia.mark(ai.removeFromSet(ia.marks));
      };
    else
      return null;
    for (var Wi = [], zi = 0; zi < jr.childCount; zi++)
      Wi.push(hi(jr.child(zi)));
    if (Ar.Fragment.from(Wi).eq(Lr))
      return {
        mark: ai,
        type: ri
      };
  }
  function su(Lr, jr, Rr, Fr, Vr) {
    if (!Fr.parent.isTextblock || Rr - jr <= Vr.pos - Fr.pos || Ml(Fr, !0, !1) < Vr.pos)
      return !1;
    var Wr = Lr.resolve(jr);
    if (Wr.parentOffset < Wr.parent.content.size || !Wr.parent.isTextblock)
      return !1;
    var ri = Lr.resolve(Ml(Wr, !0, !0));
    return !ri.parent.isTextblock || ri.pos > Rr || Ml(ri, !0, !1) < Rr ? !1 : Fr.parent.content.cut(Fr.parentOffset).eq(ri.parent.content);
  }
  function Ml(Lr, jr, Rr) {
    for (var Fr = Lr.depth, Vr = jr ? Lr.end() : Lr.pos; Fr > 0 && (jr || Lr.indexAfter(Fr) == Lr.node(Fr).childCount); )
      Fr--, Vr++, jr = !1;
    if (Rr)
      for (var Wr = Lr.node(Fr).maybeChild(Lr.indexAfter(Fr)); Wr && !Wr.isLeaf; )
        Wr = Wr.firstChild, Vr++;
    return Vr;
  }
  function lu(Lr, jr, Rr, Fr, Vr) {
    var Wr = Lr.findDiffStart(jr, Rr);
    if (Wr == null)
      return null;
    var ri = Lr.findDiffEnd(jr, Rr + Lr.size, Rr + jr.size), ai = ri.a, hi = ri.b;
    if (Vr == "end") {
      var wi = Math.max(0, Wr - Math.min(ai, hi));
      Fr -= ai + wi - Wr;
    }
    if (ai < Wr && Lr.size < jr.size) {
      var Oi = Fr <= Wr && Fr >= ai ? Wr - Fr : 0;
      Wr -= Oi, Wr && Wr < jr.size && rc(jr.textBetween(Wr - 1, Wr + 1)) && (Wr += Oi ? 1 : -1), hi = Wr + (hi - ai), ai = Wr;
    } else if (hi < Wr) {
      var Wi = Fr <= Wr && Fr >= hi ? Wr - Fr : 0;
      Wr -= Wi, Wr && Wr < Lr.size && rc(Lr.textBetween(Wr - 1, Wr + 1)) && (Wr += Wi ? 1 : -1), ai = Wr + (ai - hi), hi = Wr;
    }
    return {
      start: Wr,
      endA: ai,
      endB: hi
    };
  }
  function rc(Lr) {
    if (Lr.length != 2)
      return !1;
    var jr = Lr.charCodeAt(0), Rr = Lr.charCodeAt(1);
    return jr >= 56320 && jr <= 57343 && Rr >= 55296 && Rr <= 56319;
  }
  var cu = Os, uu = Ws, fu = Qs, du = function() {
    function Lr(jr, Rr) {
      var Fr = this;
      Sr(this, Lr), this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new dl(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = Rr, this.state = Rr.state, this.directPlugins = Rr.plugins || [], this.directPlugins.forEach(uc), this.dispatch = this.dispatch.bind(this), this.dom = jr && jr.mount || document.createElement("div"), jr && (jr.appendChild ? jr.appendChild(this.dom) : typeof jr == "function" ? jr(this.dom) : jr.mount && (this.mounted = !0)), this.editable = lc(this), oc(this), this.nodeViews = cc(this), this.docView = wa(this.state.doc, nc(this), Rl(this), this.dom, this), this.domObserver = new Yc(this, function(Vr, Wr, ri, ai) {
        return au(Fr, Vr, Wr, ri, ai);
      }), this.domObserver.start(), El(this), this.updatePluginViews();
    }
    return Cr(Lr, [{
      key: "composing",
      get: function() {
        return this.input.composing;
      }
    }, {
      key: "props",
      get: function() {
        if (this._props.state != this.state) {
          var Rr = this._props;
          this._props = {};
          for (var Fr in Rr)
            this._props[Fr] = Rr[Fr];
          this._props.state = this.state;
        }
        return this._props;
      }
    }, {
      key: "update",
      value: function(Rr) {
        Rr.handleDOMEvents != this._props.handleDOMEvents && Cl(this);
        var Fr = this._props;
        this._props = Rr, Rr.plugins && (Rr.plugins.forEach(uc), this.directPlugins = Rr.plugins), this.updateStateInner(Rr.state, Fr);
      }
    }, {
      key: "setProps",
      value: function(Rr) {
        var Fr = {};
        for (var Vr in this._props)
          Fr[Vr] = this._props[Vr];
        Fr.state = this.state;
        for (var Wr in Rr)
          Fr[Wr] = Rr[Wr];
        this.update(Fr);
      }
    }, {
      key: "updateState",
      value: function(Rr) {
        this.updateStateInner(Rr, this._props);
      }
    }, {
      key: "updateStateInner",
      value: function(Rr, Fr) {
        var Vr, Wr = this.state, ri = !1, ai = !1;
        Rr.storedMarks && this.composing && (Fl(this), ai = !0), this.state = Rr;
        var hi = Wr.plugins != Rr.plugins || this._props.plugins != Fr.plugins;
        if (hi || this._props.plugins != Fr.plugins || this._props.nodeViews != Fr.nodeViews) {
          var wi = cc(this);
          pu(wi, this.nodeViews) && (this.nodeViews = wi, ri = !0);
        }
        (hi || Fr.handleDOMEvents != this._props.handleDOMEvents) && Cl(this), this.editable = lc(this), oc(this);
        var Oi = Rl(this), Wi = nc(this), zi = Wr.plugins != Rr.plugins && !Wr.doc.eq(Rr.doc) ? "reset" : Rr.scrollToSelection > Wr.scrollToSelection ? "to selection" : "preserve", Qi = ri || !this.docView.matchesNode(Rr.doc, Wi, Oi);
        (Qi || !Rr.selection.eq(Wr.selection)) && (ai = !0);
        var ia = zi == "preserve" && ai && this.dom.style.overflowAnchor == null && Ma(this);
        if (ai) {
          this.domObserver.stop();
          var Ta = Qi && (qi || Ni) && !this.composing && !Wr.selection.empty && !Rr.selection.empty && hu(Wr.selection, Rr.selection);
          if (Qi) {
            var Da = Ni ? this.trackWrites = this.domSelectionRange().focusNode : null;
            (ri || !this.docView.update(Rr.doc, Wi, Oi, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = wa(Rr.doc, Wi, Oi, this.dom, this)), Da && !this.trackWrites && (Ta = !0);
          }
          Ta || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Vs(this)) ? Ho(this, Ta) : (qs(this, Rr.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(Wr), !((Vr = this.dragging) === null || Vr === void 0) && Vr.node && !Wr.doc.eq(Rr.doc) && this.updateDraggedNode(this.dragging, Wr), zi == "reset" ? this.dom.scrollTop = 0 : zi == "to selection" ? this.scrollToSelection() : ia && na(ia);
      }
    }, {
      key: "scrollToSelection",
      value: function() {
        var Rr = this, Fr = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", function(Wr) {
          return Wr(Rr);
        }))
          if (this.state.selection instanceof Tr.NodeSelection) {
            var Vr = this.docView.domAfterPos(this.state.selection.from);
            Vr.nodeType == 1 && Va(this, Vr.getBoundingClientRect(), Fr);
          } else
            Va(this, this.coordsAtPos(this.state.selection.head, 1), Fr);
      }
    }, {
      key: "destroyPluginViews",
      value: function() {
        for (var Rr; Rr = this.pluginViews.pop(); )
          Rr.destroy && Rr.destroy();
      }
    }, {
      key: "updatePluginViews",
      value: function(Rr) {
        if (!Rr || Rr.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (var Fr = 0; Fr < this.directPlugins.length; Fr++) {
            var Vr = this.directPlugins[Fr];
            Vr.spec.view && this.pluginViews.push(Vr.spec.view(this));
          }
          for (var Wr = 0; Wr < this.state.plugins.length; Wr++) {
            var ri = this.state.plugins[Wr];
            ri.spec.view && this.pluginViews.push(ri.spec.view(this));
          }
        } else
          for (var ai = 0; ai < this.pluginViews.length; ai++) {
            var hi = this.pluginViews[ai];
            hi.update && hi.update(this, Rr);
          }
      }
    }, {
      key: "updateDraggedNode",
      value: function(Rr, Fr) {
        var Vr = Rr.node, Wr = -1;
        if (this.state.doc.nodeAt(Vr.from) == Vr.node)
          Wr = Vr.from;
        else {
          var ri = Vr.from + (this.state.doc.content.size - Fr.doc.content.size), ai = ri > 0 && this.state.doc.nodeAt(ri);
          ai == Vr.node && (Wr = ri);
        }
        this.dragging = new jl(Rr.slice, Rr.move, Wr < 0 ? void 0 : Tr.NodeSelection.create(this.state.doc, Wr));
      }
    }, {
      key: "someProp",
      value: function(Rr, Fr) {
        var Vr = this._props && this._props[Rr], Wr;
        if (Vr != null && (Wr = Fr ? Fr(Vr) : Vr))
          return Wr;
        for (var ri = 0; ri < this.directPlugins.length; ri++) {
          var ai = this.directPlugins[ri].props[Rr];
          if (ai != null && (Wr = Fr ? Fr(ai) : ai))
            return Wr;
        }
        var hi = this.state.plugins;
        if (hi)
          for (var wi = 0; wi < hi.length; wi++) {
            var Oi = hi[wi].props[Rr];
            if (Oi != null && (Wr = Fr ? Fr(Oi) : Oi))
              return Wr;
          }
      }
    }, {
      key: "hasFocus",
      value: function() {
        if (qi) {
          var Rr = this.root.activeElement;
          if (Rr == this.dom)
            return !0;
          if (!Rr || !this.dom.contains(Rr))
            return !1;
          for (; Rr && this.dom != Rr && this.dom.contains(Rr); ) {
            if (Rr.contentEditable == "false")
              return !1;
            Rr = Rr.parentElement;
          }
          return !0;
        }
        return this.root.activeElement == this.dom;
      }
    }, {
      key: "focus",
      value: function() {
        this.domObserver.stop(), this.editable && $a(this.dom), Ho(this), this.domObserver.start();
      }
    }, {
      key: "root",
      get: function() {
        var Rr = this, Fr = this._root;
        if (Fr == null)
          for (var Vr = function(hi) {
            if (hi.nodeType == 9 || hi.nodeType == 11 && hi.host)
              return hi.getSelection || (Object.getPrototypeOf(hi).getSelection = function() {
                return hi.ownerDocument.getSelection();
              }), {
                v: Rr._root = hi
              };
          }, Wr = this.dom.parentNode; Wr; Wr = Wr.parentNode) {
            var ri = Vr(Wr);
            if (lr(ri) === "object")
              return ri.v;
          }
        return Fr || document;
      }
    }, {
      key: "updateRoot",
      value: function() {
        this._root = null;
      }
    }, {
      key: "posAtCoords",
      value: function(Rr) {
        return za(this, Rr);
      }
    }, {
      key: "coordsAtPos",
      value: function(Rr) {
        var Fr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return Ka(this, Rr, Fr);
      }
    }, {
      key: "domAtPos",
      value: function(Rr) {
        var Fr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.docView.domFromPos(Rr, Fr);
      }
    }, {
      key: "nodeDOM",
      value: function(Rr) {
        var Fr = this.docView.descAt(Rr);
        return Fr ? Fr.nodeDOM : null;
      }
    }, {
      key: "posAtDOM",
      value: function(Rr, Fr) {
        var Vr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, Wr = this.docView.posFromDOM(Rr, Fr, Vr);
        if (Wr == null)
          throw new RangeError("DOM position not inside the editor");
        return Wr;
      }
    }, {
      key: "endOfTextblock",
      value: function(Rr, Fr) {
        return Ya(this, Fr || this.state, Rr);
      }
    }, {
      key: "pasteHTML",
      value: function(Rr, Fr) {
        return rl(this, "", Rr, !1, Fr || new ClipboardEvent("paste"));
      }
    }, {
      key: "pasteText",
      value: function(Rr, Fr) {
        return rl(this, Rr, null, !0, Fr || new ClipboardEvent("paste"));
      }
    }, {
      key: "destroy",
      value: function() {
        this.docView && (Lc(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Rl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
      }
    }, {
      key: "isDestroyed",
      get: function() {
        return this.docView == null;
      }
    }, {
      key: "dispatchEvent",
      value: function(Rr) {
        return Mc(this, Rr);
      }
    }, {
      key: "dispatch",
      value: function(Rr) {
        var Fr = this._props.dispatchTransaction;
        Fr ? Fr.call(this, Rr) : this.updateState(this.state.apply(Rr));
      }
    }, {
      key: "domSelectionRange",
      value: function() {
        return bi && this.root.nodeType === 11 && fi(this.dom.ownerDocument) == this.dom ? eu(this) : this.domSelection();
      }
    }, {
      key: "domSelection",
      value: function() {
        return this.root.getSelection();
      }
    }]), Lr;
  }();
  function nc(Lr) {
    var jr = /* @__PURE__ */ Object.create(null);
    return jr.class = "ProseMirror", jr.contenteditable = String(Lr.editable), Lr.someProp("attributes", function(Rr) {
      if (typeof Rr == "function" && (Rr = Rr(Lr.state)), Rr)
        for (var Fr in Rr)
          Fr == "class" ? jr.class += " " + Rr[Fr] : Fr == "style" ? jr.style = (jr.style ? jr.style + ";" : "") + Rr[Fr] : !jr[Fr] && Fr != "contenteditable" && Fr != "nodeName" && (jr[Fr] = String(Rr[Fr]));
    }), jr.translate || (jr.translate = "no"), [_s.node(0, Lr.state.doc.content.size, jr)];
  }
  function oc(Lr) {
    if (Lr.markCursor) {
      var jr = document.createElement("img");
      jr.className = "ProseMirror-separator", jr.setAttribute("mark-placeholder", "true"), jr.setAttribute("alt", ""), Lr.cursorWrapper = {
        dom: jr,
        deco: _s.widget(Lr.state.selection.head, jr, {
          raw: !0,
          marks: Lr.markCursor
        })
      };
    } else
      Lr.cursorWrapper = null;
  }
  function lc(Lr) {
    return !Lr.someProp("editable", function(jr) {
      return jr(Lr.state) === !1;
    });
  }
  function hu(Lr, jr) {
    var Rr = Math.min(Lr.$anchor.sharedDepth(Lr.head), jr.$anchor.sharedDepth(jr.head));
    return Lr.$anchor.start(Rr) != jr.$anchor.start(Rr);
  }
  function cc(Lr) {
    var jr = /* @__PURE__ */ Object.create(null);
    function Rr(Fr) {
      for (var Vr in Fr)
        Object.prototype.hasOwnProperty.call(jr, Vr) || (jr[Vr] = Fr[Vr]);
    }
    return Lr.someProp("nodeViews", Rr), Lr.someProp("markViews", Rr), jr;
  }
  function pu(Lr, jr) {
    var Rr = 0, Fr = 0;
    for (var Vr in Lr) {
      if (Lr[Vr] != jr[Vr])
        return !0;
      Rr++;
    }
    for (var Wr in jr)
      Fr++;
    return Rr != Fr;
  }
  function uc(Lr) {
    if (Lr.spec.state || Lr.spec.filterTransaction || Lr.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  return dist$5.Decoration = _s, dist$5.DecorationSet = jo, dist$5.EditorView = du, dist$5.__endComposition = fu, dist$5.__parseFromClipboard = uu, dist$5.__serializeForClipboard = cu, dist$5;
}
var distExports$4 = requireDist$3(), distExports$3 = requireDist$4(), dist$2 = {}, w3cKeyname = {}, hasRequiredW3cKeyname;
function requireW3cKeyname() {
  if (hasRequiredW3cKeyname)
    return w3cKeyname;
  hasRequiredW3cKeyname = 1, Object.defineProperty(w3cKeyname, "__esModule", { value: !0 });
  for (var lr = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, ar = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, cr = typeof navigator != "undefined" && /Mac/.test(navigator.platform), ur = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), fr = 0; fr < 10; fr++)
    lr[48 + fr] = lr[96 + fr] = String(fr);
  for (var fr = 1; fr <= 24; fr++)
    lr[fr + 111] = "F" + fr;
  for (var fr = 65; fr <= 90; fr++)
    lr[fr] = String.fromCharCode(fr + 32), ar[fr] = String.fromCharCode(fr);
  for (var dr in lr)
    ar.hasOwnProperty(dr) || (ar[dr] = lr[dr]);
  function gr(mr) {
    var vr = cr && mr.metaKey && mr.shiftKey && !mr.ctrlKey && !mr.altKey || ur && mr.shiftKey && mr.key && mr.key.length == 1 || mr.key == "Unidentified", yr = !vr && mr.key || (mr.shiftKey ? ar : lr)[mr.keyCode] || mr.key || "Unidentified";
    return yr == "Esc" && (yr = "Escape"), yr == "Del" && (yr = "Delete"), yr == "Left" && (yr = "ArrowLeft"), yr == "Up" && (yr = "ArrowUp"), yr == "Right" && (yr = "ArrowRight"), yr == "Down" && (yr = "ArrowDown"), yr;
  }
  return w3cKeyname.base = lr, w3cKeyname.keyName = gr, w3cKeyname.shift = ar, w3cKeyname;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2)
    return dist$2;
  hasRequiredDist$2 = 1, Object.defineProperty(dist$2, "__esModule", {
    value: !0
  });
  var lr = requireW3cKeyname(), ar = requireDist$4(), cr = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
  function ur(vr) {
    var yr = vr.split(/-(?!$)/), kr = yr[yr.length - 1];
    kr == "Space" && (kr = " ");
    for (var _r, xr, Sr, Er, Cr = 0; Cr < yr.length - 1; Cr++) {
      var Tr = yr[Cr];
      if (/^(cmd|meta|m)$/i.test(Tr))
        Er = !0;
      else if (/^a(lt)?$/i.test(Tr))
        _r = !0;
      else if (/^(c|ctrl|control)$/i.test(Tr))
        xr = !0;
      else if (/^s(hift)?$/i.test(Tr))
        Sr = !0;
      else if (/^mod$/i.test(Tr))
        cr ? Er = !0 : xr = !0;
      else
        throw new Error("Unrecognized modifier name: " + Tr);
    }
    return _r && (kr = "Alt-" + kr), xr && (kr = "Ctrl-" + kr), Er && (kr = "Meta-" + kr), Sr && (kr = "Shift-" + kr), kr;
  }
  function fr(vr) {
    var yr = /* @__PURE__ */ Object.create(null);
    for (var kr in vr)
      yr[ur(kr)] = vr[kr];
    return yr;
  }
  function dr(vr, yr) {
    var kr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return yr.altKey && (vr = "Alt-" + vr), yr.ctrlKey && (vr = "Ctrl-" + vr), yr.metaKey && (vr = "Meta-" + vr), kr && yr.shiftKey && (vr = "Shift-" + vr), vr;
  }
  function gr(vr) {
    return new ar.Plugin({
      props: {
        handleKeyDown: mr(vr)
      }
    });
  }
  function mr(vr) {
    var yr = fr(vr);
    return function(kr, _r) {
      var xr = lr.keyName(_r), Sr, Er = yr[dr(xr, _r)];
      if (Er && Er(kr.state, kr.dispatch, kr))
        return !0;
      if (xr.length == 1 && xr != " ") {
        if (_r.shiftKey) {
          var Cr = yr[dr(xr, _r, !1)];
          if (Cr && Cr(kr.state, kr.dispatch, kr))
            return !0;
        }
        if ((_r.shiftKey || _r.altKey || _r.metaKey || xr.charCodeAt(0) > 127) && (Sr = lr.base[_r.keyCode]) && Sr != xr) {
          var Tr = yr[dr(Sr, _r)];
          if (Tr && Tr(kr.state, kr.dispatch, kr))
            return !0;
        }
      }
      return !1;
    };
  }
  return dist$2.keydownHandler = mr, dist$2.keymap = gr, dist$2;
}
var distExports$2 = requireDist$2();
const deleteSelection = (lr, ar) => lr.selection.empty ? !1 : (ar && ar(lr.tr.deleteSelection().scrollIntoView()), !0);
function atBlockStart(lr, ar) {
  let { $cursor: cr } = lr.selection;
  return !cr || (ar ? !ar.endOfTextblock("backward", lr) : cr.parentOffset > 0) ? null : cr;
}
const joinBackward = (lr, ar, cr) => {
  let ur = atBlockStart(lr, cr);
  if (!ur)
    return !1;
  let fr = findCutBefore(ur);
  if (!fr) {
    let gr = ur.blockRange(), mr = gr && liftTarget(gr);
    return mr == null ? !1 : (ar && ar(lr.tr.lift(gr, mr).scrollIntoView()), !0);
  }
  let dr = fr.nodeBefore;
  if (!dr.type.spec.isolating && deleteBarrier(lr, fr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(dr, "end") || distExports$3.NodeSelection.isSelectable(dr))) {
    let gr = replaceStep(lr.doc, ur.before(), ur.after(), distExports$5.Slice.empty);
    if (gr && gr.slice.size < gr.to - gr.from) {
      if (ar) {
        let mr = lr.tr.step(gr);
        mr.setSelection(textblockAt(dr, "end") ? distExports$3.Selection.findFrom(mr.doc.resolve(mr.mapping.map(fr.pos, -1)), -1) : distExports$3.NodeSelection.create(mr.doc, fr.pos - dr.nodeSize)), ar(mr.scrollIntoView());
      }
      return !0;
    }
  }
  return dr.isAtom && fr.depth == ur.depth - 1 ? (ar && ar(lr.tr.delete(fr.pos - dr.nodeSize, fr.pos).scrollIntoView()), !0) : !1;
};
function textblockAt(lr, ar, cr = !1) {
  for (let ur = lr; ur; ur = ar == "start" ? ur.firstChild : ur.lastChild) {
    if (ur.isTextblock)
      return !0;
    if (cr && ur.childCount != 1)
      return !1;
  }
  return !1;
}
const selectNodeBackward = (lr, ar, cr) => {
  let { $head: ur, empty: fr } = lr.selection, dr = ur;
  if (!fr)
    return !1;
  if (ur.parent.isTextblock) {
    if (cr ? !cr.endOfTextblock("backward", lr) : ur.parentOffset > 0)
      return !1;
    dr = findCutBefore(ur);
  }
  let gr = dr && dr.nodeBefore;
  return !gr || !distExports$3.NodeSelection.isSelectable(gr) ? !1 : (ar && ar(lr.tr.setSelection(distExports$3.NodeSelection.create(lr.doc, dr.pos - gr.nodeSize)).scrollIntoView()), !0);
};
function findCutBefore(lr) {
  if (!lr.parent.type.spec.isolating)
    for (let ar = lr.depth - 1; ar >= 0; ar--) {
      if (lr.index(ar) > 0)
        return lr.doc.resolve(lr.before(ar + 1));
      if (lr.node(ar).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(lr, ar) {
  let { $cursor: cr } = lr.selection;
  return !cr || (ar ? !ar.endOfTextblock("forward", lr) : cr.parentOffset < cr.parent.content.size) ? null : cr;
}
const joinForward = (lr, ar, cr) => {
  let ur = atBlockEnd(lr, cr);
  if (!ur)
    return !1;
  let fr = findCutAfter(ur);
  if (!fr)
    return !1;
  let dr = fr.nodeAfter;
  if (deleteBarrier(lr, fr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(dr, "start") || distExports$3.NodeSelection.isSelectable(dr))) {
    let gr = replaceStep(lr.doc, ur.before(), ur.after(), distExports$5.Slice.empty);
    if (gr && gr.slice.size < gr.to - gr.from) {
      if (ar) {
        let mr = lr.tr.step(gr);
        mr.setSelection(textblockAt(dr, "start") ? distExports$3.Selection.findFrom(mr.doc.resolve(mr.mapping.map(fr.pos)), 1) : distExports$3.NodeSelection.create(mr.doc, mr.mapping.map(fr.pos))), ar(mr.scrollIntoView());
      }
      return !0;
    }
  }
  return dr.isAtom && fr.depth == ur.depth - 1 ? (ar && ar(lr.tr.delete(fr.pos, fr.pos + dr.nodeSize).scrollIntoView()), !0) : !1;
}, selectNodeForward = (lr, ar, cr) => {
  let { $head: ur, empty: fr } = lr.selection, dr = ur;
  if (!fr)
    return !1;
  if (ur.parent.isTextblock) {
    if (cr ? !cr.endOfTextblock("forward", lr) : ur.parentOffset < ur.parent.content.size)
      return !1;
    dr = findCutAfter(ur);
  }
  let gr = dr && dr.nodeAfter;
  return !gr || !distExports$3.NodeSelection.isSelectable(gr) ? !1 : (ar && ar(lr.tr.setSelection(distExports$3.NodeSelection.create(lr.doc, dr.pos)).scrollIntoView()), !0);
};
function findCutAfter(lr) {
  if (!lr.parent.type.spec.isolating)
    for (let ar = lr.depth - 1; ar >= 0; ar--) {
      let cr = lr.node(ar);
      if (lr.index(ar) + 1 < cr.childCount)
        return lr.doc.resolve(lr.after(ar + 1));
      if (cr.type.spec.isolating)
        break;
    }
  return null;
}
const newlineInCode = (lr, ar) => {
  let { $head: cr, $anchor: ur } = lr.selection;
  return !cr.parent.type.spec.code || !cr.sameParent(ur) ? !1 : (ar && ar(lr.tr.insertText(`
`).scrollIntoView()), !0);
};
function defaultBlockAt(lr) {
  for (let ar = 0; ar < lr.edgeCount; ar++) {
    let { type: cr } = lr.edge(ar);
    if (cr.isTextblock && !cr.hasRequiredAttrs())
      return cr;
  }
  return null;
}
const exitCode = (lr, ar) => {
  let { $head: cr, $anchor: ur } = lr.selection;
  if (!cr.parent.type.spec.code || !cr.sameParent(ur))
    return !1;
  let fr = cr.node(-1), dr = cr.indexAfter(-1), gr = defaultBlockAt(fr.contentMatchAt(dr));
  if (!gr || !fr.canReplaceWith(dr, dr, gr))
    return !1;
  if (ar) {
    let mr = cr.after(), vr = lr.tr.replaceWith(mr, mr, gr.createAndFill());
    vr.setSelection(distExports$3.Selection.near(vr.doc.resolve(mr), 1)), ar(vr.scrollIntoView());
  }
  return !0;
}, createParagraphNear = (lr, ar) => {
  let cr = lr.selection, { $from: ur, $to: fr } = cr;
  if (cr instanceof distExports$3.AllSelection || ur.parent.inlineContent || fr.parent.inlineContent)
    return !1;
  let dr = defaultBlockAt(fr.parent.contentMatchAt(fr.indexAfter()));
  if (!dr || !dr.isTextblock)
    return !1;
  if (ar) {
    let gr = (!ur.parentOffset && fr.index() < fr.parent.childCount ? ur : fr).pos, mr = lr.tr.insert(gr, dr.createAndFill());
    mr.setSelection(distExports$3.TextSelection.create(mr.doc, gr + 1)), ar(mr.scrollIntoView());
  }
  return !0;
}, liftEmptyBlock = (lr, ar) => {
  let { $cursor: cr } = lr.selection;
  if (!cr || cr.parent.content.size)
    return !1;
  if (cr.depth > 1 && cr.after() != cr.end(-1)) {
    let dr = cr.before();
    if (canSplit(lr.doc, dr))
      return ar && ar(lr.tr.split(dr).scrollIntoView()), !0;
  }
  let ur = cr.blockRange(), fr = ur && liftTarget(ur);
  return fr == null ? !1 : (ar && ar(lr.tr.lift(ur, fr).scrollIntoView()), !0);
};
function splitBlockAs(lr) {
  return (ar, cr) => {
    let { $from: ur, $to: fr } = ar.selection;
    if (ar.selection instanceof distExports$3.NodeSelection && ar.selection.node.isBlock)
      return !ur.parentOffset || !canSplit(ar.doc, ur.pos) ? !1 : (cr && cr(ar.tr.split(ur.pos).scrollIntoView()), !0);
    if (!ur.parent.isBlock)
      return !1;
    if (cr) {
      let dr = fr.parentOffset == fr.parent.content.size, gr = ar.tr;
      (ar.selection instanceof distExports$3.TextSelection || ar.selection instanceof distExports$3.AllSelection) && gr.deleteSelection();
      let mr = ur.depth == 0 ? null : defaultBlockAt(ur.node(-1).contentMatchAt(ur.indexAfter(-1))), vr = lr && lr(fr.parent, dr), yr = vr ? [vr] : dr && mr ? [{ type: mr }] : void 0, kr = canSplit(gr.doc, gr.mapping.map(ur.pos), 1, yr);
      if (!yr && !kr && canSplit(gr.doc, gr.mapping.map(ur.pos), 1, mr ? [{ type: mr }] : void 0) && (mr && (yr = [{ type: mr }]), kr = !0), kr && (gr.split(gr.mapping.map(ur.pos), 1, yr), !dr && !ur.parentOffset && ur.parent.type != mr)) {
        let _r = gr.mapping.map(ur.before()), xr = gr.doc.resolve(_r);
        mr && ur.node(-1).canReplaceWith(xr.index(), xr.index() + 1, mr) && gr.setNodeMarkup(gr.mapping.map(ur.before()), mr);
      }
      cr(gr.scrollIntoView());
    }
    return !0;
  };
}
const splitBlock = splitBlockAs(), selectAll = (lr, ar) => (ar && ar(lr.tr.setSelection(new distExports$3.AllSelection(lr.doc))), !0);
function joinMaybeClear(lr, ar, cr) {
  let ur = ar.nodeBefore, fr = ar.nodeAfter, dr = ar.index();
  return !ur || !fr || !ur.type.compatibleContent(fr.type) ? !1 : !ur.content.size && ar.parent.canReplace(dr - 1, dr) ? (cr && cr(lr.tr.delete(ar.pos - ur.nodeSize, ar.pos).scrollIntoView()), !0) : !ar.parent.canReplace(dr, dr + 1) || !(fr.isTextblock || canJoin(lr.doc, ar.pos)) ? !1 : (cr && cr(lr.tr.clearIncompatible(ar.pos, ur.type, ur.contentMatchAt(ur.childCount)).join(ar.pos).scrollIntoView()), !0);
}
function deleteBarrier(lr, ar, cr) {
  let ur = ar.nodeBefore, fr = ar.nodeAfter, dr, gr;
  if (ur.type.spec.isolating || fr.type.spec.isolating)
    return !1;
  if (joinMaybeClear(lr, ar, cr))
    return !0;
  let mr = ar.parent.canReplace(ar.index(), ar.index() + 1);
  if (mr && (dr = (gr = ur.contentMatchAt(ur.childCount)).findWrapping(fr.type)) && gr.matchType(dr[0] || fr.type).validEnd) {
    if (cr) {
      let _r = ar.pos + fr.nodeSize, xr = distExports$5.Fragment.empty;
      for (let Cr = dr.length - 1; Cr >= 0; Cr--)
        xr = distExports$5.Fragment.from(dr[Cr].create(null, xr));
      xr = distExports$5.Fragment.from(ur.copy(xr));
      let Sr = lr.tr.step(new ReplaceAroundStep(ar.pos - 1, _r, ar.pos, _r, new distExports$5.Slice(xr, 1, 0), dr.length, !0)), Er = _r + 2 * dr.length;
      canJoin(Sr.doc, Er) && Sr.join(Er), cr(Sr.scrollIntoView());
    }
    return !0;
  }
  let vr = distExports$3.Selection.findFrom(ar, 1), yr = vr && vr.$from.blockRange(vr.$to), kr = yr && liftTarget(yr);
  if (kr != null && kr >= ar.depth)
    return cr && cr(lr.tr.lift(yr, kr).scrollIntoView()), !0;
  if (mr && textblockAt(fr, "start", !0) && textblockAt(ur, "end")) {
    let _r = ur, xr = [];
    for (; xr.push(_r), !_r.isTextblock; )
      _r = _r.lastChild;
    let Sr = fr, Er = 1;
    for (; !Sr.isTextblock; Sr = Sr.firstChild)
      Er++;
    if (_r.canReplace(_r.childCount, _r.childCount, Sr.content)) {
      if (cr) {
        let Cr = distExports$5.Fragment.empty;
        for (let Ar = xr.length - 1; Ar >= 0; Ar--)
          Cr = distExports$5.Fragment.from(xr[Ar].copy(Cr));
        let Tr = lr.tr.step(new ReplaceAroundStep(ar.pos - xr.length, ar.pos + fr.nodeSize, ar.pos + Er, ar.pos + fr.nodeSize - Er, new distExports$5.Slice(Cr, xr.length, 0), 0, !0));
        cr(Tr.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function selectTextblockSide(lr) {
  return function(ar, cr) {
    let ur = ar.selection, fr = lr < 0 ? ur.$from : ur.$to, dr = fr.depth;
    for (; fr.node(dr).isInline; ) {
      if (!dr)
        return !1;
      dr--;
    }
    return fr.node(dr).isTextblock ? (cr && cr(ar.tr.setSelection(distExports$3.TextSelection.create(ar.doc, lr < 0 ? fr.start(dr) : fr.end(dr)))), !0) : !1;
  };
}
const selectTextblockStart = selectTextblockSide(-1), selectTextblockEnd = selectTextblockSide(1);
function wrapIn(lr, ar = null) {
  return function(cr, ur) {
    let { $from: fr, $to: dr } = cr.selection, gr = fr.blockRange(dr), mr = gr && findWrapping(gr, lr, ar);
    return mr ? (ur && ur(cr.tr.wrap(gr, mr).scrollIntoView()), !0) : !1;
  };
}
function setBlockType(lr, ar = null) {
  return function(cr, ur) {
    let fr = !1;
    for (let dr = 0; dr < cr.selection.ranges.length && !fr; dr++) {
      let { $from: { pos: gr }, $to: { pos: mr } } = cr.selection.ranges[dr];
      cr.doc.nodesBetween(gr, mr, (vr, yr) => {
        if (fr)
          return !1;
        if (!(!vr.isTextblock || vr.hasMarkup(lr, ar)))
          if (vr.type == lr)
            fr = !0;
          else {
            let kr = cr.doc.resolve(yr), _r = kr.index();
            fr = kr.parent.canReplaceWith(_r, _r + 1, lr);
          }
      });
    }
    if (!fr)
      return !1;
    if (ur) {
      let dr = cr.tr;
      for (let gr = 0; gr < cr.selection.ranges.length; gr++) {
        let { $from: { pos: mr }, $to: { pos: vr } } = cr.selection.ranges[gr];
        dr.setBlockType(mr, vr, lr, ar);
      }
      ur(dr.scrollIntoView());
    }
    return !0;
  };
}
function markApplies(lr, ar, cr) {
  for (let ur = 0; ur < ar.length; ur++) {
    let { $from: fr, $to: dr } = ar[ur], gr = fr.depth == 0 ? lr.inlineContent && lr.type.allowsMarkType(cr) : !1;
    if (lr.nodesBetween(fr.pos, dr.pos, (mr) => {
      if (gr)
        return !1;
      gr = mr.inlineContent && mr.type.allowsMarkType(cr);
    }), gr)
      return !0;
  }
  return !1;
}
function toggleMark$1(lr, ar = null) {
  return function(cr, ur) {
    let { empty: fr, $cursor: dr, ranges: gr } = cr.selection;
    if (fr && !dr || !markApplies(cr.doc, gr, lr))
      return !1;
    if (ur)
      if (dr)
        lr.isInSet(cr.storedMarks || dr.marks()) ? ur(cr.tr.removeStoredMark(lr)) : ur(cr.tr.addStoredMark(lr.create(ar)));
      else {
        let mr = !1, vr = cr.tr;
        for (let yr = 0; !mr && yr < gr.length; yr++) {
          let { $from: kr, $to: _r } = gr[yr];
          mr = cr.doc.rangeHasMark(kr.pos, _r.pos, lr);
        }
        for (let yr = 0; yr < gr.length; yr++) {
          let { $from: kr, $to: _r } = gr[yr];
          if (mr)
            vr.removeMark(kr.pos, _r.pos, lr);
          else {
            let xr = kr.pos, Sr = _r.pos, Er = kr.nodeAfter, Cr = _r.nodeBefore, Tr = Er && Er.isText ? /^\s*/.exec(Er.text)[0].length : 0, Ar = Cr && Cr.isText ? /\s*$/.exec(Cr.text)[0].length : 0;
            xr + Tr < Sr && (xr += Tr, Sr -= Ar), vr.addMark(xr, Sr, lr.create(ar));
          }
        }
        ur(vr.scrollIntoView());
      }
    return !0;
  };
}
function chainCommands(...lr) {
  return function(ar, cr, ur) {
    for (let fr = 0; fr < lr.length; fr++)
      if (lr[fr](ar, cr, ur))
        return !0;
    return !1;
  };
}
let backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward), del = chainCommands(deleteSelection, joinForward, selectNodeForward);
const pcBaseKeymap = {
  Enter: chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  Backspace: backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  Delete: del,
  "Mod-Delete": del,
  "Mod-a": selectAll
}, macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap.Backspace,
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap.Delete,
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let lr in pcBaseKeymap)
  macBaseKeymap[lr] = pcBaseKeymap[lr];
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : !1, baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
var dist$1 = {}, hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1)
    return dist$1;
  hasRequiredDist$1 = 1;
  function lr(Hr, Br) {
    for (var zr = 0; zr < Br.length; zr++) {
      var Gr = Br[zr];
      Gr.enumerable = Gr.enumerable || !1, Gr.configurable = !0, "value" in Gr && (Gr.writable = !0), Object.defineProperty(Hr, Gr.key, Gr);
    }
  }
  function ar(Hr, Br, zr) {
    return Br && lr(Hr.prototype, Br), zr && lr(Hr, zr), Object.defineProperty(Hr, "prototype", { writable: !1 }), Hr;
  }
  function cr(Hr, Br) {
    if (!(Hr instanceof Br))
      throw new TypeError("Cannot call a class as a function");
  }
  var ur = requireDist$4(), fr = require$$1$2, dr = ar(function Hr(Br, zr) {
    var Gr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    cr(this, Hr), this.match = Br, this.match = Br, this.handler = typeof zr == "string" ? gr(zr) : zr, this.undoable = Gr.undoable !== !1;
  });
  function gr(Hr) {
    return function(Br, zr, Gr, Xr) {
      var Jr = Hr;
      if (zr[1]) {
        var li = zr[0].lastIndexOf(zr[1]);
        Jr += zr[0].slice(li + zr[1].length), Gr += li;
        var Qr = Gr - Xr;
        Qr > 0 && (Jr = zr[0].slice(li - Qr, li) + Jr, Gr = Xr);
      }
      return Br.tr.insertText(Jr, Gr, Xr);
    };
  }
  var mr = 500;
  function vr(Hr) {
    var Br = Hr.rules, zr = new ur.Plugin({
      state: {
        init: function() {
          return null;
        },
        apply: function(Xr, Jr) {
          var li = Xr.getMeta(this);
          return li || (Xr.selectionSet || Xr.docChanged ? null : Jr);
        }
      },
      props: {
        handleTextInput: function(Xr, Jr, li, Qr) {
          return yr(Xr, Jr, li, Qr, Br, zr);
        },
        handleDOMEvents: {
          compositionend: function(Xr) {
            setTimeout(function() {
              var Jr = Xr.state.selection.$cursor;
              Jr && yr(Xr, Jr.pos, Jr.pos, "", Br, zr);
            });
          }
        }
      },
      isInputRules: !0
    });
    return zr;
  }
  function yr(Hr, Br, zr, Gr, Xr, Jr) {
    if (Hr.composing)
      return !1;
    var li = Hr.state, Qr = li.doc.resolve(Br);
    if (Qr.parent.type.spec.code)
      return !1;
    for (var ei = Qr.parent.textBetween(Math.max(0, Qr.parentOffset - mr), Qr.parentOffset, null, "￼") + Gr, ui = 0; ui < Xr.length; ui++) {
      var Ai = Xr[ui], fi = Ai.match.exec(ei), gi = fi && Ai.handler(li, fi, Br - (fi[0].length - Gr.length), zr);
      if (gi)
        return Ai.undoable && gi.setMeta(Jr, {
          transform: gi,
          from: Br,
          to: zr,
          text: Gr
        }), Hr.dispatch(gi), !0;
    }
    return !1;
  }
  var kr = function(Br, zr) {
    for (var Gr = Br.plugins, Xr = 0; Xr < Gr.length; Xr++) {
      var Jr = Gr[Xr], li = void 0;
      if (Jr.spec.isInputRules && (li = Jr.getState(Br))) {
        if (zr) {
          for (var Qr = Br.tr, ei = li.transform, ui = ei.steps.length - 1; ui >= 0; ui--)
            Qr.step(ei.steps[ui].invert(ei.docs[ui]));
          if (li.text) {
            var Ai = Qr.doc.resolve(li.from).marks();
            Qr.replaceWith(li.from, li.to, Br.schema.text(li.text, Ai));
          } else
            Qr.delete(li.from, li.to);
          zr(Qr);
        }
        return !0;
      }
    }
    return !1;
  }, _r = new dr(/--$/, "—"), xr = new dr(/\.\.\.$/, "…"), Sr = new dr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"), Er = new dr(/"$/, "”"), Cr = new dr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"), Tr = new dr(/'$/, "’"), Ar = [Sr, Er, Cr, Tr];
  function Ir(Hr, Br) {
    var zr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, Gr = arguments.length > 3 ? arguments[3] : void 0;
    return new dr(Hr, function(Xr, Jr, li, Qr) {
      var ei = zr instanceof Function ? zr(Jr) : zr, ui = Xr.tr.delete(li, Qr), Ai = ui.doc.resolve(li), fi = Ai.blockRange(), gi = fi && fr.findWrapping(fi, Br, ei);
      if (!gi)
        return null;
      ui.wrap(fi, gi);
      var Ci = ui.doc.resolve(li - 1).nodeBefore;
      return Ci && Ci.type == Br && fr.canJoin(ui.doc, li - 1) && (!Gr || Gr(Jr, Ci)) && ui.join(li - 1), ui;
    });
  }
  function Mr(Hr, Br) {
    var zr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return new dr(Hr, function(Gr, Xr, Jr, li) {
      var Qr = Gr.doc.resolve(Jr), ei = zr instanceof Function ? zr(Xr) : zr;
      return Qr.node(-1).canReplaceWith(Qr.index(-1), Qr.indexAfter(-1), Br) ? Gr.tr.delete(Jr, li).setBlockType(Jr, Jr, Br, ei) : null;
    });
  }
  return dist$1.InputRule = dr, dist$1.closeDoubleQuote = Er, dist$1.closeSingleQuote = Tr, dist$1.ellipsis = xr, dist$1.emDash = _r, dist$1.inputRules = vr, dist$1.openDoubleQuote = Sr, dist$1.openSingleQuote = Cr, dist$1.smartQuotes = Ar, dist$1.textblockTypeInputRule = Mr, dist$1.undoInputRule = kr, dist$1.wrappingInputRule = Ir, dist$1;
}
var distExports$1 = requireDist$1(), GOOD_LEAF_SIZE = 200, RopeSequence = function lr() {
};
RopeSequence.prototype.append = function lr(ar) {
  return ar.length ? (ar = RopeSequence.from(ar), !this.length && ar || ar.length < GOOD_LEAF_SIZE && this.leafAppend(ar) || this.length < GOOD_LEAF_SIZE && ar.leafPrepend(this) || this.appendInner(ar)) : this;
};
RopeSequence.prototype.prepend = function lr(ar) {
  return ar.length ? RopeSequence.from(ar).append(this) : this;
};
RopeSequence.prototype.appendInner = function lr(ar) {
  return new Append(this, ar);
};
RopeSequence.prototype.slice = function lr(ar, cr) {
  return ar === void 0 && (ar = 0), cr === void 0 && (cr = this.length), ar >= cr ? RopeSequence.empty : this.sliceInner(Math.max(0, ar), Math.min(this.length, cr));
};
RopeSequence.prototype.get = function lr(ar) {
  if (!(ar < 0 || ar >= this.length))
    return this.getInner(ar);
};
RopeSequence.prototype.forEach = function lr(ar, cr, ur) {
  cr === void 0 && (cr = 0), ur === void 0 && (ur = this.length), cr <= ur ? this.forEachInner(ar, cr, ur, 0) : this.forEachInvertedInner(ar, cr, ur, 0);
};
RopeSequence.prototype.map = function lr(ar, cr, ur) {
  cr === void 0 && (cr = 0), ur === void 0 && (ur = this.length);
  var fr = [];
  return this.forEach(function(dr, gr) {
    return fr.push(ar(dr, gr));
  }, cr, ur), fr;
};
RopeSequence.from = function lr(ar) {
  return ar instanceof RopeSequence ? ar : ar && ar.length ? new Leaf(ar) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(lr) {
  function ar(ur) {
    lr.call(this), this.values = ur;
  }
  lr && (ar.__proto__ = lr), ar.prototype = Object.create(lr && lr.prototype), ar.prototype.constructor = ar;
  var cr = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return ar.prototype.flatten = function() {
    return this.values;
  }, ar.prototype.sliceInner = function(fr, dr) {
    return fr == 0 && dr == this.length ? this : new ar(this.values.slice(fr, dr));
  }, ar.prototype.getInner = function(fr) {
    return this.values[fr];
  }, ar.prototype.forEachInner = function(fr, dr, gr, mr) {
    for (var vr = dr; vr < gr; vr++)
      if (fr(this.values[vr], mr + vr) === !1)
        return !1;
  }, ar.prototype.forEachInvertedInner = function(fr, dr, gr, mr) {
    for (var vr = dr - 1; vr >= gr; vr--)
      if (fr(this.values[vr], mr + vr) === !1)
        return !1;
  }, ar.prototype.leafAppend = function(fr) {
    if (this.length + fr.length <= GOOD_LEAF_SIZE)
      return new ar(this.values.concat(fr.flatten()));
  }, ar.prototype.leafPrepend = function(fr) {
    if (this.length + fr.length <= GOOD_LEAF_SIZE)
      return new ar(fr.flatten().concat(this.values));
  }, cr.length.get = function() {
    return this.values.length;
  }, cr.depth.get = function() {
    return 0;
  }, Object.defineProperties(ar.prototype, cr), ar;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(lr) {
  function ar(cr, ur) {
    lr.call(this), this.left = cr, this.right = ur, this.length = cr.length + ur.length, this.depth = Math.max(cr.depth, ur.depth) + 1;
  }
  return lr && (ar.__proto__ = lr), ar.prototype = Object.create(lr && lr.prototype), ar.prototype.constructor = ar, ar.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, ar.prototype.getInner = function(ur) {
    return ur < this.left.length ? this.left.get(ur) : this.right.get(ur - this.left.length);
  }, ar.prototype.forEachInner = function(ur, fr, dr, gr) {
    var mr = this.left.length;
    if (fr < mr && this.left.forEachInner(ur, fr, Math.min(dr, mr), gr) === !1 || dr > mr && this.right.forEachInner(ur, Math.max(fr - mr, 0), Math.min(this.length, dr) - mr, gr + mr) === !1)
      return !1;
  }, ar.prototype.forEachInvertedInner = function(ur, fr, dr, gr) {
    var mr = this.left.length;
    if (fr > mr && this.right.forEachInvertedInner(ur, fr - mr, Math.max(dr, mr) - mr, gr + mr) === !1 || dr < mr && this.left.forEachInvertedInner(ur, Math.min(fr, mr), dr, gr) === !1)
      return !1;
  }, ar.prototype.sliceInner = function(ur, fr) {
    if (ur == 0 && fr == this.length)
      return this;
    var dr = this.left.length;
    return fr <= dr ? this.left.slice(ur, fr) : ur >= dr ? this.right.slice(ur - dr, fr - dr) : this.left.slice(ur, dr).append(this.right.slice(0, fr - dr));
  }, ar.prototype.leafAppend = function(ur) {
    var fr = this.right.leafAppend(ur);
    if (fr)
      return new ar(this.left, fr);
  }, ar.prototype.leafPrepend = function(ur) {
    var fr = this.left.leafPrepend(ur);
    if (fr)
      return new ar(fr, this.right);
  }, ar.prototype.appendInner = function(ur) {
    return this.left.depth >= Math.max(this.right.depth, ur.depth) + 1 ? new ar(this.left, new ar(this.right, ur)) : new ar(this, ur);
  }, ar;
}(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(ar, cr) {
    this.items = ar, this.eventCount = cr;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(ar, cr) {
    if (this.eventCount == 0)
      return null;
    let ur = this.items.length;
    for (; ; ur--)
      if (this.items.get(ur - 1).selection) {
        --ur;
        break;
      }
    let fr, dr;
    cr && (fr = this.remapping(ur, this.items.length), dr = fr.maps.length);
    let gr = ar.tr, mr, vr, yr = [], kr = [];
    return this.items.forEach((_r, xr) => {
      if (!_r.step) {
        fr || (fr = this.remapping(ur, xr + 1), dr = fr.maps.length), dr--, kr.push(_r);
        return;
      }
      if (fr) {
        kr.push(new Item(_r.map));
        let Sr = _r.step.map(fr.slice(dr)), Er;
        Sr && gr.maybeStep(Sr).doc && (Er = gr.mapping.maps[gr.mapping.maps.length - 1], yr.push(new Item(Er, void 0, void 0, yr.length + kr.length))), dr--, Er && fr.appendMap(Er, dr);
      } else
        gr.maybeStep(_r.step);
      if (_r.selection)
        return mr = fr ? _r.selection.map(fr.slice(dr)) : _r.selection, vr = new Branch(this.items.slice(0, ur).append(kr.reverse().concat(yr)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: vr, transform: gr, selection: mr };
  }
  // Create a new branch with the given transform added.
  addTransform(ar, cr, ur, fr) {
    let dr = [], gr = this.eventCount, mr = this.items, vr = !fr && mr.length ? mr.get(mr.length - 1) : null;
    for (let kr = 0; kr < ar.steps.length; kr++) {
      let _r = ar.steps[kr].invert(ar.docs[kr]), xr = new Item(ar.mapping.maps[kr], _r, cr), Sr;
      (Sr = vr && vr.merge(xr)) && (xr = Sr, kr ? dr.pop() : mr = mr.slice(0, mr.length - 1)), dr.push(xr), cr && (gr++, cr = void 0), fr || (vr = xr);
    }
    let yr = gr - ur.depth;
    return yr > DEPTH_OVERFLOW && (mr = cutOffEvents(mr, yr), gr -= yr), new Branch(mr.append(dr), gr);
  }
  remapping(ar, cr) {
    let ur = new Mapping();
    return this.items.forEach((fr, dr) => {
      let gr = fr.mirrorOffset != null && dr - fr.mirrorOffset >= ar ? ur.maps.length - fr.mirrorOffset : void 0;
      ur.appendMap(fr.map, gr);
    }, ar, cr), ur;
  }
  addMaps(ar) {
    return this.eventCount == 0 ? this : new Branch(this.items.append(ar.map((cr) => new Item(cr))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(ar, cr) {
    if (!this.eventCount)
      return this;
    let ur = [], fr = Math.max(0, this.items.length - cr), dr = ar.mapping, gr = ar.steps.length, mr = this.eventCount;
    this.items.forEach((xr) => {
      xr.selection && mr--;
    }, fr);
    let vr = cr;
    this.items.forEach((xr) => {
      let Sr = dr.getMirror(--vr);
      if (Sr == null)
        return;
      gr = Math.min(gr, Sr);
      let Er = dr.maps[Sr];
      if (xr.step) {
        let Cr = ar.steps[Sr].invert(ar.docs[Sr]), Tr = xr.selection && xr.selection.map(dr.slice(vr + 1, Sr));
        Tr && mr++, ur.push(new Item(Er, Cr, Tr));
      } else
        ur.push(new Item(Er));
    }, fr);
    let yr = [];
    for (let xr = cr; xr < gr; xr++)
      yr.push(new Item(dr.maps[xr]));
    let kr = this.items.slice(0, fr).append(yr).append(ur), _r = new Branch(kr, mr);
    return _r.emptyItemCount() > max_empty_items && (_r = _r.compress(this.items.length - ur.length)), _r;
  }
  emptyItemCount() {
    let ar = 0;
    return this.items.forEach((cr) => {
      cr.step || ar++;
    }), ar;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(ar = this.items.length) {
    let cr = this.remapping(0, ar), ur = cr.maps.length, fr = [], dr = 0;
    return this.items.forEach((gr, mr) => {
      if (mr >= ar)
        fr.push(gr), gr.selection && dr++;
      else if (gr.step) {
        let vr = gr.step.map(cr.slice(ur)), yr = vr && vr.getMap();
        if (ur--, yr && cr.appendMap(yr, ur), vr) {
          let kr = gr.selection && gr.selection.map(cr.slice(ur));
          kr && dr++;
          let _r = new Item(yr.invert(), vr, kr), xr, Sr = fr.length - 1;
          (xr = fr.length && fr[Sr].merge(_r)) ? fr[Sr] = xr : fr.push(_r);
        }
      } else
        gr.map && ur--;
    }, this.items.length, 0), new Branch(RopeSequence.from(fr.reverse()), dr);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(lr, ar) {
  let cr;
  return lr.forEach((ur, fr) => {
    if (ur.selection && ar-- == 0)
      return cr = fr, !1;
  }), lr.slice(cr);
}
class Item {
  constructor(ar, cr, ur, fr) {
    this.map = ar, this.step = cr, this.selection = ur, this.mirrorOffset = fr;
  }
  merge(ar) {
    if (this.step && ar.step && !ar.selection) {
      let cr = ar.step.merge(this.step);
      if (cr)
        return new Item(cr.getMap().invert(), cr, this.selection);
    }
  }
}
class HistoryState {
  constructor(ar, cr, ur, fr, dr) {
    this.done = ar, this.undone = cr, this.prevRanges = ur, this.prevTime = fr, this.prevComposition = dr;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(lr, ar, cr, ur) {
  let fr = cr.getMeta(historyKey), dr;
  if (fr)
    return fr.historyState;
  cr.getMeta(closeHistoryKey) && (lr = new HistoryState(lr.done, lr.undone, null, 0, -1));
  let gr = cr.getMeta("appendedTransaction");
  if (cr.steps.length == 0)
    return lr;
  if (gr && gr.getMeta(historyKey))
    return gr.getMeta(historyKey).redo ? new HistoryState(lr.done.addTransform(cr, void 0, ur, mustPreserveItems(ar)), lr.undone, rangesFor(cr.mapping.maps[cr.steps.length - 1]), lr.prevTime, lr.prevComposition) : new HistoryState(lr.done, lr.undone.addTransform(cr, void 0, ur, mustPreserveItems(ar)), null, lr.prevTime, lr.prevComposition);
  if (cr.getMeta("addToHistory") !== !1 && !(gr && gr.getMeta("addToHistory") === !1)) {
    let mr = cr.getMeta("composition"), vr = lr.prevTime == 0 || !gr && lr.prevComposition != mr && (lr.prevTime < (cr.time || 0) - ur.newGroupDelay || !isAdjacentTo(cr, lr.prevRanges)), yr = gr ? mapRanges(lr.prevRanges, cr.mapping) : rangesFor(cr.mapping.maps[cr.steps.length - 1]);
    return new HistoryState(lr.done.addTransform(cr, vr ? ar.selection.getBookmark() : void 0, ur, mustPreserveItems(ar)), Branch.empty, yr, cr.time, mr == null ? lr.prevComposition : mr);
  } else
    return (dr = cr.getMeta("rebased")) ? new HistoryState(lr.done.rebased(cr, dr), lr.undone.rebased(cr, dr), mapRanges(lr.prevRanges, cr.mapping), lr.prevTime, lr.prevComposition) : new HistoryState(lr.done.addMaps(cr.mapping.maps), lr.undone.addMaps(cr.mapping.maps), mapRanges(lr.prevRanges, cr.mapping), lr.prevTime, lr.prevComposition);
}
function isAdjacentTo(lr, ar) {
  if (!ar)
    return !1;
  if (!lr.docChanged)
    return !0;
  let cr = !1;
  return lr.mapping.maps[0].forEach((ur, fr) => {
    for (let dr = 0; dr < ar.length; dr += 2)
      ur <= ar[dr + 1] && fr >= ar[dr] && (cr = !0);
  }), cr;
}
function rangesFor(lr) {
  let ar = [];
  return lr.forEach((cr, ur, fr, dr) => ar.push(fr, dr)), ar;
}
function mapRanges(lr, ar) {
  if (!lr)
    return null;
  let cr = [];
  for (let ur = 0; ur < lr.length; ur += 2) {
    let fr = ar.map(lr[ur], 1), dr = ar.map(lr[ur + 1], -1);
    fr <= dr && cr.push(fr, dr);
  }
  return cr;
}
function histTransaction(lr, ar, cr, ur) {
  let fr = mustPreserveItems(ar), dr = historyKey.get(ar).spec.config, gr = (ur ? lr.undone : lr.done).popEvent(ar, fr);
  if (!gr)
    return;
  let mr = gr.selection.resolve(gr.transform.doc), vr = (ur ? lr.done : lr.undone).addTransform(gr.transform, ar.selection.getBookmark(), dr, fr), yr = new HistoryState(ur ? vr : gr.remaining, ur ? gr.remaining : vr, null, 0, -1);
  cr(gr.transform.setSelection(mr).setMeta(historyKey, { redo: ur, historyState: yr }).scrollIntoView());
}
let cachedPreserveItems = !1, cachedPreserveItemsPlugins = null;
function mustPreserveItems(lr) {
  let ar = lr.plugins;
  if (cachedPreserveItemsPlugins != ar) {
    cachedPreserveItems = !1, cachedPreserveItemsPlugins = ar;
    for (let cr = 0; cr < ar.length; cr++)
      if (ar[cr].spec.historyPreserveItems) {
        cachedPreserveItems = !0;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new distExports$3.PluginKey("history"), closeHistoryKey = new distExports$3.PluginKey("closeHistory");
function history(lr = {}) {
  return lr = {
    depth: lr.depth || 100,
    newGroupDelay: lr.newGroupDelay || 500
  }, new distExports$3.Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(ar, cr, ur) {
        return applyTransaction(cr, ur, ar, lr);
      }
    },
    config: lr,
    props: {
      handleDOMEvents: {
        beforeinput(ar, cr) {
          let ur = cr.inputType, fr = ur == "historyUndo" ? undo : ur == "historyRedo" ? redo : null;
          return fr ? (cr.preventDefault(), fr(ar.state, ar.dispatch)) : !1;
        }
      }
    }
  });
}
const undo = (lr, ar) => {
  let cr = historyKey.getState(lr);
  return !cr || cr.done.eventCount == 0 ? !1 : (ar && histTransaction(cr, lr, ar, !1), !0);
}, redo = (lr, ar) => {
  let cr = historyKey.getState(lr);
  return !cr || cr.undone.eventCount == 0 ? !1 : (ar && histTransaction(cr, lr, ar, !0), !0);
};
function undoDepth(lr) {
  let ar = historyKey.getState(lr);
  return ar ? ar.done.eventCount : 0;
}
/**
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(lr, ar) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(cr, ur) {
    cr.__proto__ = ur;
  } || function(cr, ur) {
    for (var fr in ur)
      Object.prototype.hasOwnProperty.call(ur, fr) && (cr[fr] = ur[fr]);
  }, extendStatics$1(lr, ar);
};
function __extends$1(lr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics$1(lr, ar);
  function cr() {
    this.constructor = lr;
  }
  lr.prototype = ar === null ? Object.create(ar) : (cr.prototype = ar.prototype, new cr());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(ar) {
    for (var cr, ur = 1, fr = arguments.length; ur < fr; ur++) {
      cr = arguments[ur];
      for (var dr in cr)
        Object.prototype.hasOwnProperty.call(cr, dr) && (ar[dr] = cr[dr]);
    }
    return ar;
  }, __assign$1.apply(this, arguments);
};
function __spreadArray$1(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
}
function __makeTemplateObject(lr, ar) {
  return Object.defineProperty ? Object.defineProperty(lr, "raw", { value: ar }) : lr.raw = ar, lr;
}
function forEachOwnProperties$2(lr, ar, cr) {
  var ur;
  cr = cr || null;
  for (ur in lr)
    if (lr.hasOwnProperty(ur) && ar.call(cr, lr[ur], ur, lr) === !1)
      break;
}
var forEachOwnProperties_1 = forEachOwnProperties$2;
function extend(lr, ar) {
  var cr = Object.prototype.hasOwnProperty, ur, fr, dr, gr;
  for (dr = 1, gr = arguments.length; dr < gr; dr += 1) {
    ur = arguments[dr];
    for (fr in ur)
      cr.call(ur, fr) && (lr[fr] = ur[fr]);
  }
  return lr;
}
var extend_1 = extend;
function isString$3(lr) {
  return typeof lr == "string" || lr instanceof String;
}
var isString_1 = isString$3;
function isArray$3(lr) {
  return lr instanceof Array;
}
var isArray_1 = isArray$3;
function forEachArray$3(lr, ar, cr) {
  var ur = 0, fr = lr.length;
  for (cr = cr || null; ur < fr && ar.call(cr, lr[ur], ur, lr) !== !1; ur += 1)
    ;
}
var forEachArray_1 = forEachArray$3, isArray$2 = isArray_1, forEachArray$2 = forEachArray_1, forEachOwnProperties$1 = forEachOwnProperties_1;
function forEach$4(lr, ar, cr) {
  isArray$2(lr) ? forEachArray$2(lr, ar, cr) : forEachOwnProperties$1(lr, ar, cr);
}
var forEach_1 = forEach$4, isString$2 = isString_1, forEach$3 = forEach_1;
function css$2(lr, ar, cr) {
  var ur = lr.style;
  if (isString$2(ar)) {
    ur[ar] = cr;
    return;
  }
  forEach$3(ar, function(fr, dr) {
    ur[dr] = fr;
  });
}
var css_1 = css$2, isArray$1 = isArray_1;
function inArray$4(lr, ar, cr) {
  var ur, fr;
  if (cr = cr || 0, !isArray$1(ar))
    return -1;
  if (Array.prototype.indexOf)
    return Array.prototype.indexOf.call(ar, lr, cr);
  for (fr = ar.length, ur = cr; cr >= 0 && ur < fr; ur += 1)
    if (ar[ur] === lr)
      return ur;
  return -1;
}
var inArray_1 = inArray$4;
function isUndefined$4(lr) {
  return lr === void 0;
}
var isUndefined_1 = isUndefined$4, isUndefined$3 = isUndefined_1;
function getClass$3(lr) {
  return !lr || !lr.className ? "" : isUndefined$3(lr.className.baseVal) ? lr.className : lr.className.baseVal;
}
var getClass_1 = getClass$3, isArray = isArray_1, isUndefined$2 = isUndefined_1;
function setClassName$2(lr, ar) {
  if (ar = isArray(ar) ? ar.join(" ") : ar, ar = ar.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), isUndefined$2(lr.className.baseVal)) {
    lr.className = ar;
    return;
  }
  lr.className.baseVal = ar;
}
var _setClassName = setClassName$2, forEach$2 = forEach_1, inArray$3 = inArray_1, getClass$2 = getClass_1, setClassName$1 = _setClassName;
function addClass(lr) {
  var ar = Array.prototype.slice.call(arguments, 1), cr = lr.classList, ur = [], fr;
  if (cr) {
    forEach$2(ar, function(dr) {
      lr.classList.add(dr);
    });
    return;
  }
  fr = getClass$2(lr), fr && (ar = [].concat(fr.split(/\s+/), ar)), forEach$2(ar, function(dr) {
    inArray$3(dr, ur) < 0 && ur.push(dr);
  }), setClassName$1(lr, ur);
}
var addClass_1 = addClass, forEachArray$1 = forEachArray_1, inArray$2 = inArray_1, getClass$1 = getClass_1, setClassName = _setClassName;
function removeClass(lr) {
  var ar = Array.prototype.slice.call(arguments, 1), cr = lr.classList, ur, fr;
  if (cr) {
    forEachArray$1(ar, function(dr) {
      cr.remove(dr);
    });
    return;
  }
  ur = getClass$1(lr).split(/\s+/), fr = [], forEachArray$1(ur, function(dr) {
    inArray$2(dr, ar) < 0 && fr.push(dr);
  }), setClassName(lr, fr);
}
var removeClass_1 = removeClass;
function isNumber(lr) {
  return typeof lr == "number" || lr instanceof Number;
}
var isNumber_1 = isNumber;
function isNull$1(lr) {
  return lr === null;
}
var isNull_1 = isNull$1, forEachOwnProperties = forEachOwnProperties_1;
function imagePing$1(lr, ar) {
  var cr = document.createElement("img"), ur = "";
  return forEachOwnProperties(ar, function(fr, dr) {
    ur += "&" + dr + "=" + fr;
  }), ur = ur.substring(1), cr.src = lr + "?" + ur, cr.style.display = "none", document.body.appendChild(cr), document.body.removeChild(cr), cr;
}
var imagePing_1 = imagePing$1, isUndefined$1 = isUndefined_1, imagePing = imagePing_1, ms7days = 7 * 24 * 60 * 60 * 1e3;
function isExpired(lr) {
  var ar = (/* @__PURE__ */ new Date()).getTime();
  return ar - lr > ms7days;
}
function sendHostname(lr, ar) {
  var cr = "https://www.google-analytics.com/collect", ur = location.hostname, fr = "event", dr = "use", gr = "TOAST UI " + lr + " for " + ur + ": Statistics", mr = window.localStorage.getItem(gr);
  !isUndefined$1(window.tui) && window.tui.usageStatistics === !1 || mr && !isExpired(mr) || (window.localStorage.setItem(gr, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
    (document.readyState === "interactive" || document.readyState === "complete") && imagePing(cr, {
      v: 1,
      t: fr,
      tid: ar,
      cid: ur,
      dp: ur,
      dh: lr,
      el: lr,
      ec: dr
    });
  }, 1e3));
}
var sendHostname_1 = sendHostname, reSpaceMoreThanOne = /[\u0020]+/g, reEscapeChars$1 = /[>(){}[\]+-.!#|]/g, reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g, reEscapeBackSlash = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g, reEscapePairedChars = /[*_~`]/g, reMdImageSyntax = /!\[.*\]\(.*\)/g, reEscapedCharInLinkSyntax = /[[\]]/g, reEscapeBackSlashInSentence = /(?:^|[^\\])\\(?!\\)/g, XMLSPECIAL$1 = '[&<>"]', reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, "g");
function replaceUnsafeChar$1(lr) {
  switch (lr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return lr;
  }
}
function escapeXml$1(lr) {
  return reXmlSpecial$1.test(lr) ? lr.replace(reXmlSpecial$1, replaceUnsafeChar$1) : lr;
}
function sendHostName() {
  sendHostname_1("editor", "UA-129966929-1");
}
function includes(lr, ar) {
  return lr.indexOf(ar) !== -1;
}
var availableLinkAttributes = ["rel", "target", "hreflang", "type"], reMarkdownTextToEscapeMap = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function sanitizeLinkAttribute(lr) {
  if (!lr)
    return null;
  var ar = {};
  return availableLinkAttributes.forEach(function(cr) {
    isUndefined_1(lr[cr]) || (ar[cr] = lr[cr]);
  }), ar;
}
function repeat$1(lr, ar) {
  for (var cr = "", ur = 0; ur < ar; ur += 1)
    cr += lr;
  return cr;
}
function isNeedEscapeText(lr) {
  var ar = !1;
  return forEachOwnProperties_1(reMarkdownTextToEscapeMap, function(cr) {
    return cr.test(lr) && (ar = !0), !ar;
  }), ar;
}
function escapeTextForLink(lr) {
  for (var ar = [], cr = reMdImageSyntax.exec(lr); cr; )
    ar.push([cr.index, cr.index + cr[0].length]), cr = reMdImageSyntax.exec(lr);
  return lr.replace(reEscapedCharInLinkSyntax, function(ur, fr) {
    var dr = ar.some(function(gr) {
      return fr > gr[0] && fr < gr[1];
    });
    return dr ? ur : "\\" + ur;
  });
}
function escape$1$1(lr) {
  var ar = function(fr) {
    return "\\" + fr;
  }, cr = function(fr) {
    return fr + "\\";
  }, ur = lr.replace(reSpaceMoreThanOne, " ");
  return reEscapeBackSlash.test(ur) && (ur = ur.replace(reEscapeBackSlash, ar)), reEscapeBackSlashInSentence.test(ur) && (ur = ur.replace(reEscapeBackSlashInSentence, cr)), ur = ur.replace(reEscapePairedChars, ar), reEscapeHTML.test(ur) && (ur = ur.replace(reEscapeHTML, ar)), isNeedEscapeText(ur) && (ur = ur.replace(reEscapeChars$1, ar)), ur;
}
function quote(lr) {
  var ar;
  return lr.indexOf('"') === -1 ? ar = '""' : ar = lr.indexOf("'") === -1 ? "''" : "()", ar[0] + lr + ar[1];
}
function isNil(lr) {
  return isNull_1(lr) || isUndefined_1(lr);
}
function shallowEqual(lr, ar) {
  if (lr === null && lr === ar)
    return !0;
  if (typeof lr != "object" || typeof ar != "object" || isNil(lr) || isNil(ar))
    return lr === ar;
  for (var cr in lr)
    if (lr[cr] !== ar[cr])
      return !1;
  for (var cr in ar)
    if (!(cr in lr))
      return !1;
  return !0;
}
function last$1(lr) {
  return lr[lr.length - 1];
}
function between$1(lr, ar, cr) {
  return lr >= ar && lr <= cr;
}
function isObject$1(lr) {
  return typeof lr == "object" && lr !== null;
}
function deepMergedCopy(lr, ar) {
  var cr = __assign$1({}, lr);
  return lr && ar && Object.keys(ar).forEach(function(ur) {
    isObject$1(cr[ur]) ? Array.isArray(ar[ur]) ? cr[ur] = deepCopyArray(ar[ur]) : cr.hasOwnProperty(ur) ? cr[ur] = deepMergedCopy(cr[ur], ar[ur]) : cr[ur] = deepCopy(ar[ur]) : cr[ur] = ar[ur];
  }), cr;
}
function deepCopyArray(lr) {
  return lr.map(function(ar) {
    return isObject$1(ar) ? Array.isArray(ar) ? deepCopyArray(ar) : deepCopy(ar) : ar;
  });
}
function deepCopy(lr) {
  var ar = Object.keys(lr);
  return ar.length ? ar.reduce(function(cr, ur) {
    return isObject$1(lr[ur]) ? cr[ur] = Array.isArray(lr[ur]) ? deepCopyArray(lr[ur]) : deepCopy(lr[ur]) : cr[ur] = lr[ur], cr;
  }, {}) : lr;
}
function assign(lr, ar) {
  return ar === void 0 && (ar = {}), Object.keys(ar).forEach(function(cr) {
    lr.hasOwnProperty(cr) && typeof lr[cr] == "object" ? Array.isArray(ar[cr]) ? lr[cr] = ar[cr] : assign(lr[cr], ar[cr]) : lr[cr] = ar[cr];
  }), lr;
}
function getSortedNumPair(lr, ar) {
  return lr > ar ? [ar, lr] : [lr, ar];
}
var forEachArray = forEachArray_1;
function toArray$1(lr) {
  var ar;
  try {
    ar = Array.prototype.slice.call(lr);
  } catch (cr) {
    ar = [], forEachArray(lr, function(ur) {
      ar.push(ur);
    });
  }
  return ar;
}
var toArray_1 = toArray$1;
function createParagraph(lr, ar) {
  var cr = lr.nodes.paragraph;
  return ar ? cr.create(null, isString_1(ar) ? lr.text(ar) : ar) : cr.createAndFill();
}
function createTextNode$1(lr, ar, cr) {
  return lr.text(ar, cr);
}
function createTextSelection(lr, ar, cr) {
  cr === void 0 && (cr = ar);
  var ur = lr.doc.content.size, fr = ur > 0 ? ur - 1 : 1;
  return distExports$3.TextSelection.create(lr.doc, Math.min(ar, fr), Math.min(cr, fr));
}
function addParagraph(lr, ar, cr) {
  var ur = ar.pos;
  return lr.replaceWith(ur, ur, createParagraph(cr)), lr.setSelection(createTextSelection(lr, ur + 1));
}
function replaceTextNode(lr) {
  for (var ar = lr.state, cr = lr.from, ur = lr.startIndex, fr = lr.endIndex, dr = lr.createText, gr = ar.tr, mr = ar.doc, vr = ar.schema, yr = ur; yr <= fr; yr += 1) {
    var kr = mr.child(yr), _r = kr.nodeSize, xr = kr.textContent, Sr = kr.content, Er = dr(xr), Cr = Er ? createTextNode$1(vr, Er) : distExports$5.Fragment.empty, Tr = gr.mapping.map(cr), Ar = Tr + Sr.size;
    gr.replaceWith(Tr, Ar, Cr), cr += _r;
  }
  return gr;
}
function splitAndExtendBlock(lr, ar, cr, ur) {
  var fr = cr.length;
  lr.split(ar).delete(ar - fr, ar).insert(lr.mapping.map(ar), ur).setSelection(createTextSelection(lr, lr.mapping.map(ar) - fr));
}
function getMdStartLine(lr) {
  return lr.sourcepos[0][0];
}
function getMdEndLine(lr) {
  return lr.sourcepos[1][0];
}
function getMdStartCh(lr) {
  return lr.sourcepos[0][1];
}
function getMdEndCh(lr) {
  return lr.sourcepos[1][1];
}
function isHTMLNode(lr) {
  var ar = lr.type;
  return ar === "htmlBlock" || ar === "htmlInline";
}
function isStyledInlineNode(lr) {
  var ar = lr.type;
  return ar === "strike" || ar === "strong" || ar === "emph" || ar === "code" || ar === "link" || ar === "image";
}
function isCodeBlockNode(lr) {
  return lr && lr.type === "codeBlock";
}
function isListNode$1(lr) {
  return lr && (lr.type === "item" || lr.type === "list");
}
function isOrderedListNode(lr) {
  return isListNode$1(lr) && lr.listData.type === "ordered";
}
function isBulletListNode(lr) {
  return isListNode$1(lr) && lr.listData.type !== "ordered";
}
function isTableCellNode(lr) {
  return lr && (lr.type === "tableCell" || lr.type === "tableDelimCell");
}
function isInlineNode$1(lr) {
  switch (lr.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function findClosestNode(lr, ar, cr) {
  for (cr === void 0 && (cr = !0), lr = cr ? lr : lr.parent; lr && lr.type !== "document"; ) {
    if (ar(lr))
      return lr;
    lr = lr.parent;
  }
  return null;
}
function traverseParentNodes(lr, ar, cr) {
  for (cr === void 0 && (cr = !0), lr = cr ? lr : lr.parent; lr && lr.type !== "document"; )
    ar(lr), lr = lr.parent;
}
function addOffsetPos(lr, ar) {
  return [lr[0], lr[1] + ar];
}
function setOffsetPos(lr, ar) {
  return [lr[0], ar];
}
function getInlineMarkdownText(lr) {
  var ar = lr.firstChild.literal;
  switch (lr.type) {
    case "emph":
      return "*" + ar + "*";
    case "strong":
      return "**" + ar + "**";
    case "strike":
      return "~~" + ar + "~~";
    case "code":
      return "`" + ar + "`";
    case "link":
    case "image":
      var cr = lr, ur = cr.destination, fr = cr.title, dr = lr.type === "link" ? "" : "!";
      return dr + "[" + ar + "](" + ur + (fr ? ' "' + fr + '"' : "") + ")";
    default:
      return null;
  }
}
function isContainer$2(lr) {
  switch (lr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function getChildrenText$1(lr) {
  for (var ar = [], cr = lr.walker(), ur = null; ur = cr.next(); ) {
    var fr = ur.node;
    fr.type === "text" && ar.push(fr.literal);
  }
  return ar.join("");
}
var widgetRules = [], widgetRuleMap = {}, reWidgetPrefix = /\$\$widget\d+\s/;
function unwrapWidgetSyntax(lr) {
  var ar = lr.search(reWidgetPrefix);
  if (ar !== -1) {
    var cr = lr.substring(ar), ur = cr.replace(reWidgetPrefix, "").replace("$$", "");
    lr = lr.substring(0, ar), lr += unwrapWidgetSyntax(ur);
  }
  return lr;
}
function createWidgetContent(lr, ar) {
  return "$$" + lr + " " + ar + "$$";
}
function widgetToDOM(lr, ar) {
  var cr = widgetRuleMap[lr], ur = cr.rule, fr = cr.toDOM, dr = unwrapWidgetSyntax(ar).match(ur);
  return dr && (ar = dr[0]), fr(ar);
}
function getWidgetRules() {
  return widgetRules;
}
function setWidgetRules(lr) {
  widgetRules = lr, widgetRules.forEach(function(ar, cr) {
    widgetRuleMap["widget" + cr] = ar;
  });
}
function mergeNodes(lr, ar, cr, ur) {
  return lr.concat(createNodesWithWidget(ar, cr, ur));
}
function createNodesWithWidget(lr, ar, cr) {
  cr === void 0 && (cr = 0);
  var ur = [], fr = (widgetRules[cr] || {}).rule, dr = cr + 1;
  if (lr = unwrapWidgetSyntax(lr), fr && fr.test(lr)) {
    for (var gr = void 0; (gr = lr.search(fr)) !== -1; ) {
      var mr = lr.substring(0, gr);
      mr && (ur = mergeNodes(ur, mr, ar, dr)), lr = lr.substring(gr);
      var vr = lr.match(fr)[0], yr = "widget" + cr;
      ur.push(ar.nodes.widget.create({ info: yr }, ar.text(createWidgetContent(yr, vr)))), lr = lr.substring(vr.length);
    }
    lr && (ur = mergeNodes(ur, lr, ar, dr));
  } else
    lr && (ur = cr < widgetRules.length - 1 ? mergeNodes(ur, lr, ar, dr) : [ar.text(lr)]);
  return ur;
}
function getWidgetContent(lr) {
  for (var ar, cr = "", ur = lr.walker(); ar = ur.next(); ) {
    var fr = ar.node, dr = ar.entering;
    dr && (fr !== lr && fr.type !== "text" ? (cr += getInlineMarkdownText(fr), ur.resumeAt(lr, !1), ur.next()) : fr.type === "text" && (cr += fr.literal));
  }
  return cr;
}
function getDefaultCommands() {
  return {
    deleteSelection: function() {
      return deleteSelection;
    },
    selectAll: function() {
      return selectAll;
    },
    undo: function() {
      return undo;
    },
    redo: function() {
      return redo;
    }
  };
}
function placeholder(lr) {
  return new distExports$3.Plugin({
    props: {
      decorations: function(ar) {
        var cr = ar.doc;
        if (lr.text && cr.childCount === 1 && cr.firstChild.isTextblock && cr.firstChild.content.size === 0) {
          var ur = document.createElement("span");
          return addClass_1(ur, "placeholder"), lr.className && addClass_1(ur, lr.className), ur.textContent = lr.text, distExports$4.DecorationSet.create(cr, [distExports$4.Decoration.widget(1, ur)]);
        }
        return null;
      }
    }
  });
}
var inArray$1 = inArray_1, getClass = getClass_1;
function hasClass(lr, ar) {
  var cr;
  return lr.classList ? lr.classList.contains(ar) : (cr = getClass(lr).split(/\s+/), inArray$1(ar, cr) > -1);
}
var hasClass_1 = hasClass, inArray = inArray_1, toArray = toArray_1, elProto = Element.prototype, matchSelector = elProto.matches || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || function(lr) {
  var ar = this.document || this.ownerDocument;
  return inArray(this, toArray(ar.querySelectorAll(lr))) > -1;
};
function matches(lr, ar) {
  return matchSelector.call(lr, ar);
}
var matches_1 = matches, TAG_NAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTE_NAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTED_VALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLE_QUOTED_VALUE = "'[^']*'", DOUBLE_QUOTED_VALUE = '"[^"]*"', ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")", ATTRIBUTE_VALUE_SPEC = "(?:\\s*=\\s*" + ATTRIBUTE_VALUE + ")", ATTRIBUTE$1 = "(?:\\s+" + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)", OPEN_TAG = "<(" + TAG_NAME + ")(" + ATTRIBUTE$1 + ")*\\s*/?>", CLOSE_TAG = "</(" + TAG_NAME + ")\\s*[>]", HTML_TAG = "(?:" + OPEN_TAG + "|" + CLOSE_TAG + ")", reHTMLTag = new RegExp("^" + HTML_TAG, "i"), reBR = /<br\s*\/*>/i, reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/, ALTERNATIVE_TAG_FOR_BR = "</p><p>";
function isPositionInBox(lr, ar, cr) {
  var ur = parseInt(lr.left, 10), fr = parseInt(lr.top, 10), dr = parseInt(lr.width, 10) + parseInt(lr.paddingLeft, 10) + parseInt(lr.paddingRight, 10), gr = parseInt(lr.height, 10) + parseInt(lr.paddingTop, 10) + parseInt(lr.paddingBottom, 10);
  return ar >= ur && ar <= ur + dr && cr >= fr && cr <= fr + gr;
}
var CLS_PREFIX = "toastui-editor-";
function cls() {
  for (var lr = [], ar = 0; ar < arguments.length; ar++)
    lr[ar] = arguments[ar];
  for (var cr = [], ur = 0, fr = lr; ur < fr.length; ur++) {
    var dr = fr[ur], gr = void 0;
    Array.isArray(dr) ? gr = dr[0] ? dr[1] : null : gr = dr, gr && cr.push("" + CLS_PREFIX + gr);
  }
  return cr.join(" ");
}
function clsWithMdPrefix() {
  for (var lr = [], ar = 0; ar < arguments.length; ar++)
    lr[ar] = arguments[ar];
  return lr.map(function(cr) {
    return CLS_PREFIX + "md-" + cr;
  }).join(" ");
}
function isTextNode(lr) {
  return (lr == null ? void 0 : lr.nodeType) === Node.TEXT_NODE;
}
function isElemNode(lr) {
  return lr && lr.nodeType === Node.ELEMENT_NODE;
}
function findNodes(lr, ar) {
  var cr = toArray_1(lr.querySelectorAll(ar));
  return cr.length ? cr : [];
}
function appendNodes(lr, ar) {
  ar = isArray_1(ar) ? toArray_1(ar) : [ar], ar.forEach(function(cr) {
    lr.appendChild(cr);
  });
}
function insertBeforeNode(lr, ar) {
  ar.parentNode && ar.parentNode.insertBefore(lr, ar);
}
function removeNode$1(lr) {
  lr.parentNode && lr.parentNode.removeChild(lr);
}
function unwrapNode(lr) {
  for (var ar = []; lr.firstChild; )
    ar.push(lr.firstChild), lr.parentNode && lr.parentNode.insertBefore(lr.firstChild, lr);
  return removeNode$1(lr), ar;
}
function toggleClass(lr, ar, cr) {
  isUndefined_1(cr) && (cr = !hasClass_1(lr, ar));
  var ur = cr ? addClass_1 : removeClass_1;
  ur(lr, ar);
}
function createElementWith(lr, ar) {
  var cr = document.createElement("div");
  isString_1(lr) ? cr.innerHTML = lr : cr.appendChild(lr);
  var ur = cr.firstChild;
  return ar && ar.appendChild(ur), ur;
}
function getOuterWidth(lr) {
  var ar = window.getComputedStyle(lr);
  return ["margin-left", "margin-right"].reduce(function(cr, ur) {
    return cr + parseInt(ar.getPropertyValue(ur), 10);
  }, 0) + lr.offsetWidth;
}
function closest(lr, ar) {
  var cr;
  for (isString_1(ar) ? cr = function(ur) {
    return matches_1(ur, ar);
  } : cr = function(ur) {
    return ur === ar;
  }; lr && lr !== document; ) {
    if (isElemNode(lr) && cr(lr))
      return lr;
    lr = lr.parentNode;
  }
  return null;
}
function getTotalOffset(lr, ar) {
  for (var cr = 0, ur = 0; lr && lr !== ar; ) {
    var fr = lr.offsetTop, dr = lr.offsetLeft, gr = lr.offsetParent;
    if (cr += fr, ur += dr, gr === ar.offsetParent)
      break;
    lr = lr.offsetParent;
  }
  return { offsetTop: cr, offsetLeft: ur };
}
function setAttributes(lr, ar) {
  Object.keys(lr).forEach(function(cr) {
    isNil(lr[cr]) ? ar.removeAttribute(cr) : ar.setAttribute(cr, lr[cr]);
  });
}
function replaceBRWithEmptyBlock(lr) {
  var ar = lr.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"), cr = new RegExp(HTML_TAG, "ig"), ur = ar.match(cr);
  return ur == null || ur.forEach(function(fr, dr) {
    if (reBR.test(fr)) {
      var gr = ALTERNATIVE_TAG_FOR_BR;
      if (dr) {
        var mr = ur[dr - 1], vr = mr.match(OPEN_TAG);
        if (vr && !/br/i.test(vr[1])) {
          var yr = vr[1];
          gr = "</" + yr + "><" + yr + ">";
        }
      }
      ar = ar.replace(reBR, gr);
    }
  }), ar;
}
function removeProseMirrorHackNodes(lr) {
  var ar = /<img class="ProseMirror-separator" alt="">/g, cr = / class="ProseMirror-trailingBreak"/g, ur = lr;
  return ur = ur.replace(ar, ""), ur = ur.replace(cr, ""), ur;
}
var pluginKey$1 = new distExports$3.PluginKey("widget"), MARGIN = 5, PopupWidget = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = this;
      this.popup = null, this.removeWidget = function() {
        ur.popup && (ur.rootEl.removeChild(ur.popup), ur.popup = null);
      }, this.rootEl = ar.dom.parentElement, this.eventEmitter = cr, this.eventEmitter.listen("blur", this.removeWidget), this.eventEmitter.listen("loadUI", function() {
        ur.rootEl = closest(ar.dom.parentElement, "." + cls("defaultUI"));
      }), this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    return lr.prototype.update = function(ar) {
      var cr = pluginKey$1.getState(ar.state);
      if (this.removeWidget(), cr) {
        var ur = cr.node, fr = cr.style, dr = ar.coordsAtPos(cr.pos), gr = dr.top, mr = dr.left, vr = dr.bottom, yr = vr - gr, kr = this.rootEl.getBoundingClientRect(), _r = gr - kr.top;
        css_1(ur, { opacity: "0" }), this.rootEl.appendChild(ur), css_1(ur, {
          position: "absolute",
          left: mr - kr.left + MARGIN + "px",
          top: (fr === "bottom" ? _r + yr - MARGIN : _r - yr) + "px",
          opacity: "1"
        }), this.popup = ur, ar.focus();
      }
    }, lr.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    }, lr;
  }()
);
function addWidget(lr) {
  return new distExports$3.Plugin({
    key: pluginKey$1,
    state: {
      init: function() {
        return null;
      },
      apply: function(ar) {
        return ar.getMeta("widget");
      }
    },
    view: function(ar) {
      return new PopupWidget(ar, lr);
    }
  });
}
function addDefaultImageBlobHook(lr) {
  lr.listen("addImageBlobHook", function(ar, cr) {
    var ur = new FileReader();
    ur.onload = function(fr) {
      var dr = fr.target;
      return cr(dr.result);
    }, ur.readAsDataURL(ar);
  });
}
function emitImageBlobHook(lr, ar, cr) {
  var ur = function(fr, dr) {
    lr.emit("command", "addImage", {
      imageUrl: fr,
      altText: dr || ar.name || "image"
    });
  };
  lr.emit("addImageBlobHook", ar, ur, cr);
}
function pasteImageOnly(lr) {
  var ar = toArray_1(lr).filter(function(ur) {
    var fr = ur.type;
    return fr.indexOf("image") !== -1;
  });
  if (ar.length === 1) {
    var cr = ar[0];
    if (cr)
      return cr.getAsFile();
  }
  return null;
}
function dropImage(lr) {
  var ar = lr.eventEmitter;
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        drop: function(cr, ur) {
          var fr, dr = (fr = ur.dataTransfer) === null || fr === void 0 ? void 0 : fr.files;
          return dr && forEachArray_1(dr, function(gr) {
            return gr.type.indexOf("image") !== -1 ? (ur.preventDefault(), ur.stopPropagation(), emitImageBlobHook(ar, gr, ur.type), !1) : !0;
          }), !0;
        }
      }
    }
  });
}
var Node$2 = (
  /** @class */
  function() {
    function lr() {
    }
    return Object.defineProperty(lr.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.setContext = function(ar) {
      this.context = ar;
    }, lr;
  }()
);
function widgetNodeView(lr) {
  var ar = document.createElement("span"), cr = widgetToDOM(lr.attrs.info, lr.textContent);
  return ar.className = "tui-widget", ar.appendChild(cr), { dom: ar };
}
function isWidgetNode(lr) {
  return lr.type.name === "widget";
}
var Widget = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: !0,
          content: "text*",
          selectable: !1,
          atom: !0,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(cr) {
                var ur = cr.textContent, fr = ur.match(/\$\$(widget\d+)/), dr = fr[1];
                return { info: dr };
              }
            }
          ]
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), EditorBase = (
  /** @class */
  function() {
    function lr(ar) {
      this.timer = null, this.el = document.createElement("div"), this.el.className = "toastui-editor", this.eventEmitter = ar, this.placeholder = { text: "" };
    }
    return lr.prototype.createState = function() {
      return distExports$3.EditorState.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    }, lr.prototype.initEvent = function() {
      var ar = this, cr = ar.eventEmitter, ur = ar.view, fr = ar.editorType;
      ur.dom.addEventListener("focus", function() {
        return cr.emit("focus", fr);
      }), ur.dom.addEventListener("blur", function() {
        return cr.emit("blur", fr);
      });
    }, lr.prototype.emitChangeEvent = function(ar) {
      this.eventEmitter.emit("caretChange", this.editorType), ar.docChanged && this.eventEmitter.emit("change", this.editorType);
    }, Object.defineProperty(lr.prototype, "defaultPlugins", {
      get: function() {
        var ar = this.createInputRules(), cr = __spreadArray$1(__spreadArray$1([], this.keymaps), [
          distExports$2.keymap(__assign$1({ "Shift-Enter": baseKeymap.Enter }, baseKeymap)),
          history(),
          placeholder(this.placeholder),
          addWidget(this.eventEmitter),
          dropImage(this.context)
        ]);
        return ar ? cr.concat(ar) : cr;
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.createInputRules = function() {
      var ar = getWidgetRules(), cr = ar.map(function(ur) {
        var fr = ur.rule;
        return new distExports$1.InputRule(fr, function(dr, gr, mr, vr) {
          var yr = dr.schema, kr = dr.tr, _r = dr.doc, xr = gr.input.match(new RegExp(fr, "g")), Sr = _r.resolve(mr), Er = Sr.parent, Cr = 0;
          if (isWidgetNode(Er) && (Er = Sr.node(Sr.depth - 1)), Er.forEach(function(Ir) {
            return isWidgetNode(Ir) && (Cr += 1);
          }), xr.length > Cr) {
            var Tr = last$1(xr), Ar = createNodesWithWidget(Tr, yr);
            return kr.replaceWith(vr - Tr.length + 1, vr, Ar);
          }
          return null;
        });
      });
      return cr.length ? distExports$1.inputRules({ rules: cr }) : null;
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.createSchema = function() {
      return new distExports$5.Schema({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    }, lr.prototype.createKeymaps = function(ar) {
      var cr = getDefaultCommands(), ur = cr.undo, fr = cr.redo, dr = this.specs.keymaps(ar), gr = {
        "Mod-z": ur(),
        "Shift-Mod-z": fr()
      };
      return ar ? dr.concat(distExports$2.keymap(gr)) : dr;
    }, lr.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, lr.prototype.createPluginProps = function() {
      var ar = this;
      return this.extraPlugins.map(function(cr) {
        return cr(ar.eventEmitter);
      });
    }, lr.prototype.focus = function() {
      var ar = this;
      this.clearTimer(), this.timer = setTimeout(function() {
        ar.view.focus(), ar.view.dispatch(ar.view.state.tr.scrollIntoView());
      });
    }, lr.prototype.blur = function() {
      this.view.dom.blur();
    }, lr.prototype.destroy = function() {
      var ar = this;
      this.clearTimer(), this.view.destroy(), Object.keys(this).forEach(function(cr) {
        delete ar[cr];
      });
    }, lr.prototype.moveCursorToStart = function(ar) {
      var cr = this.view.state.tr;
      this.view.dispatch(cr.setSelection(createTextSelection(cr, 1)).scrollIntoView()), ar && this.focus();
    }, lr.prototype.moveCursorToEnd = function(ar) {
      var cr = this.view.state.tr;
      this.view.dispatch(cr.setSelection(createTextSelection(cr, cr.doc.content.size - 1)).scrollIntoView()), ar && this.focus();
    }, lr.prototype.setScrollTop = function(ar) {
      this.view.dom.scrollTop = ar;
    }, lr.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    }, lr.prototype.setPlaceholder = function(ar) {
      this.placeholder.text = ar, this.view.dispatch(this.view.state.tr.scrollIntoView());
    }, lr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, lr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, lr.prototype.getElement = function() {
      return this.el;
    }, lr;
  }()
);
function isFunction(lr) {
  return lr instanceof Function;
}
var isFunction_1 = isFunction, defaultCommandShortcuts = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function execCommand(lr, ar, cr) {
  return lr.focus(), ar(cr)(lr.state, lr.dispatch, lr);
}
var SpecManager = (
  /** @class */
  function() {
    function lr(ar) {
      this.specs = ar;
    }
    return Object.defineProperty(lr.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "node";
        }).reduce(function(ar, cr) {
          var ur, fr = cr.name, dr = cr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[fr] = dr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "mark";
        }).reduce(function(ar, cr) {
          var ur, fr = cr.name, dr = cr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[fr] = dr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.commands = function(ar, cr) {
      var ur = this.specs.filter(function(dr) {
        var gr = dr.commands;
        return gr;
      }).reduce(function(dr, gr) {
        var mr = {}, vr = gr.commands();
        return isFunction_1(vr) ? mr[gr.name] = function(yr) {
          return execCommand(ar, vr, yr);
        } : Object.keys(vr).forEach(function(yr) {
          mr[yr] = function(kr) {
            return execCommand(ar, vr[yr], kr);
          };
        }), __assign$1(__assign$1({}, dr), mr);
      }, {}), fr = getDefaultCommands();
      return Object.keys(fr).forEach(function(dr) {
        ur[dr] = function(gr) {
          return execCommand(ar, fr[dr], gr);
        };
      }), cr && Object.keys(cr).forEach(function(dr) {
        ur[dr] = function(gr) {
          return execCommand(ar, cr[dr], gr);
        };
      }), ur;
    }, lr.prototype.keymaps = function(ar) {
      var cr = this.specs.filter(function(ur) {
        return ur.keymaps;
      }).map(function(ur) {
        return ur.keymaps();
      });
      return cr.map(function(ur) {
        return ar || Object.keys(ur).forEach(function(fr) {
          includes(defaultCommandShortcuts, fr) || delete ur[fr];
        }), distExports$2.keymap(ur);
      });
    }, lr.prototype.setContext = function(ar) {
      this.specs.forEach(function(cr) {
        cr.setContext(ar);
      });
    }, lr;
  }()
);
function resolveSelectionPos(lr) {
  var ar = lr.from, cr = lr.to;
  return lr instanceof distExports$3.AllSelection ? [ar + 1, cr - 1] : [ar, cr];
}
function getMdLine(lr) {
  return lr.index(0) + 1;
}
function getWidgetNodePos(lr, ar, cr) {
  cr === void 0 && (cr = 1);
  var ur = 0;
  return lr.forEach(function(fr, dr) {
    isWidgetNode(fr) && dr + 2 < ar && (ur += 2 * cr);
  }), ur;
}
function getEditorToMdPos(lr, ar, cr) {
  cr === void 0 && (cr = ar);
  var ur = ar === cr, fr = lr.resolve(ar), dr = getMdLine(fr), gr = dr, mr = fr.start(1), vr = mr;
  if (!ur) {
    var yr = lr.resolve(cr === lr.content.size ? cr - 1 : cr);
    vr = yr.start(1), gr = getMdLine(yr), yr.pos === lr.content.size && (cr = lr.content.size - 2);
  }
  var kr = Math.max(ar - mr + 1, 1), _r = Math.max(cr - vr + 1, 1);
  return [
    [dr, kr + getWidgetNodePos(lr.child(dr - 1), kr, -1)],
    [gr, _r + getWidgetNodePos(lr.child(gr - 1), _r, -1)]
  ];
}
function getStartPosListPerLine(lr, ar) {
  for (var cr = [], ur = 0, fr = 0; ur < ar; ur += 1) {
    var dr = lr.child(ur);
    cr[ur] = fr, fr += dr.nodeSize;
  }
  return cr;
}
function getMdToEditorPos(lr, ar, cr) {
  var ur = getStartPosListPerLine(lr, cr[0]), fr = ar[0] - 1, dr = cr[0] - 1, gr = lr.child(fr), mr = lr.child(dr), vr = ur[fr], yr = ur[dr];
  return vr += ar[1] + getWidgetNodePos(gr, ar[1] - 1), yr += cr[1] + getWidgetNodePos(mr, cr[1] - 1), [vr, Math.min(yr, lr.content.size)];
}
function getRangeInfo(lr) {
  var ar = lr.$from, cr = lr.$to, ur = lr.from, fr = lr.to, dr = ar.doc;
  return lr instanceof distExports$3.AllSelection && (ar = dr.resolve(ur + 1), cr = dr.resolve(fr - 1)), ar.depth === 0 && (ar = dr.resolve(ur - 1), cr = ar), {
    startFromOffset: ar.start(1),
    endFromOffset: cr.start(1),
    startToOffset: ar.end(1),
    endToOffset: cr.end(1),
    startIndex: ar.index(0),
    endIndex: cr.index(0),
    from: ar.pos,
    to: cr.pos
  };
}
function getNodeContentOffsetRange(lr, ar) {
  for (var cr = 1, ur = 1, fr = 0, dr = 0; fr < lr.childCount; fr += 1) {
    var gr = lr.child(fr).nodeSize;
    if (cr = dr + 1, ur = dr + gr - 1, fr === ar)
      break;
    dr += gr;
  }
  return { startOffset: cr, endOffset: ur };
}
var HEADING = "heading", BLOCK_QUOTE = "blockQuote", LIST_ITEM = "listItem", TABLE = "table", TABLE_CELL = "tableCell", CODE_BLOCK = "codeBlock", THEMATIC_BREAK = "thematicBreak", LINK = "link", CODE = "code", META = "meta", DELIM = "delimiter", TASK_DELIM = "taskDelimiter", TEXT = "markedText", HTML = "html", CUSTOM_BLOCK = "customBlock", delimSize = {
  strong: 2,
  emph: 1,
  strike: 2
};
function markInfo(lr, ar, cr, ur) {
  return { start: lr, end: ar, spec: { type: cr, attrs: ur } };
}
function heading$1(lr, ar, cr) {
  var ur = lr.level, fr = lr.headingType, dr = [markInfo(ar, cr, HEADING, { level: ur })];
  return fr === "atx" ? dr.push(markInfo(ar, addOffsetPos(ar, ur), DELIM)) : dr.push(markInfo(setOffsetPos(cr, 0), cr, HEADING, { seText: !0 })), dr;
}
function emphasisAndStrikethrough(lr, ar, cr) {
  var ur = lr.type, fr = addOffsetPos(ar, delimSize[ur]), dr = addOffsetPos(cr, -delimSize[ur]);
  return [
    markInfo(fr, dr, ur),
    markInfo(ar, fr, DELIM),
    markInfo(dr, cr, DELIM)
  ];
}
function markLink(lr, ar, cr, ur) {
  return [
    markInfo(lr, ar, LINK),
    markInfo(setOffsetPos(lr, cr[1] + 1), setOffsetPos(ar, ur), LINK, {
      desc: !0
    }),
    markInfo(setOffsetPos(ar, ur + 2), addOffsetPos(ar, -1), LINK, { url: !0 })
  ];
}
function image$1(lr, ar, cr) {
  var ur = lr.lastChild, fr = ur ? getMdEndCh(ur) + 1 : 3, dr = addOffsetPos(ar, 1);
  return __spreadArray$1([markInfo(ar, dr, META)], markLink(ar, cr, dr, fr));
}
function link$1(lr, ar, cr) {
  var ur = lr.lastChild, fr = lr.extendedAutolink, dr = ur ? getMdEndCh(ur) + 1 : 2;
  return fr ? [markInfo(ar, cr, LINK, { desc: !0 })] : markLink(ar, cr, ar, dr);
}
function code(lr, ar, cr) {
  var ur = lr.tickCount, fr = addOffsetPos(ar, ur), dr = addOffsetPos(cr, -ur);
  return [
    markInfo(ar, cr, CODE),
    markInfo(ar, fr, CODE, { start: !0 }),
    markInfo(fr, dr, CODE, { marked: !0 }),
    markInfo(dr, cr, CODE, { end: !0 })
  ];
}
function lineBackground(lr, ar, cr, ur) {
  var fr = {
    start: ar,
    end: cr,
    spec: {
      attrs: { className: ur + "-line-background", codeStart: ar[0], codeEnd: cr[0] }
    },
    lineBackground: !0
  };
  return lr.type !== "item" && lr.type !== "blockQuote" ? [
    __assign$1(__assign$1({}, fr), { end: ar, spec: { attrs: { className: ur + "-line-background start" } } }),
    __assign$1(__assign$1({}, fr), { start: [Math.min(ar[0] + 1, cr[0]), ar[1]] })
  ] : null;
}
function codeBlock$1(lr, ar, cr, ur) {
  var fr = lr.fenceOffset, dr = lr.fenceLength, gr = lr.fenceChar, mr = lr.info, vr = lr.infoPadding, yr = lr.parent, kr = fr + dr, _r = [markInfo(setOffsetPos(ar, 1), cr, CODE_BLOCK)];
  gr && _r.push(markInfo(ar, addOffsetPos(ar, kr), DELIM)), mr && _r.push(markInfo(addOffsetPos(ar, dr), addOffsetPos(ar, dr + vr + mr.length), META));
  var xr = "^(\\s{0,4})(" + gr + "{" + dr + ",})", Sr = new RegExp(xr);
  Sr.test(ur) && _r.push(markInfo(setOffsetPos(cr, 1), cr, DELIM));
  var Er = lineBackground(yr, ar, cr, "code-block");
  return Er ? _r.concat(Er) : _r;
}
function customBlock$2(lr, ar, cr) {
  var ur = lr, fr = ur.offset, dr = ur.syntaxLength, gr = ur.info, mr = ur.parent, vr = fr + dr, yr = [markInfo(setOffsetPos(ar, 1), cr, CUSTOM_BLOCK)];
  yr.push(markInfo(ar, addOffsetPos(ar, vr), DELIM)), gr && yr.push(markInfo(addOffsetPos(ar, vr), addOffsetPos(ar, dr + gr.length), META)), yr.push(markInfo(setOffsetPos(cr, 1), cr, DELIM));
  var kr = lineBackground(mr, ar, cr, "custom-block");
  return kr ? yr.concat(kr) : yr;
}
function markListItemChildren(lr, ar) {
  for (var cr = []; lr; ) {
    var ur = lr.type;
    (ur === "paragraph" || ur === "codeBlock") && cr.push(markInfo([getMdStartLine(lr), getMdStartCh(lr) - 1], [getMdEndLine(lr), getMdEndCh(lr) + 1], ar)), lr = lr.next;
  }
  return cr;
}
function markParagraphInBlockQuote(lr) {
  for (var ar = []; lr; )
    ar.push(markInfo([getMdStartLine(lr), getMdStartCh(lr)], [getMdEndLine(lr), getMdEndCh(lr) + 1], TEXT)), lr = lr.next;
  return ar;
}
function blockQuote$2(lr, ar, cr) {
  var ur = lr.parent && lr.parent.type !== "blockQuote" ? [markInfo(ar, cr, BLOCK_QUOTE)] : [];
  if (lr.firstChild) {
    var fr = [];
    lr.firstChild.type === "paragraph" ? fr = markParagraphInBlockQuote(lr.firstChild.firstChild) : lr.firstChild.type === "list" && (fr = markListItemChildren(lr.firstChild, TEXT)), ur = __spreadArray$1(__spreadArray$1([], ur), fr);
  }
  return ur;
}
function getSpecOfListItemStyle(lr) {
  for (var ar = 0; lr.parent.parent && lr.parent.parent.type === "item"; )
    lr = lr.parent.parent, ar += 1;
  var cr = [{ odd: !0 }, { even: !0 }][ar % 2];
  return [LIST_ITEM, __assign$1(__assign$1({}, cr), { listStyle: !0 })];
}
function item$1(lr, ar) {
  var cr = lr.listData, ur = cr.padding, fr = cr.task, dr = getSpecOfListItemStyle(lr), gr = [markInfo.apply(void 0, __spreadArray$1([ar, addOffsetPos(ar, ur)], dr))];
  return fr && (gr.push(markInfo(addOffsetPos(ar, ur), addOffsetPos(ar, ur + 3), TASK_DELIM)), gr.push(markInfo(addOffsetPos(ar, ur + 1), addOffsetPos(ar, ur + 2), META))), gr.concat(markListItemChildren(lr.firstChild, TEXT));
}
var markNodeFuncMap = {
  heading: heading$1,
  strong: emphasisAndStrikethrough,
  emph: emphasisAndStrikethrough,
  strike: emphasisAndStrikethrough,
  link: link$1,
  image: image$1,
  code,
  codeBlock: codeBlock$1,
  blockQuote: blockQuote$2,
  item: item$1,
  customBlock: customBlock$2
}, simpleMarkClassNameMap = {
  thematicBreak: THEMATIC_BREAK,
  table: TABLE,
  tableCell: TABLE_CELL,
  htmlInline: HTML
};
function getMarkInfo(lr, ar, cr, ur) {
  var fr = lr.type;
  return isFunction_1(markNodeFuncMap[fr]) ? markNodeFuncMap[fr](lr, ar, cr, ur) : simpleMarkClassNameMap[fr] ? [markInfo(ar, cr, simpleMarkClassNameMap[fr])] : null;
}
var removingBackgroundIndexMap = {};
function syntaxHighlight(lr) {
  var ar = lr.schema, cr = lr.toastMark;
  return new distExports$3.Plugin({
    appendTransaction: function(ur, fr, dr) {
      var gr = ur[0], mr = dr.tr;
      if (gr.docChanged) {
        var vr = [], yr = gr.getMeta("editResult");
        yr.forEach(function(kr) {
          var _r = kr.nodes, xr = kr.removedNodeRange;
          if (_r.length) {
            vr = vr.concat(getMarkForRemoving(mr, _r));
            for (var Sr = 0, Er = _r; Sr < Er.length; Sr++)
              for (var Cr = Er[Sr], Tr = Cr.walker(), Ar = Tr.next(); Ar; ) {
                var Ir = Ar.node, Mr = Ar.entering;
                Mr && (vr = vr.concat(getMarkForAdding(Ir, cr))), Ar = Tr.next();
              }
          } else if (xr)
            for (var Hr = mr.doc.childCount - 1, Br = xr.line, zr = Br[0], Gr = Br[1], Xr = Math.min(zr, Hr), Jr = Math.min(Gr, Hr), li = Xr; li <= Jr; li += 1)
              removingBackgroundIndexMap[li] = !0;
        }), appendMarkTr(mr, ar, vr);
      }
      return mr.setMeta("widget", gr.getMeta("widget"));
    }
  });
}
function isDifferentBlock(lr, ar, cr) {
  return Object.keys(cr).some(function(ur) {
    return cr[ur] !== lr.child(ar).attrs[ur];
  });
}
function addLineBackground(lr, ar, cr, ur, fr) {
  fr === void 0 && (fr = {});
  for (var dr = ur.startIndex, gr = ur.endIndex, mr = ur.from, vr = ur.to, yr = !1, kr = dr; kr <= gr; kr += 1)
    delete removingBackgroundIndexMap[kr], yr = isDifferentBlock(ar, kr, fr);
  yr && lr.setBlockType(mr, vr, cr, fr);
}
function appendMarkTr(lr, ar, cr) {
  var ur = lr.doc, fr = ar.nodes.paragraph, dr = getStartPosListPerLine(ur, ur.childCount);
  cr.forEach(function(gr) {
    var mr = gr.start, vr = gr.end, yr = gr.spec, kr = gr.lineBackground, _r = Math.min(mr[0], ur.childCount) - 1, xr = Math.min(vr[0], ur.childCount) - 1, Sr = ur.child(_r), Er = ur.child(xr), Cr = dr[_r], Tr = dr[xr];
    if (Cr += mr[1] + getWidgetNodePos(Sr, mr[1] - 1), Tr += vr[1] + getWidgetNodePos(Er, vr[1] - 1), yr)
      if (kr) {
        var Ar = { from: Cr, to: Tr, startIndex: _r, endIndex: xr };
        addLineBackground(lr, ur, fr, Ar, yr.attrs);
      } else
        lr.addMark(Cr, Tr, ar.mark(yr.type, yr.attrs));
    else
      lr.removeMark(Cr, Tr);
  }), removeBlockBackground(lr, dr, fr);
}
function removeBlockBackground(lr, ar, cr) {
  Object.keys(removingBackgroundIndexMap).forEach(function(ur) {
    var fr = Number(ur), dr = Math.min(Number(ur) + 1, lr.doc.childCount - 1), gr = ar[fr], mr = ar[dr] - 1;
    fr === dr && (mr += 2), lr.setBlockType(gr, mr, cr);
  });
}
function cacheIndexToRemoveBackground(lr, ar, cr) {
  var ur = [];
  removingBackgroundIndexMap = {};
  for (var fr = ar[0] - 1; fr < cr[0]; fr += 1) {
    var dr = lr.child(fr), gr = dr.attrs.codeEnd, mr = dr.attrs.codeStart;
    if (mr && gr && !includes(ur, mr)) {
      ur.push(mr), gr = Math.min(gr, lr.childCount);
      for (var vr = mr - 1, yr = cr[0], kr = vr; kr < yr; kr += 1)
        removingBackgroundIndexMap[kr] = !0;
    }
  }
}
function getMarkForRemoving(lr, ar) {
  var cr = lr.doc, ur = ar[0].sourcepos[0], fr = last$1(ar).sourcepos, dr = fr[1], gr = [ur[0], ur[1]], mr = [dr[0], dr[1] + 1], vr = [];
  return cacheIndexToRemoveBackground(cr, ur, dr), vr.push({ start: gr, end: mr }), vr;
}
function getMarkForAdding(lr, ar) {
  var cr = ar.getLineTexts(), ur = [getMdStartLine(lr), getMdStartCh(lr)], fr = [getMdEndLine(lr), getMdEndCh(lr) + 1], dr = getMarkInfo(lr, ur, fr, cr[fr[0] - 1]);
  return dr != null ? dr : [];
}
var defaultToolbarStateKeys = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function getToolbarStateType$1(lr) {
  var ar = lr.type;
  return isListNode$1(lr) ? lr.listData.task ? "taskList" : lr.listData.type === "ordered" ? "orderedList" : "bulletList" : ar.indexOf("table") !== -1 ? "table" : includes(defaultToolbarStateKeys, ar) ? ar : null;
}
function getToolbarState$1(lr) {
  var ar = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  }, cr = !0;
  return traverseParentNodes(lr, function(ur) {
    var fr = getToolbarStateType$1(ur);
    fr && (fr === "bulletList" || fr === "orderedList" ? cr && (ar[fr] = { active: !0 }, ar.indent.disabled = !1, ar.outdent.disabled = !1, cr = !1) : ar[fr] = { active: !0 });
  }), ar;
}
function previewHighlight(lr) {
  var ar = lr.toastMark, cr = lr.eventEmitter;
  return new distExports$3.Plugin({
    view: function() {
      return {
        update: function(ur, fr) {
          var dr = ur.state, gr = dr.doc, mr = dr.selection;
          if (!(fr && fr.doc.eq(gr) && fr.selection.eq(mr))) {
            var vr = mr.from, yr = dr.doc.resolve(vr).start(), kr = dr.doc.content.findIndex(vr).index + 1, _r = vr - yr;
            vr === yr && (_r += 1);
            var xr = [kr, _r], Sr = ar.findNodeAtPosition(xr), Er = getToolbarState$1(Sr);
            cr.emit("changeToolbarState", {
              cursorPos: xr,
              mdNode: Sr,
              toolbarState: Er
            }), cr.emit("setFocusedNode", Sr);
          }
        }
      };
    }
  });
}
var Doc$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Mark = (
  /** @class */
  function() {
    function lr() {
    }
    return Object.defineProperty(lr.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.setContext = function(ar) {
      this.context = ar;
    }, lr;
  }()
);
function getTextByMdLine(lr, ar) {
  return getTextContent(lr, ar - 1);
}
function getTextContent(lr, ar) {
  return lr.child(ar).textContent;
}
var reBlockQuote = /^\s*> ?/, BlockQuote$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("block-quote") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createBlockQuoteText = function(cr, ur) {
      return ur ? cr.replace(reBlockQuote, "").trim() : "> " + cr.trim();
    }, ar.prototype.extendBlockQuote = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, gr = ur.doc, mr = ur.tr, vr = ur.schema, yr = getRangeInfo(dr), kr = yr.endFromOffset, _r = yr.endToOffset, xr = yr.endIndex, Sr = yr.to, Er = getTextContent(gr, xr), Cr = reBlockQuote.test(Er);
        if (Cr && Sr > kr && dr.empty) {
          var Tr = !Er.replace(reBlockQuote, "").trim();
          if (Tr)
            mr.deleteRange(kr, _r).split(mr.mapping.map(_r));
          else {
            var Ar = Er.slice(Sr - kr).trim(), Ir = createTextNode$1(vr, cr.createBlockQuoteText(Ar));
            splitAndExtendBlock(mr, _r, Ar, Ir);
          }
          return fr(mr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      var cr = this;
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, gr = ur.doc, mr = getRangeInfo(dr), vr = mr.startFromOffset, yr = mr.endToOffset, kr = mr.startIndex, _r = mr.endIndex, xr = reBlockQuote.test(getTextContent(gr, kr)), Sr = replaceTextNode({
            state: ur,
            startIndex: kr,
            endIndex: _r,
            from: vr,
            createText: function(Er) {
              return cr.createBlockQuoteText(Er, xr);
            }
          });
          return fr(Sr.setSelection(createTextSelection(Sr, Sr.mapping.map(yr)))), !0;
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "alt-q": cr,
        "alt-Q": cr,
        Enter: this.extendBlockQuote()
      };
    }, ar;
  }(Mark)
), reList = /(^\s*)([-*+] |[\d]+\. )/, reOrderedList = /(^\s*)([\d])+\.( \[[ xX]])? /, reOrderedListGroup = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/, reCanBeTaskList = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /, reBulletListGroup = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/, reTaskList = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/, reBulletTaskList = /(^\s*)([-*+])( \[[ xX]]) /;
function getListType(lr) {
  return reOrderedList.test(lr) ? "ordered" : "bullet";
}
function getListDepth(lr) {
  for (var ar = 0; lr && lr.type !== "document"; )
    lr.type === "list" && (ar += 1), lr = lr.parent;
  return ar;
}
function findSameDepthList(lr, ar, cr, ur) {
  for (var fr = lr.getLineTexts(), dr = fr.length, gr = [], mr = ar; ur ? mr < dr : mr > 1; ) {
    mr = ur ? mr + 1 : mr - 1;
    var vr = lr.findFirstNodeAtLine(mr), yr = getListDepth(vr);
    if (yr === cr)
      gr.push({ line: mr, depth: cr, mdNode: vr });
    else if (yr < cr)
      break;
  }
  return gr;
}
function getSameDepthItems(lr) {
  var ar = lr.toastMark, cr = lr.mdNode, ur = lr.line, fr = getListDepth(cr), dr = findSameDepthList(ar, ur, fr, !1).reverse(), gr = findSameDepthList(ar, ur, fr, !0);
  return dr.concat([{ line: ur, depth: fr, mdNode: cr }]).concat(gr);
}
function textToBullet(lr) {
  if (!reList.test(lr))
    return "* " + lr;
  var ar = getListType(lr);
  return ar === "bullet" && reCanBeTaskList.test(lr) ? lr = lr.replace(reBulletTaskList, "$1$2 ") : ar === "ordered" && (lr = lr.replace(reOrderedList, "$1* ")), lr;
}
function textToOrdered(lr, ar) {
  if (!reList.test(lr))
    return ar + ". " + lr;
  var cr = getListType(lr);
  if (cr === "bullet" || cr === "ordered" && reCanBeTaskList.test(lr))
    lr = lr.replace(reCanBeTaskList, "$1" + ar + ". ");
  else if (cr === "ordered") {
    var ur = reOrderedListGroup.exec(lr)[3];
    Number(ur) !== ar && (lr = lr.replace(reOrderedList, "$1" + ar + ". "));
  }
  return lr;
}
function getChangedInfo(lr, ar, cr, ur) {
  ur === void 0 && (ur = 0);
  var fr = Number.MAX_VALUE, dr = 0, gr = ar.map(function(mr, vr) {
    var yr = mr.line;
    fr = Math.min(yr - 1, fr), dr = Math.max(yr - 1, dr);
    var kr = getTextByMdLine(lr, yr);
    return kr = cr === "bullet" ? textToBullet(kr) : textToOrdered(kr, vr + 1 + ur), { text: kr, line: yr };
  });
  return { changedResults: gr, firstIndex: fr, lastIndex: dr };
}
function getBulletOrOrdered(lr, ar) {
  var cr = getSameDepthItems(ar);
  return getChangedInfo(ar.doc, cr, lr);
}
var otherListToList = {
  bullet: function(lr) {
    return getBulletOrOrdered("bullet", lr);
  },
  ordered: function(lr) {
    return getBulletOrOrdered("ordered", lr);
  },
  task: function(lr) {
    var ar = lr.mdNode, cr = lr.doc, ur = lr.line, fr = getTextByMdLine(cr, ur);
    return ar.listData.task ? fr = fr.replace(reTaskList, "$1$2") : isListNode$1(ar) && (fr = fr.replace(reList, "$1$2[ ] ")), { changedResults: [{ text: fr, line: ur }] };
  }
}, otherNodeToList = {
  bullet: function(lr) {
    var ar = lr.doc, cr = lr.line, ur = getTextByMdLine(ar, cr), fr = [{ text: "* " + ur, line: cr }];
    return { changedResults: fr };
  },
  ordered: function(lr) {
    for (var ar = lr.toastMark, cr = lr.doc, ur = lr.line, fr = lr.startLine, dr = getTextByMdLine(cr, ur), gr = 1, mr = fr, vr = 0, yr = fr - 1; yr > 0; yr -= 1) {
      var kr = ar.findFirstNodeAtLine(yr), _r = getTextByMdLine(cr, yr), xr = _r && !!findClosestNode(kr, function(Mr) {
        return isListNode$1(Mr);
      }), Sr = reOrderedListGroup.exec(getTextByMdLine(cr, yr));
      if (!Sr && !xr)
        break;
      if (!Sr && xr) {
        vr += 1;
        continue;
      }
      var Er = Sr, Cr = Er[1], Tr = Er[3];
      if (!Cr) {
        gr = Number(Tr), mr = yr;
        break;
      }
    }
    var Ar = gr + ur - mr - vr, Ir = [{ text: Ar + ". " + dr, line: ur }];
    return { changedResults: Ir };
  },
  task: function(lr) {
    var ar = lr.doc, cr = lr.line, ur = getTextByMdLine(ar, cr), fr = [{ text: "* [ ] " + ur, line: cr }];
    return { changedResults: fr };
  }
}, extendList = {
  bullet: function(lr) {
    var ar = lr.line, cr = lr.doc, ur = getTextByMdLine(cr, ar), fr = reBulletListGroup.exec(ur), dr = fr[1], gr = fr[2];
    return { listSyntax: "" + dr + gr };
  },
  ordered: function(lr) {
    var ar = lr.toastMark, cr = lr.line, ur = lr.mdNode, fr = lr.doc, dr = getListDepth(ur), gr = getTextByMdLine(fr, cr), mr = reOrderedListGroup.exec(gr), vr = mr[1], yr = mr[3], kr = mr[4], _r = Number(yr) + 1, xr = "" + vr + _r + kr, Sr = findSameDepthList(ar, cr, dr, !0), Er = Sr.filter(function(Cr) {
      var Tr = reOrderedListGroup.exec(getTextByMdLine(fr, Cr.line));
      return Tr && Tr[1].length === vr.length && !!findClosestNode(Cr.mdNode, function(Ar) {
        return isOrderedListNode(Ar);
      });
    });
    return __assign$1({ listSyntax: xr }, getChangedInfo(fr, Er, "ordered", _r));
  }
};
function getReorderedListInfo(lr, ar, cr, ur, fr) {
  for (var dr = [], gr = getTextByMdLine(lr, cr), mr = reOrderedListGroup.exec(gr); mr; ) {
    var vr = mr[1], yr = mr[4], kr = mr[5], _r = vr.length;
    if (_r === fr)
      dr.push(createTextNode$1(ar, "" + vr + ur + yr + kr)), ur += 1, cr += 1;
    else if (_r > fr) {
      var xr = getReorderedListInfo(lr, ar, cr, 1, _r);
      cr = xr.line, dr = dr.concat(xr.nodes);
    }
    if (_r < fr || cr > lr.childCount)
      break;
    gr = getTextByMdLine(lr, cr), mr = reOrderedListGroup.exec(gr);
  }
  return { nodes: dr, line: cr };
}
var reStartSpace = /(^\s{1,4})(.*)/;
function isBlockUnit(lr, ar, cr) {
  return lr < ar || reList.test(cr) || reBlockQuote.test(cr);
}
function isInTableCellNode(lr, ar, cr) {
  var ur = cr.$from;
  ur.depth === 0 && (ur = lr.resolve(ur.pos - 1));
  var fr = ur.node(1), dr = ur.start(1), gr = fr.content.size;
  return fr.rangeHasMark(0, gr, ar.marks.table) && ur.pos - dr !== gr && ur.pos !== dr;
}
function createSelection(lr, ar) {
  var cr = ar.from, ur = ar.to;
  if (ar.type === "indent") {
    var fr = 4;
    cr += fr, ur += (ar.lineLen + 1) * fr;
  } else {
    var dr = ar.spaceLenList;
    cr -= dr[0];
    for (var gr = 0; gr < dr.length; gr += 1)
      ur -= dr[gr];
  }
  return createTextSelection(lr, cr, ur);
}
var Paragraph$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: !1,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ur.className ? ["div", { class: clsWithMdPrefix(ur.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.reorderList = function(cr, ur) {
      for (var fr = this.context, dr = fr.view, gr = fr.toastMark, mr = fr.schema, vr = dr.state, yr = vr.tr, kr = vr.selection, _r = vr.doc, xr = gr.findFirstNodeAtLine(cr), Sr = xr; xr && !isBulletListNode(xr) && xr.parent.type !== "document"; )
        if (xr = xr.parent, isOrderedListNode(xr)) {
          Sr = xr;
          break;
        }
      Sr && (cr = Sr.sourcepos[0][0]);
      var Er = reOrderedListGroup.exec(getTextByMdLine(_r, cr)), Cr = Er[1], Tr = Er[3], Ar = Cr.length, Ir = getReorderedListInfo(_r, mr, cr, Number(Tr), Ar), Mr = Ir.line, Hr = Ir.nodes;
      ur = Math.max(ur, Mr - 1);
      for (var Br = getNodeContentOffsetRange(_r, cr - 1).startOffset, zr = cr - 1; zr <= ur - 1; zr += 1) {
        var Gr = _r.child(zr), Xr = Gr.nodeSize, Jr = Gr.content, li = yr.mapping.map(Br), Qr = li + Jr.size;
        yr.replaceWith(li, Qr, Hr[zr - cr + 1]), Br += Xr;
      }
      var ei = createTextSelection(yr, kr.from, kr.to);
      dr.dispatch(yr.setSelection(ei));
    }, ar.prototype.indent = function(cr) {
      var ur = this;
      return cr === void 0 && (cr = !1), function() {
        return function(fr, dr) {
          var gr = fr.schema, mr = fr.selection, vr = fr.doc, yr = getRangeInfo(mr), kr = yr.from, _r = yr.to, xr = yr.startFromOffset, Sr = yr.startIndex, Er = yr.endIndex;
          if (cr && isInTableCellNode(vr, gr, mr))
            return !1;
          var Cr = getTextContent(vr, Sr);
          if (cr && isBlockUnit(kr, _r, Cr) || !cr && reList.test(Cr)) {
            var Tr = replaceTextNode({
              state: fr,
              from: xr,
              startIndex: Sr,
              endIndex: Er,
              createText: function(Ir) {
                return "    " + Ir;
              }
            }), Ar = {
              type: "indent",
              from: kr,
              to: _r,
              lineLen: Er - Sr
            };
            dr(Tr.setSelection(createSelection(Tr, Ar))), reOrderedListGroup.test(Cr) && ur.reorderList(Sr + 1, Er + 1);
          } else
            cr && dr(fr.tr.insert(_r, createTextNode$1(gr, "    ")));
          return !0;
        };
      };
    }, ar.prototype.outdent = function(cr) {
      var ur = this;
      return cr === void 0 && (cr = !1), function() {
        return function(fr, dr) {
          var gr = fr.selection, mr = fr.doc, vr = fr.schema, yr = getRangeInfo(gr), kr = yr.from, _r = yr.to, xr = yr.startFromOffset, Sr = yr.startIndex, Er = yr.endIndex;
          if (cr && isInTableCellNode(mr, vr, gr))
            return !1;
          var Cr = getTextContent(mr, Sr);
          if (cr && isBlockUnit(kr, _r, Cr) || !cr && reList.test(Cr)) {
            var Tr = [], Ar = replaceTextNode({
              state: fr,
              from: xr,
              startIndex: Sr,
              endIndex: Er,
              createText: function(zr) {
                var Gr = reStartSpace.exec(zr);
                return Tr.push(Gr ? Gr[1].length : 0), zr.replace(reStartSpace, "$2");
              }
            }), Ir = { type: "outdent", from: kr, to: _r, spaceLenList: Tr };
            dr(Ar.setSelection(createSelection(Ar, Ir))), reOrderedListGroup.test(Cr) && ur.reorderList(Sr + 1, Er + 1);
          } else if (cr) {
            var Mr = Cr.slice(0, _r - xr), Hr = Mr.replace(/\s{1,4}$/, ""), Br = _r - (Mr.length - Hr.length);
            dr(fr.tr.delete(Br, _r));
          }
          return !0;
        };
      };
    }, ar.prototype.deleteLines = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = cr.context.view, gr = getRangeInfo(ur.selection), mr = gr.startFromOffset, vr = gr.endToOffset, yr = function() {
          return fr(ur.tr.deleteRange(mr, vr)), !0;
        };
        return chainCommands(yr, joinForward)(ur, fr, dr);
      };
    }, ar.prototype.moveDown = function() {
      return function(cr, ur) {
        var fr = cr.doc, dr = cr.tr, gr = cr.selection, mr = cr.schema, vr = getRangeInfo(gr), yr = vr.startFromOffset, kr = vr.endToOffset, _r = vr.endIndex;
        if (_r < fr.content.childCount - 1) {
          var xr = fr.child(_r + 1), Sr = xr.nodeSize, Er = xr.textContent;
          return dr.delete(kr, kr + Sr).split(yr).insert(dr.mapping.map(yr) - 2, createTextNode$1(mr, Er)), ur(dr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveUp = function() {
      return function(cr, ur) {
        var fr = cr.tr, dr = cr.doc, gr = cr.selection, mr = cr.schema, vr = getRangeInfo(gr), yr = vr.startFromOffset, kr = vr.endToOffset, _r = vr.startIndex;
        if (_r > 0) {
          var xr = dr.child(_r - 1), Sr = xr.nodeSize, Er = xr.textContent;
          return fr.delete(yr - Sr, yr).split(fr.mapping.map(kr)).insert(fr.mapping.map(kr), createTextNode$1(mr, Er)), ur(fr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.indent(!0)(),
        "Shift-Tab": this.outdent(!0)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    }, ar;
  }(Node$2)
), Text$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reHeading = /^#{1,6}\s/, Heading$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.level, dr = ur.seText, gr = "heading|heading" + fr;
            return dr && (gr += "|delimiter|setext"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createHeadingText = function(cr, ur, fr) {
      for (var dr = ur.replace(fr, "").trim(), gr = ""; cr > 0; )
        gr += "#", cr -= 1;
      return gr + " " + dr;
    }, ar.prototype.commands = function() {
      var cr = this;
      return function(ur) {
        return function(fr, dr) {
          var gr = ur.level, mr = getRangeInfo(fr.selection), vr = mr.startFromOffset, yr = mr.endToOffset, kr = mr.startIndex, _r = mr.endIndex, xr = replaceTextNode({
            state: fr,
            from: vr,
            startIndex: kr,
            endIndex: _r,
            createText: function(Sr) {
              var Er = Sr.match(reHeading), Cr = Er ? Er[0] : "";
              return cr.createHeadingText(gr, Sr, Cr);
            }
          });
          return dr(xr.setSelection(createTextSelection(xr, xr.mapping.map(yr)))), !0;
        };
      };
    }, ar;
  }(Mark)
), fencedCodeBlockSyntax = "```", CodeBlock$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("code-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.schema, gr = cr.tr, mr = getRangeInfo(fr), vr = mr.startFromOffset, yr = mr.endToOffset, kr = createTextNode$1(dr, fencedCodeBlockSyntax);
          return gr.insert(vr, kr).split(vr + fencedCodeBlockSyntax.length), gr.split(gr.mapping.map(yr)).insert(gr.mapping.map(yr), kr), ur(gr.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            createTextSelection(gr, gr.mapping.map(yr) - (fencedCodeBlockSyntax.length + 2))
          )), !0;
        };
      };
    }, ar.prototype.keepIndentation = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, gr = ur.tr, mr = ur.doc, vr = ur.schema, yr = cr.context.toastMark, kr = getRangeInfo(dr), _r = kr.startFromOffset, xr = kr.endToOffset, Sr = kr.endIndex, Er = kr.from, Cr = kr.to, Tr = getTextContent(mr, Sr);
        if (Er === Cr && Tr.trim()) {
          var Ar = Tr.match(/^\s+/), Ir = yr.findFirstNodeAtLine(Sr + 1);
          if (isCodeBlockNode(Ir) && Ar) {
            var Mr = Ar[0], Hr = Tr.slice(Cr - _r), Br = createTextNode$1(vr, Mr + Hr);
            return splitAndExtendBlock(gr, xr, Hr, Br), fr(gr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-p": cr,
        "Shift-Mod-P": cr,
        Enter: this.keepIndentation()
      };
    }, ar;
  }(Mark)
), reEmptyTable = /\||\s/g;
function createTableHeader(lr) {
  return [createTableRow(lr), createTableRow(lr, !0)];
}
function createTableBody$1(lr, ar) {
  for (var cr = [], ur = 0; ur < ar; ur += 1)
    cr.push(createTableRow(lr));
  return cr;
}
function createTableRow(lr, ar) {
  for (var cr = "|", ur = 0; ur < lr; ur += 1)
    cr += ar ? " --- |" : "  |";
  return cr;
}
function createTargetTypes(lr) {
  return lr ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var Table$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendTable = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, gr = ur.doc, mr = ur.tr, vr = ur.schema;
        if (!dr.empty)
          return !1;
        var yr = getRangeInfo(dr), kr = yr.endFromOffset, _r = yr.endToOffset, xr = yr.endIndex, Sr = yr.to, Er = getTextContent(gr, xr), Cr = [xr + 1, Sr - kr + 1], Tr = cr.context.toastMark.findNodeAtPosition(Cr), Ar = findClosestNode(Tr, function(zr) {
          return isTableCellNode(zr) && (zr.parent.type === "tableDelimRow" || zr.parent.parent.type === "tableBody");
        });
        if (Ar) {
          var Ir = !Er.replace(reEmptyTable, "").trim(), Mr = Ar.parent, Hr = Mr.parent.parent.columns.length, Br = createTableRow(Hr);
          return Ir ? mr.deleteRange(kr, _r).split(mr.mapping.map(_r)) : mr.split(_r).insert(mr.mapping.map(_r), createTextNode$1(vr, Br)).setSelection(createTextSelection(mr, mr.mapping.map(_r) - 2)), fr(mr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveTableCell = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var gr = fr.selection, mr = fr.tr, vr = getRangeInfo(gr), yr = vr.endFromOffset, kr = vr.endIndex, _r = vr.to, xr = [kr + 1, _r - yr], Sr = ur.context.toastMark.findNodeAtPosition(xr), Er = findClosestNode(Sr, function(Gr) {
          return isTableCellNode(Gr);
        });
        if (Er) {
          var Cr = Er.parent, Tr = createTargetTypes(cr), Ar = Tr.type, Ir = Tr.parentType, Mr = Tr.childType, Hr = getMdEndCh(Er);
          if (Er[Ar])
            Hr = getMdEndCh(Er[Ar]) - 1;
          else {
            var Br = !Cr[Ar] && Cr.parent.type === Ir ? Cr.parent[Ar][Mr] : Cr[Ar];
            if (Ar === "next") {
              var zr = Br ? getMdEndCh(Br[Mr]) : 0;
              Hr += zr + 2;
            } else
              Ar === "prev" && (Hr = Br ? -4 : 0);
          }
          return dr(mr.setSelection(createTextSelection(mr, yr + Hr))), !0;
        }
        return !1;
      };
    }, ar.prototype.addTable = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.selection, gr = ur.tr, mr = ur.schema, vr = cr, yr = vr.columnCount, kr = vr.rowCount, _r = getRangeInfo(dr).endToOffset, xr = createTableHeader(yr), Sr = createTableBody$1(yr, kr - 1), Er = __spreadArray$1(__spreadArray$1([], xr), Sr);
          return Er.forEach(function(Cr) {
            gr.split(gr.mapping.map(_r)).insert(gr.mapping.map(_r), createTextNode$1(mr, Cr));
          }), fr(gr.setSelection(createTextSelection(gr, _r + 4))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { addTable: this.addTable() };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(!0),
        "Shift-Tab": this.moveTableCell(!1)
      };
    }, ar;
  }(Mark)
), thematicBreakSyntax = "***", ThematicBreak$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("thematic-break") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.schema, gr = cr.tr, mr = getRangeInfo(fr), vr = mr.from, yr = mr.to, kr = mr.endToOffset, _r = createTextNode$1(dr, thematicBreakSyntax);
          return gr.split(vr).replaceWith(gr.mapping.map(vr), gr.mapping.map(yr), _r).split(gr.mapping.map(yr)).setSelection(createTextSelection(gr, gr.mapping.map(kr))), ur(gr), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var cr = this.hr()();
      return { "Mod-l": cr, "Mod-L": cr };
    }, ar;
  }(Mark)
);
function cannotBeListNode(lr, ar) {
  var cr = lr.type, ur = lr.sourcepos, fr = ur[0][0];
  return ar <= fr && (cr === "codeBlock" || cr === "heading" || cr.match("table"));
}
var ListItem$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: !1 },
            even: { default: !1 },
            listStyle: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.odd, dr = ur.even, gr = ur.listStyle, mr = "list-item";
            return gr && (mr += "|list-item-style"), fr && (mr += "|list-item-odd"), dr && (mr += "|list-item-even"), ["span", { class: clsWithMdPrefix.apply(void 0, mr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendList = function() {
      var cr = this;
      return function(ur, fr) {
        var dr = ur.selection, gr = ur.doc, mr = ur.schema, vr = ur.tr, yr = cr.context.toastMark, kr = getRangeInfo(dr), _r = kr.to, xr = kr.startFromOffset, Sr = kr.endFromOffset, Er = kr.endIndex, Cr = kr.endToOffset, Tr = getTextContent(gr, Er), Ar = reList.test(Tr);
        if (!Ar || dr.from === xr || !dr.empty)
          return !1;
        var Ir = !Tr.replace(reCanBeTaskList, "").trim();
        if (Ir)
          vr.deleteRange(Sr, Cr).split(vr.mapping.map(Cr));
        else {
          var Mr = getListType(Tr), Hr = yr.findFirstNodeAtLine(Er + 1), Br = Tr.slice(_r - Sr), zr = { toastMark: yr, mdNode: Hr, doc: gr, line: Er + 1 }, Gr = extendList[Mr](zr), Xr = Gr.listSyntax, Jr = Gr.changedResults;
          if (Jr != null && Jr.length) {
            vr.split(_r), Jr.unshift({ text: Xr + Br, line: Er + 1 }), cr.changeToListPerLine(vr, Jr, {
              from: _r,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: Jr[0].line,
              endLine: last$1(Jr).line
            });
            var li = vr.mapping.map(Cr) - Br.length;
            vr.setSelection(createTextSelection(vr, li));
          } else {
            var Qr = createTextNode$1(mr, Xr + Br);
            splitAndExtendBlock(vr, Cr, Br, Qr);
          }
        }
        return fr(vr), !0;
      };
    }, ar.prototype.toList = function(cr) {
      var ur = this;
      return function() {
        return function(fr, dr) {
          for (var gr = fr.doc, mr = fr.tr, vr = fr.selection, yr = ur.context.toastMark, kr = getRangeInfo(vr), _r = kr.startIndex + 1, xr = kr.endIndex + 1, Sr = kr.endToOffset, Er = [], Cr = _r; Cr <= xr; Cr += 1) {
            var Tr = yr.findFirstNodeAtLine(Cr);
            if (Tr && cannotBeListNode(Tr, Cr))
              break;
            if (Er.indexOf(Cr) === -1) {
              var Ar = { toastMark: yr, mdNode: Tr, doc: gr, line: Cr, startLine: _r }, Ir = (isListNode$1(Tr) ? otherListToList[cr](Ar) : otherNodeToList[cr](Ar)).changedResults, Mr = ur.changeToListPerLine(mr, Ir, {
                from: getNodeContentOffsetRange(gr, Ir[0].line - 1).startOffset,
                startLine: Ir[0].line,
                endLine: last$1(Ir).line,
                indexDiff: 1
              });
              Sr = Math.max(Mr, Sr), Ir && (Er = Er.concat(Ir.map(function(Hr) {
                return Hr.line;
              })));
            }
          }
          return dr(mr.setSelection(createTextSelection(mr, mr.mapping.map(Sr)))), !0;
        };
      };
    }, ar.prototype.changeToListPerLine = function(cr, ur, fr) {
      for (var dr = fr.from, gr = fr.startLine, mr = fr.endLine, vr = fr.indexDiff, yr = vr === void 0 ? 0 : vr, kr = 0, _r = function(Er) {
        var Cr = cr.doc.child(Er), Tr = Cr.nodeSize, Ar = Cr.content, Ir = cr.mapping.map(dr), Mr = Ir + Ar.size, Hr = ur.filter(function(Br) {
          return Br.line - yr === Er;
        })[0];
        Hr && (cr.replaceWith(Ir, Mr, createTextNode$1(xr.context.schema, Hr.text)), kr = Math.max(kr, dr + Ar.size)), dr += Tr;
      }, xr = this, Sr = gr - yr; Sr <= mr - yr; Sr += 1)
        _r(Sr);
      return kr;
    }, ar.prototype.toggleTask = function() {
      var cr = this;
      return function(ur, fr) {
        for (var dr = ur.selection, gr = ur.tr, mr = ur.doc, vr = ur.schema, yr = cr.context.toastMark, kr = getRangeInfo(dr), _r = kr.startIndex, xr = kr.endIndex, Sr = null, Er = _r; Er <= xr; Er += 1) {
          var Cr = yr.findFirstNodeAtLine(Er + 1);
          if (isListNode$1(Cr) && Cr.listData.task) {
            var Tr = Cr.listData, Ar = Tr.checked, Ir = Tr.padding, Mr = Ar ? " " : "x", Hr = Cr.sourcepos[0], Br = getNodeContentOffsetRange(mr, Hr[0] - 1).startOffset;
            Br += Hr[1] + Ir, Sr = gr.replaceWith(Br, Br + 1, vr.text(Mr));
          }
        }
        return Sr ? (fr(Sr), !0) : !1;
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.toList("bullet")(), ur = this.toList("ordered")(), fr = this.toList("task")(), dr = this.toggleTask();
      return {
        "Mod-u": cr,
        "Mod-U": cr,
        "Mod-o": ur,
        "Mod-O": ur,
        "alt-t": fr,
        "alt-T": fr,
        "Shift-Ctrl-x": dr,
        "Shift-Ctrl-X": dr,
        Enter: this.extendList()
      };
    }, ar;
  }(Mark)
);
function toggleMark(lr, ar) {
  return function() {
    return function(cr, ur) {
      var fr = cr.tr, dr = cr.selection, gr = isFunction_1(lr) ? lr : function(Mr) {
        return lr.test(Mr);
      }, mr = ar.length, vr = fr.doc, yr = resolveSelectionPos(dr), kr = yr[0], _r = yr[1], xr = Math.max(kr - mr, 1), Sr = Math.min(_r + mr, vr.content.size - 1), Er = dr.content(), Cr = Er.content.textBetween(0, Er.content.size, `
`), Tr = vr.textBetween(xr, kr, `
`), Ar = vr.textBetween(_r, Sr, `
`);
      if (Cr = "" + Tr + Cr + Ar, Tr && Ar && gr(Cr))
        fr.delete(Sr - mr, Sr).delete(xr, xr + mr);
      else {
        fr.insertText(ar, _r).insertText(ar, kr);
        var Ir = dr.empty ? createTextSelection(fr, kr + mr) : createTextSelection(fr, kr + mr, _r + mr);
        fr.setSelection(Ir);
      }
      return ur(fr), !0;
    };
  };
}
var reStrong = /^(\*{2}|_{2}).*([\s\S]*)\1$/m, strongSyntax = "**", Strong$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strong") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return toggleMark(reStrong, strongSyntax);
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var cr = this.bold()();
      return { "Mod-b": cr, "Mod-B": cr };
    }, ar;
  }(Mark)
), reStrike = /^(~{2}).*([\s\S]*)\1$/m, strikeSyntax = "~~", Strike$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strike") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reStrike, strikeSyntax);
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return { "Mod-s": cr, "Mod-S": cr };
    }, ar;
  }(Mark)
), reEmph = /^(\*|_).*([\s\S]*)\1$/m, emphSyntax = "*", Emph$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("emph") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return toggleMark(reEmph, emphSyntax);
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var cr = this.italic()();
      return { "Mod-i": cr, "Mod-I": cr };
    }, ar;
  }(Mark)
), reCode = /^(`).*([\s\S]*)\1$/m, codeSyntax = "`", Code$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: !1 },
            end: { default: !1 },
            marked: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.start, dr = ur.end, gr = ur.marked, mr = "code";
            return fr && (mr += "|delimiter|start"), dr && (mr += "|delimiter|end"), gr && (mr += "|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, mr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reCode, codeSyntax);
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return { "Shift-Mod-c": cr, "Shift-Mod-C": cr };
    }, ar;
  }(Mark)
), Link$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: !1 },
            desc: { default: !1 }
          },
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.url, dr = ur.desc, gr = "link";
            return fr && (gr += "|link-url|marked-text"), dr && (gr += "|link-desc|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLinkOrImage = function(cr) {
      return function(ur) {
        return function(fr, dr) {
          var gr = fr.selection, mr = fr.tr, vr = fr.schema, yr = resolveSelectionPos(gr), kr = yr[0], _r = yr[1], xr = ur, Sr = xr.linkText, Er = xr.altText, Cr = xr.linkUrl, Tr = xr.imageUrl, Ar = Sr, Ir = Cr, Mr = "";
          return cr === "image" && (Ar = Er, Ir = Tr, Mr = "!"), Ar = escapeTextForLink(Ar), Mr += "[" + Ar + "](" + Ir + ")", dr(mr.replaceWith(kr, _r, createTextNode$1(vr, Mr))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    }, ar;
  }(Mark)
), TaskDelimiter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Delimiter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Meta = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("meta") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), MarkedText = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("marked-text") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), TableCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table-cell") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Html = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("html") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), customBlockSyntax = "$$", CustomBlock$1 = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("custom-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.selection, gr = ur.schema, mr = ur.tr, vr = getRangeInfo(dr), yr = vr.startFromOffset, kr = vr.endToOffset;
          if (!(cr != null && cr.info))
            return !1;
          var _r = "" + customBlockSyntax + cr.info, xr = createTextNode$1(gr, _r), Sr = createTextNode$1(gr, customBlockSyntax);
          return mr.insert(yr, xr).split(yr + _r.length), mr.split(mr.mapping.map(kr)).insert(mr.mapping.map(kr), Sr), fr(mr.setSelection(createTextSelection(mr, mr.mapping.map(kr) - (customBlockSyntax.length + 2)))), !0;
        };
      };
    }, ar;
  }(Mark)
), reTaskMarkerKey = /x|backspace/i, reTaskMarker = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function smartTask(lr) {
  var ar = lr.schema, cr = lr.toastMark;
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        keyup: function(ur, fr) {
          var dr, gr = ur.state, mr = gr.doc, vr = gr.tr, yr = gr.selection;
          if (yr.empty && reTaskMarkerKey.test(fr.key)) {
            var kr = getRangeInfo(yr), _r = kr.startIndex, xr = kr.startFromOffset, Sr = kr.from, Er = [_r + 1, Sr - xr + 1], Cr = cr.findNodeAtPosition(Er), Tr = findClosestNode(Cr, function(Qr) {
              var ei;
              return Qr.type === "paragraph" && ((ei = Qr.parent) === null || ei === void 0 ? void 0 : ei.type) === "item";
            });
            if (!((dr = Tr == null ? void 0 : Tr.firstChild) === null || dr === void 0) && dr.literal) {
              var Ar = Tr.firstChild, Ir = Ar.literal.match(reTaskMarker);
              if (Ir) {
                var Mr = Ar.sourcepos[0], Hr = Ir[1], Br = Ir[2], zr = Ir[3], Gr = Hr.length + zr.length, Xr = getNodeContentOffsetRange(mr, Mr[0] - 1).startOffset, Jr = Mr[1] + Xr;
                if (Br) {
                  var li = Gr ? Gr + 1 : 0;
                  vr.replaceWith(Jr, li + Jr, ar.text(Br)), ur.dispatch(vr);
                } else
                  Gr || (vr.insertText(" ", Jr), ur.dispatch(vr));
              }
            }
          }
          return !1;
        }
      }
    }
  });
}
var EVENT_TYPE = "cut", reLineEnding$2 = /\r\n|\n|\r/, MdEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr) || this, dr = ur.toastMark, gr = ur.useCommandShortcut, mr = gr === void 0 ? !0 : gr, vr = ur.mdPlugins, yr = vr === void 0 ? [] : vr;
      return fr.editorType = "markdown", fr.el.classList.add("md-mode"), fr.toastMark = dr, fr.extraPlugins = yr, fr.specs = fr.createSpecs(), fr.schema = fr.createSchema(), fr.context = fr.createContext(), fr.keymaps = fr.createKeymaps(mr), fr.view = fr.createView(), fr.commands = fr.createCommands(), fr.specs.setContext(__assign$1(__assign$1({}, fr.context), { view: fr.view })), fr.createClipboard(), fr.eventEmitter.listen("changePreviewTabWrite", function(kr) {
        return fr.toggleActive(!0, kr);
      }), fr.eventEmitter.listen("changePreviewTabPreview", function() {
        return fr.toggleActive(!1);
      }), fr.initEvent(), fr;
    }
    return ar.prototype.toggleActive = function(cr, ur) {
      toggleClass(this.el, "active", cr), cr ? ur || this.focus() : this.blur();
    }, ar.prototype.createClipboard = function() {
      var cr = this;
      this.clipboard = document.createElement("textarea"), this.clipboard.className = cls("pseudo-clipboard"), this.clipboard.addEventListener("paste", function(ur) {
        var fr = ur.clipboardData || window.clipboardData, dr = fr && fr.items;
        if (dr) {
          var gr = toArray_1(dr).some(function(vr) {
            return vr.kind === "string" && vr.type === "text/rtf";
          });
          if (!gr) {
            var mr = pasteImageOnly(dr);
            mr && (ur.preventDefault(), emitImageBlobHook(cr.eventEmitter, mr, ur.type));
          }
        }
      }), this.clipboard.addEventListener("input", function(ur) {
        var fr = ur.target.value;
        cr.replaceSelection(fr), ur.preventDefault(), ur.target.value = "";
      }), this.el.insertBefore(this.clipboard, this.view.dom);
    }, ar.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSpecs = function() {
      return new SpecManager([
        new Doc$1(),
        new Paragraph$1(),
        new Widget(),
        new Text$1(),
        new Heading$1(),
        new BlockQuote$1(),
        new CodeBlock$1(),
        new CustomBlock$1(),
        new Table$1(),
        new TableCell(),
        new ThematicBreak$1(),
        new ListItem$1(),
        new Strong$1(),
        new Strike$1(),
        new Emph$1(),
        new Code$1(),
        new Link$1(),
        new Delimiter(),
        new TaskDelimiter(),
        new MarkedText(),
        new Meta(),
        new Html()
      ]);
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        syntaxHighlight(this.context),
        previewHighlight(this.context),
        smartTask(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createView = function() {
      var cr = this;
      return new distExports$4.EditorView(this.el, {
        state: this.createState(),
        dispatchTransaction: function(ur) {
          cr.updateMarkdown(ur);
          var fr = cr.view.state.applyTransaction(ur).state;
          cr.view.updateState(fr), cr.emitChangeEvent(ur);
        },
        handleKeyDown: function(ur, fr) {
          return (fr.metaKey || fr.ctrlKey) && fr.key.toUpperCase() === "V" && cr.clipboard.focus(), cr.eventEmitter.emit("keydown", cr.editorType, fr), !1;
        },
        handleDOMEvents: {
          copy: function(ur, fr) {
            return cr.captureCopy(fr);
          },
          cut: function(ur, fr) {
            return cr.captureCopy(fr, EVENT_TYPE);
          },
          scroll: function() {
            return cr.eventEmitter.emit("scroll", "editor"), !0;
          },
          keyup: function(ur, fr) {
            return cr.eventEmitter.emit("keyup", cr.editorType, fr), !1;
          }
        },
        nodeViews: {
          widget: widgetNodeView
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, ar.prototype.captureCopy = function(cr, ur) {
      cr.preventDefault();
      var fr = this.view.state, dr = fr.selection, gr = fr.tr;
      if (dr.empty)
        return !0;
      var mr = this.getChanged(dr.content());
      return cr.clipboardData ? cr.clipboardData.setData("text/plain", mr) : window.clipboardData.setData("Text", mr), ur === EVENT_TYPE && this.view.dispatch(gr.deleteSelection().scrollIntoView().setMeta("uiEvent", EVENT_TYPE)), !0;
    }, ar.prototype.updateMarkdown = function(cr) {
      var ur = this;
      cr.docChanged && cr.steps.forEach(function(fr, dr) {
        if (fr.slice && !(fr instanceof ReplaceAroundStep)) {
          var gr = cr.docs[dr], mr = [fr.from, fr.to], vr = mr[0], yr = mr[1], kr = getEditorToMdPos(gr, vr, yr), _r = kr[0], xr = kr[1], Sr = ur.getChanged(fr.slice);
          _r[0] === xr[0] && _r[1] === xr[1] && Sr === "" && (Sr = `
`);
          var Er = ur.toastMark.editMarkdown(_r, xr, Sr);
          ur.eventEmitter.emit("updatePreview", Er), cr.setMeta("editResult", Er).scrollIntoView();
        }
      });
    }, ar.prototype.getChanged = function(cr) {
      var ur = "", fr = 0, dr = cr.content.size;
      return cr.content.nodesBetween(fr, dr, function(gr, mr) {
        gr.isText ? ur += gr.text.slice(Math.max(fr, mr) - mr, dr - mr) : gr.isBlock && mr > 0 && (ur += `
`);
      }), ur;
    }, ar.prototype.setSelection = function(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this.view.state.tr, dr = getMdToEditorPos(fr.doc, cr, ur), gr = dr[0], mr = dr[1];
      this.view.dispatch(fr.setSelection(createTextSelection(fr, gr, mr)).scrollIntoView());
    }, ar.prototype.replaceSelection = function(cr, ur, fr) {
      var dr, gr = this.view.state, mr = gr.tr, vr = gr.schema, yr = gr.doc, kr = cr.split(reLineEnding$2), _r = kr.map(function(Tr) {
        return createParagraph(vr, createNodesWithWidget(Tr, vr));
      }), xr = new distExports$5.Slice(distExports$5.Fragment.from(_r), 1, 1);
      if (this.focus(), ur && fr) {
        var Sr = getMdToEditorPos(yr, ur, fr), Er = Sr[0], Cr = Sr[1];
        dr = mr.replaceRange(Er, Cr, xr);
      } else
        dr = mr.replaceSelection(xr);
      this.view.dispatch(dr.scrollIntoView());
    }, ar.prototype.deleteSelection = function(cr, ur) {
      var fr, dr = this.view.state, gr = dr.tr, mr = dr.doc;
      if (cr && ur) {
        var vr = getMdToEditorPos(mr, cr, ur), yr = vr[0], kr = vr[1];
        fr = gr.deleteRange(yr, kr);
      } else
        fr = gr.deleteSelection();
      this.view.dispatch(fr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(cr, ur) {
      var fr = this.view.state, dr = fr.doc, gr = fr.selection, mr = gr.from, vr = gr.to;
      if (cr && ur) {
        var yr = getMdToEditorPos(dr, cr, ur);
        mr = yr[0], vr = yr[1];
      }
      return dr.textBetween(mr, vr, `
`);
    }, ar.prototype.getSelection = function() {
      var cr = this.view.state.selection, ur = cr.from, fr = cr.to;
      return getEditorToMdPos(this.view.state.tr.doc, ur, fr);
    }, ar.prototype.setMarkdown = function(cr, ur) {
      ur === void 0 && (ur = !0);
      var fr = cr.split(reLineEnding$2), dr = this.view.state, gr = dr.tr, mr = dr.doc, vr = dr.schema, yr = fr.map(function(kr) {
        return createParagraph(vr, createNodesWithWidget(kr, vr));
      });
      this.view.dispatch(gr.replaceWith(0, mr.content.size, yr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.addWidget = function(cr, ur, fr) {
      var dr = this.view.state, gr = dr.tr, mr = dr.doc, vr = dr.selection, yr = fr ? getMdToEditorPos(mr, fr, fr)[0] : vr.to;
      this.view.dispatch(gr.setMeta("widget", { pos: yr, node: cr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(cr, ur, fr) {
      var dr = this.view.state, gr = dr.tr, mr = dr.schema, vr = dr.doc, yr = getMdToEditorPos(vr, cr, ur), kr = createNodesWithWidget(fr, mr);
      this.view.dispatch(gr.replaceWith(yr[0], yr[1], kr));
    }, ar.prototype.getRangeInfoOfNode = function(cr) {
      var ur = this.view.state, fr = ur.doc, dr = ur.selection, gr = cr || getEditorToMdPos(fr, dr.from)[0], mr = this.toastMark.findNodeAtPosition(gr);
      return mr.type === "text" && mr.parent.type !== "paragraph" && (mr = mr.parent), mr.sourcepos[1][1] += 1, { range: mr.sourcepos, type: mr.type };
    }, ar.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(cr) {
        return unwrapWidgetSyntax(cr);
      }).join(`
`);
    }, ar.prototype.getToastMark = function() {
      return this.toastMark;
    }, ar;
  }(EditorBase)
), EVENT_KEY = "_feEventKey";
function safeEvent$2(lr, ar) {
  var cr = lr[EVENT_KEY], ur;
  return cr || (cr = lr[EVENT_KEY] = {}), ur = cr[ar], ur || (ur = cr[ar] = []), ur;
}
var _safeEvent = safeEvent$2, isString$1 = isString_1, forEach$1 = forEach_1, safeEvent$1 = _safeEvent;
function off(lr, ar, cr) {
  if (isString$1(ar)) {
    forEach$1(ar.split(/\s+/g), function(ur) {
      unbindEvent(lr, ur, cr);
    });
    return;
  }
  forEach$1(ar, function(ur, fr) {
    unbindEvent(lr, fr, ur);
  });
}
function unbindEvent(lr, ar, cr) {
  var ur = safeEvent$1(lr, ar), fr;
  cr ? (forEach$1(ur, function(dr, gr) {
    return cr === dr.handler ? (removeHandler(lr, ar, dr.wrappedHandler), fr = gr, !1) : !0;
  }), ur.splice(fr, 1)) : (forEach$1(ur, function(dr) {
    removeHandler(lr, ar, dr.wrappedHandler);
  }), ur.splice(0, ur.length));
}
function removeHandler(lr, ar, cr) {
  "removeEventListener" in lr ? lr.removeEventListener(ar, cr) : "detachEvent" in lr && lr.detachEvent("on" + ar, cr);
}
var off_1 = off, isString = isString_1, forEach = forEach_1, safeEvent = _safeEvent;
function on(lr, ar, cr, ur) {
  if (isString(ar)) {
    forEach(ar.split(/\s+/g), function(fr) {
      bindEvent(lr, fr, cr, ur);
    });
    return;
  }
  forEach(ar, function(fr, dr) {
    bindEvent(lr, dr, fr, cr);
  });
}
function bindEvent(lr, ar, cr, ur) {
  function fr(dr) {
    cr.call(ur || lr, dr || window.event);
  }
  "addEventListener" in lr ? lr.addEventListener(ar, fr) : "attachEvent" in lr && lr.attachEvent("on" + ar, fr), memorizeHandler(lr, ar, cr, fr);
}
function memorizeHandler(lr, ar, cr, ur) {
  var fr = safeEvent(lr, ar), dr = !1;
  forEach(fr, function(gr) {
    return gr.handler === cr ? (dr = !0, !1) : !0;
  }), dr || fr.push({
    handler: cr,
    wrappedHandler: ur
  });
}
var on_1 = on;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(lr, ar) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(cr, ur) {
    cr.__proto__ = ur;
  } || function(cr, ur) {
    for (var fr in ur)
      Object.prototype.hasOwnProperty.call(ur, fr) && (cr[fr] = ur[fr]);
  }, extendStatics(lr, ar);
};
function __extends(lr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics(lr, ar);
  function cr() {
    this.constructor = lr;
  }
  lr.prototype = ar === null ? Object.create(ar) : (cr.prototype = ar.prototype, new cr());
}
var __assign = function() {
  return __assign = Object.assign || function(ar) {
    for (var cr, ur = 1, fr = arguments.length; ur < fr; ur++) {
      cr = arguments[ur];
      for (var dr in cr)
        Object.prototype.hasOwnProperty.call(cr, dr) && (ar[dr] = cr[dr]);
    }
    return ar;
  }, __assign.apply(this, arguments);
};
function __spreadArray(lr, ar, cr) {
  if (cr || arguments.length === 2)
    for (var ur = 0, fr = ar.length, dr; ur < fr; ur++)
      (dr || !(ur in ar)) && (dr || (dr = Array.prototype.slice.call(ar, 0, ur)), dr[ur] = ar[ur]);
  return lr.concat(dr || Array.prototype.slice.call(ar));
}
var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, encodeCache = {};
function getEncodeCache(lr) {
  var ar, cr, ur = encodeCache[lr];
  if (ur)
    return ur;
  for (ur = encodeCache[lr] = [], ar = 0; ar < 128; ar++)
    cr = String.fromCharCode(ar), /^[0-9a-z]$/i.test(cr) ? ur.push(cr) : ur.push("%" + ("0" + ar.toString(16).toUpperCase()).slice(-2));
  for (ar = 0; ar < lr.length; ar++)
    ur[lr.charCodeAt(ar)] = lr[ar];
  return ur;
}
function encode$1(lr, ar, cr) {
  var ur, fr, dr, gr, mr, vr = "";
  for (typeof ar != "string" && (cr = ar, ar = encode$1.defaultChars), typeof cr == "undefined" && (cr = !0), mr = getEncodeCache(ar), ur = 0, fr = lr.length; ur < fr; ur++) {
    if (dr = lr.charCodeAt(ur), cr && dr === 37 && ur + 2 < fr && /^[0-9a-f]{2}$/i.test(lr.slice(ur + 1, ur + 3))) {
      vr += lr.slice(ur, ur + 3), ur += 2;
      continue;
    }
    if (dr < 128) {
      vr += mr[dr];
      continue;
    }
    if (dr >= 55296 && dr <= 57343) {
      if (dr >= 55296 && dr <= 56319 && ur + 1 < fr && (gr = lr.charCodeAt(ur + 1), gr >= 56320 && gr <= 57343)) {
        vr += encodeURIComponent(lr[ur] + lr[ur + 1]), ur++;
        continue;
      }
      vr += "%EF%BF%BD";
      continue;
    }
    vr += encodeURIComponent(lr[ur]);
  }
  return vr;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1, lib = {}, decode = {}, Aacute$1 = "Á", aacute$1 = "á", Abreve = "Ă", abreve = "ă", ac = "∾", acd = "∿", acE = "∾̳", Acirc$1 = "Â", acirc$1 = "â", acute$1 = "´", Acy = "А", acy = "а", AElig$1 = "Æ", aelig$1 = "æ", af = "⁡", Afr = "𝔄", afr = "𝔞", Agrave$1 = "À", agrave$1 = "à", alefsym = "ℵ", aleph = "ℵ", Alpha = "Α", alpha = "α", Amacr = "Ā", amacr = "ā", amalg = "⨿", amp$2 = "&", AMP$1 = "&", andand = "⩕", And = "⩓", and = "∧", andd = "⩜", andslope = "⩘", andv = "⩚", ang = "∠", ange = "⦤", angle = "∠", angmsdaa = "⦨", angmsdab = "⦩", angmsdac = "⦪", angmsdad = "⦫", angmsdae = "⦬", angmsdaf = "⦭", angmsdag = "⦮", angmsdah = "⦯", angmsd = "∡", angrt = "∟", angrtvb = "⊾", angrtvbd = "⦝", angsph = "∢", angst = "Å", angzarr = "⍼", Aogon = "Ą", aogon = "ą", Aopf = "𝔸", aopf = "𝕒", apacir = "⩯", ap = "≈", apE = "⩰", ape = "≊", apid = "≋", apos$1 = "'", ApplyFunction = "⁡", approx = "≈", approxeq = "≊", Aring$1 = "Å", aring$1 = "å", Ascr = "𝒜", ascr = "𝒶", Assign = "≔", ast = "*", asymp = "≈", asympeq = "≍", Atilde$1 = "Ã", atilde$1 = "ã", Auml$1 = "Ä", auml$1 = "ä", awconint = "∳", awint = "⨑", backcong = "≌", backepsilon = "϶", backprime = "‵", backsim = "∽", backsimeq = "⋍", Backslash = "∖", Barv = "⫧", barvee = "⊽", barwed = "⌅", Barwed = "⌆", barwedge = "⌅", bbrk = "⎵", bbrktbrk = "⎶", bcong = "≌", Bcy = "Б", bcy = "б", bdquo = "„", becaus = "∵", because = "∵", Because = "∵", bemptyv = "⦰", bepsi = "϶", bernou = "ℬ", Bernoullis = "ℬ", Beta = "Β", beta = "β", beth = "ℶ", between = "≬", Bfr = "𝔅", bfr = "𝔟", bigcap = "⋂", bigcirc = "◯", bigcup = "⋃", bigodot = "⨀", bigoplus = "⨁", bigotimes = "⨂", bigsqcup = "⨆", bigstar = "★", bigtriangledown = "▽", bigtriangleup = "△", biguplus = "⨄", bigvee = "⋁", bigwedge = "⋀", bkarow = "⤍", blacklozenge = "⧫", blacksquare = "▪", blacktriangle = "▴", blacktriangledown = "▾", blacktriangleleft = "◂", blacktriangleright = "▸", blank = "␣", blk12 = "▒", blk14 = "░", blk34 = "▓", block$1 = "█", bne = "=⃥", bnequiv = "≡⃥", bNot = "⫭", bnot = "⌐", Bopf = "𝔹", bopf = "𝕓", bot = "⊥", bottom = "⊥", bowtie = "⋈", boxbox = "⧉", boxdl = "┐", boxdL = "╕", boxDl = "╖", boxDL = "╗", boxdr = "┌", boxdR = "╒", boxDr = "╓", boxDR = "╔", boxh = "─", boxH = "═", boxhd = "┬", boxHd = "╤", boxhD = "╥", boxHD = "╦", boxhu = "┴", boxHu = "╧", boxhU = "╨", boxHU = "╩", boxminus = "⊟", boxplus = "⊞", boxtimes = "⊠", boxul = "┘", boxuL = "╛", boxUl = "╜", boxUL = "╝", boxur = "└", boxuR = "╘", boxUr = "╙", boxUR = "╚", boxv = "│", boxV = "║", boxvh = "┼", boxvH = "╪", boxVh = "╫", boxVH = "╬", boxvl = "┤", boxvL = "╡", boxVl = "╢", boxVL = "╣", boxvr = "├", boxvR = "╞", boxVr = "╟", boxVR = "╠", bprime = "‵", breve = "˘", Breve = "˘", brvbar$1 = "¦", bscr = "𝒷", Bscr = "ℬ", bsemi = "⁏", bsim = "∽", bsime = "⋍", bsolb = "⧅", bsol = "\\", bsolhsub = "⟈", bull = "•", bullet$1 = "•", bump = "≎", bumpE = "⪮", bumpe = "≏", Bumpeq = "≎", bumpeq = "≏", Cacute = "Ć", cacute = "ć", capand = "⩄", capbrcup = "⩉", capcap = "⩋", cap = "∩", Cap = "⋒", capcup = "⩇", capdot = "⩀", CapitalDifferentialD = "ⅅ", caps = "∩︀", caret$1 = "⁁", caron = "ˇ", Cayleys = "ℭ", ccaps = "⩍", Ccaron = "Č", ccaron = "č", Ccedil$1 = "Ç", ccedil$1 = "ç", Ccirc = "Ĉ", ccirc = "ĉ", Cconint = "∰", ccups = "⩌", ccupssm = "⩐", Cdot = "Ċ", cdot = "ċ", cedil$1 = "¸", Cedilla = "¸", cemptyv = "⦲", cent$1 = "¢", centerdot = "·", CenterDot = "·", cfr = "𝔠", Cfr = "ℭ", CHcy = "Ч", chcy = "ч", check = "✓", checkmark = "✓", Chi = "Χ", chi = "χ", circ = "ˆ", circeq = "≗", circlearrowleft = "↺", circlearrowright = "↻", circledast = "⊛", circledcirc = "⊚", circleddash = "⊝", CircleDot = "⊙", circledR = "®", circledS = "Ⓢ", CircleMinus = "⊖", CirclePlus = "⊕", CircleTimes = "⊗", cir = "○", cirE = "⧃", cire = "≗", cirfnint = "⨐", cirmid = "⫯", cirscir = "⧂", ClockwiseContourIntegral = "∲", CloseCurlyDoubleQuote = "”", CloseCurlyQuote = "’", clubs = "♣", clubsuit = "♣", colon = ":", Colon = "∷", Colone = "⩴", colone = "≔", coloneq = "≔", comma = ",", commat = "@", comp = "∁", compfn = "∘", complement = "∁", complexes = "ℂ", cong = "≅", congdot = "⩭", Congruent = "≡", conint = "∮", Conint = "∯", ContourIntegral = "∮", copf = "𝕔", Copf = "ℂ", coprod = "∐", Coproduct = "∐", copy$1 = "©", COPY$1 = "©", copysr = "℗", CounterClockwiseContourIntegral = "∳", crarr = "↵", cross = "✗", Cross = "⨯", Cscr = "𝒞", cscr = "𝒸", csub = "⫏", csube = "⫑", csup = "⫐", csupe = "⫒", ctdot = "⋯", cudarrl = "⤸", cudarrr = "⤵", cuepr = "⋞", cuesc = "⋟", cularr = "↶", cularrp = "⤽", cupbrcap = "⩈", cupcap = "⩆", CupCap = "≍", cup = "∪", Cup = "⋓", cupcup = "⩊", cupdot = "⊍", cupor = "⩅", cups = "∪︀", curarr = "↷", curarrm = "⤼", curlyeqprec = "⋞", curlyeqsucc = "⋟", curlyvee = "⋎", curlywedge = "⋏", curren$1 = "¤", curvearrowleft = "↶", curvearrowright = "↷", cuvee = "⋎", cuwed = "⋏", cwconint = "∲", cwint = "∱", cylcty = "⌭", dagger = "†", Dagger = "‡", daleth = "ℸ", darr = "↓", Darr = "↡", dArr = "⇓", dash = "‐", Dashv = "⫤", dashv = "⊣", dbkarow = "⤏", dblac = "˝", Dcaron = "Ď", dcaron = "ď", Dcy = "Д", dcy = "д", ddagger = "‡", ddarr = "⇊", DD = "ⅅ", dd = "ⅆ", DDotrahd = "⤑", ddotseq = "⩷", deg$1 = "°", Del = "∇", Delta = "Δ", delta = "δ", demptyv = "⦱", dfisht = "⥿", Dfr = "𝔇", dfr = "𝔡", dHar = "⥥", dharl = "⇃", dharr = "⇂", DiacriticalAcute = "´", DiacriticalDot = "˙", DiacriticalDoubleAcute = "˝", DiacriticalGrave = "`", DiacriticalTilde = "˜", diam = "⋄", diamond = "⋄", Diamond = "⋄", diamondsuit = "♦", diams = "♦", die = "¨", DifferentialD = "ⅆ", digamma = "ϝ", disin = "⋲", div = "÷", divide$1 = "÷", divideontimes = "⋇", divonx = "⋇", DJcy = "Ђ", djcy = "ђ", dlcorn = "⌞", dlcrop = "⌍", dollar = "$", Dopf = "𝔻", dopf = "𝕕", Dot = "¨", dot = "˙", DotDot = "⃜", doteq = "≐", doteqdot = "≑", DotEqual = "≐", dotminus = "∸", dotplus = "∔", dotsquare = "⊡", doublebarwedge = "⌆", DoubleContourIntegral = "∯", DoubleDot = "¨", DoubleDownArrow = "⇓", DoubleLeftArrow = "⇐", DoubleLeftRightArrow = "⇔", DoubleLeftTee = "⫤", DoubleLongLeftArrow = "⟸", DoubleLongLeftRightArrow = "⟺", DoubleLongRightArrow = "⟹", DoubleRightArrow = "⇒", DoubleRightTee = "⊨", DoubleUpArrow = "⇑", DoubleUpDownArrow = "⇕", DoubleVerticalBar = "∥", DownArrowBar = "⤓", downarrow = "↓", DownArrow = "↓", Downarrow = "⇓", DownArrowUpArrow = "⇵", DownBreve = "̑", downdownarrows = "⇊", downharpoonleft = "⇃", downharpoonright = "⇂", DownLeftRightVector = "⥐", DownLeftTeeVector = "⥞", DownLeftVectorBar = "⥖", DownLeftVector = "↽", DownRightTeeVector = "⥟", DownRightVectorBar = "⥗", DownRightVector = "⇁", DownTeeArrow = "↧", DownTee = "⊤", drbkarow = "⤐", drcorn = "⌟", drcrop = "⌌", Dscr = "𝒟", dscr = "𝒹", DScy = "Ѕ", dscy = "ѕ", dsol = "⧶", Dstrok = "Đ", dstrok = "đ", dtdot = "⋱", dtri = "▿", dtrif = "▾", duarr = "⇵", duhar = "⥯", dwangle = "⦦", DZcy = "Џ", dzcy = "џ", dzigrarr = "⟿", Eacute$1 = "É", eacute$1 = "é", easter = "⩮", Ecaron = "Ě", ecaron = "ě", Ecirc$1 = "Ê", ecirc$1 = "ê", ecir = "≖", ecolon = "≕", Ecy = "Э", ecy = "э", eDDot = "⩷", Edot = "Ė", edot = "ė", eDot = "≑", ee = "ⅇ", efDot = "≒", Efr = "𝔈", efr = "𝔢", eg = "⪚", Egrave$1 = "È", egrave$1 = "è", egs = "⪖", egsdot = "⪘", el = "⪙", Element$1 = "∈", elinters = "⏧", ell = "ℓ", els = "⪕", elsdot = "⪗", Emacr = "Ē", emacr = "ē", empty = "∅", emptyset = "∅", EmptySmallSquare = "◻", emptyv = "∅", EmptyVerySmallSquare = "▫", emsp13 = " ", emsp14 = " ", emsp = " ", ENG = "Ŋ", eng = "ŋ", ensp = " ", Eogon = "Ę", eogon = "ę", Eopf = "𝔼", eopf = "𝕖", epar = "⋕", eparsl = "⧣", eplus = "⩱", epsi = "ε", Epsilon = "Ε", epsilon = "ε", epsiv = "ϵ", eqcirc = "≖", eqcolon = "≕", eqsim = "≂", eqslantgtr = "⪖", eqslantless = "⪕", Equal = "⩵", equals = "=", EqualTilde = "≂", equest = "≟", Equilibrium = "⇌", equiv = "≡", equivDD = "⩸", eqvparsl = "⧥", erarr = "⥱", erDot = "≓", escr = "ℯ", Escr = "ℰ", esdot = "≐", Esim = "⩳", esim = "≂", Eta = "Η", eta = "η", ETH$1 = "Ð", eth$1 = "ð", Euml$1 = "Ë", euml$1 = "ë", euro = "€", excl = "!", exist = "∃", Exists = "∃", expectation = "ℰ", exponentiale = "ⅇ", ExponentialE = "ⅇ", fallingdotseq = "≒", Fcy = "Ф", fcy = "ф", female = "♀", ffilig = "ﬃ", fflig = "ﬀ", ffllig = "ﬄ", Ffr = "𝔉", ffr = "𝔣", filig = "ﬁ", FilledSmallSquare = "◼", FilledVerySmallSquare = "▪", fjlig = "fj", flat = "♭", fllig = "ﬂ", fltns = "▱", fnof = "ƒ", Fopf = "𝔽", fopf = "𝕗", forall = "∀", ForAll = "∀", fork = "⋔", forkv = "⫙", Fouriertrf = "ℱ", fpartint = "⨍", frac12$1 = "½", frac13 = "⅓", frac14$1 = "¼", frac15 = "⅕", frac16 = "⅙", frac18 = "⅛", frac23 = "⅔", frac25 = "⅖", frac34$1 = "¾", frac35 = "⅗", frac38 = "⅜", frac45 = "⅘", frac56 = "⅚", frac58 = "⅝", frac78 = "⅞", frasl = "⁄", frown = "⌢", fscr = "𝒻", Fscr = "ℱ", gacute = "ǵ", Gamma = "Γ", gamma = "γ", Gammad = "Ϝ", gammad = "ϝ", gap = "⪆", Gbreve = "Ğ", gbreve = "ğ", Gcedil = "Ģ", Gcirc = "Ĝ", gcirc = "ĝ", Gcy = "Г", gcy = "г", Gdot = "Ġ", gdot = "ġ", ge = "≥", gE = "≧", gEl = "⪌", gel = "⋛", geq = "≥", geqq = "≧", geqslant = "⩾", gescc = "⪩", ges = "⩾", gesdot = "⪀", gesdoto = "⪂", gesdotol = "⪄", gesl = "⋛︀", gesles = "⪔", Gfr = "𝔊", gfr = "𝔤", gg = "≫", Gg = "⋙", ggg = "⋙", gimel = "ℷ", GJcy = "Ѓ", gjcy = "ѓ", gla = "⪥", gl = "≷", glE = "⪒", glj = "⪤", gnap = "⪊", gnapprox = "⪊", gne = "⪈", gnE = "≩", gneq = "⪈", gneqq = "≩", gnsim = "⋧", Gopf = "𝔾", gopf = "𝕘", grave = "`", GreaterEqual = "≥", GreaterEqualLess = "⋛", GreaterFullEqual = "≧", GreaterGreater = "⪢", GreaterLess = "≷", GreaterSlantEqual = "⩾", GreaterTilde = "≳", Gscr = "𝒢", gscr = "ℊ", gsim = "≳", gsime = "⪎", gsiml = "⪐", gtcc = "⪧", gtcir = "⩺", gt$2 = ">", GT$1 = ">", Gt = "≫", gtdot = "⋗", gtlPar = "⦕", gtquest = "⩼", gtrapprox = "⪆", gtrarr = "⥸", gtrdot = "⋗", gtreqless = "⋛", gtreqqless = "⪌", gtrless = "≷", gtrsim = "≳", gvertneqq = "≩︀", gvnE = "≩︀", Hacek = "ˇ", hairsp = " ", half = "½", hamilt = "ℋ", HARDcy = "Ъ", hardcy = "ъ", harrcir = "⥈", harr = "↔", hArr = "⇔", harrw = "↭", Hat = "^", hbar = "ℏ", Hcirc = "Ĥ", hcirc = "ĥ", hearts = "♥", heartsuit = "♥", hellip = "…", hercon = "⊹", hfr = "𝔥", Hfr = "ℌ", HilbertSpace = "ℋ", hksearow = "⤥", hkswarow = "⤦", hoarr = "⇿", homtht = "∻", hookleftarrow = "↩", hookrightarrow = "↪", hopf = "𝕙", Hopf = "ℍ", horbar = "―", HorizontalLine = "─", hscr = "𝒽", Hscr = "ℋ", hslash = "ℏ", Hstrok = "Ħ", hstrok = "ħ", HumpDownHump = "≎", HumpEqual = "≏", hybull = "⁃", hyphen = "‐", Iacute$1 = "Í", iacute$1 = "í", ic = "⁣", Icirc$1 = "Î", icirc$1 = "î", Icy = "И", icy = "и", Idot = "İ", IEcy = "Е", iecy = "е", iexcl$1 = "¡", iff = "⇔", ifr = "𝔦", Ifr = "ℑ", Igrave$1 = "Ì", igrave$1 = "ì", ii = "ⅈ", iiiint = "⨌", iiint = "∭", iinfin = "⧜", iiota = "℩", IJlig = "Ĳ", ijlig = "ĳ", Imacr = "Ī", imacr = "ī", image = "ℑ", ImaginaryI = "ⅈ", imagline = "ℐ", imagpart = "ℑ", imath = "ı", Im = "ℑ", imof = "⊷", imped = "Ƶ", Implies = "⇒", incare = "℅", infin = "∞", infintie = "⧝", inodot = "ı", intcal = "⊺", int = "∫", Int = "∬", integers = "ℤ", Integral = "∫", intercal = "⊺", Intersection = "⋂", intlarhk = "⨗", intprod = "⨼", InvisibleComma = "⁣", InvisibleTimes = "⁢", IOcy = "Ё", iocy = "ё", Iogon = "Į", iogon = "į", Iopf = "𝕀", iopf = "𝕚", Iota = "Ι", iota = "ι", iprod = "⨼", iquest$1 = "¿", iscr = "𝒾", Iscr = "ℐ", isin = "∈", isindot = "⋵", isinE = "⋹", isins = "⋴", isinsv = "⋳", isinv = "∈", it = "⁢", Itilde = "Ĩ", itilde = "ĩ", Iukcy = "І", iukcy = "і", Iuml$1 = "Ï", iuml$1 = "ï", Jcirc = "Ĵ", jcirc = "ĵ", Jcy = "Й", jcy = "й", Jfr = "𝔍", jfr = "𝔧", jmath = "ȷ", Jopf = "𝕁", jopf = "𝕛", Jscr = "𝒥", jscr = "𝒿", Jsercy = "Ј", jsercy = "ј", Jukcy = "Є", jukcy = "є", Kappa = "Κ", kappa = "κ", kappav = "ϰ", Kcedil = "Ķ", kcedil = "ķ", Kcy = "К", kcy = "к", Kfr = "𝔎", kfr = "𝔨", kgreen = "ĸ", KHcy = "Х", khcy = "х", KJcy = "Ќ", kjcy = "ќ", Kopf = "𝕂", kopf = "𝕜", Kscr = "𝒦", kscr = "𝓀", lAarr = "⇚", Lacute = "Ĺ", lacute = "ĺ", laemptyv = "⦴", lagran = "ℒ", Lambda = "Λ", lambda = "λ", lang = "⟨", Lang = "⟪", langd = "⦑", langle = "⟨", lap = "⪅", Laplacetrf = "ℒ", laquo$1 = "«", larrb = "⇤", larrbfs = "⤟", larr = "←", Larr = "↞", lArr = "⇐", larrfs = "⤝", larrhk = "↩", larrlp = "↫", larrpl = "⤹", larrsim = "⥳", larrtl = "↢", latail = "⤙", lAtail = "⤛", lat = "⪫", late = "⪭", lates = "⪭︀", lbarr = "⤌", lBarr = "⤎", lbbrk = "❲", lbrace = "{", lbrack = "[", lbrke = "⦋", lbrksld = "⦏", lbrkslu = "⦍", Lcaron = "Ľ", lcaron = "ľ", Lcedil = "Ļ", lcedil = "ļ", lceil = "⌈", lcub = "{", Lcy = "Л", lcy = "л", ldca = "⤶", ldquo = "“", ldquor = "„", ldrdhar = "⥧", ldrushar = "⥋", ldsh = "↲", le = "≤", lE = "≦", LeftAngleBracket = "⟨", LeftArrowBar = "⇤", leftarrow = "←", LeftArrow = "←", Leftarrow = "⇐", LeftArrowRightArrow = "⇆", leftarrowtail = "↢", LeftCeiling = "⌈", LeftDoubleBracket = "⟦", LeftDownTeeVector = "⥡", LeftDownVectorBar = "⥙", LeftDownVector = "⇃", LeftFloor = "⌊", leftharpoondown = "↽", leftharpoonup = "↼", leftleftarrows = "⇇", leftrightarrow = "↔", LeftRightArrow = "↔", Leftrightarrow = "⇔", leftrightarrows = "⇆", leftrightharpoons = "⇋", leftrightsquigarrow = "↭", LeftRightVector = "⥎", LeftTeeArrow = "↤", LeftTee = "⊣", LeftTeeVector = "⥚", leftthreetimes = "⋋", LeftTriangleBar = "⧏", LeftTriangle = "⊲", LeftTriangleEqual = "⊴", LeftUpDownVector = "⥑", LeftUpTeeVector = "⥠", LeftUpVectorBar = "⥘", LeftUpVector = "↿", LeftVectorBar = "⥒", LeftVector = "↼", lEg = "⪋", leg = "⋚", leq = "≤", leqq = "≦", leqslant = "⩽", lescc = "⪨", les = "⩽", lesdot = "⩿", lesdoto = "⪁", lesdotor = "⪃", lesg = "⋚︀", lesges = "⪓", lessapprox = "⪅", lessdot = "⋖", lesseqgtr = "⋚", lesseqqgtr = "⪋", LessEqualGreater = "⋚", LessFullEqual = "≦", LessGreater = "≶", lessgtr = "≶", LessLess = "⪡", lesssim = "≲", LessSlantEqual = "⩽", LessTilde = "≲", lfisht = "⥼", lfloor = "⌊", Lfr = "𝔏", lfr = "𝔩", lg = "≶", lgE = "⪑", lHar = "⥢", lhard = "↽", lharu = "↼", lharul = "⥪", lhblk = "▄", LJcy = "Љ", ljcy = "љ", llarr = "⇇", ll = "≪", Ll = "⋘", llcorner = "⌞", Lleftarrow = "⇚", llhard = "⥫", lltri = "◺", Lmidot = "Ŀ", lmidot = "ŀ", lmoustache = "⎰", lmoust = "⎰", lnap = "⪉", lnapprox = "⪉", lne = "⪇", lnE = "≨", lneq = "⪇", lneqq = "≨", lnsim = "⋦", loang = "⟬", loarr = "⇽", lobrk = "⟦", longleftarrow = "⟵", LongLeftArrow = "⟵", Longleftarrow = "⟸", longleftrightarrow = "⟷", LongLeftRightArrow = "⟷", Longleftrightarrow = "⟺", longmapsto = "⟼", longrightarrow = "⟶", LongRightArrow = "⟶", Longrightarrow = "⟹", looparrowleft = "↫", looparrowright = "↬", lopar = "⦅", Lopf = "𝕃", lopf = "𝕝", loplus = "⨭", lotimes = "⨴", lowast = "∗", lowbar = "_", LowerLeftArrow = "↙", LowerRightArrow = "↘", loz = "◊", lozenge = "◊", lozf = "⧫", lpar = "(", lparlt = "⦓", lrarr = "⇆", lrcorner = "⌟", lrhar = "⇋", lrhard = "⥭", lrm = "‎", lrtri = "⊿", lsaquo = "‹", lscr = "𝓁", Lscr = "ℒ", lsh = "↰", Lsh = "↰", lsim = "≲", lsime = "⪍", lsimg = "⪏", lsqb = "[", lsquo = "‘", lsquor = "‚", Lstrok = "Ł", lstrok = "ł", ltcc = "⪦", ltcir = "⩹", lt$2 = "<", LT$1 = "<", Lt = "≪", ltdot = "⋖", lthree = "⋋", ltimes = "⋉", ltlarr = "⥶", ltquest = "⩻", ltri = "◃", ltrie = "⊴", ltrif = "◂", ltrPar = "⦖", lurdshar = "⥊", luruhar = "⥦", lvertneqq = "≨︀", lvnE = "≨︀", macr$1 = "¯", male = "♂", malt = "✠", maltese = "✠", map = "↦", mapsto = "↦", mapstodown = "↧", mapstoleft = "↤", mapstoup = "↥", marker = "▮", mcomma = "⨩", Mcy = "М", mcy = "м", mdash = "—", mDDot = "∺", measuredangle = "∡", MediumSpace = " ", Mellintrf = "ℳ", Mfr = "𝔐", mfr = "𝔪", mho = "℧", micro$1 = "µ", midast = "*", midcir = "⫰", mid = "∣", middot$1 = "·", minusb = "⊟", minus = "−", minusd = "∸", minusdu = "⨪", MinusPlus = "∓", mlcp = "⫛", mldr = "…", mnplus = "∓", models = "⊧", Mopf = "𝕄", mopf = "𝕞", mp = "∓", mscr = "𝓂", Mscr = "ℳ", mstpos = "∾", Mu = "Μ", mu = "μ", multimap = "⊸", mumap = "⊸", nabla = "∇", Nacute = "Ń", nacute = "ń", nang = "∠⃒", nap = "≉", napE = "⩰̸", napid = "≋̸", napos = "ŉ", napprox = "≉", natural = "♮", naturals = "ℕ", natur = "♮", nbsp$1 = " ", nbump = "≎̸", nbumpe = "≏̸", ncap = "⩃", Ncaron = "Ň", ncaron = "ň", Ncedil = "Ņ", ncedil = "ņ", ncong = "≇", ncongdot = "⩭̸", ncup = "⩂", Ncy = "Н", ncy = "н", ndash = "–", nearhk = "⤤", nearr = "↗", neArr = "⇗", nearrow = "↗", ne = "≠", nedot = "≐̸", NegativeMediumSpace = "​", NegativeThickSpace = "​", NegativeThinSpace = "​", NegativeVeryThinSpace = "​", nequiv = "≢", nesear = "⤨", nesim = "≂̸", NestedGreaterGreater = "≫", NestedLessLess = "≪", NewLine = `
`, nexist = "∄", nexists = "∄", Nfr = "𝔑", nfr = "𝔫", ngE = "≧̸", nge = "≱", ngeq = "≱", ngeqq = "≧̸", ngeqslant = "⩾̸", nges = "⩾̸", nGg = "⋙̸", ngsim = "≵", nGt = "≫⃒", ngt = "≯", ngtr = "≯", nGtv = "≫̸", nharr = "↮", nhArr = "⇎", nhpar = "⫲", ni = "∋", nis = "⋼", nisd = "⋺", niv = "∋", NJcy = "Њ", njcy = "њ", nlarr = "↚", nlArr = "⇍", nldr = "‥", nlE = "≦̸", nle = "≰", nleftarrow = "↚", nLeftarrow = "⇍", nleftrightarrow = "↮", nLeftrightarrow = "⇎", nleq = "≰", nleqq = "≦̸", nleqslant = "⩽̸", nles = "⩽̸", nless = "≮", nLl = "⋘̸", nlsim = "≴", nLt = "≪⃒", nlt = "≮", nltri = "⋪", nltrie = "⋬", nLtv = "≪̸", nmid = "∤", NoBreak = "⁠", NonBreakingSpace = " ", nopf = "𝕟", Nopf = "ℕ", Not = "⫬", not$1 = "¬", NotCongruent = "≢", NotCupCap = "≭", NotDoubleVerticalBar = "∦", NotElement = "∉", NotEqual = "≠", NotEqualTilde = "≂̸", NotExists = "∄", NotGreater = "≯", NotGreaterEqual = "≱", NotGreaterFullEqual = "≧̸", NotGreaterGreater = "≫̸", NotGreaterLess = "≹", NotGreaterSlantEqual = "⩾̸", NotGreaterTilde = "≵", NotHumpDownHump = "≎̸", NotHumpEqual = "≏̸", notin = "∉", notindot = "⋵̸", notinE = "⋹̸", notinva = "∉", notinvb = "⋷", notinvc = "⋶", NotLeftTriangleBar = "⧏̸", NotLeftTriangle = "⋪", NotLeftTriangleEqual = "⋬", NotLess = "≮", NotLessEqual = "≰", NotLessGreater = "≸", NotLessLess = "≪̸", NotLessSlantEqual = "⩽̸", NotLessTilde = "≴", NotNestedGreaterGreater = "⪢̸", NotNestedLessLess = "⪡̸", notni = "∌", notniva = "∌", notnivb = "⋾", notnivc = "⋽", NotPrecedes = "⊀", NotPrecedesEqual = "⪯̸", NotPrecedesSlantEqual = "⋠", NotReverseElement = "∌", NotRightTriangleBar = "⧐̸", NotRightTriangle = "⋫", NotRightTriangleEqual = "⋭", NotSquareSubset = "⊏̸", NotSquareSubsetEqual = "⋢", NotSquareSuperset = "⊐̸", NotSquareSupersetEqual = "⋣", NotSubset = "⊂⃒", NotSubsetEqual = "⊈", NotSucceeds = "⊁", NotSucceedsEqual = "⪰̸", NotSucceedsSlantEqual = "⋡", NotSucceedsTilde = "≿̸", NotSuperset = "⊃⃒", NotSupersetEqual = "⊉", NotTilde = "≁", NotTildeEqual = "≄", NotTildeFullEqual = "≇", NotTildeTilde = "≉", NotVerticalBar = "∤", nparallel = "∦", npar = "∦", nparsl = "⫽⃥", npart = "∂̸", npolint = "⨔", npr = "⊀", nprcue = "⋠", nprec = "⊀", npreceq = "⪯̸", npre = "⪯̸", nrarrc = "⤳̸", nrarr = "↛", nrArr = "⇏", nrarrw = "↝̸", nrightarrow = "↛", nRightarrow = "⇏", nrtri = "⋫", nrtrie = "⋭", nsc = "⊁", nsccue = "⋡", nsce = "⪰̸", Nscr = "𝒩", nscr = "𝓃", nshortmid = "∤", nshortparallel = "∦", nsim = "≁", nsime = "≄", nsimeq = "≄", nsmid = "∤", nspar = "∦", nsqsube = "⋢", nsqsupe = "⋣", nsub = "⊄", nsubE = "⫅̸", nsube = "⊈", nsubset = "⊂⃒", nsubseteq = "⊈", nsubseteqq = "⫅̸", nsucc = "⊁", nsucceq = "⪰̸", nsup = "⊅", nsupE = "⫆̸", nsupe = "⊉", nsupset = "⊃⃒", nsupseteq = "⊉", nsupseteqq = "⫆̸", ntgl = "≹", Ntilde$1 = "Ñ", ntilde$1 = "ñ", ntlg = "≸", ntriangleleft = "⋪", ntrianglelefteq = "⋬", ntriangleright = "⋫", ntrianglerighteq = "⋭", Nu = "Ν", nu = "ν", num = "#", numero = "№", numsp = " ", nvap = "≍⃒", nvdash = "⊬", nvDash = "⊭", nVdash = "⊮", nVDash = "⊯", nvge = "≥⃒", nvgt = ">⃒", nvHarr = "⤄", nvinfin = "⧞", nvlArr = "⤂", nvle = "≤⃒", nvlt = "<⃒", nvltrie = "⊴⃒", nvrArr = "⤃", nvrtrie = "⊵⃒", nvsim = "∼⃒", nwarhk = "⤣", nwarr = "↖", nwArr = "⇖", nwarrow = "↖", nwnear = "⤧", Oacute$1 = "Ó", oacute$1 = "ó", oast = "⊛", Ocirc$1 = "Ô", ocirc$1 = "ô", ocir = "⊚", Ocy = "О", ocy = "о", odash = "⊝", Odblac = "Ő", odblac = "ő", odiv = "⨸", odot = "⊙", odsold = "⦼", OElig = "Œ", oelig = "œ", ofcir = "⦿", Ofr = "𝔒", ofr = "𝔬", ogon = "˛", Ograve$1 = "Ò", ograve$1 = "ò", ogt = "⧁", ohbar = "⦵", ohm = "Ω", oint = "∮", olarr = "↺", olcir = "⦾", olcross = "⦻", oline = "‾", olt = "⧀", Omacr = "Ō", omacr = "ō", Omega = "Ω", omega = "ω", Omicron = "Ο", omicron = "ο", omid = "⦶", ominus = "⊖", Oopf = "𝕆", oopf = "𝕠", opar = "⦷", OpenCurlyDoubleQuote = "“", OpenCurlyQuote = "‘", operp = "⦹", oplus = "⊕", orarr = "↻", Or = "⩔", or = "∨", ord = "⩝", order = "ℴ", orderof = "ℴ", ordf$1 = "ª", ordm$1 = "º", origof = "⊶", oror = "⩖", orslope = "⩗", orv = "⩛", oS = "Ⓢ", Oscr = "𝒪", oscr = "ℴ", Oslash$1 = "Ø", oslash$1 = "ø", osol = "⊘", Otilde$1 = "Õ", otilde$1 = "õ", otimesas = "⨶", Otimes = "⨷", otimes = "⊗", Ouml$1 = "Ö", ouml$1 = "ö", ovbar = "⌽", OverBar = "‾", OverBrace = "⏞", OverBracket = "⎴", OverParenthesis = "⏜", para$1 = "¶", parallel = "∥", par = "∥", parsim = "⫳", parsl = "⫽", part = "∂", PartialD = "∂", Pcy = "П", pcy = "п", percnt = "%", period = ".", permil = "‰", perp = "⊥", pertenk = "‱", Pfr = "𝔓", pfr = "𝔭", Phi = "Φ", phi = "φ", phiv = "ϕ", phmmat = "ℳ", phone = "☎", Pi = "Π", pi = "π", pitchfork = "⋔", piv = "ϖ", planck = "ℏ", planckh = "ℎ", plankv = "ℏ", plusacir = "⨣", plusb = "⊞", pluscir = "⨢", plus = "+", plusdo = "∔", plusdu = "⨥", pluse = "⩲", PlusMinus = "±", plusmn$1 = "±", plussim = "⨦", plustwo = "⨧", pm = "±", Poincareplane = "ℌ", pointint = "⨕", popf = "𝕡", Popf = "ℙ", pound$1 = "£", prap = "⪷", Pr = "⪻", pr = "≺", prcue = "≼", precapprox = "⪷", prec = "≺", preccurlyeq = "≼", Precedes = "≺", PrecedesEqual = "⪯", PrecedesSlantEqual = "≼", PrecedesTilde = "≾", preceq = "⪯", precnapprox = "⪹", precneqq = "⪵", precnsim = "⋨", pre = "⪯", prE = "⪳", precsim = "≾", prime = "′", Prime = "″", primes = "ℙ", prnap = "⪹", prnE = "⪵", prnsim = "⋨", prod = "∏", Product = "∏", profalar = "⌮", profline = "⌒", profsurf = "⌓", prop = "∝", Proportional = "∝", Proportion = "∷", propto = "∝", prsim = "≾", prurel = "⊰", Pscr = "𝒫", pscr = "𝓅", Psi = "Ψ", psi = "ψ", puncsp = " ", Qfr = "𝔔", qfr = "𝔮", qint = "⨌", qopf = "𝕢", Qopf = "ℚ", qprime = "⁗", Qscr = "𝒬", qscr = "𝓆", quaternions = "ℍ", quatint = "⨖", quest = "?", questeq = "≟", quot$2 = '"', QUOT$1 = '"', rAarr = "⇛", race = "∽̱", Racute = "Ŕ", racute = "ŕ", radic = "√", raemptyv = "⦳", rang = "⟩", Rang = "⟫", rangd = "⦒", range = "⦥", rangle = "⟩", raquo$1 = "»", rarrap = "⥵", rarrb = "⇥", rarrbfs = "⤠", rarrc = "⤳", rarr = "→", Rarr = "↠", rArr = "⇒", rarrfs = "⤞", rarrhk = "↪", rarrlp = "↬", rarrpl = "⥅", rarrsim = "⥴", Rarrtl = "⤖", rarrtl = "↣", rarrw = "↝", ratail = "⤚", rAtail = "⤜", ratio = "∶", rationals = "ℚ", rbarr = "⤍", rBarr = "⤏", RBarr = "⤐", rbbrk = "❳", rbrace = "}", rbrack = "]", rbrke = "⦌", rbrksld = "⦎", rbrkslu = "⦐", Rcaron = "Ř", rcaron = "ř", Rcedil = "Ŗ", rcedil = "ŗ", rceil = "⌉", rcub = "}", Rcy = "Р", rcy = "р", rdca = "⤷", rdldhar = "⥩", rdquo = "”", rdquor = "”", rdsh = "↳", real = "ℜ", realine = "ℛ", realpart = "ℜ", reals = "ℝ", Re = "ℜ", rect = "▭", reg$1 = "®", REG$1 = "®", ReverseElement = "∋", ReverseEquilibrium = "⇋", ReverseUpEquilibrium = "⥯", rfisht = "⥽", rfloor = "⌋", rfr = "𝔯", Rfr = "ℜ", rHar = "⥤", rhard = "⇁", rharu = "⇀", rharul = "⥬", Rho = "Ρ", rho = "ρ", rhov = "ϱ", RightAngleBracket = "⟩", RightArrowBar = "⇥", rightarrow = "→", RightArrow = "→", Rightarrow = "⇒", RightArrowLeftArrow = "⇄", rightarrowtail = "↣", RightCeiling = "⌉", RightDoubleBracket = "⟧", RightDownTeeVector = "⥝", RightDownVectorBar = "⥕", RightDownVector = "⇂", RightFloor = "⌋", rightharpoondown = "⇁", rightharpoonup = "⇀", rightleftarrows = "⇄", rightleftharpoons = "⇌", rightrightarrows = "⇉", rightsquigarrow = "↝", RightTeeArrow = "↦", RightTee = "⊢", RightTeeVector = "⥛", rightthreetimes = "⋌", RightTriangleBar = "⧐", RightTriangle = "⊳", RightTriangleEqual = "⊵", RightUpDownVector = "⥏", RightUpTeeVector = "⥜", RightUpVectorBar = "⥔", RightUpVector = "↾", RightVectorBar = "⥓", RightVector = "⇀", ring = "˚", risingdotseq = "≓", rlarr = "⇄", rlhar = "⇌", rlm = "‏", rmoustache = "⎱", rmoust = "⎱", rnmid = "⫮", roang = "⟭", roarr = "⇾", robrk = "⟧", ropar = "⦆", ropf = "𝕣", Ropf = "ℝ", roplus = "⨮", rotimes = "⨵", RoundImplies = "⥰", rpar = ")", rpargt = "⦔", rppolint = "⨒", rrarr = "⇉", Rrightarrow = "⇛", rsaquo = "›", rscr = "𝓇", Rscr = "ℛ", rsh = "↱", Rsh = "↱", rsqb = "]", rsquo = "’", rsquor = "’", rthree = "⋌", rtimes = "⋊", rtri = "▹", rtrie = "⊵", rtrif = "▸", rtriltri = "⧎", RuleDelayed = "⧴", ruluhar = "⥨", rx = "℞", Sacute = "Ś", sacute = "ś", sbquo = "‚", scap = "⪸", Scaron = "Š", scaron = "š", Sc = "⪼", sc = "≻", sccue = "≽", sce = "⪰", scE = "⪴", Scedil = "Ş", scedil = "ş", Scirc = "Ŝ", scirc = "ŝ", scnap = "⪺", scnE = "⪶", scnsim = "⋩", scpolint = "⨓", scsim = "≿", Scy = "С", scy = "с", sdotb = "⊡", sdot = "⋅", sdote = "⩦", searhk = "⤥", searr = "↘", seArr = "⇘", searrow = "↘", sect$1 = "§", semi = ";", seswar = "⤩", setminus = "∖", setmn = "∖", sext = "✶", Sfr = "𝔖", sfr = "𝔰", sfrown = "⌢", sharp = "♯", SHCHcy = "Щ", shchcy = "щ", SHcy = "Ш", shcy = "ш", ShortDownArrow = "↓", ShortLeftArrow = "←", shortmid = "∣", shortparallel = "∥", ShortRightArrow = "→", ShortUpArrow = "↑", shy$1 = "­", Sigma = "Σ", sigma = "σ", sigmaf = "ς", sigmav = "ς", sim = "∼", simdot = "⩪", sime = "≃", simeq = "≃", simg = "⪞", simgE = "⪠", siml = "⪝", simlE = "⪟", simne = "≆", simplus = "⨤", simrarr = "⥲", slarr = "←", SmallCircle = "∘", smallsetminus = "∖", smashp = "⨳", smeparsl = "⧤", smid = "∣", smile = "⌣", smt = "⪪", smte = "⪬", smtes = "⪬︀", SOFTcy = "Ь", softcy = "ь", solbar = "⌿", solb = "⧄", sol = "/", Sopf = "𝕊", sopf = "𝕤", spades = "♠", spadesuit = "♠", spar = "∥", sqcap = "⊓", sqcaps = "⊓︀", sqcup = "⊔", sqcups = "⊔︀", Sqrt = "√", sqsub = "⊏", sqsube = "⊑", sqsubset = "⊏", sqsubseteq = "⊑", sqsup = "⊐", sqsupe = "⊒", sqsupset = "⊐", sqsupseteq = "⊒", square = "□", Square = "□", SquareIntersection = "⊓", SquareSubset = "⊏", SquareSubsetEqual = "⊑", SquareSuperset = "⊐", SquareSupersetEqual = "⊒", SquareUnion = "⊔", squarf = "▪", squ = "□", squf = "▪", srarr = "→", Sscr = "𝒮", sscr = "𝓈", ssetmn = "∖", ssmile = "⌣", sstarf = "⋆", Star = "⋆", star = "☆", starf = "★", straightepsilon = "ϵ", straightphi = "ϕ", strns = "¯", sub = "⊂", Sub = "⋐", subdot = "⪽", subE = "⫅", sube = "⊆", subedot = "⫃", submult = "⫁", subnE = "⫋", subne = "⊊", subplus = "⪿", subrarr = "⥹", subset = "⊂", Subset = "⋐", subseteq = "⊆", subseteqq = "⫅", SubsetEqual = "⊆", subsetneq = "⊊", subsetneqq = "⫋", subsim = "⫇", subsub = "⫕", subsup = "⫓", succapprox = "⪸", succ = "≻", succcurlyeq = "≽", Succeeds = "≻", SucceedsEqual = "⪰", SucceedsSlantEqual = "≽", SucceedsTilde = "≿", succeq = "⪰", succnapprox = "⪺", succneqq = "⪶", succnsim = "⋩", succsim = "≿", SuchThat = "∋", sum = "∑", Sum = "∑", sung = "♪", sup1$1 = "¹", sup2$1 = "²", sup3$1 = "³", sup = "⊃", Sup = "⋑", supdot = "⪾", supdsub = "⫘", supE = "⫆", supe = "⊇", supedot = "⫄", Superset = "⊃", SupersetEqual = "⊇", suphsol = "⟉", suphsub = "⫗", suplarr = "⥻", supmult = "⫂", supnE = "⫌", supne = "⊋", supplus = "⫀", supset = "⊃", Supset = "⋑", supseteq = "⊇", supseteqq = "⫆", supsetneq = "⊋", supsetneqq = "⫌", supsim = "⫈", supsub = "⫔", supsup = "⫖", swarhk = "⤦", swarr = "↙", swArr = "⇙", swarrow = "↙", swnwar = "⤪", szlig$1 = "ß", Tab = "	", target = "⌖", Tau = "Τ", tau = "τ", tbrk = "⎴", Tcaron = "Ť", tcaron = "ť", Tcedil = "Ţ", tcedil = "ţ", Tcy = "Т", tcy = "т", tdot = "⃛", telrec = "⌕", Tfr = "𝔗", tfr = "𝔱", there4 = "∴", therefore = "∴", Therefore = "∴", Theta = "Θ", theta = "θ", thetasym = "ϑ", thetav = "ϑ", thickapprox = "≈", thicksim = "∼", ThickSpace = "  ", ThinSpace = " ", thinsp = " ", thkap = "≈", thksim = "∼", THORN$1 = "Þ", thorn$1 = "þ", tilde = "˜", Tilde = "∼", TildeEqual = "≃", TildeFullEqual = "≅", TildeTilde = "≈", timesbar = "⨱", timesb = "⊠", times$1 = "×", timesd = "⨰", tint = "∭", toea = "⤨", topbot = "⌶", topcir = "⫱", top = "⊤", Topf = "𝕋", topf = "𝕥", topfork = "⫚", tosa = "⤩", tprime = "‴", trade = "™", TRADE = "™", triangle = "▵", triangledown = "▿", triangleleft = "◃", trianglelefteq = "⊴", triangleq = "≜", triangleright = "▹", trianglerighteq = "⊵", tridot = "◬", trie = "≜", triminus = "⨺", TripleDot = "⃛", triplus = "⨹", trisb = "⧍", tritime = "⨻", trpezium = "⏢", Tscr = "𝒯", tscr = "𝓉", TScy = "Ц", tscy = "ц", TSHcy = "Ћ", tshcy = "ћ", Tstrok = "Ŧ", tstrok = "ŧ", twixt = "≬", twoheadleftarrow = "↞", twoheadrightarrow = "↠", Uacute$1 = "Ú", uacute$1 = "ú", uarr = "↑", Uarr = "↟", uArr = "⇑", Uarrocir = "⥉", Ubrcy = "Ў", ubrcy = "ў", Ubreve = "Ŭ", ubreve = "ŭ", Ucirc$1 = "Û", ucirc$1 = "û", Ucy = "У", ucy = "у", udarr = "⇅", Udblac = "Ű", udblac = "ű", udhar = "⥮", ufisht = "⥾", Ufr = "𝔘", ufr = "𝔲", Ugrave$1 = "Ù", ugrave$1 = "ù", uHar = "⥣", uharl = "↿", uharr = "↾", uhblk = "▀", ulcorn = "⌜", ulcorner = "⌜", ulcrop = "⌏", ultri = "◸", Umacr = "Ū", umacr = "ū", uml$1 = "¨", UnderBar = "_", UnderBrace = "⏟", UnderBracket = "⎵", UnderParenthesis = "⏝", Union = "⋃", UnionPlus = "⊎", Uogon = "Ų", uogon = "ų", Uopf = "𝕌", uopf = "𝕦", UpArrowBar = "⤒", uparrow = "↑", UpArrow = "↑", Uparrow = "⇑", UpArrowDownArrow = "⇅", updownarrow = "↕", UpDownArrow = "↕", Updownarrow = "⇕", UpEquilibrium = "⥮", upharpoonleft = "↿", upharpoonright = "↾", uplus = "⊎", UpperLeftArrow = "↖", UpperRightArrow = "↗", upsi = "υ", Upsi = "ϒ", upsih = "ϒ", Upsilon = "Υ", upsilon = "υ", UpTeeArrow = "↥", UpTee = "⊥", upuparrows = "⇈", urcorn = "⌝", urcorner = "⌝", urcrop = "⌎", Uring = "Ů", uring = "ů", urtri = "◹", Uscr = "𝒰", uscr = "𝓊", utdot = "⋰", Utilde = "Ũ", utilde = "ũ", utri = "▵", utrif = "▴", uuarr = "⇈", Uuml$1 = "Ü", uuml$1 = "ü", uwangle = "⦧", vangrt = "⦜", varepsilon = "ϵ", varkappa = "ϰ", varnothing = "∅", varphi = "ϕ", varpi = "ϖ", varpropto = "∝", varr = "↕", vArr = "⇕", varrho = "ϱ", varsigma = "ς", varsubsetneq = "⊊︀", varsubsetneqq = "⫋︀", varsupsetneq = "⊋︀", varsupsetneqq = "⫌︀", vartheta = "ϑ", vartriangleleft = "⊲", vartriangleright = "⊳", vBar = "⫨", Vbar = "⫫", vBarv = "⫩", Vcy = "В", vcy = "в", vdash = "⊢", vDash = "⊨", Vdash = "⊩", VDash = "⊫", Vdashl = "⫦", veebar = "⊻", vee = "∨", Vee = "⋁", veeeq = "≚", vellip = "⋮", verbar = "|", Verbar = "‖", vert = "|", Vert = "‖", VerticalBar = "∣", VerticalLine = "|", VerticalSeparator = "❘", VerticalTilde = "≀", VeryThinSpace = " ", Vfr = "𝔙", vfr = "𝔳", vltri = "⊲", vnsub = "⊂⃒", vnsup = "⊃⃒", Vopf = "𝕍", vopf = "𝕧", vprop = "∝", vrtri = "⊳", Vscr = "𝒱", vscr = "𝓋", vsubnE = "⫋︀", vsubne = "⊊︀", vsupnE = "⫌︀", vsupne = "⊋︀", Vvdash = "⊪", vzigzag = "⦚", Wcirc = "Ŵ", wcirc = "ŵ", wedbar = "⩟", wedge = "∧", Wedge = "⋀", wedgeq = "≙", weierp = "℘", Wfr = "𝔚", wfr = "𝔴", Wopf = "𝕎", wopf = "𝕨", wp = "℘", wr = "≀", wreath = "≀", Wscr = "𝒲", wscr = "𝓌", xcap = "⋂", xcirc = "◯", xcup = "⋃", xdtri = "▽", Xfr = "𝔛", xfr = "𝔵", xharr = "⟷", xhArr = "⟺", Xi = "Ξ", xi = "ξ", xlarr = "⟵", xlArr = "⟸", xmap = "⟼", xnis = "⋻", xodot = "⨀", Xopf = "𝕏", xopf = "𝕩", xoplus = "⨁", xotime = "⨂", xrarr = "⟶", xrArr = "⟹", Xscr = "𝒳", xscr = "𝓍", xsqcup = "⨆", xuplus = "⨄", xutri = "△", xvee = "⋁", xwedge = "⋀", Yacute$1 = "Ý", yacute$1 = "ý", YAcy = "Я", yacy = "я", Ycirc = "Ŷ", ycirc = "ŷ", Ycy = "Ы", ycy = "ы", yen$1 = "¥", Yfr = "𝔜", yfr = "𝔶", YIcy = "Ї", yicy = "ї", Yopf = "𝕐", yopf = "𝕪", Yscr = "𝒴", yscr = "𝓎", YUcy = "Ю", yucy = "ю", yuml$1 = "ÿ", Yuml = "Ÿ", Zacute = "Ź", zacute = "ź", Zcaron = "Ž", zcaron = "ž", Zcy = "З", zcy = "з", Zdot = "Ż", zdot = "ż", zeetrf = "ℨ", ZeroWidthSpace = "​", Zeta = "Ζ", zeta = "ζ", zfr = "𝔷", Zfr = "ℨ", ZHcy = "Ж", zhcy = "ж", zigrarr = "⇝", zopf = "𝕫", Zopf = "ℤ", Zscr = "𝒵", zscr = "𝓏", zwj = "‍", zwnj = "‌", require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet: bullet$1,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret: caret$1,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  in: "∈",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  Map: "⤅",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
}, Aacute = "Á", aacute = "á", Acirc = "Â", acirc = "â", acute = "´", AElig = "Æ", aelig = "æ", Agrave = "À", agrave = "à", amp$1 = "&", AMP = "&", Aring = "Å", aring = "å", Atilde = "Ã", atilde = "ã", Auml = "Ä", auml = "ä", brvbar = "¦", Ccedil = "Ç", ccedil = "ç", cedil = "¸", cent = "¢", copy = "©", COPY = "©", curren = "¤", deg = "°", divide = "÷", Eacute = "É", eacute = "é", Ecirc = "Ê", ecirc = "ê", Egrave = "È", egrave = "è", ETH = "Ð", eth = "ð", Euml = "Ë", euml = "ë", frac12 = "½", frac14 = "¼", frac34 = "¾", gt$1 = ">", GT = ">", Iacute = "Í", iacute = "í", Icirc = "Î", icirc = "î", iexcl = "¡", Igrave = "Ì", igrave = "ì", iquest = "¿", Iuml = "Ï", iuml = "ï", laquo = "«", lt$1 = "<", LT = "<", macr = "¯", micro = "µ", middot = "·", nbsp = " ", not = "¬", Ntilde = "Ñ", ntilde = "ñ", Oacute = "Ó", oacute = "ó", Ocirc = "Ô", ocirc = "ô", Ograve = "Ò", ograve = "ò", ordf = "ª", ordm = "º", Oslash = "Ø", oslash = "ø", Otilde = "Õ", otilde = "õ", Ouml = "Ö", ouml = "ö", para = "¶", plusmn = "±", pound = "£", quot$1 = '"', QUOT = '"', raquo = "»", reg = "®", REG = "®", sect = "§", shy = "­", sup1 = "¹", sup2 = "²", sup3 = "³", szlig = "ß", THORN = "Þ", thorn = "þ", times = "×", Uacute = "Ú", uacute = "ú", Ucirc = "Û", ucirc = "û", Ugrave = "Ù", ugrave = "ù", uml = "¨", Uuml = "Ü", uuml = "ü", Yacute = "Ý", yacute = "ý", yen = "¥", yuml = "ÿ", require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
}, amp = "&", apos = "'", gt = ">", lt = "<", quot = '"', require$$0$1 = {
  amp,
  apos,
  gt,
  lt,
  quot
}, decode_codepoint = {}, require$$0$2 = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: !0 });
var decode_json_1 = __importDefault$2(require$$0$2), fromCodePoint$2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(lr) {
    var ar = "";
    return lr > 65535 && (lr -= 65536, ar += String.fromCharCode(lr >>> 10 & 1023 | 55296), lr = 56320 | lr & 1023), ar += String.fromCharCode(lr), ar;
  }
);
function decodeCodePoint(lr) {
  return lr >= 55296 && lr <= 57343 || lr > 1114111 ? "�" : (lr in decode_json_1.default && (lr = decode_json_1.default[lr]), fromCodePoint$2(lr));
}
decode_codepoint.default = decodeCodePoint;
var __importDefault$1$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(decode, "__esModule", { value: !0 });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$1$1(require$$1$1), legacy_json_1 = __importDefault$1$1(require$$1), xml_json_1$1 = __importDefault$1$1(require$$0$1), decode_codepoint_1 = __importDefault$1$1(decode_codepoint), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(lr) {
  var ar = getReplacer(lr);
  return function(cr) {
    return String(cr).replace(strictEntityRe, ar);
  };
}
var sorter = function(lr, ar) {
  return lr < ar ? 1 : -1;
};
decode.decodeHTML = function() {
  for (var lr = Object.keys(legacy_json_1.default).sort(sorter), ar = Object.keys(entities_json_1$1.default).sort(sorter), cr = 0, ur = 0; cr < ar.length; cr++)
    lr[ur] === ar[cr] ? (ar[cr] += ";?", ur++) : ar[cr] += ";";
  var fr = new RegExp("&(?:" + ar.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), dr = getReplacer(entities_json_1$1.default);
  function gr(mr) {
    return mr.substr(-1) !== ";" && (mr += ";"), dr(mr);
  }
  return function(mr) {
    return String(mr).replace(fr, gr);
  };
}();
function getReplacer(lr) {
  return function(cr) {
    if (cr.charAt(1) === "#") {
      var ur = cr.charAt(2);
      return ur === "X" || ur === "x" ? decode_codepoint_1.default(parseInt(cr.substr(3), 16)) : decode_codepoint_1.default(parseInt(cr.substr(2), 10));
    }
    return lr[cr.slice(1, -1)] || cr;
  };
}
var encode = {}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(encode, "__esModule", { value: !0 });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault$3(require$$0$1), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$3(require$$1$1), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(lr) {
  return Object.keys(lr).sort().reduce(function(ar, cr) {
    return ar[lr[cr]] = "&" + cr + ";", ar;
  }, {});
}
function getInverseReplacer(lr) {
  for (var ar = [], cr = [], ur = 0, fr = Object.keys(lr); ur < fr.length; ur++) {
    var dr = fr[ur];
    dr.length === 1 ? ar.push("\\" + dr) : cr.push(dr);
  }
  ar.sort();
  for (var gr = 0; gr < ar.length - 1; gr++) {
    for (var mr = gr; mr < ar.length - 1 && ar[mr].charCodeAt(1) + 1 === ar[mr + 1].charCodeAt(1); )
      mr += 1;
    var vr = 1 + mr - gr;
    vr < 3 || ar.splice(gr, vr, ar[gr] + "-" + ar[mr]);
  }
  return cr.unshift("[" + ar.join("") + "]"), new RegExp(cr.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(lr) {
      return lr.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(lr) {
      return (lr.charCodeAt(0) - 55296) * 1024 + lr.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function singleCharReplacer(lr) {
  return "&#x" + (lr.length > 1 ? getCodePoint(lr) : lr.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(lr, ar) {
  return function(cr) {
    return cr.replace(ar, function(ur) {
      return lr[ur];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
function escape$3(lr) {
  return lr.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape$3;
function escapeUTF8(lr) {
  return lr.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(lr) {
  return function(ar) {
    return ar.replace(reEscapeChars, function(cr) {
      return lr[cr] || singleCharReplacer(cr);
    });
  };
}
(function(lr) {
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.decodeXMLStrict = lr.decodeHTML5Strict = lr.decodeHTML4Strict = lr.decodeHTML5 = lr.decodeHTML4 = lr.decodeHTMLStrict = lr.decodeHTML = lr.decodeXML = lr.encodeHTML5 = lr.encodeHTML4 = lr.escapeUTF8 = lr.escape = lr.encodeNonAsciiHTML = lr.encodeHTML = lr.encodeXML = lr.encode = lr.decodeStrict = lr.decode = void 0;
  var ar = decode, cr = encode;
  function ur(vr, yr) {
    return (!yr || yr <= 0 ? ar.decodeXML : ar.decodeHTML)(vr);
  }
  lr.decode = ur;
  function fr(vr, yr) {
    return (!yr || yr <= 0 ? ar.decodeXML : ar.decodeHTMLStrict)(vr);
  }
  lr.decodeStrict = fr;
  function dr(vr, yr) {
    return (!yr || yr <= 0 ? cr.encodeXML : cr.encodeHTML)(vr);
  }
  lr.encode = dr;
  var gr = encode;
  Object.defineProperty(lr, "encodeXML", { enumerable: !0, get: function() {
    return gr.encodeXML;
  } }), Object.defineProperty(lr, "encodeHTML", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } }), Object.defineProperty(lr, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return gr.encodeNonAsciiHTML;
  } }), Object.defineProperty(lr, "escape", { enumerable: !0, get: function() {
    return gr.escape;
  } }), Object.defineProperty(lr, "escapeUTF8", { enumerable: !0, get: function() {
    return gr.escapeUTF8;
  } }), Object.defineProperty(lr, "encodeHTML4", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } }), Object.defineProperty(lr, "encodeHTML5", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } });
  var mr = decode;
  Object.defineProperty(lr, "decodeXML", { enumerable: !0, get: function() {
    return mr.decodeXML;
  } }), Object.defineProperty(lr, "decodeHTML", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeHTML4", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTML5", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(lr, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(lr, "decodeXMLStrict", { enumerable: !0, get: function() {
    return mr.decodeXML;
  } });
})(lib);
var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", C_BACKSLASH$1 = 92, reBackslashOrAmp = /[\\&]/, ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi"), XMLSPECIAL = '[&<>"]', reXmlSpecial = new RegExp(XMLSPECIAL, "g"), unescapeChar = function(lr) {
  return lr.charCodeAt(0) === C_BACKSLASH$1 ? lr.charAt(1) : lib.decodeHTML(lr);
};
function unescapeString(lr) {
  return reBackslashOrAmp.test(lr) ? lr.replace(reEntityOrEscapedChar, unescapeChar) : lr;
}
function normalizeURI(lr) {
  try {
    return encode_1(lr);
  } catch (ar) {
    return lr;
  }
}
function replaceUnsafeChar(lr) {
  switch (lr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return lr;
  }
}
function escapeXml(lr) {
  return reXmlSpecial.test(lr) ? lr.replace(reXmlSpecial, replaceUnsafeChar) : lr;
}
function repeat(lr, ar) {
  for (var cr = [], ur = 0; ur < ar; ur++)
    cr.push(lr);
  return cr.join("");
}
function isEmpty(lr) {
  return lr ? !/[^ \t]+/.test(lr) : !0;
}
var NodeWalker = (
  /** @class */
  function() {
    function lr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return lr.prototype.next = function() {
      var ar = this.current, cr = this.entering;
      if (ar === null)
        return null;
      var ur = isContainer$1(ar);
      return cr && ur ? ar.firstChild ? (this.current = ar.firstChild, this.entering = !0) : this.entering = !1 : ar === this.root ? this.current = null : ar.next === null ? (this.current = ar.parent, this.entering = !1) : (this.current = ar.next, this.entering = !0), { entering: cr, node: ar };
    }, lr.prototype.resumeAt = function(ar, cr) {
      this.current = ar, this.entering = cr === !0;
    }, lr;
  }()
);
function isContainer$1(lr) {
  switch (lr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
var lastNodeId = 1, nodeMap = {};
function getNodeById(lr) {
  return nodeMap[lr];
}
function removeNodeById(lr) {
  delete nodeMap[lr];
}
function removeAllNode() {
  nodeMap = {};
}
var Node$1 = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, ar === "document" ? this.id = -1 : this.id = lastNodeId++, this.type = ar, this.sourcepos = cr, nodeMap[this.id] = this;
    }
    return lr.prototype.isContainer = function() {
      return isContainer$1(this);
    }, lr.prototype.unlink = function() {
      this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
    }, lr.prototype.replaceWith = function(ar) {
      this.insertBefore(ar), this.unlink();
    }, lr.prototype.insertAfter = function(ar) {
      ar.unlink(), ar.next = this.next, ar.next && (ar.next.prev = ar), ar.prev = this, this.next = ar, this.parent && (ar.parent = this.parent, ar.next || (ar.parent.lastChild = ar));
    }, lr.prototype.insertBefore = function(ar) {
      ar.unlink(), ar.prev = this.prev, ar.prev && (ar.prev.next = ar), ar.next = this, this.prev = ar, ar.parent = this.parent, ar.prev || (ar.parent.firstChild = ar);
    }, lr.prototype.appendChild = function(ar) {
      ar.unlink(), ar.parent = this, this.lastChild ? (this.lastChild.next = ar, ar.prev = this.lastChild, this.lastChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, lr.prototype.prependChild = function(ar) {
      ar.unlink(), ar.parent = this, this.firstChild ? (this.firstChild.prev = ar, ar.next = this.firstChild, this.firstChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, lr.prototype.walker = function() {
      return new NodeWalker(this);
    }, lr;
  }()
), BlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr, ur) || this;
      return fr.open = !0, fr.lineOffsets = null, fr.stringContent = null, fr.lastLineBlank = !1, fr.lastLineChecked = !1, fr.type = cr, fr;
    }
    return ar;
  }(Node$1)
), ListNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.listData = null, cr;
    }
    return ar;
  }(BlockNode)
), HeadingNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.level = 0, cr.headingType = "atx", cr;
    }
    return ar;
  }(BlockNode)
), CodeBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.isFenced = !1, cr.fenceChar = null, cr.fenceLength = 0, cr.fenceOffset = -1, cr.info = null, cr.infoPadding = 0, cr;
    }
    return ar;
  }(BlockNode)
), TableNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.columns = [], cr;
    }
    return ar;
  }(BlockNode)
), TableCellNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.startIdx = 0, cr.endIdx = 0, cr.paddingLeft = 0, cr.paddingRight = 0, cr.ignored = !1, cr;
    }
    return ar;
  }(BlockNode)
), RefDefNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.title = "", cr.dest = "", cr.label = "", cr;
    }
    return ar;
  }(BlockNode)
), CustomBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.syntaxLength = 0, cr.offset = -1, cr.info = "", cr;
    }
    return ar;
  }(BlockNode)
), HtmlBlockNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.htmlBlockType = -1, cr;
    }
    return ar;
  }(BlockNode)
), LinkNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.destination = null, cr.title = null, cr.extendedAutolink = !1, cr;
    }
    return ar;
  }(Node$1)
), CodeNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.tickCount = 0, cr;
    }
    return ar;
  }(Node$1)
), CustomInlineNode = (
  /** @class */
  function(lr) {
    __extends(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.info = "", cr;
    }
    return ar;
  }(Node$1)
);
function createNode$1(lr, ar) {
  switch (lr) {
    case "heading":
      return new HeadingNode(lr, ar);
    case "list":
    case "item":
      return new ListNode(lr, ar);
    case "link":
    case "image":
      return new LinkNode(lr, ar);
    case "codeBlock":
      return new CodeBlockNode(lr, ar);
    case "htmlBlock":
      return new HtmlBlockNode(lr, ar);
    case "table":
      return new TableNode(lr, ar);
    case "tableCell":
      return new TableCellNode(lr, ar);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new BlockNode(lr, ar);
    case "code":
      return new CodeNode(lr, ar);
    case "refDef":
      return new RefDefNode(lr, ar);
    case "customBlock":
      return new CustomBlockNode(lr, ar);
    case "customInline":
      return new CustomInlineNode(lr, ar);
    default:
      return new Node$1(lr, ar);
  }
}
function isCodeBlock(lr) {
  return lr.type === "codeBlock";
}
function isHtmlBlock(lr) {
  return lr.type === "htmlBlock";
}
function isHeading(lr) {
  return lr.type === "heading";
}
function isList(lr) {
  return lr.type === "list";
}
function isTable(lr) {
  return lr.type === "table";
}
function isRefDef(lr) {
  return lr.type === "refDef";
}
function isCustomBlock(lr) {
  return lr.type === "customBlock";
}
function isCustomInline(lr) {
  return lr.type === "customInline";
}
function text$1(lr, ar) {
  var cr = createNode$1("text", ar);
  return cr.literal = lr, cr;
}
var TAGNAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTENAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLEQUOTEDVALUE = "'[^']*'", DOUBLEQUOTEDVALUE = '"[^"]*"', ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")", ATTRIBUTEVALUESPEC = "(?:\\s*=\\s*" + ATTRIBUTEVALUE + ")", ATTRIBUTE = "(?:\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)", OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*\\s*/?>", CLOSETAG = "</" + TAGNAME + "\\s*[>]", HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", PROCESSINGINSTRUCTION = "[<][?].*?[?][>]", DECLARATION = "<![A-Z]+\\s+[^>]*>", CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")", reHtmlTag = new RegExp("^" + HTMLTAG, "i");
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var fromCodePoint;
if (String.fromCodePoint)
  fromCodePoint = function(lr) {
    try {
      return String.fromCodePoint(lr);
    } catch (ar) {
      if (ar instanceof RangeError)
        return String.fromCharCode(65533);
      throw ar;
    }
  };
else {
  var stringFromCharCode_1 = String.fromCharCode, floor_1 = Math.floor;
  fromCodePoint = function() {
    for (var lr = [], ar = 0; ar < arguments.length; ar++)
      lr[ar] = arguments[ar];
    var cr = 16384, ur = [], fr, dr, gr = -1, mr = lr.length;
    if (!mr)
      return "";
    for (var vr = ""; ++gr < mr; ) {
      var yr = Number(lr[gr]);
      if (!isFinite(yr) || // `NaN`, `+Infinity`, or `-Infinity`
      yr < 0 || // not a valid Unicode code point
      yr > 1114111 || // not a valid Unicode code point
      floor_1(yr) !== yr)
        return String.fromCharCode(65533);
      yr <= 65535 ? ur.push(yr) : (yr -= 65536, fr = (yr >> 10) + 55296, dr = yr % 1024 + 56320, ur.push(fr, dr)), (gr + 1 === mr || ur.length > cr) && (vr += stringFromCharCode_1.apply(void 0, ur), ur.length = 0);
    }
    return vr;
  };
}
var fromCodePoint$1 = fromCodePoint, DOMAIN = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", PATH = "[^<\\s]*[^<?!.,:*_?~\\s]", EMAIL = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function trimUnmatchedTrailingParens(lr) {
  var ar = /\)+$/.exec(lr);
  if (ar) {
    for (var cr = 0, ur = 0, fr = lr; ur < fr.length; ur++) {
      var dr = fr[ur];
      dr === "(" ? cr < 0 ? cr = 1 : cr += 1 : dr === ")" && (cr -= 1);
    }
    if (cr < 0) {
      var gr = Math.min(-cr, ar[0].length);
      return lr.substring(0, lr.length - gr);
    }
  }
  return lr;
}
function trimTrailingEntity(lr) {
  return lr.replace(/&[A-Za-z0-9]+;$/, "");
}
function parseEmailLink(lr) {
  for (var ar = new RegExp(EMAIL, "g"), cr = [], ur; ur = ar.exec(lr); ) {
    var fr = ur[0];
    /[_-]+$/.test(fr) || cr.push({
      text: fr,
      range: [ur.index, ur.index + fr.length - 1],
      url: "mailto:" + fr
    });
  }
  return cr;
}
function parseUrlLink(lr) {
  for (var ar = new RegExp("(www|https?://)." + DOMAIN + PATH, "g"), cr = [], ur; ur = ar.exec(lr); ) {
    var fr = trimTrailingEntity(trimUnmatchedTrailingParens(ur[0])), dr = ur[1] === "www" ? "http://" : "";
    cr.push({
      text: fr,
      range: [ur.index, ur.index + fr.length - 1],
      url: "" + dr + fr
    });
  }
  return cr;
}
function baseAutolinkParser(lr) {
  return __spreadArray(__spreadArray([], parseUrlLink(lr)), parseEmailLink(lr)).sort(function(ar, cr) {
    return ar.range[0] - cr.range[0];
  });
}
function convertExtAutoLinks(lr, ar) {
  typeof ar == "boolean" && (ar = baseAutolinkParser);
  for (var cr, ur = function() {
    var fr = cr.entering, dr = cr.node;
    if (fr && dr.type === "text" && dr.parent.type !== "link") {
      var gr = dr.literal, mr = ar(gr);
      if (!mr || !mr.length)
        return "continue";
      for (var vr = 0, yr = dr.sourcepos[0], kr = yr[0], _r = yr[1], xr = function(Xr, Jr) {
        return [
          [kr, _r + Xr],
          [kr, _r + Jr]
        ];
      }, Sr = [], Er = 0, Cr = mr; Er < Cr.length; Er++) {
        var Tr = Cr[Er], Ar = Tr.range, Ir = Tr.url, Mr = Tr.text;
        Ar[0] > vr && Sr.push(text$1(gr.substring(vr, Ar[0]), xr(vr, Ar[0] - 1)));
        var Hr = createNode$1("link", xr.apply(void 0, Ar));
        Hr.appendChild(text$1(Mr, xr.apply(void 0, Ar))), Hr.destination = Ir, Hr.extendedAutolink = !0, Sr.push(Hr), vr = Ar[1] + 1;
      }
      vr < gr.length && Sr.push(text$1(gr.substring(vr), xr(vr, gr.length - 1)));
      for (var Br = 0, zr = Sr; Br < zr.length; Br++) {
        var Gr = zr[Br];
        dr.insertBefore(Gr);
      }
      dr.unlink();
    }
  }; cr = lr.next(); )
    ur();
}
function last(lr) {
  return lr[lr.length - 1];
}
function normalizeReference(lr) {
  return lr.slice(1, lr.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function iterateObject(lr, ar) {
  Object.keys(lr).forEach(function(cr) {
    ar(cr, lr[cr]);
  });
}
function omit(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  var ur = __assign({}, lr);
  return ar.forEach(function(fr) {
    delete ur[fr];
  }), ur;
}
function isEmptyObj(lr) {
  return !Object.keys(lr).length;
}
function clearObj(lr) {
  Object.keys(lr).forEach(function(ar) {
    delete lr[ar];
  });
}
var C_NEWLINE = 10, C_ASTERISK = 42, C_UNDERSCORE = 95, C_BACKTICK = 96, C_OPEN_BRACKET$1 = 91, C_CLOSE_BRACKET = 93, C_TILDE = 126, C_LESSTHAN$1 = 60, C_BANG = 33, C_BACKSLASH = 92, C_AMPERSAND = 38, C_OPEN_PAREN = 40, C_CLOSE_PAREN = 41, C_COLON = 58, C_SINGLEQUOTE = 39, C_DOUBLEQUOTE = 34, C_DOLLAR = 36, ESCAPED_CHAR = "\\\\" + ESCAPABLE, rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), reLinkTitle = new RegExp('^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"|' + ("'(" + ESCAPED_CHAR + "|[^'\\x00])*'") + "|" + ("\\((" + ESCAPED_CHAR + "|[^()\\x00])*\\))")), reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, reEscapable = new RegExp("^" + ESCAPABLE), reEntityHere = new RegExp("^" + ENTITY, "i"), reTicks = /`+/, reTicksHere = /^`+/, reEllipses = /\.\.\./g, reDash = /--+/g, reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, reSpnl = /^ *(?:\n *)?/, reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/, reUnicodeWhitespaceChar = /^\s/, reFinalSpace = / *$/, reInitialSpace = /^ */, reSpaceAtEndOfLine = /^ *(?:\n|$)/, reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, reMain = /^[^\n`\[\]\\!<&*_'"~$]+/m, InlineParser = (
  /** @class */
  function() {
    function lr(ar) {
      this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = ar;
    }
    return lr.prototype.sourcepos = function(ar, cr) {
      var ur = this.linePosOffset + this.lineOffsets[this.lineIdx], fr = this.lineStartNum + this.lineIdx, dr = [fr, ar + ur];
      return typeof cr == "number" ? [dr, [fr, cr + ur]] : dr;
    }, lr.prototype.nextLine = function() {
      this.lineIdx += 1, this.linePosOffset = -this.pos;
    }, lr.prototype.match = function(ar) {
      var cr = ar.exec(this.subject.slice(this.pos));
      return cr === null ? null : (this.pos += cr.index + cr[0].length, cr[0]);
    }, lr.prototype.peek = function() {
      return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
    }, lr.prototype.spnl = function() {
      return this.match(reSpnl), !0;
    }, lr.prototype.parseBackticks = function(ar) {
      var cr = this.pos + 1, ur = this.match(reTicksHere);
      if (ur === null)
        return !1;
      for (var fr = this.pos, dr; (dr = this.match(reTicks)) !== null; )
        if (dr === ur) {
          var gr = this.subject.slice(fr, this.pos - ur.length), mr = this.sourcepos(cr, this.pos), vr = gr.split(`
`);
          if (vr.length > 1) {
            var yr = last(vr);
            this.lineIdx += vr.length - 1, this.linePosOffset = -(this.pos - yr.length - ur.length), mr[1] = this.sourcepos(this.pos), gr = vr.join(" ");
          }
          var kr = createNode$1("code", mr);
          return gr.length > 0 && gr.match(/[^ ]/) !== null && gr[0] == " " && gr[gr.length - 1] == " " ? kr.literal = gr.slice(1, gr.length - 1) : kr.literal = gr, kr.tickCount = ur.length, ar.appendChild(kr), !0;
        }
      return this.pos = fr, ar.appendChild(text$1(ur, this.sourcepos(cr, this.pos - 1))), !0;
    }, lr.prototype.parseBackslash = function(ar) {
      var cr = this.subject, ur;
      this.pos += 1;
      var fr = this.pos;
      return this.peek() === C_NEWLINE ? (this.pos += 1, ur = createNode$1("linebreak", this.sourcepos(this.pos - 1, this.pos)), ar.appendChild(ur), this.nextLine()) : reEscapable.test(cr.charAt(this.pos)) ? (ar.appendChild(text$1(cr.charAt(this.pos), this.sourcepos(fr, this.pos))), this.pos += 1) : ar.appendChild(text$1("\\", this.sourcepos(fr, fr))), !0;
    }, lr.prototype.parseAutolink = function(ar) {
      var cr, ur, fr, dr = this.pos + 1;
      return (cr = this.match(reEmailAutolink)) ? (ur = cr.slice(1, cr.length - 1), fr = createNode$1("link", this.sourcepos(dr, this.pos)), fr.destination = normalizeURI("mailto:" + ur), fr.title = "", fr.appendChild(text$1(ur, this.sourcepos(dr + 1, this.pos - 1))), ar.appendChild(fr), !0) : (cr = this.match(reAutolink)) ? (ur = cr.slice(1, cr.length - 1), fr = createNode$1("link", this.sourcepos(dr, this.pos)), fr.destination = normalizeURI(ur), fr.title = "", fr.appendChild(text$1(ur, this.sourcepos(dr + 1, this.pos - 1))), ar.appendChild(fr), !0) : !1;
    }, lr.prototype.parseHtmlTag = function(ar) {
      var cr = this.pos + 1, ur = this.match(reHtmlTag);
      if (ur === null)
        return !1;
      var fr = createNode$1("htmlInline", this.sourcepos(cr, this.pos));
      return fr.literal = ur, ar.appendChild(fr), !0;
    }, lr.prototype.scanDelims = function(ar) {
      var cr = 0, ur = this.pos;
      if (ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE)
        cr++, this.pos++;
      else
        for (; this.peek() === ar; )
          cr++, this.pos++;
      if (cr === 0 || cr < 2 && (ar === C_TILDE || ar === C_DOLLAR))
        return this.pos = ur, null;
      var fr = ur === 0 ? `
` : this.subject.charAt(ur - 1), dr = this.peek(), gr;
      dr === -1 ? gr = `
` : gr = fromCodePoint$1(dr);
      var mr = reUnicodeWhitespaceChar.test(gr), vr = rePunctuation.test(gr), yr = reUnicodeWhitespaceChar.test(fr), kr = rePunctuation.test(fr), _r = !mr && (!vr || yr || kr), xr = !yr && (!kr || mr || vr), Sr, Er;
      return ar === C_UNDERSCORE ? (Sr = _r && (!xr || kr), Er = xr && (!_r || vr)) : ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE ? (Sr = _r && !xr, Er = xr) : ar === C_DOLLAR ? (Sr = !mr, Er = !yr) : (Sr = _r, Er = xr), this.pos = ur, { numdelims: cr, canOpen: Sr, canClose: Er };
    }, lr.prototype.handleDelim = function(ar, cr) {
      var ur = this.scanDelims(ar);
      if (!ur)
        return !1;
      var fr = ur.numdelims, dr = this.pos + 1, gr;
      this.pos += fr, ar === C_SINGLEQUOTE ? gr = "’" : ar === C_DOUBLEQUOTE ? gr = "“" : gr = this.subject.slice(dr - 1, this.pos);
      var mr = text$1(gr, this.sourcepos(dr, this.pos));
      return cr.appendChild(mr), (ur.canOpen || ur.canClose) && (this.options.smart || ar !== C_SINGLEQUOTE && ar !== C_DOUBLEQUOTE) && (this.delimiters = {
        cc: ar,
        numdelims: fr,
        origdelims: fr,
        node: mr,
        previous: this.delimiters,
        next: null,
        canOpen: ur.canOpen,
        canClose: ur.canClose
      }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
    }, lr.prototype.removeDelimiter = function(ar) {
      ar.previous !== null && (ar.previous.next = ar.next), ar.next === null ? this.delimiters = ar.previous : ar.next.previous = ar.previous;
    }, lr.prototype.removeDelimitersBetween = function(ar, cr) {
      ar.next !== cr && (ar.next = cr, cr.previous = ar);
    }, lr.prototype.processEmphasis = function(ar) {
      var cr, ur, fr, dr, gr, mr, vr, yr = !1, kr = (cr = {}, cr[C_UNDERSCORE] = [ar, ar, ar], cr[C_ASTERISK] = [ar, ar, ar], cr[C_SINGLEQUOTE] = [ar], cr[C_DOUBLEQUOTE] = [ar], cr[C_TILDE] = [ar], cr[C_DOLLAR] = [ar], cr);
      for (fr = this.delimiters; fr !== null && fr.previous !== ar; )
        fr = fr.previous;
      for (; fr !== null; ) {
        var _r = fr.cc, xr = _r === C_UNDERSCORE || _r === C_ASTERISK;
        if (!fr.canClose)
          fr = fr.next;
        else {
          for (ur = fr.previous, vr = !1; ur !== null && ur !== ar && ur !== kr[_r][xr ? fr.origdelims % 3 : 0]; ) {
            if (yr = xr && (fr.canOpen || ur.canClose) && fr.origdelims % 3 !== 0 && (ur.origdelims + fr.origdelims) % 3 === 0, ur.cc === fr.cc && ur.canOpen && !yr) {
              vr = !0;
              break;
            }
            ur = ur.previous;
          }
          if (dr = fr, xr || _r === C_TILDE || _r === C_DOLLAR) {
            if (!vr)
              fr = fr.next;
            else if (ur) {
              var Sr = fr.numdelims >= 2 && ur.numdelims >= 2 ? 2 : 1, Er = xr ? 0 : 1;
              gr = ur.node, mr = fr.node;
              var Cr = xr ? Sr === 1 ? "emph" : "strong" : "strike";
              _r === C_DOLLAR && (Cr = "customInline");
              var Tr = createNode$1(Cr), Ar = gr.sourcepos[1], Ir = mr.sourcepos[0];
              Tr.sourcepos = [
                [Ar[0], Ar[1] - Sr + 1],
                [Ir[0], Ir[1] + Sr - 1]
              ], gr.sourcepos[1][1] -= Sr, mr.sourcepos[0][1] += Sr, gr.literal = gr.literal.slice(Sr), mr.literal = mr.literal.slice(Sr), ur.numdelims -= Sr, fr.numdelims -= Sr;
              for (var Mr = gr.next, Hr = void 0; Mr && Mr !== mr; )
                Hr = Mr.next, Mr.unlink(), Tr.appendChild(Mr), Mr = Hr;
              if (_r === C_DOLLAR) {
                var Br = Tr.firstChild, zr = Br.literal || "", Gr = zr.split(/\s/)[0];
                Tr.info = Gr, zr.length <= Gr.length ? Br.unlink() : (Br.sourcepos[0][1] += Gr.length, Br.literal = zr.replace(Gr + " ", ""));
              }
              if (gr.insertAfter(Tr), this.removeDelimitersBetween(ur, fr), ur.numdelims <= Er && (ur.numdelims === 0 && gr.unlink(), this.removeDelimiter(ur)), fr.numdelims <= Er) {
                fr.numdelims === 0 && mr.unlink();
                var Xr = fr.next;
                this.removeDelimiter(fr), fr = Xr;
              }
            }
          } else
            _r === C_SINGLEQUOTE ? (fr.node.literal = "’", vr && (ur.node.literal = "‘"), fr = fr.next) : _r === C_DOUBLEQUOTE && (fr.node.literal = "”", vr && (ur.node.literal = "“"), fr = fr.next);
          vr || (kr[_r][xr ? dr.origdelims % 3 : 0] = dr.previous, dr.canOpen || this.removeDelimiter(dr));
        }
      }
      for (; this.delimiters !== null && this.delimiters !== ar; )
        this.removeDelimiter(this.delimiters);
    }, lr.prototype.parseLinkTitle = function() {
      var ar = this.match(reLinkTitle);
      return ar === null ? null : unescapeString(ar.substr(1, ar.length - 2));
    }, lr.prototype.parseLinkDestination = function() {
      var ar = this.match(reLinkDestinationBraces);
      if (ar === null) {
        if (this.peek() === C_LESSTHAN$1)
          return null;
        for (var cr = this.pos, ur = 0, fr = void 0; (fr = this.peek()) !== -1; )
          if (fr === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1)))
            this.pos += 1, this.peek() !== -1 && (this.pos += 1);
          else if (fr === C_OPEN_PAREN)
            this.pos += 1, ur += 1;
          else if (fr === C_CLOSE_PAREN) {
            if (ur < 1)
              break;
            this.pos += 1, ur -= 1;
          } else {
            if (reWhitespaceChar.exec(fromCodePoint$1(fr)) !== null)
              break;
            this.pos += 1;
          }
        return this.pos === cr && fr !== C_CLOSE_PAREN || ur !== 0 ? null : (ar = this.subject.substr(cr, this.pos - cr), normalizeURI(unescapeString(ar)));
      }
      return normalizeURI(unescapeString(ar.substr(1, ar.length - 2)));
    }, lr.prototype.parseLinkLabel = function() {
      var ar = this.match(reLinkLabel);
      return ar === null || ar.length > 1001 ? 0 : ar.length;
    }, lr.prototype.parseOpenBracket = function(ar) {
      var cr = this.pos;
      this.pos += 1;
      var ur = text$1("[", this.sourcepos(this.pos, this.pos));
      return ar.appendChild(ur), this.addBracket(ur, cr, !1), !0;
    }, lr.prototype.parseBang = function(ar) {
      var cr = this.pos;
      if (this.pos += 1, this.peek() === C_OPEN_BRACKET$1) {
        this.pos += 1;
        var ur = text$1("![", this.sourcepos(this.pos - 1, this.pos));
        ar.appendChild(ur), this.addBracket(ur, cr + 1, !0);
      } else {
        var ur = text$1("!", this.sourcepos(this.pos, this.pos));
        ar.appendChild(ur);
      }
      return !0;
    }, lr.prototype.parseCloseBracket = function(ar) {
      var cr = null, ur = null, fr = !1;
      this.pos += 1;
      var dr = this.pos, gr = this.brackets;
      if (gr === null)
        return ar.appendChild(text$1("]", this.sourcepos(dr, dr))), !0;
      if (!gr.active)
        return ar.appendChild(text$1("]", this.sourcepos(dr, dr))), this.removeBracket(), !0;
      var mr = gr.image, vr = this.pos;
      this.peek() === C_OPEN_PAREN && (this.pos++, this.spnl() && (cr = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
      (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) && (ur = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === C_CLOSE_PAREN ? (this.pos += 1, fr = !0) : this.pos = vr);
      var yr = "";
      if (!fr) {
        var kr = this.pos, _r = this.parseLinkLabel();
        if (_r > 2 ? yr = this.subject.slice(kr, kr + _r) : gr.bracketAfter || (yr = this.subject.slice(gr.index, dr)), _r === 0 && (this.pos = vr), yr) {
          yr = normalizeReference(yr);
          var xr = this.refMap[yr];
          xr && (cr = xr.destination, ur = xr.title, fr = !0);
        }
      }
      if (fr) {
        var Sr = createNode$1(mr ? "image" : "link");
        Sr.destination = cr, Sr.title = ur || "", Sr.sourcepos = [gr.startpos, this.sourcepos(this.pos)];
        for (var Er = gr.node.next, Cr = void 0; Er; )
          Cr = Er.next, Er.unlink(), Sr.appendChild(Er), Er = Cr;
        if (ar.appendChild(Sr), this.processEmphasis(gr.previousDelimiter), this.removeBracket(), gr.node.unlink(), !mr)
          for (gr = this.brackets; gr !== null; )
            gr.image || (gr.active = !1), gr = gr.previous;
        return this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: yr }), !0;
      }
      return this.removeBracket(), this.pos = dr, ar.appendChild(text$1("]", this.sourcepos(dr, dr))), this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: yr }), !0;
    }, lr.prototype.addBracket = function(ar, cr, ur) {
      this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
        node: ar,
        startpos: this.sourcepos(cr + (ur ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: cr,
        image: ur,
        active: !0
      };
    }, lr.prototype.removeBracket = function() {
      this.brackets && (this.brackets = this.brackets.previous);
    }, lr.prototype.parseEntity = function(ar) {
      var cr, ur = this.pos + 1;
      return (cr = this.match(reEntityHere)) ? (ar.appendChild(text$1(lib.decodeHTML(cr), this.sourcepos(ur, this.pos))), !0) : !1;
    }, lr.prototype.parseString = function(ar) {
      var cr, ur = this.pos + 1;
      if (cr = this.match(reMain)) {
        if (this.options.smart) {
          var fr = cr.replace(reEllipses, "…").replace(reDash, function(gr) {
            var mr = 0, vr = 0;
            return gr.length % 3 === 0 ? vr = gr.length / 3 : gr.length % 2 === 0 ? mr = gr.length / 2 : gr.length % 3 === 2 ? (mr = 1, vr = (gr.length - 2) / 3) : (mr = 2, vr = (gr.length - 4) / 3), repeat("—", vr) + repeat("–", mr);
          });
          ar.appendChild(text$1(fr, this.sourcepos(ur, this.pos)));
        } else {
          var dr = text$1(cr, this.sourcepos(ur, this.pos));
          ar.appendChild(dr);
        }
        return !0;
      }
      return !1;
    }, lr.prototype.parseNewline = function(ar) {
      this.pos += 1;
      var cr = ar.lastChild;
      if (cr && cr.type === "text" && cr.literal[cr.literal.length - 1] === " ") {
        var ur = cr.literal[cr.literal.length - 2] === " ", fr = cr.literal.length;
        cr.literal = cr.literal.replace(reFinalSpace, "");
        var dr = fr - cr.literal.length;
        cr.sourcepos[1][1] -= dr, ar.appendChild(createNode$1(ur ? "linebreak" : "softbreak", this.sourcepos(this.pos - dr, this.pos)));
      } else
        ar.appendChild(createNode$1("softbreak", this.sourcepos(this.pos, this.pos)));
      return this.nextLine(), this.match(reInitialSpace), !0;
    }, lr.prototype.parseReference = function(ar, cr) {
      if (!this.options.referenceDefinition)
        return 0;
      this.subject = ar.stringContent, this.pos = 0;
      var ur = null, fr = this.pos, dr = this.parseLinkLabel();
      if (dr === 0)
        return 0;
      var gr = this.subject.substr(0, dr);
      if (this.peek() === C_COLON)
        this.pos++;
      else
        return this.pos = fr, 0;
      this.spnl();
      var mr = this.parseLinkDestination();
      if (mr === null)
        return this.pos = fr, 0;
      var vr = this.pos;
      this.spnl(), this.pos !== vr && (ur = this.parseLinkTitle()), ur === null && (ur = "", this.pos = vr);
      var yr = !0;
      if (this.match(reSpaceAtEndOfLine) === null && (ur === "" ? yr = !1 : (ur = "", this.pos = vr, yr = this.match(reSpaceAtEndOfLine) !== null)), !yr)
        return this.pos = fr, 0;
      var kr = normalizeReference(gr);
      if (kr === "")
        return this.pos = fr, 0;
      var _r = this.getReferenceDefSourcepos(ar);
      ar.sourcepos[0][0] = _r[1][0] + 1;
      var xr = createNode$1("refDef", _r);
      return xr.title = ur, xr.dest = mr, xr.label = kr, ar.insertBefore(xr), cr[kr] ? this.refDefCandidateMap[xr.id] = xr : cr[kr] = createRefDefState(xr), this.pos - fr;
    }, lr.prototype.mergeTextNodes = function(ar) {
      for (var cr, ur = []; cr = ar.next(); ) {
        var fr = cr.entering, dr = cr.node;
        if (fr && dr.type === "text")
          ur.push(dr);
        else if (ur.length === 1)
          ur = [];
        else if (ur.length > 1) {
          var gr = ur[0], mr = ur[ur.length - 1];
          gr.sourcepos && mr.sourcepos && (gr.sourcepos[1] = mr.sourcepos[1]), gr.next = mr.next, gr.next && (gr.next.prev = gr);
          for (var vr = 1; vr < ur.length; vr += 1)
            gr.literal += ur[vr].literal, ur[vr].unlink();
          ur = [];
        }
      }
    }, lr.prototype.getReferenceDefSourcepos = function(ar) {
      for (var cr = ar.stringContent.split(/\n|\r\n/), ur = !1, fr = 0, dr = { line: 0, ch: 0 }, gr = 0; gr < cr.length; gr += 1) {
        var mr = cr[gr];
        if (reWhitespaceChar.test(mr))
          break;
        if (/\:/.test(mr) && fr === 0) {
          if (ur)
            break;
          var vr = mr.indexOf(":") === mr.length - 1 ? gr + 1 : gr;
          dr = { line: vr, ch: cr[vr].length }, ur = !0;
        }
        var yr = mr.match(/'|"/g);
        if (yr && (fr += yr.length), fr === 2) {
          dr = { line: gr, ch: mr.length };
          break;
        }
      }
      return [
        [ar.sourcepos[0][0], ar.sourcepos[0][1]],
        [ar.sourcepos[0][0] + dr.line, dr.ch]
      ];
    }, lr.prototype.parseInline = function(ar) {
      var cr, ur = !1, fr = this.peek();
      if (fr === -1)
        return !1;
      switch (fr) {
        case C_NEWLINE:
          ur = this.parseNewline(ar);
          break;
        case C_BACKSLASH:
          ur = this.parseBackslash(ar);
          break;
        case C_BACKTICK:
          ur = this.parseBackticks(ar);
          break;
        case C_ASTERISK:
        case C_UNDERSCORE:
        case C_TILDE:
        case C_DOLLAR:
          ur = this.handleDelim(fr, ar);
          break;
        case C_SINGLEQUOTE:
        case C_DOUBLEQUOTE:
          ur = !!(!((cr = this.options) === null || cr === void 0) && cr.smart) && this.handleDelim(fr, ar);
          break;
        case C_OPEN_BRACKET$1:
          ur = this.parseOpenBracket(ar);
          break;
        case C_BANG:
          ur = this.parseBang(ar);
          break;
        case C_CLOSE_BRACKET:
          ur = this.parseCloseBracket(ar);
          break;
        case C_LESSTHAN$1:
          ur = this.parseAutolink(ar) || this.parseHtmlTag(ar);
          break;
        case C_AMPERSAND:
          ar.disabledEntityParse || (ur = this.parseEntity(ar));
          break;
        default:
          ur = this.parseString(ar);
          break;
      }
      return ur || (this.pos += 1, ar.appendChild(text$1(fromCodePoint$1(fr), this.sourcepos(this.pos, this.pos + 1)))), !0;
    }, lr.prototype.parse = function(ar) {
      for (this.subject = ar.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = ar.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = ar.sourcepos[0][0], isHeading(ar) && (this.lineOffsets[0] += ar.level + 1); this.parseInline(ar); )
        ;
      ar.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(ar.walker());
      var cr = this.options, ur = cr.extendedAutolinks, fr = cr.customParser;
      if (ur && convertExtAutoLinks(ar.walker(), ur), fr && ar.firstChild)
        for (var dr, gr = ar.firstChild.walker(); dr = gr.next(); ) {
          var mr = dr.node, vr = dr.entering;
          fr[mr.type] && fr[mr.type](mr, { entering: vr, options: this.options });
        }
    }, lr;
  }()
), reTaskListItemMarker = /^\[([ \txX])\][ \t]+/;
function taskListItemFinalize(lr, ar) {
  if (ar.firstChild && ar.firstChild.type === "paragraph") {
    var cr = ar.firstChild, ur = cr.stringContent.match(reTaskListItemMarker);
    if (ur) {
      var fr = ur[0].length;
      cr.stringContent = cr.stringContent.substring(fr - 1), cr.sourcepos[0][1] += fr, cr.lineOffsets[0] += fr, ar.listData.task = !0, ar.listData.checked = /[xX]/.test(ur[1]);
    }
  }
}
var table = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableHead" || lr === "tableBody";
  },
  acceptsLines: !1
}, tableBody$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableRow";
  },
  acceptsLines: !1
}, tableHead$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableRow" || lr === "tableDelimRow";
  },
  acceptsLines: !1
}, tableDelimRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableDelimCell";
  },
  acceptsLines: !1
}, tableDelimCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, tableRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr === "tableCell";
  },
  acceptsLines: !1
}, tableCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, CODE_INDENT = 4, C_TAB = 9, C_GREATERTHAN = 62, C_LESSTHAN = 60, C_SPACE = 32, C_OPEN_BRACKET = 91, reNonSpace = /[^ \t\f\v\r\n]/, reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
function endsWithBlankLine(lr) {
  for (var ar = lr; ar; ) {
    if (ar.lastLineBlank)
      return !0;
    var cr = ar.type;
    if (!ar.lastLineChecked && (cr === "list" || cr === "item"))
      ar.lastLineChecked = !0, ar = ar.lastChild;
    else {
      ar.lastLineChecked = !0;
      break;
    }
  }
  return !1;
}
function peek(lr, ar) {
  return ar < lr.length ? lr.charCodeAt(ar) : -1;
}
function isBlank(lr) {
  return !reNonSpace.test(lr);
}
function isSpaceOrTab(lr) {
  return lr === C_SPACE || lr === C_TAB;
}
var reClosingCustomBlock = /^\$\$$/, customBlock$1 = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = cr.match(reClosingCustomBlock);
    if (ur)
      return lr.lastLineLength = ur[0].length, lr.finalize(ar, lr.lineNumber), 2;
    for (var fr = ar.offset; fr > 0 && isSpaceOrTab(peek(cr, lr.offset)); )
      lr.advanceOffset(1, !0), fr--;
    return 0;
  },
  finalize: function(lr, ar) {
    if (ar.stringContent !== null) {
      var cr = ar.stringContent, ur = cr.indexOf(`
`), fr = cr.slice(0, ur), dr = cr.slice(ur + 1), gr = fr.match(/^(\s*)(.*)/);
      ar.info = unescapeString(gr[2].trim()), ar.literal = dr, ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, noop = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, document$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, list$1 = {
  continue: function() {
    return 0;
  },
  finalize: function(lr, ar) {
    for (var cr = ar.firstChild; cr; ) {
      if (endsWithBlankLine(cr) && cr.next) {
        ar.listData.tight = !1;
        break;
      }
      for (var ur = cr.firstChild; ur; ) {
        if (endsWithBlankLine(ur) && (cr.next || ur.next)) {
          ar.listData.tight = !1;
          break;
        }
        ur = ur.next;
      }
      cr = cr.next;
    }
  },
  canContain: function(lr) {
    return lr === "item";
  },
  acceptsLines: !1
}, blockQuote$1 = {
  continue: function(lr) {
    var ar = lr.currentLine;
    if (!lr.indented && peek(ar, lr.nextNonspace) === C_GREATERTHAN)
      lr.advanceNextNonspace(), lr.advanceOffset(1, !1), isSpaceOrTab(peek(ar, lr.offset)) && lr.advanceOffset(1, !0);
    else
      return 1;
    return 0;
  },
  finalize: function() {
  },
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, item = {
  continue: function(lr, ar) {
    if (lr.blank) {
      if (ar.firstChild === null)
        return 1;
      lr.advanceNextNonspace();
    } else if (lr.indent >= ar.listData.markerOffset + ar.listData.padding)
      lr.advanceOffset(ar.listData.markerOffset + ar.listData.padding, !0);
    else
      return 1;
    return 0;
  },
  finalize: taskListItemFinalize,
  canContain: function(lr) {
    return lr !== "item";
  },
  acceptsLines: !1
}, heading$2 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, thematicBreak$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, codeBlock = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = lr.indent;
    if (ar.isFenced) {
      var fr = ur <= 3 && cr.charAt(lr.nextNonspace) === ar.fenceChar && cr.slice(lr.nextNonspace).match(reClosingCodeFence);
      if (fr && fr[0].length >= ar.fenceLength)
        return lr.lastLineLength = lr.offset + ur + fr[0].length, lr.finalize(ar, lr.lineNumber), 2;
      for (var dr = ar.fenceOffset; dr > 0 && isSpaceOrTab(peek(cr, lr.offset)); )
        lr.advanceOffset(1, !0), dr--;
    } else if (ur >= CODE_INDENT)
      lr.advanceOffset(CODE_INDENT, !0);
    else if (lr.blank)
      lr.advanceNextNonspace();
    else
      return 1;
    return 0;
  },
  finalize: function(lr, ar) {
    var cr;
    if (ar.stringContent !== null) {
      if (ar.isFenced) {
        var ur = ar.stringContent, fr = ur.indexOf(`
`), dr = ur.slice(0, fr), gr = ur.slice(fr + 1), mr = dr.match(/^(\s*)(.*)/);
        ar.infoPadding = mr[1].length, ar.info = unescapeString(mr[2].trim()), ar.literal = gr;
      } else
        ar.literal = (cr = ar.stringContent) === null || cr === void 0 ? void 0 : cr.replace(/(\n *)+$/, `
`);
      ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, htmlBlock$1 = {
  continue: function(lr, ar) {
    return lr.blank && (ar.htmlBlockType === 6 || ar.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(lr, ar) {
    var cr;
    ar.literal = ((cr = ar.stringContent) === null || cr === void 0 ? void 0 : cr.replace(/(\n *)+$/, "")) || null, ar.stringContent = null;
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, paragraph$1 = {
  continue: function(lr) {
    return lr.blank ? 1 : 0;
  },
  finalize: function(lr, ar) {
    if (ar.stringContent !== null) {
      for (var cr, ur = !1; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (cr = lr.inlineParser.parseReference(ar, lr.refMap)); )
        ar.stringContent = ar.stringContent.slice(cr), ur = !0;
      ur && isBlank(ar.stringContent) && ar.unlink();
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, refDef = noop, frontMatter$2 = noop, blockHandlers = {
  document: document$1,
  list: list$1,
  blockQuote: blockQuote$1,
  item,
  heading: heading$2,
  thematicBreak: thematicBreak$1,
  codeBlock,
  htmlBlock: htmlBlock$1,
  paragraph: paragraph$1,
  table,
  tableBody: tableBody$1,
  tableHead: tableHead$1,
  tableRow,
  tableCell,
  tableDelimRow,
  tableDelimCell,
  refDef,
  customBlock: customBlock$1,
  frontMatter: frontMatter$2
};
function parseRowContent(lr) {
  for (var ar = 0, cr = 0, ur = [], fr = 0; fr < lr.length; fr += 1)
    if (lr[fr] === "|" && lr[fr - 1] !== "\\") {
      var dr = lr.substring(ar, fr);
      ar === 0 && isEmpty(dr) ? cr = fr + 1 : ur.push(dr), ar = fr + 1;
    }
  if (ar < lr.length) {
    var dr = lr.substring(ar, lr.length);
    isEmpty(dr) || ur.push(dr);
  }
  return [cr, ur];
}
function generateTableCells(lr, ar, cr, ur) {
  for (var fr = [], dr = 0, gr = ar; dr < gr.length; dr++) {
    var mr = gr[dr], vr = mr.match(/^[ \t]+/), yr = vr ? vr[0].length : 0, kr = void 0, _r = void 0;
    if (yr === mr.length)
      yr = 0, kr = 0, _r = "";
    else {
      var xr = mr.match(/[ \t]+$/);
      kr = xr ? xr[0].length : 0, _r = mr.slice(yr, mr.length - kr);
    }
    var Sr = ur + yr, Er = createNode$1(lr, [
      [cr, ur],
      [cr, ur + mr.length - 1]
    ]);
    Er.stringContent = _r.replace(/\\\|/g, "|"), Er.startIdx = fr.length, Er.endIdx = fr.length, Er.lineOffsets = [Sr - 1], Er.paddingLeft = yr, Er.paddingRight = kr, fr.push(Er), ur += mr.length + 1;
  }
  return fr;
}
function getColumnFromDelimCell(lr) {
  var ar = null, cr = lr.stringContent, ur = cr[0], fr = cr[cr.length - 1];
  return fr === ":" ? ar = ur === ":" ? "center" : "right" : ur === ":" && (ar = "left"), { align: ar };
}
var tableHead = function(lr, ar) {
  var cr = ar.stringContent;
  if (ar.type === "paragraph" && !lr.indented && !lr.blank) {
    var ur = cr.length - 1, fr = cr.lastIndexOf(`
`, ur - 1) + 1, dr = cr.slice(fr, ur), gr = lr.currentLine.slice(lr.nextNonspace), mr = parseRowContent(dr), vr = mr[0], yr = mr[1], kr = parseRowContent(gr), _r = kr[0], xr = kr[1], Sr = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !yr.length || !xr.length || xr.some(function(Xr) {
        return !Sr.test(Xr);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      xr.length === 1 && gr.indexOf("|") !== 0
    )
      return 0;
    var Er = ar.lineOffsets, Cr = lr.lineNumber - 1, Tr = last(Er) + 1, Ar = createNode$1("table", [
      [Cr, Tr],
      [lr.lineNumber, lr.offset]
    ]);
    if (Ar.columns = xr.map(function() {
      return { align: null };
    }), ar.insertAfter(Ar), Er.length === 1)
      ar.unlink();
    else {
      ar.stringContent = cr.slice(0, fr);
      var Ir = cr.lastIndexOf(`
`, fr - 2) + 1, Mr = fr - Ir - 1;
      lr.lastLineLength = Er[Er.length - 2] + Mr, lr.finalize(ar, Cr - 1);
    }
    lr.advanceOffset(lr.currentLine.length - lr.offset, !1);
    var Hr = createNode$1("tableHead", [
      [Cr, Tr],
      [lr.lineNumber, lr.offset]
    ]);
    Ar.appendChild(Hr);
    var Br = createNode$1("tableRow", [
      [Cr, Tr],
      [Cr, Tr + dr.length - 1]
    ]), zr = createNode$1("tableDelimRow", [
      [lr.lineNumber, lr.nextNonspace + 1],
      [lr.lineNumber, lr.offset]
    ]);
    Hr.appendChild(Br), Hr.appendChild(zr), generateTableCells("tableCell", yr, Cr, Tr + vr).forEach(function(Xr) {
      Br.appendChild(Xr);
    });
    var Gr = generateTableCells("tableDelimCell", xr, lr.lineNumber, lr.nextNonspace + 1 + _r);
    return Gr.forEach(function(Xr) {
      zr.appendChild(Xr);
    }), Ar.columns = Gr.map(getColumnFromDelimCell), lr.tip = Ar, 2;
  }
  return 0;
}, tableBody = function(lr, ar) {
  if (ar.type !== "table" && ar.type !== "tableBody" || !lr.blank && lr.currentLine.indexOf("|") === -1)
    return 0;
  if (lr.advanceOffset(lr.currentLine.length - lr.offset, !1), lr.blank) {
    var cr = ar;
    return ar.type === "tableBody" && (cr = ar.parent, lr.finalize(ar, lr.lineNumber - 1)), lr.finalize(cr, lr.lineNumber - 1), 0;
  }
  var ur = ar;
  ar.type === "table" && (ur = lr.addChild("tableBody", lr.nextNonspace), ur.stringContent = null);
  var fr = createNode$1("tableRow", [
    [lr.lineNumber, lr.nextNonspace + 1],
    [lr.lineNumber, lr.currentLine.length]
  ]);
  ur.appendChild(fr);
  var dr = ur.parent, gr = lr.currentLine.slice(lr.nextNonspace), mr = parseRowContent(gr), vr = mr[0], yr = mr[1];
  return generateTableCells("tableCell", yr, lr.lineNumber, lr.nextNonspace + 1 + vr).forEach(function(kr, _r) {
    _r >= dr.columns.length && (kr.ignored = !0), fr.appendChild(kr);
  }), 2;
}, reCustomBlock = /^(\$\$)(\s*[a-zA-Z])+/, reCanBeCustomInline = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, customBlock = function(lr) {
  var ar;
  if (!lr.indented && !reCanBeCustomInline.test(lr.currentLine) && (ar = lr.currentLine.match(reCustomBlock))) {
    var cr = ar[1].length;
    lr.closeUnmatchedBlocks();
    var ur = lr.addChild("customBlock", lr.nextNonspace);
    return ur.syntaxLength = cr, ur.offset = lr.indent, lr.advanceNextNonspace(), lr.advanceOffset(cr, !1), 2;
  }
  return 0;
}, reCodeFence = /^`{3,}(?!.*`)|^~{3,}/, reHtmlBlockOpen = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", "i")
], reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/, reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/, reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, reBulletListMarker = /^[*+-]/, reOrderedListMarker = /^(\d{1,9})([.)])/;
function parseListMarker(lr, ar) {
  var cr = lr.currentLine.slice(lr.nextNonspace), ur, fr, dr = {
    type: "bullet",
    tight: !0,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: lr.indent,
    // GFM: Task List Item
    task: !1,
    checked: !1
  };
  if (lr.indent >= 4)
    return null;
  if (ur = cr.match(reBulletListMarker))
    dr.type = "bullet", dr.bulletChar = ur[0][0];
  else if ((ur = cr.match(reOrderedListMarker)) && (ar.type !== "paragraph" || ur[1] === "1"))
    dr.type = "ordered", dr.start = parseInt(ur[1], 10), dr.delimiter = ur[2];
  else
    return null;
  if (fr = peek(lr.currentLine, lr.nextNonspace + ur[0].length), !(fr === -1 || fr === C_TAB || fr === C_SPACE) || ar.type === "paragraph" && !lr.currentLine.slice(lr.nextNonspace + ur[0].length).match(reNonSpace))
    return null;
  lr.advanceNextNonspace(), lr.advanceOffset(ur[0].length, !0);
  var gr = lr.column, mr = lr.offset;
  do
    lr.advanceOffset(1, !0), fr = peek(lr.currentLine, lr.offset);
  while (lr.column - gr < 5 && isSpaceOrTab(fr));
  var vr = peek(lr.currentLine, lr.offset) === -1, yr = lr.column - gr;
  return yr >= 5 || yr < 1 || vr ? (dr.padding = ur[0].length + 1, lr.column = gr, lr.offset = mr, isSpaceOrTab(peek(lr.currentLine, lr.offset)) && lr.advanceOffset(1, !0)) : dr.padding = ur[0].length + yr, dr;
}
function listsMatch(lr, ar) {
  return lr.type === ar.type && lr.delimiter === ar.delimiter && lr.bulletChar === ar.bulletChar;
}
function isDisallowedDeepHeading(lr, ar) {
  return lr.options.disallowDeepHeading && (ar.type === "blockQuote" || ar.type === "item");
}
var blockQuote = function(lr) {
  return !lr.indented && peek(lr.currentLine, lr.nextNonspace) === C_GREATERTHAN ? (lr.advanceNextNonspace(), lr.advanceOffset(1, !1), isSpaceOrTab(peek(lr.currentLine, lr.offset)) && lr.advanceOffset(1, !0), lr.closeUnmatchedBlocks(), lr.addChild("blockQuote", lr.nextNonspace), 1) : 0;
}, atxHeading = function(lr, ar) {
  var cr;
  if (!lr.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(lr, ar) && (cr = lr.currentLine.slice(lr.nextNonspace).match(reATXHeadingMarker))) {
    lr.advanceNextNonspace(), lr.advanceOffset(cr[0].length, !1), lr.closeUnmatchedBlocks();
    var ur = lr.addChild("heading", lr.nextNonspace);
    return ur.level = cr[0].trim().length, ur.headingType = "atx", ur.stringContent = lr.currentLine.slice(lr.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), lr.advanceOffset(lr.currentLine.length - lr.offset), 2;
  }
  return 0;
}, fencedCodeBlock = function(lr) {
  var ar;
  if (!lr.indented && (ar = lr.currentLine.slice(lr.nextNonspace).match(reCodeFence))) {
    var cr = ar[0].length;
    lr.closeUnmatchedBlocks();
    var ur = lr.addChild("codeBlock", lr.nextNonspace);
    return ur.isFenced = !0, ur.fenceLength = cr, ur.fenceChar = ar[0][0], ur.fenceOffset = lr.indent, lr.advanceNextNonspace(), lr.advanceOffset(cr, !1), 2;
  }
  return 0;
}, htmlBlock = function(lr, ar) {
  if (!lr.indented && peek(lr.currentLine, lr.nextNonspace) === C_LESSTHAN) {
    var cr = lr.currentLine.slice(lr.nextNonspace), ur = lr.options.disallowedHtmlBlockTags, fr = void 0;
    for (fr = 1; fr <= 7; fr++) {
      var dr = cr.match(reHtmlBlockOpen[fr]);
      if (dr) {
        if (fr === 7) {
          if (ar.type === "paragraph")
            return 0;
          if (ur.length > 0) {
            var gr = new RegExp("</?(?:" + ur.join("|") + ")", "i");
            if (gr.test(dr[0]))
              return 0;
          }
        }
        lr.closeUnmatchedBlocks();
        var mr = lr.addChild("htmlBlock", lr.offset);
        return mr.htmlBlockType = fr, 2;
      }
    }
  }
  return 0;
}, seTextHeading = function(lr, ar) {
  var cr;
  if (ar.stringContent !== null && !lr.indented && ar.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(lr, ar.parent) && (cr = lr.currentLine.slice(lr.nextNonspace).match(reSetextHeadingLine))) {
    lr.closeUnmatchedBlocks();
    for (var ur = void 0; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (ur = lr.inlineParser.parseReference(ar, lr.refMap)); )
      ar.stringContent = ar.stringContent.slice(ur);
    if (ar.stringContent.length > 0) {
      var fr = createNode$1("heading", ar.sourcepos);
      return fr.level = cr[0][0] === "=" ? 1 : 2, fr.headingType = "setext", fr.stringContent = ar.stringContent, ar.insertAfter(fr), ar.unlink(), lr.tip = fr, lr.advanceOffset(lr.currentLine.length - lr.offset, !1), 2;
    }
    return 0;
  }
  return 0;
}, thematicBreak = function(lr) {
  return !lr.indented && reThematicBreak.test(lr.currentLine.slice(lr.nextNonspace)) ? (lr.closeUnmatchedBlocks(), lr.addChild("thematicBreak", lr.nextNonspace), lr.advanceOffset(lr.currentLine.length - lr.offset, !1), 2) : 0;
}, listItem = function(lr, ar) {
  var cr, ur = ar;
  return (!lr.indented || ar.type === "list") && (cr = parseListMarker(lr, ur)) ? (lr.closeUnmatchedBlocks(), (lr.tip.type !== "list" || !listsMatch(ur.listData, cr)) && (ur = lr.addChild("list", lr.nextNonspace), ur.listData = cr), ur = lr.addChild("item", lr.nextNonspace), ur.listData = cr, 1) : 0;
}, indentedCodeBlock = function(lr) {
  return lr.indented && lr.tip.type !== "paragraph" && !lr.blank ? (lr.advanceOffset(CODE_INDENT, !0), lr.closeUnmatchedBlocks(), lr.addChild("codeBlock", lr.offset), 2) : 0;
}, blockStarts = [
  blockQuote,
  atxHeading,
  fencedCodeBlock,
  htmlBlock,
  seTextHeading,
  thematicBreak,
  listItem,
  indentedCodeBlock,
  tableHead,
  tableBody,
  customBlock
], reFrontMatter = /^(-{3}|\+{3}|;{3})$/, frontMatter$1 = function(lr, ar) {
  var cr = lr.currentLine, ur = lr.lineNumber, fr = lr.indented;
  if (ur === 1 && !fr && ar.type === "document" && reFrontMatter.test(cr)) {
    lr.closeUnmatchedBlocks();
    var dr = lr.addChild("frontMatter", lr.nextNonspace);
    return dr.stringContent = cr, lr.advanceNextNonspace(), lr.advanceOffset(cr.length, !1), 2;
  }
  return 0;
}, frontMatter = {
  continue: function(lr, ar) {
    var cr = lr.currentLine, ur = cr.match(reFrontMatter);
    return ar.type === "frontMatter" && ur ? (ar.stringContent += cr, lr.lastLineLength = ur[0].length, lr.finalize(ar, lr.lineNumber), 2) : 0;
  },
  finalize: function(lr, ar) {
    ar.stringContent !== null && (ar.literal = ar.stringContent, ar.stringContent = null);
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, reHtmlBlockClose = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
], reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/, reLineEnding$1 = /\r\n|\n|\r/;
function document$2() {
  return createNode$1("document", [
    [1, 1],
    [0, 0]
  ]);
}
var defaultOptions$1 = {
  smart: !1,
  tagFilter: !1,
  extendedAutolinks: !1,
  disallowedHtmlBlockTags: [],
  referenceDefinition: !1,
  disallowDeepHeading: !1,
  customParser: null,
  frontMatter: !1
}, Parser = (
  /** @class */
  function() {
    function lr(ar) {
      this.options = __assign(__assign({}, defaultOptions$1), ar), this.doc = document$2(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (blockHandlers.frontMatter = frontMatter, blockStarts.unshift(frontMatter$1)), this.inlineParser = new InlineParser(this.options);
    }
    return lr.prototype.advanceOffset = function(ar, cr) {
      cr === void 0 && (cr = !1);
      for (var ur = this.currentLine, fr, dr, gr; ar > 0 && (gr = ur[this.offset]); )
        gr === "	" ? (fr = 4 - this.column % 4, cr ? (this.partiallyConsumedTab = fr > ar, dr = fr > ar ? ar : fr, this.column += dr, this.offset += this.partiallyConsumedTab ? 0 : 1, ar -= dr) : (this.partiallyConsumedTab = !1, this.column += fr, this.offset += 1, ar -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, ar -= 1);
    }, lr.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
    }, lr.prototype.findNextNonspace = function() {
      for (var ar = this.currentLine, cr = this.offset, ur = this.column, fr; (fr = ar.charAt(cr)) !== ""; )
        if (fr === " ")
          cr++, ur++;
        else if (fr === "	")
          cr++, ur += 4 - ur % 4;
        else
          break;
      this.blank = fr === `
` || fr === "\r" || fr === "", this.nextNonspace = cr, this.nextNonspaceColumn = ur, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= CODE_INDENT;
    }, lr.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var ar = 4 - this.column % 4;
        this.tip.stringContent += repeat(" ", ar);
      }
      this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
    }, lr.prototype.addChild = function(ar, cr) {
      for (; !blockHandlers[this.tip.type].canContain(ar); )
        this.finalize(this.tip, this.lineNumber - 1);
      var ur = cr + 1, fr = createNode$1(ar, [
        [this.lineNumber, ur],
        [0, 0]
      ]);
      return fr.stringContent = "", this.tip.appendChild(fr), this.tip = fr, fr;
    }, lr.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        for (; this.oldtip !== this.lastMatchedContainer; ) {
          var ar = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = ar;
        }
        this.allClosed = !0;
      }
    }, lr.prototype.finalize = function(ar, cr) {
      var ur = ar.parent;
      ar.open = !1, ar.sourcepos[1] = [cr, this.lastLineLength], blockHandlers[ar.type].finalize(this, ar), this.tip = ur;
    }, lr.prototype.processInlines = function(ar) {
      var cr, ur = this.options.customParser, fr = ar.walker();
      for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; cr = fr.next(); ) {
        var dr = cr.node, gr = cr.entering, mr = dr.type;
        ur && ur[mr] && ur[mr](dr, { entering: gr, options: this.options }), !gr && (mr === "paragraph" || mr === "heading" || mr === "tableCell" && !dr.ignored) && this.inlineParser.parse(dr);
      }
    }, lr.prototype.incorporateLine = function(ar) {
      var cr = this.doc;
      this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, ar.indexOf("\0") !== -1 && (ar = ar.replace(/\0/g, "�")), this.currentLine = ar;
      for (var ur = !0, fr; (fr = cr.lastChild) && fr.open; ) {
        switch (cr = fr, this.findNextNonspace(), blockHandlers[cr.type].continue(this, cr)) {
          case 0:
            break;
          case 1:
            ur = !1;
            break;
          case 2:
            this.lastLineLength = ar.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!ur) {
          cr = cr.parent;
          break;
        }
      }
      this.allClosed = cr === this.oldtip, this.lastMatchedContainer = cr;
      for (var dr = cr.type !== "paragraph" && blockHandlers[cr.type].acceptsLines, gr = blockStarts.length; !dr; ) {
        if (this.findNextNonspace(), cr.type !== "table" && cr.type !== "tableBody" && cr.type !== "paragraph" && !this.indented && !reMaybeSpecial.test(ar.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        for (var mr = 0; mr < gr; ) {
          var vr = blockStarts[mr](this, cr);
          if (vr === 1) {
            cr = this.tip;
            break;
          } else if (vr === 2) {
            cr = this.tip, dr = !0;
            break;
          } else
            mr++;
        }
        if (mr === gr) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
        this.addLine();
      else {
        this.closeUnmatchedBlocks(), this.blank && cr.lastChild && (cr.lastChild.lastLineBlank = !0);
        for (var yr = cr.type, kr = this.blank && !(yr === "blockQuote" || isCodeBlock(cr) && cr.isFenced || yr === "item" && !cr.firstChild && cr.sourcepos[0][0] === this.lineNumber), _r = cr; _r; )
          _r.lastLineBlank = kr, _r = _r.parent;
        blockHandlers[yr].acceptsLines ? (this.addLine(), isHtmlBlock(cr) && cr.htmlBlockType >= 1 && cr.htmlBlockType <= 5 && reHtmlBlockClose[cr.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = ar.length, this.finalize(cr, this.lineNumber))) : this.offset < ar.length && !this.blank && (cr = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
      }
      this.lastLineLength = ar.length;
    }, lr.prototype.parse = function(ar, cr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      var ur = ar.split(reLineEnding$1), fr = ur.length;
      this.lines = cr || ur, this.options.referenceDefinition && this.clearRefMaps(), ar.charCodeAt(ar.length - 1) === C_NEWLINE && (fr -= 1);
      for (var dr = 0; dr < fr; dr++)
        this.incorporateLine(ur[dr]);
      for (; this.tip; )
        this.finalize(this.tip, fr);
      return this.processInlines(this.doc), this.doc;
    }, lr.prototype.partialParseStart = function(ar, cr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = ar - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      for (var ur = cr.length, fr = 0; fr < ur; fr++)
        this.incorporateLine(cr[fr]);
      return this.doc;
    }, lr.prototype.partialParseExtends = function(ar) {
      for (var cr = 0; cr < ar.length; cr++)
        this.incorporateLine(ar[cr]);
    }, lr.prototype.partialParseFinish = function() {
      for (; this.tip; )
        this.finalize(this.tip, this.lineNumber);
      this.processInlines(this.doc);
    }, lr.prototype.setRefMaps = function(ar, cr, ur) {
      this.refMap = ar, this.refLinkCandidateMap = cr, this.refDefCandidateMap = ur;
    }, lr.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        clearObj(ar);
      });
    }, lr;
  }()
);
function comparePos(lr, ar) {
  return lr[0] < ar[0] ? 1 : lr[0] > ar[0] ? -1 : lr[1] < ar[1] ? 1 : lr[1] > ar[1] ? -1 : 0;
}
function compareRangeAndPos(lr, ar) {
  var cr = lr[0], ur = lr[1];
  return comparePos(ur, ar) === 1 ? 1 : comparePos(cr, ar) === -1 ? -1 : 0;
}
function removeNextUntil(lr, ar) {
  if (!(lr.parent !== ar.parent || lr === ar)) {
    for (var cr = lr.next; cr && cr !== ar; ) {
      for (var ur = cr.next, fr = 0, dr = ["parent", "prev", "next"]; fr < dr.length; fr++) {
        var gr = dr[fr];
        cr[gr] && (removeNodeById(cr[gr].id), cr[gr] = null);
      }
      cr = ur;
    }
    lr.next = ar.next, ar.next ? ar.next.prev = lr : lr.parent.lastChild = lr;
  }
}
function getChildNodes(lr) {
  for (var ar = [], cr = lr.firstChild; cr; )
    ar.push(cr), cr = cr.next;
  return ar;
}
function insertNodesBefore(lr, ar) {
  for (var cr = 0, ur = ar; cr < ur.length; cr++) {
    var fr = ur[cr];
    lr.insertBefore(fr);
  }
}
function prependChildNodes(lr, ar) {
  for (var cr = ar.length - 1; cr >= 0; cr -= 1)
    lr.prependChild(ar[cr]);
}
function updateNextLineNumbers(lr, ar) {
  if (!(!lr || !lr.parent || ar === 0)) {
    var cr = lr.parent.walker();
    cr.resumeAt(lr, !0);
    for (var ur; ur = cr.next(); ) {
      var fr = ur.node, dr = ur.entering;
      dr && (fr.sourcepos[0][0] += ar, fr.sourcepos[1][0] += ar);
    }
  }
}
function compareRangeAndLine(lr, ar) {
  var cr = lr[0], ur = lr[1];
  return ur[0] < ar ? 1 : cr[0] > ar ? -1 : 0;
}
function findChildNodeAtLine(lr, ar) {
  for (var cr = lr.firstChild; cr; ) {
    var ur = compareRangeAndLine(cr.sourcepos, ar);
    if (ur === 0)
      return cr;
    if (ur === -1)
      return cr.prev || cr;
    cr = cr.next;
  }
  return lr.lastChild;
}
function lastLeafNode(lr) {
  for (; lr.lastChild; )
    lr = lr.lastChild;
  return lr;
}
function sameLineTopAncestor(lr) {
  for (; lr.parent && lr.parent.type !== "document" && lr.parent.sourcepos[0][0] === lr.sourcepos[0][0]; )
    lr = lr.parent;
  return lr;
}
function findFirstNodeAtLine(lr, ar) {
  for (var cr = lr.firstChild, ur = null; cr; ) {
    var fr = compareRangeAndLine(cr.sourcepos, ar);
    if (fr === 0) {
      if (cr.sourcepos[0][0] === ar || !cr.firstChild)
        return cr;
      ur = cr, cr = cr.firstChild;
    } else {
      if (fr === -1)
        break;
      ur = cr, cr = cr.next;
    }
  }
  return ur ? sameLineTopAncestor(lastLeafNode(ur)) : null;
}
function findNodeAtPosition(lr, ar) {
  for (var cr = lr, ur = null; cr; ) {
    var fr = compareRangeAndPos(cr.sourcepos, ar);
    if (fr === 0)
      if (cr.firstChild)
        ur = cr, cr = cr.firstChild;
      else
        return cr;
    else {
      if (fr === -1)
        return ur;
      if (cr.next)
        cr = cr.next;
      else
        return ur;
    }
  }
  return cr;
}
function findNodeById(lr) {
  return getNodeById(lr) || null;
}
function invokeNextUntil(lr, ar, cr) {
  if (cr === void 0 && (cr = null), ar)
    for (var ur = ar.walker(); ar && ar !== cr; ) {
      lr(ar);
      var fr = ur.next();
      if (fr)
        ar = fr.node;
      else
        break;
    }
}
function isUnlinked(lr) {
  var ar = findNodeById(lr);
  if (!ar)
    return !0;
  for (; ar && ar.type !== "document"; ) {
    if (!ar.parent && !ar.prev && !ar.next)
      return !0;
    ar = ar.parent;
  }
  return !1;
}
var reLineEnding = /\r\n|\n|\r/;
function canBeContinuedListItem(lr) {
  var ar = lr.match(/^[ \t]+/);
  if (ar && (ar[0].length >= 2 || /\t/.test(ar[0])))
    return !0;
  var cr = ar ? lr.slice(ar.length) : lr;
  return reBulletListMarker.test(cr) || reOrderedListMarker.test(cr);
}
function canBeContinuedTableBody(lr) {
  return !isBlank(lr) && lr.indexOf("|") !== -1;
}
function createRefDefState(lr) {
  var ar = lr.id, cr = lr.title, ur = lr.sourcepos, fr = lr.dest;
  return {
    id: ar,
    title: cr,
    sourcepos: ur,
    unlinked: !1,
    destination: fr
  };
}
var ToastMark = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(cr != null && cr.referenceDefinition), this.parser = new Parser(cr), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, ar = ar || "", this.lineTexts = ar.split(reLineEnding), this.root = this.parser.parse(ar, this.lineTexts);
    }
    return lr.prototype.updateLineTexts = function(ar, cr, ur) {
      var fr, dr = ar[0], gr = ar[1], mr = cr[0], vr = cr[1], yr = ur.split(reLineEnding), kr = yr.length, _r = this.lineTexts[dr - 1], xr = this.lineTexts[mr - 1];
      yr[0] = _r.slice(0, gr - 1) + yr[0], yr[kr - 1] = yr[kr - 1] + xr.slice(vr - 1);
      var Sr = mr - dr + 1;
      return (fr = this.lineTexts).splice.apply(fr, __spreadArray([dr - 1, Sr], yr)), kr - Sr;
    }, lr.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = !0, this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
      for (var ar = this.lineTexts, cr = ar.length - 1; ar[cr] === ""; )
        cr -= 1;
      ar.length - 2 > cr && (cr += 1), this.root.sourcepos[1] = [cr + 1, ar[cr].length];
    }, lr.prototype.replaceRangeNodes = function(ar, cr, ur) {
      ar ? (insertNodesBefore(ar, ur), removeNextUntil(ar, cr), [ar.id, cr.id].forEach(function(fr) {
        return removeNodeById(fr);
      }), ar.unlink()) : cr ? (insertNodesBefore(cr, ur), removeNodeById(cr.id), cr.unlink()) : prependChildNodes(this.root, ur);
    }, lr.prototype.getNodeRange = function(ar, cr) {
      var ur = findChildNodeAtLine(this.root, ar[0]), fr = findChildNodeAtLine(this.root, cr[0]);
      return fr && fr.next && cr[0] + 1 === fr.next.sourcepos[0][0] && (fr = fr.next), [ur, fr];
    }, lr.prototype.trigger = function(ar, cr) {
      this.eventHandlerMap[ar].forEach(function(ur) {
        ur(cr);
      });
    }, lr.prototype.extendEndLine = function(ar) {
      for (; this.lineTexts[ar] === ""; )
        ar += 1;
      return ar;
    }, lr.prototype.parseRange = function(ar, cr, ur, fr) {
      ar && ar.prev && (isList(ar.prev) && canBeContinuedListItem(this.lineTexts[ur - 1]) || isTable(ar.prev) && canBeContinuedTableBody(this.lineTexts[ur - 1])) && (ar = ar.prev, ur = ar.sourcepos[0][0]);
      for (var dr = this.lineTexts.slice(ur - 1, fr), gr = this.parser.partialParseStart(ur, dr), mr = cr ? cr.next : this.root.firstChild, vr = gr.lastChild, yr = vr && isCodeBlock(vr) && vr.open, kr = vr && isCustomBlock(vr) && vr.open, _r = vr && isList(vr); (yr || kr) && mr || _r && mr && (mr.type === "list" || mr.sourcepos[0][1] >= 2); ) {
        var xr = this.extendEndLine(mr.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(fr, xr)), ar || (ar = cr), cr = mr, fr = xr, mr = mr.next;
      }
      this.parser.partialParseFinish();
      var Sr = getChildNodes(gr);
      return { newNodes: Sr, extStartNode: ar, extEndNode: cr };
    }, lr.prototype.getRemovedNodeRange = function(ar, cr) {
      return !ar || ar && isRefDef(ar) || cr && isRefDef(cr) ? null : {
        id: [ar.id, cr.id],
        line: [ar.sourcepos[0][0] - 1, cr.sourcepos[1][0] - 1]
      };
    }, lr.prototype.markDeletedRefMap = function(ar, cr) {
      var ur = this;
      if (!isEmptyObj(this.refMap)) {
        var fr = function(dr) {
          if (isRefDef(dr)) {
            var gr = ur.refMap[dr.label];
            gr && dr.id === gr.id && (gr.unlinked = !0);
          }
        };
        ar && invokeNextUntil(fr, ar.parent, cr), cr && invokeNextUntil(fr, cr);
      }
    }, lr.prototype.replaceWithNewRefDefState = function(ar) {
      var cr = this;
      if (!isEmptyObj(this.refMap)) {
        var ur = function(fr) {
          if (isRefDef(fr)) {
            var dr = fr.label, gr = cr.refMap[dr];
            (!gr || gr.unlinked) && (cr.refMap[dr] = createRefDefState(fr));
          }
        };
        ar.forEach(function(fr) {
          invokeNextUntil(ur, fr);
        });
      }
    }, lr.prototype.replaceWithRefDefCandidate = function() {
      var ar = this;
      isEmptyObj(this.refDefCandidateMap) || iterateObject(this.refDefCandidateMap, function(cr, ur) {
        var fr = ur.label, dr = ur.sourcepos, gr = ar.refMap[fr];
        (!gr || gr.unlinked || gr.sourcepos[0][0] > dr[0][0]) && (ar.refMap[fr] = createRefDefState(ur));
      });
    }, lr.prototype.getRangeWithRefDef = function(ar, cr, ur, fr, dr) {
      if (this.referenceDefinition && !isEmptyObj(this.refMap)) {
        var gr = findChildNodeAtLine(this.root, ar - 1), mr = findChildNodeAtLine(this.root, cr + 1);
        gr && isRefDef(gr) && gr !== ur && gr !== fr && (ur = gr, ar = ur.sourcepos[0][0]), mr && isRefDef(mr) && mr !== ur && mr !== fr && (fr = mr, cr = this.extendEndLine(fr.sourcepos[1][0] + dr));
      }
      return [ur, fr, ar, cr];
    }, lr.prototype.parse = function(ar, cr, ur) {
      ur === void 0 && (ur = 0);
      var fr = this.getNodeRange(ar, cr), dr = fr[0], gr = fr[1], mr = dr ? Math.min(dr.sourcepos[0][0], ar[0]) : ar[0], vr = this.extendEndLine((gr ? Math.max(gr.sourcepos[1][0], cr[0]) : cr[0]) + ur), yr = this.parseRange.apply(this, this.getRangeWithRefDef(mr, vr, dr, gr, ur)), kr = yr.newNodes, _r = yr.extStartNode, xr = yr.extEndNode, Sr = this.getRemovedNodeRange(_r, xr), Er = xr ? xr.next : this.root.firstChild;
      return this.referenceDefinition ? (this.markDeletedRefMap(_r, xr), this.replaceRangeNodes(_r, xr, kr), this.replaceWithNewRefDefState(kr)) : this.replaceRangeNodes(_r, xr, kr), { nodes: kr, removedNodeRange: Sr, nextNode: Er };
    }, lr.prototype.parseRefLink = function() {
      var ar = this, cr = [];
      return isEmptyObj(this.refMap) || iterateObject(this.refMap, function(ur, fr) {
        fr.unlinked && delete ar.refMap[ur], iterateObject(ar.refLinkCandidateMap, function(dr, gr) {
          var mr = gr.node, vr = gr.refLabel;
          vr === ur && cr.push(ar.parse(mr.sourcepos[0], mr.sourcepos[1]));
        });
      }), cr;
    }, lr.prototype.removeUnlinkedCandidate = function() {
      isEmptyObj(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        iterateObject(ar, function(cr) {
          isUnlinked(cr) && delete ar[cr];
        });
      });
    }, lr.prototype.editMarkdown = function(ar, cr, ur) {
      var fr = this.updateLineTexts(ar, cr, ur), dr = this.parse(ar, cr, fr), gr = omit(dr, "nextNode");
      updateNextLineNumbers(dr.nextNode, fr), this.updateRootNodeState();
      var mr = [gr];
      return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), mr = mr.concat(this.parseRefLink())), this.trigger("change", mr), mr;
    }, lr.prototype.getLineTexts = function() {
      return this.lineTexts;
    }, lr.prototype.getRootNode = function() {
      return this.root;
    }, lr.prototype.findNodeAtPosition = function(ar) {
      var cr = findNodeAtPosition(this.root, ar);
      return !cr || cr === this.root ? null : cr;
    }, lr.prototype.findFirstNodeAtLine = function(ar) {
      return findFirstNodeAtLine(this.root, ar);
    }, lr.prototype.on = function(ar, cr) {
      this.eventHandlerMap[ar].push(cr);
    }, lr.prototype.off = function(ar, cr) {
      var ur = this.eventHandlerMap[ar], fr = ur.indexOf(cr);
      ur.splice(fr, 1);
    }, lr.prototype.findNodeById = function(ar) {
      return findNodeById(ar);
    }, lr.prototype.removeAllNode = function() {
      removeAllNode();
    }, lr;
  }()
), disallowedTags = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
], reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join("|") + ")[^>]*>)", "ig");
function filterDisallowedTags(lr) {
  return reDisallowedTag.test(lr) ? lr.replace(reDisallowedTag, function(ar, cr) {
    return "&lt;" + cr;
  }) : lr;
}
var baseConvertors$1 = {
  heading: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "h" + lr.level,
      outerNewLine: !0
    };
  },
  text: function(lr) {
    return {
      type: "text",
      content: lr.literal
    };
  },
  softbreak: function(lr, ar) {
    var cr = ar.options;
    return {
      type: "html",
      content: cr.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: `<br />
`
    };
  },
  emph: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(lr, ar) {
    var cr, ur = ar.entering, fr = (cr = lr.parent) === null || cr === void 0 ? void 0 : cr.parent;
    return fr && fr.type === "list" && fr.listData.tight ? null : {
      type: ur ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: !0
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: !0,
      selfClose: !0
    };
  },
  blockQuote: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: !0,
      innerNewLine: !0
    };
  },
  list: function(lr, ar) {
    var cr = ar.entering, ur = lr.listData, fr = ur.type, dr = ur.start, gr = fr === "bullet" ? "ul" : "ol", mr = {};
    return gr === "ol" && dr !== null && dr !== 1 && (mr.start = dr.toString()), {
      type: cr ? "openTag" : "closeTag",
      tagName: gr,
      attributes: mr,
      outerNewLine: !0
    };
  },
  item: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  htmlInline: function(lr, ar) {
    var cr = ar.options, ur = cr.tagFilter ? filterDisallowedTags(lr.literal) : lr.literal;
    return { type: "html", content: ur };
  },
  htmlBlock: function(lr, ar) {
    var cr = ar.options, ur = cr.tagFilter ? filterDisallowedTags(lr.literal) : lr.literal;
    return cr.nodeId ? [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "html", content: ur },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ] : { type: "html", content: ur, outerNewLine: !0 };
  },
  code: function(lr) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(lr) {
    var ar = lr.info, cr = ar ? ar.split(/\s+/) : [], ur = [];
    return cr.length > 0 && cr[0].length > 0 && ur.push("language-" + escapeXml(cr[0])), [
      { type: "openTag", tagName: "pre", outerNewLine: !0 },
      { type: "openTag", tagName: "code", classNames: ur },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: !0 }
    ];
  },
  link: function(lr, ar) {
    var cr = ar.entering;
    if (cr) {
      var ur = lr, fr = ur.title, dr = ur.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: __assign({ href: escapeXml(dr) }, fr && { title: escapeXml(fr) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(lr, ar) {
    var cr = ar.getChildrenText, ur = ar.skipChildren, fr = lr, dr = fr.title, gr = fr.destination;
    return ur(), {
      type: "openTag",
      tagName: "img",
      selfClose: !0,
      attributes: __assign({ src: escapeXml(gr), alt: cr(lr) }, dr && { title: escapeXml(dr) })
    };
  },
  customBlock: function(lr, ar, cr) {
    var ur = lr.info.trim().toLowerCase(), fr = cr[ur];
    if (fr)
      try {
        return fr(lr, ar);
      } catch (dr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + ur + " block node was parsed in markdown renderer: " + dr);
      }
    return [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  frontMatter: function(lr) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: !0,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  customInline: function(lr, ar, cr) {
    var ur = lr, fr = ur.info, dr = ur.firstChild, gr = fr.trim().toLowerCase(), mr = cr[gr], vr = ar.entering;
    if (mr)
      try {
        return mr(lr, ar);
      } catch (yr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + gr + " inline node was parsed in markdown renderer: " + yr);
      }
    return vr ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + fr + (dr ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
}, gfmConvertors = {
  strike: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(lr, ar) {
    var cr = ar.entering, ur = lr.listData, fr = ur.checked, dr = ur.task;
    if (cr) {
      var gr = {
        type: "openTag",
        tagName: "li",
        outerNewLine: !0
      };
      return dr ? [
        gr,
        {
          type: "openTag",
          tagName: "input",
          selfClose: !0,
          attributes: __assign(__assign({}, fr && { checked: "" }), { disabled: "", type: "checkbox" })
        },
        {
          type: "text",
          content: " "
        }
      ] : gr;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  table: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: !0
    };
  },
  tableHead: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: !0
    };
  },
  tableBody: function(lr, ar) {
    var cr = ar.entering;
    return {
      type: cr ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: !0
    };
  },
  tableRow: function(lr, ar) {
    var cr = ar.entering;
    if (cr)
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: !0
      };
    var ur = [];
    if (lr.lastChild)
      for (var fr = lr.parent.parent.columns.length, dr = lr.lastChild.endIdx, gr = dr + 1; gr < fr; gr += 1)
        ur.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: !0
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: !0
        });
    return ur.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: !0
    }), ur;
  },
  tableCell: function(lr, ar) {
    var cr = ar.entering;
    if (lr.ignored)
      return {
        type: "text",
        content: ""
      };
    var ur = lr.parent.parent, fr = ur.type === "tableHead" ? "th" : "td", dr = ur.parent, gr = dr.columns[lr.startIdx], mr = gr != null && gr.align ? { align: gr.align } : null;
    return cr ? __assign({ type: "openTag", tagName: fr, outerNewLine: !0 }, mr && { attributes: mr }) : {
      type: "closeTag",
      tagName: fr,
      outerNewLine: !0
    };
  }
}, defaultOptions = {
  softbreak: `
`,
  gfm: !1,
  tagFilter: !1,
  nodeId: !1
};
function getChildrenText(lr) {
  for (var ar = [], cr = lr.walker(), ur = null; ur = cr.next(); ) {
    var fr = ur.node;
    fr.type === "text" && ar.push(fr.literal);
  }
  return ar.join("");
}
var Renderer = (
  /** @class */
  function() {
    function lr(ar) {
      this.buffer = [], this.options = __assign(__assign({}, defaultOptions), ar), this.convertors = this.createConvertors(), delete this.options.convertors;
    }
    return lr.prototype.createConvertors = function() {
      var ar = __assign({}, baseConvertors$1);
      if (this.options.gfm && (ar = __assign(__assign({}, ar), gfmConvertors)), this.options.convertors) {
        var cr = this.options.convertors, ur = Object.keys(cr), fr = __assign(__assign({}, baseConvertors$1), gfmConvertors);
        ur.forEach(function(dr) {
          var gr = ar[dr], mr = cr[dr], vr = Object.keys(fr).indexOf(dr) === -1 ? dr.toLowerCase() : dr;
          gr ? ar[vr] = function(yr, kr, _r) {
            return kr.origin = function() {
              return gr(yr, kr, _r);
            }, mr(yr, kr);
          } : ar[vr] = mr;
        });
      }
      return ar;
    }, lr.prototype.getConvertors = function() {
      return this.convertors;
    }, lr.prototype.getOptions = function() {
      return this.options;
    }, lr.prototype.render = function(ar) {
      var cr = this;
      this.buffer = [];
      for (var ur = ar.walker(), fr = null, dr = function() {
        var mr = fr.node, vr = fr.entering, yr = gr.convertors[mr.type];
        if (!yr)
          return "continue";
        var kr = !1, _r = {
          entering: vr,
          leaf: !isContainer$1(mr),
          options: gr.options,
          getChildrenText,
          skipChildren: function() {
            kr = !0;
          }
        }, xr = isCustomBlock(mr) || isCustomInline(mr) ? yr(mr, _r, gr.convertors) : yr(mr, _r);
        if (xr) {
          var Sr = Array.isArray(xr) ? xr : [xr];
          Sr.forEach(function(Er, Cr) {
            Er.type === "openTag" && cr.options.nodeId && Cr === 0 && (Er.attributes || (Er.attributes = {}), Er.attributes["data-nodeid"] = String(mr.id)), cr.renderHTMLNode(Er);
          }), kr && (ur.resumeAt(mr, !1), ur.next());
        }
      }, gr = this; fr = ur.next(); )
        dr();
      return this.addNewLine(), this.buffer.join("");
    }, lr.prototype.renderHTMLNode = function(ar) {
      switch (ar.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(ar);
          break;
        case "text":
          this.renderTextNode(ar);
          break;
        case "html":
          this.renderRawHtmlNode(ar);
          break;
      }
    }, lr.prototype.generateOpenTagString = function(ar) {
      var cr = this, ur = ar.tagName, fr = ar.classNames, dr = ar.attributes;
      this.buffer.push("<" + ur), fr && fr.length > 0 && this.buffer.push(' class="' + fr.join(" ") + '"'), dr && Object.keys(dr).forEach(function(gr) {
        var mr = dr[gr];
        cr.buffer.push(" " + gr + '="' + mr + '"');
      }), ar.selfClose && this.buffer.push(" /"), this.buffer.push(">");
    }, lr.prototype.generateCloseTagString = function(ar) {
      var cr = ar.tagName;
      this.buffer.push("</" + cr + ">");
    }, lr.prototype.addNewLine = function() {
      this.buffer.length && last(last(this.buffer)) !== `
` && this.buffer.push(`
`);
    }, lr.prototype.addOuterNewLine = function(ar) {
      ar.outerNewLine && this.addNewLine();
    }, lr.prototype.addInnerNewLine = function(ar) {
      ar.innerNewLine && this.addNewLine();
    }, lr.prototype.renderTextNode = function(ar) {
      this.buffer.push(escapeXml(ar.content));
    }, lr.prototype.renderRawHtmlNode = function(ar) {
      this.addOuterNewLine(ar), this.buffer.push(ar.content), this.addOuterNewLine(ar);
    }, lr.prototype.renderElementNode = function(ar) {
      ar.type === "openTag" ? (this.addOuterNewLine(ar), this.generateOpenTagString(ar), ar.selfClose ? this.addOuterNewLine(ar) : this.addInnerNewLine(ar)) : (this.addInnerNewLine(ar), this.generateCloseTagString(ar), this.addOuterNewLine(ar));
    }, lr;
  }()
);
/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
function _toConsumableArray(lr) {
  if (Array.isArray(lr)) {
    for (var ar = 0, cr = Array(lr.length); ar < lr.length; ar++)
      cr[ar] = lr[ar];
    return cr;
  } else
    return Array.from(lr);
}
var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf$1 = Object.setPrototypeOf, isFrozen$1 = Object.isFrozen, getPrototypeOf$1 = Object.getPrototypeOf, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, freeze$1 = Object.freeze, seal$1 = Object.seal, create$1 = Object.create, _ref = typeof Reflect != "undefined" && Reflect, apply$1 = _ref.apply, construct$1 = _ref.construct;
apply$1 || (apply$1 = function(ar, cr, ur) {
  return ar.apply(cr, ur);
});
freeze$1 || (freeze$1 = function(ar) {
  return ar;
});
seal$1 || (seal$1 = function(ar) {
  return ar;
});
construct$1 || (construct$1 = function(ar, cr) {
  return new (Function.prototype.bind.apply(ar, [null].concat(_toConsumableArray(cr))))();
});
var arrayForEach$1 = unapply$1(Array.prototype.forEach), arrayPop$1 = unapply$1(Array.prototype.pop), arrayPush$1 = unapply$1(Array.prototype.push), stringToLowerCase$1 = unapply$1(String.prototype.toLowerCase), stringMatch$1 = unapply$1(String.prototype.match), stringReplace$1 = unapply$1(String.prototype.replace), stringIndexOf$1 = unapply$1(String.prototype.indexOf), stringTrim$1 = unapply$1(String.prototype.trim), regExpTest$1 = unapply$1(RegExp.prototype.test), typeErrorCreate$1 = unconstruct$1(TypeError);
function unapply$1(lr) {
  return function(ar) {
    for (var cr = arguments.length, ur = Array(cr > 1 ? cr - 1 : 0), fr = 1; fr < cr; fr++)
      ur[fr - 1] = arguments[fr];
    return apply$1(lr, ar, ur);
  };
}
function unconstruct$1(lr) {
  return function() {
    for (var ar = arguments.length, cr = Array(ar), ur = 0; ur < ar; ur++)
      cr[ur] = arguments[ur];
    return construct$1(lr, cr);
  };
}
function addToSet$1(lr, ar) {
  setPrototypeOf$1 && setPrototypeOf$1(lr, null);
  for (var cr = ar.length; cr--; ) {
    var ur = ar[cr];
    if (typeof ur == "string") {
      var fr = stringToLowerCase$1(ur);
      fr !== ur && (isFrozen$1(ar) || (ar[cr] = fr), ur = fr);
    }
    lr[ur] = !0;
  }
  return lr;
}
function clone$1(lr) {
  var ar = create$1(null), cr = void 0;
  for (cr in lr)
    apply$1(hasOwnProperty, lr, [cr]) && (ar[cr] = lr[cr]);
  return ar;
}
function lookupGetter$1(lr, ar) {
  for (; lr !== null; ) {
    var cr = getOwnPropertyDescriptor$1(lr, ar);
    if (cr) {
      if (cr.get)
        return unapply$1(cr.get);
      if (typeof cr.value == "function")
        return unapply$1(cr.value);
    }
    lr = getPrototypeOf$1(lr);
  }
  function ur(fr) {
    return console.warn("fallback value for", fr), null;
  }
  return ur;
}
var html$2$1 = freeze$1(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$2 = freeze$1(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters$1 = freeze$1(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed$1 = freeze$1(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$2 = freeze$1(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), mathMlDisallowed$1 = freeze$1(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$2 = freeze$1(["#text"]), html$1$1 = freeze$1(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg$1$1 = freeze$1(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl$1$1 = freeze$1(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml$1 = freeze$1(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR$1 = seal$1(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ERB_EXPR$1 = seal$1(/<%[\s\S]*|[\s\S]*%>/gm), DATA_ATTR$1 = seal$1(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR$1 = seal$1(/^aria-[\-\w]+$/), IS_ALLOWED_URI$1 = seal$1(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA$1 = seal$1(/^(?:\w+script|data):/i), ATTR_WHITESPACE$1 = seal$1(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(lr) {
  return typeof lr;
} : function(lr) {
  return lr && typeof Symbol == "function" && lr.constructor === Symbol && lr !== Symbol.prototype ? "symbol" : typeof lr;
};
function _toConsumableArray$1(lr) {
  if (Array.isArray(lr)) {
    for (var ar = 0, cr = Array(lr.length); ar < lr.length; ar++)
      cr[ar] = lr[ar];
    return cr;
  } else
    return Array.from(lr);
}
var getGlobal$1 = function lr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy$1 = function lr(ar, cr) {
  if ((typeof ar == "undefined" ? "undefined" : _typeof(ar)) !== "object" || typeof ar.createPolicy != "function")
    return null;
  var ur = null, fr = "data-tt-policy-suffix";
  cr.currentScript && cr.currentScript.hasAttribute(fr) && (ur = cr.currentScript.getAttribute(fr));
  var dr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(dr, {
      createHTML: function(mr) {
        return mr;
      }
    });
  } catch (gr) {
    return console.warn("TrustedTypes policy " + dr + " could not be created."), null;
  }
};
function createDOMPurify$1() {
  var lr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal$1(), ar = function($i) {
    return createDOMPurify$1($i);
  };
  if (ar.version = "2.3.3", ar.removed = [], !lr || !lr.document || lr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  var cr = lr.document, ur = lr.document, fr = lr.DocumentFragment, dr = lr.HTMLTemplateElement, gr = lr.Node, mr = lr.Element, vr = lr.NodeFilter, yr = lr.NamedNodeMap, kr = yr === void 0 ? lr.NamedNodeMap || lr.MozNamedAttrMap : yr, _r = lr.Text, xr = lr.Comment, Sr = lr.DOMParser, Er = lr.trustedTypes, Cr = mr.prototype, Tr = lookupGetter$1(Cr, "cloneNode"), Ar = lookupGetter$1(Cr, "nextSibling"), Ir = lookupGetter$1(Cr, "childNodes"), Mr = lookupGetter$1(Cr, "parentNode");
  if (typeof dr == "function") {
    var Hr = ur.createElement("template");
    Hr.content && Hr.content.ownerDocument && (ur = Hr.content.ownerDocument);
  }
  var Br = _createTrustedTypesPolicy$1(Er, cr), zr = Br && Ua ? Br.createHTML("") : "", Gr = ur, Xr = Gr.implementation, Jr = Gr.createNodeIterator, li = Gr.createDocumentFragment, Qr = Gr.getElementsByTagName, ei = cr.importNode, ui = {};
  try {
    ui = clone$1(ur).documentMode ? ur.documentMode : {};
  } catch (wa) {
  }
  var Ai = {};
  ar.isSupported = typeof Mr == "function" && Xr && typeof Xr.createHTMLDocument != "undefined" && ui !== 9;
  var fi = MUSTACHE_EXPR$1, gi = ERB_EXPR$1, Ci = DATA_ATTR$1, mi = ARIA_ATTR$1, vi = IS_SCRIPT_OR_DATA$1, Ri = ATTR_WHITESPACE$1, di = IS_ALLOWED_URI$1, Ti = null, qi = addToSet$1({}, [].concat(_toConsumableArray$1(html$2$1), _toConsumableArray$1(svg$2), _toConsumableArray$1(svgFilters$1), _toConsumableArray$1(mathMl$2), _toConsumableArray$1(text$2))), ki = null, Ji = addToSet$1({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1$1), _toConsumableArray$1(mathMl$1$1), _toConsumableArray$1(xml$1))), Bi = null, Ni = null, Mi = !0, bi = !0, Ei = !1, Si = !1, Vi = !1, Di = !1, sa = !1, ra = !1, fa = !1, ba = !0, Ua = !1, Va = !0, Ma = !0, Fi = !1, na = {}, Gi = null, Ca = addToSet$1({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), $a = null, no = addToSet$1({}, ["audio", "video", "img", "source", "image", "track"]), ga = null, pa = addToSet$1({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Sa = "http://www.w3.org/1998/Math/MathML", Na = "http://www.w3.org/2000/svg", Oa = "http://www.w3.org/1999/xhtml", Ja = Oa, za = !1, Ia = void 0, Yi = ["application/xhtml+xml", "text/html"], La = "text/html", Ka = void 0, Qa = null, Hi = ur.createElement("form"), da = function($i) {
    Qa && Qa === $i || ((!$i || (typeof $i == "undefined" ? "undefined" : _typeof($i)) !== "object") && ($i = {}), $i = clone$1($i), Ti = "ALLOWED_TAGS" in $i ? addToSet$1({}, $i.ALLOWED_TAGS) : qi, ki = "ALLOWED_ATTR" in $i ? addToSet$1({}, $i.ALLOWED_ATTR) : Ji, ga = "ADD_URI_SAFE_ATTR" in $i ? addToSet$1(clone$1(pa), $i.ADD_URI_SAFE_ATTR) : pa, $a = "ADD_DATA_URI_TAGS" in $i ? addToSet$1(clone$1(no), $i.ADD_DATA_URI_TAGS) : no, Gi = "FORBID_CONTENTS" in $i ? addToSet$1({}, $i.FORBID_CONTENTS) : Ca, Bi = "FORBID_TAGS" in $i ? addToSet$1({}, $i.FORBID_TAGS) : {}, Ni = "FORBID_ATTR" in $i ? addToSet$1({}, $i.FORBID_ATTR) : {}, na = "USE_PROFILES" in $i ? $i.USE_PROFILES : !1, Mi = $i.ALLOW_ARIA_ATTR !== !1, bi = $i.ALLOW_DATA_ATTR !== !1, Ei = $i.ALLOW_UNKNOWN_PROTOCOLS || !1, Si = $i.SAFE_FOR_TEMPLATES || !1, Vi = $i.WHOLE_DOCUMENT || !1, ra = $i.RETURN_DOM || !1, fa = $i.RETURN_DOM_FRAGMENT || !1, ba = $i.RETURN_DOM_IMPORT !== !1, Ua = $i.RETURN_TRUSTED_TYPE || !1, sa = $i.FORCE_BODY || !1, Va = $i.SANITIZE_DOM !== !1, Ma = $i.KEEP_CONTENT !== !1, Fi = $i.IN_PLACE || !1, di = $i.ALLOWED_URI_REGEXP || di, Ja = $i.NAMESPACE || Oa, Ia = // eslint-disable-next-line unicorn/prefer-includes
    Yi.indexOf($i.PARSER_MEDIA_TYPE) === -1 ? Ia = La : Ia = $i.PARSER_MEDIA_TYPE, Ka = Ia === "application/xhtml+xml" ? function(ca) {
      return ca;
    } : stringToLowerCase$1, Si && (bi = !1), fa && (ra = !0), na && (Ti = addToSet$1({}, [].concat(_toConsumableArray$1(text$2))), ki = [], na.html === !0 && (addToSet$1(Ti, html$2$1), addToSet$1(ki, html$1$1)), na.svg === !0 && (addToSet$1(Ti, svg$2), addToSet$1(ki, svg$1$1), addToSet$1(ki, xml$1)), na.svgFilters === !0 && (addToSet$1(Ti, svgFilters$1), addToSet$1(ki, svg$1$1), addToSet$1(ki, xml$1)), na.mathMl === !0 && (addToSet$1(Ti, mathMl$2), addToSet$1(ki, mathMl$1$1), addToSet$1(ki, xml$1))), $i.ADD_TAGS && (Ti === qi && (Ti = clone$1(Ti)), addToSet$1(Ti, $i.ADD_TAGS)), $i.ADD_ATTR && (ki === Ji && (ki = clone$1(ki)), addToSet$1(ki, $i.ADD_ATTR)), $i.ADD_URI_SAFE_ATTR && addToSet$1(ga, $i.ADD_URI_SAFE_ATTR), $i.FORBID_CONTENTS && (Gi === Ca && (Gi = clone$1(Gi)), addToSet$1(Gi, $i.FORBID_CONTENTS)), Ma && (Ti["#text"] = !0), Vi && addToSet$1(Ti, ["html", "head", "body"]), Ti.table && (addToSet$1(Ti, ["tbody"]), delete Bi.tbody), freeze$1 && freeze$1($i), Qa = $i);
  }, aa = addToSet$1({}, ["mi", "mo", "mn", "ms", "mtext"]), oa = addToSet$1({}, ["foreignobject", "desc", "title", "annotation-xml"]), ja = addToSet$1({}, svg$2);
  addToSet$1(ja, svgFilters$1), addToSet$1(ja, svgDisallowed$1);
  var Ga = addToSet$1({}, mathMl$2);
  addToSet$1(Ga, mathMlDisallowed$1);
  var xa = function($i) {
    var ca = Mr($i);
    (!ca || !ca.tagName) && (ca = {
      namespaceURI: Oa,
      tagName: "template"
    });
    var ci = stringToLowerCase$1($i.tagName), ti = stringToLowerCase$1(ca.tagName);
    if ($i.namespaceURI === Na)
      return ca.namespaceURI === Oa ? ci === "svg" : ca.namespaceURI === Sa ? ci === "svg" && (ti === "annotation-xml" || aa[ti]) : !!ja[ci];
    if ($i.namespaceURI === Sa)
      return ca.namespaceURI === Oa ? ci === "math" : ca.namespaceURI === Na ? ci === "math" && oa[ti] : !!Ga[ci];
    if ($i.namespaceURI === Oa) {
      if (ca.namespaceURI === Na && !oa[ti] || ca.namespaceURI === Sa && !aa[ti])
        return !1;
      var Ur = addToSet$1({}, ["title", "style", "font", "a", "script"]);
      return !Ga[ci] && (Ur[ci] || !ja[ci]);
    }
    return !1;
  }, qa = function($i) {
    arrayPush$1(ar.removed, { element: $i });
    try {
      $i.parentNode.removeChild($i);
    } catch (ca) {
      try {
        $i.outerHTML = zr;
      } catch (ci) {
        $i.remove();
      }
    }
  }, Ya = function($i, ca) {
    try {
      arrayPush$1(ar.removed, {
        attribute: ca.getAttributeNode($i),
        from: ca
      });
    } catch (ci) {
      arrayPush$1(ar.removed, {
        attribute: null,
        from: ca
      });
    }
    if (ca.removeAttribute($i), $i === "is" && !ki[$i])
      if (ra || fa)
        try {
          qa(ca);
        } catch (ci) {
        }
      else
        try {
          ca.setAttribute($i, "");
        } catch (ci) {
        }
  }, Za = function($i) {
    var ca = void 0, ci = void 0;
    if (sa)
      $i = "<remove></remove>" + $i;
    else {
      var ti = stringMatch$1($i, /^[\r\n\t ]+/);
      ci = ti && ti[0];
    }
    Ia === "application/xhtml+xml" && ($i = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + $i + "</body></html>");
    var Ur = Br ? Br.createHTML($i) : $i;
    if (Ja === Oa)
      try {
        ca = new Sr().parseFromString(Ur, Ia);
      } catch (Yr) {
      }
    if (!ca || !ca.documentElement) {
      ca = Xr.createDocument(Ja, "template", null);
      try {
        ca.documentElement.innerHTML = za ? "" : Ur;
      } catch (Yr) {
      }
    }
    var qr = ca.body || ca.documentElement;
    return $i && ci && qr.insertBefore(ur.createTextNode(ci), qr.childNodes[0] || null), Ja === Oa ? Qr.call(ca, Vi ? "html" : "body")[0] : Vi ? ca.documentElement : qr;
  }, ko = function($i) {
    return Jr.call($i.ownerDocument || $i, $i, vr.SHOW_ELEMENT | vr.SHOW_COMMENT | vr.SHOW_TEXT, null, !1);
  }, lo = function($i) {
    return $i instanceof _r || $i instanceof xr ? !1 : typeof $i.nodeName != "string" || typeof $i.textContent != "string" || typeof $i.removeChild != "function" || !($i.attributes instanceof kr) || typeof $i.removeAttribute != "function" || typeof $i.setAttribute != "function" || typeof $i.namespaceURI != "string" || typeof $i.insertBefore != "function";
  }, so = function($i) {
    return (typeof gr == "undefined" ? "undefined" : _typeof(gr)) === "object" ? $i instanceof gr : $i && (typeof $i == "undefined" ? "undefined" : _typeof($i)) === "object" && typeof $i.nodeType == "number" && typeof $i.nodeName == "string";
  }, ho = function($i, ca, ci) {
    Ai[$i] && arrayForEach$1(Ai[$i], function(ti) {
      ti.call(ar, ca, ci, Qa);
    });
  }, Ro = function($i) {
    var ca = void 0;
    if (ho("beforeSanitizeElements", $i, null), lo($i) || stringMatch$1($i.nodeName, /[\u0080-\uFFFF]/))
      return qa($i), !0;
    var ci = Ka($i.nodeName);
    if (ho("uponSanitizeElement", $i, {
      tagName: ci,
      allowedTags: Ti
    }), !so($i.firstElementChild) && (!so($i.content) || !so($i.content.firstElementChild)) && regExpTest$1(/<[/\w]/g, $i.innerHTML) && regExpTest$1(/<[/\w]/g, $i.textContent) || ci === "select" && regExpTest$1(/<template/i, $i.innerHTML))
      return qa($i), !0;
    if (!Ti[ci] || Bi[ci]) {
      if (Ma && !Gi[ci]) {
        var ti = Mr($i) || $i.parentNode, Ur = Ir($i) || $i.childNodes;
        if (Ur && ti)
          for (var qr = Ur.length, Yr = qr - 1; Yr >= 0; --Yr)
            ti.insertBefore(Tr(Ur[Yr], !0), Ar($i));
      }
      return qa($i), !0;
    }
    return $i instanceof mr && !xa($i) || (ci === "noscript" || ci === "noembed") && regExpTest$1(/<\/no(script|embed)/i, $i.innerHTML) ? (qa($i), !0) : (Si && $i.nodeType === 3 && (ca = $i.textContent, ca = stringReplace$1(ca, fi, " "), ca = stringReplace$1(ca, gi, " "), $i.textContent !== ca && (arrayPush$1(ar.removed, { element: $i.cloneNode() }), $i.textContent = ca)), ho("afterSanitizeElements", $i, null), !1);
  }, Mo = function($i, ca, ci) {
    if (Va && (ca === "id" || ca === "name") && (ci in ur || ci in Hi))
      return !1;
    if (!(bi && !Ni[ca] && regExpTest$1(Ci, ca))) {
      if (!(Mi && regExpTest$1(mi, ca))) {
        if (!ki[ca] || Ni[ca])
          return !1;
        if (!ga[ca]) {
          if (!regExpTest$1(di, stringReplace$1(ci, Ri, ""))) {
            if (!((ca === "src" || ca === "xlink:href" || ca === "href") && $i !== "script" && stringIndexOf$1(ci, "data:") === 0 && $a[$i])) {
              if (!(Ei && !regExpTest$1(vi, stringReplace$1(ci, Ri, "")))) {
                if (ci)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Co = function($i) {
    var ca = void 0, ci = void 0, ti = void 0, Ur = void 0;
    ho("beforeSanitizeAttributes", $i, null);
    var qr = $i.attributes;
    if (qr) {
      var Yr = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: ki
      };
      for (Ur = qr.length; Ur--; ) {
        ca = qr[Ur];
        var si = ca, yi = si.name, Ii = si.namespaceURI;
        if (ci = stringTrim$1(ca.value), ti = Ka(yi), Yr.attrName = ti, Yr.attrValue = ci, Yr.keepAttr = !0, Yr.forceKeepAttr = void 0, ho("uponSanitizeAttribute", $i, Yr), ci = Yr.attrValue, !Yr.forceKeepAttr && (Ya(yi, $i), !!Yr.keepAttr)) {
          if (regExpTest$1(/\/>/i, ci)) {
            Ya(yi, $i);
            continue;
          }
          Si && (ci = stringReplace$1(ci, fi, " "), ci = stringReplace$1(ci, gi, " "));
          var Ki = Ka($i.nodeName);
          if (Mo(Ki, ti, ci))
            try {
              Ii ? $i.setAttributeNS(Ii, yi, ci) : $i.setAttribute(yi, ci), arrayPop$1(ar.removed);
            } catch (ta) {
            }
        }
      }
      ho("afterSanitizeAttributes", $i, null);
    }
  }, uo = function wa($i) {
    var ca = void 0, ci = ko($i);
    for (ho("beforeSanitizeShadowDOM", $i, null); ca = ci.nextNode(); )
      ho("uponSanitizeShadowNode", ca, null), !Ro(ca) && (ca.content instanceof fr && wa(ca.content), Co(ca));
    ho("afterSanitizeShadowDOM", $i, null);
  };
  return ar.sanitize = function(wa, $i) {
    var ca = void 0, ci = void 0, ti = void 0, Ur = void 0, qr = void 0;
    if (za = !wa, za && (wa = "<!-->"), typeof wa != "string" && !so(wa)) {
      if (typeof wa.toString != "function")
        throw typeErrorCreate$1("toString is not a function");
      if (wa = wa.toString(), typeof wa != "string")
        throw typeErrorCreate$1("dirty is not a string, aborting");
    }
    if (!ar.isSupported) {
      if (_typeof(lr.toStaticHTML) === "object" || typeof lr.toStaticHTML == "function") {
        if (typeof wa == "string")
          return lr.toStaticHTML(wa);
        if (so(wa))
          return lr.toStaticHTML(wa.outerHTML);
      }
      return wa;
    }
    if (Di || da($i), ar.removed = [], typeof wa == "string" && (Fi = !1), !Fi)
      if (wa instanceof gr)
        ca = Za("<!---->"), ci = ca.ownerDocument.importNode(wa, !0), ci.nodeType === 1 && ci.nodeName === "BODY" || ci.nodeName === "HTML" ? ca = ci : ca.appendChild(ci);
      else {
        if (!ra && !Si && !Vi && // eslint-disable-next-line unicorn/prefer-includes
        wa.indexOf("<") === -1)
          return Br && Ua ? Br.createHTML(wa) : wa;
        if (ca = Za(wa), !ca)
          return ra ? null : zr;
      }
    ca && sa && qa(ca.firstChild);
    for (var Yr = ko(Fi ? wa : ca); ti = Yr.nextNode(); )
      ti.nodeType === 3 && ti === Ur || Ro(ti) || (ti.content instanceof fr && uo(ti.content), Co(ti), Ur = ti);
    if (Ur = null, Fi)
      return wa;
    if (ra) {
      if (fa)
        for (qr = li.call(ca.ownerDocument); ca.firstChild; )
          qr.appendChild(ca.firstChild);
      else
        qr = ca;
      return ba && (qr = ei.call(cr, qr, !0)), qr;
    }
    var si = Vi ? ca.outerHTML : ca.innerHTML;
    return Si && (si = stringReplace$1(si, fi, " "), si = stringReplace$1(si, gi, " ")), Br && Ua ? Br.createHTML(si) : si;
  }, ar.setConfig = function(wa) {
    da(wa), Di = !0;
  }, ar.clearConfig = function() {
    Qa = null, Di = !1;
  }, ar.isValidAttribute = function(wa, $i, ca) {
    Qa || da({});
    var ci = Ka(wa), ti = Ka($i);
    return Mo(ci, ti, ca);
  }, ar.addHook = function(wa, $i) {
    typeof $i == "function" && (Ai[wa] = Ai[wa] || [], arrayPush$1(Ai[wa], $i));
  }, ar.removeHook = function(wa) {
    Ai[wa] && arrayPop$1(Ai[wa]);
  }, ar.removeHooks = function(wa) {
    Ai[wa] && (Ai[wa] = []);
  }, ar.removeAllHooks = function() {
    Ai = {};
  }, ar;
}
var purify$1 = createDOMPurify$1(), CAN_BE_WHITE_TAG_LIST = ["iframe", "embed"], whiteTagList = [];
function registerTagWhitelistIfPossible(lr) {
  includes(CAN_BE_WHITE_TAG_LIST, lr) && whiteTagList.push(lr.toLowerCase());
}
function sanitizeHTML(lr, ar) {
  return purify$1.sanitize(lr, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, ar));
}
function getChildrenHTML(lr, ar) {
  return lr.literal.replace(new RegExp("(<\\s*" + ar + "[^>]*>)|(</" + ar + "\\s*[>])", "ig"), "").trim();
}
function getHTMLAttrsByHTMLString(lr) {
  lr = lr.match(reHTMLTag)[0];
  var ar = lr.match(new RegExp(ATTRIBUTE$1, "g"));
  return ar ? ar.reduce(function(cr, ur) {
    var fr = ur.trim().split("="), dr = fr[0], gr = fr.slice(1);
    return gr.length && (cr[dr] = gr.join("=").replace(/'|"/g, "").trim()), cr;
  }, {}) : {};
}
function getHTMLAttrs(lr) {
  return toArray_1(lr.attributes).reduce(function(ar, cr) {
    return ar[cr.nodeName] = cr.nodeValue, ar;
  }, {});
}
function sanitizeDOM(lr, ar, cr, ur) {
  var fr = ur.getToDOMNode(ar)(lr), dr = cr(fr.outerHTML), gr = document.createElement("div");
  gr.innerHTML = dr, fr = gr.firstChild;
  var mr = getHTMLAttrs(fr);
  return { dom: fr, htmlAttrs: mr };
}
var schemaFactory = {
  htmlBlock: function(lr, ar, cr) {
    return {
      atom: !0,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: !0 }
      },
      parseDOM: [
        {
          tag: lr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur),
              childrenHTML: ur.innerHTML
            };
          }
        }
      ],
      toDOM: function(ur) {
        var fr = sanitizeDOM(ur, lr, ar, cr), dr = fr.dom, gr = fr.htmlAttrs;
        return gr.class = gr.class ? gr.class + " html-block" : "html-block", __spreadArray$1([lr, gr], toArray_1(dr.childNodes));
      }
    };
  },
  htmlInline: function(lr, ar, cr) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: !0 }
      },
      parseDOM: [
        {
          tag: lr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur)
            };
          }
        }
      ],
      toDOM: function(ur) {
        var fr = sanitizeDOM(ur, lr, ar, cr).htmlAttrs;
        return [lr, fr, 0];
      }
    };
  }
};
function createHTMLSchemaMap(lr, ar, cr) {
  var ur = { nodes: {}, marks: {} };
  return ["htmlBlock", "htmlInline"].forEach(function(fr) {
    lr[fr] && Object.keys(lr[fr]).forEach(function(dr) {
      var gr = fr === "htmlBlock" ? "nodes" : "marks";
      registerTagWhitelistIfPossible(dr), ur[gr][dr] = schemaFactory[fr](dr, ar, cr);
    });
  }), ur;
}
var reCloseTag = /^\s*<\s*\//, baseConvertors = {
  paragraph: function(lr, ar) {
    var cr = ar.entering, ur = ar.origin, fr = ar.options;
    return fr.nodeId ? {
      type: cr ? "openTag" : "closeTag",
      outerNewLine: !0,
      tagName: "p"
    } : ur();
  },
  softbreak: function(lr) {
    var ar = lr.prev && lr.prev.type === "htmlInline", cr = ar && /<br ?\/?>/.test(lr.prev.literal), ur = cr ? `
` : `<br>
`;
    return { type: "html", content: ur };
  },
  item: function(lr, ar) {
    var cr = ar.entering;
    if (cr) {
      var ur = {}, fr = [];
      return lr.listData.task && (ur["data-task"] = "", fr.push("task-list-item"), lr.listData.checked && (fr.push("checked"), ur["data-task-checked"] = "")), {
        type: "openTag",
        tagName: "li",
        classNames: fr,
        attributes: ur,
        outerNewLine: !0
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  code: function(lr) {
    var ar = { "data-backticks": String(lr.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes: ar },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(lr) {
    var ar = lr, cr = ar.fenceLength, ur = ar.info, fr = ur ? ur.split(/\s+/) : [], dr = [], gr = {};
    if (cr > 3 && (gr["data-backticks"] = cr), fr.length > 0 && fr[0].length > 0) {
      var mr = fr[0];
      dr.push("lang-" + mr), gr["data-language"] = mr;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: dr },
      { type: "openTag", tagName: "code", attributes: gr },
      { type: "text", content: lr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(lr, ar) {
    var cr = ar.origin, ur = ar.entering, fr = ar.skipChildren, dr = lr.info;
    if (dr.indexOf("widget") !== -1 && ur) {
      fr();
      var gr = getWidgetContent(lr), mr = widgetToDOM(dr, gr).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: mr },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return cr();
  }
};
function getHTMLRenderConvertors(lr, ar) {
  var cr = __assign$1({}, baseConvertors);
  return lr && (cr.link = function(ur, fr) {
    var dr = fr.entering, gr = fr.origin, mr = gr();
    return dr && (mr.attributes = __assign$1(__assign$1({}, mr.attributes), lr)), mr;
  }), ar && Object.keys(ar).forEach(function(ur) {
    var fr = cr[ur], dr = ar[ur];
    fr && isFunction_1(dr) ? cr[ur] = function(gr, mr) {
      var vr = __assign$1({}, mr);
      return vr.origin = function() {
        return fr(gr, mr);
      }, dr(gr, vr);
    } : includes(["htmlBlock", "htmlInline"], ur) && !isFunction_1(dr) ? cr[ur] = function(gr, mr) {
      var vr = gr.literal.match(reHTMLTag);
      if (vr) {
        var yr = vr[0], kr = vr[1], _r = vr[3], xr = (kr || _r).toLowerCase(), Sr = dr[xr], Er = getChildrenHTML(gr, xr);
        if (Sr) {
          var Cr = __assign$1({}, gr);
          return Cr.attrs = getHTMLAttrsByHTMLString(yr), Cr.childrenHTML = Er, Cr.type = xr, mr.entering = !reCloseTag.test(gr.literal), Sr(Cr, mr);
        }
      }
      return mr.origin();
    } : cr[ur] = dr;
  }), cr;
}
var nestableTypes = ["list", "item", "blockQuote"], nestableTagNames = ["UL", "OL", "BLOCKQUOTE"];
function isBlankLine(lr, ar) {
  var cr, ur = lr.child(ar);
  return !ur.childCount || ur.childCount === 1 && !(!((cr = ur.firstChild.text) === null || cr === void 0) && cr.trim());
}
function getEditorRangeHeightInfo(lr, ar, cr) {
  var ur = getMdStartLine(ar) - 1, fr = getMdEndLine(ar) - 1, dr = cr[ur].getBoundingClientRect(), gr = cr[fr].offsetTop - cr[ur].offsetTop + cr[fr].clientHeight;
  return {
    height: gr <= 0 ? cr[ur].clientHeight : gr + getBlankLinesHeight(lr, cr, Math.min(fr + 1, lr.childCount - 1)),
    rect: dr
  };
}
function getBlankLinesHeight(lr, ar, cr) {
  for (var ur = lr.childCount - 1, fr = 0; cr <= ur && isBlankLine(lr, cr); )
    fr += ar[cr].clientHeight, cr += 1;
  return fr;
}
function findAncestorHavingId(lr, ar) {
  for (; !lr.getAttribute("data-nodeid") && lr.parentElement !== ar; )
    lr = lr.parentElement;
  return lr;
}
function getTotalOffsetTop(lr, ar) {
  for (var cr = 0; lr && lr !== ar && (includes(nestableTagNames, lr.tagName) || (cr += lr.offsetTop), lr.offsetParent !== ar.offsetParent); )
    lr = lr.parentElement;
  return cr;
}
function findAdjacentElementToScrollTop(lr, ar) {
  for (var cr = ar, ur = null; cr; ) {
    var fr = cr.firstElementChild;
    if (!fr)
      break;
    var dr = findLastSiblingElementToScrollTop(fr, lr, getTotalOffsetTop(cr, ar));
    ur = cr, cr = dr;
  }
  var gr = cr || ur;
  return gr === ar ? null : gr;
}
function findLastSiblingElementToScrollTop(lr, ar, cr) {
  return lr && ar > cr + lr.offsetTop ? findLastSiblingElementToScrollTop(lr.nextElementSibling, ar, cr) || lr : null;
}
function getAdditionalPos(lr, ar, cr, ur) {
  var fr = Math.min((lr - ar) / cr, 1);
  return fr * ur;
}
function getParentNodeObj(lr, ar) {
  for (var cr = lr.querySelector('[data-nodeid="' + ar.id + '"]'); !cr || isStyledInlineNode(ar); )
    ar = ar.parent, cr = lr.querySelector('[data-nodeid="' + ar.id + '"]');
  return getNonNestableNodeObj({ mdNode: ar, el: cr });
}
function getNonNestableNodeObj(lr) {
  for (var ar = lr.mdNode, cr = lr.el; (includes(nestableTypes, ar.type) || ar.type === "table") && ar.firstChild; )
    ar = ar.firstChild, cr = cr.firstElementChild;
  return { mdNode: ar, el: cr };
}
var offsetInfoMap = {};
function setHeight(lr, ar) {
  offsetInfoMap[lr] = offsetInfoMap[lr] || {}, offsetInfoMap[lr].height = ar;
}
function setOffsetTop(lr, ar) {
  offsetInfoMap[lr] = offsetInfoMap[lr] || {}, offsetInfoMap[lr].offsetTop = ar;
}
function getHeight(lr) {
  return offsetInfoMap[lr] && offsetInfoMap[lr].height;
}
function getOffsetTop(lr) {
  return offsetInfoMap[lr] && offsetInfoMap[lr].offsetTop;
}
function removeOffsetInfoByNode(lr) {
  lr && (delete offsetInfoMap[Number(lr.getAttribute("data-nodeid"))], toArray_1(lr.children).forEach(function(ar) {
    removeOffsetInfoByNode(ar);
  }));
}
function getAndSaveOffsetInfo(lr, ar, cr) {
  var ur = getHeight(cr), fr = getOffsetTop(cr), dr = ur || lr.clientHeight, gr = fr || getTotalOffsetTop(lr, ar) || lr.offsetTop;
  return ur || setHeight(cr, dr), fr || setOffsetTop(cr, gr), { nodeHeight: dr, offsetTop: gr };
}
var CLASS_HIGHLIGHT = cls("md-preview-highlight");
function findTableCell(lr, ar) {
  for (var cr = lr.firstChild; cr && cr.next && !(getMdStartCh(cr.next) > ar + 1); )
    cr = cr.next;
  return cr;
}
var MarkdownPreview = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = document.createElement("div");
      this.el = ur, this.eventEmitter = ar, this.isViewer = !!cr.isViewer, this.el.className = cls("md-preview");
      var fr = cr.linkAttributes, dr = cr.customHTMLRenderer, gr = cr.sanitizer, mr = cr.highlight, vr = mr === void 0 ? !1 : mr;
      this.renderer = new Renderer({
        gfm: !0,
        nodeId: !0,
        convertors: getHTMLRenderConvertors(fr, dr)
      }), this.cursorNodeId = null, this.sanitizer = gr, this.initEvent(vr), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
    }
    return lr.prototype.initContentSection = function() {
      this.previewContent = createElementWith('<div class="' + cls("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
    }, lr.prototype.toggleActive = function(ar) {
      toggleClass(this.el, "active", ar);
    }, lr.prototype.initEvent = function(ar) {
      var cr = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (ar && (this.eventEmitter.listen("changeToolbarState", function(ur) {
        var fr = ur.mdNode, dr = ur.cursorPos;
        cr.updateCursorNode(fr, dr);
      }), this.eventEmitter.listen("blur", function() {
        cr.removeHighlight();
      })), on_1(this.el, "scroll", function(ur) {
        cr.eventEmitter.emit("scroll", "preview", findAdjacentElementToScrollTop(ur.target.scrollTop, cr.previewContent));
      }), this.eventEmitter.listen("changePreviewTabPreview", function() {
        return cr.toggleActive(!0);
      }), this.eventEmitter.listen("changePreviewTabWrite", function() {
        return cr.toggleActive(!1);
      }));
    }, lr.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var ar = this.getElementByNodeId(this.cursorNodeId);
        ar && removeClass_1(ar, CLASS_HIGHLIGHT);
      }
    }, lr.prototype.updateCursorNode = function(ar, cr) {
      ar && (ar = findClosestNode(ar, function(gr) {
        return !isInlineNode$1(gr);
      }), ar.type === "tableRow" ? ar = findTableCell(ar, cr[1]) : ar.type === "tableBody" && (ar = null));
      var ur = ar ? ar.id : null;
      if (this.cursorNodeId !== ur) {
        var fr = this.getElementByNodeId(this.cursorNodeId), dr = this.getElementByNodeId(ur);
        fr && removeClass_1(fr, CLASS_HIGHLIGHT), dr && addClass_1(dr, CLASS_HIGHLIGHT), this.cursorNodeId = ur;
      }
    }, lr.prototype.getElementByNodeId = function(ar) {
      return ar ? this.previewContent.querySelector('[data-nodeid="' + ar + '"]') : null;
    }, lr.prototype.update = function(ar) {
      var cr = this;
      ar.forEach(function(ur) {
        return cr.replaceRangeNodes(ur);
      }), this.eventEmitter.emit("afterPreviewRender", this);
    }, lr.prototype.replaceRangeNodes = function(ar) {
      var cr = this, ur = ar.nodes, fr = ar.removedNodeRange, dr = this.previewContent, gr = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(ur.map(function(Er) {
        return cr.renderer.render(Er);
      }).join("")));
      if (!fr)
        dr.insertAdjacentHTML("afterbegin", gr);
      else {
        var mr = fr.id, vr = mr[0], yr = mr[1], kr = this.getElementByNodeId(vr), _r = this.getElementByNodeId(yr);
        if (kr) {
          kr.insertAdjacentHTML("beforebegin", gr);
          for (var xr = kr; xr && xr !== _r; ) {
            var Sr = xr.nextElementSibling;
            removeNode$1(xr), removeOffsetInfoByNode(xr), xr = Sr;
          }
          xr != null && xr.parentNode && (removeNode$1(xr), removeOffsetInfoByNode(xr));
        }
      }
    }, lr.prototype.getRenderer = function() {
      return this.renderer;
    }, lr.prototype.destroy = function() {
      off_1(this.el, "scroll"), this.el = null;
    }, lr.prototype.getElement = function() {
      return this.el;
    }, lr.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.previewContent.innerHTML);
    }, lr.prototype.setHTML = function(ar) {
      this.previewContent.innerHTML = ar;
    }, lr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, lr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, lr;
  }()
);
function findNodeBy(lr, ar) {
  for (var cr = lr.depth; cr; ) {
    var ur = lr.node(cr);
    if (ar(ur, cr))
      return {
        node: ur,
        depth: cr,
        offset: cr > 0 ? lr.before(cr) : 0
      };
    cr -= 1;
  }
  return null;
}
function isInListNode(lr) {
  return !!findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "listItem" || cr.name === "bulletList" || cr.name === "orderedList";
  });
}
function isInTableNode(lr) {
  return !!findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "tableHeadCell" || cr.name === "tableBodyCell";
  });
}
function findListItem(lr) {
  return findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "listItem";
  });
}
function createDOMInfoParsedRawHTML(lr) {
  return {
    tag: lr,
    getAttrs: function(ar) {
      var cr = ar.getAttribute("data-raw-html");
      return __assign$1({}, cr && { rawHTML: cr });
    }
  };
}
function createCellAttrs(lr) {
  return Object.keys(lr).reduce(function(ar, cr) {
    return cr !== "rawHTML" && lr[cr] && (cr = cr === "className" ? "class" : cr, ar[cr] = lr[cr]), ar;
  }, {});
}
function createParsedCellDOM(lr) {
  return {
    tag: lr,
    getAttrs: function(ar) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(cr, ur) {
        var fr = ur === "rawHTML" ? "data-raw-html" : ur, dr = ar.getAttribute(fr);
        return dr && (cr[ur] = includes(["rawHTML", "extended"], ur) ? dr : Number(dr)), cr;
      }, {});
    }
  };
}
function getDefaultCustomAttrs() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function getCustomAttrs(lr) {
  var ar = lr.htmlAttrs, cr = lr.classNames;
  return __assign$1(__assign$1({}, ar), { class: cr ? cr.join(" ") : null });
}
function findWrappingOutside(lr, ar) {
  var cr = lr.parent, ur = lr.startIndex, fr = lr.endIndex, dr = cr.contentMatchAt(ur).findWrapping(ar);
  if (dr) {
    var gr = dr.length ? dr[0] : ar;
    return cr.canReplaceWith(ur, fr, gr) ? dr : null;
  }
  return null;
}
function findWrappingInside(lr, ar) {
  var cr = lr.parent, ur = lr.startIndex, fr = lr.endIndex, dr = cr.child(ur), gr = ar.contentMatch.findWrapping(dr.type);
  if (gr) {
    for (var mr = gr.length ? gr[gr.length - 1] : ar, vr = mr.contentMatch, yr = ur; vr && yr < fr; yr += 1)
      vr = vr.matchType(cr.child(yr).type);
    if (vr && vr.validEnd)
      return gr;
  }
  return null;
}
function findWrappers(lr, ar, cr, ur) {
  var fr = findWrappingOutside(lr, cr), dr = findWrappingInside(ar, cr);
  if (fr && dr) {
    var gr = fr.map(function(vr) {
      return { type: vr };
    }), mr = dr.map(function(vr) {
      return { type: vr, attrs: ur };
    });
    return gr.concat({ type: cr }).concat(mr);
  }
  return null;
}
function wrapInList(lr, ar, cr, ur, fr) {
  for (var dr = ar.start, gr = ar.end, mr = ar.startIndex, vr = ar.endIndex, yr = ar.parent, kr = distExports$5.Fragment.empty, _r = cr.length - 1; _r >= 0; _r -= 1)
    kr = distExports$5.Fragment.from(cr[_r].type.create(cr[_r].attrs, kr));
  lr.step(new ReplaceAroundStep(dr - (ur ? 2 : 0), gr, dr, gr, new distExports$5.Slice(kr, 0, 0), cr.length, !0));
  for (var xr = 0, _r = 0; _r < cr.length; _r += 1)
    if (cr[_r].type === fr) {
      xr = _r + 1;
      break;
    }
  for (var Sr = cr.length - xr, Er = dr + cr.length - (ur ? 2 : 0), _r = mr, Cr = vr; _r < Cr; _r += 1) {
    var Tr = _r === mr;
    !Tr && canSplit(lr.doc, Er, Sr) && (lr.split(Er, Sr), Er += Sr * 2), Er += yr.child(_r).nodeSize;
  }
  return lr;
}
function changeToList(lr, ar, cr, ur) {
  var fr = ar.$from, dr = ar.$to, gr = ar.depth, mr = ar, vr = !1;
  if (gr >= 2 && fr.node(gr - 1).type.compatibleContent(cr) && ar.startIndex === 0 && fr.index(gr - 1)) {
    var yr = lr.doc.resolve(ar.start - 2);
    mr = new distExports$5.NodeRange(yr, yr, gr), ar.endIndex < ar.parent.childCount && (ar = new distExports$5.NodeRange(fr, lr.doc.resolve(dr.end(gr)), gr)), vr = !0;
  }
  var kr = findWrappers(mr, ar, cr, ur);
  return kr ? wrapInList(lr, ar, kr, vr, cr) : lr;
}
function getBeforeLineListItem(lr, ar) {
  for (var cr = lr.resolve(ar); cr.node().type.name !== "paragraph"; )
    ar -= 2, cr = lr.resolve(ar);
  return findListItem(cr);
}
function toggleTaskListItems(lr, ar) {
  var cr = ar.$from, ur = ar.$to, fr = findListItem(cr), dr = findListItem(ur);
  if (fr && dr)
    for (; dr; ) {
      var gr = dr.offset, mr = dr.node, vr = { task: !mr.attrs.task, checked: !1 };
      if (lr.setNodeMarkup(gr, null, vr), gr === fr.offset)
        break;
      dr = getBeforeLineListItem(lr.doc, gr);
    }
  return lr;
}
function changeListType(lr, ar, cr) {
  var ur = ar.$from, fr = ar.$to, dr = findListItem(ur), gr = findListItem(fr);
  if (dr && gr)
    for (; gr; ) {
      var mr = gr.offset, vr = gr.node, yr = gr.depth;
      vr.attrs.task && lr.setNodeMarkup(mr, null, { task: !1, checked: !1 });
      var kr = lr.doc.resolve(mr);
      if (kr.parent.type !== cr) {
        var _r = kr.before(yr - 1);
        lr.setNodeMarkup(_r, cr);
      }
      if (mr === dr.offset)
        break;
      gr = getBeforeLineListItem(lr.doc, mr);
    }
  return lr;
}
function changeList(lr) {
  return function(ar, cr) {
    var ur = ar.selection, fr = ar.tr, dr = ur.$from, gr = ur.$to, mr = dr.blockRange(gr);
    if (mr) {
      var vr = isInListNode(dr) ? changeListType(fr, mr, lr) : changeToList(fr, mr, lr);
      return cr(vr), !0;
    }
    return !1;
  };
}
function toggleTask() {
  return function(lr, ar) {
    var cr = lr.selection, ur = lr.tr, fr = lr.schema, dr = cr.$from, gr = cr.$to, mr = dr.blockRange(gr);
    if (mr) {
      var vr = isInListNode(dr) ? toggleTaskListItems(ur, mr) : changeToList(ur, mr, fr.nodes.bulletList, { task: !0 });
      return ar(vr), !0;
    }
    return !1;
  };
}
function sinkListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, gr = fr.$to, mr = dr.blockRange(gr, function(Cr) {
      var Tr = Cr.childCount, Ar = Cr.firstChild;
      return !!Tr && Ar.type === lr;
    });
    if (mr && mr.startIndex > 0) {
      var vr = mr.parent, yr = vr.child(mr.startIndex - 1);
      if (yr.type !== lr)
        return !1;
      var kr = yr.lastChild && yr.lastChild.type === vr.type, _r = kr ? distExports$5.Fragment.from(lr.create()) : null, xr = new distExports$5.Slice(distExports$5.Fragment.from(lr.create(null, distExports$5.Fragment.from(vr.type.create(null, _r)))), kr ? 3 : 1, 0), Sr = mr.start, Er = mr.end;
      return ur.step(new ReplaceAroundStep(Sr - (kr ? 3 : 1), Er, Sr, Er, xr, 1, !0)), cr(ur), !0;
    }
    return !1;
  };
}
function liftToOuterList(lr, ar, cr) {
  var ur = ar.$from, fr = ar.$to, dr = ar.end, gr = ar.depth, mr = ar.parent, vr = fr.end(gr);
  return dr < vr && (lr.step(new ReplaceAroundStep(dr - 1, vr, dr, vr, new distExports$5.Slice(distExports$5.Fragment.from(cr.create(null, mr.copy())), 1, 0), 1, !0)), ar = new distExports$5.NodeRange(lr.doc.resolve(ur.pos), lr.doc.resolve(vr), gr)), lr.lift(ar, liftTarget(ar)), lr;
}
function liftOutOfList(lr, ar) {
  for (var cr = ar.parent, ur = ar.end, fr = ar.endIndex - 1, dr = ar.startIndex; fr > dr; fr -= 1)
    ur -= cr.child(fr).nodeSize, lr.delete(ur - 1, ur + 1);
  var gr = lr.doc.resolve(ar.start), mr = gr.nodeAfter, vr = ar.startIndex === 0, yr = ar.endIndex === cr.childCount, kr = gr.node(-1), _r = gr.index(-1), xr = kr.canReplace(_r + (vr ? 0 : 1), _r + 1, mr == null ? void 0 : mr.content.append(yr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr)));
  if (mr && xr) {
    var Sr = gr.pos, Er = Sr + mr.nodeSize;
    lr.step(new ReplaceAroundStep(Sr - (vr ? 1 : 0), Er + (yr ? 1 : 0), Sr + 1, Er - 1, new distExports$5.Slice((vr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr.copy(distExports$5.Fragment.empty))).append(yr ? distExports$5.Fragment.empty : distExports$5.Fragment.from(cr.copy(distExports$5.Fragment.empty))), vr ? 0 : 1, yr ? 0 : 1), vr ? 0 : 1));
  }
  return lr;
}
function liftListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, gr = fr.$to, mr = dr.blockRange(gr, function(kr) {
      var _r = kr.childCount, xr = kr.firstChild;
      return !!_r && xr.type === lr;
    });
    if (mr) {
      var vr = dr.node(mr.depth - 1).type === lr, yr = vr ? liftToOuterList(ur, mr, lr) : liftOutOfList(ur, mr);
      return cr(yr), !0;
    }
    return !1;
  };
}
function splitListItem(lr) {
  return function(ar, cr) {
    var ur = ar.tr, fr = ar.selection, dr = fr.$from, gr = fr.$to;
    if (dr.depth < 2 || !dr.sameParent(gr))
      return !1;
    var mr = dr.node(-1);
    if (mr.type !== lr)
      return !1;
    if (dr.parent.content.size === 0 && dr.node(-1).childCount === dr.indexAfter(-1)) {
      if (dr.depth === 2 || dr.node(-3).type !== lr || dr.index(-2) !== dr.node(-2).childCount - 1)
        return !1;
      for (var vr = dr.index(-1) > 0, yr = distExports$5.Fragment.empty, kr = dr.depth - (vr ? 1 : 2); kr >= dr.depth - 3; kr -= 1)
        yr = distExports$5.Fragment.from(dr.node(kr).copy(yr));
      return yr = yr.append(distExports$5.Fragment.from(lr.createAndFill())), ur.replace(vr ? dr.before() : dr.before(-1), dr.after(-3), new distExports$5.Slice(yr, vr ? 3 : 2, 2)), ur.setSelection(distExports$3.Selection.near(ur.doc.resolve(dr.pos + (vr ? 3 : 2)))), cr(ur), !0;
    }
    var _r = gr.pos === dr.end() ? mr.contentMatchAt(0).defaultType : null, xr = _r && [null, { type: _r }];
    return ur.delete(dr.pos, gr.pos), canSplit(ur.doc, dr.pos, 2, xr) ? (ur.split(dr.pos, 2, xr), cr(ur), !0) : !1;
  };
}
function indent() {
  return function() {
    return function(lr, ar) {
      var cr = lr.selection, ur = lr.schema, fr = cr.$from, dr = cr.$to, gr = fr.blockRange(dr);
      return gr && isInListNode(fr) ? sinkListItem(ur.nodes.listItem)(lr, ar) : !1;
    };
  };
}
function outdent() {
  return function() {
    return function(lr, ar) {
      var cr = lr.selection, ur = lr.schema, fr = cr.$from, dr = cr.$to, gr = fr.blockRange(dr);
      return gr && isInListNode(fr) ? liftListItem(ur.nodes.listItem)(lr, ar) : !1;
    };
  };
}
function getWwCommands() {
  return {
    indent: indent(),
    outdent: outdent()
  };
}
var cache = /* @__PURE__ */ new Map(), TableOffsetMap = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      this.table = ar, this.tableRows = cr, this.tableStartPos = ur, this.rowInfo = fr;
    }
    return lr.create = function(ar) {
      var cr = findNodeBy(ar, function(Er) {
        var Cr = Er.type;
        return Cr.name === "table";
      });
      if (cr) {
        var ur = cr.node, fr = cr.depth, dr = cr.offset, gr = cache.get(ur);
        if ((gr == null ? void 0 : gr.tableStartPos) === dr + 1)
          return gr;
        var mr = [], vr = ar.start(fr), yr = ur.child(0), kr = ur.child(1), _r = createOffsetMap(yr, vr), xr = createOffsetMap(kr, vr + yr.nodeSize);
        yr.forEach(function(Er) {
          return mr.push(Er);
        }), kr.forEach(function(Er) {
          return mr.push(Er);
        });
        var Sr = new lr(ur, mr, vr, _r.concat(xr));
        return cache.set(ur, Sr), Sr;
      }
      return null;
    }, Object.defineProperty(lr.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(lr.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: !1,
      configurable: !0
    }), lr.prototype.getCellInfo = function(ar, cr) {
      return this.rowInfo[ar][cr];
    }, lr.prototype.posAt = function(ar, cr) {
      for (var ur = 0, fr = this.tableStartPos; ; ur += 1) {
        var dr = fr + this.tableRows[ur].nodeSize;
        if (ur === ar) {
          for (var gr = cr; gr < this.totalColumnCount && this.rowInfo[ur][gr].offset < fr; )
            gr += 1;
          return gr === this.totalColumnCount ? dr : this.rowInfo[ur][gr].offset;
        }
        fr = dr;
      }
    }, lr.prototype.getNodeAndPos = function(ar, cr) {
      var ur = this.rowInfo[ar][cr];
      return {
        node: this.table.nodeAt(ur.offset - this.tableStartOffset),
        pos: ur.offset
      };
    }, lr.prototype.extendedRowspan = function(ar, cr) {
      return !1;
    }, lr.prototype.extendedColspan = function(ar, cr) {
      return !1;
    }, lr.prototype.getRowspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.getColspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.decreaseColspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.decreaseRowspanCount = function(ar, cr) {
      return 0;
    }, lr.prototype.getColspanStartInfo = function(ar, cr) {
      return null;
    }, lr.prototype.getRowspanStartInfo = function(ar, cr) {
      return null;
    }, lr.prototype.getCellStartOffset = function(ar, cr) {
      var ur = this.rowInfo[ar][cr].offset;
      return this.extendedRowspan(ar, cr) ? this.posAt(ar, cr) : ur;
    }, lr.prototype.getCellEndOffset = function(ar, cr) {
      var ur = this.rowInfo[ar][cr], fr = ur.offset, dr = ur.nodeSize;
      return this.extendedRowspan(ar, cr) ? this.posAt(ar, cr) : fr + dr;
    }, lr.prototype.getCellIndex = function(ar) {
      for (var cr = 0; cr < this.totalRowCount; cr += 1)
        for (var ur = this.rowInfo[cr], fr = 0; fr < this.totalColumnCount; fr += 1)
          if (ur[fr].offset + 1 > ar.pos)
            return [cr, fr];
      return [0, 0];
    }, lr.prototype.getRectOffsets = function(ar, cr) {
      var ur, fr, dr;
      cr === void 0 && (cr = ar), ar.pos > cr.pos && (ur = [cr, ar], ar = ur[0], cr = ur[1]);
      var gr = this.getCellIndex(ar), mr = gr[0], vr = gr[1], yr = this.getCellIndex(cr), kr = yr[0], _r = yr[1];
      return fr = getSortedNumPair(mr, kr), mr = fr[0], kr = fr[1], dr = getSortedNumPair(vr, _r), vr = dr[0], _r = dr[1], this.getSpannedOffsets({ startRowIdx: mr, startColIdx: vr, endRowIdx: kr, endColIdx: _r });
    }, lr.prototype.getSpannedOffsets = function(ar) {
      return ar;
    }, lr;
  }()
), createOffsetMap = function(lr, ar) {
  var cr = [];
  return lr.forEach(function(ur, fr) {
    var dr = { rowspanMap: {}, colspanMap: {}, length: 0 };
    ur.forEach(function(gr, mr) {
      for (var vr = gr.nodeSize, yr = 0; dr[yr]; )
        yr += 1;
      dr[yr] = {
        // 2 is the sum of the front and back positions of the tag
        offset: ar + fr + mr + 2,
        nodeSize: vr
      }, dr.length += 1;
    }), cr.push(dr);
  }), cr;
};
function mixinTableOffsetMapPrototype(lr, ar) {
  return assign(TableOffsetMap.prototype, lr), createOffsetMap = ar, TableOffsetMap;
}
function getSelectionRanges(lr, ar, cr) {
  for (var ur = cr.startRowIdx, fr = cr.startColIdx, dr = cr.endRowIdx, gr = cr.endColIdx, mr = [], vr = ur; vr <= dr; vr += 1)
    for (var yr = fr; yr <= gr; yr += 1) {
      var kr = ar.getCellInfo(vr, yr), _r = kr.offset, xr = kr.nodeSize;
      mr.push(new distExports$3.SelectionRange(lr.resolve(_r + 1), lr.resolve(_r + xr - 1)));
    }
  return mr;
}
function createTableFragment(lr, ar) {
  var cr = [];
  return lr.childCount && cr.push(lr), ar.childCount && cr.push(ar), distExports$5.Fragment.from(cr);
}
var CellSelection = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this, dr = cr.node(0), gr = TableOffsetMap.create(cr), mr = gr.getRectOffsets(cr, ur), vr = getSelectionRanges(dr, gr, mr);
      return fr = lr.call(this, vr[0].$from, vr[0].$to, vr) || this, fr.startCell = cr, fr.endCell = ur, fr.offsetMap = gr, fr.isCellSelection = !0, fr.visible = !1, fr;
    }
    return ar.prototype.map = function(cr, ur) {
      var fr = this.startCell.pos, dr = this.endCell.pos, gr = cr.resolve(ur.map(fr)), mr = cr.resolve(ur.map(dr)), vr = TableOffsetMap.create(gr);
      if (this.offsetMap.totalColumnCount > vr.totalColumnCount || this.offsetMap.totalRowCount > vr.totalRowCount) {
        var yr = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 }, kr = yr[mr.parent.type.name], _r = mr.end(mr.depth - kr), xr = Math.min(_r - 4, mr.pos);
        return distExports$3.TextSelection.create(cr, xr);
      }
      return new ar(gr, mr);
    }, ar.prototype.eq = function(cr) {
      return cr instanceof ar && cr.startCell.pos === this.startCell.pos && cr.endCell.pos === this.endCell.pos;
    }, ar.prototype.content = function() {
      for (var cr = this.startCell.node(-2), ur = this.startCell.start(-2), fr = cr.child(1).firstChild, dr = cr.child(0).type.create(), gr = cr.child(1).type.create(), mr = TableOffsetMap.create(this.startCell), vr = mr.getRectOffsets(this.startCell, this.endCell), yr = vr.startRowIdx, kr = vr.startColIdx, _r = vr.endRowIdx, xr = vr.endColIdx, Sr = !1, Er = yr; Er <= _r; Er += 1) {
        for (var Cr = [], Tr = kr; Tr <= xr; Tr += 1) {
          var Ar = mr.getCellInfo(Er, Tr).offset, Ir = cr.nodeAt(Ar - ur);
          Ir && (Sr = Ir.type.name === "tableHeadCell", mr.extendedRowspan(Er, Tr) || mr.extendedColspan(Er, Tr) ? Cr.push(Ir.type.create({ extended: !0 })) : Cr.push(Ir.copy(Ir.content)));
        }
        var Mr = fr.copy(distExports$5.Fragment.from(Cr)), Hr = Sr ? dr : gr;
        Hr.content = Hr.content.append(distExports$5.Fragment.from(Mr));
      }
      return new distExports$5.Slice(createTableFragment(dr, gr), 1, 1);
    }, ar.prototype.toJSON = function() {
      return JSON.stringify(this);
    }, ar;
  }(distExports$3.Selection)
);
function createTableHeadRow(lr, ar, cr) {
  for (var ur = ar.nodes, fr = ur.tableRow, dr = ur.tableHeadCell, gr = ur.paragraph, mr = [], vr = 0; vr < lr; vr += 1) {
    var yr = cr && cr[vr], kr = gr.create(null, yr ? ar.text(yr) : []);
    mr.push(dr.create(null, kr));
  }
  return [fr.create(null, mr)];
}
function createTableBodyRows(lr, ar, cr, ur) {
  for (var fr = cr.nodes, dr = fr.tableRow, gr = fr.tableBodyCell, mr = fr.paragraph, vr = [], yr = 0; yr < lr; yr += 1) {
    for (var kr = [], _r = 0; _r < ar; _r += 1) {
      var xr = ur && ur[yr * ar + _r], Sr = mr.create(null, xr ? cr.text(xr) : []);
      kr.push(gr.create(null, Sr));
    }
    vr.push(dr.create(null, kr));
  }
  return vr;
}
function createDummyCells(lr, ar, cr, ur) {
  ur === void 0 && (ur = null);
  for (var fr = cr.nodes, dr = fr.tableHeadCell, gr = fr.tableBodyCell, mr = fr.paragraph, vr = ar === 0 ? dr : gr, yr = [], kr = 0; kr < lr; kr += 1)
    yr.push(vr.create(ur, mr.create()));
  return yr;
}
function findCellElement(lr, ar) {
  for (; lr && lr !== ar; ) {
    if (lr.nodeName === "TD" || lr.nodeName === "TH")
      return lr;
    lr = lr.parentNode;
  }
  return null;
}
function findCell(lr) {
  return findNodeBy(lr, function(ar) {
    var cr = ar.type;
    return cr.name === "tableHeadCell" || cr.name === "tableBodyCell";
  });
}
function getResolvedSelection(lr) {
  if (lr instanceof distExports$3.TextSelection) {
    var ar = lr.$anchor, cr = findCell(ar);
    if (cr) {
      var ur = ar.node(0).resolve(ar.before(cr.depth));
      return { anchor: ur, head: ur };
    }
  }
  var fr = lr, dr = fr.startCell, gr = fr.endCell;
  return { anchor: dr, head: gr };
}
function getTableContentFromSlice(lr) {
  var ar;
  if (lr.size) {
    var cr = lr.content, ur = lr.openStart, fr = lr.openEnd;
    if (cr.childCount !== 1)
      return null;
    for (; cr.childCount === 1 && (ur > 0 && fr > 0 || ((ar = cr.firstChild) === null || ar === void 0 ? void 0 : ar.type.name) === "table"); )
      ur -= 1, fr -= 1, cr = cr.firstChild.content;
    if (cr.firstChild.type.name === "tableHead" || cr.firstChild.type.name === "tableBody")
      return cr;
  }
  return null;
}
function getRowAndColumnCount(lr) {
  var ar = lr.startRowIdx, cr = lr.startColIdx, ur = lr.endRowIdx, fr = lr.endColIdx, dr = ur - ar + 1, gr = fr - cr + 1;
  return { rowCount: dr, columnCount: gr };
}
function setAttrs(lr, ar) {
  return __assign$1(__assign$1({}, lr.attrs), ar);
}
var pluginKey = new distExports$3.PluginKey("cellSelection"), MOUSE_RIGHT_BUTTON = 2, TableSelection = (
  /** @class */
  function() {
    function lr(ar) {
      this.view = ar, this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      }, this.startCellPos = null, this.init();
    }
    return lr.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    }, lr.prototype.handleMousedown = function(ar) {
      var cr = findCellElement(ar.target, this.view.dom);
      if (ar.button === MOUSE_RIGHT_BUTTON) {
        ar.preventDefault();
        return;
      }
      if (cr) {
        var ur = this.getCellPos(ar);
        ur && (this.startCellPos = ur), this.bindEvent();
      }
    }, lr.prototype.handleMousemove = function(ar) {
      var cr = pluginKey.getState(this.view.state), ur = this.getCellPos(ar), fr = this.startCellPos, dr;
      cr ? dr = this.view.state.doc.resolve(cr) : fr !== ur && (dr = fr), dr && fr && ur && this.setCellSelection(fr, ur);
    }, lr.prototype.handleMouseup = function() {
      this.startCellPos = null, this.unbindEvent(), pluginKey.getState(this.view.state) !== null && this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));
    }, lr.prototype.bindEvent = function() {
      var ar = this.view.dom;
      ar.addEventListener("mousemove", this.handlers.mousemove), ar.addEventListener("mouseup", this.handlers.mouseup);
    }, lr.prototype.unbindEvent = function() {
      var ar = this.view.dom;
      ar.removeEventListener("mousemove", this.handlers.mousemove), ar.removeEventListener("mouseup", this.handlers.mouseup);
    }, lr.prototype.getCellPos = function(ar) {
      var cr = ar.clientX, ur = ar.clientY, fr = this.view.posAtCoords({ left: cr, top: ur });
      if (fr) {
        var dr = this.view.state.doc, gr = dr.resolve(fr.pos), mr = findCell(gr);
        if (mr) {
          var vr = gr.before(mr.depth);
          return dr.resolve(vr);
        }
      }
      return null;
    }, lr.prototype.setCellSelection = function(ar, cr) {
      var ur = this.view.state, fr = ur.selection, dr = ur.tr, gr = pluginKey.getState(this.view.state) === null, mr = new CellSelection(ar, cr);
      if (gr || !fr.eq(mr)) {
        var vr = dr.setSelection(mr);
        gr && vr.setMeta(pluginKey, cr.pos), this.view.dispatch(vr);
      }
    }, lr.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    }, lr;
  }()
), SELECTED_CELL_CLASS_NAME = cls("cell-selected");
function drawCellSelection(lr) {
  var ar = lr.selection, cr = lr.doc;
  if (ar instanceof CellSelection) {
    var ur = [], fr = ar.ranges;
    return fr.forEach(function(dr) {
      var gr = dr.$from, mr = dr.$to;
      ur.push(distExports$4.Decoration.node(gr.pos - 1, mr.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));
    }), distExports$4.DecorationSet.create(cr, ur);
  }
  return null;
}
function tableSelection() {
  return new distExports$3.Plugin({
    key: pluginKey,
    state: {
      init: function() {
        return null;
      },
      apply: function(lr, ar) {
        var cr = lr.getMeta(pluginKey);
        if (cr)
          return cr === -1 ? null : cr;
        if (isNull_1(ar) || !lr.docChanged)
          return ar;
        var ur = lr.mapping.mapResult(ar), fr = ur.deleted, dr = ur.pos;
        return fr ? null : dr;
      }
    },
    props: {
      decorations: drawCellSelection,
      createSelectionBetween: function(lr) {
        var ar = lr.state;
        return isNull_1(pluginKey.getState(ar)) ? null : ar.selection;
      }
    },
    view: function(lr) {
      return new TableSelection(lr);
    }
  });
}
var Map$1 = (
  /** @class */
  function() {
    function lr() {
      this.keys = [], this.values = [];
    }
    return lr.prototype.getKeyIndex = function(ar) {
      return inArray_1(ar, this.keys);
    }, lr.prototype.get = function(ar) {
      return this.values[this.getKeyIndex(ar)];
    }, lr.prototype.set = function(ar, cr) {
      var ur = this.getKeyIndex(ar);
      return ur > -1 ? this.values[ur] = cr : (this.keys.push(ar), this.values.push(cr)), this;
    }, lr.prototype.has = function(ar) {
      return this.getKeyIndex(ar) > -1;
    }, lr.prototype.delete = function(ar) {
      var cr = this.getKeyIndex(ar);
      return cr > -1 ? (this.keys.splice(cr, 1), this.values.splice(cr, 1), !0) : !1;
    }, lr.prototype.forEach = function(ar, cr) {
      var ur = this;
      cr === void 0 && (cr = this), this.values.forEach(function(fr, dr) {
        fr && ur.keys[dr] && ar.call(cr, fr, ur.keys[dr], ur);
      });
    }, lr.prototype.clear = function() {
      this.keys = [], this.values = [];
    }, lr;
  }()
), DEFAULT_CODE = "en-US", I18n = (
  /** @class */
  function() {
    function lr() {
      this.code = DEFAULT_CODE, this.langs = new Map$1();
    }
    return lr.prototype.setCode = function(ar) {
      this.code = ar || DEFAULT_CODE;
    }, lr.prototype.setLanguage = function(ar, cr) {
      var ur = this;
      ar = [].concat(ar), ar.forEach(function(fr) {
        if (!ur.langs.has(fr))
          ur.langs.set(fr, cr);
        else {
          var dr = ur.langs.get(fr);
          ur.langs.set(fr, extend_1(dr, cr));
        }
      });
    }, lr.prototype.get = function(ar, cr) {
      cr || (cr = this.code);
      var ur = this.langs.get(cr);
      ur || (ur = this.langs.get(DEFAULT_CODE));
      var fr = ur[ar];
      if (!fr)
        throw new Error('There is no text key "' + ar + '" in ' + cr);
      return fr;
    }, lr;
  }()
), i18n = new I18n(), contextMenuGroups = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: !0,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: !0,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function getContextMenuGroups(lr, ar) {
  return contextMenuGroups.map(function(cr) {
    return cr.map(function(ur) {
      var fr = ur.action, dr = ur.command, gr = ur.payload, mr = ur.disableInThead, vr = ur.className;
      return {
        label: i18n.get(fr),
        onClick: function() {
          lr.emit("command", dr, gr);
        },
        disabled: ar && !!mr,
        className: vr
      };
    });
  }).concat();
}
function tableContextMenu(lr) {
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        contextmenu: function(ar, cr) {
          var ur = findCellElement(cr.target, ar.dom);
          if (ur) {
            cr.preventDefault();
            var fr = cr, dr = fr.clientX, gr = fr.clientY, mr = ar.dom.parentNode.getBoundingClientRect(), vr = mr.left, yr = mr.top, kr = ur.nodeName === "TH";
            return lr.emit("contextmenu", {
              pos: { left: dr - vr + 10 + "px", top: gr - yr + 30 + "px" },
              menuGroups: getContextMenuGroups(lr, kr),
              tableCell: ur
            }), !0;
          }
          return !1;
        }
      }
    }
  });
}
function task() {
  return new distExports$3.Plugin({
    props: {
      handleDOMEvents: {
        mousedown: function(lr, ar) {
          var cr = ar, ur = cr.clientX, fr = cr.clientY, dr = lr.posAtCoords({ left: ur, top: fr });
          if (dr) {
            var gr = lr.state, mr = gr.doc, vr = gr.tr, yr = mr.resolve(dr.pos), kr = findListItem(yr), _r = ar.target, xr = getComputedStyle(_r, ":before"), Sr = ar, Er = Sr.offsetX, Cr = Sr.offsetY;
            if (!kr || !isPositionInBox(xr, Er, Cr))
              return !1;
            ar.preventDefault();
            var Tr = yr.before(kr.depth), Ar = kr.node.attrs;
            return vr.setNodeMarkup(Tr, null, __assign$1(__assign$1({}, Ar), { checked: !Ar.checked })), lr.dispatch(vr), !0;
          }
          return !1;
        }
      }
    }
  });
}
var EXCEPT_TYPES = ["image", "link", "customBlock", "frontMatter"], MARK_TYPES = ["strong", "strike", "emph", "code"], LIST_TYPES = ["bulletList", "orderedList", "taskList"];
function getToolbarStateType(lr, ar) {
  var cr = lr.type.name;
  return cr === "listItem" ? lr.attrs.task ? "taskList" : ar.type.name : cr.indexOf("table") !== -1 ? "table" : cr;
}
function setListNodeToolbarState(lr, ar) {
  ar[lr] = { active: !0 }, LIST_TYPES.filter(function(cr) {
    return cr !== lr;
  }).forEach(function(cr) {
    ar[cr] && delete ar[cr];
  });
}
function setMarkTypeStates(lr, ar, cr, ur) {
  MARK_TYPES.forEach(function(fr) {
    var dr = cr.marks[fr], gr = lr.marksAcross(ar) || [], mr = !!dr.isInSet(gr);
    mr && (ur[fr] = { active: !0 });
  });
}
function getToolbarState(lr, ar, cr) {
  var ur = lr.$from, fr = lr.$to, dr = lr.from, gr = lr.to, mr = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  };
  return ar.nodesBetween(dr, gr, function(vr, yr, kr) {
    var _r = getToolbarStateType(vr, kr);
    includes(EXCEPT_TYPES, _r) || (includes(LIST_TYPES, _r) ? (setListNodeToolbarState(_r, mr), mr.indent.disabled = !1, mr.outdent.disabled = !1) : _r === "paragraph" || _r === "text" ? setMarkTypeStates(ur, fr, cr, mr) : mr[_r] = { active: !0 });
  }), mr;
}
function toolbarStateHighlight(lr) {
  return new distExports$3.Plugin({
    view: function() {
      return {
        update: function(ar) {
          var cr = ar.state, ur = cr.selection, fr = cr.doc, dr = cr.schema;
          lr.emit("changeToolbarState", {
            toolbarState: getToolbarState(ur, fr, dr)
          });
        }
      };
    }
  });
}
var CustomBlockView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.openEditor = function() {
        if (dr.innerEditorView)
          throw new Error("The editor is already opened.");
        dr.dom.draggable = !1, dr.wrapper.style.display = "none", dr.innerViewContainer.style.display = "block", dr.innerEditorView = new distExports$4.EditorView(dr.innerViewContainer, {
          state: distExports$3.EditorState.create({
            doc: dr.node,
            plugins: [
              distExports$2.keymap({
                "Mod-z": function() {
                  return undo(dr.innerEditorView.state, dr.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return redo(dr.innerEditorView.state, dr.innerEditorView.dispatch);
                },
                Tab: function(gr, mr) {
                  return mr(gr.tr.insertText("	")), !0;
                },
                Enter: newlineInCode,
                Escape: function() {
                  return dr.cancelEditing(), !0;
                },
                "Ctrl-Enter": function() {
                  return dr.saveAndFinishEditing(), !0;
                }
              }),
              history()
            ]
          }),
          dispatchTransaction: function(gr) {
            return dr.dispatchInner(gr);
          },
          handleDOMEvents: {
            mousedown: function() {
              return dr.editorView.hasFocus() && dr.innerEditorView.focus(), !0;
            },
            blur: function() {
              return dr.saveAndFinishEditing(), !0;
            }
          }
        }), dr.innerEditorView.focus();
      }, this.node = ar, this.editorView = cr, this.getPos = ur, this.toDOMAdaptor = fr, this.innerEditorView = null, this.canceled = !1, this.dom = document.createElement("div"), this.dom.className = cls("custom-block"), this.wrapper = document.createElement("div"), this.wrapper.className = cls("custom-block-view"), this.createInnerViewContainer(), this.renderCustomBlock(), this.dom.appendChild(this.innerViewContainer), this.dom.appendChild(this.wrapper);
    }
    return lr.prototype.renderToolArea = function() {
      var ar = this, cr = document.createElement("div"), ur = document.createElement("span"), fr = document.createElement("button");
      cr.className = "tool", ur.textContent = this.node.attrs.info, ur.className = "info", fr.type = "button", fr.addEventListener("click", function() {
        return ar.openEditor();
      }), cr.appendChild(ur), cr.appendChild(fr), this.wrapper.appendChild(cr);
    }, lr.prototype.renderCustomBlock = function() {
      var ar = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (ar) {
        for (var cr = ar(this.node); this.wrapper.hasChildNodes(); )
          this.wrapper.removeChild(this.wrapper.lastChild);
        cr && this.wrapper.appendChild(cr), this.renderToolArea();
      }
    }, lr.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div"), this.innerViewContainer.className = cls("custom-block-editor"), this.innerViewContainer.style.display = "none";
    }, lr.prototype.closeEditor = function() {
      this.innerEditorView && (this.innerEditorView.destroy(), this.innerEditorView = null, this.innerViewContainer.style.display = "none"), this.wrapper.style.display = "block";
    }, lr.prototype.saveAndFinishEditing = function() {
      var ar = this.editorView.state.selection.to, cr = this.editorView.state;
      this.editorView.dispatch(cr.tr.setSelection(createTextSelection(cr.tr, ar))), this.editorView.focus(), this.renderCustomBlock(), this.closeEditor();
    }, lr.prototype.cancelEditing = function() {
      var ar = undoDepth(this.innerEditorView.state);
      for (this.canceled = !0; ar--; )
        undo(this.innerEditorView.state, this.innerEditorView.dispatch), undo(this.editorView.state, this.editorView.dispatch);
      this.canceled = !1;
      var cr = this.editorView.state.selection.to, ur = this.editorView.state;
      this.editorView.dispatch(ur.tr.setSelection(distExports$3.TextSelection.create(ur.doc, cr))), this.editorView.focus(), this.closeEditor();
    }, lr.prototype.dispatchInner = function(ar) {
      var cr = this.innerEditorView.state.applyTransaction(ar), ur = cr.state, fr = cr.transactions;
      if (this.innerEditorView.updateState(ur), !this.canceled && isFunction_1(this.getPos)) {
        for (var dr = this.editorView.state.tr, gr = StepMap.offset(this.getPos() + 1), mr = 0; mr < fr.length; mr += 1)
          for (var vr = fr[mr].steps, yr = 0; yr < vr.length; yr += 1)
            dr.step(vr[yr].map(gr));
        dr.docChanged && this.editorView.dispatch(dr);
      }
    }, lr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, this.innerEditorView || this.renderCustomBlock(), !0) : !1;
    }, lr.prototype.stopEvent = function(ar) {
      return !!this.innerEditorView && !!ar.target && this.innerEditorView.dom.contains(ar.target);
    }, lr.prototype.ignoreMutation = function() {
      return !0;
    }, lr.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor();
    }, lr;
  }()
), IMAGE_LINK_CLASS_NAME = "image-link", ImageView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this, gr;
      this.handleMousedown = function(mr) {
        mr.preventDefault();
        var vr = mr.target, yr = mr.offsetX, kr = mr.offsetY;
        if (dr.imageLink && isFunction_1(dr.getPos) && hasClass_1(vr, IMAGE_LINK_CLASS_NAME)) {
          var _r = getComputedStyle(vr, ":before");
          if (mr.stopPropagation(), isPositionInBox(_r, yr, kr)) {
            var xr = dr.view.state.tr, Sr = dr.getPos();
            xr.setSelection(createTextSelection(xr, Sr, Sr + 1)), dr.view.dispatch(xr), dr.eventEmitter.emit("openPopup", "link", dr.imageLink.attrs);
          }
        }
      }, this.node = ar, this.view = cr, this.getPos = ur, this.eventEmitter = fr, this.imageLink = (gr = ar.marks.filter(function(mr) {
        var vr = mr.type;
        return vr.name === "link";
      })[0]) !== null && gr !== void 0 ? gr : null, this.dom = this.createElement(), this.bindEvent();
    }
    return lr.prototype.createElement = function() {
      var ar = this.createImageElement(this.node);
      if (this.imageLink) {
        var cr = document.createElement("span");
        return cr.className = IMAGE_LINK_CLASS_NAME, cr.appendChild(ar), cr;
      }
      return ar;
    }, lr.prototype.createImageElement = function(ar) {
      var cr = document.createElement("img"), ur = ar.attrs, fr = ur.imageUrl, dr = ur.altText, gr = getCustomAttrs(ar.attrs);
      return cr.src = fr, dr && (cr.alt = dr), setAttributes(gr, cr), cr;
    }, lr.prototype.bindEvent = function() {
      this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown);
    }, lr.prototype.stopEvent = function() {
      return !0;
    }, lr.prototype.destroy = function() {
      this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown);
    }, lr;
  }()
), WRAPPER_CLASS_NAME = "toastui-editor-ww-code-block", CODE_BLOCK_LANG_CLASS_NAME = "toastui-editor-ww-code-block-language", CodeBlockView = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.contentDOM = null, this.input = null, this.timer = null, this.handleMousedown = function(gr) {
        var mr = gr.target, vr = getComputedStyle(mr, ":after");
        if (vr.backgroundImage !== "none" && isFunction_1(dr.getPos)) {
          var yr = dr.view.coordsAtPos(dr.getPos()), kr = yr.top, _r = yr.right;
          dr.createLanguageEditor({ top: kr, right: _r });
        }
      }, this.handleKeydown = function(gr) {
        gr.key === "Enter" && dr.input && (gr.preventDefault(), dr.changeLanguage());
      }, this.node = ar, this.view = cr, this.getPos = ur, this.eventEmitter = fr, this.createElement(), this.bindDOMEvent(), this.bindEvent();
    }
    return lr.prototype.createElement = function() {
      var ar = this.node.attrs.language, cr = document.createElement("div");
      cr.setAttribute("data-language", ar || "text"), cr.className = WRAPPER_CLASS_NAME;
      var ur = this.createCodeBlockElement(), fr = ur.firstChild;
      cr.appendChild(ur), this.dom = cr, this.contentDOM = fr;
    }, lr.prototype.createCodeBlockElement = function() {
      var ar = document.createElement("pre"), cr = document.createElement("code"), ur = this.node.attrs.language, fr = getCustomAttrs(this.node.attrs);
      return ur && cr.setAttribute("data-language", ur), setAttributes(fr, ar), ar.appendChild(cr), ar;
    }, lr.prototype.createLanguageEditor = function(ar) {
      var cr = this, ur = ar.top, fr = ar.right, dr = document.createElement("span");
      dr.className = CODE_BLOCK_LANG_CLASS_NAME;
      var gr = document.createElement("input");
      gr.type = "text", gr.value = this.node.attrs.language, dr.appendChild(gr), this.view.dom.parentElement.appendChild(dr);
      var mr = dr.clientWidth;
      css_1(dr, {
        top: ur + 10 + "px",
        left: fr - mr - 10 + "px",
        width: mr + "px"
      }), this.input = gr, this.input.addEventListener("blur", function() {
        return cr.changeLanguage();
      }), this.input.addEventListener("keydown", this.handleKeydown), this.clearTimer(), this.timer = setTimeout(function() {
        cr.input.focus();
      });
    }, lr.prototype.bindDOMEvent = function() {
      this.dom && this.dom.addEventListener("click", this.handleMousedown);
    }, lr.prototype.bindEvent = function() {
      var ar = this;
      this.eventEmitter.listen("scroll", function() {
        ar.input && ar.reset();
      });
    }, lr.prototype.changeLanguage = function() {
      if (this.input && isFunction_1(this.getPos)) {
        var ar = this.input.value;
        this.reset();
        var cr = this.getPos(), ur = this.view.state.tr;
        ur.setNodeMarkup(cr, null, { language: ar }), this.view.dispatch(ur);
      }
    }, lr.prototype.reset = function() {
      var ar;
      if (!((ar = this.input) === null || ar === void 0) && ar.parentElement) {
        var cr = this.input.parentElement;
        this.input = null, removeNode$1(cr);
      }
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.stopEvent = function() {
      return !0;
    }, lr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, !0) : !1;
    }, lr.prototype.destroy = function() {
      this.reset(), this.clearTimer(), this.dom && this.dom.removeEventListener("click", this.handleMousedown);
    }, lr;
  }()
), reMSOListClassName = /MsoListParagraph/, reMSOStylePrefix = /style=(.|\n)*mso-/, reMSOListStyle = /mso-list:(.*)/, reMSOTagName = /O:P/, reMSOListBullet = /^(n|u|l)/, MSO_CLASS_NAME_LIST_PARA = "p.MsoListParagraph";
function isFromMso(lr) {
  return reMSOStylePrefix.test(lr);
}
function getListItemContents(lr) {
  for (var ar = [], cr = document.createTreeWalker(lr, 1, null, !1); cr.nextNode(); ) {
    var ur = cr.currentNode;
    if (isElemNode(ur)) {
      var fr = ur, dr = fr.outerHTML, gr = fr.textContent, mr = reMSOStylePrefix.test(dr), vr = reMSOListStyle.test(dr);
      mr && !vr && gr ? ar.push([ur, !0]) : (reMSOTagName.test(ur.nodeName) || mr && !gr || vr) && ar.push([ur, !1]);
    }
  }
  return ar.forEach(function(yr) {
    var kr = yr[0], _r = yr[1];
    _r ? unwrapNode(kr) : removeNode$1(kr);
  }), lr.innerHTML.trim();
}
function createListItemDataFromParagraph(lr, ar) {
  var cr = lr.getAttribute("style");
  if (cr) {
    var ur = cr.match(reMSOListStyle), fr = ur[1], dr = fr.trim().split(" "), gr = dr[1], mr = parseInt(gr.replace("level", ""), 10), vr = reMSOListBullet.test(lr.textContent || "");
    return {
      id: ar,
      level: mr,
      prev: null,
      parent: null,
      children: [],
      unordered: vr,
      contents: getListItemContents(lr)
    };
  }
  return null;
}
function addListItemDetailData(lr, ar) {
  if (ar.level < lr.level)
    ar.children.push(lr), lr.parent = ar;
  else {
    for (; ar && ar.level !== lr.level; )
      ar = ar.parent;
    ar && (lr.prev = ar, lr.parent = ar.parent, lr.parent && lr.parent.children.push(lr));
  }
}
function createListData(lr) {
  var ar = [];
  return lr.forEach(function(cr, ur) {
    var fr = ar[ur - 1], dr = createListItemDataFromParagraph(cr, ur);
    dr && (fr && addListItemDetailData(dr, fr), ar.push(dr));
  }), ar;
}
function makeList(lr) {
  var ar = lr[0].unordered ? "ul" : "ol", cr = document.createElement(ar);
  return lr.forEach(function(ur) {
    var fr = ur.children, dr = ur.contents, gr = document.createElement("li");
    gr.innerHTML = dr, cr.appendChild(gr), fr.length && cr.appendChild(makeList(fr));
  }), cr;
}
function makeListFromParagraphs(lr) {
  var ar = createListData(lr), cr = ar.filter(function(ur) {
    var fr = ur.parent;
    return !fr;
  });
  return makeList(cr);
}
function isMsoListParagraphEnd(lr) {
  for (; lr && !isElemNode(lr); )
    lr = lr.nextSibling;
  return lr ? !reMSOListClassName.test(lr.className) : !0;
}
function convertMsoParagraphsToList(lr) {
  var ar = document.createElement("div");
  ar.innerHTML = lr;
  var cr = [], ur = findNodes(ar, MSO_CLASS_NAME_LIST_PARA);
  ur.forEach(function(dr) {
    var gr = isMsoListParagraphEnd(dr.nextSibling);
    if (cr.push(dr), gr) {
      var mr = makeListFromParagraphs(cr), vr = dr.nextSibling;
      vr ? insertBeforeNode(mr, vr) : appendNodes(ar, mr), cr = [];
    }
    removeNode$1(dr);
  });
  var fr = ur.length ? "<p></p>" : "";
  return "" + fr + ar.innerHTML;
}
var START_FRAGMENT_COMMENT = "<!--StartFragment-->", END_FRAGMENT_COMMENT = "<!--EndFragment-->";
function getContentBetweenFragmentComments(lr) {
  var ar = lr.indexOf(START_FRAGMENT_COMMENT), cr = lr.lastIndexOf(END_FRAGMENT_COMMENT);
  return ar > -1 && cr > -1 && (lr = lr.slice(ar + START_FRAGMENT_COMMENT.length, cr)), lr.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);
}
function convertMsoTableToCompletedTable(lr) {
  return /<\/td>((?!<\/tr>)[\s\S])*$/i.test(lr) && (lr = "<tr>" + lr + "</tr>"), /<\/tr>((?!<\/table>)[\s\S])*$/i.test(lr) && (lr = "<table>" + lr + "</table>"), lr;
}
function changePastedHTML(lr) {
  return lr = getContentBetweenFragmentComments(lr), lr = convertMsoTableToCompletedTable(lr), isFromMso(lr) && (lr = convertMsoParagraphsToList(lr)), lr;
}
function getMaxColumnCount(lr) {
  var ar = lr.reduce(function(cr, ur) {
    return cr.childCount > ur.childCount ? cr : ur;
  });
  return ar.childCount;
}
function createCells(lr, ar, cr) {
  for (var ur = [], fr = lr.childCount, dr = 0; dr < fr; dr += 1)
    if (!lr.child(dr).attrs.extended) {
      var gr = dr < fr ? cr.create(lr.child(dr).attrs, lr.child(dr).content) : cr.createAndFill();
      ur.push(gr);
    }
  return ur;
}
function copyTableHeadRow(lr, ar, cr) {
  var ur = cr.nodes, fr = ur.tableRow, dr = ur.tableHeadCell, gr = createCells(lr, ar, dr);
  return fr.create(null, gr);
}
function copyTableBodyRow(lr, ar, cr) {
  var ur = cr.nodes, fr = ur.tableRow, dr = ur.tableBodyCell, gr = createCells(lr, ar, dr);
  return fr.create(null, gr);
}
function creatTableBodyDummyRow(lr, ar) {
  for (var cr = ar.nodes, ur = cr.tableRow, fr = cr.tableBodyCell, dr = [], gr = 0; gr < lr; gr += 1) {
    var mr = fr.createAndFill();
    dr.push(mr);
  }
  return ur.create({ dummyRowForPasting: !0 }, dr);
}
function createRowsFromPastingTable(lr) {
  var ar = [], cr = [];
  if (lr.firstChild.type.name === "tableHead") {
    var ur = lr.firstChild;
    ur.forEach(function(dr) {
      return ar.push(dr);
    });
  }
  if (lr.lastChild.type.name === "tableBody") {
    var fr = lr.lastChild;
    fr.forEach(function(dr) {
      return cr.push(dr);
    });
  }
  return __spreadArray$1(__spreadArray$1([], ar), cr);
}
function createTableHead(lr, ar, cr) {
  var ur = copyTableHeadRow(lr, ar, cr);
  return cr.nodes.tableHead.create(null, ur);
}
function createTableBody(lr, ar, cr) {
  var ur = lr.map(function(dr) {
    return copyTableBodyRow(dr, ar, cr);
  });
  if (!lr.length) {
    var fr = creatTableBodyDummyRow(ar, cr);
    ur.push(fr);
  }
  return cr.nodes.tableBody.create(null, ur);
}
function createTableFromPastingTable(lr, ar, cr, ur) {
  var fr = getMaxColumnCount(lr);
  if (cr && ur)
    return ar.nodes.table.create(null, [createTableBody(lr, fr, ar)]);
  var dr = lr[0], gr = lr.slice(1), mr = [createTableHead(dr, fr, ar)];
  return gr.length && mr.push(createTableBody(gr, fr, ar)), ar.nodes.table.create(null, mr);
}
function changePastedSlice(lr, ar, cr) {
  var ur = [], fr = lr.content, dr = lr.openStart, gr = lr.openEnd;
  return fr.forEach(function(mr) {
    if (mr.type.name === "table") {
      var vr = getTableContentFromSlice(new distExports$5.Slice(distExports$5.Fragment.from(mr), 0, 0));
      if (vr) {
        var yr = createRowsFromPastingTable(vr), kr = vr.firstChild.type.name === "tableBody", _r = createTableFromPastingTable(yr, ar, kr, cr);
        ur.push(_r);
      }
    } else
      ur.push(mr);
  }), new distExports$5.Slice(distExports$5.Fragment.from(ur), dr, gr);
}
var DUMMY_CELL_SIZE = 4, TR_NODES_SIZE = 2;
function getDummyCellSize(lr) {
  return lr * DUMMY_CELL_SIZE;
}
function createPastingCells(lr, ar, cr) {
  var ur = [], fr = createRowsFromPastingTable(lr), dr = fr[0].childCount, gr = fr.length, mr = ar.startRowIdx === 0, vr = fr.slice(0, gr);
  if (mr) {
    var yr = vr.shift();
    if (yr) {
      var kr = copyTableHeadRow(yr, dr, cr).content;
      ur.push(kr);
    }
  }
  return vr.forEach(function(_r) {
    if (!_r.attrs.dummyRowForPasting) {
      var xr = copyTableBodyRow(_r, dr, cr).content;
      ur.push(xr);
    }
  }), ur;
}
function getPastingRangeInfo(lr, ar, cr) {
  for (var ur = ar.startRowIdx, fr = ar.startColIdx, dr = cr.length, gr = 0, mr = function(Sr) {
    var Er = cr[Sr].childCount;
    cr[Sr].forEach(function(Cr) {
      var Tr = Cr.attrs, Ar = Tr.colspan;
      Ar > 1 && (Er += Ar - 1);
    }), gr = Math.max(gr, Er);
  }, vr = 0; vr < dr; vr += 1)
    mr(vr);
  var yr = ur + dr - 1, kr = fr + gr - 1, _r = Math.max(yr + 1 - lr.totalRowCount, 0), xr = Math.max(kr + 1 - lr.totalColumnCount, 0);
  return {
    startRowIdx: ur,
    startColIdx: fr,
    endRowIdx: yr,
    endColIdx: kr,
    addedRowCount: _r,
    addedColumnCount: xr
  };
}
function addReplacedOffsets(lr, ar) {
  for (var cr = lr.startRowIdx, ur = lr.startColIdx, fr = lr.endRowIdx, dr = lr.endColIdx, gr = lr.addedRowCount, mr = lr.addedColumnCount, vr = cr; vr <= fr - gr; vr += 1)
    ar.push({
      rowIdx: vr,
      startColIdx: ur,
      endColIdx: dr - mr
    });
}
function expandColumns(lr, ar, cr, ur, fr) {
  for (var dr = ur.startRowIdx, gr = ur.startColIdx, mr = ur.endRowIdx, vr = ur.endColIdx, yr = ur.addedRowCount, kr = ur.addedColumnCount, _r = cr.totalRowCount, xr = 0, Sr = 0; Sr < _r; Sr += 1) {
    var Er = cr.getCellInfo(Sr, vr - kr), Cr = Er.offset, Tr = Er.nodeSize, Ar = lr.mapping.map(Cr + Tr), Ir = createDummyCells(kr, Sr, ar);
    if (lr.insert(Ar, Ir), Sr >= dr && Sr <= mr - yr) {
      var Mr = cr.getCellInfo(Sr, vr - kr), Hr = lr.mapping.map(Mr.offset), Br = Ar + getDummyCellSize(kr);
      fr[xr] = {
        rowIdx: Sr,
        startColIdx: gr,
        endColIdx: vr,
        dummyOffsets: [Hr, Br]
      }, xr += 1;
    }
  }
}
function expandRows(lr, ar, cr, ur, fr) {
  var dr = ur.addedRowCount, gr = ur.addedColumnCount, mr = ur.startColIdx, vr = ur.endColIdx, yr = lr.mapping.maps.length, kr = cr.tableEndOffset - 2, _r = createTableBodyRows(dr, cr.totalColumnCount + gr, ar), xr = kr;
  lr.insert(lr.mapping.slice(yr).map(xr), _r);
  for (var Sr = 0; Sr < dr; Sr += 1) {
    var Er = xr + getDummyCellSize(mr) + 1, Cr = xr + getDummyCellSize(vr + 1) + 1, Tr = xr + getDummyCellSize(cr.totalColumnCount + gr) + TR_NODES_SIZE;
    fr.push({
      rowIdx: Sr + cr.totalRowCount,
      startColIdx: mr,
      endColIdx: vr,
      dummyOffsets: [Er, Cr]
    }), xr = Tr;
  }
}
function replaceCells(lr, ar, cr, ur) {
  var fr = lr.mapping.maps.length;
  cr.forEach(function(dr, gr) {
    var mr = dr.rowIdx, vr = dr.startColIdx, yr = dr.endColIdx, kr = dr.dummyOffsets, _r = lr.mapping.slice(fr), xr = new distExports$5.Slice(ar[gr], 0, 0), Sr = kr ? kr[0] : ur.getCellStartOffset(mr, vr), Er = kr ? kr[1] : ur.getCellEndOffset(mr, yr);
    lr.replace(_r.map(Sr), _r.map(Er), xr);
  });
}
function pasteToTable(lr, ar) {
  var cr = lr.state, ur = cr.selection, fr = cr.schema, dr = cr.tr, gr = getResolvedSelection(ur), mr = gr.anchor, vr = gr.head;
  if (mr && vr) {
    var yr = getTableContentFromSlice(ar);
    if (!yr)
      return !1;
    var kr = TableOffsetMap.create(mr), _r = kr.getRectOffsets(mr, vr), xr = createPastingCells(yr, _r, fr), Sr = getPastingRangeInfo(kr, _r, xr), Er = [];
    return canMerge(kr, Sr) && (addReplacedOffsets(Sr, Er), Sr.addedColumnCount && expandColumns(dr, fr, kr, Sr, Er), Sr.addedRowCount && expandRows(dr, fr, kr, Sr, Er), replaceCells(dr, xr, Er, kr), lr.dispatch(dr), setSelection(lr, Er, kr.getCellInfo(0, 0).offset)), !0;
  }
  return !1;
}
function setSelection(lr, ar, cr) {
  var ur = lr.state, fr = ur.tr, dr = ur.doc, gr = TableOffsetMap.create(dr.resolve(cr)), mr = ar[0], vr = mr.rowIdx, yr = mr.startColIdx, kr = last$1(ar), _r = kr.rowIdx, xr = kr.endColIdx, Sr = gr.getCellInfo(vr, yr).offset, Er = gr.getCellInfo(_r, xr).offset;
  lr.dispatch(fr.setSelection(new CellSelection(dr.resolve(Sr), dr.resolve(Er))));
}
function canMerge(lr, ar) {
  var cr = lr.getSpannedOffsets(ar), ur = getRowAndColumnCount(cr), fr = ur.rowCount, dr = ur.columnCount, gr = getRowAndColumnCount(ar), mr = gr.rowCount, vr = gr.columnCount;
  return fr === mr && dr === vr;
}
var Doc = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Paragraph = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: __assign$1({}, getDefaultCustomAttrs()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["p", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reSoftTabLen = /\s{1,4}$/, Text = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addSpaces = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, gr = fr.$from, mr = fr.$to, vr = gr.blockRange(mr);
        return vr && !isInListNode(gr) && !isInTableNode(gr) ? (ur(dr.insertText("    ", gr.pos, mr.pos)), !0) : !1;
      };
    }, ar.prototype.removeSpaces = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, gr = fr.$from, mr = fr.$to, vr = fr.from, yr = gr.blockRange(mr);
        if (yr && !isInListNode(gr) && !isInTableNode(gr)) {
          var kr = gr.nodeBefore;
          if (kr && kr.isText) {
            var _r = kr.text, xr = _r.replace(reSoftTabLen, ""), Sr = _r.length - xr.length;
            return ur(dr.delete(vr - Sr, vr)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    }, ar;
  }(Node$2)
), Heading = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = this.levels.map(function(ur) {
          return {
            tag: "h" + ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({ level: ur }, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "inline*",
          group: "block",
          defining: !0,
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return ["h" + fr.level, getCustomAttrs(fr), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.schema.nodes[cr.level ? "heading" : "paragraph"];
          return setBlockType(dr, cr)(ur, fr);
        };
      };
    }, ar;
  }(Node$2)
), CodeBlock = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          code: !0,
          defining: !0,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html"), fr = cr.firstElementChild;
                return __assign$1({ language: (fr == null ? void 0 : fr.getAttribute("data-language")) || null }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "pre",
              ["code", __assign$1({ "data-language": ur.language }, getCustomAttrs(ur)), 0]
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return setBlockType(cr.schema.nodes.codeBlock)(cr, ur);
        };
      };
    }, ar.prototype.moveCursor = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var gr = fr.tr, mr = fr.doc, vr = fr.schema, yr = fr.selection.$from, kr = ur.context.view;
        if (kr.endOfTextblock(cr) && yr.node().type.name === "codeBlock") {
          var _r = yr.parent.textContent.split(`
`), xr = cr === "up" ? yr.start() : yr.end(), Sr = cr === "up" ? [xr, _r[0].length + xr] : [xr - last$1(_r).length, xr], Er = mr.resolve(cr === "up" ? yr.before() : yr.after()), Cr = cr === "up" ? Er.nodeBefore : Er.nodeAfter;
          if (between$1(yr.pos, Sr[0], Sr[1]) && !Cr) {
            var Tr = addParagraph(gr, Er, vr);
            if (Tr)
              return dr(Tr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-p": cr,
        "Shift-Mod-P": cr,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    }, ar;
  }(Node$2)
), BulletList = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("ul")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["ul", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.changeList = function() {
      return function(cr, ur) {
        return changeList(cr.schema.nodes.bulletList)(cr, ur);
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: toggleTask
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.changeList(), ur = getWwCommands(), fr = ur.indent, dr = ur.outdent;
      return {
        "Mod-u": cr,
        "Mod-U": cr,
        Tab: fr(),
        "Shift-Tab": dr()
      };
    }, ar;
  }(Node$2)
), OrderedList = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("start"), fr = cr.getAttribute("data-raw-html");
                return __assign$1({ order: cr.hasAttribute("start") ? Number(ur) : 1 }, fr && { rawHTML: fr });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "ol",
              __assign$1({ start: ur.order === 1 ? null : ur.order }, getCustomAttrs(ur)),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return changeList(cr.schema.nodes.orderedList)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()(), ur = getWwCommands(), fr = ur.indent, dr = ur.outdent;
      return {
        "Mod-o": cr,
        "Mod-O": cr,
        Tab: fr(),
        "Shift-Tab": dr()
      };
    }, ar;
  }(Node$2)
), ListItem = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: !1,
          attrs: {
            task: { default: !1 },
            checked: { default: !1 },
            rawHTML: { default: null }
          },
          defining: !0,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html");
                return __assign$1({ task: cr.hasAttribute("data-task"), checked: cr.hasAttribute("data-task-checked") }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = ur.task, dr = ur.checked;
            if (!fr)
              return [ur.rawHTML || "li", 0];
            var gr = ["task-list-item"];
            return dr && gr.push("checked"), [
              ur.rawHTML || "li",
              __assign$1({ class: gr.join(" "), "data-task": fr }, dr && { "data-task-checked": dr }),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.liftToPrevListItem = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, gr = cr.schema, mr = fr.$from, vr = fr.empty, yr = gr.nodes.listItem, kr = mr.parent, _r = mr.node(-1);
        if (vr && !kr.childCount && _r.type === yr) {
          if (mr.index(-2) >= 1)
            return dr.delete(mr.start(-1) - 1, mr.end(-1)), ur(dr), !0;
          var xr = mr.node(-3);
          if (xr.type === yr)
            return dr.delete(mr.start(-2) - 1, mr.end(-1)), ur(dr), !0;
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var cr = function(ur, fr) {
        return splitListItem(ur.schema.nodes.listItem)(ur, fr);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: cr
      };
    }, ar;
  }(Node$2)
), BlockQuote = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "block+",
          group: "block",
          parseDOM: [createDOMInfoParsedRawHTML("blockquote")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["blockquote", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return wrapIn(cr.schema.nodes.blockQuote)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Alt-q": cr,
        "Alt-Q": cr
      };
    }, ar;
  }(Node$2)
), cellOffsetFnMap = {
  left: getLeftCellOffset,
  right: getRightCellOffset,
  up: getUpCellOffset,
  down: getDownCellOffset
};
function isInFirstListItem(lr, ar, cr) {
  var ur = cr[0], fr = cr[1], dr = ar.resolve(lr.before(ur - 1));
  return fr === ur && !dr.nodeBefore;
}
function isInLastListItem(lr) {
  for (var ar, cr = lr.depth, ur; cr && (ur = lr.node(cr), ur.type.name !== "tableBodyCell"); ) {
    if (ur.type.name === "listItem") {
      var fr = lr.node(cr - 1), dr = fr.lastChild === ur, gr = ((ar = ur.lastChild) === null || ar === void 0 ? void 0 : ar.type.name) !== "paragraph";
      return dr ? !gr : !1;
    }
    cr -= 1;
  }
  return !1;
}
function canMoveToBeforeCell(lr, ar, cr, ur, fr) {
  var dr = ar[0], gr = ar[1], mr = ar[2];
  if (lr === "left" || lr === "up") {
    if (fr && !isInFirstListItem(cr, ur, [dr, gr]))
      return !1;
    var vr = cr.before(mr), yr = ur.resolve(vr).nodeBefore;
    if (yr)
      return !1;
  }
  return !0;
}
function canMoveToAfterCell(lr, ar, cr, ur, fr) {
  if (lr === "right" || lr === "down") {
    if (fr && !isInLastListItem(cr))
      return !1;
    var dr = cr.after(ar), gr = ur.resolve(dr).nodeAfter;
    if (gr)
      return !1;
  }
  return !0;
}
function canMoveBetweenCells(lr, ar, cr, ur) {
  var fr = ar[0], dr = ar[1], gr = fr + 3, mr = dr >= gr, vr = mr ? fr + 1 : dr, yr = canMoveToBeforeCell(lr, [dr, gr, vr], cr, ur, mr), kr = canMoveToAfterCell(lr, vr, cr, ur, mr);
  return yr && kr;
}
function canBeOutOfTable(lr, ar, cr) {
  var ur = cr[0], fr = cr[1], dr = ar.getRowspanStartInfo(ur, fr), gr = lr === "up" && ur === 0, mr = lr === "down" && ((dr == null ? void 0 : dr.count) > 1 ? ur + dr.count - 1 : ur) === ar.totalRowCount - 1;
  return gr || mr;
}
function addParagraphBeforeTable(lr, ar, cr) {
  var ur = lr.doc.resolve(ar.tableStartOffset - 1);
  return ur.nodeBefore ? lr.setSelection(distExports$3.Selection.near(ur, -1)) : addParagraph(lr, ur, cr);
}
function addParagraphAfterTable(lr, ar, cr, ur) {
  ur === void 0 && (ur = !1);
  var fr = lr.doc.resolve(ar.tableEndOffset);
  return ur || !fr.nodeAfter ? addParagraph(lr, fr, cr) : lr.setSelection(distExports$3.Selection.near(fr, 1));
}
function getRightCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalRowCount, dr = ar.totalColumnCount, gr = ur === dr - 1, mr = cr === fr - 1 && gr;
  if (!mr) {
    var vr = ur + 1, yr = ar.getColspanStartInfo(cr, ur);
    (yr == null ? void 0 : yr.count) > 1 && (vr += yr.count - 1), (gr || vr === dr) && (cr += 1, vr = 0);
    var kr = ar.getCellInfo(cr, vr).offset;
    return kr + 2;
  }
  return null;
}
function getLeftCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalColumnCount, dr = ur === 0, gr = cr === 0 && dr;
  if (!gr) {
    ur -= 1, dr && (cr -= 1, ur = fr - 1);
    var mr = ar.getCellInfo(cr, ur), vr = mr.offset, yr = mr.nodeSize;
    return vr + yr - 2;
  }
  return null;
}
function getUpCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1];
  if (cr > 0) {
    var fr = ar.getCellInfo(cr - 1, ur), dr = fr.offset, gr = fr.nodeSize;
    return dr + gr - 2;
  }
  return null;
}
function getDownCellOffset(lr, ar) {
  var cr = lr[0], ur = lr[1], fr = ar.totalRowCount;
  if (cr < fr - 1) {
    var dr = cr + 1, gr = ar.getRowspanStartInfo(cr, ur);
    (gr == null ? void 0 : gr.count) > 1 && (dr += gr.count - 1);
    var mr = ar.getCellInfo(dr, ur).offset;
    return mr + 2;
  }
  return null;
}
function moveToCell(lr, ar, cr, ur) {
  var fr = cellOffsetFnMap[lr], dr = fr(cr, ur);
  if (dr) {
    var gr = lr === "right" || lr === "down" ? 1 : -1;
    return ar.setSelection(distExports$3.Selection.near(ar.doc.resolve(dr), gr));
  }
  return null;
}
function canSelectTableNode(lr, ar, cr) {
  var ur = cr[0], fr = cr[1];
  if (lr === "up" || lr === "down")
    return !1;
  var dr = ar.tableStartOffset, gr = ar.tableEndOffset, mr = ar.getCellInfo(ur, fr), vr = mr.offset, yr = mr.nodeSize, kr = lr === "left" ? dr : gr, _r = lr === "left" ? vr - 2 : vr + yr + 3;
  return kr === _r;
}
function selectNode(lr, ar, cr) {
  var ur = lr.doc.resolve(ar.before(cr - 3));
  return lr.setSelection(new distExports$3.NodeSelection(ur));
}
function getTargetRowInfo(lr, ar, cr) {
  var ur, fr, dr;
  return lr === "up" ? (ur = cr.startRowIdx, fr = 0, dr = -1) : (ur = cr.endRowIdx, fr = ar.totalColumnCount - 1, dr = ar.getCellInfo(ur, fr).nodeSize + 1), { targetRowIdx: ur, insertColIdx: fr, nodeSize: dr };
}
function getRowRanges(lr, ar, cr) {
  var ur = lr.getCellInfo(ar, 0).offset, fr = lr.getCellInfo(ar, cr - 1), dr = fr.offset, gr = fr.nodeSize;
  return { from: ur, to: dr + gr };
}
var Table = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("table")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["table", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addTable = function() {
      return function(cr) {
        return cr === void 0 && (cr = { rowCount: 2, columnCount: 1, data: [] }), function(ur, fr) {
          var dr = cr.rowCount, gr = cr.columnCount, mr = cr.data, vr = ur.schema, yr = ur.selection, kr = ur.tr, _r = yr.from, xr = yr.to, Sr = yr.$from, Er = _r === xr;
          if (Er && !isInTableNode(Sr)) {
            var Cr = vr.nodes, Tr = Cr.tableHead, Ar = Cr.tableBody, Ir = mr == null ? void 0 : mr.slice(0, gr), Mr = mr == null ? void 0 : mr.slice(gr, mr.length), Hr = createTableHeadRow(gr, vr, Ir), Br = createTableBodyRows(dr - 1, gr, vr, Mr), zr = vr.nodes.table.create(null, [
              Tr.create(null, Hr),
              Ar.create(null, Br)
            ]);
            return fr(kr.replaceSelectionWith(zr)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeTable = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, gr = TableOffsetMap.create(fr.$anchor);
          if (gr) {
            var mr = gr.tableStartOffset, vr = gr.tableEndOffset, yr = mr - 1, kr = createTextSelection(dr.delete(yr, vr), yr);
            return ur(dr.setSelection(kr)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addColumn = function(cr) {
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, gr = ur.tr, mr = ur.schema, vr = getResolvedSelection(dr), yr = vr.anchor, kr = vr.head;
          if (yr && kr) {
            for (var _r = TableOffsetMap.create(yr), xr = _r.getRectOffsets(yr, kr), Sr = cr === "left" ? xr.startColIdx : xr.endColIdx + 1, Er = getRowAndColumnCount(xr).columnCount, Cr = _r.totalRowCount, Tr = 0; Tr < Cr; Tr += 1) {
              var Ar = createDummyCells(Er, Tr, mr);
              gr.insert(gr.mapping.map(_r.posAt(Tr, Sr)), Ar);
            }
            return fr(gr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeColumn = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, gr = getResolvedSelection(fr), mr = gr.anchor, vr = gr.head;
          if (mr && vr) {
            var yr = TableOffsetMap.create(mr), kr = yr.getRectOffsets(mr, vr), _r = yr.totalColumnCount, xr = yr.totalRowCount, Sr = getRowAndColumnCount(kr).columnCount, Er = Sr === _r;
            if (Er)
              return !1;
            for (var Cr = kr.startColIdx, Tr = kr.endColIdx, Ar = dr.mapping.maps.length, Ir = 0; Ir < xr; Ir += 1)
              for (var Mr = Tr; Mr >= Cr; Mr -= 1) {
                var Hr = yr.getCellInfo(Ir, Mr), Br = Hr.offset, zr = Hr.nodeSize, Gr = dr.mapping.slice(Ar).map(Br), Xr = Gr + zr;
                dr.delete(Gr, Xr);
              }
            return ur(dr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addRow = function(cr) {
      return function() {
        return function(ur, fr) {
          var dr = ur.selection, gr = ur.schema, mr = ur.tr, vr = getResolvedSelection(dr), yr = vr.anchor, kr = vr.head;
          if (yr && kr) {
            var _r = TableOffsetMap.create(yr), xr = _r.totalColumnCount, Sr = _r.getRectOffsets(yr, kr), Er = getRowAndColumnCount(Sr).rowCount, Cr = getTargetRowInfo(cr, _r, Sr), Tr = Cr.targetRowIdx, Ar = Cr.insertColIdx, Ir = Cr.nodeSize, Mr = Tr === 0;
            if (!Mr) {
              for (var Hr = [], Br = mr.mapping.map(_r.posAt(Tr, Ar)) + Ir, zr = [], Gr = 0; Gr < xr; Gr += 1)
                zr = zr.concat(createDummyCells(1, Tr, gr));
              for (var Xr = 0; Xr < Er; Xr += 1)
                Hr.push(gr.nodes.tableRow.create(null, zr));
              return fr(mr.insert(Br, Hr)), !0;
            }
          }
          return !1;
        };
      };
    }, ar.prototype.removeRow = function() {
      return function() {
        return function(cr, ur) {
          var fr = cr.selection, dr = cr.tr, gr = getResolvedSelection(fr), mr = gr.anchor, vr = gr.head;
          if (mr && vr) {
            var yr = TableOffsetMap.create(mr), kr = yr.totalRowCount, _r = yr.totalColumnCount, xr = yr.getRectOffsets(mr, vr), Sr = getRowAndColumnCount(xr).rowCount, Er = xr.startRowIdx, Cr = xr.endRowIdx, Tr = Er === 0, Ar = Sr === kr - 1;
            if (Ar || Tr)
              return !1;
            for (var Ir = Cr; Ir >= Er; Ir -= 1) {
              var Mr = getRowRanges(yr, Ir, _r), Hr = Mr.from, Br = Mr.to;
              dr.delete(Hr - 1, Br + 1);
            }
            return ur(dr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.alignColumn = function() {
      return function(cr) {
        return cr === void 0 && (cr = { align: "center" }), function(ur, fr) {
          var dr = cr.align, gr = ur.selection, mr = ur.tr, vr = getResolvedSelection(gr), yr = vr.anchor, kr = vr.head;
          if (yr && kr) {
            for (var _r = TableOffsetMap.create(yr), xr = _r.totalRowCount, Sr = _r.getRectOffsets(yr, kr), Er = Sr.startColIdx, Cr = Sr.endColIdx, Tr = 0; Tr < xr; Tr += 1)
              for (var Ar = Er; Ar <= Cr; Ar += 1)
                if (!_r.extendedRowspan(Tr, Ar) && !_r.extendedColspan(Tr, Ar)) {
                  var Ir = _r.getNodeAndPos(Tr, Ar), Mr = Ir.node, Hr = Ir.pos, Br = setAttrs(Mr, { align: dr });
                  mr.setNodeMarkup(Hr, null, Br);
                }
            return fr(mr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.moveToCell = function(cr) {
      return function(ur, fr) {
        var dr = ur.selection, gr = ur.tr, mr = ur.schema, vr = getResolvedSelection(dr), yr = vr.anchor, kr = vr.head;
        if (yr && kr) {
          var _r = TableOffsetMap.create(yr), xr = _r.getCellIndex(yr), Sr = void 0;
          if (canBeOutOfTable(cr, _r, xr) ? Sr = addParagraphAfterTable(gr, _r, mr) : Sr = moveToCell(cr, gr, xr, _r), Sr)
            return fr(Sr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveInCell = function(cr) {
      var ur = this;
      return function(fr, dr) {
        var gr = fr.selection, mr = fr.tr, vr = fr.doc, yr = fr.schema, kr = gr.$from, _r = ur.context.view;
        if (!_r.endOfTextblock(cr))
          return !1;
        var xr = findNodeBy(kr, function(Mr) {
          var Hr = Mr.type;
          return Hr.name === "tableHeadCell" || Hr.name === "tableBodyCell";
        });
        if (xr) {
          var Sr = findNodeBy(kr, function(Mr) {
            var Hr = Mr.type;
            return Hr.name === "paragraph";
          }), Er = xr.depth;
          if (Sr && canMoveBetweenCells(cr, [Er, Sr.depth], kr, vr)) {
            var Cr = getResolvedSelection(gr).anchor, Tr = TableOffsetMap.create(Cr), Ar = Tr.getCellIndex(Cr), Ir = void 0;
            if (canSelectTableNode(cr, Tr, Ar) ? Ir = selectNode(mr, kr, Er) : canBeOutOfTable(cr, Tr, Ar) ? cr === "up" ? Ir = addParagraphBeforeTable(mr, Tr, yr) : cr === "down" && (Ir = addParagraphAfterTable(mr, Tr, yr)) : Ir = moveToCell(cr, mr, Ar, Tr), Ir)
              return dr(Ir), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.deleteCells = function() {
      return function(cr, ur) {
        var fr = cr.schema, dr = cr.selection, gr = cr.tr, mr = getResolvedSelection(dr), vr = mr.anchor, yr = mr.head, kr = dr instanceof distExports$3.TextSelection;
        if (vr && yr && !kr) {
          for (var _r = TableOffsetMap.create(vr), xr = _r.getRectOffsets(vr, yr), Sr = xr.startRowIdx, Er = xr.startColIdx, Cr = xr.endRowIdx, Tr = xr.endColIdx, Ar = Sr; Ar <= Cr; Ar += 1)
            for (var Ir = Er; Ir <= Tr; Ir += 1)
              if (!_r.extendedRowspan(Ar, Ir) && !_r.extendedColspan(Ar, Ir)) {
                var Mr = _r.getNodeAndPos(Ar, Ir), Hr = Mr.node, Br = Mr.pos, zr = createDummyCells(1, Ar, fr, Hr.attrs);
                gr.replaceWith(gr.mapping.map(Br), gr.mapping.map(Br + Hr.nodeSize), zr);
              }
          return ur(gr), !0;
        }
        return !1;
      };
    }, ar.prototype.exitTable = function() {
      return function(cr, ur) {
        var fr = cr.selection, dr = cr.tr, gr = cr.schema, mr = fr.$from, vr = findNodeBy(mr, function(xr) {
          var Sr = xr.type;
          return Sr.name === "tableHeadCell" || Sr.name === "tableBodyCell";
        });
        if (vr) {
          var yr = findNodeBy(mr, function(xr) {
            var Sr = xr.type;
            return Sr.name === "paragraph";
          });
          if (yr) {
            var kr = getResolvedSelection(fr).anchor, _r = TableOffsetMap.create(kr);
            return ur(addParagraphAfterTable(dr, _r, gr, !0)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: cr,
        "Mod-Backspace": cr,
        Delete: cr,
        "Mod-Delete": cr,
        "Mod-Enter": this.exitTable()
      };
    }, ar;
  }(Node$2)
), TableHead = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("thead")],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["thead", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(cr) {
                var ur = cr.querySelectorAll("tr"), fr = ur[0].children.length, dr = cr.getAttribute("data-raw-html");
                return fr ? __assign$1({}, dr && { rawHTML: dr }) : !1;
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["tbody", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableRow = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(cr) {
                var ur = cr.children.length, fr = cr.getAttribute("data-raw-html");
                return ur ? __assign$1({}, fr && { rawHTML: fr }) : !1;
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["tr", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableHeadCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),
          isolating: !0,
          parseDOM: [createParsedCellDOM("th")],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = createCellAttrs(ur);
            return ["th", __assign$1(__assign$1({}, fr), getCustomAttrs(ur)), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBodyCell = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: !0,
          parseDOM: [createParsedCellDOM("td")],
          toDOM: function(cr) {
            var ur = cr.attrs, fr = createCellAttrs(ur);
            return ["td", fr, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Image = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          inline: !0,
          attrs: __assign$1({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "inline",
          selectable: !1,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(cr) {
                var ur = sanitizeHTML(cr, { RETURN_DOM_FRAGMENT: !0 }).firstChild, fr = ur.getAttribute("src") || "", dr = ur.getAttribute("data-raw-html"), gr = ur.getAttribute("alt");
                return __assign$1({
                  imageUrl: fr,
                  altText: gr
                }, dr && { rawHTML: dr });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [
              ur.rawHTML || "img",
              __assign$1(__assign$1({ src: escapeXml$1(ur.imageUrl) }, ur.altText && { alt: ur.altText }), getCustomAttrs(ur))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addImage = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = ur.schema, gr = ur.tr, mr = cr, vr = mr.imageUrl, yr = mr.altText;
          if (!vr)
            return !1;
          var kr = dr.nodes.image.createAndFill(__assign$1({ imageUrl: vr }, yr && { altText: yr }));
          return fr(gr.replaceSelectionWith(kr).scrollIntoView()), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    }, ar;
  }(Node$2)
), ROOT_BLOCK_DEPTH = 1, ThematicBreak = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: !1,
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["div", getCustomAttrs(ur), [ur.rawHTML || "hr"]];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      var cr = this;
      return function() {
        return function(ur, fr) {
          var dr, gr = ur.selection, mr = gr.$from, vr = gr.$to;
          if (mr === vr) {
            var yr = ur.doc, kr = ur.schema.nodes, _r = kr.thematicBreak, xr = kr.paragraph, Sr = [_r.create()], Er = mr.node(ROOT_BLOCK_DEPTH), Cr = yr.child(yr.childCount - 1) === Er, Tr = yr.resolve(mr.after(ROOT_BLOCK_DEPTH)), Ar = ((dr = mr.nodeAfter) === null || dr === void 0 ? void 0 : dr.type.name) === cr.name;
            return (Cr || Ar) && Sr.push(xr.create()), fr(ur.tr.insert(Tr.pos, Sr).scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var cr = this.hr()();
      return {
        "Mod-l": cr,
        "Mod-L": cr
      };
    }, ar;
  }(Node$2)
), Strong = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["b", "strong"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "strong", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.strong)(cr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var cr = this.bold()();
      return {
        "Mod-b": cr,
        "Mod-B": cr
      };
    }, ar;
  }(Mark)
), Emph = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["i", "em"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "em", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.emph)(cr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var cr = this.italic()();
      return {
        "Mod-i": cr,
        "Mod-I": cr
      };
    }, ar;
  }(Mark)
), Strike = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = ["s", "del"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(fr) {
              var dr = fr.getAttribute("data-raw-html");
              return __assign$1({}, dr && { rawHTML: dr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: cr,
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [fr.rawHTML || "del", getCustomAttrs(fr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.strike)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Mod-s": cr,
        "Mod-S": cr
      };
    }, ar;
  }(Mark)
), Link = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this) || this;
      return ur.linkAttributes = cr, ur;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var cr = this;
        return {
          attrs: __assign$1({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          inclusive: !1,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(ur) {
                var fr = sanitizeHTML(ur, { RETURN_DOM_FRAGMENT: !0 }).firstChild, dr = fr.getAttribute("href") || "", gr = fr.getAttribute("title") || "", mr = fr.getAttribute("data-raw-html");
                return __assign$1({ linkUrl: dr, title: gr }, mr && { rawHTML: mr });
              }
            }
          ],
          toDOM: function(ur) {
            var fr = ur.attrs;
            return [
              fr.rawHTML || "a",
              __assign$1(__assign$1({ href: escapeXml$1(fr.linkUrl) }, cr.linkAttributes), getCustomAttrs(fr))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLink = function() {
      return function(cr) {
        return function(ur, fr) {
          var dr = cr, gr = dr.linkUrl, mr = dr.linkText, vr = mr === void 0 ? "" : mr, yr = ur.schema, kr = ur.tr, _r = ur.selection, xr = _r.empty, Sr = _r.from, Er = _r.to;
          if (Sr && Er && gr) {
            var Cr = { linkUrl: gr }, Tr = yr.mark("link", Cr);
            if (xr && vr) {
              var Ar = createTextNode$1(yr, vr, Tr);
              kr.replaceRangeWith(Sr, Er, Ar);
            } else
              kr.addMark(Sr, Er, Tr);
            return fr(kr.scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.toggleLink = function() {
      return function(cr) {
        return function(ur, fr) {
          return toggleMark$1(ur.schema.marks.link, cr)(ur, fr);
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    }, ar;
  }(Mark)
), Code = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-raw-html");
                return __assign$1({}, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return [ur.rawHTML || "code", getCustomAttrs(ur)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur) {
          return toggleMark$1(cr.schema.marks.code)(cr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var cr = this.commands()();
      return {
        "Shift-Mod-c": cr,
        "Shift-Mod-C": cr
      };
    }, ar;
  }(Mark)
), CustomBlock = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: !0,
          code: !0,
          defining: !0,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(cr) {
                var ur = cr.getAttribute("data-custom-info");
                return { info: ur };
              }
            }
          ],
          toDOM: function(cr) {
            var ur = cr.attrs;
            return ["div", { "data-custom-info": ur.info || null }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(cr) {
        return function(ur, fr) {
          return cr != null && cr.info ? setBlockType(ur.schema.nodes.customBlock, cr)(ur, fr) : !1;
        };
      };
    }, ar;
  }(Node$2)
), FrontMatter = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur, fr) {
          var dr = cr.selection.$from;
          return fr.endOfTextblock("down") && dr.node().type.name === "frontMatter" ? exitCode(cr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
), HTMLComment = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(cr, ur, fr) {
          var dr = cr.selection.$from;
          return fr.endOfTextblock("down") && dr.node().type.name === "htmlComment" ? exitCode(cr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
);
function createSpecs(lr) {
  return new SpecManager([
    new Doc(),
    new Paragraph(),
    new Text(),
    new Heading(),
    new CodeBlock(),
    new BulletList(),
    new OrderedList(),
    new ListItem(),
    new BlockQuote(),
    new Table(),
    new TableHead(),
    new TableBody(),
    new TableRow(),
    new TableHeadCell(),
    new TableBodyCell(),
    new Image(),
    new ThematicBreak(),
    new Strong(),
    new Emph(),
    new Strike(),
    new Link(lr),
    new Code(),
    new CustomBlock(),
    new FrontMatter(),
    new Widget(),
    new HTMLComment()
  ]);
}
var CONTENTS_CLASS_NAME = cls("contents"), WysiwygEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr, ur) {
      var fr = lr.call(this, cr) || this, dr = ur.toDOMAdaptor, gr = ur.htmlSchemaMap, mr = gr === void 0 ? {} : gr, vr = ur.linkAttributes, yr = vr === void 0 ? {} : vr, kr = ur.useCommandShortcut, _r = kr === void 0 ? !0 : kr, xr = ur.wwPlugins, Sr = xr === void 0 ? [] : xr, Er = ur.wwNodeViews, Cr = Er === void 0 ? {} : Er;
      return fr.editorType = "wysiwyg", fr.el.classList.add("ww-mode"), fr.toDOMAdaptor = dr, fr.linkAttributes = yr, fr.extraPlugins = Sr, fr.pluginNodeViews = Cr, fr.specs = fr.createSpecs(), fr.schema = fr.createSchema(mr), fr.context = fr.createContext(), fr.keymaps = fr.createKeymaps(_r), fr.view = fr.createView(), fr.commands = fr.createCommands(), fr.specs.setContext(__assign$1(__assign$1({}, fr.context), { view: fr.view })), fr.initEvent(), fr;
    }
    return ar.prototype.createSpecs = function() {
      return createSpecs(this.linkAttributes);
    }, ar.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSchema = function(cr) {
      return new distExports$5.Schema({
        nodes: __assign$1(__assign$1({}, this.specs.nodes), cr.nodes),
        marks: __assign$1(__assign$1({}, this.specs.marks), cr.marks)
      });
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        tableSelection(),
        tableContextMenu(this.eventEmitter),
        task(),
        toolbarStateHighlight(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createPluginNodeViews = function() {
      var cr = this, ur = cr.eventEmitter, fr = cr.pluginNodeViews, dr = {};
      return fr && Object.keys(fr).forEach(function(gr) {
        dr[gr] = function(mr, vr, yr) {
          return fr[gr](mr, vr, yr, ur);
        };
      }), dr;
    }, ar.prototype.createView = function() {
      var cr = this, ur = this, fr = ur.toDOMAdaptor, dr = ur.eventEmitter;
      return new distExports$4.EditorView(this.el, {
        state: this.createState(),
        attributes: {
          class: CONTENTS_CLASS_NAME
        },
        nodeViews: __assign$1({
          customBlock: function(gr, mr, vr) {
            return new CustomBlockView(gr, mr, vr, fr);
          },
          image: function(gr, mr, vr) {
            return new ImageView(gr, mr, vr, dr);
          },
          codeBlock: function(gr, mr, vr) {
            return new CodeBlockView(gr, mr, vr, dr);
          },
          widget: widgetNodeView
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(gr) {
          var mr = cr.view.state.applyTransaction(gr).state;
          cr.view.updateState(mr), cr.emitChangeEvent(gr.scrollIntoView()), cr.eventEmitter.emit("setFocusedNode", mr.selection.$from.node(1));
        },
        transformPastedHTML: changePastedHTML,
        transformPasted: function(gr) {
          return changePastedSlice(gr, cr.schema, isInTableNode(cr.view.state.selection.$from));
        },
        handlePaste: function(gr, mr, vr) {
          return pasteToTable(gr, vr);
        },
        handleKeyDown: function(gr, mr) {
          return cr.eventEmitter.emit("keydown", cr.editorType, mr), !1;
        },
        handleDOMEvents: {
          paste: function(gr, mr) {
            var vr = mr.clipboardData || window.clipboardData, yr = vr == null ? void 0 : vr.items;
            if (yr) {
              var kr = toArray_1(yr).some(function(xr) {
                return xr.kind === "string" && xr.type === "text/rtf";
              });
              if (!kr) {
                var _r = pasteImageOnly(yr);
                _r && (mr.preventDefault(), emitImageBlobHook(cr.eventEmitter, _r, mr.type));
              }
            }
            return !1;
          },
          keyup: function(gr, mr) {
            return cr.eventEmitter.emit("keyup", cr.editorType, mr), !1;
          },
          scroll: function() {
            return cr.eventEmitter.emit("scroll", "editor"), !0;
          }
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view, getWwCommands());
    }, ar.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.view.dom.innerHTML);
    }, ar.prototype.getModel = function() {
      return this.view.state.doc;
    }, ar.prototype.getSelection = function() {
      var cr = this.view.state.selection, ur = cr.from, fr = cr.to;
      return [ur, fr];
    }, ar.prototype.getSchema = function() {
      return this.view.state.schema;
    }, ar.prototype.replaceSelection = function(cr, ur, fr) {
      var dr = this.view.state, gr = dr.schema, mr = dr.tr, vr = cr.split(`
`), yr = vr.map(function(xr) {
        return createParagraph(gr, createNodesWithWidget(xr, gr));
      }), kr = new distExports$5.Slice(distExports$5.Fragment.from(yr), 1, 1), _r = isNumber_1(ur) && isNumber_1(fr) ? mr.replaceRange(ur, fr, kr) : mr.replaceSelection(kr);
      this.view.dispatch(_r), this.focus();
    }, ar.prototype.deleteSelection = function(cr, ur) {
      var fr = this.view.state.tr, dr = isNumber_1(cr) && isNumber_1(ur) ? fr.deleteRange(cr, ur) : fr.deleteSelection();
      this.view.dispatch(dr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(cr, ur) {
      var fr = this.view.state, dr = fr.doc, gr = fr.selection, mr = gr.from, vr = gr.to;
      return isNumber_1(cr) && isNumber_1(ur) && (mr = cr, vr = ur), dr.textBetween(mr, vr, `
`);
    }, ar.prototype.setModel = function(cr, ur) {
      ur === void 0 && (ur = !1);
      var fr = this.view.state, dr = fr.tr, gr = fr.doc;
      this.view.dispatch(dr.replaceWith(0, gr.content.size, cr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.setSelection = function(cr, ur) {
      ur === void 0 && (ur = cr);
      var fr = this.view.state.tr, dr = createTextSelection(fr, cr, ur);
      this.view.dispatch(fr.setSelection(dr).scrollIntoView());
    }, ar.prototype.addWidget = function(cr, ur, fr) {
      var dr = this.view, gr = dr.dispatch, mr = dr.state;
      gr(mr.tr.setMeta("widget", { pos: fr != null ? fr : mr.selection.to, node: cr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(cr, ur, fr) {
      var dr = this.view.state, gr = dr.tr, mr = dr.schema, vr = createNodesWithWidget(fr, mr);
      this.view.dispatch(gr.replaceWith(cr, ur, vr));
    }, ar.prototype.getRangeInfoOfNode = function(cr) {
      var ur = this.view.state, fr = ur.doc, dr = ur.selection, gr = cr ? fr.resolve(cr) : dr.$from, mr = gr.marks(), vr = gr.node(), yr = gr.start(), kr = gr.end(), _r = vr.type.name;
      if (mr.length || _r === "paragraph") {
        var xr = mr[mr.length - 1], Sr = function(Er) {
          return Er.length ? includes(Er, xr) : !0;
        };
        _r = xr ? xr.type.name : "text", vr.forEach(function(Er, Cr) {
          var Tr = Er.isText, Ar = Er.nodeSize, Ir = Er.marks, Mr = gr.pos - yr;
          Tr && Cr <= Mr && Cr + Ar >= Mr && Sr(Ir) && (yr = yr + Cr, kr = yr + Ar);
        });
      }
      return { range: [yr, kr], type: _r };
    }, ar;
  }(EditorBase)
), isUndefined = isUndefined_1, isNull = isNull_1;
function isExisty$1(lr) {
  return !isUndefined(lr) && !isNull(lr);
}
var isExisty_1 = isExisty$1, isExisty = isExisty_1;
function isTruthy$1(lr) {
  return isExisty(lr) && lr !== !1;
}
var isTruthy_1 = isTruthy$1, isTruthy = isTruthy_1;
function isFalsy(lr) {
  return !isTruthy(lr);
}
var isFalsy_1 = isFalsy, eventTypeList = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
], EventEmitter = (
  /** @class */
  function() {
    function lr() {
      var ar = this;
      this.events = new Map$1(), this.eventTypes = eventTypeList.reduce(function(cr, ur) {
        return __assign$1(__assign$1({}, cr), { type: ur });
      }, {}), this.hold = !1, eventTypeList.forEach(function(cr) {
        ar.addEventType(cr);
      });
    }
    return lr.prototype.listen = function(ar, cr) {
      var ur = this.getTypeInfo(ar), fr = this.events.get(ur.type) || [];
      if (!this.hasEventType(ur.type))
        throw new Error("There is no event type " + ur.type);
      ur.namespace && (cr.namespace = ur.namespace), fr.push(cr), this.events.set(ur.type, fr);
    }, lr.prototype.emit = function(ar) {
      for (var cr = [], ur = 1; ur < arguments.length; ur++)
        cr[ur - 1] = arguments[ur];
      var fr = this.getTypeInfo(ar), dr = this.events.get(fr.type), gr = [];
      return !this.hold && dr && dr.forEach(function(mr) {
        var vr = mr.apply(void 0, cr);
        isUndefined_1(vr) || gr.push(vr);
      }), gr;
    }, lr.prototype.emitReduce = function(ar, cr) {
      for (var ur = [], fr = 2; fr < arguments.length; fr++)
        ur[fr - 2] = arguments[fr];
      var dr = this.events.get(ar);
      return !this.hold && dr && dr.forEach(function(gr) {
        var mr = gr.apply(void 0, __spreadArray$1([cr], ur));
        isFalsy_1(mr) || (cr = mr);
      }), cr;
    }, lr.prototype.getTypeInfo = function(ar) {
      var cr = ar.split(".");
      return {
        type: cr[0],
        namespace: cr[1]
      };
    }, lr.prototype.hasEventType = function(ar) {
      return !isUndefined_1(this.eventTypes[this.getTypeInfo(ar).type]);
    }, lr.prototype.addEventType = function(ar) {
      if (this.hasEventType(ar))
        throw new Error("There is already have event type " + ar);
      this.eventTypes[ar] = ar;
    }, lr.prototype.removeEventHandler = function(ar, cr) {
      var ur = this, fr = this.getTypeInfo(ar), dr = fr.type, gr = fr.namespace;
      dr && cr ? this.removeEventHandlerWithHandler(dr, cr) : dr && !gr ? this.events.delete(dr) : !dr && gr ? this.events.forEach(function(mr, vr) {
        ur.removeEventHandlerWithTypeInfo(vr, gr);
      }) : dr && gr && this.removeEventHandlerWithTypeInfo(dr, gr);
    }, lr.prototype.removeEventHandlerWithHandler = function(ar, cr) {
      var ur = this.events.get(ar);
      if (ur) {
        var fr = ur.indexOf(cr);
        ur.indexOf(cr) >= 0 && ur.splice(fr, 1);
      }
    }, lr.prototype.removeEventHandlerWithTypeInfo = function(ar, cr) {
      var ur = [], fr = this.events.get(ar);
      fr && (fr.map(function(dr) {
        return dr.namespace !== cr && ur.push(dr), null;
      }), this.events.set(ar, ur));
    }, lr.prototype.getEvents = function() {
      return this.events;
    }, lr.prototype.holdEventInvoke = function(ar) {
      this.hold = !0, ar(), this.hold = !1;
    }, lr;
  }()
), CommandManager = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      this.eventEmitter = ar, this.mdCommands = cr, this.wwCommands = ur, this.getEditorType = fr, this.initEvent();
    }
    return lr.prototype.initEvent = function() {
      var ar = this;
      this.eventEmitter.listen("command", function(cr, ur) {
        ar.exec(cr, ur);
      });
    }, lr.prototype.addCommand = function(ar, cr, ur) {
      ar === "markdown" ? this.mdCommands[cr] = ur : this.wwCommands[cr] = ur;
    }, lr.prototype.deleteCommand = function(ar, cr) {
      ar === "markdown" ? delete this.mdCommands[cr] : delete this.wwCommands[cr];
    }, lr.prototype.exec = function(ar, cr) {
      var ur = this.getEditorType();
      ur === "markdown" ? this.mdCommands[ar](cr) : this.wwCommands[ar](cr);
    }, lr;
  }()
);
function getTextWithoutTrailingNewline(lr) {
  return lr[lr.length - 1] === `
` ? lr.slice(0, lr.length - 1) : lr;
}
function isCustomHTMLInlineNode(lr, ar) {
  var cr = lr.schema, ur = ar.literal, fr = ur.match(reHTMLTag);
  if (fr) {
    var dr = fr[1], gr = fr[3], mr = (dr || gr).toLowerCase();
    return ar.type === "htmlInline" && !!(cr.marks[mr] || cr.nodes[mr]);
  }
  return !1;
}
function isInlineNode(lr) {
  var ar = lr.type;
  return includes(["text", "strong", "emph", "strike", "image", "link", "code"], ar);
}
function isSoftbreak(lr) {
  return (lr == null ? void 0 : lr.type) === "softbreak";
}
function isListNode(lr) {
  var ar = lr.type, cr = lr.literal, ur = ar === "htmlInline" && cr.match(reHTMLTag);
  if (ur) {
    var fr = ur[1], dr = ur[3], gr = fr || dr;
    if (gr)
      return includes(["ul", "ol", "li"], gr.toLowerCase());
  }
  return !1;
}
function getListItemAttrs(lr) {
  var ar = lr.literal, cr = /data-task/.test(ar), ur = /data-task-checked/.test(ar);
  return { task: cr, checked: ur };
}
function getMatchedAttributeValue(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  var ur = document.createElement("div");
  ur.innerHTML = sanitizeHTML(lr);
  var fr = ur.firstChild;
  return ar.map(function(dr) {
    return fr.getAttribute(dr) || "";
  });
}
function createConvertors(lr) {
  var ar = {};
  return Object.keys(lr).forEach(function(cr) {
    var ur = cr.split(", ");
    ur.forEach(function(fr) {
      var dr = fr.toLowerCase();
      ar[dr] = lr[cr];
    });
  }), ar;
}
var convertors = {
  "b, strong": function(lr, ar, cr) {
    var ur = lr.schema.marks.strong;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  "i, em": function(lr, ar, cr) {
    var ur = lr.schema.marks.emph;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  "s, del": function(lr, ar, cr) {
    var ur = lr.schema.marks.strike;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  code: function(lr, ar, cr) {
    var ur = lr.schema.marks.code;
    cr ? lr.openMark(ur.create({ rawHTML: cr })) : lr.closeMark(ur);
  },
  a: function(lr, ar, cr) {
    var ur = ar.literal, fr = lr.schema.marks.link;
    if (cr) {
      var dr = getMatchedAttributeValue(ur, "href")[0];
      lr.openMark(fr.create({
        linkUrl: dr,
        rawHTML: cr
      }));
    } else
      lr.closeMark(fr);
  },
  img: function(lr, ar, cr) {
    var ur = ar.literal;
    if (cr) {
      var fr = getMatchedAttributeValue(ur, "src", "alt"), dr = fr[0], gr = fr[1], mr = lr.schema.nodes.image;
      lr.addNode(mr, __assign$1({ rawHTML: cr, imageUrl: dr }, gr && { altText: gr }));
    }
  },
  hr: function(lr, ar, cr) {
    lr.addNode(lr.schema.nodes.thematicBreak, { rawHTML: cr });
  },
  br: function(lr, ar) {
    var cr = lr.schema.nodes.paragraph, ur = ar.parent, fr = ar.prev, dr = ar.next;
    (ur == null ? void 0 : ur.type) === "paragraph" ? (isSoftbreak(fr) && lr.openNode(cr), isSoftbreak(dr) ? lr.closeNode() : dr && (lr.closeNode(), lr.openNode(cr))) : (ur == null ? void 0 : ur.type) === "tableCell" && (fr && (isInlineNode(fr) || isCustomHTMLInlineNode(lr, fr)) && lr.closeNode(), dr && (isInlineNode(dr) || isCustomHTMLInlineNode(lr, dr)) && lr.openNode(cr));
  },
  pre: function(lr, ar, cr) {
    var ur, fr, dr = document.createElement("div");
    dr.innerHTML = ar.literal;
    var gr = (fr = (ur = dr.firstChild) === null || ur === void 0 ? void 0 : ur.firstChild) === null || fr === void 0 ? void 0 : fr.textContent;
    lr.openNode(lr.schema.nodes.codeBlock, { rawHTML: cr }), lr.addText(getTextWithoutTrailingNewline(gr)), lr.closeNode();
  },
  "ul, ol": function(lr, ar, cr) {
    if (ar.parent.type === "tableCell") {
      var ur = lr.schema.nodes, fr = ur.bulletList, dr = ur.orderedList, gr = ur.paragraph, mr = cr === "ul" ? fr : dr;
      cr ? (ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.openNode(mr, { rawHTML: cr })) : (lr.closeNode(), ar.next && !isListNode(ar.next) && lr.openNode(gr));
    }
  },
  li: function(lr, ar, cr) {
    var ur;
    if (((ur = ar.parent) === null || ur === void 0 ? void 0 : ur.type) === "tableCell") {
      var fr = lr.schema.nodes, dr = fr.listItem, gr = fr.paragraph;
      if (cr) {
        var mr = getListItemAttrs(ar);
        ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.openNode(dr, __assign$1({ rawHTML: cr }, mr)), ar.next && !isListNode(ar.next) && lr.openNode(gr);
      } else
        ar.prev && !isListNode(ar.prev) && lr.closeNode(), lr.closeNode();
    }
  }
}, htmlToWwConvertors = createConvertors(convertors);
function isBRTag(lr) {
  return lr.type === "htmlInline" && reBR.test(lr.literal);
}
function addRawHTMLAttributeToDOM(lr) {
  toArray_1(lr.childNodes).forEach(function(ar) {
    if (isElemNode(ar)) {
      var cr = ar.nodeName.toLowerCase();
      ar.setAttribute("data-raw-html", cr), ar.childNodes && addRawHTMLAttributeToDOM(ar);
    }
  });
}
var toWwConvertors = {
  text: function(lr, ar) {
    lr.addText(ar.literal || "");
  },
  paragraph: function(lr, ar, cr, ur) {
    var fr, dr = cr.entering;
    if (dr) {
      var gr = lr.schema.nodes.paragraph;
      ((fr = ar.prev) === null || fr === void 0 ? void 0 : fr.type) === "paragraph" && (lr.openNode(gr, ur), lr.closeNode()), lr.openNode(gr, ur);
    } else
      lr.closeNode();
  },
  heading: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    if (fr) {
      var dr = ar, gr = dr.level, mr = dr.headingType;
      lr.openNode(lr.schema.nodes.heading, __assign$1({ level: gr, headingType: mr }, ur));
    } else
      lr.closeNode();
  },
  codeBlock: function(lr, ar, cr) {
    var ur = lr.schema.nodes.codeBlock, fr = ar, dr = fr.info, gr = fr.literal;
    lr.openNode(ur, __assign$1({ language: dr }, cr)), lr.addText(getTextWithoutTrailingNewline(gr || "")), lr.closeNode();
  },
  list: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    if (fr) {
      var dr = lr.schema.nodes, gr = dr.bulletList, mr = dr.orderedList, vr = ar.listData, yr = vr.type, kr = vr.start;
      yr === "bullet" ? lr.openNode(gr, ur) : lr.openNode(mr, __assign$1({ order: kr }, ur));
    } else
      lr.closeNode();
  },
  item: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.nodes.listItem, gr = ar.listData, mr = gr.task, vr = gr.checked;
    if (fr) {
      var yr = __assign$1(__assign$1(__assign$1({}, mr && { task: mr }), vr && { checked: vr }), ur);
      lr.openNode(dr, yr);
    } else
      lr.closeNode();
  },
  blockQuote: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.blockQuote, ur) : lr.closeNode();
  },
  image: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = cr.skipChildren, gr = lr.schema.nodes.image, mr = ar, vr = mr.destination, yr = mr.firstChild;
    fr && dr && dr(), lr.addNode(gr, __assign$1(__assign$1({ imageUrl: vr }, yr && { altText: yr.literal }), ur));
  },
  thematicBreak: function(lr, ar, cr, ur) {
    lr.addNode(lr.schema.nodes.thematicBreak, ur);
  },
  strong: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.strong;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  emph: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.emph;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  link: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.link, gr = ar, mr = gr.destination, vr = gr.title;
    if (fr) {
      var yr = __assign$1({ linkUrl: mr, title: vr }, ur);
      lr.openMark(dr.create(yr));
    } else
      lr.closeMark(dr);
  },
  softbreak: function(lr, ar) {
    if (ar.parent.type === "paragraph") {
      var cr = ar.prev, ur = ar.next;
      cr && !isBRTag(cr) && lr.closeNode(), ur && !isBRTag(ur) && lr.openNode(lr.schema.nodes.paragraph);
    }
  },
  // GFM specifications node
  table: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.table, ur) : lr.closeNode();
  },
  tableHead: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableHead, ur) : lr.closeNode();
  },
  tableBody: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableBody, ur) : lr.closeNode();
  },
  tableRow: function(lr, ar, cr, ur) {
    var fr = cr.entering;
    fr ? lr.openNode(lr.schema.nodes.tableRow, ur) : lr.closeNode();
  },
  tableCell: function(lr, ar, cr) {
    var ur = cr.entering;
    if (!ar.ignored) {
      var fr = function(Er) {
        return Er && (isInlineNode(Er) || isCustomHTMLInlineNode(lr, Er));
      };
      if (ur) {
        var dr = lr.schema.nodes, gr = dr.tableHeadCell, mr = dr.tableBodyCell, vr = dr.paragraph, yr = ar.parent.parent, kr = yr.type === "tableHead" ? gr : mr, _r = yr.parent, xr = (_r.columns[ar.startIdx] || {}).align, Sr = __assign$1({}, ar.attrs);
        xr && (Sr.align = xr), lr.openNode(kr, Sr), fr(ar.firstChild) && lr.openNode(vr);
      } else
        fr(ar.lastChild) && lr.closeNode(), lr.closeNode();
    }
  },
  strike: function(lr, ar, cr, ur) {
    var fr = cr.entering, dr = lr.schema.marks.strike;
    fr ? lr.openMark(dr.create(ur)) : lr.closeMark(dr);
  },
  code: function(lr, ar, cr, ur) {
    var fr = lr.schema.marks.code;
    lr.openMark(fr.create(ur)), lr.addText(getTextWithoutTrailingNewline(ar.literal || "")), lr.closeMark(fr);
  },
  customBlock: function(lr, ar) {
    var cr = lr.schema.nodes, ur = cr.customBlock, fr = cr.paragraph, dr = ar, gr = dr.info, mr = dr.literal;
    lr.openNode(ur, { info: gr }), lr.addText(getTextWithoutTrailingNewline(mr || "")), lr.closeNode(), ar.next || (lr.openNode(fr), lr.closeNode());
  },
  frontMatter: function(lr, ar) {
    lr.openNode(lr.schema.nodes.frontMatter), lr.addText(ar.literal), lr.closeNode();
  },
  htmlInline: function(lr, ar) {
    var cr = ar.literal, ur = cr.match(reHTMLTag), fr = ur[1], dr = ur[3], gr = (fr || dr).toLowerCase(), mr = lr.schema.marks[gr], vr = sanitizeHTML(cr);
    if (mr != null && mr.spec.attrs.htmlInline)
      if (fr) {
        var yr = getHTMLAttrsByHTMLString(vr);
        lr.openMark(mr.create({ htmlAttrs: yr }));
      } else
        lr.closeMark(mr);
    else {
      var kr = htmlToWwConvertors[gr];
      kr && kr(lr, ar, fr);
    }
  },
  htmlBlock: function(lr, ar) {
    var cr = ar.literal, ur = document.createElement("div"), fr = reHTMLComment.test(cr);
    if (fr)
      lr.openNode(lr.schema.nodes.htmlComment), lr.addText(ar.literal), lr.closeNode();
    else {
      var dr = cr.match(reHTMLTag), gr = dr[1], mr = dr[3], vr = (gr || mr).toLowerCase(), yr = lr.schema.nodes[vr], kr = sanitizeHTML(cr);
      if (yr != null && yr.spec.attrs.htmlBlock) {
        var _r = getHTMLAttrsByHTMLString(kr), xr = getChildrenHTML(ar, vr);
        lr.addNode(yr, { htmlAttrs: _r, childrenHTML: xr });
      } else
        ur.innerHTML = kr, addRawHTMLAttributeToDOM(ur), lr.convertByDOMParser(ur);
    }
  },
  customInline: function(lr, ar, cr) {
    var ur = cr.entering, fr = cr.skipChildren, dr = ar, gr = dr.info, mr = dr.firstChild, vr = lr.schema;
    if (gr.indexOf("widget") !== -1 && ur) {
      var yr = getWidgetContent(ar);
      fr(), lr.addNode(vr.nodes.widget, { info: gr }, [
        vr.text(createWidgetContent(gr, yr))
      ]);
    } else {
      var kr = "$$";
      ur && (kr += mr ? gr + " " : gr), lr.addText(kr);
    }
  }
};
function createWwConvertors(lr) {
  var ar = Object.keys(lr), cr = __assign$1({}, toWwConvertors), ur = new Renderer({
    gfm: !0,
    nodeId: !0,
    convertors: lr
  }), fr = ur.getConvertors();
  return ar.forEach(function(dr) {
    var gr = toWwConvertors[dr];
    gr && !includes(["htmlBlock", "htmlInline"], dr) && (cr[dr] = function(mr, vr, yr) {
      yr.origin = function() {
        return fr[dr](vr, yr, fr);
      };
      var kr = lr[dr](vr, yr), _r;
      if (kr) {
        var xr = Array.isArray(kr) ? kr[0] : kr, Sr = xr.attributes, Er = xr.classNames;
        _r = { htmlAttrs: Sr, classNames: Er };
      }
      gr(mr, vr, yr, _r);
    });
  }), cr;
}
function mergeMarkText(lr, ar) {
  return lr.isText && ar.isText && distExports$5.Mark.sameSet(lr.marks, ar.marks) ? lr.withText(lr.text + ar.text) : !1;
}
var ToWwConvertorState = (
  /** @class */
  function() {
    function lr(ar, cr) {
      this.schema = ar, this.convertors = cr, this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }], this.marks = distExports$5.Mark.none;
    }
    return lr.prototype.top = function() {
      return last$1(this.stack);
    }, lr.prototype.push = function(ar) {
      this.stack.length && this.top().content.push(ar);
    }, lr.prototype.addText = function(ar) {
      if (ar) {
        var cr = this.top().content, ur = last$1(cr), fr = this.schema.text(ar, this.marks), dr = ur && mergeMarkText(ur, fr);
        dr ? cr[cr.length - 1] = dr : cr.push(fr);
      }
    }, lr.prototype.openMark = function(ar) {
      this.marks = ar.addToSet(this.marks);
    }, lr.prototype.closeMark = function(ar) {
      this.marks = ar.removeFromSet(this.marks);
    }, lr.prototype.addNode = function(ar, cr, ur) {
      var fr = ar.createAndFill(cr, ur, this.marks);
      return fr ? (this.push(fr), fr) : null;
    }, lr.prototype.openNode = function(ar, cr) {
      this.stack.push({ type: ar, attrs: cr, content: [] });
    }, lr.prototype.closeNode = function() {
      this.marks.length && (this.marks = distExports$5.Mark.none);
      var ar = this.stack.pop(), cr = ar.type, ur = ar.attrs, fr = ar.content;
      return this.addNode(cr, ur, fr);
    }, lr.prototype.convertByDOMParser = function(ar) {
      var cr = this, ur = distExports$5.DOMParser.fromSchema(this.schema).parse(ar);
      ur.content.forEach(function(fr) {
        return cr.push(fr);
      });
    }, lr.prototype.closeUnmatchedHTMLInline = function(ar, cr) {
      var ur;
      if (!cr && ar.type !== "htmlInline")
        for (var fr = this.stack.length - 1, dr = fr; dr >= 0; dr -= 1) {
          var gr = this.stack[dr];
          if (!((ur = gr.attrs) === null || ur === void 0) && ur.rawHTML)
            gr.content.length ? this.closeNode() : this.stack.pop();
          else
            break;
        }
    }, lr.prototype.convert = function(ar, cr) {
      for (var ur = ar.walker(), fr = ur.next(), dr = function() {
        var mr = fr.node, vr = fr.entering, yr = gr.convertors[mr.type], kr = !1;
        if (yr) {
          var _r = {
            entering: vr,
            leaf: !isContainer$2(mr),
            getChildrenText: getChildrenText$1,
            options: { gfm: !0, nodeId: !1, tagFilter: !1, softbreak: `
` },
            skipChildren: function() {
              kr = !0;
            }
          };
          if (gr.closeUnmatchedHTMLInline(mr, vr), yr(gr, mr, _r), (cr == null ? void 0 : cr.node) === mr) {
            var xr = gr.stack.reduce(function(Sr, Er) {
              return Sr + Er.content.reduce(function(Cr, Tr) {
                return Cr + Tr.nodeSize;
              }, 0);
            }, 0) + 1;
            cr.setMappedPos(xr);
          }
        }
        kr && (ur.resumeAt(mr, !1), ur.next()), fr = ur.next();
      }, gr = this; fr; )
        dr();
    }, lr.prototype.convertNode = function(ar, cr) {
      return this.convert(ar, cr), this.stack.length ? this.closeNode() : null;
    }, lr;
  }()
);
function convertToRawHTMLHavingInlines(lr, ar, cr) {
  var ur = cr[0], fr = cr[1];
  lr.write(ur), lr.convertInline(ar), lr.write(fr);
}
function convertToRawHTMLHavingBlocks(lr, ar, cr) {
  var ur = ar.node, fr = ar.parent, dr = cr[0], gr = cr[1];
  lr.stopNewline = !0, lr.write(dr), lr.convertNode(ur), lr.write(gr), (fr == null ? void 0 : fr.type.name) === "doc" && (lr.closeBlock(ur), lr.stopNewline = !1);
}
function createTableHeadDelim(lr, ar) {
  var cr = lr.length, ur = "", fr = "";
  return ar === "left" ? (ur = ":", cr -= 1) : ar === "right" ? (fr = ":", cr -= 1) : ar === "center" && (ur = ":", fr = ":", cr -= 2), "" + ur + repeat$1("-", Math.max(cr, 3)) + fr;
}
var nodeTypeWriters = {
  text: function(lr, ar) {
    var cr, ur = ar.node, fr = (cr = ur.text) !== null && cr !== void 0 ? cr : "";
    (ur.marks || []).some(function(dr) {
      return dr.type.name === "link";
    }) ? lr.text(escapeTextForLink(fr), !1) : lr.text(fr);
  },
  paragraph: function(lr, ar) {
    var cr = ar.node, ur = ar.parent, fr = ar.index, dr = fr === void 0 ? 0 : fr;
    if (lr.stopNewline)
      lr.convertInline(cr);
    else {
      var gr = dr === 0, mr = !gr && ur.child(dr - 1), vr = mr && mr.childCount === 0, yr = dr < ur.childCount - 1 && ur.child(dr + 1), kr = yr && yr.type.name === "paragraph", _r = cr.childCount === 0;
      if (_r && vr)
        lr.write(`<br>
`);
      else if (_r && !vr && !gr) {
        if ((ur == null ? void 0 : ur.type.name) === "listItem") {
          var xr = lr.getDelim();
          lr.setDelim(""), lr.write("<br>"), lr.setDelim(xr);
        }
        lr.write(`
`);
      } else
        lr.convertInline(cr), kr ? lr.write(`
`) : lr.closeBlock(cr);
    }
  },
  heading: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = ur.attrs.headingType;
    dr === "atx" ? (lr.write(fr + " "), lr.convertInline(ur), lr.closeBlock(ur)) : (lr.convertInline(ur), lr.ensureNewLine(), lr.write(fr), lr.closeBlock(ur));
  },
  codeBlock: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = cr.text, gr = fr, mr = gr[0], vr = gr[1];
    lr.write(mr), lr.ensureNewLine(), lr.text(dr, !1), lr.ensureNewLine(), lr.write(vr), lr.closeBlock(ur);
  },
  blockQuote: function(lr, ar, cr) {
    var ur = ar.node, fr = ar.parent, dr = cr.delim;
    (fr == null ? void 0 : fr.type.name) === ur.type.name && lr.flushClose(1), lr.wrapBlock(dr, null, ur, function() {
      return lr.convertNode(ur);
    });
  },
  bulletList: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim;
    lr.convertList(ur, repeat$1(" ", 4), function() {
      return fr + " ";
    });
  },
  orderedList: function(lr, ar) {
    var cr = ar.node, ur = cr.attrs.order || 1;
    lr.convertList(cr, repeat$1(" ", 4), function(fr) {
      var dr = String(ur + fr);
      return dr + ". ";
    });
  },
  listItem: function(lr, ar) {
    var cr = ar.node, ur = cr.attrs, fr = ur.task, dr = ur.checked;
    fr && lr.write("[" + (dr ? "x" : " ") + "] "), lr.convertNode(cr);
  },
  image: function(lr, ar, cr) {
    var ur = cr.attrs;
    lr.write("![" + (ur == null ? void 0 : ur.altText) + "](" + (ur == null ? void 0 : ur.imageUrl) + ")");
  },
  thematicBreak: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim;
    lr.write(fr), lr.closeBlock(ur);
  },
  table: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr), lr.closeBlock(cr);
  },
  tableHead: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = ur.firstChild;
    lr.convertNode(ur);
    var gr = fr != null ? fr : "";
    !fr && dr && dr.forEach(function(mr) {
      var vr = mr.textContent, yr = mr.attrs, kr = createTableHeadDelim(vr, yr.align);
      gr += "| " + kr + " ";
    }), lr.write(gr + "|"), lr.ensureNewLine();
  },
  tableBody: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr);
  },
  tableRow: function(lr, ar) {
    var cr = ar.node;
    lr.convertNode(cr), lr.write("|"), lr.ensureNewLine();
  },
  tableHeadCell: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = fr === void 0 ? "| " : fr;
    lr.write(dr), lr.convertTableCell(ur), lr.write(" ");
  },
  tableBodyCell: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = fr === void 0 ? "| " : fr;
    lr.write(dr), lr.convertTableCell(ur), lr.write(" ");
  },
  customBlock: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.delim, dr = cr.text, gr = fr, mr = gr[0], vr = gr[1];
    lr.write(mr), lr.ensureNewLine(), lr.text(dr, !1), lr.ensureNewLine(), lr.write(vr), lr.closeBlock(ur);
  },
  frontMatter: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.text(fr, !1), lr.closeBlock(ur);
  },
  widget: function(lr, ar, cr) {
    var ur = cr.text;
    lr.write(ur);
  },
  html: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.write(fr), ur.attrs.htmlBlock && lr.closeBlock(ur);
  },
  htmlComment: function(lr, ar, cr) {
    var ur = ar.node, fr = cr.text;
    lr.write(fr), lr.closeBlock(ur);
  }
};
function write(lr, ar) {
  var cr = ar.state, ur = ar.nodeInfo, fr = ar.params, dr = fr.rawHTML;
  dr ? inArray_1(lr, ["heading", "codeBlock"]) > -1 ? convertToRawHTMLHavingInlines(cr, ur.node, dr) : inArray_1(lr, ["image", "thematicBreak"]) > -1 ? cr.write(dr) : convertToRawHTMLHavingBlocks(cr, ur, dr) : nodeTypeWriters[lr](cr, ur, fr);
}
function addBackticks(lr, ar) {
  var cr = lr.text, ur = /`+/g, fr = 0;
  if (lr.isText && cr)
    for (var dr = ur.exec(cr); dr; )
      fr = Math.max(fr, dr[0].length), dr = ur.exec(cr);
  for (var gr = fr > 0 && ar > 0 ? " `" : "`", mr = 0; mr < fr; mr += 1)
    gr += "`";
  return fr > 0 && ar < 0 && (gr += " "), gr;
}
function getPairRawHTML(lr) {
  return lr ? ["<" + lr + ">", "</" + lr + ">"] : null;
}
function getOpenRawHTML(lr) {
  return lr ? "<" + lr + ">" : null;
}
function getCloseRawHTML(lr) {
  return lr ? "</" + lr + ">" : null;
}
var toMdConvertors = {
  heading: function(lr) {
    var ar = lr.node, cr = ar.attrs, ur = cr.level, fr = repeat$1("#", ur);
    return cr.headingType === "setext" && (fr = ur === 1 ? "===" : "---"), {
      delim: fr,
      rawHTML: getPairRawHTML(cr.rawHTML)
    };
  },
  codeBlock: function(lr) {
    var ar = lr.node, cr = ar, ur = cr.attrs, fr = cr.textContent;
    return {
      delim: ["```" + (ur.language || ""), "```"],
      rawHTML: getPairRawHTML(ur.rawHTML),
      text: fr
    };
  },
  blockQuote: function(lr) {
    var ar = lr.node;
    return {
      delim: "> ",
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  bulletList: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs.rawHTML;
    return ur && (fr = fr || "ul"), {
      delim: "*",
      rawHTML: getPairRawHTML(fr)
    };
  },
  orderedList: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs.rawHTML;
    return ur && (fr = fr || "ol"), {
      rawHTML: getPairRawHTML(fr)
    };
  },
  listItem: function(lr, ar) {
    var cr = lr.node, ur = ar.inTable, fr = cr.attrs, dr = fr.task, gr = fr.checked, mr = cr.attrs.rawHTML;
    ur && (mr = mr || "li");
    var vr = dr ? ' class="task-list-item' + (gr ? " checked" : "") + '"' : "", yr = dr ? " data-task" + (gr ? " data-task-checked" : "") : "";
    return {
      rawHTML: mr ? ["<" + mr + vr + yr + ">", "</" + mr + ">"] : null
    };
  },
  table: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHead: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBody: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableRow: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHeadCell: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBodyCell: function(lr) {
    var ar = lr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  image: function(lr) {
    var ar = lr.node, cr = ar.attrs, ur = cr.rawHTML, fr = cr.altText, dr = cr.imageUrl.replace(/&amp;/g, "&"), gr = fr ? ' alt="' + escapeXml$1(fr) + '"' : "";
    return {
      rawHTML: ur ? "<" + ur + ' src="' + escapeXml$1(dr) + '"' + gr + ">" : null,
      attrs: {
        altText: escapeTextForLink(fr || ""),
        imageUrl: dr
      }
    };
  },
  thematicBreak: function(lr) {
    var ar = lr.node;
    return {
      delim: "***",
      rawHTML: getOpenRawHTML(ar.attrs.rawHTML)
    };
  },
  customBlock: function(lr) {
    var ar = lr.node, cr = ar, ur = cr.attrs, fr = cr.textContent;
    return {
      delim: ["$$" + ur.info, "$$"],
      text: fr
    };
  },
  frontMatter: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  widget: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  strong: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "**",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  emph: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "*",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  strike: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs.rawHTML;
    return {
      delim: "~~",
      rawHTML: ur ? getOpenRawHTML(fr) : getCloseRawHTML(fr)
    };
  },
  link: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.attrs, dr = fr.title, gr = fr.rawHTML, mr = fr.linkUrl.replace(/&amp;/g, "&"), vr = dr ? ' title="' + escapeXml$1(dr) + '"' : "";
    return ur ? {
      delim: "[",
      rawHTML: gr ? "<" + gr + ' href="' + escapeXml$1(mr) + '"' + vr + ">" : null
    } : {
      delim: "](" + mr + (dr ? " " + quote(escapeTextForLink(dr)) : "") + ")",
      rawHTML: getCloseRawHTML(gr)
    };
  },
  code: function(lr, ar) {
    var cr = lr.node, ur = lr.parent, fr = lr.index, dr = fr === void 0 ? 0 : fr, gr = ar.entering, mr = gr ? addBackticks(ur.child(dr), -1) : addBackticks(ur.child(dr - 1), 1), vr = gr ? getOpenRawHTML(cr.attrs.rawHTML) : getCloseRawHTML(cr.attrs.rawHTML);
    return {
      delim: mr,
      rawHTML: vr
    };
  },
  htmlComment: function(lr) {
    var ar = lr.node;
    return {
      text: ar.textContent
    };
  },
  // html inline node, html block node
  html: function(lr, ar) {
    var cr = lr.node, ur = ar.entering, fr = cr.type.name, dr = cr.attrs.htmlAttrs, gr = "<" + fr, mr = "</" + fr + ">";
    return Object.keys(dr).forEach(function(vr) {
      gr += " " + vr + '="' + dr[vr].replace(/"/g, "'") + '"';
    }), gr += ">", cr.attrs.htmlInline ? {
      rawHTML: ur ? gr : mr
    } : {
      text: "" + gr + cr.attrs.childrenHTML + mr
    };
  }
}, markTypeOptions = {
  strong: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  emph: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  strike: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  code: {
    escape: !1
  },
  link: null,
  html: null
};
function createNodeTypeConvertors(lr) {
  var ar = {}, cr = Object.keys(nodeTypeWriters);
  return cr.forEach(function(ur) {
    ar[ur] = function(fr, dr) {
      var gr = nodeTypeWriters[ur];
      if (gr) {
        var mr = lr[ur], vr = mr ? mr(dr, {
          inTable: fr.inTable
        }) : {};
        write(ur, { state: fr, nodeInfo: dr, params: vr });
      }
    };
  }), ar;
}
function createMarkTypeConvertors(lr) {
  var ar = {}, cr = Object.keys(markTypeOptions);
  return cr.forEach(function(ur) {
    ar[ur] = function(fr, dr) {
      var gr = markTypeOptions[ur], mr = lr[ur], vr = mr && fr && !isUndefined_1(dr), yr = vr ? mr(fr, { entering: dr }) : {};
      return __assign$1(__assign$1({}, yr), gr);
    };
  }), ar;
}
function createMdConvertors(lr) {
  var ar = Object.keys(lr);
  ar.forEach(function(fr) {
    var dr = toMdConvertors[fr], gr = lr[fr];
    dr ? toMdConvertors[fr] = function(mr, vr) {
      return vr.origin = function() {
        return dr(mr, vr);
      }, gr(mr, vr);
    } : toMdConvertors[fr] = gr, delete lr[fr];
  });
  var cr = createNodeTypeConvertors(toMdConvertors), ur = createMarkTypeConvertors(toMdConvertors);
  return {
    nodeTypeConvertors: cr,
    markTypeConvertors: ur
  };
}
var ToMdConvertorState = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = ar.nodeTypeConvertors, ur = ar.markTypeConvertors;
      this.nodeTypeConvertors = cr, this.markTypeConvertors = ur, this.delim = "", this.result = "", this.closed = !1, this.tightList = !1, this.stopNewline = !1, this.inTable = !1;
    }
    return lr.prototype.getMarkConvertor = function(ar) {
      var cr = ar.attrs.htmlInline ? "html" : ar.type.name;
      return this.markTypeConvertors[cr];
    }, lr.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    }, lr.prototype.markText = function(ar, cr, ur, fr) {
      var dr = this.getMarkConvertor(ar);
      if (dr) {
        var gr = dr({ node: ar, parent: ur, index: fr }, cr), mr = gr.delim, vr = gr.rawHTML;
        return vr || mr;
      }
      return "";
    }, lr.prototype.setDelim = function(ar) {
      this.delim = ar;
    }, lr.prototype.getDelim = function() {
      return this.delim;
    }, lr.prototype.flushClose = function(ar) {
      if (!this.stopNewline && this.closed) {
        if (this.isInBlank() || (this.result += `
`), ar || (ar = 2), ar > 1) {
          var cr = this.delim, ur = /\s+$/.exec(cr);
          ur && (cr = cr.slice(0, cr.length - ur[0].length));
          for (var fr = 1; fr < ar; fr += 1)
            this.result += cr + `
`;
        }
        this.closed = !1;
      }
    }, lr.prototype.wrapBlock = function(ar, cr, ur, fr) {
      var dr = this.getDelim();
      this.write(cr || ar), this.setDelim(this.getDelim() + ar), fr(), this.setDelim(dr), this.closeBlock(ur);
    }, lr.prototype.ensureNewLine = function() {
      this.isInBlank() || (this.result += `
`);
    }, lr.prototype.write = function(ar) {
      ar === void 0 && (ar = ""), this.flushClose(), this.delim && this.isInBlank() && (this.result += this.delim), ar && (this.result += ar);
    }, lr.prototype.closeBlock = function(ar) {
      this.closed = ar;
    }, lr.prototype.text = function(ar, cr) {
      cr === void 0 && (cr = !0);
      for (var ur = ar.split(`
`), fr = 0; fr < ur.length; fr += 1)
        this.write(), this.result += cr ? escape$1$1(ur[fr]) : ur[fr], fr !== ur.length - 1 && (this.result += `
`);
    }, lr.prototype.convertBlock = function(ar, cr, ur) {
      var fr = ar.type.name, dr = this.nodeTypeConvertors[fr], gr = { node: ar, parent: cr, index: ur };
      ar.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, gr) : dr && dr(this, gr);
    }, lr.prototype.convertInline = function(ar) {
      var cr = this, ur = [], fr = "", dr = function(gr, mr, vr) {
        var yr = gr ? gr.marks : [], kr = fr;
        fr = "";
        var _r = gr && gr.isText && yr.some(function(li) {
          var Qr = cr.getMarkConvertor(li), ei = Qr && Qr();
          return ei && ei.removedEnclosingWhitespace;
        });
        if (_r && gr && gr.text) {
          var xr = /^(\s*)(.*?)(\s*)$/m.exec(gr.text), Sr = xr[1], Er = xr[2], Cr = xr[3];
          kr += Sr, fr = Cr, (Sr || Cr) && (gr = Er ? gr.withText(Er) : null, gr || (yr = ur));
        }
        for (var Tr = yr.length && last$1(yr), Ar = Tr && cr.getMarkConvertor(Tr), Ir = Ar && Ar(), Mr = Ir && Ir.escape === !1, Hr = yr.length - (Mr ? 1 : 0), Br = 0; Br < Hr; Br += 1) {
          var Er = yr[Br];
          if (Ir && !Ir.mixable)
            break;
          for (var zr = 0; zr < ur.length; zr += 1) {
            var Gr = ur[zr];
            if (Ir && !Ir.mixable)
              break;
            if (Er.eq(Gr)) {
              Br > zr ? yr = yr.slice(0, zr).concat(Er).concat(yr.slice(zr, Br)).concat(yr.slice(Br + 1, Hr)) : zr > Br && (yr = yr.slice(0, Br).concat(yr.slice(Br + 1, zr)).concat(Er).concat(yr.slice(zr, Hr)));
              break;
            }
          }
        }
        for (var Xr = 0; Xr < Math.min(ur.length, Hr) && yr[Xr].eq(ur[Xr]); )
          Xr += 1;
        for (; Xr < ur.length; ) {
          var Jr = ur.pop();
          Jr && cr.text(cr.markText(Jr, !1, ar, vr), !1);
        }
        if (kr && cr.text(kr), gr) {
          for (; ur.length < Hr; ) {
            var Er = yr[ur.length];
            ur.push(Er), cr.text(cr.markText(Er, !0, ar, vr), !1);
          }
          Mr && gr.isText ? cr.text(cr.markText(Tr, !0, ar, vr) + gr.text + cr.markText(Tr, !1, ar, vr + 1), !1) : cr.convertBlock(gr, ar, vr);
        }
      };
      ar.forEach(dr), dr(null, null, ar.childCount);
    }, lr.prototype.convertList = function(ar, cr, ur) {
      var fr = this, dr;
      this.closed && this.closed.type === ar.type ? this.flushClose(3) : this.tightList && this.flushClose(1);
      var gr = (dr = ar.attrs.tight) !== null && dr !== void 0 ? dr : !0, mr = this.tightList;
      this.tightList = gr, ar.forEach(function(vr, yr, kr) {
        kr && gr && fr.flushClose(1), fr.wrapBlock(cr, ur(kr), ar, function() {
          return fr.convertBlock(vr, ar, kr);
        });
      }), this.tightList = mr;
    }, lr.prototype.convertTableCell = function(ar) {
      var cr = this;
      this.stopNewline = !0, this.inTable = !0, ar.forEach(function(ur, fr, dr) {
        if (includes(["bulletList", "orderedList"], ur.type.name))
          cr.convertBlock(ur, ar, dr), cr.closed = !1;
        else if (cr.convertInline(ur), dr < ar.childCount - 1) {
          var gr = ar.child(dr + 1);
          gr.type.name === "paragraph" && cr.write("<br>");
        }
      }), this.stopNewline = !1, this.inTable = !1;
    }, lr.prototype.convertNode = function(ar, cr) {
      var ur = this;
      return ar.forEach(function(fr, dr, gr) {
        if (ur.convertBlock(fr, ar, gr), (cr == null ? void 0 : cr.node) === fr) {
          var mr = ur.result.split(`
`);
          cr.setMappedPos([mr.length, last$1(mr).length + 1]);
        }
      }), this.result;
    }, lr;
  }()
), Convertor = (
  /** @class */
  function() {
    function lr(ar, cr, ur, fr) {
      var dr = this;
      this.setMappedPos = function(gr) {
        dr.mappedPosWhenConverting = gr;
      }, this.schema = ar, this.eventEmitter = fr, this.focusedNode = null, this.mappedPosWhenConverting = null, this.toWwConvertors = createWwConvertors(ur), this.toMdConvertors = createMdConvertors(cr || {}), this.eventEmitter.listen("setFocusedNode", function(gr) {
        return dr.focusedNode = gr;
      });
    }
    return lr.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    }, lr.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    }, lr.prototype.toWysiwygModel = function(ar) {
      var cr = new ToWwConvertorState(this.schema, this.toWwConvertors);
      return cr.convertNode(ar, this.getInfoForPosSync());
    }, lr.prototype.toMarkdownText = function(ar) {
      var cr = new ToMdConvertorState(this.toMdConvertors), ur = cr.convertNode(ar, this.getInfoForPosSync());
      return ur = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", ur), ur;
    }, lr;
  }()
);
function execPlugin(lr) {
  var ar = lr.plugin, cr = lr.eventEmitter, ur = lr.usageStatistics, fr = lr.instance, dr = { Plugin: distExports$3.Plugin, PluginKey: distExports$3.PluginKey, Selection: distExports$3.Selection, TextSelection: distExports$3.TextSelection }, gr = { Decoration: distExports$4.Decoration, DecorationSet: distExports$4.DecorationSet }, mr = { Fragment: distExports$5.Fragment }, vr = { InputRule: distExports$1.InputRule, inputRules: distExports$1.inputRules, undoInputRule: distExports$1.undoInputRule }, yr = { keymap: distExports$2.keymap }, kr = {
    eventEmitter: cr,
    usageStatistics: ur,
    instance: fr,
    pmState: dr,
    pmView: gr,
    pmModel: mr,
    pmRules: vr,
    pmKeymap: yr,
    i18n
  };
  if (isArray_1(ar)) {
    var _r = ar[0], xr = ar[1], Sr = xr === void 0 ? {} : xr;
    return _r(kr, Sr);
  }
  return ar(kr);
}
function getPluginInfo(lr) {
  var ar = lr.plugins, cr = lr.eventEmitter, ur = lr.usageStatistics, fr = lr.instance;
  return cr.listen("mixinTableOffsetMapPrototype", mixinTableOffsetMapPrototype), (ar != null ? ar : []).reduce(function(dr, gr) {
    var mr = execPlugin({
      plugin: gr,
      eventEmitter: cr,
      usageStatistics: ur,
      instance: fr
    });
    if (!mr)
      throw new Error("The return value of the executed plugin is empty.");
    var vr = mr.markdownParsers, yr = mr.toHTMLRenderers, kr = mr.toMarkdownRenderers, _r = mr.markdownPlugins, xr = mr.wysiwygPlugins, Sr = mr.wysiwygNodeViews, Er = mr.markdownCommands, Cr = mr.wysiwygCommands, Tr = mr.toolbarItems;
    return yr && (dr.toHTMLRenderers = deepMergedCopy(dr.toHTMLRenderers, yr)), kr && (dr.toMarkdownRenderers = deepMergedCopy(dr.toMarkdownRenderers, kr)), _r && (dr.mdPlugins = dr.mdPlugins.concat(_r)), xr && (dr.wwPlugins = dr.wwPlugins.concat(xr)), Sr && (dr.wwNodeViews = __assign$1(__assign$1({}, dr.wwNodeViews), Sr)), Er && (dr.mdCommands = __assign$1(__assign$1({}, dr.mdCommands), Er)), Cr && (dr.wwCommands = __assign$1(__assign$1({}, dr.wwCommands), Cr)), Tr && (dr.toolbarItems = dr.toolbarItems.concat(Tr)), vr && (dr.markdownParsers = __assign$1(__assign$1({}, dr.markdownParsers), vr)), dr;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var TASK_ATTR_NAME = "data-task", DISABLED_TASK_ATTR_NAME = "data-task-disabled", TASK_CHECKED_CLASS_NAME = "checked";
function registerHTMLTagToWhitelist(lr) {
  ["htmlBlock", "htmlInline"].forEach(function(ar) {
    lr[ar] && Object.keys(lr[ar]).forEach(function(cr) {
      return registerTagWhitelistIfPossible(cr);
    });
  });
}
var ToastUIEditorViewer = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = this;
      this.options = extend_1({
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        usageStatistics: !0,
        theme: "light"
      }, ar), this.eventEmitter = new EventEmitter();
      var ur = sanitizeLinkAttribute(this.options.linkAttributes), fr = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      }) || {}, dr = fr.toHTMLRenderers, gr = fr.markdownParsers, mr = this.options, vr = mr.customHTMLRenderer, yr = mr.extendedAutolinks, kr = mr.referenceDefinition, _r = mr.frontMatter, xr = mr.customHTMLSanitizer, Sr = {
        linkAttributes: ur,
        customHTMLRenderer: __assign$1(__assign$1({}, dr), vr),
        extendedAutolinks: yr,
        referenceDefinition: kr,
        frontMatter: _r,
        sanitizer: xr || sanitizeHTML
      };
      registerHTMLTagToWhitelist(Sr.customHTMLRenderer), this.options.events && forEachOwnProperties_1(this.options.events, function(Mr, Hr) {
        cr.on(Hr, Mr);
      });
      var Er = this.options, Cr = Er.el, Tr = Er.initialValue, Ar = Er.theme, Ir = Cr.innerHTML;
      Ar !== "light" && Cr.classList.add(cls(Ar)), Cr.innerHTML = "", this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: yr,
        referenceDefinition: kr,
        disallowDeepHeading: !0,
        frontMatter: _r,
        customParser: gr
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, Sr), { isViewer: !0 })), on_1(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), Tr ? this.setMarkdown(Tr) : Ir && this.preview.setHTML(Ir), Cr.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
    }
    return lr.prototype.toggleTask = function(ar) {
      var cr = ar.target, ur = getComputedStyle(cr, ":before");
      !cr.hasAttribute(DISABLED_TASK_ATTR_NAME) && cr.hasAttribute(TASK_ATTR_NAME) && isPositionInBox(ur, ar.offsetX, ar.offsetY) && (toggleClass(cr, TASK_CHECKED_CLASS_NAME), this.eventEmitter.emit("change", {
        source: "viewer",
        date: ar
      }));
    }, lr.prototype.setMarkdown = function(ar) {
      var cr = this.toastMark.getLineTexts(), ur = cr.length, fr = last$1(cr), dr = [ur, fr.length + 1], gr = this.toastMark.editMarkdown([1, 1], dr, ar || "");
      this.eventEmitter.emit("updatePreview", gr);
    }, lr.prototype.on = function(ar, cr) {
      this.eventEmitter.listen(ar, cr);
    }, lr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.addHook = function(ar, cr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, cr);
    }, lr.prototype.destroy = function() {
      off_1(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
    }, lr.prototype.isViewer = function() {
      return !0;
    }, lr.prototype.isMarkdownMode = function() {
      return !1;
    }, lr.prototype.isWysiwygMode = function() {
      return !1;
    }, lr;
  }()
);
function isPmNode(lr) {
  return lr instanceof distExports$5.Node;
}
function isContainer(lr) {
  var ar = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return includes(ar, lr);
}
function createMdLikeNode(lr) {
  var ar = lr.attrs, cr = lr.type, ur = cr.name, fr = {
    type: ur,
    wysiwygNode: !0,
    literal: !isContainer(ur) && isPmNode(lr) ? lr.textContent : null
  }, dr = {
    heading: { level: ar.level },
    link: { destination: ar.linkUrl, title: ar.title },
    image: { destination: ar.imageUrl },
    codeBlock: { info: ar.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: ar.order } },
    listItem: { type: "item", listData: { task: ar.task, checked: ar.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: ar.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: ar.align },
    customBlock: { info: ar.info }
  }, gr = dr[ur], mr = __assign$1(__assign$1({}, fr), gr), vr = lr.attrs, yr = vr.htmlAttrs, kr = vr.childrenHTML;
  return yr ? __assign$1(__assign$1({}, mr), { attrs: yr, childrenHTML: kr }) : mr;
}
var tokenToDOMNode = {
  openTag: function(lr, ar) {
    var cr = lr, ur = cr.tagName, fr = cr.classNames, dr = cr.attributes, gr = document.createElement(ur), mr = {};
    fr && (gr.className = fr.join(" ")), dr && (mr = __assign$1(__assign$1({}, mr), dr)), setAttributes(mr, gr), ar.push(gr);
  },
  closeTag: function(lr, ar) {
    if (ar.length > 1) {
      var cr = ar.pop();
      last$1(ar).appendChild(cr);
    }
  },
  html: function(lr, ar) {
    last$1(ar).insertAdjacentHTML("beforeend", lr.content);
  },
  text: function(lr, ar) {
    var cr = document.createTextNode(lr.content);
    last$1(ar).appendChild(cr);
  }
}, WwToDOMAdaptor = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = getHTMLRenderConvertors(ar, cr), fr = __assign$1(__assign$1({}, cr.htmlBlock), cr.htmlInline);
      this.customConvertorKeys = Object.keys(cr).concat(Object.keys(fr)), this.renderer = new Renderer({
        gfm: !0,
        convertors: __assign$1(__assign$1({}, ur), fr)
      }), this.convertors = this.renderer.getConvertors();
    }
    return lr.prototype.generateTokens = function(ar) {
      var cr = createMdLikeNode(ar), ur = {
        entering: !0,
        leaf: isPmNode(ar) ? ar.isLeaf : !1,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return isPmNode(ar) ? ar.textContent : "";
        },
        skipChildren: function() {
          return !1;
        }
      }, fr = this.convertors[ar.type.name], dr = fr(cr, ur, this.convertors), gr = isArray_1(dr) ? dr : [dr];
      return (isContainer(ar.type.name) || ar.attrs.htmlInline) && (ur.entering = !1, gr.push({ type: "text", content: isPmNode(ar) ? ar.textContent : "" }), gr = gr.concat(fr(cr, ur, this.convertors))), gr;
    }, lr.prototype.toDOMNode = function(ar) {
      var cr = this.generateTokens(ar), ur = [];
      return cr.forEach(function(fr) {
        return tokenToDOMNode[fr.type](fr, ur);
      }), ur[0];
    }, lr.prototype.getToDOMNode = function(ar) {
      return includes(this.customConvertorKeys, ar) ? this.toDOMNode.bind(this) : null;
    }, lr;
  }()
), ANIMATION_TIME = 100, SCROLL_BLOCKING_RESET_DELAY = 15, currentTimeoutId = null, releaseTimer = null;
function run(lr, ar) {
  var cr = ar.syncScrollTop, ur = ar.releaseEventBlock;
  releaseTimer && clearTimeout(releaseTimer), cr(lr), releaseTimer = setTimeout(function() {
    ur();
  }, SCROLL_BLOCKING_RESET_DELAY);
}
function animate(lr, ar, cr) {
  var ur = ar - lr, fr = Date.now(), dr = function() {
    var gr = Date.now(), mr = (gr - fr) / ANIMATION_TIME, vr;
    currentTimeoutId && clearTimeout(currentTimeoutId), mr < 1 ? (vr = lr + ur * Math.cos((1 - mr) * Math.PI / 2), run(Math.ceil(vr), cr), currentTimeoutId = setTimeout(dr, 1)) : (run(ar, cr), currentTimeoutId = null);
  };
  dr();
}
var EDITOR_BOTTOM_PADDING = 18, ScrollSync = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      this.latestEditorScrollTop = null, this.latestPreviewScrollTop = null, this.blockedScroll = null, this.active = !0, this.timer = null;
      var fr = cr.previewContent, dr = cr.el;
      this.previewRoot = fr, this.previewEl = dr, this.mdEditor = ar, this.editorView = ar.view, this.toastMark = ar.getToastMark(), this.eventEmitter = ur, this.addScrollSyncEvent();
    }
    return lr.prototype.addScrollSyncEvent = function() {
      var ar = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        ar.clearTimer(), ar.timer = setTimeout(function() {
          ar.syncPreviewScrollTop(!0);
        }, 200);
      }), this.eventEmitter.listen("scroll", function(cr, ur) {
        ar.active && (cr === "editor" && ar.blockedScroll !== "editor" ? ar.syncPreviewScrollTop() : cr === "preview" && ar.blockedScroll !== "preview" && ar.syncEditorScrollTop(ur));
      }), this.eventEmitter.listen("toggleScrollSync", function(cr) {
        ar.active = cr;
      });
    }, lr.prototype.getMdNodeAtPos = function(ar, cr) {
      var ur = ar.content.findIndex(cr.pos), fr = ur.index;
      return this.toastMark.findFirstNodeAtLine(fr + 1);
    }, lr.prototype.getScrollTopByCaretPos = function() {
      var ar = this.mdEditor.getSelection(), cr = this.toastMark.findFirstNodeAtLine(ar[0][0]), ur = this.previewEl.clientHeight, fr = getParentNodeObj(this.previewRoot, cr).el, dr = getTotalOffsetTop(fr, this.previewRoot) || fr.offsetTop, gr = fr.clientHeight, mr = dr + gr - ur * 0.5;
      this.latestEditorScrollTop = null;
      var vr = fr.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return vr < ur ? null : mr;
    }, lr.prototype.syncPreviewScrollTop = function(ar) {
      ar === void 0 && (ar = !1);
      var cr = this, ur = cr.editorView, fr = cr.previewEl, dr = cr.previewRoot, gr = ur.dom.getBoundingClientRect(), mr = gr.left, vr = gr.top, yr = ur.posAtCoords({ left: mr, top: vr }), kr = ur.state.doc, _r = this.getMdNodeAtPos(kr, yr);
      if (!(!_r || isHTMLNode(_r))) {
        var xr = fr.scrollTop, Sr = ur.dom, Er = Sr.scrollTop, Cr = Sr.scrollHeight, Tr = Sr.clientHeight, Ar = Sr.children, Ir = Cr - Er <= Tr + EDITOR_BOTTOM_PADDING, Mr = Ir ? fr.scrollHeight : 0;
        if (Er && !Ir) {
          if (ar) {
            var Hr = this.getScrollTopByCaretPos();
            if (!Hr)
              return;
            Mr = Hr;
          } else {
            var Br = getParentNodeObj(this.previewRoot, _r), zr = Br.el, Gr = Br.mdNode, Xr = getEditorRangeHeightInfo(kr, Gr, Ar), Jr = Xr.height, li = Xr.rect, Qr = getTotalOffsetTop(zr, dr) || zr.offsetTop, ei = zr.clientHeight, ui = vr > li.top ? Math.min((vr - li.top) / Jr, 1) : 0;
            Mr = Qr + ei * ui;
          }
          Mr = this.getResolvedScrollTop("editor", Er, Mr, xr), this.latestEditorScrollTop = Er;
        }
        Mr !== xr && this.run("editor", Mr, xr);
      }
    }, lr.prototype.syncEditorScrollTop = function(ar) {
      var cr = this, ur = cr.toastMark, fr = cr.editorView, dr = cr.previewRoot, gr = cr.previewEl, mr = fr.dom, vr = fr.state, yr = gr.scrollTop, kr = gr.clientHeight, _r = gr.scrollHeight, xr = _r - yr <= kr, Sr = mr.scrollTop, Er = xr ? mr.scrollHeight : 0;
      if (yr && ar && !xr) {
        if (ar = findAncestorHavingId(ar, dr), !ar.getAttribute("data-nodeid"))
          return;
        var Cr = mr.children, Tr = Number(ar.getAttribute("data-nodeid")), Ar = getParentNodeObj(this.previewRoot, ur.findNodeById(Tr)), Ir = Ar.mdNode, Mr = Ar.el, Hr = getMdStartLine(Ir);
        Er = Cr[Hr - 1].offsetTop;
        var Br = getEditorRangeHeightInfo(vr.doc, Ir, Cr).height, zr = getAndSaveOffsetInfo(Mr, dr, Tr), Gr = zr.nodeHeight, Xr = zr.offsetTop;
        Er += getAdditionalPos(yr, Xr, Gr, Br), Er = this.getResolvedScrollTop("preview", yr, Er, Sr), this.latestPreviewScrollTop = yr;
      }
      Er !== Sr && this.run("preview", Er, Sr);
    }, lr.prototype.getResolvedScrollTop = function(ar, cr, ur, fr) {
      var dr = ar === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      return dr === null ? ur : dr < cr ? Math.max(ur, fr) : Math.min(ur, fr);
    }, lr.prototype.run = function(ar, cr, ur) {
      var fr = this, dr;
      ar === "editor" ? (dr = this.previewEl, this.blockedScroll = "preview") : (dr = this.editorView.dom, this.blockedScroll = "editor");
      var gr = {
        syncScrollTop: function(mr) {
          return dr.scrollTop = mr;
        },
        releaseEventBlock: function() {
          return fr.blockedScroll = null;
        }
      };
      animate(ur, cr, gr);
    }, lr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, lr.prototype.destroy = function() {
      this.clearTimer(), this.eventEmitter.removeEventHandler("scroll"), this.eventEmitter.removeEventHandler("afterPreviewRender");
    }, lr;
  }()
), queryMap = {
  getPopupInitialValues: function(lr, ar) {
    var cr = ar.popupName;
    return cr === "link" ? { linkText: lr.getSelectedText() } : {};
  }
};
function buildQuery(lr) {
  lr.eventEmitter.listen("query", function(ar, cr) {
    return queryMap[ar](lr, cr);
  });
}
var ToastUIEditorCore = (
  /** @class */
  function() {
    function lr(ar) {
      var cr = this;
      this.initialHTML = ar.el.innerHTML, ar.el.innerHTML = "", this.options = extend_1({
        previewStyle: "tab",
        previewHighlight: !0,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: !0,
        usageStatistics: !0,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: !1,
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        widgetRules: [],
        theme: "light",
        autofocus: !0
      }, ar);
      var ur = this.options, fr = ur.customHTMLRenderer, dr = ur.extendedAutolinks, gr = ur.referenceDefinition, mr = ur.frontMatter, vr = ur.customMarkdownRenderer, yr = ur.useCommandShortcut, kr = ur.initialEditType, _r = ur.widgetRules, xr = ur.customHTMLSanitizer;
      this.mode = kr || "markdown", this.mdPreviewStyle = this.options.previewStyle, this.i18n = i18n, this.i18n.setCode(this.options.language), this.eventEmitter = new EventEmitter(), setWidgetRules(_r);
      var Sr = sanitizeLinkAttribute(this.options.linkAttributes);
      this.pluginInfo = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      });
      var Er = this.pluginInfo, Cr = Er.toHTMLRenderers, Tr = Er.toMarkdownRenderers, Ar = Er.mdPlugins, Ir = Er.wwPlugins, Mr = Er.wwNodeViews, Hr = Er.mdCommands, Br = Er.wwCommands, zr = Er.markdownParsers, Gr = {
        linkAttributes: Sr,
        customHTMLRenderer: deepMergedCopy(Cr, fr),
        extendedAutolinks: dr,
        referenceDefinition: gr,
        frontMatter: mr,
        sanitizer: xr || sanitizeHTML
      }, Xr = new WwToDOMAdaptor(Sr, Gr.customHTMLRenderer), Jr = createHTMLSchemaMap(Gr.customHTMLRenderer, Gr.sanitizer, Xr);
      this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: dr,
        referenceDefinition: gr,
        disallowDeepHeading: !0,
        frontMatter: mr,
        customParser: zr
      }), this.mdEditor = new MdEditor(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut: yr,
        mdPlugins: Ar
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, Gr), { isViewer: !1, highlight: this.options.previewHighlight })), this.wwEditor = new WysiwygEditor(this.eventEmitter, {
        toDOMAdaptor: Xr,
        useCommandShortcut: yr,
        htmlSchemaMap: Jr,
        linkAttributes: Sr,
        wwPlugins: Ir,
        wwNodeViews: Mr
      }), this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, Tr), vr), getHTMLRenderConvertors(Sr, Gr.customHTMLRenderer), this.eventEmitter), this.setMinHeight(this.options.minHeight), this.setHeight(this.options.height), this.setMarkdown(this.options.initialValue, !1), this.options.placeholder && this.setPlaceholder(this.options.placeholder), this.options.initialValue || this.setHTML(this.initialHTML, !1), this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return cr.mode;
      }), this.options.usageStatistics && sendHostName(), this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter), this.addInitEvent(), this.addInitCommand(Hr, Br), buildQuery(this), this.options.hooks && forEachOwnProperties_1(this.options.hooks, function(li, Qr) {
        return cr.addHook(Qr, li);
      }), this.options.events && forEachOwnProperties_1(this.options.events, function(li, Qr) {
        return cr.on(Qr, li);
      }), this.eventEmitter.emit("load", this), this.moveCursorToStart(this.options.autofocus);
    }
    return lr.prototype.addInitEvent = function() {
      var ar = this;
      this.on("needChangeMode", this.changeMode.bind(this)), this.on("loadUI", function() {
        if (ar.height !== "auto") {
          var cr = Math.min(parseInt(ar.minHeight, 10), parseInt(ar.height, 10) - 75) + "px";
          ar.setMinHeight(cr);
        }
      }), addDefaultImageBlobHook(this.eventEmitter);
    }, lr.prototype.addInitCommand = function(ar, cr) {
      var ur = this, fr = function(dr, gr) {
        Object.keys(gr).forEach(function(mr) {
          ur.addCommand(dr, mr, gr[mr]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(dr) {
        return ur.eventEmitter.emit("toggleScrollSync", dr.active), !0;
      }), fr("markdown", ar), fr("wysiwyg", cr);
    }, lr.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    }, lr.factory = function(ar) {
      return ar.viewer ? new ToastUIEditorViewer(ar) : new lr(ar);
    }, lr.setLanguage = function(ar, cr) {
      i18n.setLanguage(ar, cr);
    }, lr.prototype.changePreviewStyle = function(ar) {
      this.mdPreviewStyle !== ar && (this.mdPreviewStyle = ar, this.eventEmitter.emit("changePreviewStyle", ar));
    }, lr.prototype.exec = function(ar, cr) {
      this.commandManager.exec(ar, cr);
    }, lr.prototype.addCommand = function(ar, cr, ur) {
      var fr = this, dr = function(gr) {
        gr === void 0 && (gr = {});
        var mr = (ar === "markdown" ? fr.mdEditor : fr.wwEditor).view;
        ur(gr, mr.state, mr.dispatch, mr);
      };
      this.commandManager.addCommand(ar, cr, dr);
    }, lr.prototype.on = function(ar, cr) {
      this.eventEmitter.listen(ar, cr);
    }, lr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.addHook = function(ar, cr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, cr);
    }, lr.prototype.removeHook = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, lr.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    }, lr.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    }, lr.prototype.moveCursorToEnd = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToEnd(ar);
    }, lr.prototype.moveCursorToStart = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToStart(ar);
    }, lr.prototype.setMarkdown = function(ar, cr) {
      if (ar === void 0 && (ar = ""), cr === void 0 && (cr = !0), this.mdEditor.setMarkdown(ar, cr), this.isWysiwygMode()) {
        var ur = this.toastMark.getRootNode(), fr = this.convertor.toWysiwygModel(ur);
        this.wwEditor.setModel(fr, cr);
      }
    }, lr.prototype.setHTML = function(ar, cr) {
      ar === void 0 && (ar = ""), cr === void 0 && (cr = !0);
      var ur = document.createElement("div");
      ur.innerHTML = replaceBRWithEmptyBlock(ar);
      var fr = distExports$5.DOMParser.fromSchema(this.wwEditor.schema).parse(ur);
      this.isMarkdownMode() ? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(fr), cr) : this.wwEditor.setModel(fr, cr);
    }, lr.prototype.getMarkdown = function() {
      return this.isMarkdownMode() ? this.mdEditor.getMarkdown() : this.convertor.toMarkdownText(this.wwEditor.getModel());
    }, lr.prototype.getHTML = function() {
      var ar = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (ar.isMarkdownMode()) {
          var fr = ar.toastMark.getRootNode(), dr = ar.convertor.toWysiwygModel(fr);
          ar.wwEditor.setModel(dr);
        }
      });
      var cr = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);
      if (this.placeholder) {
        var ur = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return cr.replace(ur, "");
      }
      return cr;
    }, lr.prototype.insertText = function(ar) {
      this.getCurrentModeEditor().replaceSelection(ar);
    }, lr.prototype.setSelection = function(ar, cr) {
      this.getCurrentModeEditor().setSelection(ar, cr);
    }, lr.prototype.replaceSelection = function(ar, cr, ur) {
      this.getCurrentModeEditor().replaceSelection(ar, cr, ur);
    }, lr.prototype.deleteSelection = function(ar, cr) {
      this.getCurrentModeEditor().deleteSelection(ar, cr);
    }, lr.prototype.getSelectedText = function(ar, cr) {
      return this.getCurrentModeEditor().getSelectedText(ar, cr);
    }, lr.prototype.getRangeInfoOfNode = function(ar) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(ar);
    }, lr.prototype.addWidget = function(ar, cr, ur) {
      this.getCurrentModeEditor().addWidget(ar, cr, ur);
    }, lr.prototype.replaceWithWidget = function(ar, cr, ur) {
      this.getCurrentModeEditor().replaceWithWidget(ar, cr, ur);
    }, lr.prototype.setHeight = function(ar) {
      var cr = this.options.el;
      isString_1(ar) && (ar === "auto" ? addClass_1(cr, "auto-height") : removeClass_1(cr, "auto-height"), this.setMinHeight(this.getMinHeight())), css_1(cr, { height: ar }), this.height = ar;
    }, lr.prototype.getHeight = function() {
      return this.height;
    }, lr.prototype.setMinHeight = function(ar) {
      if (ar !== this.minHeight) {
        var cr = this.height || this.options.height;
        cr !== "auto" && this.options.el.querySelector("." + cls("main")) && (ar = Math.min(parseInt(ar, 10), parseInt(cr, 10) - 75) + "px");
        var ur = parseInt(ar, 10);
        this.minHeight = ar, this.wwEditor.setMinHeight(ur), this.mdEditor.setMinHeight(ur), this.preview.setMinHeight(ur);
      }
    }, lr.prototype.getMinHeight = function() {
      return this.minHeight;
    }, lr.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    }, lr.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    }, lr.prototype.isViewer = function() {
      return !1;
    }, lr.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    }, lr.prototype.changeMode = function(ar, cr) {
      if (this.mode !== ar) {
        if (this.mode = ar, this.isWysiwygMode()) {
          var ur = this.toastMark.getRootNode(), fr = this.convertor.toWysiwygModel(ur);
          this.wwEditor.setModel(fr);
        } else {
          var fr = this.wwEditor.getModel();
          this.mdEditor.setMarkdown(this.convertor.toMarkdownText(fr), !cr);
        }
        if (this.eventEmitter.emit("removePopupWidget"), this.eventEmitter.emit("changeMode", ar), !cr) {
          var dr = this.convertor.getMappedPos();
          this.focus(), this.isWysiwygMode() && isNumber_1(dr) ? this.wwEditor.setSelection(dr) : Array.isArray(dr) && this.mdEditor.setSelection(dr);
        }
      }
    }, lr.prototype.destroy = function() {
      var ar = this;
      this.wwEditor.destroy(), this.mdEditor.destroy(), this.preview.destroy(), this.scrollSync.destroy(), this.eventEmitter.emit("destroy"), this.eventEmitter.getEvents().forEach(function(cr, ur) {
        return ar.off(ur);
      });
    }, lr.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    }, lr.prototype.show = function() {
      this.eventEmitter.emit("show");
    }, lr.prototype.setScrollTop = function(ar) {
      this.getCurrentModeEditor().setScrollTop(ar);
    }, lr.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    }, lr.prototype.reset = function() {
      this.wwEditor.setModel([]), this.mdEditor.setMarkdown("");
    }, lr.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    }, lr.prototype.setPlaceholder = function(ar) {
      this.placeholder = ar, this.mdEditor.setPlaceholder(ar), this.wwEditor.setPlaceholder(ar);
    }, lr.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    }, lr.prototype.convertPosToMatchEditorMode = function(ar, cr, ur) {
      var fr, dr;
      cr === void 0 && (cr = ar), ur === void 0 && (ur = this.mode);
      var gr = this.mdEditor.view.state.doc, mr = Array.isArray(ar), vr = Array.isArray(cr), yr = ar, kr = cr;
      if (mr !== vr)
        throw new Error("Types of arguments must be same");
      return ur === "markdown" && !mr && !vr ? (fr = getEditorToMdPos(gr, ar, cr), yr = fr[0], kr = fr[1]) : ur === "wysiwyg" && mr && vr && (dr = getMdToEditorPos(gr, ar, cr), yr = dr[0], kr = dr[1]), [yr, kr];
    }, lr;
  }()
);
function html$1$2(lr) {
  for (var ar, cr, ur = arguments, fr = 1, dr = "", gr = "", mr = [0], vr = function(kr) {
    fr === 1 && (kr || (dr = dr.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? mr.push(kr ? ur[kr] : dr) : fr === 3 && (kr || dr) ? (mr[1] = kr ? ur[kr] : dr, fr = 2) : fr === 2 && dr === "..." && kr ? mr[2] = assign(mr[2] || {}, ur[kr]) : fr === 2 && dr && !kr ? (mr[2] = mr[2] || {})[dr] = !0 : fr >= 5 && (fr === 5 ? ((mr[2] = mr[2] || {})[cr] = kr ? dr ? dr + ur[kr] : ur[kr] : dr, fr = 6) : (kr || dr) && (mr[2][cr] += kr ? dr + ur[kr] : dr)), dr = "";
  }, yr = 0; yr < lr.length; yr++) {
    yr && (fr === 1 && vr(), vr(yr));
    for (let kr = 0; kr < lr[yr].length; kr++)
      ar = lr[yr][kr], fr === 1 ? ar === "<" ? (vr(), mr = [mr, "", null], fr = 3) : dr += ar : fr === 4 ? dr === "--" && ar === ">" ? (fr = 1, dr = "") : dr = ar + dr[0] : gr ? ar === gr ? gr = "" : dr += ar : ar === '"' || ar === "'" ? gr = ar : ar === ">" ? (vr(), fr = 1) : fr && (ar === "=" ? (fr = 5, cr = dr, dr = "") : ar === "/" && (fr < 5 || lr[yr][kr + 1] === ">") ? (vr(), fr === 3 && (mr = mr[0]), fr = mr, (mr = mr[0]).push(this.apply(null, fr.slice(1))), fr = 0) : ar === " " || ar === "	" || ar === `
` || ar === "\r" ? (vr(), fr = 2) : dr += ar), fr === 3 && dr === "!--" && (fr = 4, mr = mr[0]);
  }
  return vr(), mr.length > 2 ? mr.slice(1) : mr[1];
}
function isBoolean(lr) {
  return typeof lr == "boolean" || lr instanceof Boolean;
}
var isBoolean_1 = isBoolean, VNodeWalker = (
  /** @class */
  function() {
    function lr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return lr.prototype.walk = function() {
      var ar = this, cr = ar.entering, ur = ar.current;
      return ur ? (cr ? ur.firstChild ? (this.current = ur.firstChild, this.entering = !0) : this.entering = !1 : ur === this.root ? this.current = null : ur.next ? (this.current = ur.next, this.entering = !0) : (this.current = ur.parent, this.entering = !1), { vnode: ur, entering: cr }) : null;
    }, lr;
  }()
), VNode = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      this.parent = null, this.old = null, this.firstChild = null, this.next = null, this.skip = !1, this.type = ar, this.props = cr, this.children = ur, this.props.children = ur, cr.ref && (this.ref = cr.ref, delete cr.ref), cr.key && (this.key = cr.key, delete cr.key);
    }
    return lr.prototype.walker = function() {
      return new VNodeWalker(this);
    }, lr.removalNodes = [], lr;
  }()
);
function createTextNode(lr) {
  return new VNode("TEXT_NODE", { nodeValue: lr }, []);
}
function excludeUnnecessaryChild(lr, ar) {
  var cr = lr;
  isBoolean_1(lr) || lr == null ? cr = null : (isString_1(lr) || isNumber_1(lr)) && (cr = createTextNode(String(lr))), cr && ar.push(cr);
}
function h(lr, ar) {
  for (var cr = [], ur = 2; ur < arguments.length; ur++)
    cr[ur - 2] = arguments[ur];
  var fr = [];
  return cr.forEach(function(dr) {
    Array.isArray(dr) ? dr.forEach(function(gr) {
      excludeUnnecessaryChild(gr, fr);
    }) : excludeUnnecessaryChild(dr, fr);
  }), new VNode(lr, ar || {}, fr);
}
var html$3 = html$1$2.bind(h);
function isObject(lr) {
  return lr === Object(lr);
}
var isObject_1 = isObject;
function createNode(lr) {
  var ar;
  return lr.type === "TEXT_NODE" ? ar = document.createTextNode(lr.props.nodeValue) : (ar = document.createElement(lr.type), setProps(ar, {}, lr.props)), ar;
}
function removeNode(lr, ar) {
  lr.node ? ar.removeChild(lr.node) : removeNode(lr.firstChild, ar);
}
function innerDiff(lr, ar, cr) {
  Object.keys(ar).forEach(function(ur) {
    if (/^on/.test(ur)) {
      if (!cr[ur] || ar[ur] !== cr[ur]) {
        var fr = ur.slice(2).toLowerCase();
        lr.removeEventListener(fr, ar[ur]);
      }
    } else
      ur !== "children" && !cr[ur] && !isTextNode(lr) && lr.removeAttribute(ur);
  }), setProps(lr, ar, cr, function(ur) {
    return !shallowEqual(ar[ur], cr[ur]);
  });
}
var reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setProps(lr, ar, cr, ur) {
  Object.keys(cr).forEach(function(fr) {
    if (!ur || ur(fr))
      if (/^on/.test(fr)) {
        var dr = fr.slice(2).toLowerCase();
        lr.addEventListener(dr, cr[fr]);
      } else
        fr === "nodeValue" ? lr[fr] = cr[fr] : fr === "style" && isObject_1(cr[fr]) ? setStyleProps(lr, ar[fr], cr[fr]) : fr !== "children" && (cr[fr] === !1 ? lr.removeAttribute(fr) : lr.setAttribute(fr, cr[fr]));
  });
}
function setStyleProps(lr, ar, cr) {
  ar && Object.keys(ar).forEach(function(ur) {
    lr.style[ur] = "";
  }), Object.keys(cr).forEach(function(ur) {
    var fr = cr[ur];
    lr.style[ur] = isNumber_1(fr) && !reNonDimension.test(ur) ? fr + "px" : fr;
  });
}
function commit(lr) {
  if (VNode.removalNodes.forEach(function(dr) {
    return diff(dr);
  }), lr) {
    for (var ar = void 0, cr = lr.walker(); ar = cr.walk(); )
      if (lr = ar.vnode, ar.entering)
        diff(lr);
      else if (isFunction_1(lr.type)) {
        var ur = lr.component;
        if (!lr.old && ur.mounted && ur.mounted(), lr.old && ur.updated) {
          var fr = ur.prevProps || {};
          ur.updated(fr);
        }
      }
  }
}
function getParentNode(lr) {
  for (var ar = lr.parent; !ar.node; )
    ar = ar.parent;
  return ar.node;
}
function diff(lr) {
  if (!(!lr || !lr.parent)) {
    if (lr.node) {
      var ar = getParentNode(lr);
      lr.effect === "A" ? ar.appendChild(lr.node) : lr.effect === "U" && innerDiff(lr.node, lr.old.props, lr.props);
    }
    if (lr.effect === "D") {
      for (var cr = void 0, ur = lr.walker(); cr = ur.walk(); )
        if (lr = cr.vnode, !cr.entering)
          if (isFunction_1(lr.type)) {
            var fr = lr.component;
            fr.beforeDestroy && fr.beforeDestroy();
          } else {
            var ar = getParentNode(lr);
            removeNode(lr, ar);
          }
    }
    lr.ref && (lr.component ? lr.ref(lr.component) : lr.node && lr.ref(lr.node));
  }
}
function createComponent(lr, ar) {
  var cr = ar.props, ur = ar.component;
  return ur ? (ur.prevProps = ur.props, ur.props = ar.props, ur) : new lr(cr);
}
function buildVNode(lr) {
  for (var ar = lr; lr && !lr.skip; ) {
    if (isFunction_1(lr.type)) {
      var cr = createComponent(lr.type, lr);
      cr.vnode = lr, lr.component = cr, lr.props.children = lr.children = [cr.render()], buildChildrenVNode(lr);
    } else
      lr.node || (lr.node = createNode(lr)), buildChildrenVNode(lr);
    if (lr.firstChild)
      lr = lr.firstChild;
    else {
      for (; lr && lr.parent && !lr.next && (lr = lr.parent, lr !== ar); )
        ;
      lr = lr.next;
    }
  }
}
function isSameType(lr, ar) {
  return lr && ar && ar.type === lr.type && (!ar.key || ar.key === lr.key);
}
function buildChildrenVNode(lr) {
  var ar = lr.children, cr = lr.old ? lr.old.firstChild : null, ur = null;
  ar.forEach(function(dr, gr) {
    var mr = isSameType(cr, dr);
    mr && (dr.old = cr, dr.parent = lr, dr.node = cr.node, dr.component = cr.component, dr.effect = "U"), dr && !mr && (dr.old = null, dr.parent = lr, dr.node = null, dr.effect = "A"), cr && !mr && (VNode.removalNodes.push(cr), cr.effect = "D"), cr && (cr = cr.next), gr === 0 ? lr.firstChild = dr : dr && (ur.next = dr), ur = dr;
  });
  var fr = last$1(ar);
  if (!ar.length)
    for (; cr; )
      VNode.removalNodes.push(cr), cr.effect = "D", cr = cr.next;
  for (; cr && fr; )
    cr && fr.old !== cr && (VNode.removalNodes.push(cr), cr.effect = "D", cr = cr.next);
}
function destroy(lr) {
  lr.effect = "D", VNode.removalNodes = [lr], commit(), VNode.removalNodes = [];
}
function rerender(lr) {
  var ar = lr.vnode;
  ar.effect = "U", ar.old = ar, ar.next && (ar.next.skip = !0), VNode.removalNodes = [], buildVNode(ar), commit(ar), ar.next && (ar.next.skip = !1);
}
function render(lr, ar) {
  var cr = new VNode(lr.tagName.toLowerCase(), {}, [ar]);
  return cr.node = lr, VNode.removalNodes = [], buildVNode(cr), commit(cr), function() {
    return destroy(cr.firstChild);
  };
}
var Component = (
  /** @class */
  function() {
    function lr(ar) {
      this.props = ar, this.state = {}, this.refs = {};
    }
    return lr.prototype.setState = function(ar) {
      var cr = __assign$1(__assign$1({}, this.state), ar);
      shallowEqual(this.state, cr) || (this.state = cr, rerender(this));
    }, lr;
  }()
), Switch = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.state = {
        hide: !1
      }, ur;
    }
    return ar.prototype.show = function() {
      this.setState({ hide: !1 });
    }, ar.prototype.hide = function() {
      this.setState({ hide: !0 });
    }, ar.prototype.render = function() {
      var cr = this.props, ur = cr.editorType, fr = cr.eventEmitter;
      return html$3(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([`
      <div class="`, '" style="display: ', `">
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style="display: ',
        `">
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("mode-switch"), this.state.hide ? "none" : "block", ur === "markdown" ? " active" : "", function() {
        fr.emit("needChangeMode", "markdown");
      }, i18n.get("Markdown"), ur === "wysiwyg" ? " active" : "", function() {
        fr.emit("needChangeMode", "wysiwyg");
      }, i18n.get("WYSIWYG"));
    }, ar;
  }(Component)
), templateObject_1$h;
function debounce$1(lr, ar) {
  var cr, ur;
  ar = ar || 0;
  function fr() {
    ur = Array.prototype.slice.call(arguments), window.clearTimeout(cr), cr = window.setTimeout(function() {
      lr.apply(null, ur);
    }, ar);
  }
  return fr;
}
var debounce_1 = debounce$1, debounce = debounce_1;
function throttle$1(lr, ar) {
  var cr, ur = !0, fr = function(kr) {
    lr.apply(null, kr), cr = null;
  }, dr, gr, mr;
  ar = ar || 0, dr = debounce(fr, ar);
  function vr() {
    if (mr = Array.prototype.slice.call(arguments), ur) {
      fr(mr), ur = !1;
      return;
    }
    gr = Number(/* @__PURE__ */ new Date()), cr = cr || gr, dr(mr), gr - cr >= ar && fr(mr);
  }
  function yr() {
    ur = !0, cr = null;
  }
  return vr.reset = yr, vr;
}
var throttle_1 = throttle$1, MapShim = function() {
  if (typeof Map != "undefined")
    return Map;
  function lr(ar, cr) {
    var ur = -1;
    return ar.some(function(fr, dr) {
      return fr[0] === cr ? (ur = dr, !0) : !1;
    }), ur;
  }
  return (
    /** @class */
    function() {
      function ar() {
        this.__entries__ = [];
      }
      return Object.defineProperty(ar.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), ar.prototype.get = function(cr) {
        var ur = lr(this.__entries__, cr), fr = this.__entries__[ur];
        return fr && fr[1];
      }, ar.prototype.set = function(cr, ur) {
        var fr = lr(this.__entries__, cr);
        ~fr ? this.__entries__[fr][1] = ur : this.__entries__.push([cr, ur]);
      }, ar.prototype.delete = function(cr) {
        var ur = this.__entries__, fr = lr(ur, cr);
        ~fr && ur.splice(fr, 1);
      }, ar.prototype.has = function(cr) {
        return !!~lr(this.__entries__, cr);
      }, ar.prototype.clear = function() {
        this.__entries__.splice(0);
      }, ar.prototype.forEach = function(cr, ur) {
        ur === void 0 && (ur = null);
        for (var fr = 0, dr = this.__entries__; fr < dr.length; fr++) {
          var gr = dr[fr];
          cr.call(ur, gr[1], gr[0]);
        }
      }, ar;
    }()
  );
}(), isBrowser = typeof window != "undefined" && typeof document != "undefined" && window.document === document, global$1 = function() {
  return typeof global != "undefined" && global.Math === Math ? global : typeof self != "undefined" && self.Math === Math ? self : typeof window != "undefined" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(lr) {
    return setTimeout(function() {
      return lr(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle(lr, ar) {
  var cr = !1, ur = !1, fr = 0;
  function dr() {
    cr && (cr = !1, lr()), ur && mr();
  }
  function gr() {
    requestAnimationFrame$1(dr);
  }
  function mr() {
    var vr = Date.now();
    if (cr) {
      if (vr - fr < trailingTimeout)
        return;
      ur = !0;
    } else
      cr = !0, ur = !1, setTimeout(gr, ar);
    fr = vr;
  }
  return mr;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver != "undefined", ResizeObserverController = (
  /** @class */
  function() {
    function lr() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    return lr.prototype.addObserver = function(ar) {
      ~this.observers_.indexOf(ar) || this.observers_.push(ar), this.connected_ || this.connect_();
    }, lr.prototype.removeObserver = function(ar) {
      var cr = this.observers_, ur = cr.indexOf(ar);
      ~ur && cr.splice(ur, 1), !cr.length && this.connected_ && this.disconnect_();
    }, lr.prototype.refresh = function() {
      var ar = this.updateObservers_();
      ar && this.refresh();
    }, lr.prototype.updateObservers_ = function() {
      var ar = this.observers_.filter(function(cr) {
        return cr.gatherActive(), cr.hasActive();
      });
      return ar.forEach(function(cr) {
        return cr.broadcastActive();
      }), ar.length > 0;
    }, lr.prototype.connect_ = function() {
      !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, lr.prototype.disconnect_ = function() {
      !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, lr.prototype.onTransitionEnd_ = function(ar) {
      var cr = ar.propertyName, ur = cr === void 0 ? "" : cr, fr = transitionKeys.some(function(dr) {
        return !!~ur.indexOf(dr);
      });
      fr && this.refresh();
    }, lr.getInstance = function() {
      return this.instance_ || (this.instance_ = new lr()), this.instance_;
    }, lr.instance_ = null, lr;
  }()
), defineConfigurable = function(lr, ar) {
  for (var cr = 0, ur = Object.keys(ar); cr < ur.length; cr++) {
    var fr = ur[cr];
    Object.defineProperty(lr, fr, {
      value: ar[fr],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return lr;
}, getWindowOf = function(lr) {
  var ar = lr && lr.ownerDocument && lr.ownerDocument.defaultView;
  return ar || global$1;
}, emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(lr) {
  return parseFloat(lr) || 0;
}
function getBordersSize(lr) {
  for (var ar = [], cr = 1; cr < arguments.length; cr++)
    ar[cr - 1] = arguments[cr];
  return ar.reduce(function(ur, fr) {
    var dr = lr["border-" + fr + "-width"];
    return ur + toFloat(dr);
  }, 0);
}
function getPaddings(lr) {
  for (var ar = ["top", "right", "bottom", "left"], cr = {}, ur = 0, fr = ar; ur < fr.length; ur++) {
    var dr = fr[ur], gr = lr["padding-" + dr];
    cr[dr] = toFloat(gr);
  }
  return cr;
}
function getSVGContentRect(lr) {
  var ar = lr.getBBox();
  return createRectInit(0, 0, ar.width, ar.height);
}
function getHTMLElementContentRect(lr) {
  var ar = lr.clientWidth, cr = lr.clientHeight;
  if (!ar && !cr)
    return emptyRect;
  var ur = getWindowOf(lr).getComputedStyle(lr), fr = getPaddings(ur), dr = fr.left + fr.right, gr = fr.top + fr.bottom, mr = toFloat(ur.width), vr = toFloat(ur.height);
  if (ur.boxSizing === "border-box" && (Math.round(mr + dr) !== ar && (mr -= getBordersSize(ur, "left", "right") + dr), Math.round(vr + gr) !== cr && (vr -= getBordersSize(ur, "top", "bottom") + gr)), !isDocumentElement(lr)) {
    var yr = Math.round(mr + dr) - ar, kr = Math.round(vr + gr) - cr;
    Math.abs(yr) !== 1 && (mr -= yr), Math.abs(kr) !== 1 && (vr -= kr);
  }
  return createRectInit(fr.left, fr.top, mr, vr);
}
var isSVGGraphicsElement = function() {
  return typeof SVGGraphicsElement != "undefined" ? function(lr) {
    return lr instanceof getWindowOf(lr).SVGGraphicsElement;
  } : function(lr) {
    return lr instanceof getWindowOf(lr).SVGElement && typeof lr.getBBox == "function";
  };
}();
function isDocumentElement(lr) {
  return lr === getWindowOf(lr).document.documentElement;
}
function getContentRect(lr) {
  return isBrowser ? isSVGGraphicsElement(lr) ? getSVGContentRect(lr) : getHTMLElementContentRect(lr) : emptyRect;
}
function createReadOnlyRect(lr) {
  var ar = lr.x, cr = lr.y, ur = lr.width, fr = lr.height, dr = typeof DOMRectReadOnly != "undefined" ? DOMRectReadOnly : Object, gr = Object.create(dr.prototype);
  return defineConfigurable(gr, {
    x: ar,
    y: cr,
    width: ur,
    height: fr,
    top: cr,
    right: ar + ur,
    bottom: fr + cr,
    left: ar
  }), gr;
}
function createRectInit(lr, ar, cr, ur) {
  return { x: lr, y: ar, width: cr, height: ur };
}
var ResizeObservation = (
  /** @class */
  function() {
    function lr(ar) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = ar;
    }
    return lr.prototype.isActive = function() {
      var ar = getContentRect(this.target);
      return this.contentRect_ = ar, ar.width !== this.broadcastWidth || ar.height !== this.broadcastHeight;
    }, lr.prototype.broadcastRect = function() {
      var ar = this.contentRect_;
      return this.broadcastWidth = ar.width, this.broadcastHeight = ar.height, ar;
    }, lr;
  }()
), ResizeObserverEntry = (
  /** @class */
  function() {
    function lr(ar, cr) {
      var ur = createReadOnlyRect(cr);
      defineConfigurable(this, { target: ar, contentRect: ur });
    }
    return lr;
  }()
), ResizeObserverSPI = (
  /** @class */
  function() {
    function lr(ar, cr, ur) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof ar != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = ar, this.controller_ = cr, this.callbackCtx_ = ur;
    }
    return lr.prototype.observe = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var cr = this.observations_;
        cr.has(ar) || (cr.set(ar, new ResizeObservation(ar)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, lr.prototype.unobserve = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var cr = this.observations_;
        cr.has(ar) && (cr.delete(ar), cr.size || this.controller_.removeObserver(this));
      }
    }, lr.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, lr.prototype.gatherActive = function() {
      var ar = this;
      this.clearActive(), this.observations_.forEach(function(cr) {
        cr.isActive() && ar.activeObservations_.push(cr);
      });
    }, lr.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var ar = this.callbackCtx_, cr = this.activeObservations_.map(function(ur) {
          return new ResizeObserverEntry(ur.target, ur.broadcastRect());
        });
        this.callback_.call(ar, cr, ar), this.clearActive();
      }
    }, lr.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, lr.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, lr;
  }()
), observers = typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver = (
  /** @class */
  function() {
    function lr(ar) {
      if (!(this instanceof lr))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var cr = ResizeObserverController.getInstance(), ur = new ResizeObserverSPI(ar, cr, this);
      observers.set(this, ur);
    }
    return lr;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(lr) {
  ResizeObserver.prototype[lr] = function() {
    var ar;
    return (ar = observers.get(this))[lr].apply(ar, arguments);
  };
});
var index = function() {
  return typeof global$1.ResizeObserver != "undefined" ? global$1.ResizeObserver : ResizeObserver;
}(), HeadingPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.execCommand = function(cr) {
      var ur = closest(cr.target, "li");
      this.props.execCommand("heading", {
        level: Number(ur.getAttribute("data-level"))
      });
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([`
      <ul
        onClick=`, `
        aria-role="menu"
        aria-label="`, `"
      >
        `, `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`, `</div>
        </li>
      </ul>
    `], [
        `
      <ul
        onClick=`,
        `
        aria-role="menu"
        aria-label="`,
        `"
      >
        `,
        `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
        `</div>
        </li>
      </ul>
    `
      ])), function(ur) {
        return cr.execCommand(ur);
      }, i18n.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(ur) {
        return html$3(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `], [`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `])), ur, "h" + ur, i18n.get("Heading"), ur);
      }), i18n.get("Paragraph"));
    }, ar;
  }(Component)
), templateObject_1$g, templateObject_2$8, Tabs = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.toggleTab = function(cr, ur) {
      this.props.onClick(cr, ur);
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([`
      <div class="`, `" aria-role="tabpanel">
        `, `
      </div>
    `], [
        `
      <div class="`,
        `" aria-role="tabpanel">
        `,
        `
      </div>
    `
      ])), cls("tabs"), this.props.tabs.map(function(ur) {
        var fr = ur.name, dr = ur.text, gr = cr.props.activeTab === fr;
        return html$3(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `], [`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `])), gr ? " active" : "", function(mr) {
          return cr.toggleTab(mr, fr);
        }, i18n.get(dr), gr ? "true" : "false", gr ? "0" : "-1", i18n.get(dr));
      }));
    }, ar;
  }(Component)
), templateObject_1$f, templateObject_2$7, TYPE_UI = "ui", ImagePopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.initialize = function(fr) {
        fr === void 0 && (fr = "file");
        var dr = ur.refs.url;
        dr.value = "", ur.refs.altText.value = "", ur.refs.file.value = "", removeClass_1(dr, "wrong"), ur.setState({ activeTab: fr, file: null, fileNameElClassName: "" });
      }, ur.execCommand = function() {
        ur.state.activeTab === "file" ? ur.emitAddImageBlob() : ur.emitAddImage();
      }, ur.toggleTab = function(fr, dr) {
        dr !== ur.state.activeTab && ur.initialize(dr);
      }, ur.showFileSelectBox = function() {
        ur.refs.file.click();
      }, ur.changeFile = function(fr) {
        var dr = fr.target.files;
        dr != null && dr.length && ur.setState({ file: dr[0] });
      }, ur.state = { activeTab: "file", file: null, fileNameElClassName: "" }, ur.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ], ur;
    }
    return ar.prototype.emitAddImageBlob = function() {
      var cr = this, ur = this.refs.file.files, fr = this.refs.altText, dr = " wrong";
      if (ur != null && ur.length) {
        dr = "";
        var gr = ur.item(0), mr = function(vr, yr) {
          return cr.props.execCommand("addImage", { imageUrl: vr, altText: yr || fr.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", gr, mr, TYPE_UI);
      }
      this.setState({ fileNameElClassName: dr });
    }, ar.prototype.emitAddImage = function() {
      var cr = this.refs.url, ur = this.refs.altText, fr = cr.value, dr = ur.value || "image";
      if (removeClass_1(cr, "wrong"), !fr.length) {
        addClass_1(cr, "wrong");
        return;
      }
      fr && this.props.execCommand("addImage", { imageUrl: fr, altText: dr });
    }, ar.prototype.preventSelectStart = function(cr) {
      cr.preventDefault();
    }, ar.prototype.updated = function() {
      this.props.show || this.initialize();
    }, ar.prototype.render = function() {
      var cr = this, ur = this.state, fr = ur.activeTab, dr = ur.file, gr = ur.fileNameElClassName;
      return html$3(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert image"), Tabs, this.tabs, fr, this.toggleTab, fr === "url" ? "block" : "none", i18n.get("Image URL"), function(mr) {
        return cr.refs.url = mr;
      }, fr === "file" ? "block" : "none", i18n.get("Select image file"), cls("file-name"), dr ? " has-file" : gr, this.showFileSelectBox, this.preventSelectStart, dr ? dr.name : i18n.get("No file"), cls("file-select-button"), this.showFileSelectBox, i18n.get("Choose a file"), this.changeFile, function(mr) {
        return cr.refs.file = mr;
      }, i18n.get("Description"), function(mr) {
        return cr.refs.altText = mr;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$e, LinkPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.execCommand = function() {
        var ur = cr.refs.url, fr = cr.refs.text;
        if (removeClass_1(ur, "wrong"), removeClass_1(fr, "wrong"), ur.value.length < 1) {
          addClass_1(ur, "wrong");
          return;
        }
        var dr = isUndefined_1(cr.props.initialValues.linkUrl);
        if (dr && fr.value.length < 1) {
          addClass_1(fr, "wrong");
          return;
        }
        cr.props.execCommand("addLink", {
          linkUrl: ur.value,
          linkText: fr.value
        });
      }, cr;
    }
    return ar.prototype.initialize = function() {
      var cr = this.props.initialValues, ur = cr.linkUrl, fr = cr.linkText, dr = this.refs.url, gr = this.refs.text;
      removeClass_1(dr, "wrong"), removeClass_1(gr, "wrong", "disabled"), gr.removeAttribute("disabled"), ur && (addClass_1(gr, "disabled"), gr.setAttribute("disabled", "disabled")), dr.value = ur || "", gr.value = fr || "";
    }, ar.prototype.mounted = function() {
      this.initialize();
    }, ar.prototype.updated = function(cr) {
      !cr.show && this.props.show && this.initialize();
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert link"), i18n.get("URL"), function(ur) {
        return cr.refs.url = ur;
      }, i18n.get("Link text"), function(ur) {
        return cr.refs.text = ur;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$d, CELL_WIDTH = 20, CELL_HEIGHT = 20, MIN_ROW_INDEX = 5, MAX_ROW_INDEX = 14, MIN_COL_INDEX = 5, MAX_COL_INDEX = 9, MIN_ROW_SELECTION_INDEX = 1, MIN_COL_SELECTION_INDEX = 1, BORDER_WIDTH = 1, TablePopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.extendSelectionRange = function(fr) {
        var dr = fr.pageX, gr = fr.pageY, mr = dr - ur.offsetRect.left, vr = gr - ur.offsetRect.top, yr = ur.getSelectionRangeByOffset(mr, vr);
        ur.setState(__assign$1({}, yr));
      }, ur.execCommand = function() {
        ur.props.execCommand("addTable", {
          rowCount: ur.state.rowIdx + 1,
          columnCount: ur.state.colIdx + 1
        });
      }, ur.state = {
        rowIdx: -1,
        colIdx: -1
      }, ur;
    }
    return ar.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    }, ar.prototype.getBoundByRange = function(cr, ur) {
      return {
        width: (cr + 1) * CELL_WIDTH,
        height: (ur + 1) * CELL_HEIGHT
      };
    }, ar.prototype.getRangeByOffset = function(cr, ur) {
      return {
        colIdx: Math.floor(cr / CELL_WIDTH),
        rowIdx: Math.floor(ur / CELL_HEIGHT)
      };
    }, ar.prototype.getTableRange = function() {
      var cr = this.state, ur = cr.colIdx, fr = cr.rowIdx, dr = Math.max(ur, MIN_COL_INDEX), gr = Math.max(fr, MIN_ROW_INDEX);
      return ur >= MIN_COL_INDEX && dr < MAX_COL_INDEX && (dr += 1), fr >= MIN_ROW_INDEX && gr < MAX_ROW_INDEX && (gr += 1), { colIdx: dr + 1, rowIdx: gr + 1 };
    }, ar.prototype.getSelectionAreaBound = function() {
      var cr = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), ur = cr.width, fr = cr.height;
      return !ur && !fr ? { display: "none" } : { width: ur - BORDER_WIDTH, height: fr - BORDER_WIDTH, display: "block" };
    }, ar.prototype.getSelectionRangeByOffset = function(cr, ur) {
      var fr = this.getRangeByOffset(cr, ur);
      return fr.rowIdx = Math.min(Math.max(fr.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX), fr.colIdx = Math.min(Math.max(fr.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX), fr;
    }, ar.prototype.updated = function() {
      if (!this.props.show)
        this.setState({ colIdx: -1, rowIdx: -1 });
      else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var cr = this.refs.tableEl.getBoundingClientRect(), ur = cr.left, fr = cr.top;
        this.offsetRect = {
          left: window.pageXOffset + ur,
          top: window.pageYOffset + fr
        };
      }
    }, ar.prototype.createTableArea = function(cr) {
      for (var ur = cr.colIdx, fr = cr.rowIdx, dr = [], gr = 0; gr < fr; gr += 1) {
        for (var mr = [], vr = 0; vr < ur; vr += 1) {
          var yr = "" + cls("table-cell") + (gr > 0 ? "" : " header");
          mr.push(html$3(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(['<div class="', '"></div>'], ['<div class="', '"></div>'])), yr));
        }
        dr.push(html$3(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table-row"), mr));
      }
      return html$3(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table"), dr);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.getTableRange(), fr = this.getSelectionAreaBound();
      return html$3(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `], [`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `])), i18n.get("Insert table"), cls("table-selection"), function(dr) {
        return cr.refs.tableEl = dr;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(ur), cls("table-selection-layer"), fr, cls("table-description"), this.getDescription());
    }, ar;
  }(Component)
), templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1, CustomPopupBody = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    }, ar.prototype.updated = function(cr) {
      this.refs.el.replaceChild(this.props.body, cr.body);
    }, ar.prototype.render = function() {
      var cr = this;
      return html$3(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(ur) {
        return cr.refs.el = ur;
      });
    }, ar;
  }(Component)
), templateObject_1$b;
function createToolbarItemInfo(lr) {
  return isString_1(lr) ? createDefaultToolbarItemInfo(lr) : lr;
}
function createScrollSyncToolbarItem() {
  var lr = document.createElement("label"), ar = document.createElement("input"), cr = document.createElement("span");
  lr.className = "scroll-sync active", ar.type = "checkbox", ar.checked = !0, cr.className = "switch";
  var ur = function(fr) {
    return ar.addEventListener("change", function(dr) {
      var gr = dr.target.checked;
      gr ? addClass_1(lr, "active") : removeClass_1(lr, "active"), fr("toggleScrollSync", { active: gr });
    });
  };
  return lr.appendChild(ar), lr.appendChild(cr), {
    name: "scrollSync",
    el: lr,
    onMounted: ur
  };
}
function createDefaultToolbarItemInfo(lr) {
  var ar;
  switch (lr) {
    case "heading":
      ar = {
        name: "heading",
        className: "heading",
        tooltip: i18n.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      ar = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: i18n.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      ar = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: i18n.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      ar = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: i18n.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      ar = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: i18n.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      ar = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: i18n.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      ar = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: i18n.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      ar = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: i18n.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      ar = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: i18n.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      ar = {
        name: "table",
        className: "table",
        tooltip: i18n.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      ar = {
        name: "image",
        className: "image",
        tooltip: i18n.get("Insert image")
      };
      break;
    case "link":
      ar = {
        name: "link",
        className: "link",
        tooltip: i18n.get("Insert link")
      };
      break;
    case "code":
      ar = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: i18n.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      ar = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: i18n.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      ar = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: i18n.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      ar = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: i18n.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      ar = createScrollSyncToolbarItem();
      break;
    case "more":
      ar = {
        name: "more",
        className: "more",
        tooltip: i18n.get("More")
      };
      break;
  }
  return ar.name !== "scrollSync" && (ar.className += " " + cls("toolbar-icons")), ar;
}
function createPopupInfo(lr, ar) {
  var cr = ar.el, ur = ar.pos, fr = ar.popup, dr = ar.initialValues;
  switch (lr) {
    case "heading":
      return {
        render: function(gr) {
          return html$3(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, gr);
        },
        className: cls("popup-add-heading"),
        fromEl: cr,
        pos: ur
      };
    case "link":
      return {
        render: function(gr) {
          return html$3(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, gr);
        },
        className: cls("popup-add-link"),
        fromEl: cr,
        pos: ur,
        initialValues: dr
      };
    case "image":
      return {
        render: function(gr) {
          return html$3(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, gr);
        },
        className: cls("popup-add-image"),
        fromEl: cr,
        pos: ur
      };
    case "table":
      return {
        render: function(gr) {
          return html$3(templateObject_4 || (templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, gr);
        },
        className: cls("popup-add-table"),
        fromEl: cr,
        pos: ur
      };
    case "customPopupBody":
      return fr ? __assign$1({ render: function(gr) {
        return html$3(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, gr, fr.body);
      }, fromEl: cr, pos: ur }, fr) : null;
    default:
      return null;
  }
}
function setGroupState(lr) {
  lr.hidden = lr.length === lr.filter(function(ar) {
    return ar.hidden;
  }).length;
}
function groupToolbarItems(lr, ar) {
  var cr = function(ur) {
    return ur.hidden = ur.name === "scrollSync" && ar, ur;
  };
  return lr.reduce(function(ur, fr) {
    ur.push(fr.map(function(gr) {
      return cr(createToolbarItemInfo(gr));
    }));
    var dr = ur[(ur.length || 1) - 1];
    return dr && setGroupState(dr), ur;
  }, []);
}
function toggleScrollSync(lr, ar) {
  lr.forEach(function(cr) {
    cr.forEach(function(ur) {
      return ur.hidden = ur.name === "scrollSync" && ar;
    }), setGroupState(cr);
  });
}
var templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5, MARGIN_FROM_RIGHT_SIDE = 20, Popup = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.handleMousedown = function(ur) {
        !closest(ur.target, "." + cls("popup")) && !closest(ur.target, cr.props.info.fromEl) && cr.props.hidePopup();
      }, cr;
    }
    return ar.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown), this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    }, ar.prototype.updated = function(cr) {
      var ur = this.props, fr = ur.show, dr = ur.info;
      if (fr && dr.pos && cr.show !== fr) {
        var gr = __assign$1({}, dr.pos), mr = this.refs.el.offsetWidth, vr = closest(this.refs.el, "." + cls("toolbar")), yr = vr.offsetWidth;
        gr.left + mr >= yr && (gr.left = yr - mr - MARGIN_FROM_RIGHT_SIDE), shallowEqual(this.state.popupPos, gr) || this.setState({ popupPos: gr });
      }
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.info, dr = ur.show, gr = ur.hidePopup, mr = ur.eventEmitter, vr = ur.execCommand, yr = fr || {}, kr = yr.className, _r = kr === void 0 ? "" : kr, xr = yr.style, Sr = yr.render, Er = yr.initialValues, Cr = Er === void 0 ? {} : Er, Tr = __assign$1(__assign$1({ display: dr ? "block" : "none" }, xr), this.state.popupPos);
      return html$3(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `], [`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `])), cls("popup"), _r, Tr, function(Ar) {
        return cr.refs.el = Ar;
      }, cls("popup-body"), Sr && Sr({ eventEmitter: mr, show: dr, hidePopup: gr, execCommand: vr, initialValues: Cr }));
    }, ar;
  }(Component)
), templateObject_1$9, TOOLTIP_INDENT = 6;
function connectHOC(lr) {
  return (
    /** @class */
    function(ar) {
      __extends$1(cr, ar);
      function cr(ur) {
        var fr = ar.call(this, ur) || this;
        return fr.showTooltip = function(dr) {
          var gr = fr.props.item.tooltip;
          if (!fr.props.disabled && gr) {
            var mr = fr.getBound(dr), vr = mr.left + TOOLTIP_INDENT + "px", yr = mr.top + TOOLTIP_INDENT + "px";
            css_1(fr.props.tooltipRef.current, { display: "block", left: vr, top: yr }), fr.props.tooltipRef.current.querySelector(".text").textContent = gr;
          }
        }, fr.hideTooltip = function() {
          css_1(fr.props.tooltipRef.current, "display", "none");
        }, fr.state = { active: !1, disabled: ur.disabled }, fr.addEvent(), fr;
      }
      return cr.prototype.addEvent = function() {
        var ur = this, fr = this.props, dr = fr.item, gr = fr.eventEmitter;
        dr.state && gr.listen("changeToolbarState", function(mr) {
          var vr, yr = mr.toolbarState, kr = (vr = yr[dr.state]) !== null && vr !== void 0 ? vr : {}, _r = kr.active, xr = kr.disabled;
          ur.setState({ active: !!_r, disabled: xr != null ? xr : ur.props.disabled });
        });
      }, cr.prototype.getBound = function(ur) {
        var fr = getTotalOffset(ur, closest(ur, "." + cls("toolbar"))), dr = fr.offsetLeft, gr = fr.offsetTop;
        return { left: dr, top: ur.offsetHeight + gr };
      }, cr.prototype.render = function() {
        return html$3(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `], [`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `])), lr, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      }, cr;
    }(Component)
  );
}
var templateObject_1$8, DEFAULT_WIDTH = 80, ToolbarButtonComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.showTooltip = function() {
        cr.props.showTooltip(cr.refs.el);
      }, cr.execCommand = function() {
        var ur = cr.props, fr = ur.item, dr = ur.execCommand, gr = ur.setPopupInfo, mr = ur.getBound, vr = ur.eventEmitter, yr = fr.command, kr = fr.name, _r = fr.popup;
        if (yr)
          dr(yr);
        else {
          var xr = _r ? "customPopupBody" : kr, Sr = vr.emit("query", "getPopupInitialValues", { popupName: xr })[0], Er = createPopupInfo(xr, {
            el: cr.refs.el,
            pos: mr(cr.refs.el),
            popup: _r,
            initialValues: Sr
          });
          Er && gr(Er);
        }
      }, cr;
    }
    return ar.prototype.mounted = function() {
      this.setItemWidth();
    }, ar.prototype.updated = function(cr) {
      cr.item.name !== this.props.item.name && this.setItemWidth();
    }, ar.prototype.setItemWidth = function() {
      var cr = this.props, ur = cr.setItemWidth, fr = cr.item;
      ur && ur(fr.name, getOuterWidth(this.refs.el) + (fr.hidden ? DEFAULT_WIDTH : 0));
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.hideTooltip, dr = ur.disabled, gr = ur.item, mr = ur.active, vr = __assign$1({ display: gr.hidden ? "none" : null }, gr.style), yr = "" + (gr.className || "") + (mr ? " active" : "");
      return html$3(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `], [`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `])), function(kr) {
        return cr.refs.el = kr;
      }, vr, yr, this.execCommand, this.showTooltip, fr, !!dr, gr.text || gr.tooltip || "", gr.text || "");
    }, ar;
  }(Component)
), ToolbarButton = connectHOC(ToolbarButtonComp), templateObject_1$7, CustomToolbarItemComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      var cr = lr !== null && lr.apply(this, arguments) || this;
      return cr.showTooltip = function() {
        cr.props.showTooltip(cr.refs.el);
      }, cr.showPopup = function() {
        var ur = createPopupInfo("customPopupBody", {
          el: cr.refs.el,
          pos: cr.props.getBound(cr.refs.el),
          popup: cr.props.item.popup
        });
        ur && cr.props.setPopupInfo(ur);
      }, cr;
    }
    return ar.prototype.mounted = function() {
      var cr = this.props, ur = cr.setItemWidth, fr = cr.item;
      this.refs.el.appendChild(fr.el), ur && ur(fr.name, getOuterWidth(this.refs.el)), fr.onMounted && fr.onMounted(this.props.execCommand);
    }, ar.prototype.updated = function(cr) {
      var ur, fr = this.props, dr = fr.item, gr = fr.active, mr = fr.disabled;
      (cr.active !== gr || cr.disabled !== mr) && ((ur = dr.onUpdated) === null || ur === void 0 || ur.call(dr, { active: gr, disabled: mr }));
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.disabled, dr = ur.item, gr = { display: dr.hidden ? "none" : "inline-block" }, mr = function(vr) {
        return fr ? null : vr;
      };
      return html$3(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `], [`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `])), function(vr) {
        return cr.refs.el = vr;
      }, gr, cls("toolbar-item-wrapper"), mr(this.showPopup), mr(this.showTooltip), mr(this.props.hideTooltip));
    }, ar;
  }(Component)
), CustomToolbarItem = connectHOC(CustomToolbarItemComp), templateObject_1$6, ToolbarGroup = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar() {
      return lr !== null && lr.apply(this, arguments) || this;
    }
    return ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.group, dr = ur.hiddenDivider, gr = fr.hidden ? { display: "none" } : null, mr = dr ? { display: "none" } : null;
      return html$3(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        `, `
        <div class="`, '" style=', `></div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        `,
        `
        <div class="`,
        '" style=',
        `></div>
      </div>
    `
      ])), cls("toolbar-group"), gr, fr.map(function(vr) {
        var yr = vr.el ? CustomToolbarItem : ToolbarButton;
        return html$3(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), yr, vr.name, cr.props, vr);
      }), cls("toolbar-divider"), mr);
    }, ar;
  }(Component)
), templateObject_1$5, templateObject_2$4, POPUP_INDENT = 4, DropdownToolbarButtonComp = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.handleClickDocument = function(fr) {
        var dr = fr.target;
        !closest(dr, "." + cls("dropdown-toolbar")) && !closest(dr, ".more") && ur.setState({ showDropdown: !1, dropdownPos: null });
      }, ur.showTooltip = function() {
        ur.props.showTooltip(ur.refs.el);
      }, ur.state = { showDropdown: !1, dropdownPos: null }, ur;
    }
    return ar.prototype.getBound = function() {
      var cr = this.props.getBound(this.refs.el);
      return cr.top += POPUP_INDENT, __assign$1(__assign$1({}, cr), { left: null, right: 10 });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.updated = function() {
      this.state.showDropdown && !this.state.dropdownPos && this.setState({ dropdownPos: this.getBound() });
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.state, fr = ur.showDropdown, dr = ur.dropdownPos, gr = this.props, mr = gr.disabled, vr = gr.item, yr = gr.items, kr = gr.hideTooltip, _r = yr.filter(function(Er) {
        return !Er.hidden;
      }), xr = _r.length ? null : { display: "none" }, Sr = fr ? null : { display: "none" };
      return html$3(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        <button
          ref=`, `
          type="button"
          class=`, `
          onClick=`, `
          onMouseover=`, `
          onMouseout=`, `
          disabled=`, `
        ></button>
        <div
          class="`, `"
          style=`, `
          ref=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        <button
          ref=`,
        `
          type="button"
          class=`,
        `
          onClick=`,
        `
          onMouseover=`,
        `
          onMouseout=`,
        `
          disabled=`,
        `
        ></button>
        <div
          class="`,
        `"
          style=`,
        `
          ref=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("toolbar-group"), xr, function(Er) {
        return cr.refs.el = Er;
      }, vr.className, function() {
        return cr.setState({ showDropdown: !0 });
      }, this.showTooltip, kr, mr, cls("dropdown-toolbar"), __assign$1(__assign$1({}, Sr), dr), function(Er) {
        return cr.refs.dropdownEl = Er;
      }, _r.length ? _r.map(function(Er, Cr) {
        var Tr;
        return html$3(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([`
                  <`, `
                    group=`, `
                    hiddenDivider=`, `
                    ...`, `
                  />
                `], [
          `
                  <`,
          `
                    group=`,
          `
                    hiddenDivider=`,
          `
                    ...`,
          `
                  />
                `
        ])), ToolbarGroup, Er, Cr === _r.length - 1 || ((Tr = _r[Cr + 1]) === null || Tr === void 0 ? void 0 : Tr.hidden), cr.props);
      }) : null);
    }, ar;
  }(Component)
), DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp), templateObject_1$4, templateObject_2$3, INLINE_PADDING = 50, Toolbar = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.toggleTab = function(fr, dr) {
        var gr = ur.props.eventEmitter;
        if (ur.state.activeTab !== dr) {
          var mr = dr === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          gr.emit(mr), ur.setState({ activeTab: dr });
        }
      }, ur.setItemWidth = function(fr, dr) {
        ur.itemWidthMap[fr] = dr;
      }, ur.setPopupInfo = function(fr) {
        ur.setState({ showPopup: !0, popupInfo: fr });
      }, ur.openPopup = function(fr, dr) {
        dr === void 0 && (dr = {});
        var gr = ur.refs.el.querySelector("." + cls("toolbar-group") + " ." + fr);
        if (gr) {
          var mr = getTotalOffset(gr, closest(gr, "." + cls("toolbar"))), vr = mr.offsetLeft, yr = mr.offsetTop, kr = createPopupInfo(fr, {
            el: gr,
            pos: { left: vr, top: gr.offsetHeight + yr },
            initialValues: dr
          });
          kr && ur.setPopupInfo(kr);
        }
      }, ur.hidePopup = function() {
        ur.state.showPopup && ur.setState({ showPopup: !1 });
      }, ur.execCommand = function(fr, dr) {
        var gr = ur.props.eventEmitter;
        gr.emit("command", fr, dr), ur.hidePopup();
      }, ur.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ], ur.itemWidthMap = {}, ur.initialItems = groupToolbarItems(cr.toolbarItems || [], ur.hiddenScrollSync()), ur.state = {
        items: ur.initialItems,
        dropdownItems: [],
        showPopup: !1,
        popupInfo: {},
        activeTab: "write"
      }, ur.tooltipRef = { current: null }, ur.resizeObserver = new index(function() {
        return ur.handleResize();
      }), ur.addEvent(), ur;
    }
    return ar.prototype.insertToolbarItem = function(cr, ur) {
      var fr = cr.groupIndex, dr = cr.itemIndex, gr = this.initialItems[fr];
      ur = createToolbarItemInfo(ur), gr ? gr.splice(dr, 0, ur) : this.initialItems.push([ur]), this.setState(this.classifyToolbarItems());
    }, ar.prototype.removeToolbarItem = function(cr) {
      var ur = this;
      forEachArray_1(this.initialItems, function(fr) {
        var dr = !1;
        return forEachArray_1(fr, function(gr, mr) {
          return gr.name === cr ? (dr = !0, fr.splice(mr, 1), ur.setState(ur.classifyToolbarItems()), !1) : !0;
        }), !dr;
      });
    }, ar.prototype.addEvent = function() {
      var cr = this, ur = this.props.eventEmitter;
      this.handleResize = throttle_1(function() {
        cr.setState({ items: cr.initialItems, dropdownItems: [] }), cr.setState(cr.classifyToolbarItems());
      }, 200), ur.listen("openPopup", this.openPopup);
    }, ar.prototype.appendTooltipToRoot = function() {
      var cr = '<div class="' + cls("tooltip") + `" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`;
      this.tooltipRef.current = createElementWith(cr, this.refs.el);
    }, ar.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    }, ar.prototype.movePrevItemToDropdownToolbar = function(cr, ur, fr, dr) {
      var gr = function(vr) {
        var yr = vr.pop();
        yr && dr.push(yr);
      };
      if (cr > 1)
        gr(fr);
      else {
        var mr = last$1(ur);
        mr && gr(mr);
      }
    }, ar.prototype.classifyToolbarItems = function() {
      var cr = this, ur = 0, fr = this.refs.el.clientWidth, dr = this.refs.el.querySelector("." + cls("toolbar-divider")), gr = dr ? getOuterWidth(dr) : 0, mr = [], vr = [], yr = !1;
      return this.initialItems.forEach(function(kr, _r) {
        var xr = [], Sr = [];
        kr.forEach(function(Er, Cr) {
          Er.hidden || (ur += cr.itemWidthMap[Er.name], ur > fr - INLINE_PADDING ? (yr || (cr.movePrevItemToDropdownToolbar(Cr, mr, xr, Sr), yr = !0), Sr.push(Er)) : xr.push(Er));
        }), xr.length && (setGroupState(xr), mr.push(xr)), Sr.length && (setGroupState(Sr), vr.push(Sr)), _r < cr.state.items.length - 1 && (ur += gr);
      }), { items: mr, dropdownItems: vr };
    }, ar.prototype.mounted = function() {
      this.props.previewStyle === "tab" && this.props.eventEmitter.emit("changePreviewTabWrite", !0), this.setState(this.classifyToolbarItems()), this.appendTooltipToRoot(), this.resizeObserver.observe(this.refs.el);
    }, ar.prototype.updated = function(cr) {
      var ur = this.props, fr = ur.editorType, dr = ur.previewStyle, gr = ur.eventEmitter, mr = dr !== cr.previewStyle, vr = fr !== cr.editorType;
      if (mr || vr) {
        toggleScrollSync(this.initialItems, this.hiddenScrollSync());
        var yr = this.classifyToolbarItems();
        (mr || dr === "tab" && fr === "markdown") && (gr.emit("changePreviewTabWrite"), yr.activeTab = "write"), this.setState(yr);
      }
    }, ar.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize), this.resizeObserver.disconnect(), removeNode$1(this.tooltipRef.current);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.previewStyle, dr = ur.eventEmitter, gr = ur.editorType, mr = this.state, vr = mr.popupInfo, yr = mr.showPopup, kr = mr.activeTab, _r = mr.items, xr = mr.dropdownItems, Sr = {
        eventEmitter: dr,
        tooltipRef: this.tooltipRef,
        disabled: gr === "markdown" && fr === "tab" && kr === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      }, Er = fr === "tab" ? { borderTopLeftRadius: 0 } : null;
      return html$3(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([`
      <div class="`, `">
        <div
          class="`, `"
          style="display: `, `"
        >
          <`, " tabs=", " activeTab=", " onClick=", ` />
        </div>
        <div
          class="`, `"
          ref=`, `
          style=`, `
        >
          `, `
          <`, `
            item=`, `
            items=`, `
            ...`, `
          />
        </div>
        <`, `
          info=`, `
          show=`, `
          eventEmitter=`, `
          hidePopup=`, `
          execCommand=`, `
        />
      </div>
    `], [
        `
      <div class="`,
        `">
        <div
          class="`,
        `"
          style="display: `,
        `"
        >
          <`,
        " tabs=",
        " activeTab=",
        " onClick=",
        ` />
        </div>
        <div
          class="`,
        `"
          ref=`,
        `
          style=`,
        `
        >
          `,
        `
          <`,
        `
            item=`,
        `
            items=`,
        `
            ...`,
        `
          />
        </div>
        <`,
        `
          info=`,
        `
          show=`,
        `
          eventEmitter=`,
        `
          hidePopup=`,
        `
          execCommand=`,
        `
        />
      </div>
    `
      ])), cls("toolbar"), cls("md-tab-container"), gr === "wysiwyg" || fr === "vertical" ? "none" : "block", Tabs, this.tabs, kr, this.toggleTab, cls("defaultUI-toolbar"), function(Cr) {
        return cr.refs.el = Cr;
      }, Er, _r.map(function(Cr, Tr) {
        var Ar;
        return html$3(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `], [`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `])), ToolbarGroup, Cr, Tr === _r.length - 1 || ((Ar = _r[Tr + 1]) === null || Ar === void 0 ? void 0 : Ar.hidden), cr.setItemWidth, Sr);
      }), DropdownToolbarButton, createToolbarItemInfo("more"), xr, Sr, Popup, vr, yr, dr, this.hidePopup, this.execCommand);
    }, ar;
  }(Component)
), templateObject_1$3, templateObject_2$2, ContextMenu = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      return ur.handleClickDocument = function(fr) {
        closest(fr.target, "." + cls("context-menu")) || ur.setState({ pos: null });
      }, ur.state = {
        pos: null,
        menuGroups: []
      }, ur.addEvent(), ur;
    }
    return ar.prototype.addEvent = function() {
      var cr = this;
      this.props.eventEmitter.listen("contextmenu", function(ur) {
        var fr = ur.pos, dr = ur.menuGroups;
        cr.setState({ pos: fr, menuGroups: dr });
      });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.getMenuGroupElements = function() {
      var cr = this, ur = this.state, fr = ur.pos, dr = ur.menuGroups;
      return fr ? dr.reduce(function(gr, mr) {
        var vr = [];
        return mr.forEach(function(yr) {
          var kr = yr.label, _r = yr.className, xr = _r === void 0 ? !1 : _r, Sr = yr.disabled, Er = yr.onClick, Cr = function() {
            Sr || (Er(), cr.setState({ pos: null }));
          };
          vr.push(html$3(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `], [`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `])), Cr, Sr ? " disabled" : "", xr, kr));
        }), gr.push(html$3(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([`<ul class="menu-group">
              `, `
            </ul>`], [`<ul class="menu-group">
              `, `
            </ul>`])), vr)), gr;
      }, []) : [];
    }, ar.prototype.render = function() {
      var cr = __assign$1({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return html$3(templateObject_3 || (templateObject_3 = __makeTemplateObject(['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`], ['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`])), cls("context-menu"), cr, this.getMenuGroupElements());
    }, ar;
  }(Component)
), templateObject_1$2, templateObject_2$1, templateObject_3, Layout = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur = lr.call(this, cr) || this;
      ur.changeMode = function(gr) {
        gr !== ur.state.editorType && ur.setState({ editorType: gr });
      }, ur.changePreviewStyle = function(gr) {
        gr !== ur.state.previewStyle && ur.setState({ previewStyle: gr });
      }, ur.hide = function() {
        ur.setState({ hide: !0 });
      }, ur.show = function() {
        ur.setState({ hide: !1 });
      };
      var fr = cr.editorType, dr = cr.previewStyle;
      return ur.state = {
        editorType: fr,
        previewStyle: dr,
        hide: !1
      }, ur.addEvent(), ur;
    }
    return ar.prototype.mounted = function() {
      var cr = this.props.slots, ur = cr.wwEditor, fr = cr.mdEditor, dr = cr.mdPreview;
      this.refs.wwContainer.appendChild(ur), this.refs.mdContainer.insertAdjacentElement("afterbegin", fr), this.refs.mdContainer.appendChild(dr);
    }, ar.prototype.insertToolbarItem = function(cr, ur) {
      this.toolbar.insertToolbarItem(cr, ur);
    }, ar.prototype.removeToolbarItem = function(cr) {
      this.toolbar.removeToolbarItem(cr);
    }, ar.prototype.render = function() {
      var cr = this, ur = this.props, fr = ur.eventEmitter, dr = ur.hideModeSwitch, gr = ur.toolbarItems, mr = ur.theme, vr = this.state, yr = vr.hide, kr = vr.previewStyle, _r = vr.editorType, xr = yr ? " hidden" : "", Sr = cls(_r === "markdown" ? "md-mode" : "ww-mode"), Er = cls("md") + "-" + kr + "-style", Cr = cls([mr !== "light", mr + " "]);
      return html$3(templateObject_2 || (templateObject_2 = __makeTemplateObject([`
      <div
        class="`, "", "", `"
        ref=`, `
      >
        <`, `
          ref=`, `
          eventEmitter=`, `
          previewStyle=`, `
          toolbarItems=`, `
          editorType=`, `
        />
        <div
          class="`, " ", `"
          ref=`, `
        >
          <div class="`, `">
            <div
              class="`, " ", `"
              ref=`, `
            >
              <div class="`, `"></div>
            </div>
            <div
              class="`, `"
              ref=`, `
            />
          </div>
        </div>
        `, `
        <`, " eventEmitter=", ` />
      </div>
    `], [
        `
      <div
        class="`,
        "",
        "",
        `"
        ref=`,
        `
      >
        <`,
        `
          ref=`,
        `
          eventEmitter=`,
        `
          previewStyle=`,
        `
          toolbarItems=`,
        `
          editorType=`,
        `
        />
        <div
          class="`,
        " ",
        `"
          ref=`,
        `
        >
          <div class="`,
        `">
            <div
              class="`,
        " ",
        `"
              ref=`,
        `
            >
              <div class="`,
        `"></div>
            </div>
            <div
              class="`,
        `"
              ref=`,
        `
            />
          </div>
        </div>
        `,
        `
        <`,
        " eventEmitter=",
        ` />
      </div>
    `
      ])), Cr, cls("defaultUI"), xr, function(Tr) {
        return cr.refs.el = Tr;
      }, Toolbar, function(Tr) {
        return cr.toolbar = Tr;
      }, fr, kr, gr, _r, cls("main"), Sr, function(Tr) {
        return cr.refs.editorSection = Tr;
      }, cls("main-container"), cls("md-container"), Er, function(Tr) {
        return cr.refs.mdContainer = Tr;
      }, cls("md-splitter"), cls("ww-container"), function(Tr) {
        return cr.refs.wwContainer = Tr;
      }, !dr && html$3(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, fr, _r), ContextMenu, fr);
    }, ar.prototype.addEvent = function() {
      var cr = this.props.eventEmitter;
      cr.listen("hide", this.hide), cr.listen("show", this.show), cr.listen("changeMode", this.changeMode), cr.listen("changePreviewStyle", this.changePreviewStyle);
    }, ar;
  }(Component)
), templateObject_1$1, templateObject_2, ToastUIEditor = (
  /** @class */
  function(lr) {
    __extends$1(ar, lr);
    function ar(cr) {
      var ur, fr = lr.call(this, cr) || this, dr, gr = render(fr.options.el, html$3(templateObject_1 || (templateObject_1 = __makeTemplateObject([`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `], [`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `])), Layout, function(mr) {
        return dr = mr;
      }, fr.eventEmitter, fr.getEditorElements(), fr.options.hideModeSwitch, fr.options.toolbarItems, fr.options.previewStyle, fr.options.initialEditType, fr.options.theme));
      return fr.setMinHeight(fr.options.minHeight), fr.setHeight(fr.options.height), fr.defaultUI = {
        insertToolbarItem: dr.insertToolbarItem.bind(dr),
        removeToolbarItem: dr.removeToolbarItem.bind(dr),
        destroy: gr
      }, (ur = fr.pluginInfo.toolbarItems) === null || ur === void 0 || ur.forEach(function(mr) {
        var vr = mr.groupIndex, yr = mr.itemIndex, kr = mr.item;
        fr.defaultUI.insertToolbarItem({ groupIndex: vr, itemIndex: yr }, kr);
      }), fr.eventEmitter.emit("loadUI", fr), fr;
    }
    return ar.factory = function(cr) {
      return cr.viewer ? new ToastUIEditorViewer(cr) : new ar(cr);
    }, ar.prototype.insertToolbarItem = function(cr, ur) {
      this.defaultUI.insertToolbarItem(cr, ur);
    }, ar.prototype.removeToolbarItem = function(cr) {
      this.defaultUI.removeToolbarItem(cr);
    }, ar.prototype.destroy = function() {
      lr.prototype.destroy.call(this), this.defaultUI.destroy();
    }, ar;
  }(ToastUIEditorCore)
), templateObject_1;
ToastUIEditorCore.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});
const css$1 = `/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */.ProseMirror{position:relative;word-wrap:break-word;white-space:pre-wrap;white-space:break-spaces;-webkit-font-variant-ligatures:none;font-variant-ligatures:none;-webkit-font-feature-settings:"liga" 0;font-feature-settings:"liga" 0}.ProseMirror pre{white-space:pre-wrap}.ProseMirror li{position:relative}.ProseMirror-hideselection *::selection{background:transparent}.ProseMirror-hideselection *::-moz-selection{background:transparent}.ProseMirror-hideselection{caret-color:transparent}.ProseMirror-selectednode{outline:2px solid #8cf}li.ProseMirror-selectednode{outline:none}li.ProseMirror-selectednode:after{content:"";position:absolute;inset:-2px -2px -2px -32px;border:2px solid #8cf;pointer-events:none}img.ProseMirror-separator{display:inline!important;border:none!important;margin:0!important}.auto-height,.auto-height .toastui-editor-defaultUI{height:auto}.auto-height .toastui-editor-md-container{position:relative}:not(.auto-height)>.toastui-editor-defaultUI,:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-direction:column;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{-ms-flex:1;-webkit-box-flex:1;flex:1}.toastui-editor-md-container:after,.toastui-editor-defaultUI-toolbar:after{content:"";display:block;height:0;clear:both}.toastui-editor-main{min-height:0px;position:relative;height:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-md-container{display:none;overflow:hidden;height:100%}.toastui-editor-md-container .toastui-editor{line-height:1.5;position:relative}.toastui-editor-md-container .toastui-editor,.toastui-editor-md-container .toastui-editor-md-preview{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;height:inherit}.toastui-editor-md-container .toastui-editor-md-preview{overflow:auto;padding:0 25px;height:100%}.toastui-editor-md-container .toastui-editor-md-preview>p:first-child{margin-top:0!important}.toastui-editor-md-container .toastui-editor-md-preview .toastui-editor-contents{padding-top:8px}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor,.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-md-preview{width:100%;display:none}.toastui-editor-main .toastui-editor-md-tab-style>.active{display:block}.toastui-editor-main .toastui-editor-md-vertical-style>.toastui-editor-tabs{display:none}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-tabs{display:block}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor,.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-preview{width:50%}.toastui-editor-main .toastui-editor-md-splitter{display:none;height:100%;width:1px;background-color:#ebedf2;position:absolute;left:50%}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-splitter{display:block}.toastui-editor-ww-container{display:none;overflow:hidden;height:inherit;background-color:#fff}.auto-height .toastui-editor-main-container{position:relative}.toastui-editor-main-container{position:absolute;line-height:1;color:#222;width:100%;height:inherit}.toastui-editor-ww-container>.toastui-editor{height:inherit;position:relative;width:100%}.toastui-editor-ww-container .toastui-editor-contents{overflow:auto;-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:16px 25px 0;height:inherit}.toastui-editor-ww-container .toastui-editor-contents p{margin:0}.toastui-editor-md-mode .toastui-editor-md-container,.toastui-editor-ww-mode .toastui-editor-ww-container{display:block;z-index:20}.toastui-editor-md-mode .toastui-editor-md-vertical-style{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-main.hidden,.toastui-editor-defaultUI.hidden{display:none}.toastui-editor-defaultUI .ProseMirror{padding:18px 25px}.toastui-editor-defaultUI{position:relative;border:1px solid #dadde6;height:100%;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;border-radius:4px}.toastui-editor-defaultUI button{color:#333;height:28px;font-size:13px;cursor:pointer;border:none;border-radius:2px}.toastui-editor-defaultUI .toastui-editor-ok-button{min-width:63px;height:32px;background-color:#00a9ff;color:#fff;outline-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-ok-button:hover{background-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-close-button{min-width:63px;height:32px;background-color:#f7f9fc;border:1px solid #dadde6;margin-right:5px;outline-color:#cbcfdb}.toastui-editor-defaultUI .toastui-editor-close-button:hover{border-color:#cbcfdb}.toastui-editor-mode-switch{background-color:#fff;border-top:1px solid #dadde6;font-size:12px;text-align:right;height:28px;padding-right:10px;border-radius:0 0 3px 3px}.toastui-editor-mode-switch .tab-item{display:inline-block;width:96px;height:24px;line-height:24px;text-align:center;background:#f7f9fc;color:#969aa5;margin-top:-1px;margin-right:-1px;cursor:pointer;border:1px solid #dadde6;border-radius:0 0 4px 4px;font-weight:500;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-mode-switch .tab-item.active{border-top:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-defaultUI .toastui-editor-md-tab-container{float:left;height:45px;font-size:13px;background:#f7f9fc;border-bottom:1px solid #ebedf2;border-top-left-radius:3px}.toastui-editor-md-tab-container .toastui-editor-tabs{margin-left:15px;height:100%}.toastui-editor-md-tab-container .tab-item{display:inline-block;width:70px;height:33px;line-height:33px;font-size:12px;font-weight:500;text-align:center;background:#eaedf1;color:#969aa5;cursor:pointer;border:1px solid #dadde6;border-radius:4px 4px 0 0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:13px}.toastui-editor-md-tab-container .tab-item.active{border-bottom:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-md-tab-container .tab-item:last-child{margin-left:-1px}.toastui-editor-defaultUI-toolbar{display:-ms-flexbox;display:-webkit-box;display:flex;padding:0 25px;height:45px;background-color:#f7f9fc;border-bottom:1px solid #ebedf2;border-radius:3px 3px 0 0}.toastui-editor-toolbar{height:46px;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-toolbar-divider{display:inline-block;width:1px;height:18px;background-color:#e1e3e9;margin:14px 12px}.toastui-editor-toolbar-group{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-defaultUI-toolbar button{-webkit-box-sizing:border-box;box-sizing:border-box;cursor:pointer;width:32px;height:32px;padding:0;border-radius:3px;margin:7px 5px;border:1px solid #f7f9fc}.toastui-editor-defaultUI-toolbar button:not(:disabled):hover{border:1px solid #e4e7ee;background-color:#fff}.toastui-editor-defaultUI-toolbar .scroll-sync{display:inline-block;position:relative;width:70px;height:10px;text-align:center;line-height:10px;color:#81858f;cursor:pointer}.toastui-editor-defaultUI-toolbar .scroll-sync:before{content:"Scroll";position:absolute;left:0;font-size:14px}.toastui-editor-defaultUI-toolbar .scroll-sync.active:before{color:#00a9ff}.toastui-editor-defaultUI-toolbar .scroll-sync input{opacity:0;width:0;height:0}.toastui-editor-defaultUI-toolbar .switch{position:absolute;inset:0 0 0 45px;background-color:#d6d8de;-webkit-transition:.4s;transition:.4s;border-radius:50px}.toastui-editor-defaultUI-toolbar input:checked+.switch{background-color:#acddfa}.toastui-editor-defaultUI-toolbar .switch:before{position:absolute;content:"";height:14px;width:14px;left:0;bottom:-2px;background-color:#94979f;-webkit-transition:.4s;transition:.4s;border-radius:50%}.toastui-editor-defaultUI-toolbar input:checked+.switch:before{background-color:#00a9ff;-webkit-transform:translateX(12px);transform:translate(12px)}.toastui-editor-dropdown-toolbar .scroll-sync{margin:0 5px}.toastui-editor-dropdown-toolbar{position:absolute;height:46px;z-index:30;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;background-color:#f7f9fc;display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-toolbar-item-wrapper{margin:7px 5px;height:32px;line-height:32px}.toastui-editor-popup{width:400px;margin-right:auto;background:#fff;z-index:30;position:absolute;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6}.toastui-editor-popup-body{padding:15px;font-size:12px}.toastui-editor-popup-body label{font-weight:600;color:#555;display:block;margin:20px 0 5px}.toastui-editor-popup-body .toastui-editor-button-container{text-align:right;margin-top:20px}.toastui-editor-popup-body input[type=text]{width:calc(100% - 26px);height:30px;padding:0 12px;border-radius:2px;border:1px solid #e1e3e9;color:#333}.toastui-editor-popup-body input[type=text]:focus{outline:1px solid #00a9ff;border-color:transparent}.toastui-editor-popup-body input[type=text].disabled{background-color:#f7f9fc;border-color:#e1e3e9;color:#969aa5}.toastui-editor-popup-body input[type=file]{opacity:0;border:none;width:1px;height:1px;position:absolute;top:0;left:0}.toastui-editor-popup-body input.wrong,.toastui-editor-popup-body span.wrong{border-color:#fa2828}.toastui-editor-popup-add-link .toastui-editor-popup-body,.toastui-editor-popup-add-image .toastui-editor-popup-body{padding:0 20px 20px}.toastui-editor-popup-add-image .toastui-editor-tabs{margin:5px 0 10px}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item{display:inline-block;width:60px;height:40px;line-height:40px;border-bottom:1px solid #dadde6;color:#333;font-size:13px;font-weight:600;text-align:center;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item:hover{border-bottom:1px solid #cbcfdb}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item.active{color:#00a9ff;border-bottom:2px solid #00a9ff}.toastui-editor-popup-add-image .toastui-editor-file-name{width:58%;display:inline-block;border-radius:2px;border:1px solid #e1e3e9;color:#dadde6;height:30px;line-height:30px;padding:0 12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:pointer}.toastui-editor-popup-add-image .toastui-editor-file-name.has-file{color:#333}.toastui-editor-popup-add-image .toastui-editor-file-select-button{width:33%;margin-left:5px;height:32px;border-radius:2px;border:1px solid #dadde6;background-color:#f7f9fc;vertical-align:top}.toastui-editor-popup-add-image .toastui-editor-file-select-button:hover{border-color:#cbcfdb}.toastui-editor-popup-add-table{width:auto}.toastui-editor-popup-add-table .toastui-editor-table-selection{position:relative}.toastui-editor-popup-add-table .toastui-editor-table-cell{display:table-cell;width:20px;height:20px;border:1px solid #e1e3e9;background:#fff;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-table .toastui-editor-table-cell.header{background:#f7f9fc}.toastui-editor-popup-add-table .toastui-editor-table-row{display:table-row}.toastui-editor-popup-add-table .toastui-editor-table{display:table;border-collapse:collapse}.toastui-editor-popup-add-table .toastui-editor-table-selection-layer{position:absolute;top:0;left:0;border:1px solid #00a9ff;background:rgba(0,169,255,.1);z-index:30}.toastui-editor-popup-add-table .toastui-editor-table-description{margin:5px 0 0;text-align:center;color:#333}.toastui-editor-popup-add-heading{width:auto}.toastui-editor-popup-add-heading .toastui-editor-popup-body{padding:0}.toastui-editor-popup-add-heading h1,.toastui-editor-popup-add-heading h2,.toastui-editor-popup-add-heading h3,.toastui-editor-popup-add-heading h4,.toastui-editor-popup-add-heading h5,.toastui-editor-popup-add-heading h6,.toastui-editor-popup-add-heading ul,.toastui-editor-popup-add-heading p{padding:0;margin:0}.toastui-editor-popup-add-heading ul{padding:5px 0;list-style:none}.toastui-editor-popup-add-heading ul li{padding:4px 12px;cursor:pointer}.toastui-editor-popup-add-heading ul li:hover{background-color:#dff4ff}.toastui-editor-popup-add-heading h1{font-size:24px}.toastui-editor-popup-add-heading h2{font-size:22px}.toastui-editor-popup-add-heading h3{font-size:20px}.toastui-editor-popup-add-heading h4{font-size:18px}.toastui-editor-popup-add-heading h5{font-size:16px}.toastui-editor-popup-add-heading h6{font-size:14px}.toastui-editor-context-menu{position:absolute;width:auto;min-width:197px;color:#333;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;z-index:30;padding:5px 0;background-color:#fff}.toastui-editor-context-menu .menu-group{list-style:none;border-bottom:1px solid #ebedf2;padding:0;margin:0;font-size:13px}.toastui-editor-context-menu .menu-group:last-child{border-bottom:none!important}.toastui-editor-context-menu .menu-item{height:32px;line-height:32px;padding:0 14px;cursor:pointer}.toastui-editor-context-menu span{display:inline-block}.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px;content:"";width:20px;height:20px;display:inline-block;vertical-align:middle;margin-right:10px}.toastui-editor-context-menu .add-row-up:before{background-position:3px -104px}.toastui-editor-context-menu .add-row-down:before{background-position:-19px -104px}.toastui-editor-context-menu .remove-row:before{background-position:-41px -104px}.toastui-editor-context-menu .add-column-left:before{background-position:-63px -104px}.toastui-editor-context-menu .add-column-right:before{background-position:-85px -104px}.toastui-editor-context-menu .remove-column:before{background-position:-111px -104px}.toastui-editor-context-menu .align-column-left:before{background-position:-129px -104px}.toastui-editor-context-menu .align-column-center:before{background-position:-151px -104px}.toastui-editor-context-menu .align-column-right:before{background-position:-173px -104px}.toastui-editor-context-menu .remove-table:before{background-position:-197px -104px}.toastui-editor-context-menu .disabled span:before{opacity:.3}.toastui-editor-context-menu li:not(.disabled):hover{background-color:#dff4ff}.toastui-editor-context-menu li.disabled{color:#c9ccd5}.toastui-editor-tooltip{position:absolute;background-color:#444;z-index:40;padding:4px 7px;font-size:12px;border-radius:3px;color:#fff;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif}.toastui-editor-tooltip .arrow{content:"";display:inline-block;width:10px;height:10px;background-color:#444;-webkit-transform:rotate(45deg);transform:rotate(45deg);position:absolute;top:-3px;left:6px;z-index:-1}.toastui-editor-toolbar-icons{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px}@media only screen and (-webkit-min-device-pixel-ratio: 2),only screen and (min-device-pixel-ratio: 2),only screen and (min-resolution: 192dpi),only screen and (min-resolution: 2dppx){.toastui-editor-toolbar-icons,.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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P0A9dgflJJi2Szl5led4F57jlvpECs/6vuTjuhR3dAo961VP9UoRby5eaGBuxz2Zy/3pyiWBlJEiA/s5FHaEnU170tGmBChvV5O1/Zske9dQ3upqiLdbfuL3hTpvY+q8m3ELRkrj1xLs36Md8A17jhOutYwTnYufJw89tLmvbxmhJagIVEmgaoW0yvjlXQREQASakkA77LJL42wfGmdpGiktpZBagaFRfQqNsDNGSykNldFTUQ6+3ZQFWEJlRsA6pVmzZjML1sks0hoiosy9vMoqq2wVjg7VEMNQkHbLTzEI7tOqdCoeTd1nn7dK2tjwf2F5Gsro3cVhdS4CItCcBKSQNud9kVQiIAIikIqAjZLSQNu8lGeujZiyW8pvs7mHI6W2tb/tlF28jigvcRfSmLUpw+doZDQvxM0Xb40zpbLKiE03nWtLiOpVRp1A7ZYfl6+4yTPqo5hO4nndFPt4fi+OHTv2Qb5x/Y+4P9lFQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAQ6mYDfyZlX3kVABESgnQgc/WRhlf5F3j6Dvjdw6UT/mnbKm/IiAiIgAiIgAiLQngSkkLbnfVWuREAEOohA7+OFsc8v8w4peN43yfZGlnW/y9t/9kT/2g7CoKyKgAiIgAiIgAi0IIGeFpRZIouACIhA3QSOm1fY4A3f28MiWqXg/fyCyf7CuiMdhQiOmFc4YOEy7zsk/fZhyRe89ww7b8GTI+YXthv0vBO9gjcZ8TdoUBYWer43r8vzzpk1yb+vQWkqmVEmcPQjhY36+rzv0amzI6I0qqy5XC9kdGDumDHeSRdv5T/n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vaXiGC338PM8x9WSftjWO6CWsArTOAKhollR2UwjEc9wdYeNvhHCevQvqneamUs5jzhd3GlMemI2KtUTUyq89dBYDwAArSK8cWt+zbJmtNII6bA8tdAI6TC5wxP7rtbACm97tkR/K+ssVude9DBm+gqV+JM9a3q/rfW7Vklpya19CNCr94HCAFOk3LRd33u1u8vbhSlgLfWJFJ71famHrqt0Z6ivplBf17v2qFIymV1n07LtaITNJW+jus8B3NjU09sxzQZqmWVeETWcACNtV1PespspVUcOKG/XMLpUV0O83fITx3nEo4WNB1d4N+O2Rdw9yc7z+z1GRr/RrCOjSTInuTHq+3naNz3U4dcnXZebCLQDAeo+HSIgAiLQeQTaYZfdI+YV9qGhUrGR0moKqZVGlG2bxnzGaCmloTJ6Ksrotzvv6eisHFunNGvWHiHX64xyzl8eO8bbKhwdqlmUdstPMYjgqwH/9I6mQ/F4OhKYzTvi+F82kzjtksn+3SOuyEEERKApCUghbcrbIqFEQAREIB0BGyXF5+ZlfCdN2S3jvXku2UgpCveJNDxtp+xh64hylNKm/s1jaPYcjYzmSLnJoq5lplSGWVhIY2yuLSGqVxl1MrVbfly+4qZtXnT0Q96kPs/btKvgjUc5fbHH9x6cMdG39Ws6REAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERAACviiIgAiIgAgMJ7DPPvvshMuNoeueN9xww5zhPnQmAiIgAiIgAiIgAiKQBYGeLCJRHCIgAiLQTgR839++UCiMtzyZHUMKaTvd4AzzctBBB627bNmydxDlwNixY5++6qqrFmUYvaISAREQAREQgbYnkJlCOtojCl/4whd2HRwcvIw7tlHOd+25rq6uw6677rrbck6nraKv4v5kwrfR6eV9s9otP3nzUvyNJVBF+axXsEzqh3qFsPC883bHOAVl9EOYwWyjFStW9OM+h06MM66//vpfmz8dIiACIiACIiAC5Ql0lb+c/mo4imAjCuNDe/rAGfhskDJqkm4UppWB1J0TRRX3JxO+jU4v7zvZbvnJm5fibyyBKspnvYJlUj/UIwQKZ/e+++47gzh+we/D/OJLX6yTdxdG1+/DTy92HSIgAiIgAiIgAhUIZKaQVkinEZfzHhmN56GRacXTbWV7Ncyq8VuKSTVxVOO3VHp5u1cjYzV+a5KbxvYtNMwLZtYUgQKNOoGM72HuZS4GrJFpxZINRkW76XD9IQrnke4C54PY/8TvaeeG6eNnupTSGBFZRUAEREAERKAEgcym7JaIf1Sc2YAk3mOdmQzWAM8ssg6OqNT9yYtvo9PL+9Y2Q35obO9m+XRm3nlW/NkTcPfOmdmn0F4xUj85ZfTAWM5uYt3oEVdeeeVCc8PPJhiX89vBzmF7GkrpLzV912joEAEREAEREIFkAjUrpLx4d4pPzeXFu6NLwuzxnmHO76URrU1BHCCZIiACTUGg1NpH6qxIPuzTqe+mRw5DlqZZy1gkl05zIJCkjPL+uwRFMxoptWR5zz2F352x3sXPlFIbKT0N81P8dIiACIiACIiACCQQqFkhJa4bedEGu1AmxLsD14Ie4vDaYsw1E/zJSQREQARGjUAdax/dWsa3jZrwSrghBNIqo04YlNIBwhzK+ZOh204HHnjgmtp91xGSKQIiIAIiIALDCdSjkA6PSWciIAIdT6DUiGMZMKM90ljPesR6wpZBUvlSM3MuNaU8nitm0Eyn07LX3Bhp7GWk8fT49SQ7St7KYeskDzm4VauMOhHCkVJbU7oxvx523zXzYXddpgiIgAiIgAiIwEoC9SikeyZM2XWjovdwba5LhobHvc4uUwREoH0J1DDiqJHGGoqDONcArYYgvMdm8v6K1oxyPmKabplo+9w1PhXWThsIumzJFAEREAEREIFMCNSskNIDbGtCo3WhtmaUF3egkJoySo93byYStmkkNYxw1EoilxEoRg52QqAbQ6H2DMtDrTI2fbhOy28dN6SWUcNawtQhYlsErYVZLWHaAlYtmaCO3gfF/3AXthpldMqUKRswKrop70QLXiCeZ108MkVABERABERABIYTqFkhHR5Nc52NxtSuagnUMMJRbRLOfy4jUDTOtqexFawhNjuJRZ0TLuF2Mjstv+1075QXEaiFAHV0rwvH839D8QZG7lqxSb3o00E7G3c3KvoAHXYvF/vTuQiIgAiIgAiIwBCBdlJInyNLjRoBsLTqPRolq8nZyLTq5aLwItBIAvXUG1nUA43Mq9JKSYBOzU3wunnofUl3d/c0s3/5y18ev2TJkq9jXbTaaqtdeMUVVywP/UQGI6szOPmsc0CZPdvZZYqACIiACIiACIwk0DPSqTYXeoVtnajtpmvfXjN7Qw+W6BzWoFHHYApslpmj91zfTc0SqOISgZQE6qg3Mq8HUoosbw0ggBK5Ge8xl9LD11xzzUt2gjL6Jdy/afbXX399IsYXzO4ORkZtzWmgvIZuMxhZvdVdlykCIiACIiACIjCSQGYKabiGcNQ+7XLdddfdRvb0CYaR9zgTF1tDadNWXWQ0unaM220Ncey85b8722n5dfcuA9NGDasdkbcwo3KUqjfCNfHTTSjK/elNuCa+pTiPys2tI1HueVdMIe13UeH2h5h9X0ZDb6EM/cjcKDMnx5VR4rhq8803P5Z3owsiUwREQAREQAREIIFAZgppQtxyai8Cnfbd2U7LbyaltYYRR4001kBenGuAViIInU/dKI9ncPnT/E61EU34PsWMGxdiEn7WQLFcwu+X2H/AhUPsIgroKRiBQop9L3Ozw5RRzg/u7e2NIhm6on8REAEREAEREIFiAlJIi4noXAREoGYCpUYca44w44Bpd7dGmYhSxj4dJSQYLY0cR1py2c16ZDJDLs3MmZHCSqwsEzvE8rZDmjDxexILW5fVlFEi+BFxH2ARoUjadNxbmaL7R2T6C+7v4nw87udiTuXnjR079qt9fX37cW11fpsdcMABm1599dVPosR+ByX2DPzegvupKK8D5l+HCIiACIiACIhAeQJSSMvz0dWVBDrtu7Mtl18awLmsRV5ZBFrfluM681x2s25F4ihjvdXIjf+P499+DT2cMkqigTJqiSPLTTEhvo3dRkPN/XD8X88zNueqq65ahH0BztvZtYGBgU0wnqSTwMLGw9tlHSIgAiIgAiIgAhUIlFRI044kVIg/zeWGjiw4gWhQ7IS9rb+jmaWCYg0xeNkvOBg96KWRFoxyMCLQdt+d7bT8uvtar5lDvZF1/VDt+tZqkGQWdwtwrIZLU/ql3rqQOixSRjmfyXTdc5ywKJj/TT23O+efNzeuvxfD1YE2shocxKFpuQ6GTBEQAREQARGogUBJhTTHkYRiMUdlZIHGRdN8RxPluFAMpdx5lopmuXR0TQSqJZBDvTEq9UO1+c7afytzpG7tTcFjBxS5YFQU/3fj/55KYfCfJt5K0QTXUfg/A+MjnWdkuARl9Ch3biZuBermKZjHk/b4NdZYI1gruv/++6/X39+/tfPb09PzpLPLFAEREAEREAERqJ5ASYWUqDLr7U8hViPTSiFOQ7w812DGDcmUEmkOAjYDgIb0+2hIz6QDI1rLZt9RXLx48ZGsd7uNEaBHcpA2j2c5jzhzyHqmUeaR5zziHJFpFLvTRzgWOYRrRt003XvShKFM9xZFU/Mpz4VtRhQcPCc3kn6knDp3M3l2lmHY1N3gIJyP7LM4Wc0cCPt71o8+HVzUnwiIgAiIgAiIQE0EyimkUYR5jchVOzIYCdQGlhp2yWyqXNMwuxeBRu27s42G0Ur5NWUUPncis+0e+mHOp5hSGiqjt3PtI4wOfZPNWCbZZiyNZqn0RKAWAlm9h8IRzg+GMgzwnByRRh78mTI6E797O/+4VVS+nV+ZIiACIiACIiACyQRSKaTJQVvL1RrpNM63d1LTkNgxbqeh0Rs7z/07mlntkkm+3k++foLs88nTF2m0rbB84D4W9yuwTsJ9b9wfM/esDuKztVSj9t3ZrPKRNp5Wyi/33UZGgzVumPtx7qF8TmNk9Bfk9yNhnscz7XBj7J2mkOY5M8Hi1tHkBOiMeSci+iYmz8afGR19vpLIPEc+03xn4C9SXgk7m7BW9+oQAREQAREQARGog0DHKKQwasvvStIomkVjaTPyZ781UUSDDTiw/wx325DDGl02xexjZtfR/gS47zO55x/G3M9yayafqbBvLK4dy/3ZNKbviJ13hDXHmQn6nmrrlKBoCjvPRsV3IH4CZRRzmssiz9dVm2++eeI0X+dHpgiIgAiIgAiIQDoCFV/G6aKRr9EiQCPJPjPw0TB9U0B/RmPJx303J1Pox53KbHMCjOYO0DFhm7EEymiY3WHKKH6+lRMGGyXMeq2ixZnJkXZmgs2Y4LmZbonC8XSU995MBEgfSVNzTJ+N+nxSjjNfC73qqqs+vXTpUlNKbRbBJqTxTp6HZ5IkpQy4abrxkVFTRg/q7e3V7rpJ0OQmAiIgAiIgAlUS6KrSfyt7t+9Knu5+ZOSeWGbuce5m4r5n7FpTW2lInYPMZ8aE3D2ujNo18xO7LmsHEOCeD6y22mrWiH61KLtPcB4oWkXumZzaCCQRZaZAWlxhnJnI1yqRiGOw7MCthb6QeuxKFMdgGnpsLfR3mH57H9PRN63mvl5xxRX2TMwNw9jU3ctRLke8C00ZTZimK2U0BCdDBERABERABLIi0JNVRM0eDw10W/Nov+AIR0B2sBMaOy39HU1Gb04jPz00oL4xlLuhf/L1bbsWd5O9MwiEjfZbyG18ZNQyv3nYuA82OsqaRtoRyKzTbbf4xDGol/NcC22deDuH5Wanxx9//JcovIfynghGSrFPoE6dzfXPubLFcyNl1MGQKQIiIAIiIAIZEkilkPJyLmSYpqLKmAD3ZyzK6JbF0eK2lV2jkRVsdFR8fbTOG12eGp1e3lyT8sM9DjZpsbRjI0huAyNztpHRzc1CuQg2OiKeXJRSS0NH5xJIKp/FNCiDkRP2XsL0mkO8HOOe21po0rmHNM8mSff5FxuN/QtuT6F49pO2rckPRmQxrdNSyqiB0CECIiACIiACORAYMU0plkaW0+5i0SZaG5lWogCt6kgDaiyy/4xfsIFRUT6CNaWhn6JLDT+t5h5X47dURqqJoxq/pdLL2z21jPadUYSJK6PW8N6SRvW1Tkga3KaU7uHOZYpAnQRSl8+06aA02idZbC10VG4JGx/xPxs/Na+FZvbIqcRnz4Y7rFNnDxHlOwAAEdBJREFUU9J8L2ZcGZ2pNaMOkUwREAEREAERyJ5ASYU0hzVMpaQflTViNDruRSD7jubi0F5KvqZ2p7FmO+hGyijnZ9ovJvTuoZ+YU+OtVZSnTMpDo9PLm2gV+fHwexvyBN+IxQwa7QmN++co97+pVW7K1K1hWJsW3HZHu9QP5W5MlvewmvJZTqbia1Zu81oLTf4LptBi2tKNu/hFu+9iL+Buz8dnUFyP0gZGkNAhAiIgAiIgAjkRiKb55RS/os2ZAOucbqbxHIx00YA6060Zxf0M3G0EwI6baXhFa6GGnPTfzgRsoxf7zijlYdinXRgtt5Gfz/J7gDLxfDszUN5an0CJ6edBxqjvrqWOy2za+Re/+MW1ly1btjGRd6NgP3PNNde81PoElQMREAEREAERaH4CUkib/x6VlRDF400oHhfgaT7Kx0Vxzyilx3A+qaen57irr776lfg12UVABESgmQmUUEajtdAme9ZKaTPzkGwiIAIiIAIi0K4EpJC2651VvkRABESghQkwmv91xP9OLAu23nM6SuiVjIzu59w534vOuBvduUwREAEREAEREIHWIlByDWlrZUPSioAIiIAItBOBRqyFbideyosIiIAIiIAItCoBjZC26p2T3CIgAiLQ5gS0FrrNb7CyJwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikJLAq6++utPLL7+8yH5mTxlM3kRABERABERABERABKok0FOlf3kXAREQgbYnUCgUtieT4y2joX1O22daGayJwKJFi9YdHBx8B+VkYO21137a9/1FNUWkQCIgAiIgAiLQoQQyU0htFIGX8o3Gsaura09ezA1twL322mu7DgwMXEbyG+V8L5/r7u4+bK211rot53TaKvoq7k8mfBudXt43q93ykzcvxd9YAlWUz3oFy6R+qFcIC8/o+e4Yp/De+RDKqG9uvAf7cZ/T09Nzxpprrvlrc9MhAiIgAiIgAiJQnkBX+cvpr8ZGFMaH9vSBM/DZIGXUJN0oTCsDqTsniiruTyZ8G51e3ney3fKTNy/F31gCVZTPegXLpH6oRwjeb92vvPLKDOL4Bb8PO2XU4sRunby7wOM+/PSamw4REAEREAEREIHyBDJTSMsn05CreY+MxjPRyLTi6bayvRpm1fgtxaSaOKrxWyq9vN2rkbEavzXJzSjQLfwKZtYUgQKNOoGM72HuZS4GrJFpxZINFM5uRkF/iOJ5pLvAFN1B7H/CfNq5mZLKb7qUUkdEpgiIgAiIgAiUJpDZlN3SSTT+yjrrrBNMn8o6ZWuAZx1nJ8ZX6v7kxbfR6eV9T5skP7uF+XRm3tlW/NkTcPfOmdmn0EYxomA6ZfRAly2U0JvGjh17xOqrr77Q3Ji6vAlLVy7H7w6hn9NYY/pLTd91xGSKgAiIgAiIwEgCNSuktmaUl+72sSh3jNvjPcO8tO9t9JrSmCyyioAIiEAigVJrH6nbIv/Yp9NZMj1yGLI0zVrGIrl0mgMBysAIZZS9Ei7hvRaNlFqy7C3wFH535v14F+YO/Pz+/v7TuPSpHMRSlCIgAiIgAiLQFgRqVkjDDYyCXSiLSdiLGDfXQ2zrahZzvmaxP52LgAiIwGgSqGPto1vL+LbRlF9p50+A91cqZdRJQgfsAB0dh1K2njQ3zq3zdk1M7b7rIMkUAREQAREQgRiBmhXSWByyioAIiEBAoNSIYxk8oz3SWM96xHrClkFS+VIzcy41pTyeK2bQTEdJ6zU3FLXeN73pTafHryfZ85rSn5SWc6tWGXXhbKSUPD5N+I359TBiujHXHnbXZYqACIiACIiACKwkULNCap924UU7bMou58GoKA2Me0hirkuG83udXaYIiED7EqhhxFEjjTUUB3GuAVoNQVAqZxIsWjOaNE23VLS8D/vcNd6B7bSBoMuWTBEQAREQARHIhEDNCmm4JnSOkyJcM+qm6c6lx7vXXZM5kkANIxwjI0nnkssIlK0hHs3vzqbLena+Oi2/dZCrZdSwljB1iNgWQWthVkuYtoBVSyZ45vehjjvcha1GGV26dOkGK1as2BSl1EaAC/yedfHIFAEREAEREAERGE6gZoV0eDTNdTYaU7uqJVDDCEe1STj/uYxAhaPjwRri0B51TriE28nstPy2071TXkSgFgIoo70uHArlDcUbGLlrxSZ1hY8yOxszGBXFfIApvC8X+9O5CIiACIiACIjAEIF2mkb0XANvahZpNXK0opFpNfA2KCkRqJtAPc9yPWHrFlwR5EeAGSybEPvmYQpLuru7p5kd5XI8yubZ/E7GPi68Pswg7AyufdY5EvZsZ5cpAiIgAiIgAiIwkkDPSKfaXOhBvpeXsO2ma1OUGr5mlJf+YQ0adQymwNZGKTlUmk1AkkOWd22FkeLyOdBVEciXQB31Rub1QL45VexVEtgs5v9hviP6kp2jiH6J99w3zc4ylYkYXzC7O7g+k5HVQHk1N96FMxgdvdVdlykCIiACIiACIjCSQGYKabimdNQ+7cJL/zayp08wjLzHmbjQ0Oqo7852Wn4zKSRDkdioYbUj8hZmVI5S9YatiUfxmG5CoVSc3oRr4luK86jc3DoSpXMzmj3E/e93UWH/A+XCne5LObmFsvEjc6DOOLlIGb2K9+KxzrNMERABERABERCBZAKZKaTJ0cu1XQjQ0LqRvHTMd2c7Lb9ZldMaRhw10lgDfHGuAVqJICiY3UyzPQPz02xcdKqNaPb09DzV3z+kh+I+id8aKKNLUDB/iRL6A84PCaM7BTNQSKkz9nJJ4NeU0YMxB52bTBEQAREQAREQgWQCUkiTuchVBESgBgKlRhxriCqXIGl3t0bhiNLHPp3p78FoaeQ40pLLbtYjkxlyaWbOKGyVWFkmdojlbYc0YeL3JBa2LitxdpO2KZQHWESMjNp03FuZovtH3P/C9XdxPh77uZhT+Xkoml/lfD+sq3N9M8rUptyPJ1E+v4PbGZi3cH4q5oD51yECIiACIiACIlCegBTS8nx0NSTQad+dbcX85rUWuZ0eghzXmeeym3UrskdJ661Gbvx/HP/2a+hBusOUUUuc5/6mmBDfxv6D8PxwpuRejzI6B0VzEQrpAsJvF17bBPNJpu5a2Hj48LIMERABERABERCBcgRKKqRpRxLKRZ7yWkNHFpxMtkYwnJZpjZA9raHhrrWLmaWCEvKJGNEg64WTG+Vou+/Odlp+syrzOdQbWdcP1a5vrQZNZnG3AMdquDSlX94BFyJYMDJqAqJozuS5P8cJi/2/8bM7iufnzY33xXsxgjrQlFnnzy7F7LKKgAiIgAiIgAhUSaCkQprjSEKxiKMyskCDYnsEaYrvaFa7G26WimbxzdC5CNRDIId6Y1Tqh3oYZBG2lTmi2PWmYLADdXAwKor/u/F/T6Uw+E8Tb6VoguvUuZ8hviOdZzolL0EBPcqdm4lceClMofPteE7Hu82LFi1atB7rS7d2fvHzpLPLFAEREAEREAERqJ5ASYWUqDLr7U8hViPTSiFOQ7w812DGDcmUEmkOAjYDgIby+2hkz6RhHa1lw83Wwx2J2200sB/JQdo8nuU84swh65lGmUee84hzRKYpV6ePcCxyoAzaOlM3TfeeNGFQInuLoqnn1DYjCg6ehRt5TiLl1LmbybVlGDZ1Nzh4fnyerVmcrBY6/Z6wT4d2GSIgAiIgAiIgAjUQKKeQRtHlNSJX7chgJFAbWGrYJbOpck1DbVS/O9toGK2U31AZvZPGs62R+zDmFOQfCJXR22H3EezfZFroJNuMpdEslZ4I1EIgq/eQjXAyAv1BngFTOAfGjBlzRBp58O/zPM3E797OPyOrFZVv51emCIiACIiACIhAMoFUCmly0NZyDRvpNk3XHTs6C+aONDR63bkpH/R6z3HneZhZ7ZKJUv9+5P0JjaX5jDJ8EfsKk5fzseTpCs7tkwV705h7LMt8hHxG7buzWeYlTVytlF/u9/v4uTVu+1EO7BuJ0zB/QV4/EubXpqtvzK/TFNI8ZyZY3DqanADPxjv5+SYm5p/XWGON5yuJbP7pwJmBv7jyOpt64SeVwuq6CIiACIiACIhAeQIdo5C28XclZ9FY2ozbvBkKx5rYgw04sP8MN9uQw0qATTH7mFl0tD8BGskzuf8fJqf2aQo79qMcfBpz7eCMP0Z2zqZT5A533ilmjjMT9D3VFilEPAvRFHY67Cq+A/EfKKO8Q6a5LBLOvjOaOM3X+ZEpAiIgAiIgAiKQjkDFl3G6aORrtAigWNxEQ+mjYfq7h4qo9f7v5mQyP84us/0J0Fi26bm2GYtlNlBKOR+mjNKY/lZOJGyUMOu1ihZnJkfamQmw64WZrXO0aZ2nM/ugNxMB0kfS1BzTZ6M+n+HMlkzXQnNfnw6fEZtFsAlpvJPn4ZkkSfHrpulGI6OhMnoQ5mBSGLmJgAiIgAiIgAhUR6BjFFKUsj1pXAybssv5DoaLhsU9GHPNbgfn9w7Zmv+fhtQ5NJ7Hk5dTQ2l3j0tNXs40P3E32dufAPd9gHJhjehPUzYiZZTzJ1DKAkUrDwo5jEB25MijOHo2zdw25sp8LTSdC6/ybMyl/O9M/NZ5dznmJ3lmhimYdq14mi5+bGRUymgelYfiFAEREAER6FgCHaOQ0oiwNaH2Cw4bAcESKKSYLf0dTRpYp9F462Gk9BtB5sI/lPBvk+/T4m6ydwYBGtO2m+4t5DaujFrmN8f9Sq4HGx1lTSPtCGTW6bZbfOIYrO/Mcy30mZSZna3c8CzsRP35S36HUl8GI6VLliyZwPlsrn3OlS0po46ETBEQAREQARHIlkAqhbSTd8PNFnc+sdFosg2MtiyOHQV1K7tGQyrY6Kj4+midN7o8NTq9vLkm5Se+Ayn33JTRYDfdmCxPYN88PA82OsJfLkppLE1ZO5BAUvksxkDZi5yw9xKm1xzi5RjlMLe10HTi3YPCeTZ1ZPD5F2TYieT/wnPzFPb+vr6+zTDdxmA2a0Yjo3aDdIiACIiACIhADgS6ysRpa5gadTQyrUblqSHp0GgyZTTYwCghwWBNqflJuNZop2rucTV+S+Wjmjiq8VsqvbzdU8tIebDNVtxuusEGRjTArcPi2piQ+9Eg3yN2LqsI1EMgdflMmwhK4ADldgr+o3JLXRaN+DMD5GyU1prXQjMKfarF4eQhbp/fppy/FzOujM4kHU3TdaBkioAIiIAIiEDGBEoqpLaGibQyb2QkyD8qa8Ro7Ng60cX2C+0JojW/E0qF7aAbrRslL2faLyb57qGfmFPjrVWUp0zKQ6PTy5toFfmx0ZzbkMfKdqCMWqMdt+LG/XN8f/E3dch9axjWpgW33QGvtqgfKtyYzO5hNeWzgkzDLlu55XcEv1eHXchgLTRxFsJnYwfsd/GL775rQ7j2fHwGpfgorg1bX1oki05FQAREQAREQAREoHMJMBp2s02Rsx/2MxwJs8fctcuuA9MhJpuxbMrvU8XZtZEfysZetkau+JrORaDZCFBex1OP/drVZUXmNfGRzHpl57lYm867iTw32y5atGi9euNTeBEQAREQAREQgXQEgo+Dp/MqX81IgAbUm2iUXYBs8+nJvyguIw2sYzifRO/+cYwEBN8AiV+XXQREQASalYApo9Rh5dZCm+jX2rTe+Ohms+ZHcomACIiACIiACIiACIiACIiACLQIAUZDvx4fEaXz7SwbEcXtmrg7SuueLZIliSkCIiACIiACIpBAoOQa0gS/chIBERABERCBhhBg1LMRa6EbkhclIgIiIAIiIAIiIAIiIAIiIAIi0GIEtBa6xW6YxBUBERABERABERABERABERABERABERABERABERCBViHw/wHIAHUN1iL6RwAAAABJRU5ErkJggg==) no-repeat;background-size:466px 146px}}.toastui-editor-toolbar-icons{background-position-y:3px}.toastui-editor-toolbar-icons:disabled{opacity:.3}.toastui-editor-toolbar-icons.heading{background-position-x:3px}.toastui-editor-toolbar-icons.bold{background-position-x:-23px}.toastui-editor-toolbar-icons.italic{background-position-x:-49px}.toastui-editor-toolbar-icons.strike{background-position-x:-75px}.toastui-editor-toolbar-icons.hrline{background-position-x:-101px}.toastui-editor-toolbar-icons.quote{background-position-x:-127px}.toastui-editor-toolbar-icons.bullet-list{background-position-x:-153px}.toastui-editor-toolbar-icons.ordered-list{background-position-x:-179px}.toastui-editor-toolbar-icons.task-list{background-position-x:-205px}.toastui-editor-toolbar-icons.indent{background-position-x:-231px}.toastui-editor-toolbar-icons.outdent{background-position-x:-257px}.toastui-editor-toolbar-icons.table{background-position-x:-283px}.toastui-editor-toolbar-icons.image{background-position-x:-309px}.toastui-editor-toolbar-icons.link{background-position-x:-334px}.toastui-editor-toolbar-icons.code{background-position-x:-361px}.toastui-editor-toolbar-icons.codeblock{background-position-x:-388px}.toastui-editor-toolbar-icons.more{background-position-x:-412px}.toastui-editor-toolbar-icons:not(:disabled).active{background-position-y:-23px}@media only screen and (max-width: 480px){.toastui-editor-popup{max-width:300px;margin-left:-150px}.toastui-editor-dropdown-toolbar{max-width:none}}.ProseMirror{font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;color:#222;font-size:13px;overflow-y:auto;overflow-X:hidden;height:calc(100% - 36px)}.ProseMirror .placeholder{color:#999}.ProseMirror:focus{outline:none}.ProseMirror-selectednode{outline:none}table.ProseMirror-selectednode,.html-block.ProseMirror-selectednode{border-radius:2px;outline:2px solid #00a9ff}.toastui-editor-contents{margin:0;padding:0;font-size:13px;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;z-index:20}.toastui-editor-contents *:not(table){line-height:160%;-webkit-box-sizing:content-box;box-sizing:content-box}.toastui-editor-contents i,.toastui-editor-contents cite,.toastui-editor-contents em,.toastui-editor-contents var,.toastui-editor-contents address,.toastui-editor-contents dfn{font-style:italic}.toastui-editor-contents strong{font-weight:700}.toastui-editor-contents p{margin:10px 0;color:#222}.toastui-editor-contents>h1:first-of-type,.toastui-editor-contents>div>div:first-of-type h1{margin-top:14px}.toastui-editor-contents h1,.toastui-editor-contents h2,.toastui-editor-contents h3,.toastui-editor-contents h4,.toastui-editor-contents h5,.toastui-editor-contents h6{font-weight:700;color:#222}.toastui-editor-contents h1{font-size:24px;line-height:28px;border-bottom:3px double #999;margin:52px 0 15px;padding-bottom:7px}.toastui-editor-contents h2{font-size:22px;line-height:23px;border-bottom:1px solid #dbdbdb;margin:20px 0 13px;padding-bottom:7px}.toastui-editor-contents h3{font-size:20px;margin:18px 0 2px}.toastui-editor-contents h4{font-size:18px;margin:10px 0 2px}.toastui-editor-contents h3,.toastui-editor-contents h4{line-height:18px}.toastui-editor-contents h5{font-size:16px}.toastui-editor-contents h6{font-size:14px}.toastui-editor-contents h5,.toastui-editor-contents h6{line-height:17px;margin:9px 0 -4px}.toastui-editor-contents del{color:#999}.toastui-editor-contents blockquote{margin:14px 0;border-left:4px solid #e5e5e5;padding:0 16px;color:#999}.toastui-editor-contents blockquote p,.toastui-editor-contents blockquote ul,.toastui-editor-contents blockquote ol{color:#999}.toastui-editor-contents blockquote>:first-child{margin-top:0}.toastui-editor-contents blockquote>:last-child{margin-bottom:0}.toastui-editor-contents pre,.toastui-editor-contents code{font-family:Consolas,Courier,Apple SD 산돌고딕 Neo,-apple-system,Lucida Grande,Apple SD Gothic Neo,맑은 고딕,Malgun Gothic,Segoe UI,돋움,dotum,sans-serif;border:0;border-radius:0}.toastui-editor-contents pre{margin:2px 0 8px;padding:18px;background-color:#f4f7f8}.toastui-editor-contents code{color:#c1798b;background-color:#f9f2f4;padding:2px 3px;letter-spacing:-.3px;border-radius:2px}.toastui-editor-contents pre code{padding:0;color:inherit;white-space:pre-wrap;background-color:transparent}.toastui-editor-contents img{margin:4px 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box;vertical-align:top;max-width:100%}.toastui-editor-contents table{border:1px solid rgba(0,0,0,.1);margin:12px 0 14px;color:#222;width:auto;border-collapse:collapse;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-contents table th,.toastui-editor-contents table td{border:1px solid rgba(0,0,0,.1);padding:5px 14px 5px 12px;height:32px}.toastui-editor-contents table th{background-color:#555;font-weight:300;color:#fff;padding-top:6px}.toastui-editor-contents th p{margin:0;color:#fff}.toastui-editor-contents td p{margin:0;padding:0 2px}.toastui-editor-contents td.toastui-editor-cell-selected{background-color:#d8dfec}.toastui-editor-contents th.toastui-editor-cell-selected{background-color:#908f8f}.toastui-editor-contents ul,.toastui-editor-contents menu,.toastui-editor-contents ol,.toastui-editor-contents dir{display:block;list-style-type:none;padding-left:24px;margin:6px 0 10px;color:#222}.toastui-editor-contents ol{list-style-type:none;counter-reset:li}.toastui-editor-contents ol>li{counter-increment:li}.toastui-editor-contents ul>li:before,.toastui-editor-contents ol>li:before{display:inline-block;position:absolute}.toastui-editor-contents ul>li:before{content:"";margin-top:6px;margin-left:-17px;width:5px;height:5px;border-radius:50%;background-color:#ccc}.toastui-editor-contents ol>li:before{content:"." counter(li);margin-left:-28px;width:24px;text-align:right;direction:rtl;color:#aaa}.toastui-editor-contents ul ul,.toastui-editor-contents ul ol,.toastui-editor-contents ol ol,.toastui-editor-contents ol ul{margin-top:0!important;margin-bottom:0!important}.toastui-editor-contents ul li,.toastui-editor-contents ol li{position:relative}.toastui-editor-contents ul p,.toastui-editor-contents ol p{margin:0}.toastui-editor-contents hr{border-top:1px solid #eee;margin:16px 0}.toastui-editor-contents a{text-decoration:underline;color:#4b96e6}.toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-contents .image-link{position:relative}.toastui-editor-contents .image-link:hover:before{content:"";position:absolute;width:30px;height:30px;right:0;border-radius:50%;border:1px solid #c9ccd5;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiM1NTUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAwIC00NTgxKSB0cmFuc2xhdGUoOTk1IDQ1NzYpIHRyYW5zbGF0ZSg1IDUpIHNjYWxlKDEgLTEpIHJvdGF0ZSg0NSAzNy4yOTMgMCkiLz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzI2IDQuOTM0bDEuODIyLjAwMmMxLjQ4NyAwIDIuNjkzIDEuMjI4IDIuNjkzIDIuNzQ0di4xOTJjMCAxLjUxNS0xLjIwNiAyLjc0NC0yLjY5MyAyLjc0NGgtMy44NDVjLTEuNDg3IDAtMi42OTItMS4yMjktMi42OTItMi43NDRWNy42OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMDAgLTQ1ODEpIHRyYW5zbGF0ZSg5OTUgNDU3NikgdHJhbnNsYXRlKDUgNSkgc2NhbGUoMSAtMSkgcm90YXRlKDQ1IDMwLjk5NiAwKSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K) no-repeat;background-position:center;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;cursor:pointer}.toastui-editor-contents .task-list-item{border:0;list-style:none;padding-left:24px;margin-left:-24px}.toastui-editor-contents .task-list-item:before{background-repeat:no-repeat;background-size:18px 18px;background-position:center;content:"";margin-left:0;margin-top:0;border-radius:2px;height:18px;width:18px;position:absolute;left:0;top:1px;cursor:pointer;background:transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQ0NDIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMjk2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMDQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==)}.toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-custom-block .toastui-editor-custom-block-editor{background:#f9f7fd;color:#452d6b;border:solid 1px #dbd4ea}.toastui-editor-custom-block .toastui-editor-custom-block-view{position:relative;padding:9px 13px 8px 12px}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{border:solid 1px #dbd4ea;border-radius:2px}.toastui-editor-custom-block .toastui-editor-custom-block-view .tool{position:absolute;right:10px;top:7px;display:none}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view .tool{display:block}.toastui-editor-custom-block-view button{vertical-align:middle;width:15px;height:15px;margin-left:8px;padding:3px;border:solid 1px #cccccc;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:center;background-size:30px 30px}.toastui-editor-custom-block-view .info{font-size:13px;font-weight:700;color:#5200d0;vertical-align:middle}.toastui-editor-contents .toastui-editor-ww-code-block{position:relative}.toastui-editor-contents .toastui-editor-ww-code-block:after{content:attr(data-language);position:absolute;display:inline-block;top:10px;right:10px;height:24px;padding:3px 35px 0 10px;font-weight:700;font-size:13px;color:#333;background:#e5e9ea url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:right;border-radius:2px;background-size:30px 30px;cursor:pointer}.toastui-editor-ww-code-block-language{position:fixed;display:inline-block;width:100px;height:27px;right:35px;border:1px solid #ccc;border-radius:2px;background-color:#fff;z-index:30}.toastui-editor-ww-code-block-language input{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:0 10px;height:100%;width:100%;background-color:transparent;border:none;outline:none}.toastui-editor-contents-placeholder:before{content:attr(data-placeholder);color:gray;line-height:160%;position:absolute}.toastui-editor-md-preview .toastui-editor-contents h1{min-height:28px}.toastui-editor-md-preview .toastui-editor-contents h2{min-height:23px}.toastui-editor-md-preview .toastui-editor-contents blockquote{min-height:20px}.toastui-editor-md-preview .toastui-editor-contents li{min-height:22px}.toastui-editor-pseudo-clipboard{position:fixed;opacity:0;width:0;height:0;left:-1000px;top:-1000px;z-index:-1}.toastui-editor-contents .toastui-editor-md-preview-highlight{position:relative;z-index:0}.toastui-editor-contents .toastui-editor-md-preview-highlight:after{content:"";background-color:#fff58380;border-radius:4px;z-index:-1;position:absolute;inset:-4px}.toastui-editor-contents h1.toastui-editor-md-preview-highlight:after,.toastui-editor-contents h2.toastui-editor-md-preview-highlight:after{bottom:0}.toastui-editor-contents td.toastui-editor-md-preview-highlight:after,.toastui-editor-contents th.toastui-editor-md-preview-highlight:after{display:none}.toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fff58380}.toastui-editor-contents th.toastui-editor-md-preview-highlight{color:#222}.toastui-editor-md-heading1{font-size:24px}.toastui-editor-md-heading2{font-size:22px}.toastui-editor-md-heading3{font-size:20px}.toastui-editor-md-heading4{font-size:18px}.toastui-editor-md-heading5{font-size:16px}.toastui-editor-md-heading6{font-size:14px}.toastui-editor-md-heading.toastui-editor-md-delimiter.setext{line-height:15px}.toastui-editor-md-strong,.toastui-editor-md-heading,.toastui-editor-md-list-item-style,.toastui-editor-md-list-item .toastui-editor-md-meta{font-weight:700}.toastui-editor-md-emph{font-style:italic}.toastui-editor-md-strike{text-decoration:line-through}.toastui-editor-md-strike.toastui-editor-md-delimiter{text-decoration:none}.toastui-editor-md-delimiter,.toastui-editor-md-thematic-break,.toastui-editor-md-link,.toastui-editor-md-table,.toastui-editor-md-block-quote{color:#ccc}.toastui-editor-md-code.toastui-editor-md-delimiter{color:#aaa}.toastui-editor-md-meta,.toastui-editor-md-html,.toastui-editor-md-link.toastui-editor-md-link-url.toastui-editor-md-marked-text{color:#999}.toastui-editor-md-block-quote .toastui-editor-md-marked-text,.toastui-editor-md-list-item .toastui-editor-md-meta{color:#555}.toastui-editor-md-table .toastui-editor-md-table-cell{color:#222}.toastui-editor-md-link.toastui-editor-md-link-desc.toastui-editor-md-marked-text,.toastui-editor-md-list-item-style.toastui-editor-md-list-item-odd{color:#4b96e6}.toastui-editor-md-list-item-style.toastui-editor-md-list-item-even{color:#cb4848}.toastui-editor-md-code.toastui-editor-md-marked-text{color:#c1798b}.toastui-editor-md-code{background-color:#f3e5e980;padding:2px 0;letter-spacing:-.3px}.toastui-editor-md-code.toastui-editor-md-start{padding-left:2px;border-top-left-radius:2px;border-bottom-left-radius:2px}.toastui-editor-md-code.toastui-editor-md-end{padding-right:2px;border-top-right-radius:2px;border-bottom-right-radius:2px}.toastui-editor-md-code-block-line-background{background-color:#f5f7f8}.toastui-editor-md-code-block-line-background.start,.toastui-editor-md-custom-block-line-background.start{margin-top:2px}.toastui-editor-md-code,.toastui-editor-md-code-block{font-family:Consolas,Courier,Lucida Grande,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif}.toastui-editor-md-custom-block{color:#452d6b}.toastui-editor-md-custom-block-line-background{background-color:#f9f7fd}.toastui-editor-md-custom-block .toastui-editor-md-delimiter{color:#b8b3c0}.toastui-editor-md-custom-block .toastui-editor-md-meta{color:#5200d0}
`, dark = `@charset "UTF-8";.toastui-editor-dark.toastui-editor-defaultUI{border-color:#494c56;color:#eee}.toastui-editor-dark .toastui-editor-md-container,.toastui-editor-dark .toastui-editor-ww-container{background-color:#121212}.toastui-editor-dark .toastui-editor-defaultUI-toolbar{background-color:#232428;border-bottom-color:#303238}.toastui-editor-dark .toastui-editor-toolbar-icons{background-position-y:-49px;border-color:#232428}.toastui-editor-dark .toastui-editor-toolbar-icons:not(:disabled):hover{background-color:#36383f;border-color:#36383f}.toastui-editor-dark .toastui-editor-toolbar-divider{background-color:#303238}.toastui-editor-dark .toastui-editor-tooltip,.toastui-editor-dark .toastui-editor-tooltip .arrow{background-color:#535662}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .scroll-sync:before{color:#8f939f}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .scroll-sync.active:before{color:#67ccff}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .switch{background-color:#2b4455}.toastui-editor-dark .toastui-editor-defaultUI-toolbar input:checked+.switch{background-color:#2b4455}.toastui-editor-dark .toastui-editor-defaultUI-toolbar .switch:before{background-color:#8f939f}.toastui-editor-dark .toastui-editor-defaultUI-toolbar input:checked+.switch:before{background-color:#67ccff}.toastui-editor-dark .toastui-editor-main .toastui-editor-md-splitter{background-color:#303238}.toastui-editor-dark .toastui-editor-mode-switch{border-top-color:#393b42;background-color:#121212}.toastui-editor-dark .toastui-editor-mode-switch .tab-item{border-color:#393b42;background-color:#232428;color:#757a86}.toastui-editor-dark .toastui-editor-mode-switch .tab-item.active{border-top-color:#121212;background-color:#121212;color:#eee}.toastui-editor-dark .toastui-editor-popup,.toastui-editor-dark .toastui-editor-context-menu{background-color:#121212;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border-color:#494c56}.toastui-editor-dark .toastui-editor-popup-add-heading ul li:hover{background-color:#36383f}.toastui-editor-dark .toastui-editor-popup-body label{color:#9a9da3}.toastui-editor-dark .toastui-editor-popup-body input[type=text]{background-color:transparent;color:#eee;border-color:#303238}.toastui-editor-dark .toastui-editor-popup-body input[type=text]:focus{outline-color:#67ccff}.toastui-editor-dark .toastui-editor-popup-body input[type=text].disabled{color:#969aa5;border-color:#303238;background-color:#30323866}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item{border-bottom-color:#292e37;color:#eee}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item:hover{border-bottom-color:#3c424d}.toastui-editor-dark .toastui-editor-popup-add-image .toastui-editor-tabs .tab-item.active{color:#67ccff;border-bottom-color:#67ccff}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-name{border-color:#303238;color:#eee}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-select-button{border-color:#303238;background-color:#232428;color:#eee}.toastui-editor-dark .toastui-editor-popup-body .toastui-editor-file-select-button:hover{border-color:#494c56}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-close-button{color:#eee;border-color:#303238;background-color:#232428}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-close-button:hover{border-color:#494c56}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-ok-button{color:#121212;background-color:#67ccff}.toastui-editor-dark.toastui-editor-defaultUI .toastui-editor-ok-button:hover{color:#121212;background-color:#32baff}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-cell{border-color:#303238;background-color:#121212}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-cell.header{border-color:#303238;background-color:#232428}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-selection-layer{border-color:#67ccff66;background-color:#67ccff1a}.toastui-editor-dark .toastui-editor-popup-add-table .toastui-editor-table-description{color:#eee}.toastui-editor-dark .toastui-editor-md-tab-container{background-color:#232428;border-bottom-color:#303238}.toastui-editor-dark .toastui-editor-md-tab-container .tab-item{border-color:#393b42;background-color:#2d2f34;color:#757a86}.toastui-editor-dark .toastui-editor-md-tab-container .tab-item.active{border-bottom-color:#121212;background-color:#121212;color:#eee}.toastui-editor-dark .toastui-editor-context-menu .menu-group{border-bottom-color:#303238;color:#eee}.toastui-editor-dark .toastui-editor-context-menu .menu-item span:before{background-position-y:-126px}.toastui-editor-dark .toastui-editor-context-menu li:not(.disabled):hover{background-color:#36383f}.toastui-editor-dark .toastui-editor-context-menu li.disabled{color:#969aa5}.toastui-editor-dark .toastui-editor-dropdown-toolbar{border-color:#494c56;background-color:#232428}.toastui-editor-dark .ProseMirror,.toastui-editor-dark .toastui-editor-contents p,.toastui-editor-dark .toastui-editor-contents h1,.toastui-editor-dark .toastui-editor-contents h2,.toastui-editor-dark .toastui-editor-contents h3,.toastui-editor-dark .toastui-editor-contents h4,.toastui-editor-dark .toastui-editor-contents h5,.toastui-editor-dark .toastui-editor-contents h6{color:#fff}.toastui-editor-dark .toastui-editor-contents h1,.toastui-editor-dark .toastui-editor-contents h2{border-color:#fff}.toastui-editor-dark .toastui-editor-contents del{color:#777980}.toastui-editor-dark .toastui-editor-contents blockquote{border-color:#303135}.toastui-editor-dark .toastui-editor-contents blockquote p,.toastui-editor-dark .toastui-editor-contents blockquote ul,.toastui-editor-dark .toastui-editor-contents blockquote ol{color:#777980}.toastui-editor-dark .toastui-editor-contents pre{background-color:#232428}.toastui-editor-dark .toastui-editor-contents pre code{background-color:transparent;color:#fff}.toastui-editor-dark .toastui-editor-contents code{color:#c1798b;background-color:#35262a}.toastui-editor-dark .toastui-editor-contents div{color:#fff}.toastui-editor-dark .toastui-editor-ww-code-block-language{border-color:#303238;background-color:#121212}.toastui-editor-dark .toastui-editor-ww-code-block-language input{color:#fff}.toastui-editor-dark .toastui-editor-contents .toastui-editor-ww-code-block:after{background-color:#232428;border:1px solid #393b42;color:#eee;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6I2ZmZjt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==)}.toastui-editor-dark .toastui-editor-contents .toastui-editor-custom-block-editor{background:#392d31;color:#fff;border-color:#327491}.toastui-editor-dark .toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{color:#fff;border-color:#327491}.toastui-editor-dark .toastui-editor-custom-block-view button{background-color:#232428;border-color:#393b42;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6I2ZmZjt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==)}.toastui-editor-dark .toastui-editor-custom-block-view button:hover{background-color:#232428;border-color:#595c68}.toastui-editor-dark .toastui-editor-custom-block-view .info{color:#65acca}.toastui-editor-dark .toastui-editor-contents table,.toastui-editor-dark .toastui-editor-contents table th,.toastui-editor-dark .toastui-editor-contents table td{border-color:#303238}.toastui-editor-dark .toastui-editor-contents table th{background-color:#3a3c42}.toastui-editor-dark .toastui-editor-contents table td,.toastui-editor-dark .toastui-editor-contents table td p{color:#fff}.toastui-editor-dark .toastui-editor-contents td.toastui-editor-cell-selected{background-color:#67ccff80}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-cell-selected{background-color:#67ccff4d}.toastui-editor-dark table.ProseMirror-selectednode,.toastui-editor-dark .html-block.ProseMirror-selectednode{outline-color:#67ccff}.toastui-editor-dark .toastui-editor-contents ul,.toastui-editor-dark .toastui-editor-contents menu,.toastui-editor-dark .toastui-editor-contents ol,.toastui-editor-dark .toastui-editor-contents dir{color:#55575f}.toastui-editor-dark .toastui-editor-contents ul>li:before{background-color:#55575f}.toastui-editor-dark .toastui-editor-contents hr{border-color:#55575f}.toastui-editor-dark .toastui-editor-contents a{color:#4b96e6}.toastui-editor-dark .toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-dark .toastui-editor-contents .image-link:hover:before{border-color:#393b42;background-color:#232428;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiNFRUUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDQ1IC0xNzQzKSB0cmFuc2xhdGUoMTA0MCAxNzM4KSB0cmFuc2xhdGUoNSA1KSBzY2FsZSgxIC0xKSByb3RhdGUoNDUgMzcuMjkzIDApIi8+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEyLjMyNiA0LjkzNGwxLjgyMi4wMDJjMS40ODcgMCAyLjY5MyAxLjIyOCAyLjY5MyAyLjc0NHYuMTkyYzAgMS41MTUtMS4yMDYgMi43NDQtMi42OTMgMi43NDRoLTMuODQ1Yy0xLjQ4NyAwLTIuNjkyLTEuMjI5LTIuNjkyLTIuNzQ0VjcuNjgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDQ1IC0xNzQzKSB0cmFuc2xhdGUoMTA0MCAxNzM4KSB0cmFuc2xhdGUoNSA1KSBzY2FsZSgxIC0xKSByb3RhdGUoNDUgMzAuOTk2IDApIi8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPgo=);-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014}.toastui-editor-dark .toastui-editor-contents .task-list-item:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgc3Ryb2tlPSIjNTU1NzVGIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMzE2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMjQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==);background-color:transparent}.toastui-editor-dark .toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-dark .toastui-editor-md-delimiter,.toastui-editor-dark .toastui-editor-md-code.toastui-editor-md-delimiter,.toastui-editor-dark .toastui-editor-md-thematic-break,.toastui-editor-dark .toastui-editor-md-link,.toastui-editor-dark .toastui-editor-md-table,.toastui-editor-dark .toastui-editor-md-block-quote,.toastui-editor-dark .toastui-editor-md-meta,.toastui-editor-dark .toastui-editor-md-html{color:#55575f}.toastui-editor-dark .toastui-editor-md-link.toastui-editor-md-link-url.toastui-editor-md-marked-text{color:#777980}.toastui-editor-dark .toastui-editor-md-block-quote .toastui-editor-md-marked-text,.toastui-editor-dark .toastui-editor-md-list-item .toastui-editor-md-meta{color:#b3b5bc}.toastui-editor-dark .toastui-editor-md-link.toastui-editor-md-link-desc.toastui-editor-md-marked-text,.toastui-editor-dark .toastui-editor-md-list-item-style.toastui-editor-md-list-item-odd{color:#4b96e6}.toastui-editor-dark .toastui-editor-md-list-item-style.toastui-editor-md-list-item-even{color:#ef6767}.toastui-editor-dark .toastui-editor-md-table .toastui-editor-md-table-cell{color:#fff}.toastui-editor-dark .toastui-editor-md-code.toastui-editor-md-marked-text{color:#c1798b}.toastui-editor-dark .toastui-editor-md-code{background-color:#35262a}.toastui-editor-dark .toastui-editor-md-code-block-line-background{background-color:#232428}.toastui-editor-dark .toastui-editor-md-code-block .toastui-editor-md-meta{color:#aaa}.toastui-editor-dark .toastui-editor-md-custom-block{color:#fff}.toastui-editor-dark .toastui-editor-md-custom-block-line-background{background-color:#392d31}.toastui-editor-dark .toastui-editor-md-custom-block .toastui-editor-md-delimiter{color:#327491}.toastui-editor-dark .toastui-editor-md-custom-block .toastui-editor-md-meta{color:#65acca}.toastui-editor-dark .toastui-editor-contents .toastui-editor-md-preview-highlight:after{background-color:#fffac180}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-dark .toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fffac180}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight{color:#fff}.toastui-editor-dark .toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-dark .toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fffac140}.toastui-editor-dark .toastui-editor-contents .toastui-editor-md-preview-highlight:after{background-color:#fffac140}
`;
var dist = {}, api = {}, streamUploader = {}, upload = {}, sjcl = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(lr) {
  var ar = { cipher: {}, hash: {}, keyexchange: {}, mode: {}, misc: {}, codec: {}, exception: { corrupt: function(Er) {
    this.toString = function() {
      return "CORRUPT: " + this.message;
    }, this.message = Er;
  }, invalid: function(Er) {
    this.toString = function() {
      return "INVALID: " + this.message;
    }, this.message = Er;
  }, bug: function(Er) {
    this.toString = function() {
      return "BUG: " + this.message;
    }, this.message = Er;
  }, notReady: function(Er) {
    this.toString = function() {
      return "NOT READY: " + this.message;
    }, this.message = Er;
  } } };
  ar.cipher.aes = function(Er) {
    this.s[0][0][0] || this.O();
    var Cr, Tr, Ar, Ir, Mr = this.s[0][4], Hr = this.s[1];
    Cr = Er.length;
    var Br = 1;
    if (Cr !== 4 && Cr !== 6 && Cr !== 8)
      throw new ar.exception.invalid("invalid aes key size");
    for (this.b = [Ar = Er.slice(0), Ir = []], Er = Cr; Er < 4 * Cr + 28; Er++)
      Tr = Ar[Er - 1], (Er % Cr === 0 || Cr === 8 && Er % Cr === 4) && (Tr = Mr[Tr >>> 24] << 24 ^ Mr[Tr >> 16 & 255] << 16 ^ Mr[Tr >> 8 & 255] << 8 ^ Mr[Tr & 255], Er % Cr === 0 && (Tr = Tr << 8 ^ Tr >>> 24 ^ Br << 24, Br = Br << 1 ^ 283 * (Br >> 7))), Ar[Er] = Ar[Er - Cr] ^ Tr;
    for (Cr = 0; Er; Cr++, Er--)
      Tr = Ar[Cr & 3 ? Er : Er - 4], Ir[Cr] = 4 >= Er || 4 > Cr ? Tr : Hr[0][Mr[Tr >>> 24]] ^ Hr[1][Mr[Tr >> 16 & 255]] ^ Hr[2][Mr[Tr >> 8 & 255]] ^ Hr[3][Mr[Tr & 255]];
  }, ar.cipher.aes.prototype = { encrypt: function(Er) {
    return cr(this, Er, 0);
  }, decrypt: function(Er) {
    return cr(this, Er, 1);
  }, s: [[[], [], [], [], []], [[], [], [], [], []]], O: function() {
    var Er = this.s[0], Cr = this.s[1], Tr = Er[4], Ar = Cr[4], Ir, Mr, Hr, Br = [], zr = [], Gr, Xr, Jr, li;
    for (Ir = 0; 256 > Ir; Ir++)
      zr[(Br[Ir] = Ir << 1 ^ 283 * (Ir >> 7)) ^ Ir] = Ir;
    for (Mr = Hr = 0; !Tr[Mr]; Mr ^= Gr || 1, Hr = zr[Hr] || 1)
      for (Jr = Hr ^ Hr << 1 ^ Hr << 2 ^ Hr << 3 ^ Hr << 4, Jr = Jr >> 8 ^ Jr & 255 ^ 99, Tr[Mr] = Jr, Ar[Jr] = Mr, Xr = Br[Ir = Br[Gr = Br[Mr]]], li = 16843009 * Xr ^ 65537 * Ir ^ 257 * Gr ^ 16843008 * Mr, Xr = 257 * Br[Jr] ^ 16843008 * Jr, Ir = 0; 4 > Ir; Ir++)
        Er[Ir][Mr] = Xr = Xr << 24 ^ Xr >>> 8, Cr[Ir][Jr] = li = li << 24 ^ li >>> 8;
    for (Ir = 0; 5 > Ir; Ir++)
      Er[Ir] = Er[Ir].slice(0), Cr[Ir] = Cr[Ir].slice(0);
  } };
  function cr(Er, Cr, Tr) {
    if (Cr.length !== 4)
      throw new ar.exception.invalid("invalid aes block size");
    var Ar = Er.b[Tr], Ir = Cr[0] ^ Ar[0], Mr = Cr[Tr ? 3 : 1] ^ Ar[1], Hr = Cr[2] ^ Ar[2];
    Cr = Cr[Tr ? 1 : 3] ^ Ar[3];
    var Br, zr, Gr, Xr = Ar.length / 4 - 2, Jr, li = 4, Qr = [0, 0, 0, 0];
    Br = Er.s[Tr], Er = Br[0];
    var ei = Br[1], ui = Br[2], Ai = Br[3], fi = Br[4];
    for (Jr = 0; Jr < Xr; Jr++)
      Br = Er[Ir >>> 24] ^ ei[Mr >> 16 & 255] ^ ui[Hr >> 8 & 255] ^ Ai[Cr & 255] ^ Ar[li], zr = Er[Mr >>> 24] ^ ei[Hr >> 16 & 255] ^ ui[Cr >> 8 & 255] ^ Ai[Ir & 255] ^ Ar[li + 1], Gr = Er[Hr >>> 24] ^ ei[Cr >> 16 & 255] ^ ui[Ir >> 8 & 255] ^ Ai[Mr & 255] ^ Ar[li + 2], Cr = Er[Cr >>> 24] ^ ei[Ir >> 16 & 255] ^ ui[Mr >> 8 & 255] ^ Ai[Hr & 255] ^ Ar[li + 3], li += 4, Ir = Br, Mr = zr, Hr = Gr;
    for (Jr = 0; 4 > Jr; Jr++)
      Qr[Tr ? 3 & -Jr : Jr] = fi[Ir >>> 24] << 24 ^ fi[Mr >> 16 & 255] << 16 ^ fi[Hr >> 8 & 255] << 8 ^ fi[Cr & 255] ^ Ar[li++], Br = Ir, Ir = Mr, Mr = Hr, Hr = Cr, Cr = Br;
    return Qr;
  }
  ar.bitArray = { bitSlice: function(Er, Cr, Tr) {
    return Er = ar.bitArray.$(Er.slice(Cr / 32), 32 - (Cr & 31)).slice(1), Tr === void 0 ? Er : ar.bitArray.clamp(Er, Tr - Cr);
  }, extract: function(Er, Cr, Tr) {
    var Ar = Math.floor(-Cr - Tr & 31);
    return ((Cr + Tr - 1 ^ Cr) & -32 ? Er[Cr / 32 | 0] << 32 - Ar ^ Er[Cr / 32 + 1 | 0] >>> Ar : Er[Cr / 32 | 0] >>> Ar) & (1 << Tr) - 1;
  }, concat: function(Er, Cr) {
    if (Er.length === 0 || Cr.length === 0)
      return Er.concat(Cr);
    var Tr = Er[Er.length - 1], Ar = ar.bitArray.getPartial(Tr);
    return Ar === 32 ? Er.concat(Cr) : ar.bitArray.$(Cr, Ar, Tr | 0, Er.slice(0, Er.length - 1));
  }, bitLength: function(Er) {
    var Cr = Er.length;
    return Cr === 0 ? 0 : 32 * (Cr - 1) + ar.bitArray.getPartial(Er[Cr - 1]);
  }, clamp: function(Er, Cr) {
    if (32 * Er.length < Cr)
      return Er;
    Er = Er.slice(0, Math.ceil(Cr / 32));
    var Tr = Er.length;
    return Cr = Cr & 31, 0 < Tr && Cr && (Er[Tr - 1] = ar.bitArray.partial(Cr, Er[Tr - 1] & 2147483648 >> Cr - 1, 1)), Er;
  }, partial: function(Er, Cr, Tr) {
    return Er === 32 ? Cr : (Tr ? Cr | 0 : Cr << 32 - Er) + 1099511627776 * Er;
  }, getPartial: function(Er) {
    return Math.round(Er / 1099511627776) || 32;
  }, equal: function(Er, Cr) {
    if (ar.bitArray.bitLength(Er) !== ar.bitArray.bitLength(Cr))
      return !1;
    var Tr = 0, Ar;
    for (Ar = 0; Ar < Er.length; Ar++)
      Tr |= Er[Ar] ^ Cr[Ar];
    return Tr === 0;
  }, $: function(Er, Cr, Tr, Ar) {
    var Ir;
    for (Ir = 0, Ar === void 0 && (Ar = []); 32 <= Cr; Cr -= 32)
      Ar.push(Tr), Tr = 0;
    if (Cr === 0)
      return Ar.concat(Er);
    for (Ir = 0; Ir < Er.length; Ir++)
      Ar.push(Tr | Er[Ir] >>> Cr), Tr = Er[Ir] << 32 - Cr;
    return Ir = Er.length ? Er[Er.length - 1] : 0, Er = ar.bitArray.getPartial(Ir), Ar.push(ar.bitArray.partial(Cr + Er & 31, 32 < Cr + Er ? Tr : Ar.pop(), 1)), Ar;
  }, i: function(Er, Cr) {
    return [Er[0] ^ Cr[0], Er[1] ^ Cr[1], Er[2] ^ Cr[2], Er[3] ^ Cr[3]];
  }, byteswapM: function(Er) {
    var Cr, Tr;
    for (Cr = 0; Cr < Er.length; ++Cr)
      Tr = Er[Cr], Er[Cr] = Tr >>> 24 | Tr >>> 8 & 65280 | (Tr & 65280) << 8 | Tr << 24;
    return Er;
  } }, ar.codec.utf8String = { fromBits: function(Er) {
    var Cr = "", Tr = ar.bitArray.bitLength(Er), Ar, Ir;
    for (Ar = 0; Ar < Tr / 8; Ar++)
      !(Ar & 3) && (Ir = Er[Ar / 4]), Cr += String.fromCharCode(Ir >>> 8 >>> 8 >>> 8), Ir <<= 8;
    return decodeURIComponent(escape(Cr));
  }, toBits: function(Er) {
    Er = unescape(encodeURIComponent(Er));
    var Cr = [], Tr, Ar = 0;
    for (Tr = 0; Tr < Er.length; Tr++)
      Ar = Ar << 8 | Er.charCodeAt(Tr), (Tr & 3) === 3 && (Cr.push(Ar), Ar = 0);
    return Tr & 3 && Cr.push(ar.bitArray.partial(8 * (Tr & 3), Ar)), Cr;
  } }, ar.codec.hex = { fromBits: function(Er) {
    var Cr = "", Tr;
    for (Tr = 0; Tr < Er.length; Tr++)
      Cr += ((Er[Tr] | 0) + 263882790666240).toString(16).substr(4);
    return Cr.substr(0, ar.bitArray.bitLength(Er) / 4);
  }, toBits: function(Er) {
    var Cr, Tr = [], Ar;
    for (Er = Er.replace(/\s|0x/g, ""), Ar = Er.length, Er = Er + "00000000", Cr = 0; Cr < Er.length; Cr += 8)
      Tr.push(parseInt(Er.substr(Cr, 8), 16) ^ 0);
    return ar.bitArray.clamp(Tr, 4 * Ar);
  } }, ar.codec.base32 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", X: "0123456789ABCDEFGHIJKLMNOPQRSTUV", BITS: 32, BASE: 5, REMAINING: 27, fromBits: function(Er, Cr, Tr) {
    var Ar = ar.codec.base32.BASE, Ir = ar.codec.base32.REMAINING, Mr = "", Hr = 0, Br = ar.codec.base32.B, zr = 0, Gr = ar.bitArray.bitLength(Er);
    for (Tr && (Br = ar.codec.base32.X), Tr = 0; Mr.length * Ar < Gr; )
      Mr += Br.charAt((zr ^ Er[Tr] >>> Hr) >>> Ir), Hr < Ar ? (zr = Er[Tr] << Ar - Hr, Hr += Ir, Tr++) : (zr <<= Ar, Hr -= Ar);
    for (; Mr.length & 7 && !Cr; )
      Mr += "=";
    return Mr;
  }, toBits: function(Er, Cr) {
    Er = Er.replace(/\s|=/g, "").toUpperCase();
    var Tr = ar.codec.base32.BITS, Ar = ar.codec.base32.BASE, Ir = ar.codec.base32.REMAINING, Mr = [], Hr, Br = 0, zr = ar.codec.base32.B, Gr = 0, Xr, Jr = "base32";
    for (Cr && (zr = ar.codec.base32.X, Jr = "base32hex"), Hr = 0; Hr < Er.length; Hr++) {
      if (Xr = zr.indexOf(Er.charAt(Hr)), 0 > Xr) {
        if (!Cr)
          try {
            return ar.codec.base32hex.toBits(Er);
          } catch (li) {
          }
        throw new ar.exception.invalid("this isn't " + Jr + "!");
      }
      Br > Ir ? (Br -= Ir, Mr.push(Gr ^ Xr >>> Br), Gr = Xr << Tr - Br) : (Br += Ar, Gr ^= Xr << Tr - Br);
    }
    return Br & 56 && Mr.push(ar.bitArray.partial(Br & 56, Gr, 1)), Mr;
  } }, ar.codec.base32hex = { fromBits: function(Er, Cr) {
    return ar.codec.base32.fromBits(Er, Cr, 1);
  }, toBits: function(Er) {
    return ar.codec.base32.toBits(Er, 1);
  } }, ar.codec.base64 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fromBits: function(Er, Cr, Tr) {
    var Ar = "", Ir = 0, Mr = ar.codec.base64.B, Hr = 0, Br = ar.bitArray.bitLength(Er);
    for (Tr && (Mr = Mr.substr(0, 62) + "-_"), Tr = 0; 6 * Ar.length < Br; )
      Ar += Mr.charAt((Hr ^ Er[Tr] >>> Ir) >>> 26), 6 > Ir ? (Hr = Er[Tr] << 6 - Ir, Ir += 26, Tr++) : (Hr <<= 6, Ir -= 6);
    for (; Ar.length & 3 && !Cr; )
      Ar += "=";
    return Ar;
  }, toBits: function(Er, Cr) {
    Er = Er.replace(/\s|=/g, "");
    var Tr = [], Ar, Ir = 0, Mr = ar.codec.base64.B, Hr = 0, Br;
    for (Cr && (Mr = Mr.substr(0, 62) + "-_"), Ar = 0; Ar < Er.length; Ar++) {
      if (Br = Mr.indexOf(Er.charAt(Ar)), 0 > Br)
        throw new ar.exception.invalid("this isn't base64!");
      26 < Ir ? (Ir -= 26, Tr.push(Hr ^ Br >>> Ir), Hr = Br << 32 - Ir) : (Ir += 6, Hr ^= Br << 32 - Ir);
    }
    return Ir & 56 && Tr.push(ar.bitArray.partial(Ir & 56, Hr, 1)), Tr;
  } }, ar.codec.base64url = { fromBits: function(Er) {
    return ar.codec.base64.fromBits(Er, 1, 1);
  }, toBits: function(Er) {
    return ar.codec.base64.toBits(Er, 1);
  } }, ar.hash.sha256 = function(Er) {
    this.b[0] || this.O(), Er ? (this.F = Er.F.slice(0), this.A = Er.A.slice(0), this.l = Er.l) : this.reset();
  }, ar.hash.sha256.hash = function(Er) {
    return new ar.hash.sha256().update(Er).finalize();
  }, ar.hash.sha256.prototype = { blockSize: 512, reset: function() {
    return this.F = this.Y.slice(0), this.A = [], this.l = 0, this;
  }, update: function(Er) {
    typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er));
    var Cr, Tr = this.A = ar.bitArray.concat(this.A, Er);
    if (Cr = this.l, Er = this.l = Cr + ar.bitArray.bitLength(Er), 9007199254740991 < Er)
      throw new ar.exception.invalid("Cannot hash more than 2^53 - 1 bits");
    if (typeof Uint32Array != "undefined") {
      var Ar = new Uint32Array(Tr), Ir = 0;
      for (Cr = 512 + Cr - (512 + Cr & 511); Cr <= Er; Cr += 512)
        ur(this, Ar.subarray(
          16 * Ir,
          16 * (Ir + 1)
        )), Ir += 1;
      Tr.splice(0, 16 * Ir);
    } else
      for (Cr = 512 + Cr - (512 + Cr & 511); Cr <= Er; Cr += 512)
        ur(this, Tr.splice(0, 16));
    return this;
  }, finalize: function() {
    var Er, Tr = this.A, Cr = this.F, Tr = ar.bitArray.concat(Tr, [ar.bitArray.partial(1, 1)]);
    for (Er = Tr.length + 2; Er & 15; Er++)
      Tr.push(0);
    for (Tr.push(Math.floor(this.l / 4294967296)), Tr.push(this.l | 0); Tr.length; )
      ur(this, Tr.splice(0, 16));
    return this.reset(), Cr;
  }, Y: [], b: [], O: function() {
    function Er(Mr) {
      return 4294967296 * (Mr - Math.floor(Mr)) | 0;
    }
    for (var Cr = 0, Tr = 2, Ar, Ir; 64 > Cr; Tr++) {
      for (Ir = !0, Ar = 2; Ar * Ar <= Tr; Ar++)
        if (Tr % Ar === 0) {
          Ir = !1;
          break;
        }
      Ir && (8 > Cr && (this.Y[Cr] = Er(Math.pow(Tr, 0.5))), this.b[Cr] = Er(Math.pow(Tr, 1 / 3)), Cr++);
    }
  } };
  function ur(Er, Cr) {
    var Tr, Ar, Ir, Mr = Er.F, Hr = Er.b, Br = Mr[0], zr = Mr[1], Gr = Mr[2], Xr = Mr[3], Jr = Mr[4], li = Mr[5], Qr = Mr[6], ei = Mr[7];
    for (Tr = 0; 64 > Tr; Tr++)
      16 > Tr ? Ar = Cr[Tr] : (Ar = Cr[Tr + 1 & 15], Ir = Cr[Tr + 14 & 15], Ar = Cr[Tr & 15] = (Ar >>> 7 ^ Ar >>> 18 ^ Ar >>> 3 ^ Ar << 25 ^ Ar << 14) + (Ir >>> 17 ^ Ir >>> 19 ^ Ir >>> 10 ^ Ir << 15 ^ Ir << 13) + Cr[Tr & 15] + Cr[Tr + 9 & 15] | 0), Ar = Ar + ei + (Jr >>> 6 ^ Jr >>> 11 ^ Jr >>> 25 ^ Jr << 26 ^ Jr << 21 ^ Jr << 7) + (Qr ^ Jr & (li ^ Qr)) + Hr[Tr], ei = Qr, Qr = li, li = Jr, Jr = Xr + Ar | 0, Xr = Gr, Gr = zr, zr = Br, Br = Ar + (zr & Gr ^ Xr & (zr ^ Gr)) + (zr >>> 2 ^ zr >>> 13 ^ zr >>> 22 ^ zr << 30 ^ zr << 19 ^ zr << 10) | 0;
    Mr[0] = Mr[0] + Br | 0, Mr[1] = Mr[1] + zr | 0, Mr[2] = Mr[2] + Gr | 0, Mr[3] = Mr[3] + Xr | 0, Mr[4] = Mr[4] + Jr | 0, Mr[5] = Mr[5] + li | 0, Mr[6] = Mr[6] + Qr | 0, Mr[7] = Mr[7] + ei | 0;
  }
  ar.mode.ccm = { name: "ccm", G: [], listenProgress: function(Er) {
    ar.mode.ccm.G.push(Er);
  }, unListenProgress: function(Er) {
    Er = ar.mode.ccm.G.indexOf(Er), -1 < Er && ar.mode.ccm.G.splice(Er, 1);
  }, fa: function(Er) {
    var Cr = ar.mode.ccm.G.slice(), Tr;
    for (Tr = 0; Tr < Cr.length; Tr += 1)
      Cr[Tr](Er);
  }, encrypt: function(Er, Cr, Tr, Ar, Ir) {
    var Mr, Hr = Cr.slice(0), Br = ar.bitArray, zr = Br.bitLength(Tr) / 8, Gr = Br.bitLength(Hr) / 8;
    if (Ir = Ir || 64, Ar = Ar || [], 7 > zr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Mr = 2; 4 > Mr && Gr >>> 8 * Mr; Mr++)
      ;
    return Mr < 15 - zr && (Mr = 15 - zr), Tr = Br.clamp(
      Tr,
      8 * (15 - Mr)
    ), Cr = ar.mode.ccm.V(Er, Cr, Tr, Ar, Ir, Mr), Hr = ar.mode.ccm.C(Er, Hr, Tr, Cr, Ir, Mr), Br.concat(Hr.data, Hr.tag);
  }, decrypt: function(Er, Cr, Tr, Ar, Ir) {
    Ir = Ir || 64, Ar = Ar || [];
    var Mr = ar.bitArray, Hr = Mr.bitLength(Tr) / 8, Gr = Mr.bitLength(Cr), Br = Mr.clamp(Cr, Gr - Ir), zr = Mr.bitSlice(Cr, Gr - Ir), Gr = (Gr - Ir) / 8;
    if (7 > Hr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Cr = 2; 4 > Cr && Gr >>> 8 * Cr; Cr++)
      ;
    if (Cr < 15 - Hr && (Cr = 15 - Hr), Tr = Mr.clamp(Tr, 8 * (15 - Cr)), Br = ar.mode.ccm.C(Er, Br, Tr, zr, Ir, Cr), Er = ar.mode.ccm.V(Er, Br.data, Tr, Ar, Ir, Cr), !Mr.equal(Br.tag, Er))
      throw new ar.exception.corrupt("ccm: tag doesn't match");
    return Br.data;
  }, na: function(Er, Cr, Tr, Ar, Ir, Mr) {
    var Hr = [], Br = ar.bitArray, zr = Br.i;
    if (Ar = [Br.partial(8, (Cr.length ? 64 : 0) | Ar - 2 << 2 | Mr - 1)], Ar = Br.concat(Ar, Tr), Ar[3] |= Ir, Ar = Er.encrypt(Ar), Cr.length)
      for (Tr = Br.bitLength(Cr) / 8, 65279 >= Tr ? Hr = [Br.partial(16, Tr)] : 4294967295 >= Tr && (Hr = Br.concat([Br.partial(16, 65534)], [Tr])), Hr = Br.concat(Hr, Cr), Cr = 0; Cr < Hr.length; Cr += 4)
        Ar = Er.encrypt(zr(Ar, Hr.slice(Cr, Cr + 4).concat([0, 0, 0])));
    return Ar;
  }, V: function(Er, Cr, Tr, Ar, Ir, Mr) {
    var Hr = ar.bitArray, Br = Hr.i;
    if (Ir /= 8, Ir % 2 || 4 > Ir || 16 < Ir)
      throw new ar.exception.invalid("ccm: invalid tag length");
    if (4294967295 < Ar.length || 4294967295 < Cr.length)
      throw new ar.exception.bug("ccm: can't deal with 4GiB or more data");
    for (Tr = ar.mode.ccm.na(Er, Ar, Tr, Ir, Hr.bitLength(Cr) / 8, Mr), Ar = 0; Ar < Cr.length; Ar += 4)
      Tr = Er.encrypt(Br(Tr, Cr.slice(Ar, Ar + 4).concat([0, 0, 0])));
    return Hr.clamp(Tr, 8 * Ir);
  }, C: function(Er, Cr, Tr, Ar, Ir, Mr) {
    var Hr, Br = ar.bitArray;
    Hr = Br.i;
    var zr = Cr.length, Gr = Br.bitLength(Cr), Xr = zr / 50, Jr = Xr;
    if (Tr = Br.concat([Br.partial(8, Mr - 1)], Tr).concat([0, 0, 0]).slice(0, 4), Ar = Br.bitSlice(Hr(Ar, Er.encrypt(Tr)), 0, Ir), !zr)
      return { tag: Ar, data: [] };
    for (Hr = 0; Hr < zr; Hr += 4)
      Hr > Xr && (ar.mode.ccm.fa(Hr / zr), Xr += Jr), Tr[3]++, Ir = Er.encrypt(Tr), Cr[Hr] ^= Ir[0], Cr[Hr + 1] ^= Ir[1], Cr[Hr + 2] ^= Ir[2], Cr[Hr + 3] ^= Ir[3];
    return { tag: Ar, data: Br.clamp(Cr, Gr) };
  } }, ar.mode.ocb2 = { name: "ocb2", encrypt: function(Er, Cr, Tr, Ar, Ir, Mr) {
    if (ar.bitArray.bitLength(Tr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    var Hr, Br = ar.mode.ocb2.S, zr = ar.bitArray, Gr = zr.i, Xr = [0, 0, 0, 0];
    Tr = Br(Er.encrypt(Tr));
    var Jr, li = [];
    for (Ar = Ar || [], Ir = Ir || 64, Hr = 0; Hr + 4 < Cr.length; Hr += 4)
      Jr = Cr.slice(Hr, Hr + 4), Xr = Gr(Xr, Jr), li = li.concat(Gr(Tr, Er.encrypt(Gr(Tr, Jr)))), Tr = Br(Tr);
    return Jr = Cr.slice(Hr), Cr = zr.bitLength(Jr), Hr = Er.encrypt(Gr(Tr, [0, 0, 0, Cr])), Jr = zr.clamp(Gr(Jr.concat([0, 0, 0]), Hr), Cr), Xr = Gr(Xr, Gr(Jr.concat([0, 0, 0]), Hr)), Xr = Er.encrypt(Gr(Xr, Gr(Tr, Br(Tr)))), Ar.length && (Xr = Gr(Xr, Mr ? Ar : ar.mode.ocb2.pmac(Er, Ar))), li.concat(zr.concat(Jr, zr.clamp(Xr, Ir)));
  }, decrypt: function(Er, Cr, Tr, Ar, Ir, Mr) {
    if (ar.bitArray.bitLength(Tr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    Ir = Ir || 64;
    var Hr = ar.mode.ocb2.S, Br = ar.bitArray, zr = Br.i, Gr = [0, 0, 0, 0], Xr = Hr(Er.encrypt(Tr)), Jr, li, Qr = ar.bitArray.bitLength(Cr) - Ir, ei = [];
    for (Ar = Ar || [], Tr = 0; Tr + 4 < Qr / 32; Tr += 4)
      Jr = zr(Xr, Er.decrypt(zr(Xr, Cr.slice(Tr, Tr + 4)))), Gr = zr(Gr, Jr), ei = ei.concat(Jr), Xr = Hr(Xr);
    if (li = Qr - 32 * Tr, Jr = Er.encrypt(zr(Xr, [0, 0, 0, li])), Jr = zr(Jr, Br.clamp(Cr.slice(Tr), li).concat([
      0,
      0,
      0
    ])), Gr = zr(Gr, Jr), Gr = Er.encrypt(zr(Gr, zr(Xr, Hr(Xr)))), Ar.length && (Gr = zr(Gr, Mr ? Ar : ar.mode.ocb2.pmac(Er, Ar))), !Br.equal(Br.clamp(Gr, Ir), Br.bitSlice(Cr, Qr)))
      throw new ar.exception.corrupt("ocb: tag doesn't match");
    return ei.concat(Br.clamp(Jr, li));
  }, pmac: function(Er, Cr) {
    var Tr, Ar = ar.mode.ocb2.S, Ir = ar.bitArray, Mr = Ir.i, Hr = [0, 0, 0, 0], Br = Er.encrypt([0, 0, 0, 0]), Br = Mr(Br, Ar(Ar(Br)));
    for (Tr = 0; Tr + 4 < Cr.length; Tr += 4)
      Br = Ar(Br), Hr = Mr(Hr, Er.encrypt(Mr(Br, Cr.slice(Tr, Tr + 4))));
    return Tr = Cr.slice(Tr), 128 > Ir.bitLength(Tr) && (Br = Mr(Br, Ar(Br)), Tr = Ir.concat(Tr, [-2147483648, 0, 0, 0])), Hr = Mr(Hr, Tr), Er.encrypt(Mr(Ar(Mr(Br, Ar(Br))), Hr));
  }, S: function(Er) {
    return [Er[0] << 1 ^ Er[1] >>> 31, Er[1] << 1 ^ Er[2] >>> 31, Er[2] << 1 ^ Er[3] >>> 31, Er[3] << 1 ^ 135 * (Er[0] >>> 31)];
  } }, ar.mode.gcm = { name: "gcm", encrypt: function(Er, Cr, Tr, Ar, Ir) {
    var Mr = Cr.slice(0);
    return Cr = ar.bitArray, Ar = Ar || [], Er = ar.mode.gcm.C(!0, Er, Mr, Ar, Tr, Ir || 128), Cr.concat(Er.data, Er.tag);
  }, decrypt: function(Er, Cr, Tr, Ar, Ir) {
    var Mr = Cr.slice(0), Hr = ar.bitArray, Br = Hr.bitLength(Mr);
    if (Ir = Ir || 128, Ar = Ar || [], Ir <= Br ? (Cr = Hr.bitSlice(Mr, Br - Ir), Mr = Hr.bitSlice(Mr, 0, Br - Ir)) : (Cr = Mr, Mr = []), Er = ar.mode.gcm.C(!1, Er, Mr, Ar, Tr, Ir), !Hr.equal(Er.tag, Cr))
      throw new ar.exception.corrupt("gcm: tag doesn't match");
    return Er.data;
  }, ka: function(Er, Cr) {
    var Tr, Ar, Ir, Mr, Hr, Br = ar.bitArray.i;
    for (Ir = [
      0,
      0,
      0,
      0
    ], Mr = Cr.slice(0), Tr = 0; 128 > Tr; Tr++) {
      for ((Ar = (Er[Math.floor(Tr / 32)] & 1 << 31 - Tr % 32) !== 0) && (Ir = Br(Ir, Mr)), Hr = (Mr[3] & 1) !== 0, Ar = 3; 0 < Ar; Ar--)
        Mr[Ar] = Mr[Ar] >>> 1 | (Mr[Ar - 1] & 1) << 31;
      Mr[0] >>>= 1, Hr && (Mr[0] ^= -520093696);
    }
    return Ir;
  }, j: function(Er, Cr, Tr) {
    var Ar, Ir = Tr.length;
    for (Cr = Cr.slice(0), Ar = 0; Ar < Ir; Ar += 4)
      Cr[0] ^= 4294967295 & Tr[Ar], Cr[1] ^= 4294967295 & Tr[Ar + 1], Cr[2] ^= 4294967295 & Tr[Ar + 2], Cr[3] ^= 4294967295 & Tr[Ar + 3], Cr = ar.mode.gcm.ka(Cr, Er);
    return Cr;
  }, C: function(Er, Cr, Tr, Ar, Ir, Mr) {
    var Hr, Br, zr, Gr, Xr, Jr, li, Qr, ei = ar.bitArray;
    for (Jr = Tr.length, li = ei.bitLength(Tr), Qr = ei.bitLength(Ar), Br = ei.bitLength(Ir), Hr = Cr.encrypt([0, 0, 0, 0]), Br === 96 ? (Ir = Ir.slice(0), Ir = ei.concat(Ir, [1])) : (Ir = ar.mode.gcm.j(Hr, [0, 0, 0, 0], Ir), Ir = ar.mode.gcm.j(Hr, Ir, [0, 0, Math.floor(Br / 4294967296), Br & 4294967295])), Br = ar.mode.gcm.j(Hr, [0, 0, 0, 0], Ar), Xr = Ir.slice(0), Ar = Br.slice(0), Er || (Ar = ar.mode.gcm.j(Hr, Br, Tr)), Gr = 0; Gr < Jr; Gr += 4)
      Xr[3]++, zr = Cr.encrypt(Xr), Tr[Gr] ^= zr[0], Tr[Gr + 1] ^= zr[1], Tr[Gr + 2] ^= zr[2], Tr[Gr + 3] ^= zr[3];
    return Tr = ei.clamp(Tr, li), Er && (Ar = ar.mode.gcm.j(Hr, Br, Tr)), Er = [Math.floor(Qr / 4294967296), Qr & 4294967295, Math.floor(li / 4294967296), li & 4294967295], Ar = ar.mode.gcm.j(Hr, Ar, Er), zr = Cr.encrypt(Ir), Ar[0] ^= zr[0], Ar[1] ^= zr[1], Ar[2] ^= zr[2], Ar[3] ^= zr[3], { tag: ei.bitSlice(Ar, 0, Mr), data: Tr };
  } }, ar.misc.hmac = function(Er, Cr) {
    this.W = Cr = Cr || ar.hash.sha256;
    var Tr = [[], []], Ar, Ir = Cr.prototype.blockSize / 32;
    for (this.w = [new Cr(), new Cr()], Er.length > Ir && (Er = Cr.hash(Er)), Ar = 0; Ar < Ir; Ar++)
      Tr[0][Ar] = Er[Ar] ^ 909522486, Tr[1][Ar] = Er[Ar] ^ 1549556828;
    this.w[0].update(Tr[0]), this.w[1].update(Tr[1]), this.R = new Cr(this.w[0]);
  }, ar.misc.hmac.prototype.encrypt = ar.misc.hmac.prototype.mac = function(Er) {
    if (this.aa)
      throw new ar.exception.invalid("encrypt on already updated hmac called!");
    return this.update(Er), this.digest(Er);
  }, ar.misc.hmac.prototype.reset = function() {
    this.R = new this.W(this.w[0]), this.aa = !1;
  }, ar.misc.hmac.prototype.update = function(Er) {
    this.aa = !0, this.R.update(Er);
  }, ar.misc.hmac.prototype.digest = function() {
    var Er = this.R.finalize(), Er = new this.W(this.w[1]).update(Er).finalize();
    return this.reset(), Er;
  }, ar.misc.pbkdf2 = function(Er, Cr, Tr, Ar, Ir) {
    if (Tr = Tr || 1e4, 0 > Ar || 0 > Tr)
      throw new ar.exception.invalid("invalid params to pbkdf2");
    typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er)), typeof Cr == "string" && (Cr = ar.codec.utf8String.toBits(Cr)), Ir = Ir || ar.misc.hmac, Er = new Ir(Er);
    var Mr, Hr, Br, zr, Gr = [], Xr = ar.bitArray;
    for (zr = 1; 32 * Gr.length < (Ar || 1); zr++) {
      for (Ir = Mr = Er.encrypt(Xr.concat(Cr, [zr])), Hr = 1; Hr < Tr; Hr++)
        for (Mr = Er.encrypt(Mr), Br = 0; Br < Mr.length; Br++)
          Ir[Br] ^= Mr[Br];
      Gr = Gr.concat(Ir);
    }
    return Ar && (Gr = Xr.clamp(Gr, Ar)), Gr;
  }, ar.prng = function(Er) {
    this.c = [new ar.hash.sha256()], this.m = [0], this.P = 0, this.H = {}, this.N = 0, this.U = {}, this.Z = this.f = this.o = this.ha = 0, this.b = [0, 0, 0, 0, 0, 0, 0, 0], this.h = [0, 0, 0, 0], this.L = void 0, this.M = Er, this.D = !1, this.K = { progress: {}, seeded: {} }, this.u = this.ga = 0, this.I = 1, this.J = 2, this.ca = 65536, this.T = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024], this.da = 3e4, this.ba = 80;
  }, ar.prng.prototype = {
    randomWords: function(Er, Cr) {
      var Tr = [], Ar;
      Ar = this.isReady(Cr);
      var Ir;
      if (Ar === this.u)
        throw new ar.exception.notReady("generator isn't seeded");
      if (Ar & this.J) {
        Ar = !(Ar & this.I), Ir = [];
        var Mr = 0, Hr;
        for (this.Z = Ir[0] = (/* @__PURE__ */ new Date()).valueOf() + this.da, Hr = 0; 16 > Hr; Hr++)
          Ir.push(4294967296 * Math.random() | 0);
        for (Hr = 0; Hr < this.c.length && (Ir = Ir.concat(this.c[Hr].finalize()), Mr += this.m[Hr], this.m[Hr] = 0, Ar || !(this.P & 1 << Hr)); Hr++)
          ;
        for (this.P >= 1 << this.c.length && (this.c.push(new ar.hash.sha256()), this.m.push(0)), this.f -= Mr, Mr > this.o && (this.o = Mr), this.P++, this.b = ar.hash.sha256.hash(this.b.concat(Ir)), this.L = new ar.cipher.aes(this.b), Ar = 0; 4 > Ar && (this.h[Ar] = this.h[Ar] + 1 | 0, !this.h[Ar]); Ar++)
          ;
      }
      for (Ar = 0; Ar < Er; Ar += 4)
        (Ar + 1) % this.ca === 0 && gr(this), Ir = mr(this), Tr.push(Ir[0], Ir[1], Ir[2], Ir[3]);
      return gr(this), Tr.slice(0, Er);
    },
    setDefaultParanoia: function(Er, Cr) {
      if (Er === 0 && Cr !== "Setting paranoia=0 will ruin your security; use it only for testing")
        throw new ar.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
      this.M = Er;
    },
    addEntropy: function(Er, Cr, Tr) {
      Tr = Tr || "user";
      var Ar, Ir, Mr = (/* @__PURE__ */ new Date()).valueOf(), Hr = this.H[Tr], Br = this.isReady(), zr = 0;
      switch (Ar = this.U[Tr], Ar === void 0 && (Ar = this.U[Tr] = this.ha++), Hr === void 0 && (Hr = this.H[Tr] = 0), this.H[Tr] = (this.H[Tr] + 1) % this.c.length, typeof Er) {
        case "number":
          Cr === void 0 && (Cr = 1), this.c[Hr].update([Ar, this.N++, 1, Cr, Mr, 1, Er | 0]);
          break;
        case "object":
          if (Tr = Object.prototype.toString.call(Er), Tr === "[object Uint32Array]") {
            for (Ir = [], Tr = 0; Tr < Er.length; Tr++)
              Ir.push(Er[Tr]);
            Er = Ir;
          } else
            for (Tr !== "[object Array]" && (zr = 1), Tr = 0; Tr < Er.length && !zr; Tr++)
              typeof Er[Tr] != "number" && (zr = 1);
          if (!zr) {
            if (Cr === void 0)
              for (Tr = Cr = 0; Tr < Er.length; Tr++)
                for (Ir = Er[Tr]; 0 < Ir; )
                  Cr++, Ir = Ir >>> 1;
            this.c[Hr].update([Ar, this.N++, 2, Cr, Mr, Er.length].concat(Er));
          }
          break;
        case "string":
          Cr === void 0 && (Cr = Er.length), this.c[Hr].update([Ar, this.N++, 3, Cr, Mr, Er.length]), this.c[Hr].update(Er);
          break;
        default:
          zr = 1;
      }
      if (zr)
        throw new ar.exception.bug("random: addEntropy only supports number, array of numbers or string");
      this.m[Hr] += Cr, this.f += Cr, Br === this.u && (this.isReady() !== this.u && fr("seeded", Math.max(this.o, this.f)), fr("progress", this.getProgress()));
    },
    isReady: function(Er) {
      return Er = this.T[Er !== void 0 ? Er : this.M], this.o && this.o >= Er ? this.m[0] > this.ba && (/* @__PURE__ */ new Date()).valueOf() > this.Z ? this.J | this.I : this.I : this.f >= Er ? this.J | this.u : this.u;
    },
    getProgress: function(Er) {
      return Er = this.T[Er || this.M], this.o >= Er || this.f > Er ? 1 : this.f / Er;
    },
    startCollectors: function() {
      if (!this.D) {
        if (this.a = { loadTimeCollector: vr(this, this.ma), mouseCollector: vr(this, this.oa), keyboardCollector: vr(this, this.la), accelerometerCollector: vr(this, this.ea), touchCollector: vr(this, this.qa) }, window.addEventListener)
          window.addEventListener(
            "load",
            this.a.loadTimeCollector,
            !1
          ), window.addEventListener("mousemove", this.a.mouseCollector, !1), window.addEventListener("keypress", this.a.keyboardCollector, !1), window.addEventListener("devicemotion", this.a.accelerometerCollector, !1), window.addEventListener("touchmove", this.a.touchCollector, !1);
        else if (document.attachEvent)
          document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector);
        else
          throw new ar.exception.bug("can't attach event");
        this.D = !0;
      }
    },
    stopCollectors: function() {
      this.D && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, !1), window.removeEventListener("mousemove", this.a.mouseCollector, !1), window.removeEventListener("keypress", this.a.keyboardCollector, !1), window.removeEventListener("devicemotion", this.a.accelerometerCollector, !1), window.removeEventListener("touchmove", this.a.touchCollector, !1)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent(
        "onmousemove",
        this.a.mouseCollector
      ), document.detachEvent("keypress", this.a.keyboardCollector)), this.D = !1);
    },
    addEventListener: function(Er, Cr) {
      this.K[Er][this.ga++] = Cr;
    },
    removeEventListener: function(Er, Cr) {
      var Tr, Ar, Ir = this.K[Er], Mr = [];
      for (Ar in Ir)
        Ir.hasOwnProperty(Ar) && Ir[Ar] === Cr && Mr.push(Ar);
      for (Tr = 0; Tr < Mr.length; Tr++)
        Ar = Mr[Tr], delete Ir[Ar];
    },
    la: function() {
      dr(this, 1);
    },
    oa: function(Er) {
      var Cr, Tr;
      try {
        Cr = Er.x || Er.clientX || Er.offsetX || 0, Tr = Er.y || Er.clientY || Er.offsetY || 0;
      } catch (Ar) {
        Tr = Cr = 0;
      }
      Cr != 0 && Tr != 0 && this.addEntropy([Cr, Tr], 2, "mouse"), dr(this, 0);
    },
    qa: function(Er) {
      Er = Er.touches[0] || Er.changedTouches[0], this.addEntropy([Er.pageX || Er.clientX, Er.pageY || Er.clientY], 1, "touch"), dr(this, 0);
    },
    ma: function() {
      dr(this, 2);
    },
    ea: function(Er) {
      if (Er = Er.accelerationIncludingGravity.x || Er.accelerationIncludingGravity.y || Er.accelerationIncludingGravity.z, window.orientation) {
        var Cr = window.orientation;
        typeof Cr == "number" && this.addEntropy(Cr, 1, "accelerometer");
      }
      Er && this.addEntropy(Er, 2, "accelerometer"), dr(this, 0);
    }
  };
  function fr(Er, Cr) {
    var Tr, Ar = ar.random.K[Er], Ir = [];
    for (Tr in Ar)
      Ar.hasOwnProperty(Tr) && Ir.push(Ar[Tr]);
    for (Tr = 0; Tr < Ir.length; Tr++)
      Ir[Tr](Cr);
  }
  function dr(Er, Cr) {
    typeof window != "undefined" && window.performance && typeof window.performance.now == "function" ? Er.addEntropy(window.performance.now(), Cr, "loadtime") : Er.addEntropy((/* @__PURE__ */ new Date()).valueOf(), Cr, "loadtime");
  }
  function gr(Er) {
    Er.b = mr(Er).concat(mr(Er)), Er.L = new ar.cipher.aes(Er.b);
  }
  function mr(Er) {
    for (var Cr = 0; 4 > Cr && (Er.h[Cr] = Er.h[Cr] + 1 | 0, !Er.h[Cr]); Cr++)
      ;
    return Er.L.encrypt(Er.h);
  }
  function vr(Er, Cr) {
    return function() {
      Cr.apply(Er, arguments);
    };
  }
  ar.random = new ar.prng(6);
  e:
    try {
      var yr, kr, _r, xr;
      if (xr = lr.exports) {
        var Sr;
        try {
          Sr = require$$0;
        } catch (Er) {
          Sr = null;
        }
        xr = kr = Sr;
      }
      if (xr && kr.randomBytes)
        yr = kr.randomBytes(128), yr = new Uint32Array(new Uint8Array(yr).buffer), ar.random.addEntropy(yr, 1024, "crypto['randomBytes']");
      else if (typeof window != "undefined" && typeof Uint32Array != "undefined") {
        if (_r = new Uint32Array(32), window.crypto && window.crypto.getRandomValues)
          window.crypto.getRandomValues(_r);
        else if (window.msCrypto && window.msCrypto.getRandomValues)
          window.msCrypto.getRandomValues(_r);
        else
          break e;
        ar.random.addEntropy(_r, 1024, "crypto['getRandomValues']");
      }
    } catch (Er) {
      typeof window != "undefined" && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(Er));
    }
  ar.json = { defaults: { v: 1, iter: 1e4, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes" }, ja: function(Er, Cr, Tr, Ar) {
    Tr = Tr || {}, Ar = Ar || {};
    var Ir = ar.json, Mr = Ir.g({ iv: ar.random.randomWords(4, 0) }, Ir.defaults), Hr;
    if (Ir.g(Mr, Tr), Tr = Mr.adata, typeof Mr.salt == "string" && (Mr.salt = ar.codec.base64.toBits(Mr.salt)), typeof Mr.iv == "string" && (Mr.iv = ar.codec.base64.toBits(Mr.iv)), !ar.mode[Mr.mode] || !ar.cipher[Mr.cipher] || typeof Er == "string" && 100 >= Mr.iter || Mr.ts !== 64 && Mr.ts !== 96 && Mr.ts !== 128 || Mr.ks !== 128 && Mr.ks !== 192 && Mr.ks !== 256 || 2 > Mr.iv.length || 4 < Mr.iv.length)
      throw new ar.exception.invalid("json encrypt: invalid parameters");
    return typeof Er == "string" ? (Hr = ar.misc.cachedPbkdf2(Er, Mr), Er = Hr.key.slice(0, Mr.ks / 32), Mr.salt = Hr.salt) : ar.ecc && Er instanceof ar.ecc.elGamal.publicKey && (Hr = Er.kem(), Mr.kemtag = Hr.tag, Er = Hr.key.slice(0, Mr.ks / 32)), typeof Cr == "string" && (Cr = ar.codec.utf8String.toBits(Cr)), typeof Tr == "string" && (Mr.adata = Tr = ar.codec.utf8String.toBits(Tr)), Hr = new ar.cipher[Mr.cipher](Er), Ir.g(Ar, Mr), Ar.key = Er, Mr.ct = Mr.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Cr instanceof ArrayBuffer ? ar.arrayBuffer.ccm.encrypt(Hr, Cr, Mr.iv, Tr, Mr.ts) : ar.mode[Mr.mode].encrypt(Hr, Cr, Mr.iv, Tr, Mr.ts), Mr;
  }, encrypt: function(Er, Cr, Tr, Ar) {
    var Ir = ar.json, Mr = Ir.ja.apply(Ir, arguments);
    return Ir.encode(Mr);
  }, ia: function(Er, Cr, Tr, Ar) {
    Tr = Tr || {}, Ar = Ar || {};
    var Ir = ar.json;
    Cr = Ir.g(Ir.g(Ir.g({}, Ir.defaults), Cr), Tr, !0);
    var Mr, Hr;
    if (Mr = Cr.adata, typeof Cr.salt == "string" && (Cr.salt = ar.codec.base64.toBits(Cr.salt)), typeof Cr.iv == "string" && (Cr.iv = ar.codec.base64.toBits(Cr.iv)), !ar.mode[Cr.mode] || !ar.cipher[Cr.cipher] || typeof Er == "string" && 100 >= Cr.iter || Cr.ts !== 64 && Cr.ts !== 96 && Cr.ts !== 128 || Cr.ks !== 128 && Cr.ks !== 192 && Cr.ks !== 256 || !Cr.iv || 2 > Cr.iv.length || 4 < Cr.iv.length)
      throw new ar.exception.invalid("json decrypt: invalid parameters");
    return typeof Er == "string" ? (Hr = ar.misc.cachedPbkdf2(Er, Cr), Er = Hr.key.slice(0, Cr.ks / 32), Cr.salt = Hr.salt) : ar.ecc && Er instanceof ar.ecc.elGamal.secretKey && (Er = Er.unkem(ar.codec.base64.toBits(Cr.kemtag)).slice(0, Cr.ks / 32)), typeof Mr == "string" && (Mr = ar.codec.utf8String.toBits(Mr)), Hr = new ar.cipher[Cr.cipher](Er), Mr = Cr.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Cr.ct instanceof ArrayBuffer ? ar.arrayBuffer.ccm.decrypt(Hr, Cr.ct, Cr.iv, Cr.tag, Mr, Cr.ts) : ar.mode[Cr.mode].decrypt(Hr, Cr.ct, Cr.iv, Mr, Cr.ts), Ir.g(Ar, Cr), Ar.key = Er, Tr.raw === 1 ? Mr : ar.codec.utf8String.fromBits(Mr);
  }, decrypt: function(Er, Cr, Tr, Ar) {
    var Ir = ar.json;
    return Ir.ia(Er, Ir.decode(Cr), Tr, Ar);
  }, encode: function(Er) {
    var Cr, Tr = "{", Ar = "";
    for (Cr in Er)
      if (Er.hasOwnProperty(Cr)) {
        if (!Cr.match(/^[a-z0-9]+$/i))
          throw new ar.exception.invalid("json encode: invalid property name");
        switch (Tr += Ar + '"' + Cr + '":', Ar = ",", typeof Er[Cr]) {
          case "number":
          case "boolean":
            Tr += Er[Cr];
            break;
          case "string":
            Tr += '"' + escape(Er[Cr]) + '"';
            break;
          case "object":
            Tr += '"' + ar.codec.base64.fromBits(Er[Cr], 0) + '"';
            break;
          default:
            throw new ar.exception.bug("json encode: unsupported type");
        }
      }
    return Tr + "}";
  }, decode: function(Er) {
    if (Er = Er.replace(/\s/g, ""), !Er.match(/^\{.*\}$/))
      throw new ar.exception.invalid("json decode: this isn't json!");
    Er = Er.replace(/^\{|\}$/g, "").split(/,/);
    var Cr = {}, Tr, Ar;
    for (Tr = 0; Tr < Er.length; Tr++) {
      if (!(Ar = Er[Tr].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))
        throw new ar.exception.invalid("json decode: this isn't json!");
      Ar[3] != null ? Cr[Ar[2]] = parseInt(Ar[3], 10) : Ar[4] != null ? Cr[Ar[2]] = Ar[2].match(/^(ct|adata|salt|iv)$/) ? ar.codec.base64.toBits(Ar[4]) : unescape(Ar[4]) : Ar[5] != null && (Cr[Ar[2]] = Ar[5] === "true");
    }
    return Cr;
  }, g: function(Er, Cr, Tr) {
    if (Er === void 0 && (Er = {}), Cr === void 0)
      return Er;
    for (var Ar in Cr)
      if (Cr.hasOwnProperty(Ar)) {
        if (Tr && Er[Ar] !== void 0 && Er[Ar] !== Cr[Ar])
          throw new ar.exception.invalid("required parameter overridden");
        Er[Ar] = Cr[Ar];
      }
    return Er;
  }, sa: function(Er, Cr) {
    var Tr = {}, Ar;
    for (Ar in Er)
      Er.hasOwnProperty(Ar) && Er[Ar] !== Cr[Ar] && (Tr[Ar] = Er[Ar]);
    return Tr;
  }, ra: function(Er, Cr) {
    var Tr = {}, Ar;
    for (Ar = 0; Ar < Cr.length; Ar++)
      Er[Cr[Ar]] !== void 0 && (Tr[Cr[Ar]] = Er[Cr[Ar]]);
    return Tr;
  } }, ar.encrypt = ar.json.encrypt, ar.decrypt = ar.json.decrypt, ar.misc.pa = {}, ar.misc.cachedPbkdf2 = function(Er, Cr) {
    var Tr = ar.misc.pa, Ar;
    return Cr = Cr || {}, Ar = Cr.iter || 1e3, Tr = Tr[Er] = Tr[Er] || {}, Ar = Tr[Ar] = Tr[Ar] || { firstSalt: Cr.salt && Cr.salt.length ? Cr.salt.slice(0) : ar.random.randomWords(2, 0) }, Tr = Cr.salt === void 0 ? Ar.firstSalt : Cr.salt, Ar[Tr] = Ar[Tr] || ar.misc.pbkdf2(Er, Tr, Cr.iter), { key: Ar[Tr].slice(0), salt: Tr.slice(0) };
  }, lr.exports && (lr.exports = ar);
})(sjcl);
var sjclExports = sjcl.exports, codecBytes = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(codecBytes, "__esModule", { value: !0 });
codecBytes.sjclcodec = void 0;
const sjcl_1$1 = __importDefault$1(sjclExports);
codecBytes.sjclcodec = {
  /** Convert from a bitArray to an array of bytes. */
  fromBits: function(lr) {
    var ar = [], cr = sjcl_1$1.default.bitArray.bitLength(lr), ur, fr;
    for (ur = 0; ur < cr / 8; ur++)
      ur & 3 || (fr = lr[ur / 4]), ar.push(fr >>> 24), fr <<= 8;
    return ar;
  },
  /** Convert from an array of bytes to a bitArray. */
  /** @return {bitArray} */
  toBits: function(lr) {
    var ar = [], cr, ur = 0;
    for (cr = 0; cr < lr.length; cr++)
      ur = ur << 8 | lr[cr], (cr & 3) === 3 && (ar.push(ur), ur = 0);
    return cr & 3 && ar.push(sjcl_1$1.default.bitArray.partial(8 * (cr & 3), ur)), ar;
  }
};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: !0 });
utils.buf2hex = void 0;
function buf2hex(lr) {
  return [...new Uint8Array(lr)].map((ar) => ar.toString(16).padStart(2, "0")).join("");
}
utils.buf2hex = buf2hex;
(function(lr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(gr) {
    return gr && gr.__esModule ? gr : { default: gr };
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.VoidUploader = lr.UploadState = void 0;
  const cr = ar(sjclExports), ur = codecBytes, fr = utils;
  (function(gr) {
    gr[gr.NotStarted = 0] = "NotStarted", gr[gr.Starting = 1] = "Starting", gr[gr.Hashing = 2] = "Hashing", gr[gr.Uploading = 3] = "Uploading", gr[gr.Done = 4] = "Done", gr[gr.Failed = 5] = "Failed", gr[gr.Challenge = 6] = "Challenge";
  })(lr.UploadState || (lr.UploadState = {}));
  class dr {
    constructor(mr, vr, yr, kr, _r, xr, Sr) {
      ji(this, "uri");
      ji(this, "file");
      ji(this, "auth");
      ji(this, "maxChunkSize");
      ji(this, "onStateChange");
      ji(this, "onProgress");
      ji(this, "onProxyChallenge");
      this.uri = mr, this.file = vr, this.onStateChange = yr, this.onProgress = kr, this.onProxyChallenge = _r, this.auth = xr, this.maxChunkSize = Sr != null ? Sr : Number.MAX_VALUE;
    }
    /**
     * SHA-256 hash the entire blob
     * @param file
     * @protected
     */
    async digest(mr) {
      var _r;
      const yr = new cr.default.hash.sha256();
      let kr = 0;
      for (let xr = 0; xr < Math.ceil(mr.size / 1048576); xr++) {
        const Sr = xr * 1048576, Cr = await mr.slice(Sr, Sr + 1048576).arrayBuffer();
        yr.update(ur.sjclcodec.toBits(new Uint8Array(Cr))), (_r = this.onProgress) == null || _r.call(this, kr += Cr.byteLength);
      }
      return (0, fr.buf2hex)(ur.sjclcodec.fromBits(yr.finalize()));
    }
  }
  lr.VoidUploader = dr;
})(upload);
var streamEncryption = {}, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(lr) {
  return lr && lr.__esModule ? lr : { default: lr };
};
Object.defineProperty(streamEncryption, "__esModule", { value: !0 });
streamEncryption.StreamEncryption = void 0;
const codecBytes_1 = codecBytes, sjcl_1 = __importDefault(sjclExports), utils_1 = utils;
var ts, Us, zs, Dl, us;
class StreamEncryption {
  constructor(ar, cr, ur) {
    zo(this, ts, void 0);
    zo(this, Us, void 0);
    zo(this, zs, void 0);
    zo(this, Dl, void 0);
    zo(this, us, void 0);
    var fr, dr;
    if (!ar && !cr && (ar = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(16))), cr = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(12)))), typeof ar == "string" && typeof cr == "string")
      ar = sjcl_1.default.codec.hex.toBits(ar), cr = sjcl_1.default.codec.hex.toBits(cr);
    else if (!Array.isArray(ar) || !Array.isArray(cr))
      throw "Key and IV must be hex string or bitArray";
    typeof ur == "string" && (ur = JSON.parse(ur)), cs(this, ts, (fr = ur == null ? void 0 : ur.ts) != null ? fr : 128), cs(this, Us, (dr = ur == null ? void 0 : ur.cs) != null ? dr : 1024 * 1024 * 10), cs(this, zs, new sjcl_1.default.cipher.aes(ar)), cs(this, Dl, ar), cs(this, us, cr), console.log(`ts=${to(this, ts)}, cs=${to(this, Us)}, key=${ar}, iv=${to(this, us)}`);
  }
  /**
   * Return formatted encryption key
   */
  getKey() {
    return `${sjcl_1.default.codec.hex.fromBits(to(this, Dl))}:${sjcl_1.default.codec.hex.fromBits(to(this, us))}`;
  }
  /**
   * Get encryption params
   */
  getParams() {
    return {
      ts: to(this, ts),
      cs: to(this, Us)
    };
  }
  /**
   * Get encryption TransformStream
   */
  getEncryptionTransform() {
    return this._getCryptoStream(0);
  }
  /**
   * Get decryption TransformStream
   */
  getDecryptionTransform() {
    return this._getCryptoStream(1);
  }
  _getCryptoStream(ar) {
    let cr = 0, ur = new Uint8Array(to(this, Us) + (ar === 1 ? to(this, ts) / 8 : 0));
    return new TransformStream({
      transform: async (fr, dr) => {
        fr = await fr;
        try {
          let gr = Math.min(fr.byteLength, ur.byteLength - cr);
          if (ur.set(fr.slice(0, gr), cr), cr += gr, cr === ur.byteLength) {
            let mr = codecBytes_1.sjclcodec.toBits(ur), vr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(to(this, zs), mr, to(this, us), [], to(this, ts)) : sjcl_1.default.mode.gcm.decrypt(to(this, zs), mr, to(this, us), [], to(this, ts)));
            dr.enqueue(new Uint8Array(vr)), cr = fr.byteLength - gr, ur.set(fr.slice(gr));
          }
        } catch (gr) {
          throw console.error(gr), gr;
        }
      },
      flush: (fr) => {
        let dr = ur.slice(0, cr), gr = codecBytes_1.sjclcodec.toBits(dr), mr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(to(this, zs), gr, to(this, us), [], to(this, ts)) : sjcl_1.default.mode.gcm.decrypt(to(this, zs), gr, to(this, us), [], to(this, ts)));
        fr.enqueue(new Uint8Array(mr));
      }
    }, {
      highWaterMark: to(this, Us)
    });
  }
}
ts = new WeakMap(), Us = new WeakMap(), zs = new WeakMap(), Dl = new WeakMap(), us = new WeakMap();
streamEncryption.StreamEncryption = StreamEncryption;
Object.defineProperty(streamUploader, "__esModule", { value: !0 });
streamUploader.StreamUploader = void 0;
const upload_1$1 = upload, stream_encryption_1 = streamEncryption;
var fs;
class StreamUploader extends upload_1$1.VoidUploader {
  constructor() {
    super(...arguments);
    zo(this, fs, void 0);
  }
  static canUse() {
    const cr = globalThis.navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    return (cr ? parseInt(cr[2], 10) : 0) >= 105 && "getRandomValues" in globalThis.crypto && globalThis.location.protocol === "https:";
  }
  canEncrypt() {
    return !0;
  }
  setEncryption(cr) {
    cr ? cs(this, fs, new stream_encryption_1.StreamEncryption(void 0, void 0, void 0)) : cs(this, fs, void 0);
  }
  getEncryptionKey() {
    var cr;
    return (cr = to(this, fs)) == null ? void 0 : cr.getKey();
  }
  async upload(cr) {
    var kr;
    (kr = this.onStateChange) == null || kr.call(this, upload_1$1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    let fr = 0;
    const dr = 1024 * 1024, gr = new ReadableStream({
      start: async () => {
        var _r;
        (_r = this.onStateChange) == null || _r.call(this, upload_1$1.UploadState.Uploading);
      },
      pull: async (_r) => {
        var Sr, Er;
        const xr = await this.readChunk(fr, (Sr = _r.desiredSize) != null ? Sr : dr);
        if (xr.byteLength === 0) {
          _r.close();
          return;
        }
        (Er = this.onProgress) == null || Er.call(this, fr + xr.byteLength), fr += xr.byteLength, _r.enqueue(xr);
      },
      cancel: (_r) => {
        console.log(_r);
      },
      type: "bytes"
    }, {
      highWaterMark: dr
    }), mr = `${this.uri}/upload`, vr = {
      "Content-Type": "application/octet-stream",
      "V-Content-Type": this.file.type ? this.file.type : "application/octet-stream",
      "V-Filename": "name" in this.file ? this.file.name : "",
      "V-Full-Digest": ur
    };
    to(this, fs) && (vr["V-EncryptionParams"] = JSON.stringify(to(this, fs).getParams())), this.auth && (vr.Authorization = await this.auth(mr, "POST"));
    const yr = await fetch(mr, {
      method: "POST",
      mode: "cors",
      body: to(this, fs) ? gr.pipeThrough(to(this, fs).getEncryptionTransform()) : gr,
      headers: {
        ...vr,
        ...cr
      },
      // @ts-ignore New stream spec
      duplex: "half"
    });
    if (yr.ok)
      return await yr.json();
    throw new Error("Unknown error");
  }
  async readChunk(cr, ur) {
    if (cr > this.file.size)
      return new Uint8Array(0);
    const fr = Math.min(cr + ur, this.file.size), gr = await this.file.slice(cr, fr, this.file.type).arrayBuffer();
    return new Uint8Array(gr);
  }
}
fs = new WeakMap();
streamUploader.StreamUploader = StreamUploader;
var xhrUploader = {};
Object.defineProperty(xhrUploader, "__esModule", { value: !0 });
xhrUploader.XHRUploader = void 0;
const upload_1 = upload;
var Ac, Ed, Bl, Ju;
class XHRUploader extends upload_1.VoidUploader {
  constructor() {
    super(...arguments);
    zo(this, Ac);
    /**
     * Upload a segment of the file
     * @param segment
     * @param fullDigest Full file hash
     * @param id
     * @param editSecret
     * @param part Segment number
     * @param partOf Total number of segments
     * @param headers
     */
    zo(this, Bl);
  }
  canEncrypt() {
    return !1;
  }
  setEncryption() {
  }
  getEncryptionKey() {
  }
  async upload(cr) {
    var fr;
    (fr = this.onStateChange) == null || fr.call(this, upload_1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    return this.file.size > this.maxChunkSize ? await go(this, Ac, Ed).call(this, ur, this.maxChunkSize, cr) : await go(this, Bl, Ju).call(this, this.file, ur, void 0, void 0, 1, 1, cr);
  }
}
Ac = new WeakSet(), Ed = async function(cr, ur, fr) {
  var mr, vr, yr;
  let dr = null;
  const gr = Math.ceil(this.file.size / ur);
  for (let kr = 0; kr < gr; kr++) {
    const _r = kr * ur, xr = this.file.slice(_r, _r + ur, this.file.type);
    if (dr = await go(this, Bl, Ju).call(this, xr, cr, (mr = dr == null ? void 0 : dr.file) == null ? void 0 : mr.id, (yr = (vr = dr == null ? void 0 : dr.file) == null ? void 0 : vr.metadata) == null ? void 0 : yr.editSecret, kr + 1, gr, fr), !dr.ok)
      break;
  }
  return dr;
}, Bl = new WeakSet(), Ju = async function(cr, ur, fr, dr, gr, mr, vr) {
  var _r;
  (_r = this.onStateChange) == null || _r.call(this, upload_1.UploadState.Uploading);
  const yr = fr ? `${this.uri}/upload/${fr}` : `${this.uri}/upload`, kr = this.auth ? await this.auth(yr, "POST") : void 0;
  return await new Promise((xr, Sr) => {
    try {
      const Er = new XMLHttpRequest();
      if (Er.onreadystatechange = () => {
        var Cr, Tr;
        if (Er.readyState === XMLHttpRequest.DONE && Er.status === 200) {
          const Ar = JSON.parse(Er.responseText);
          xr(Ar);
        } else if (Er.readyState === XMLHttpRequest.DONE && Er.status === 403) {
          const Ar = Er.getResponseHeader("content-type");
          (Ar == null ? void 0 : Ar.toLowerCase().trim().indexOf("text/html")) === 0 && ((Cr = this.onProxyChallenge) == null || Cr.call(this, Er.response), (Tr = this.onStateChange) == null || Tr.call(this, upload_1.UploadState.Challenge), Sr(new Error("CF Challenge")));
        }
      }, Er.upload.onprogress = (Cr) => {
        var Tr;
        Cr instanceof ProgressEvent && ((Tr = this.onProgress) == null || Tr.call(this, Cr.loaded));
      }, Er.open("POST", yr), Er.setRequestHeader("Content-Type", "application/octet-stream"), Er.setRequestHeader("V-Content-Type", this.file.type ? this.file.type : "application/octet-stream"), Er.setRequestHeader("V-Filename", "name" in this.file ? this.file.name : ""), Er.setRequestHeader("V-Full-Digest", ur), Er.setRequestHeader("V-Segment", `${gr}/${mr}`), kr && (Er.withCredentials = !0, Er.setRequestHeader("Authorization", kr)), dr && Er.setRequestHeader("V-EditSecret", dr), vr)
        for (const [Cr, Tr] of Object.entries(vr))
          Er.setRequestHeader(Cr, Tr);
      Er.send(cr);
    } catch (Er) {
      Sr(Er);
    }
  });
};
xhrUploader.XHRUploader = XHRUploader;
var hasRequiredApi;
function requireApi() {
  var fr, dr, gr, Eo;
  if (hasRequiredApi)
    return api;
  hasRequiredApi = 1, Object.defineProperty(api, "__esModule", { value: !0 }), api.VoidApi = void 0;
  const lr = requireDist(), ar = streamUploader, cr = xhrUploader;
  class ur {
    constructor(yr, kr) {
      zo(this, gr);
      zo(this, fr, void 0);
      zo(this, dr, void 0);
      cs(this, fr, yr), cs(this, dr, kr);
    }
    /**
     * Get uploader for uploading files
     */
    getUploader(yr, kr, _r, xr, Sr) {
      return ar.StreamUploader.canUse() ? new ar.StreamUploader(to(this, fr), yr, kr, _r, xr, to(this, dr), Sr) : new cr.XHRUploader(to(this, fr), yr, kr, _r, xr, to(this, dr), Sr);
    }
    /**
     * General site information
     */
    info() {
      return go(this, gr, Eo).call(this, "GET", "/info");
    }
    fileInfo(yr) {
      return go(this, gr, Eo).call(this, "GET", `/upload/${yr}`);
    }
    setPaymentConfig(yr, kr) {
      return go(this, gr, Eo).call(this, "POST", `/upload/${yr}/payment`, kr);
    }
    createOrder(yr) {
      return go(this, gr, Eo).call(this, "GET", `/upload/${yr}/payment`);
    }
    getOrder(yr, kr) {
      return go(this, gr, Eo).call(this, "GET", `/upload/${yr}/payment/${kr}`);
    }
    login(yr, kr, _r) {
      return go(this, gr, Eo).call(this, "POST", "/auth/login", {
        username: yr,
        password: kr,
        captcha: _r
      });
    }
    register(yr, kr, _r) {
      return go(this, gr, Eo).call(this, "POST", "/auth/register", {
        username: yr,
        password: kr,
        captcha: _r
      });
    }
    getUser(yr) {
      return go(this, gr, Eo).call(this, "GET", `/user/${yr}`);
    }
    updateUser(yr) {
      return go(this, gr, Eo).call(this, "POST", `/user/${yr.id}`, yr);
    }
    listUserFiles(yr, kr) {
      return go(this, gr, Eo).call(this, "POST", `/user/${yr}/files`, kr);
    }
    submitVerifyCode(yr, kr) {
      return go(this, gr, Eo).call(this, "POST", `/user/${yr}/verify`, { code: kr });
    }
    sendNewCode(yr) {
      return go(this, gr, Eo).call(this, "GET", `/user/${yr}/verify`);
    }
    updateFileMetadata(yr, kr) {
      return go(this, gr, Eo).call(this, "POST", `/upload/${yr}/meta`, kr);
    }
    listApiKeys() {
      return go(this, gr, Eo).call(this, "GET", "/auth/api-key");
    }
    createApiKey(yr) {
      return go(this, gr, Eo).call(this, "POST", "/auth/api-key", yr);
    }
    adminListFiles(yr) {
      return go(this, gr, Eo).call(this, "POST", "/admin/file", yr);
    }
    adminDeleteFile(yr) {
      return go(this, gr, Eo).call(this, "DELETE", `/admin/file/${yr}`);
    }
    adminUserList(yr) {
      return go(this, gr, Eo).call(this, "POST", "/admin/users", yr);
    }
    adminUpdateUser(yr) {
      return go(this, gr, Eo).call(this, "POST", "/admin/update-user", yr);
    }
  }
  return fr = new WeakMap(), dr = new WeakMap(), gr = new WeakSet(), Eo = async function(yr, kr, _r) {
    const xr = `${to(this, fr)}${kr}`, Sr = {
      Accept: "application/json"
    };
    to(this, dr) && (Sr.Authorization = await to(this, dr).call(this, xr, yr)), _r && (Sr["Content-Type"] = "application/json");
    const Er = await fetch(xr, {
      method: yr,
      headers: Sr,
      mode: "cors",
      body: _r ? JSON.stringify(_r) : void 0
    }), Cr = await Er.text();
    if (Er.ok)
      return Cr ? JSON.parse(Cr) : {};
    throw new lr.ApiError(Er.status, Cr);
  }, api.VoidApi = ur, api;
}
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(lr) {
    Object.defineProperty(lr, "__esModule", { value: !0 }), lr.PageSortOrder = lr.PagedSortBy = lr.PaymentOrderState = lr.PaymentServices = lr.PaymentCurrencies = lr.ApiError = lr.StreamEncryption = lr.UploadState = lr.VoidApi = void 0;
    var ar = requireApi();
    Object.defineProperty(lr, "VoidApi", { enumerable: !0, get: function() {
      return ar.VoidApi;
    } });
    var cr = upload;
    Object.defineProperty(lr, "UploadState", { enumerable: !0, get: function() {
      return cr.UploadState;
    } });
    var ur = streamEncryption;
    Object.defineProperty(lr, "StreamEncryption", { enumerable: !0, get: function() {
      return ur.StreamEncryption;
    } });
    class fr extends Error {
      constructor(mr, vr) {
        super(vr);
        ji(this, "statusCode");
        this.statusCode = mr;
      }
    }
    lr.ApiError = fr, function(dr) {
      dr[dr.BTC = 0] = "BTC", dr[dr.USD = 1] = "USD", dr[dr.EUR = 2] = "EUR", dr[dr.GBP = 3] = "GBP";
    }(lr.PaymentCurrencies || (lr.PaymentCurrencies = {})), function(dr) {
      dr[dr.None = 0] = "None", dr[dr.Strike = 1] = "Strike";
    }(lr.PaymentServices || (lr.PaymentServices = {})), function(dr) {
      dr[dr.Unpaid = 0] = "Unpaid", dr[dr.Paid = 1] = "Paid", dr[dr.Expired = 2] = "Expired";
    }(lr.PaymentOrderState || (lr.PaymentOrderState = {})), function(dr) {
      dr[dr.Name = 0] = "Name", dr[dr.Date = 1] = "Date", dr[dr.Size = 2] = "Size", dr[dr.Id = 3] = "Id";
    }(lr.PagedSortBy || (lr.PagedSortBy = {})), function(dr) {
      dr[dr.Asc = 0] = "Asc", dr[dr.Dsc = 1] = "Dsc";
    }(lr.PageSortOrder || (lr.PageSortOrder = {}));
  }(dist)), dist;
}
var distExports = requireDist();
function create_fragment$i(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("style"), cr = space(), ur = element("style"), fr = space(), dr = element("div");
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.innerHTML = css$1, insert(gr, cr, mr), insert(gr, ur, mr), ur.innerHTML = dark, insert(gr, fr, mr), insert(gr, dr, mr), lr[6](dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && (detach(ar), detach(cr), detach(ur), detach(fr), detach(dr)), lr[6](null);
    }
  };
}
const FILE_EXT_REGEX$1 = /\.([\w]{1,7})$/i;
function instance$9(lr, ar, cr) {
  let ur, fr, dr;
  component_subscribe(lr, theme, (Ir) => cr(5, ur = Ir)), component_subscribe(lr, ndkStore, (Ir) => cr(7, fr = Ir)), component_subscribe(lr, localStore, (Ir) => cr(8, dr = Ir));
  let { opinionContent: gr } = ar, { fileArray: mr } = ar, vr, yr, kr = !1;
  const _r = uploadUrl, xr = new distExports.VoidApi(_r), Sr = (Ir) => {
    const Mr = /(?<!\]\()https?:\/\/\S*\.(jpg|jpeg|png|gif|svg|webp)(?!\))/g;
    return Ir.replace(Mr, (Hr) => Hr.startsWith("![](") ? Hr : `![](${Hr})`);
  }, Er = async (Ir) => {
    var zr, Gr, Xr, Jr, li, Qr;
    console.log(Ir);
    const Mr = dr.pk;
    Mr ? !fr.signer && await privkeyLogin(Mr) : !fr.signer && await NDKlogin();
    const Br = await xr.getUploader(Ir).upload({ "V-Strip-Metadata": "true" });
    if (Br.ok) {
      let ei = Ir.name.match(FILE_EXT_REGEX$1);
      console.log(ei), ((Gr = (zr = Br.file) == null ? void 0 : zr.metadata) == null ? void 0 : Gr.mimeType) === "image/webp" && (ei = ["", "webp"]);
      const ui = (Qr = (Jr = (Xr = Br.file) == null ? void 0 : Xr.metadata) == null ? void 0 : Jr.url) != null ? Qr : `${_r}/d/${(li = Br.file) == null ? void 0 : li.id}${ei ? `.${ei[1]}` : ""}`;
      return cr(2, mr = [...mr, { files: Ir, url: ui }]), ui;
    }
    return "";
  };
  function Cr() {
    cr(3, yr = new ToastUIEditor({
      el: vr,
      height: "auto",
      initialEditType: "markdown",
      previewStyle: "tab",
      theme: ur,
      initialValue: gr,
      autofocus: !0,
      events: {
        change() {
          Tr();
        }
      },
      hooks: {
        addImageBlobHook: async (Ir, Mr) => {
          const Hr = await Er(Ir);
          Hr && Mr(Hr, "image");
        }
      },
      extendedAutolinks: !0
    }));
  }
  const Tr = () => {
    cr(4, kr = !0), cr(1, gr = yr.getMarkdown());
  };
  onMount(() => {
    cr(1, gr = gr.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), Cr(), yr.getMarkdown();
  });
  function Ar(Ir) {
    binding_callbacks[Ir ? "unshift" : "push"](() => {
      vr = Ir, cr(0, vr);
    });
  }
  return lr.$$set = (Ir) => {
    "opinionContent" in Ir && cr(1, gr = Ir.opinionContent), "fileArray" in Ir && cr(2, mr = Ir.fileArray);
  }, lr.$$.update = () => {
    if (lr.$$.dirty & /*editor, isInternalUpdate, opinionContent*/
    26) {
      if (yr && !kr) {
        const Ir = yr.getMarkdown();
        gr !== Ir && (cr(1, gr = Sr(gr)), yr.setMarkdown(gr));
      }
      cr(4, kr = !1);
    }
    lr.$$.dirty & /*$theme, editor*/
    40 && ur && yr != null && (yr.destroy(), Cr());
  }, [
    vr,
    gr,
    mr,
    yr,
    kr,
    ur,
    Ar
  ];
}
class Editor_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$9, create_fragment$i, safe_not_equal, { opinionContent: 1, fileArray: 2 });
  }
  get opinionContent() {
    return this.$$.ctx[1];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
}
create_custom_element(Editor_1, { opinionContent: {}, fileArray: {} }, [], [], !0);
function create_fragment$h(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 17.7917L8.79169 16.6917C4.50002 12.8 1.66669 10.225 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5C16.3167 2.5 18.3334 4.50833 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917Z"), attr(ur, "fill", "#cbcccc"), attr(cr, "opacity", "0.5"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class LikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$h, safe_not_equal, {});
  }
}
create_custom_element(LikeButton, {}, [], [], !0);
function create_fragment$g(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "d", "M10 18.35L8.55 17.03C3.4 12.36 0 9.27 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0C17.58 0 20 2.41 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35Z"), attr(cr, "fill", "#73777A"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class LikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$g, safe_not_equal, {});
  }
}
create_custom_element(LikedButton, {}, [], [], !0);
function create_fragment$f(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "fill-rule", "evenodd"), attr(ur, "clip-rule", "evenodd"), attr(ur, "d", "M13.75 2.5C14.5376 2.5 15.2734 2.68911 15.9151 3.02568L5.40369 13.5371C3.07255 11.2282 1.66669 9.29634 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5ZM8.79169 16.6917C7.98933 15.9641 7.23794 15.2825 6.54651 14.6347L17.1749 4.00627C17.8982 4.81336 18.3334 5.88721 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917L8.79169 16.6917Z"), attr(ur, "fill", "#cbcccc"), attr(cr, "opacity", "0.5"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class DislikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$f, safe_not_equal, {});
  }
}
create_custom_element(DislikeButton, {}, [], [], !0);
function create_fragment$e(lr) {
  let ar, cr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), attr(cr, "fill-rule", "evenodd"), attr(cr, "clip-rule", "evenodd"), attr(cr, "d", "M14.5 0C15.4451 0 16.3281 0.226936 17.0981 0.630818L4.48441 13.2445C1.68704 10.4738 0 8.15561 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0ZM8.55 17.03C7.58717 16.1569 6.68551 15.339 5.85579 14.5616L18.6099 1.80753C19.4778 2.77603 20 4.06465 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35L8.55 17.03Z"), attr(cr, "fill", "#73777A"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, fr) {
      insert(ur, ar, fr), append(ar, cr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class DislikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$e, safe_not_equal, {});
  }
}
create_custom_element(DislikedButton, {}, [], [], !0);
function create_fragment$d(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 4L3 10L10 16V12.5C10 12.5 14.802 11.9579 17.2115 14.3323C17.2115 7.91272 10 7.5 10 7.5V4Z"), set_style(ur, "fill", "#cbcccc"), set_style(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class ReplyButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$d, safe_not_equal, {});
  }
}
create_custom_element(ReplyButton, {}, [], [], !0);
function create_fragment$c(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("circle"), fr = svg_element("circle"), dr = svg_element("circle"), attr(ur, "cx", "3.66669"), attr(ur, "cy", "9.6665"), attr(ur, "r", "2.5"), attr(ur, "fill", "#73777A"), attr(fr, "cx", "10.66669"), attr(fr, "cy", "9.6665"), attr(fr, "r", "2.5"), attr(fr, "fill", "#73777A"), attr(dr, "cx", "17.6667"), attr(dr, "cy", "9.6665"), attr(dr, "r", "2.5"), attr(dr, "fill", "#73777A"), attr(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar);
    }
  };
}
class OptionButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$c, safe_not_equal, {});
  }
}
create_custom_element(OptionButton, {}, [], [], !0);
function create_fragment$b(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("rect"), ur = svg_element("path"), attr(cr, "y", "0.5"), attr(cr, "width", "106"), attr(cr, "height", "17"), attr(cr, "rx", "3"), attr(cr, "fill", "#F7931A"), attr(ur, "d", "M9.1985 10.07L8.3075 7.703C8.2355 7.52 8.162 7.2875 8.087 7.0055C8.054 7.1465 8.018 7.277 7.979 7.397C7.94 7.514 7.904 7.6175 7.871 7.7075L6.98 10.07H9.1985ZM11.192 12.5H10.3775C10.2845 12.5 10.2095 12.4775 10.1525 12.4325C10.0955 12.3845 10.052 12.326 10.022 12.257L9.482 10.826H6.692L6.152 12.257C6.128 12.317 6.086 12.3725 6.026 12.4235C5.966 12.4745 5.891 12.5 5.801 12.5H4.9865L7.556 6.02H8.6225L11.192 12.5ZM13.9642 9.323C14.1982 9.323 14.4037 9.293 14.5807 9.233C14.7607 9.173 14.9092 9.089 15.0262 8.981C15.1462 8.87 15.2362 8.7365 15.2962 8.5805C15.3562 8.4245 15.3862 8.2505 15.3862 8.0585C15.3862 7.8695 15.3562 7.7 15.2962 7.55C15.2392 7.4 15.1522 7.2725 15.0352 7.1675C14.9182 7.0625 14.7697 6.983 14.5897 6.929C14.4127 6.872 14.2042 6.8435 13.9642 6.8435H13.0012V9.323H13.9642ZM13.9642 6.02C14.3872 6.02 14.7532 6.0695 15.0622 6.1685C15.3742 6.2675 15.6307 6.407 15.8317 6.587C16.0357 6.764 16.1872 6.9785 16.2862 7.2305C16.3852 7.4795 16.4347 7.7555 16.4347 8.0585C16.4347 8.3675 16.3822 8.651 16.2772 8.909C16.1722 9.164 16.0162 9.3845 15.8092 9.5705C15.6022 9.7535 15.3442 9.8975 15.0352 10.0025C14.7292 10.1045 14.3722 10.1555 13.9642 10.1555H13.0012V12.5H11.9482V6.02H13.9642ZM19.4574 9.323C19.6914 9.323 19.8969 9.293 20.0739 9.233C20.2539 9.173 20.4024 9.089 20.5194 8.981C20.6394 8.87 20.7294 8.7365 20.7894 8.5805C20.8494 8.4245 20.8794 8.2505 20.8794 8.0585C20.8794 7.8695 20.8494 7.7 20.7894 7.55C20.7324 7.4 20.6454 7.2725 20.5284 7.1675C20.4114 7.0625 20.2629 6.983 20.0829 6.929C19.9059 6.872 19.6974 6.8435 19.4574 6.8435H18.4944V9.323H19.4574ZM19.4574 6.02C19.8804 6.02 20.2464 6.0695 20.5554 6.1685C20.8674 6.2675 21.1239 6.407 21.3249 6.587C21.5289 6.764 21.6804 6.9785 21.7794 7.2305C21.8784 7.4795 21.9279 7.7555 21.9279 8.0585C21.9279 8.3675 21.8754 8.651 21.7704 8.909C21.6654 9.164 21.5094 9.3845 21.3024 9.5705C21.0954 9.7535 20.8374 9.8975 20.5284 10.0025C20.2224 10.1045 19.8654 10.1555 19.4574 10.1555H18.4944V12.5H17.4414V6.02H19.4574ZM24.8155 9.125C25.0555 9.125 25.2655 9.0965 25.4455 9.0395C25.6255 8.9795 25.7755 8.897 25.8955 8.792C26.0155 8.687 26.1055 8.5625 26.1655 8.4185C26.2255 8.2715 26.2555 8.1095 26.2555 7.9325C26.2555 7.5785 26.1385 7.3085 25.9045 7.1225C25.6705 6.9365 25.3165 6.8435 24.8425 6.8435H23.9875V9.125H24.8155ZM27.8665 12.5H26.926C26.74 12.5 26.605 12.428 26.521 12.284L25.009 10.1015C24.958 10.0265 24.9025 9.9725 24.8425 9.9395C24.7825 9.9065 24.6925 9.89 24.5725 9.89H23.9875V12.5H22.9345V6.02H24.8425C25.2685 6.02 25.6345 6.0635 25.9405 6.1505C26.2495 6.2375 26.503 6.362 26.701 6.524C26.899 6.683 27.0445 6.875 27.1375 7.1C27.2335 7.325 27.2815 7.5755 27.2815 7.8515C27.2815 8.0765 27.247 8.2865 27.178 8.4815C27.112 8.6765 27.0145 8.8535 26.8855 9.0125C26.7595 9.1715 26.6035 9.3095 26.4175 9.4265C26.2315 9.5435 26.02 9.635 25.783 9.701C25.912 9.779 26.023 9.8885 26.116 10.0295L27.8665 12.5ZM34.6568 9.26C34.6568 9.74 34.5788 10.1825 34.4228 10.5875C34.2668 10.9925 34.0463 11.342 33.7613 11.636C33.4793 11.927 33.1388 12.155 32.7398 12.32C32.3438 12.485 31.9028 12.5675 31.4168 12.5675C30.9338 12.5675 30.4928 12.485 30.0938 12.32C29.6978 12.155 29.3573 11.927 29.0723 11.636C28.7873 11.342 28.5668 10.9925 28.4108 10.5875C28.2548 10.1825 28.1768 9.74 28.1768 9.26C28.1768 8.78 28.2548 8.3375 28.4108 7.9325C28.5668 7.5275 28.7873 7.178 29.0723 6.884C29.3573 6.59 29.6978 6.3605 30.0938 6.1955C30.4928 6.0305 30.9338 5.948 31.4168 5.948C31.9028 5.948 32.3438 6.0305 32.7398 6.1955C33.1388 6.3605 33.4793 6.59 33.7613 6.884C34.0463 7.178 34.2668 7.5275 34.4228 7.9325C34.5788 8.3375 34.6568 8.78 34.6568 9.26ZM33.5813 9.26C33.5813 8.888 33.5303 8.5535 33.4283 8.2565C33.3293 7.9595 33.1853 7.7075 32.9963 7.5005C32.8103 7.2935 32.5838 7.1345 32.3168 7.0235C32.0498 6.9125 31.7498 6.857 31.4168 6.857C31.0868 6.857 30.7883 6.9125 30.5213 7.0235C30.2543 7.1345 30.0263 7.2935 29.8373 7.5005C29.6483 7.7075 29.5028 7.9595 29.4008 8.2565C29.2988 8.5535 29.2478 8.888 29.2478 9.26C29.2478 9.635 29.2988 9.971 29.4008 10.268C29.5028 10.565 29.6483 10.817 29.8373 11.024C30.0263 11.228 30.2543 11.3855 30.5213 11.4965C30.7883 11.6045 31.0868 11.6585 31.4168 11.6585C31.7498 11.6585 32.0498 11.6045 32.3168 11.4965C32.5838 11.3855 32.8103 11.228 32.9963 11.024C33.1853 10.817 33.3293 10.565 33.4283 10.268C33.5303 9.971 33.5813 9.635 33.5813 9.26ZM41.0309 6.02L38.4029 12.5H37.4534L34.8254 6.02H35.6669C35.7599 6.02 35.8349 6.044 35.8919 6.092C35.9489 6.137 35.9924 6.194 36.0224 6.263L37.6919 10.4885C37.7819 10.7255 37.8644 10.9985 37.9394 11.3075C37.9724 11.1545 38.0069 11.009 38.0429 10.871C38.0819 10.733 38.1239 10.6055 38.1689 10.4885L39.8339 6.263C39.8579 6.203 39.8999 6.1475 39.9599 6.0965C40.0199 6.0455 40.0949 6.02 40.1849 6.02H41.0309ZM45.8326 11.6495L45.8281 12.5H41.7871V6.02H45.8281V6.8705H42.8446V8.8235H45.2296V9.647H42.8446V11.6495H45.8326ZM52.6606 9.26C52.6606 9.74 52.5826 10.1795 52.4266 10.5785C52.2706 10.9745 52.0501 11.315 51.7651 11.6C51.4831 11.885 51.1426 12.107 50.7436 12.266C50.3476 12.422 49.9066 12.5 49.4206 12.5H46.9726V6.02H49.4206C49.9066 6.02 50.3476 6.0995 50.7436 6.2585C51.1426 6.4145 51.4831 6.635 51.7651 6.92C52.0501 7.205 52.2706 7.547 52.4266 7.946C52.5826 8.342 52.6606 8.78 52.6606 9.26ZM51.5851 9.26C51.5851 8.888 51.5341 8.5535 51.4321 8.2565C51.3331 7.9595 51.1891 7.709 51.0001 7.505C50.8141 7.301 50.5876 7.145 50.3206 7.037C50.0536 6.926 49.7536 6.8705 49.4206 6.8705H48.0301V11.6495H49.4206C49.7536 11.6495 50.0536 11.5955 50.3206 11.4875C50.5876 11.3795 50.8141 11.2235 51.0001 11.0195C51.1891 10.8125 51.3331 10.562 51.4321 10.268C51.5341 9.971 51.5851 9.635 51.5851 9.26ZM57.9415 9.125C58.1815 9.125 58.3915 9.0965 58.5715 9.0395C58.7515 8.9795 58.9015 8.897 59.0215 8.792C59.1415 8.687 59.2315 8.5625 59.2915 8.4185C59.3515 8.2715 59.3815 8.1095 59.3815 7.9325C59.3815 7.5785 59.2645 7.3085 59.0305 7.1225C58.7965 6.9365 58.4425 6.8435 57.9685 6.8435H57.1135V9.125H57.9415ZM60.9925 12.5H60.052C59.866 12.5 59.731 12.428 59.647 12.284L58.135 10.1015C58.084 10.0265 58.0285 9.9725 57.9685 9.9395C57.9085 9.9065 57.8185 9.89 57.6985 9.89H57.1135V12.5H56.0605V6.02H57.9685C58.3945 6.02 58.7605 6.0635 59.0665 6.1505C59.3755 6.2375 59.629 6.362 59.827 6.524C60.025 6.683 60.1705 6.875 60.2635 7.1C60.3595 7.325 60.4075 7.5755 60.4075 7.8515C60.4075 8.0765 60.373 8.2865 60.304 8.4815C60.238 8.6765 60.1405 8.8535 60.0115 9.0125C59.8855 9.1715 59.7295 9.3095 59.5435 9.4265C59.3575 9.5435 59.146 9.635 58.909 9.701C59.038 9.779 59.149 9.8885 59.242 10.0295L60.9925 12.5ZM65.8189 11.6495L65.8144 12.5H61.7734V6.02H65.8144V6.8705H62.8309V8.8235H65.2159V9.647H62.8309V11.6495H65.8189ZM72.3815 6.02L69.7535 12.5H68.804L66.176 6.02H67.0175C67.1105 6.02 67.1855 6.044 67.2425 6.092C67.2995 6.137 67.343 6.194 67.373 6.263L69.0425 10.4885C69.1325 10.7255 69.215 10.9985 69.29 11.3075C69.323 11.1545 69.3575 11.009 69.3935 10.871C69.4325 10.733 69.4745 10.6055 69.5195 10.4885L71.1845 6.263C71.2085 6.203 71.2505 6.1475 71.3105 6.0965C71.3705 6.0455 71.4455 6.02 71.5355 6.02H72.3815ZM74.1952 12.5H73.1377V6.02H74.1952V12.5ZM79.7759 11.6495L79.7714 12.5H75.7304V6.02H79.7714V6.8705H76.7879V8.8235H79.1729V9.647H76.7879V11.6495H79.7759ZM89.4345 6.02L87.4185 12.5H86.469L84.948 7.847C84.93 7.796 84.912 7.7405 84.894 7.6805C84.879 7.6205 84.864 7.556 84.849 7.487C84.834 7.556 84.8175 7.6205 84.7995 7.6805C84.7845 7.7405 84.768 7.796 84.75 7.847L83.2155 12.5H82.266L80.25 6.02H81.132C81.222 6.02 81.297 6.0425 81.357 6.0875C81.42 6.1295 81.462 6.188 81.483 6.263L82.698 10.4165C82.722 10.5065 82.7445 10.604 82.7655 10.709C82.7865 10.814 82.8075 10.9235 82.8285 11.0375C82.8495 10.9235 82.872 10.814 82.896 10.709C82.923 10.601 82.9515 10.5035 82.9815 10.4165L84.372 6.263C84.393 6.203 84.435 6.1475 84.498 6.0965C84.561 6.0455 84.636 6.02 84.723 6.02H85.029C85.122 6.02 85.197 6.044 85.254 6.092C85.311 6.137 85.3545 6.194 85.3845 6.263L86.7705 10.4165C86.8005 10.5035 86.8275 10.598 86.8515 10.7C86.8785 10.799 86.9025 10.904 86.9235 11.015C86.9445 10.904 86.964 10.799 86.982 10.7C87.003 10.598 87.0255 10.5035 87.0495 10.4165L88.26 6.263C88.278 6.197 88.3185 6.14 88.3815 6.092C88.4475 6.044 88.524 6.02 88.611 6.02H89.4345ZM94.357 11.6495L94.3525 12.5H90.3115V6.02H94.3525V6.8705H91.369V8.8235H93.754V9.647H91.369V11.6495H94.357ZM97.378 9.125C97.618 9.125 97.828 9.0965 98.008 9.0395C98.188 8.9795 98.338 8.897 98.458 8.792C98.578 8.687 98.668 8.5625 98.728 8.4185C98.788 8.2715 98.818 8.1095 98.818 7.9325C98.818 7.5785 98.701 7.3085 98.467 7.1225C98.233 6.9365 97.879 6.8435 97.405 6.8435H96.55V9.125H97.378ZM100.429 12.5H99.4885C99.3025 12.5 99.1675 12.428 99.0835 12.284L97.5715 10.1015C97.5205 10.0265 97.465 9.9725 97.405 9.9395C97.345 9.9065 97.255 9.89 97.135 9.89H96.55V12.5H95.497V6.02H97.405C97.831 6.02 98.197 6.0635 98.503 6.1505C98.812 6.2375 99.0655 6.362 99.2635 6.524C99.4615 6.683 99.607 6.875 99.7 7.1C99.796 7.325 99.844 7.5755 99.844 7.8515C99.844 8.0765 99.8095 8.2865 99.7405 8.4815C99.6745 8.6765 99.577 8.8535 99.448 9.0125C99.322 9.1715 99.166 9.3095 98.98 9.4265C98.794 9.5435 98.5825 9.635 98.3455 9.701C98.4745 9.779 98.5855 9.8885 98.6785 10.0295L100.429 12.5Z"), attr(ur, "fill", "white"), attr(ar, "width", "106"), attr(ar, "height", "18"), attr(ar, "viewBox", "0 0 106 18"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class ApprovedBadge extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$b, safe_not_equal, {});
  }
}
create_custom_element(ApprovedBadge, {}, [], [], !0);
function _getDefaults() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
let _defaults = _getDefaults();
function changeDefaults(lr) {
  _defaults = lr;
}
const escapeTest = /[&<>"']/, escapeReplace = new RegExp(escapeTest.source, "g"), escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g"), escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, getEscapeReplacement = (lr) => escapeReplacements[lr];
function escape$1(lr, ar) {
  if (ar) {
    if (escapeTest.test(lr))
      return lr.replace(escapeReplace, getEscapeReplacement);
  } else if (escapeTestNoEncode.test(lr))
    return lr.replace(escapeReplaceNoEncode, getEscapeReplacement);
  return lr;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(lr) {
  return lr.replace(unescapeTest, (ar, cr) => (cr = cr.toLowerCase(), cr === "colon" ? ":" : cr.charAt(0) === "#" ? cr.charAt(1) === "x" ? String.fromCharCode(parseInt(cr.substring(2), 16)) : String.fromCharCode(+cr.substring(1)) : ""));
}
const caret = /(^|[^\[])\^/g;
function edit(lr, ar) {
  let cr = typeof lr == "string" ? lr : lr.source;
  ar = ar || "";
  const ur = {
    replace: (fr, dr) => {
      let gr = typeof dr == "string" ? dr : dr.source;
      return gr = gr.replace(caret, "$1"), cr = cr.replace(fr, gr), ur;
    },
    getRegex: () => new RegExp(cr, ar)
  };
  return ur;
}
function cleanUrl(lr) {
  try {
    lr = encodeURI(lr).replace(/%25/g, "%");
  } catch (ar) {
    return null;
  }
  return lr;
}
const noopTest = { exec: () => null };
function splitCells(lr, ar) {
  const cr = lr.replace(/\|/g, (dr, gr, mr) => {
    let vr = !1, yr = gr;
    for (; --yr >= 0 && mr[yr] === "\\"; )
      vr = !vr;
    return vr ? "|" : " |";
  }), ur = cr.split(/ \|/);
  let fr = 0;
  if (ur[0].trim() || ur.shift(), ur.length > 0 && !ur[ur.length - 1].trim() && ur.pop(), ar)
    if (ur.length > ar)
      ur.splice(ar);
    else
      for (; ur.length < ar; )
        ur.push("");
  for (; fr < ur.length; fr++)
    ur[fr] = ur[fr].trim().replace(/\\\|/g, "|");
  return ur;
}
function rtrim(lr, ar, cr) {
  const ur = lr.length;
  if (ur === 0)
    return "";
  let fr = 0;
  for (; fr < ur; ) {
    const dr = lr.charAt(ur - fr - 1);
    if (dr === ar && !cr)
      fr++;
    else if (dr !== ar && cr)
      fr++;
    else
      break;
  }
  return lr.slice(0, ur - fr);
}
function findClosingBracket(lr, ar) {
  if (lr.indexOf(ar[1]) === -1)
    return -1;
  let cr = 0;
  for (let ur = 0; ur < lr.length; ur++)
    if (lr[ur] === "\\")
      ur++;
    else if (lr[ur] === ar[0])
      cr++;
    else if (lr[ur] === ar[1] && (cr--, cr < 0))
      return ur;
  return -1;
}
function outputLink(lr, ar, cr, ur) {
  const fr = ar.href, dr = ar.title ? escape$1(ar.title) : null, gr = lr[1].replace(/\\([\[\]])/g, "$1");
  if (lr[0].charAt(0) !== "!") {
    ur.state.inLink = !0;
    const mr = {
      type: "link",
      raw: cr,
      href: fr,
      title: dr,
      text: gr,
      tokens: ur.inlineTokens(gr)
    };
    return ur.state.inLink = !1, mr;
  }
  return {
    type: "image",
    raw: cr,
    href: fr,
    title: dr,
    text: escape$1(gr)
  };
}
function indentCodeCompensation(lr, ar) {
  const cr = lr.match(/^(\s+)(?:```)/);
  if (cr === null)
    return ar;
  const ur = cr[1];
  return ar.split(`
`).map((fr) => {
    const dr = fr.match(/^\s+/);
    if (dr === null)
      return fr;
    const [gr] = dr;
    return gr.length >= ur.length ? fr.slice(ur.length) : fr;
  }).join(`
`);
}
class _Tokenizer {
  // set by the lexer
  constructor(ar) {
    ji(this, "options");
    ji(this, "rules");
    // set by the lexer
    ji(this, "lexer");
    this.options = ar || _defaults;
  }
  space(ar) {
    const cr = this.rules.block.newline.exec(ar);
    if (cr && cr[0].length > 0)
      return {
        type: "space",
        raw: cr[0]
      };
  }
  code(ar) {
    const cr = this.rules.block.code.exec(ar);
    if (cr) {
      const ur = cr[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cr[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? ur : rtrim(ur, `
`)
      };
    }
  }
  fences(ar) {
    const cr = this.rules.block.fences.exec(ar);
    if (cr) {
      const ur = cr[0], fr = indentCodeCompensation(ur, cr[3] || "");
      return {
        type: "code",
        raw: ur,
        lang: cr[2] ? cr[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cr[2],
        text: fr
      };
    }
  }
  heading(ar) {
    const cr = this.rules.block.heading.exec(ar);
    if (cr) {
      let ur = cr[2].trim();
      if (/#$/.test(ur)) {
        const fr = rtrim(ur, "#");
        (this.options.pedantic || !fr || / $/.test(fr)) && (ur = fr.trim());
      }
      return {
        type: "heading",
        raw: cr[0],
        depth: cr[1].length,
        text: ur,
        tokens: this.lexer.inline(ur)
      };
    }
  }
  hr(ar) {
    const cr = this.rules.block.hr.exec(ar);
    if (cr)
      return {
        type: "hr",
        raw: cr[0]
      };
  }
  blockquote(ar) {
    const cr = this.rules.block.blockquote.exec(ar);
    if (cr) {
      const ur = rtrim(cr[0].replace(/^ *>[ \t]?/gm, ""), `
`), fr = this.lexer.state.top;
      this.lexer.state.top = !0;
      const dr = this.lexer.blockTokens(ur);
      return this.lexer.state.top = fr, {
        type: "blockquote",
        raw: cr[0],
        tokens: dr,
        text: ur
      };
    }
  }
  list(ar) {
    let cr = this.rules.block.list.exec(ar);
    if (cr) {
      let ur = cr[1].trim();
      const fr = ur.length > 1, dr = {
        type: "list",
        raw: "",
        ordered: fr,
        start: fr ? +ur.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      ur = fr ? `\\d{1,9}\\${ur.slice(-1)}` : `\\${ur}`, this.options.pedantic && (ur = fr ? ur : "[*+-]");
      const gr = new RegExp(`^( {0,3}${ur})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let mr = "", vr = "", yr = !1;
      for (; ar; ) {
        let kr = !1;
        if (!(cr = gr.exec(ar)) || this.rules.block.hr.test(ar))
          break;
        mr = cr[0], ar = ar.substring(mr.length);
        let _r = cr[2].split(`
`, 1)[0].replace(/^\t+/, (Ar) => " ".repeat(3 * Ar.length)), xr = ar.split(`
`, 1)[0], Sr = 0;
        this.options.pedantic ? (Sr = 2, vr = _r.trimStart()) : (Sr = cr[2].search(/[^ ]/), Sr = Sr > 4 ? 1 : Sr, vr = _r.slice(Sr), Sr += cr[1].length);
        let Er = !1;
        if (!_r && /^ *$/.test(xr) && (mr += xr + `
`, ar = ar.substring(xr.length + 1), kr = !0), !kr) {
          const Ar = new RegExp(`^ {0,${Math.min(3, Sr - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Ir = new RegExp(`^ {0,${Math.min(3, Sr - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), Mr = new RegExp(`^ {0,${Math.min(3, Sr - 1)}}(?:\`\`\`|~~~)`), Hr = new RegExp(`^ {0,${Math.min(3, Sr - 1)}}#`);
          for (; ar; ) {
            const Br = ar.split(`
`, 1)[0];
            if (xr = Br, this.options.pedantic && (xr = xr.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), Mr.test(xr) || Hr.test(xr) || Ar.test(xr) || Ir.test(ar))
              break;
            if (xr.search(/[^ ]/) >= Sr || !xr.trim())
              vr += `
` + xr.slice(Sr);
            else {
              if (Er || _r.search(/[^ ]/) >= 4 || Mr.test(_r) || Hr.test(_r) || Ir.test(_r))
                break;
              vr += `
` + xr;
            }
            !Er && !xr.trim() && (Er = !0), mr += Br + `
`, ar = ar.substring(Br.length + 1), _r = xr.slice(Sr);
          }
        }
        dr.loose || (yr ? dr.loose = !0 : /\n *\n *$/.test(mr) && (yr = !0));
        let Cr = null, Tr;
        this.options.gfm && (Cr = /^\[[ xX]\] /.exec(vr), Cr && (Tr = Cr[0] !== "[ ] ", vr = vr.replace(/^\[[ xX]\] +/, ""))), dr.items.push({
          type: "list_item",
          raw: mr,
          task: !!Cr,
          checked: Tr,
          loose: !1,
          text: vr,
          tokens: []
        }), dr.raw += mr;
      }
      dr.items[dr.items.length - 1].raw = mr.trimEnd(), dr.items[dr.items.length - 1].text = vr.trimEnd(), dr.raw = dr.raw.trimEnd();
      for (let kr = 0; kr < dr.items.length; kr++)
        if (this.lexer.state.top = !1, dr.items[kr].tokens = this.lexer.blockTokens(dr.items[kr].text, []), !dr.loose) {
          const _r = dr.items[kr].tokens.filter((Sr) => Sr.type === "space"), xr = _r.length > 0 && _r.some((Sr) => /\n.*\n/.test(Sr.raw));
          dr.loose = xr;
        }
      if (dr.loose)
        for (let kr = 0; kr < dr.items.length; kr++)
          dr.items[kr].loose = !0;
      return dr;
    }
  }
  html(ar) {
    const cr = this.rules.block.html.exec(ar);
    if (cr)
      return {
        type: "html",
        block: !0,
        raw: cr[0],
        pre: cr[1] === "pre" || cr[1] === "script" || cr[1] === "style",
        text: cr[0]
      };
  }
  def(ar) {
    const cr = this.rules.block.def.exec(ar);
    if (cr) {
      const ur = cr[1].toLowerCase().replace(/\s+/g, " "), fr = cr[2] ? cr[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", dr = cr[3] ? cr[3].substring(1, cr[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cr[3];
      return {
        type: "def",
        tag: ur,
        raw: cr[0],
        href: fr,
        title: dr
      };
    }
  }
  table(ar) {
    const cr = this.rules.block.table.exec(ar);
    if (!cr || !/[:|]/.test(cr[2]))
      return;
    const ur = splitCells(cr[1]), fr = cr[2].replace(/^\||\| *$/g, "").split("|"), dr = cr[3] && cr[3].trim() ? cr[3].replace(/\n[ \t]*$/, "").split(`
`) : [], gr = {
      type: "table",
      raw: cr[0],
      header: [],
      align: [],
      rows: []
    };
    if (ur.length === fr.length) {
      for (const mr of fr)
        /^ *-+: *$/.test(mr) ? gr.align.push("right") : /^ *:-+: *$/.test(mr) ? gr.align.push("center") : /^ *:-+ *$/.test(mr) ? gr.align.push("left") : gr.align.push(null);
      for (const mr of ur)
        gr.header.push({
          text: mr,
          tokens: this.lexer.inline(mr)
        });
      for (const mr of dr)
        gr.rows.push(splitCells(mr, gr.header.length).map((vr) => ({
          text: vr,
          tokens: this.lexer.inline(vr)
        })));
      return gr;
    }
  }
  lheading(ar) {
    const cr = this.rules.block.lheading.exec(ar);
    if (cr)
      return {
        type: "heading",
        raw: cr[0],
        depth: cr[2].charAt(0) === "=" ? 1 : 2,
        text: cr[1],
        tokens: this.lexer.inline(cr[1])
      };
  }
  paragraph(ar) {
    const cr = this.rules.block.paragraph.exec(ar);
    if (cr) {
      const ur = cr[1].charAt(cr[1].length - 1) === `
` ? cr[1].slice(0, -1) : cr[1];
      return {
        type: "paragraph",
        raw: cr[0],
        text: ur,
        tokens: this.lexer.inline(ur)
      };
    }
  }
  text(ar) {
    const cr = this.rules.block.text.exec(ar);
    if (cr)
      return {
        type: "text",
        raw: cr[0],
        text: cr[0],
        tokens: this.lexer.inline(cr[0])
      };
  }
  escape(ar) {
    const cr = this.rules.inline.escape.exec(ar);
    if (cr)
      return {
        type: "escape",
        raw: cr[0],
        text: escape$1(cr[1])
      };
  }
  tag(ar) {
    const cr = this.rules.inline.tag.exec(ar);
    if (cr)
      return !this.lexer.state.inLink && /^<a /i.test(cr[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(cr[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cr[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cr[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: cr[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: cr[0]
      };
  }
  link(ar) {
    const cr = this.rules.inline.link.exec(ar);
    if (cr) {
      const ur = cr[2].trim();
      if (!this.options.pedantic && /^</.test(ur)) {
        if (!/>$/.test(ur))
          return;
        const gr = rtrim(ur.slice(0, -1), "\\");
        if ((ur.length - gr.length) % 2 === 0)
          return;
      } else {
        const gr = findClosingBracket(cr[2], "()");
        if (gr > -1) {
          const vr = (cr[0].indexOf("!") === 0 ? 5 : 4) + cr[1].length + gr;
          cr[2] = cr[2].substring(0, gr), cr[0] = cr[0].substring(0, vr).trim(), cr[3] = "";
        }
      }
      let fr = cr[2], dr = "";
      if (this.options.pedantic) {
        const gr = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(fr);
        gr && (fr = gr[1], dr = gr[3]);
      } else
        dr = cr[3] ? cr[3].slice(1, -1) : "";
      return fr = fr.trim(), /^</.test(fr) && (this.options.pedantic && !/>$/.test(ur) ? fr = fr.slice(1) : fr = fr.slice(1, -1)), outputLink(cr, {
        href: fr && fr.replace(this.rules.inline.anyPunctuation, "$1"),
        title: dr && dr.replace(this.rules.inline.anyPunctuation, "$1")
      }, cr[0], this.lexer);
    }
  }
  reflink(ar, cr) {
    let ur;
    if ((ur = this.rules.inline.reflink.exec(ar)) || (ur = this.rules.inline.nolink.exec(ar))) {
      const fr = (ur[2] || ur[1]).replace(/\s+/g, " "), dr = cr[fr.toLowerCase()];
      if (!dr) {
        const gr = ur[0].charAt(0);
        return {
          type: "text",
          raw: gr,
          text: gr
        };
      }
      return outputLink(ur, dr, ur[0], this.lexer);
    }
  }
  emStrong(ar, cr, ur = "") {
    let fr = this.rules.inline.emStrongLDelim.exec(ar);
    if (!fr || fr[3] && ur.match(/[\p{L}\p{N}]/u))
      return;
    if (!(fr[1] || fr[2] || "") || !ur || this.rules.inline.punctuation.exec(ur)) {
      const gr = [...fr[0]].length - 1;
      let mr, vr, yr = gr, kr = 0;
      const _r = fr[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (_r.lastIndex = 0, cr = cr.slice(-1 * ar.length + gr); (fr = _r.exec(cr)) != null; ) {
        if (mr = fr[1] || fr[2] || fr[3] || fr[4] || fr[5] || fr[6], !mr)
          continue;
        if (vr = [...mr].length, fr[3] || fr[4]) {
          yr += vr;
          continue;
        } else if ((fr[5] || fr[6]) && gr % 3 && !((gr + vr) % 3)) {
          kr += vr;
          continue;
        }
        if (yr -= vr, yr > 0)
          continue;
        vr = Math.min(vr, vr + yr + kr);
        const xr = [...fr[0]][0].length, Sr = ar.slice(0, gr + fr.index + xr + vr);
        if (Math.min(gr, vr) % 2) {
          const Cr = Sr.slice(1, -1);
          return {
            type: "em",
            raw: Sr,
            text: Cr,
            tokens: this.lexer.inlineTokens(Cr)
          };
        }
        const Er = Sr.slice(2, -2);
        return {
          type: "strong",
          raw: Sr,
          text: Er,
          tokens: this.lexer.inlineTokens(Er)
        };
      }
    }
  }
  codespan(ar) {
    const cr = this.rules.inline.code.exec(ar);
    if (cr) {
      let ur = cr[2].replace(/\n/g, " ");
      const fr = /[^ ]/.test(ur), dr = /^ /.test(ur) && / $/.test(ur);
      return fr && dr && (ur = ur.substring(1, ur.length - 1)), ur = escape$1(ur, !0), {
        type: "codespan",
        raw: cr[0],
        text: ur
      };
    }
  }
  br(ar) {
    const cr = this.rules.inline.br.exec(ar);
    if (cr)
      return {
        type: "br",
        raw: cr[0]
      };
  }
  del(ar) {
    const cr = this.rules.inline.del.exec(ar);
    if (cr)
      return {
        type: "del",
        raw: cr[0],
        text: cr[2],
        tokens: this.lexer.inlineTokens(cr[2])
      };
  }
  autolink(ar) {
    const cr = this.rules.inline.autolink.exec(ar);
    if (cr) {
      let ur, fr;
      return cr[2] === "@" ? (ur = escape$1(cr[1]), fr = "mailto:" + ur) : (ur = escape$1(cr[1]), fr = ur), {
        type: "link",
        raw: cr[0],
        text: ur,
        href: fr,
        tokens: [
          {
            type: "text",
            raw: ur,
            text: ur
          }
        ]
      };
    }
  }
  url(ar) {
    var ur, fr;
    let cr;
    if (cr = this.rules.inline.url.exec(ar)) {
      let dr, gr;
      if (cr[2] === "@")
        dr = escape$1(cr[0]), gr = "mailto:" + dr;
      else {
        let mr;
        do
          mr = cr[0], cr[0] = (fr = (ur = this.rules.inline._backpedal.exec(cr[0])) == null ? void 0 : ur[0]) != null ? fr : "";
        while (mr !== cr[0]);
        dr = escape$1(cr[0]), cr[1] === "www." ? gr = "http://" + cr[0] : gr = cr[0];
      }
      return {
        type: "link",
        raw: cr[0],
        text: dr,
        href: gr,
        tokens: [
          {
            type: "text",
            raw: dr,
            text: dr
          }
        ]
      };
    }
  }
  inlineText(ar) {
    const cr = this.rules.inline.text.exec(ar);
    if (cr) {
      let ur;
      return this.lexer.state.inRawBlock ? ur = cr[0] : ur = escape$1(cr[0]), {
        type: "text",
        raw: cr[0],
        text: ur
      };
    }
  }
}
const newline = /^(?: *(?:\n|$))+/, blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/, lheading = edit(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, blockText = /^[^\n]+/, _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/, def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex(), _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, html$2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html: html$2,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
}, gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
}, blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, escape$2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br = /^( {2,}|\\)\n(?!\s*$)/, inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, _punctuation = "\\p{P}$+<=>`^|~", punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex(), blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex(), anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex(), autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex(), tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex(), nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex(), reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex(), inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$2,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
}, inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
}, inlineGfm = {
  ...inlineNormal,
  escape: edit(escape$2).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
}, inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
class _Lexer {
  constructor(ar) {
    ji(this, "tokens");
    ji(this, "options");
    ji(this, "state");
    ji(this, "tokenizer");
    ji(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = ar || _defaults, this.options.tokenizer = this.options.tokenizer || new _Tokenizer(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const cr = {
      block: block.normal,
      inline: inline.normal
    };
    this.options.pedantic ? (cr.block = block.pedantic, cr.inline = inline.pedantic) : this.options.gfm && (cr.block = block.gfm, this.options.breaks ? cr.inline = inline.breaks : cr.inline = inline.gfm), this.tokenizer.rules = cr;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(ar, cr) {
    return new _Lexer(cr).lex(ar);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(ar, cr) {
    return new _Lexer(cr).inlineTokens(ar);
  }
  /**
   * Preprocessing
   */
  lex(ar) {
    ar = ar.replace(/\r\n|\r/g, `
`), this.blockTokens(ar, this.tokens);
    let cr;
    for (; cr = this.inlineQueue.shift(); )
      this.inlineTokens(cr.src, cr.tokens);
    return this.tokens;
  }
  blockTokens(ar, cr = []) {
    this.options.pedantic ? ar = ar.replace(/\t/g, "    ").replace(/^ +$/gm, "") : ar = ar.replace(/^( *)(\t+)/gm, (mr, vr, yr) => vr + "    ".repeat(yr.length));
    let ur, fr, dr, gr;
    for (; ar; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((mr) => (ur = mr.call({ lexer: this }, ar, cr)) ? (ar = ar.substring(ur.raw.length), cr.push(ur), !0) : !1))) {
        if (ur = this.tokenizer.space(ar)) {
          ar = ar.substring(ur.raw.length), ur.raw.length === 1 && cr.length > 0 ? cr[cr.length - 1].raw += `
` : cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.code(ar)) {
          ar = ar.substring(ur.raw.length), fr = cr[cr.length - 1], fr && (fr.type === "paragraph" || fr.type === "text") ? (fr.raw += `
` + ur.raw, fr.text += `
` + ur.text, this.inlineQueue[this.inlineQueue.length - 1].src = fr.text) : cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.fences(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.heading(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.hr(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.blockquote(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.list(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.html(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.def(ar)) {
          ar = ar.substring(ur.raw.length), fr = cr[cr.length - 1], fr && (fr.type === "paragraph" || fr.type === "text") ? (fr.raw += `
` + ur.raw, fr.text += `
` + ur.raw, this.inlineQueue[this.inlineQueue.length - 1].src = fr.text) : this.tokens.links[ur.tag] || (this.tokens.links[ur.tag] = {
            href: ur.href,
            title: ur.title
          });
          continue;
        }
        if (ur = this.tokenizer.table(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.lheading(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (dr = ar, this.options.extensions && this.options.extensions.startBlock) {
          let mr = 1 / 0;
          const vr = ar.slice(1);
          let yr;
          this.options.extensions.startBlock.forEach((kr) => {
            yr = kr.call({ lexer: this }, vr), typeof yr == "number" && yr >= 0 && (mr = Math.min(mr, yr));
          }), mr < 1 / 0 && mr >= 0 && (dr = ar.substring(0, mr + 1));
        }
        if (this.state.top && (ur = this.tokenizer.paragraph(dr))) {
          fr = cr[cr.length - 1], gr && fr.type === "paragraph" ? (fr.raw += `
` + ur.raw, fr.text += `
` + ur.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = fr.text) : cr.push(ur), gr = dr.length !== ar.length, ar = ar.substring(ur.raw.length);
          continue;
        }
        if (ur = this.tokenizer.text(ar)) {
          ar = ar.substring(ur.raw.length), fr = cr[cr.length - 1], fr && fr.type === "text" ? (fr.raw += `
` + ur.raw, fr.text += `
` + ur.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = fr.text) : cr.push(ur);
          continue;
        }
        if (ar) {
          const mr = "Infinite loop on byte: " + ar.charCodeAt(0);
          if (this.options.silent) {
            console.error(mr);
            break;
          } else
            throw new Error(mr);
        }
      }
    return this.state.top = !0, cr;
  }
  inline(ar, cr = []) {
    return this.inlineQueue.push({ src: ar, tokens: cr }), cr;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(ar, cr = []) {
    let ur, fr, dr, gr = ar, mr, vr, yr;
    if (this.tokens.links) {
      const kr = Object.keys(this.tokens.links);
      if (kr.length > 0)
        for (; (mr = this.tokenizer.rules.inline.reflinkSearch.exec(gr)) != null; )
          kr.includes(mr[0].slice(mr[0].lastIndexOf("[") + 1, -1)) && (gr = gr.slice(0, mr.index) + "[" + "a".repeat(mr[0].length - 2) + "]" + gr.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (mr = this.tokenizer.rules.inline.blockSkip.exec(gr)) != null; )
      gr = gr.slice(0, mr.index) + "[" + "a".repeat(mr[0].length - 2) + "]" + gr.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (mr = this.tokenizer.rules.inline.anyPunctuation.exec(gr)) != null; )
      gr = gr.slice(0, mr.index) + "++" + gr.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; ar; )
      if (vr || (yr = ""), vr = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((kr) => (ur = kr.call({ lexer: this }, ar, cr)) ? (ar = ar.substring(ur.raw.length), cr.push(ur), !0) : !1))) {
        if (ur = this.tokenizer.escape(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.tag(ar)) {
          ar = ar.substring(ur.raw.length), fr = cr[cr.length - 1], fr && ur.type === "text" && fr.type === "text" ? (fr.raw += ur.raw, fr.text += ur.text) : cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.link(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.reflink(ar, this.tokens.links)) {
          ar = ar.substring(ur.raw.length), fr = cr[cr.length - 1], fr && ur.type === "text" && fr.type === "text" ? (fr.raw += ur.raw, fr.text += ur.text) : cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.emStrong(ar, gr, yr)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.codespan(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.br(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.del(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.autolink(ar)) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (!this.state.inLink && (ur = this.tokenizer.url(ar))) {
          ar = ar.substring(ur.raw.length), cr.push(ur);
          continue;
        }
        if (dr = ar, this.options.extensions && this.options.extensions.startInline) {
          let kr = 1 / 0;
          const _r = ar.slice(1);
          let xr;
          this.options.extensions.startInline.forEach((Sr) => {
            xr = Sr.call({ lexer: this }, _r), typeof xr == "number" && xr >= 0 && (kr = Math.min(kr, xr));
          }), kr < 1 / 0 && kr >= 0 && (dr = ar.substring(0, kr + 1));
        }
        if (ur = this.tokenizer.inlineText(dr)) {
          ar = ar.substring(ur.raw.length), ur.raw.slice(-1) !== "_" && (yr = ur.raw.slice(-1)), vr = !0, fr = cr[cr.length - 1], fr && fr.type === "text" ? (fr.raw += ur.raw, fr.text += ur.text) : cr.push(ur);
          continue;
        }
        if (ar) {
          const kr = "Infinite loop on byte: " + ar.charCodeAt(0);
          if (this.options.silent) {
            console.error(kr);
            break;
          } else
            throw new Error(kr);
        }
      }
    return cr;
  }
}
class _Renderer {
  constructor(ar) {
    ji(this, "options");
    this.options = ar || _defaults;
  }
  code(ar, cr, ur) {
    var dr;
    const fr = (dr = (cr || "").match(/^\S*/)) == null ? void 0 : dr[0];
    return ar = ar.replace(/\n$/, "") + `
`, fr ? '<pre><code class="language-' + escape$1(fr) + '">' + (ur ? ar : escape$1(ar, !0)) + `</code></pre>
` : "<pre><code>" + (ur ? ar : escape$1(ar, !0)) + `</code></pre>
`;
  }
  blockquote(ar) {
    return `<blockquote>
${ar}</blockquote>
`;
  }
  html(ar, cr) {
    return ar;
  }
  heading(ar, cr, ur) {
    return `<h${cr}>${ar}</h${cr}>
`;
  }
  hr() {
    return `<hr>
`;
  }
  list(ar, cr, ur) {
    const fr = cr ? "ol" : "ul", dr = cr && ur !== 1 ? ' start="' + ur + '"' : "";
    return "<" + fr + dr + `>
` + ar + "</" + fr + `>
`;
  }
  listitem(ar, cr, ur) {
    return `<li>${ar}</li>
`;
  }
  checkbox(ar) {
    return "<input " + (ar ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(ar) {
    return `<p>${ar}</p>
`;
  }
  table(ar, cr) {
    return cr && (cr = `<tbody>${cr}</tbody>`), `<table>
<thead>
` + ar + `</thead>
` + cr + `</table>
`;
  }
  tablerow(ar) {
    return `<tr>
${ar}</tr>
`;
  }
  tablecell(ar, cr) {
    const ur = cr.header ? "th" : "td";
    return (cr.align ? `<${ur} align="${cr.align}">` : `<${ur}>`) + ar + `</${ur}>
`;
  }
  /**
   * span level renderer
   */
  strong(ar) {
    return `<strong>${ar}</strong>`;
  }
  em(ar) {
    return `<em>${ar}</em>`;
  }
  codespan(ar) {
    return `<code>${ar}</code>`;
  }
  br() {
    return "<br>";
  }
  del(ar) {
    return `<del>${ar}</del>`;
  }
  link(ar, cr, ur) {
    const fr = cleanUrl(ar);
    if (fr === null)
      return ur;
    ar = fr;
    let dr = '<a href="' + ar + '"';
    return cr && (dr += ' title="' + cr + '"'), dr += ">" + ur + "</a>", dr;
  }
  image(ar, cr, ur) {
    const fr = cleanUrl(ar);
    if (fr === null)
      return ur;
    ar = fr;
    let dr = `<img src="${ar}" alt="${ur}"`;
    return cr && (dr += ` title="${cr}"`), dr += ">", dr;
  }
  text(ar) {
    return ar;
  }
}
class _TextRenderer {
  // no need for block level renderers
  strong(ar) {
    return ar;
  }
  em(ar) {
    return ar;
  }
  codespan(ar) {
    return ar;
  }
  del(ar) {
    return ar;
  }
  html(ar) {
    return ar;
  }
  text(ar) {
    return ar;
  }
  link(ar, cr, ur) {
    return "" + ur;
  }
  image(ar, cr, ur) {
    return "" + ur;
  }
  br() {
    return "";
  }
}
class _Parser {
  constructor(ar) {
    ji(this, "options");
    ji(this, "renderer");
    ji(this, "textRenderer");
    this.options = ar || _defaults, this.options.renderer = this.options.renderer || new _Renderer(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(ar, cr) {
    return new _Parser(cr).parse(ar);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(ar, cr) {
    return new _Parser(cr).parseInline(ar);
  }
  /**
   * Parse Loop
   */
  parse(ar, cr = !0) {
    let ur = "";
    for (let fr = 0; fr < ar.length; fr++) {
      const dr = ar[fr];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[dr.type]) {
        const gr = dr, mr = this.options.extensions.renderers[gr.type].call({ parser: this }, gr);
        if (mr !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(gr.type)) {
          ur += mr || "";
          continue;
        }
      }
      switch (dr.type) {
        case "space":
          continue;
        case "hr": {
          ur += this.renderer.hr();
          continue;
        }
        case "heading": {
          const gr = dr;
          ur += this.renderer.heading(this.parseInline(gr.tokens), gr.depth, unescape$1(this.parseInline(gr.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const gr = dr;
          ur += this.renderer.code(gr.text, gr.lang, !!gr.escaped);
          continue;
        }
        case "table": {
          const gr = dr;
          let mr = "", vr = "";
          for (let kr = 0; kr < gr.header.length; kr++)
            vr += this.renderer.tablecell(this.parseInline(gr.header[kr].tokens), { header: !0, align: gr.align[kr] });
          mr += this.renderer.tablerow(vr);
          let yr = "";
          for (let kr = 0; kr < gr.rows.length; kr++) {
            const _r = gr.rows[kr];
            vr = "";
            for (let xr = 0; xr < _r.length; xr++)
              vr += this.renderer.tablecell(this.parseInline(_r[xr].tokens), { header: !1, align: gr.align[xr] });
            yr += this.renderer.tablerow(vr);
          }
          ur += this.renderer.table(mr, yr);
          continue;
        }
        case "blockquote": {
          const gr = dr, mr = this.parse(gr.tokens);
          ur += this.renderer.blockquote(mr);
          continue;
        }
        case "list": {
          const gr = dr, mr = gr.ordered, vr = gr.start, yr = gr.loose;
          let kr = "";
          for (let _r = 0; _r < gr.items.length; _r++) {
            const xr = gr.items[_r], Sr = xr.checked, Er = xr.task;
            let Cr = "";
            if (xr.task) {
              const Tr = this.renderer.checkbox(!!Sr);
              yr ? xr.tokens.length > 0 && xr.tokens[0].type === "paragraph" ? (xr.tokens[0].text = Tr + " " + xr.tokens[0].text, xr.tokens[0].tokens && xr.tokens[0].tokens.length > 0 && xr.tokens[0].tokens[0].type === "text" && (xr.tokens[0].tokens[0].text = Tr + " " + xr.tokens[0].tokens[0].text)) : xr.tokens.unshift({
                type: "text",
                text: Tr + " "
              }) : Cr += Tr + " ";
            }
            Cr += this.parse(xr.tokens, yr), kr += this.renderer.listitem(Cr, Er, !!Sr);
          }
          ur += this.renderer.list(kr, mr, vr);
          continue;
        }
        case "html": {
          const gr = dr;
          ur += this.renderer.html(gr.text, gr.block);
          continue;
        }
        case "paragraph": {
          const gr = dr;
          ur += this.renderer.paragraph(this.parseInline(gr.tokens));
          continue;
        }
        case "text": {
          let gr = dr, mr = gr.tokens ? this.parseInline(gr.tokens) : gr.text;
          for (; fr + 1 < ar.length && ar[fr + 1].type === "text"; )
            gr = ar[++fr], mr += `
` + (gr.tokens ? this.parseInline(gr.tokens) : gr.text);
          ur += cr ? this.renderer.paragraph(mr) : mr;
          continue;
        }
        default: {
          const gr = 'Token with "' + dr.type + '" type was not found.';
          if (this.options.silent)
            return console.error(gr), "";
          throw new Error(gr);
        }
      }
    }
    return ur;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(ar, cr) {
    cr = cr || this.renderer;
    let ur = "";
    for (let fr = 0; fr < ar.length; fr++) {
      const dr = ar[fr];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[dr.type]) {
        const gr = this.options.extensions.renderers[dr.type].call({ parser: this }, dr);
        if (gr !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(dr.type)) {
          ur += gr || "";
          continue;
        }
      }
      switch (dr.type) {
        case "escape": {
          const gr = dr;
          ur += cr.text(gr.text);
          break;
        }
        case "html": {
          const gr = dr;
          ur += cr.html(gr.text);
          break;
        }
        case "link": {
          const gr = dr;
          ur += cr.link(gr.href, gr.title, this.parseInline(gr.tokens, cr));
          break;
        }
        case "image": {
          const gr = dr;
          ur += cr.image(gr.href, gr.title, gr.text);
          break;
        }
        case "strong": {
          const gr = dr;
          ur += cr.strong(this.parseInline(gr.tokens, cr));
          break;
        }
        case "em": {
          const gr = dr;
          ur += cr.em(this.parseInline(gr.tokens, cr));
          break;
        }
        case "codespan": {
          const gr = dr;
          ur += cr.codespan(gr.text);
          break;
        }
        case "br": {
          ur += cr.br();
          break;
        }
        case "del": {
          const gr = dr;
          ur += cr.del(this.parseInline(gr.tokens, cr));
          break;
        }
        case "text": {
          const gr = dr;
          ur += cr.text(gr.text);
          break;
        }
        default: {
          const gr = 'Token with "' + dr.type + '" type was not found.';
          if (this.options.silent)
            return console.error(gr), "";
          throw new Error(gr);
        }
      }
    }
    return ur;
  }
}
class _Hooks {
  constructor(ar) {
    ji(this, "options");
    this.options = ar || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(ar) {
    return ar;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(ar) {
    return ar;
  }
}
ji(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
var Pl, Yu, Ic, Cd;
class Marked {
  constructor(...ar) {
    zo(this, Pl);
    zo(this, Ic);
    ji(this, "defaults", _getDefaults());
    ji(this, "options", this.setOptions);
    ji(this, "parse", go(this, Pl, Yu).call(this, _Lexer.lex, _Parser.parse));
    ji(this, "parseInline", go(this, Pl, Yu).call(this, _Lexer.lexInline, _Parser.parseInline));
    ji(this, "Parser", _Parser);
    ji(this, "Renderer", _Renderer);
    ji(this, "TextRenderer", _TextRenderer);
    ji(this, "Lexer", _Lexer);
    ji(this, "Tokenizer", _Tokenizer);
    ji(this, "Hooks", _Hooks);
    this.use(...ar);
  }
  /**
   * Run callback for every token
   */
  walkTokens(ar, cr) {
    var fr, dr;
    let ur = [];
    for (const gr of ar)
      switch (ur = ur.concat(cr.call(this, gr)), gr.type) {
        case "table": {
          const mr = gr;
          for (const vr of mr.header)
            ur = ur.concat(this.walkTokens(vr.tokens, cr));
          for (const vr of mr.rows)
            for (const yr of vr)
              ur = ur.concat(this.walkTokens(yr.tokens, cr));
          break;
        }
        case "list": {
          const mr = gr;
          ur = ur.concat(this.walkTokens(mr.items, cr));
          break;
        }
        default: {
          const mr = gr;
          (dr = (fr = this.defaults.extensions) == null ? void 0 : fr.childTokens) != null && dr[mr.type] ? this.defaults.extensions.childTokens[mr.type].forEach((vr) => {
            ur = ur.concat(this.walkTokens(mr[vr], cr));
          }) : mr.tokens && (ur = ur.concat(this.walkTokens(mr.tokens, cr)));
        }
      }
    return ur;
  }
  use(...ar) {
    const cr = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return ar.forEach((ur) => {
      const fr = { ...ur };
      if (fr.async = this.defaults.async || fr.async || !1, ur.extensions && (ur.extensions.forEach((dr) => {
        if (!dr.name)
          throw new Error("extension name required");
        if ("renderer" in dr) {
          const gr = cr.renderers[dr.name];
          gr ? cr.renderers[dr.name] = function(...mr) {
            let vr = dr.renderer.apply(this, mr);
            return vr === !1 && (vr = gr.apply(this, mr)), vr;
          } : cr.renderers[dr.name] = dr.renderer;
        }
        if ("tokenizer" in dr) {
          if (!dr.level || dr.level !== "block" && dr.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const gr = cr[dr.level];
          gr ? gr.unshift(dr.tokenizer) : cr[dr.level] = [dr.tokenizer], dr.start && (dr.level === "block" ? cr.startBlock ? cr.startBlock.push(dr.start) : cr.startBlock = [dr.start] : dr.level === "inline" && (cr.startInline ? cr.startInline.push(dr.start) : cr.startInline = [dr.start]));
        }
        "childTokens" in dr && dr.childTokens && (cr.childTokens[dr.name] = dr.childTokens);
      }), fr.extensions = cr), ur.renderer) {
        const dr = this.defaults.renderer || new _Renderer(this.defaults);
        for (const gr in ur.renderer) {
          if (!(gr in dr) || gr === "options")
            throw new Error(`renderer '${gr}' does not exist`);
          const mr = gr, vr = ur.renderer[mr], yr = dr[mr];
          dr[mr] = (...kr) => {
            let _r = vr.apply(dr, kr);
            return _r === !1 && (_r = yr.apply(dr, kr)), _r || "";
          };
        }
        fr.renderer = dr;
      }
      if (ur.tokenizer) {
        const dr = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const gr in ur.tokenizer) {
          if (!(gr in dr) || ["options", "rules", "lexer"].includes(gr))
            throw new Error(`tokenizer '${gr}' does not exist`);
          const mr = gr, vr = ur.tokenizer[mr], yr = dr[mr];
          dr[mr] = (...kr) => {
            let _r = vr.apply(dr, kr);
            return _r === !1 && (_r = yr.apply(dr, kr)), _r;
          };
        }
        fr.tokenizer = dr;
      }
      if (ur.hooks) {
        const dr = this.defaults.hooks || new _Hooks();
        for (const gr in ur.hooks) {
          if (!(gr in dr) || gr === "options")
            throw new Error(`hook '${gr}' does not exist`);
          const mr = gr, vr = ur.hooks[mr], yr = dr[mr];
          _Hooks.passThroughHooks.has(gr) ? dr[mr] = (kr) => {
            if (this.defaults.async)
              return Promise.resolve(vr.call(dr, kr)).then((xr) => yr.call(dr, xr));
            const _r = vr.call(dr, kr);
            return yr.call(dr, _r);
          } : dr[mr] = (...kr) => {
            let _r = vr.apply(dr, kr);
            return _r === !1 && (_r = yr.apply(dr, kr)), _r;
          };
        }
        fr.hooks = dr;
      }
      if (ur.walkTokens) {
        const dr = this.defaults.walkTokens, gr = ur.walkTokens;
        fr.walkTokens = function(mr) {
          let vr = [];
          return vr.push(gr.call(this, mr)), dr && (vr = vr.concat(dr.call(this, mr))), vr;
        };
      }
      this.defaults = { ...this.defaults, ...fr };
    }), this;
  }
  setOptions(ar) {
    return this.defaults = { ...this.defaults, ...ar }, this;
  }
  lexer(ar, cr) {
    return _Lexer.lex(ar, cr != null ? cr : this.defaults);
  }
  parser(ar, cr) {
    return _Parser.parse(ar, cr != null ? cr : this.defaults);
  }
}
Pl = new WeakSet(), Yu = function(ar, cr) {
  return (ur, fr) => {
    const dr = { ...fr }, gr = { ...this.defaults, ...dr };
    this.defaults.async === !0 && dr.async === !1 && (gr.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), gr.async = !0);
    const mr = go(this, Ic, Cd).call(this, !!gr.silent, !!gr.async);
    if (typeof ur == "undefined" || ur === null)
      return mr(new Error("marked(): input parameter is undefined or null"));
    if (typeof ur != "string")
      return mr(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(ur) + ", string expected"));
    if (gr.hooks && (gr.hooks.options = gr), gr.async)
      return Promise.resolve(gr.hooks ? gr.hooks.preprocess(ur) : ur).then((vr) => ar(vr, gr)).then((vr) => gr.walkTokens ? Promise.all(this.walkTokens(vr, gr.walkTokens)).then(() => vr) : vr).then((vr) => cr(vr, gr)).then((vr) => gr.hooks ? gr.hooks.postprocess(vr) : vr).catch(mr);
    try {
      gr.hooks && (ur = gr.hooks.preprocess(ur));
      const vr = ar(ur, gr);
      gr.walkTokens && this.walkTokens(vr, gr.walkTokens);
      let yr = cr(vr, gr);
      return gr.hooks && (yr = gr.hooks.postprocess(yr)), yr;
    } catch (vr) {
      return mr(vr);
    }
  };
}, Ic = new WeakSet(), Cd = function(ar, cr) {
  return (ur) => {
    if (ur.message += `
Please report this to https://github.com/markedjs/marked.`, ar) {
      const fr = "<p>An error occurred:</p><pre>" + escape$1(ur.message + "", !0) + "</pre>";
      return cr ? Promise.resolve(fr) : fr;
    }
    if (cr)
      return Promise.reject(ur);
    throw ur;
  };
};
const markedInstance = new Marked();
function marked(lr, ar) {
  return markedInstance.parse(lr, ar);
}
marked.options = marked.setOptions = function(lr) {
  return markedInstance.setOptions(lr), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...lr) {
  return markedInstance.use(...lr), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.walkTokens = function(lr, ar) {
  return markedInstance.walkTokens(lr, ar);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
function add_css$8(lr) {
  append_styles(lr, "svelte-1qh4vd6", ".preview-container.svelte-1qh4vd6{position:relative;width:150px;height:150px;border-radius:10px;overflow:hidden;box-shadow:0 4px 8px rgba(0, 0, 0, 0.1)}.preview-image.svelte-1qh4vd6{width:100%;height:100%;display:block;border-radius:10px}.delete-button.svelte-1qh4vd6{position:absolute;top:10px;right:10px;background-color:transparent;border:none;border-radius:50%;color:white;cursor:pointer}");
}
function create_if_block$2(lr) {
  let ar, cr, ur, fr, dr, gr;
  return {
    c() {
      ar = element("img"), ur = space(), fr = element("button"), fr.textContent = "X", attr(ar, "class", "preview-image svelte-1qh4vd6"), src_url_equal(ar.src, cr = /*dataUrl*/
      lr[0]) || attr(ar, "src", cr), attr(ar, "alt", "Uploaded file preview"), attr(fr, "class", "delete-button svelte-1qh4vd6");
    },
    m(mr, vr) {
      insert(mr, ar, vr), insert(mr, ur, vr), insert(mr, fr, vr), dr || (gr = listen(
        fr,
        "click",
        /*handleDelete*/
        lr[1]
      ), dr = !0);
    },
    p(mr, vr) {
      vr & /*dataUrl*/
      1 && !src_url_equal(ar.src, cr = /*dataUrl*/
      mr[0]) && attr(ar, "src", cr);
    },
    d(mr) {
      mr && (detach(ar), detach(ur), detach(fr)), dr = !1, gr();
    }
  };
}
function create_fragment$a(lr) {
  let ar, cr = (
    /*dataUrl*/
    lr[0] && create_if_block$2(lr)
  );
  return {
    c() {
      ar = element("div"), cr && cr.c(), attr(ar, "class", "preview-container svelte-1qh4vd6");
    },
    m(ur, fr) {
      insert(ur, ar, fr), cr && cr.m(ar, null);
    },
    p(ur, [fr]) {
      /*dataUrl*/
      ur[0] ? cr ? cr.p(ur, fr) : (cr = create_if_block$2(ur), cr.c(), cr.m(ar, null)) : cr && (cr.d(1), cr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), cr && cr.d();
    }
  };
}
function instance$8(lr, ar, cr) {
  let { file: ur } = ar, { onDelete: fr } = ar, dr = "";
  const gr = new FileReader();
  gr.onload = (vr) => {
    var yr;
    typeof ((yr = vr == null ? void 0 : vr.target) == null ? void 0 : yr.result) == "string" && cr(0, dr = vr.target.result);
  }, ur && gr.readAsDataURL(ur);
  const mr = () => {
    fr(ur);
  };
  return lr.$$set = (vr) => {
    "file" in vr && cr(2, ur = vr.file), "onDelete" in vr && cr(3, fr = vr.onDelete);
  }, [dr, mr, ur, fr];
}
class FilePreview extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$8, create_fragment$a, safe_not_equal, { file: 2, onDelete: 3 }, add_css$8);
  }
  get file() {
    return this.$$.ctx[2];
  }
  set file(ar) {
    this.$$set({ file: ar }), flush();
  }
  get onDelete() {
    return this.$$.ctx[3];
  }
  set onDelete(ar) {
    this.$$set({ onDelete: ar }), flush();
  }
}
create_custom_element(FilePreview, { file: {}, onDelete: {} }, [], [], !0);
function create_fragment$9(lr) {
  let ar, cr, ur, fr;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("path"), ur = svg_element("path"), fr = svg_element("path"), attr(cr, "d", "M455.111 284.444H512v682.667h-56.889z"), attr(cr, "fill", "#73777A"), attr(ur, "d", "M113.778 113.778h739.555v682.666H625.778v56.89h284.444V56.888H56.89v796.444h284.444v-56.889H113.778z"), attr(ur, "fill", "#73777A"), attr(fr, "d", "M284.444 415.289l39.823 39.822L483.556 307.2l159.288 147.911 39.823-39.822-199.111-187.733z"), attr(fr, "fill", "#73777A"), set_style(ar, "width", "50"), set_style(ar, "height", "30"), set_style(ar, "fill", "currentColor"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "version", "1.1"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, gr) {
      insert(dr, ar, gr), append(ar, cr), append(ar, ur), append(ar, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class UploadButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$9, safe_not_equal, {});
  }
}
create_custom_element(UploadButton, {}, [], [], !0);
function add_css$7(lr) {
  append_styles(lr, "svelte-y5sskm", ".file-input.svelte-y5sskm{display:none}.upload-button.svelte-y5sskm{background:none;border:none;background-color:transparent;cursor:pointer}");
}
function create_fragment$8(lr) {
  let ar, cr, ur, fr, dr, gr, mr;
  return fr = new UploadButton({}), {
    c() {
      ar = element("input"), cr = space(), ur = element("button"), create_component(fr.$$.fragment), attr(ar, "type", "file"), attr(ar, "class", "file-input svelte-y5sskm"), attr(ar, "accept", "image/*"), attr(ur, "class", "upload-button svelte-y5sskm");
    },
    m(vr, yr) {
      insert(vr, ar, yr), lr[4](ar), insert(vr, cr, yr), insert(vr, ur, yr), mount_component(fr, ur, null), dr = !0, gr || (mr = [
        listen(
          ar,
          "change",
          /*handleChange*/
          lr[1]
        ),
        listen(ur, "click", prevent_default(
          /*click_handler*/
          lr[5]
        ))
      ], gr = !0);
    },
    p: noop$1,
    i(vr) {
      dr || (transition_in(fr.$$.fragment, vr), dr = !0);
    },
    o(vr) {
      transition_out(fr.$$.fragment, vr), dr = !1;
    },
    d(vr) {
      vr && (detach(ar), detach(cr), detach(ur)), lr[4](null), destroy_component(fr), gr = !1, run_all(mr);
    }
  };
}
const FILE_EXT_REGEX = /\.([\w]{1,7})$/i;
function instance$7(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkStore, (Er) => cr(6, ur = Er)), component_subscribe(lr, localStore, (Er) => cr(7, fr = Er));
  let dr, gr, { fileArray: mr = [] } = ar, { opinionContent: vr } = ar;
  const yr = uploadUrl, kr = new distExports.VoidApi(yr), _r = async (Er) => {
    var Tr, Ar, Ir, Mr, Hr, Br;
    const Cr = Er.target;
    if (!Cr.files) {
      console.log("Files array is empty");
      return;
    }
    for (gr of Cr.files) {
      const zr = fr.pk;
      zr ? !ur.signer && await privkeyLogin(zr) : !ur.signer && await NDKlogin();
      const Xr = await kr.getUploader(gr).upload({ "V-Strip-Metadata": "true" });
      if (Xr.ok) {
        let Jr = gr.name.match(FILE_EXT_REGEX);
        ((Ar = (Tr = Xr.file) == null ? void 0 : Tr.metadata) == null ? void 0 : Ar.mimeType) === "image/webp" && (Jr = ["", "webp"]);
        const li = (Br = (Mr = (Ir = Xr.file) == null ? void 0 : Ir.metadata) == null ? void 0 : Mr.url) != null ? Br : `${yr}/d/${(Hr = Xr.file) == null ? void 0 : Hr.id}${Jr ? `.${Jr[1]}` : ""}`;
        cr(2, mr = [...mr, { files: gr, url: li }]), cr(3, vr = vr + " " + li);
      }
    }
  };
  function xr(Er) {
    binding_callbacks[Er ? "unshift" : "push"](() => {
      dr = Er, cr(0, dr);
    });
  }
  const Sr = () => dr.click();
  return lr.$$set = (Er) => {
    "fileArray" in Er && cr(2, mr = Er.fileArray), "opinionContent" in Er && cr(3, vr = Er.opinionContent);
  }, [
    dr,
    _r,
    mr,
    vr,
    xr,
    Sr
  ];
}
class Upload extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$7, create_fragment$8, safe_not_equal, { fileArray: 2, opinionContent: 3 }, add_css$7);
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[3];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(Upload, { fileArray: {}, opinionContent: {} }, [], [], !0);
function create_fragment$7(lr) {
  let ar, cr, ur;
  return {
    c() {
      ar = svg_element("svg"), cr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", `M967.111 227.556H739.556V56.889H284.444v170.667H56.89v56.888h113.778v682.667h682.666V284.444h113.778v-56.888zM341.333 113.778h341.334v113.778H341.333V113.778z m455.111 796.444H227.556V284.444h568.888v625.778z
    M398.222 341.333h56.89v512h-56.89z m170.667 0h56.889v512h-56.89z`), attr(ur, "fill", "#73777A"), attr(cr, "opacity", "1"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "fill", "currentColor"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, dr) {
      insert(fr, ar, dr), append(ar, cr), append(cr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class DeleteButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$7, safe_not_equal, {});
  }
}
create_custom_element(DeleteButton, {}, [], [], !0);
function add_css$6(lr) {
  append_styles(lr, "svelte-1nsksb0", ".card-button.svelte-1nsksb0.svelte-1nsksb0{display:inline-flex;align-items:center;gap:2px}.card-button.svelte-1nsksb0 button.svelte-1nsksb0{background:none;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}");
}
function create_fragment$6(lr) {
  let ar, cr, ur, fr, dr, gr;
  return ur = new DeleteButton({}), {
    c() {
      ar = element("div"), cr = element("button"), create_component(ur.$$.fragment), attr(cr, "class", "svelte-1nsksb0"), attr(ar, "class", "card-button svelte-1nsksb0");
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, cr), mount_component(ur, cr, null), fr = !0, dr || (gr = listen(
        cr,
        "click",
        /*click_handler*/
        lr[4]
      ), dr = !0);
    },
    p: noop$1,
    i(mr) {
      fr || (transition_in(ur.$$.fragment, mr), fr = !0);
    },
    o(mr) {
      transition_out(ur.$$.fragment, mr), fr = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_component(ur), dr = !1, gr();
    }
  };
}
function instance$6(lr, ar, cr) {
  let ur, fr;
  component_subscribe(lr, ndkStore, (kr) => cr(5, ur = kr)), component_subscribe(lr, localStore, (kr) => cr(6, fr = kr));
  let { eventID: dr } = ar, { isDeleted: gr } = ar, { count: mr } = ar;
  async function vr(kr) {
    try {
      const _r = fr.pk;
      _r ? !ur.signer && await privkeyLogin(_r) : !ur.signer && await NDKlogin();
      const xr = await ur.fetchEvent({ ids: [kr] });
      await db.events.delete(kr), await (xr == null ? void 0 : xr.delete()), cr(2, gr = !0), cr(3, mr = mr == 0 ? 0 : mr - 1);
    } catch (_r) {
      console.log("Error: ", _r);
    }
  }
  const yr = () => vr(dr);
  return lr.$$set = (kr) => {
    "eventID" in kr && cr(0, dr = kr.eventID), "isDeleted" in kr && cr(2, gr = kr.isDeleted), "count" in kr && cr(3, mr = kr.count);
  }, [dr, vr, gr, mr, yr];
}
class DeleteEventData extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$6, create_fragment$6, safe_not_equal, { eventID: 0, isDeleted: 2, count: 3 }, add_css$6);
  }
  get eventID() {
    return this.$$.ctx[0];
  }
  set eventID(ar) {
    this.$$set({ eventID: ar }), flush();
  }
  get isDeleted() {
    return this.$$.ctx[2];
  }
  set isDeleted(ar) {
    this.$$set({ isDeleted: ar }), flush();
  }
  get count() {
    return this.$$.ctx[3];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
}
create_custom_element(DeleteEventData, { eventID: {}, isDeleted: {}, count: {} }, [], [], !0);
function add_css$5(lr) {
  append_styles(lr, "svelte-1819t8t", `.textarea-style.svelte-1819t8t{width:100%;min-height:200px;background-color:#f8f8f8;color:#333;border:1px solid #ccc;border-radius:4px;padding:10px;font-family:'Arial', sans-serif;font-size:16px;line-height:1.5;resize:vertical;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);transition:border-color 0.3s,
			box-shadow 0.3s}.dark.svelte-1819t8t{background-color:black;color:white}`);
}
function create_fragment$5(lr) {
  let ar, cr, ur, fr, dr;
  return {
    c() {
      ar = element("textarea"), attr(ar, "class", "textarea-style svelte-1819t8t"), ar.value = "", toggle_class(
        ar,
        "dark",
        /*$theme*/
        lr[1] === "dark"
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), lr[4](ar), ur = !0, fr || (dr = listen(
        ar,
        "input",
        /*updateContent*/
        lr[2]
      ), fr = !0);
    },
    p(gr, [mr]) {
      (!ur || mr & /*$theme*/
      2) && toggle_class(
        ar,
        "dark",
        /*$theme*/
        gr[1] === "dark"
      );
    },
    i(gr) {
      ur || (gr && add_render_callback(() => {
        ur && (cr || (cr = create_bidirectional_transition(ar, slide, {}, !0)), cr.run(1));
      }), ur = !0);
    },
    o(gr) {
      gr && (cr || (cr = create_bidirectional_transition(ar, slide, {}, !1)), cr.run(0)), ur = !1;
    },
    d(gr) {
      gr && detach(ar), lr[4](null), gr && cr && cr.end(), fr = !1, dr();
    }
  };
}
function instance$5(lr, ar, cr) {
  let ur;
  component_subscribe(lr, theme, (vr) => cr(1, ur = vr));
  let fr, { opinionContent: dr } = ar;
  const gr = () => {
    cr(3, dr = fr.value);
  };
  onMount(() => {
    cr(0, fr.value = dr, fr);
  });
  function mr(vr) {
    binding_callbacks[vr ? "unshift" : "push"](() => {
      fr = vr, cr(0, fr), cr(3, dr);
    });
  }
  return lr.$$set = (vr) => {
    "opinionContent" in vr && cr(3, dr = vr.opinionContent);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*textarea, opinionContent*/
    9 && fr && cr(0, fr.value = dr, fr);
  }, [fr, ur, gr, dr, mr];
}
class TextArea extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$5, create_fragment$5, safe_not_equal, { opinionContent: 3 }, add_css$5);
  }
  get opinionContent() {
    return this.$$.ctx[3];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(TextArea, { opinionContent: {} }, [], [], !0);
/*! @license DOMPurify 3.0.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.8/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object, {
  apply,
  construct
} = typeof Reflect != "undefined" && Reflect;
freeze || (freeze = function(ar) {
  return ar;
});
seal || (seal = function(ar) {
  return ar;
});
apply || (apply = function(ar, cr, ur) {
  return ar.apply(cr, ur);
});
construct || (construct = function(ar, cr) {
  return new ar(...cr);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(lr) {
  return function(ar) {
    for (var cr = arguments.length, ur = new Array(cr > 1 ? cr - 1 : 0), fr = 1; fr < cr; fr++)
      ur[fr - 1] = arguments[fr];
    return apply(lr, ar, ur);
  };
}
function unconstruct(lr) {
  return function() {
    for (var ar = arguments.length, cr = new Array(ar), ur = 0; ur < ar; ur++)
      cr[ur] = arguments[ur];
    return construct(lr, cr);
  };
}
function addToSet(lr, ar) {
  let cr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(lr, null);
  let ur = ar.length;
  for (; ur--; ) {
    let fr = ar[ur];
    if (typeof fr == "string") {
      const dr = cr(fr);
      dr !== fr && (isFrozen(ar) || (ar[ur] = dr), fr = dr);
    }
    lr[fr] = !0;
  }
  return lr;
}
function cleanArray(lr) {
  for (let ar = 0; ar < lr.length; ar++)
    getOwnPropertyDescriptor(lr, ar) === void 0 && (lr[ar] = null);
  return lr;
}
function clone(lr) {
  const ar = create(null);
  for (const [cr, ur] of entries(lr))
    getOwnPropertyDescriptor(lr, cr) !== void 0 && (Array.isArray(ur) ? ar[cr] = cleanArray(ur) : ur && typeof ur == "object" && ur.constructor === Object ? ar[cr] = clone(ur) : ar[cr] = ur);
  return ar;
}
function lookupGetter(lr, ar) {
  for (; lr !== null; ) {
    const ur = getOwnPropertyDescriptor(lr, ar);
    if (ur) {
      if (ur.get)
        return unapply(ur.get);
      if (typeof ur.value == "function")
        return unapply(ur.value);
    }
    lr = getPrototypeOf(lr);
  }
  function cr(ur) {
    return console.warn("fallback value for", ur), null;
  }
  return cr;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = function lr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy = function lr(ar, cr) {
  if (typeof ar != "object" || typeof ar.createPolicy != "function")
    return null;
  let ur = null;
  const fr = "data-tt-policy-suffix";
  cr && cr.hasAttribute(fr) && (ur = cr.getAttribute(fr));
  const dr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(dr, {
      createHTML(gr) {
        return gr;
      },
      createScriptURL(gr) {
        return gr;
      }
    });
  } catch (gr) {
    return console.warn("TrustedTypes policy " + dr + " could not be created."), null;
  }
};
function createDOMPurify() {
  let lr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const ar = (Ur) => createDOMPurify(Ur);
  if (ar.version = "3.0.8", ar.removed = [], !lr || !lr.document || lr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  let {
    document: cr
  } = lr;
  const ur = cr, fr = ur.currentScript, {
    DocumentFragment: dr,
    HTMLTemplateElement: gr,
    Node: mr,
    Element: vr,
    NodeFilter: yr,
    NamedNodeMap: kr = lr.NamedNodeMap || lr.MozNamedAttrMap,
    HTMLFormElement: _r,
    DOMParser: xr,
    trustedTypes: Sr
  } = lr, Er = vr.prototype, Cr = lookupGetter(Er, "cloneNode"), Tr = lookupGetter(Er, "nextSibling"), Ar = lookupGetter(Er, "childNodes"), Ir = lookupGetter(Er, "parentNode");
  if (typeof gr == "function") {
    const Ur = cr.createElement("template");
    Ur.content && Ur.content.ownerDocument && (cr = Ur.content.ownerDocument);
  }
  let Mr, Hr = "";
  const {
    implementation: Br,
    createNodeIterator: zr,
    createDocumentFragment: Gr,
    getElementsByTagName: Xr
  } = cr, {
    importNode: Jr
  } = ur;
  let li = {};
  ar.isSupported = typeof entries == "function" && typeof Ir == "function" && Br && Br.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Qr,
    ERB_EXPR: ei,
    TMPLIT_EXPR: ui,
    DATA_ATTR: Ai,
    ARIA_ATTR: fi,
    IS_SCRIPT_OR_DATA: gi,
    ATTR_WHITESPACE: Ci
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: mi
  } = EXPRESSIONS, vi = null;
  const Ri = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let di = null;
  const Ti = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let qi = Object.seal(create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), ki = null, Ji = null, Bi = !0, Ni = !0, Mi = !1, bi = !0, Ei = !1, Si = !1, Vi = !1, Di = !1, sa = !1, ra = !1, fa = !1, ba = !0, Ua = !1;
  const Va = "user-content-";
  let Ma = !0, Fi = !1, na = {}, Gi = null;
  const Ca = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let $a = null;
  const no = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let ga = null;
  const pa = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Sa = "http://www.w3.org/1998/Math/MathML", Na = "http://www.w3.org/2000/svg", Oa = "http://www.w3.org/1999/xhtml";
  let Ja = Oa, za = !1, Ia = null;
  const Yi = addToSet({}, [Sa, Na, Oa], stringToString);
  let La = null;
  const Ka = ["application/xhtml+xml", "text/html"], Qa = "text/html";
  let Hi = null, da = null;
  const aa = cr.createElement("form"), oa = function(qr) {
    return qr instanceof RegExp || qr instanceof Function;
  }, ja = function() {
    let qr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(da && da === qr)) {
      if ((!qr || typeof qr != "object") && (qr = {}), qr = clone(qr), La = // eslint-disable-next-line unicorn/prefer-includes
      Ka.indexOf(qr.PARSER_MEDIA_TYPE) === -1 ? Qa : qr.PARSER_MEDIA_TYPE, Hi = La === "application/xhtml+xml" ? stringToString : stringToLowerCase, vi = "ALLOWED_TAGS" in qr ? addToSet({}, qr.ALLOWED_TAGS, Hi) : Ri, di = "ALLOWED_ATTR" in qr ? addToSet({}, qr.ALLOWED_ATTR, Hi) : Ti, Ia = "ALLOWED_NAMESPACES" in qr ? addToSet({}, qr.ALLOWED_NAMESPACES, stringToString) : Yi, ga = "ADD_URI_SAFE_ATTR" in qr ? addToSet(
        clone(pa),
        // eslint-disable-line indent
        qr.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Hi
        // eslint-disable-line indent
      ) : pa, $a = "ADD_DATA_URI_TAGS" in qr ? addToSet(
        clone(no),
        // eslint-disable-line indent
        qr.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Hi
        // eslint-disable-line indent
      ) : no, Gi = "FORBID_CONTENTS" in qr ? addToSet({}, qr.FORBID_CONTENTS, Hi) : Ca, ki = "FORBID_TAGS" in qr ? addToSet({}, qr.FORBID_TAGS, Hi) : {}, Ji = "FORBID_ATTR" in qr ? addToSet({}, qr.FORBID_ATTR, Hi) : {}, na = "USE_PROFILES" in qr ? qr.USE_PROFILES : !1, Bi = qr.ALLOW_ARIA_ATTR !== !1, Ni = qr.ALLOW_DATA_ATTR !== !1, Mi = qr.ALLOW_UNKNOWN_PROTOCOLS || !1, bi = qr.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ei = qr.SAFE_FOR_TEMPLATES || !1, Si = qr.WHOLE_DOCUMENT || !1, sa = qr.RETURN_DOM || !1, ra = qr.RETURN_DOM_FRAGMENT || !1, fa = qr.RETURN_TRUSTED_TYPE || !1, Di = qr.FORCE_BODY || !1, ba = qr.SANITIZE_DOM !== !1, Ua = qr.SANITIZE_NAMED_PROPS || !1, Ma = qr.KEEP_CONTENT !== !1, Fi = qr.IN_PLACE || !1, mi = qr.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, Ja = qr.NAMESPACE || Oa, qi = qr.CUSTOM_ELEMENT_HANDLING || {}, qr.CUSTOM_ELEMENT_HANDLING && oa(qr.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (qi.tagNameCheck = qr.CUSTOM_ELEMENT_HANDLING.tagNameCheck), qr.CUSTOM_ELEMENT_HANDLING && oa(qr.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (qi.attributeNameCheck = qr.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), qr.CUSTOM_ELEMENT_HANDLING && typeof qr.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (qi.allowCustomizedBuiltInElements = qr.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ei && (Ni = !1), ra && (sa = !0), na && (vi = addToSet({}, text), di = [], na.html === !0 && (addToSet(vi, html$1), addToSet(di, html)), na.svg === !0 && (addToSet(vi, svg$1), addToSet(di, svg), addToSet(di, xml)), na.svgFilters === !0 && (addToSet(vi, svgFilters), addToSet(di, svg), addToSet(di, xml)), na.mathMl === !0 && (addToSet(vi, mathMl$1), addToSet(di, mathMl), addToSet(di, xml))), qr.ADD_TAGS && (vi === Ri && (vi = clone(vi)), addToSet(vi, qr.ADD_TAGS, Hi)), qr.ADD_ATTR && (di === Ti && (di = clone(di)), addToSet(di, qr.ADD_ATTR, Hi)), qr.ADD_URI_SAFE_ATTR && addToSet(ga, qr.ADD_URI_SAFE_ATTR, Hi), qr.FORBID_CONTENTS && (Gi === Ca && (Gi = clone(Gi)), addToSet(Gi, qr.FORBID_CONTENTS, Hi)), Ma && (vi["#text"] = !0), Si && addToSet(vi, ["html", "head", "body"]), vi.table && (addToSet(vi, ["tbody"]), delete ki.tbody), qr.TRUSTED_TYPES_POLICY) {
        if (typeof qr.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof qr.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        Mr = qr.TRUSTED_TYPES_POLICY, Hr = Mr.createHTML("");
      } else
        Mr === void 0 && (Mr = _createTrustedTypesPolicy(Sr, fr)), Mr !== null && typeof Hr == "string" && (Hr = Mr.createHTML(""));
      freeze && freeze(qr), da = qr;
    }
  }, Ga = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), xa = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]), qa = addToSet({}, ["title", "style", "font", "a", "script"]), Ya = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), Za = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), ko = function(qr) {
    let Yr = Ir(qr);
    (!Yr || !Yr.tagName) && (Yr = {
      namespaceURI: Ja,
      tagName: "template"
    });
    const si = stringToLowerCase(qr.tagName), yi = stringToLowerCase(Yr.tagName);
    return Ia[qr.namespaceURI] ? qr.namespaceURI === Na ? Yr.namespaceURI === Oa ? si === "svg" : Yr.namespaceURI === Sa ? si === "svg" && (yi === "annotation-xml" || Ga[yi]) : !!Ya[si] : qr.namespaceURI === Sa ? Yr.namespaceURI === Oa ? si === "math" : Yr.namespaceURI === Na ? si === "math" && xa[yi] : !!Za[si] : qr.namespaceURI === Oa ? Yr.namespaceURI === Na && !xa[yi] || Yr.namespaceURI === Sa && !Ga[yi] ? !1 : !Za[si] && (qa[si] || !Ya[si]) : !!(La === "application/xhtml+xml" && Ia[qr.namespaceURI]) : !1;
  }, lo = function(qr) {
    arrayPush(ar.removed, {
      element: qr
    });
    try {
      qr.parentNode.removeChild(qr);
    } catch (Yr) {
      qr.remove();
    }
  }, so = function(qr, Yr) {
    try {
      arrayPush(ar.removed, {
        attribute: Yr.getAttributeNode(qr),
        from: Yr
      });
    } catch (si) {
      arrayPush(ar.removed, {
        attribute: null,
        from: Yr
      });
    }
    if (Yr.removeAttribute(qr), qr === "is" && !di[qr])
      if (sa || ra)
        try {
          lo(Yr);
        } catch (si) {
        }
      else
        try {
          Yr.setAttribute(qr, "");
        } catch (si) {
        }
  }, ho = function(qr) {
    let Yr = null, si = null;
    if (Di)
      qr = "<remove></remove>" + qr;
    else {
      const Ki = stringMatch(qr, /^[\r\n\t ]+/);
      si = Ki && Ki[0];
    }
    La === "application/xhtml+xml" && Ja === Oa && (qr = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + qr + "</body></html>");
    const yi = Mr ? Mr.createHTML(qr) : qr;
    if (Ja === Oa)
      try {
        Yr = new xr().parseFromString(yi, La);
      } catch (Ki) {
      }
    if (!Yr || !Yr.documentElement) {
      Yr = Br.createDocument(Ja, "template", null);
      try {
        Yr.documentElement.innerHTML = za ? Hr : yi;
      } catch (Ki) {
      }
    }
    const Ii = Yr.body || Yr.documentElement;
    return qr && si && Ii.insertBefore(cr.createTextNode(si), Ii.childNodes[0] || null), Ja === Oa ? Xr.call(Yr, Si ? "html" : "body")[0] : Si ? Yr.documentElement : Ii;
  }, Ro = function(qr) {
    return zr.call(
      qr.ownerDocument || qr,
      qr,
      // eslint-disable-next-line no-bitwise
      yr.SHOW_ELEMENT | yr.SHOW_COMMENT | yr.SHOW_TEXT,
      null
    );
  }, Mo = function(qr) {
    return qr instanceof _r && (typeof qr.nodeName != "string" || typeof qr.textContent != "string" || typeof qr.removeChild != "function" || !(qr.attributes instanceof kr) || typeof qr.removeAttribute != "function" || typeof qr.setAttribute != "function" || typeof qr.namespaceURI != "string" || typeof qr.insertBefore != "function" || typeof qr.hasChildNodes != "function");
  }, Co = function(qr) {
    return typeof mr == "function" && qr instanceof mr;
  }, uo = function(qr, Yr, si) {
    li[qr] && arrayForEach(li[qr], (yi) => {
      yi.call(ar, Yr, si, da);
    });
  }, wa = function(qr) {
    let Yr = null;
    if (uo("beforeSanitizeElements", qr, null), Mo(qr))
      return lo(qr), !0;
    const si = Hi(qr.nodeName);
    if (uo("uponSanitizeElement", qr, {
      tagName: si,
      allowedTags: vi
    }), qr.hasChildNodes() && !Co(qr.firstElementChild) && regExpTest(/<[/\w]/g, qr.innerHTML) && regExpTest(/<[/\w]/g, qr.textContent))
      return lo(qr), !0;
    if (!vi[si] || ki[si]) {
      if (!ki[si] && ca(si) && (qi.tagNameCheck instanceof RegExp && regExpTest(qi.tagNameCheck, si) || qi.tagNameCheck instanceof Function && qi.tagNameCheck(si)))
        return !1;
      if (Ma && !Gi[si]) {
        const yi = Ir(qr) || qr.parentNode, Ii = Ar(qr) || qr.childNodes;
        if (Ii && yi) {
          const Ki = Ii.length;
          for (let ta = Ki - 1; ta >= 0; --ta)
            yi.insertBefore(Cr(Ii[ta], !0), Tr(qr));
        }
      }
      return lo(qr), !0;
    }
    return qr instanceof vr && !ko(qr) || (si === "noscript" || si === "noembed" || si === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, qr.innerHTML) ? (lo(qr), !0) : (Ei && qr.nodeType === 3 && (Yr = qr.textContent, arrayForEach([Qr, ei, ui], (yi) => {
      Yr = stringReplace(Yr, yi, " ");
    }), qr.textContent !== Yr && (arrayPush(ar.removed, {
      element: qr.cloneNode()
    }), qr.textContent = Yr)), uo("afterSanitizeElements", qr, null), !1);
  }, $i = function(qr, Yr, si) {
    if (ba && (Yr === "id" || Yr === "name") && (si in cr || si in aa))
      return !1;
    if (!(Ni && !Ji[Yr] && regExpTest(Ai, Yr))) {
      if (!(Bi && regExpTest(fi, Yr))) {
        if (!di[Yr] || Ji[Yr]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ca(qr) && (qi.tagNameCheck instanceof RegExp && regExpTest(qi.tagNameCheck, qr) || qi.tagNameCheck instanceof Function && qi.tagNameCheck(qr)) && (qi.attributeNameCheck instanceof RegExp && regExpTest(qi.attributeNameCheck, Yr) || qi.attributeNameCheck instanceof Function && qi.attributeNameCheck(Yr)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Yr === "is" && qi.allowCustomizedBuiltInElements && (qi.tagNameCheck instanceof RegExp && regExpTest(qi.tagNameCheck, si) || qi.tagNameCheck instanceof Function && qi.tagNameCheck(si)))
          )
            return !1;
        } else if (!ga[Yr]) {
          if (!regExpTest(mi, stringReplace(si, Ci, ""))) {
            if (!((Yr === "src" || Yr === "xlink:href" || Yr === "href") && qr !== "script" && stringIndexOf(si, "data:") === 0 && $a[qr])) {
              if (!(Mi && !regExpTest(gi, stringReplace(si, Ci, "")))) {
                if (si)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ca = function(qr) {
    return qr.indexOf("-") > 0;
  }, ci = function(qr) {
    uo("beforeSanitizeAttributes", qr, null);
    const {
      attributes: Yr
    } = qr;
    if (!Yr)
      return;
    const si = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: di
    };
    let yi = Yr.length;
    for (; yi--; ) {
      const Ii = Yr[yi], {
        name: Ki,
        namespaceURI: ta,
        value: va
      } = Ii, ua = Hi(Ki);
      let ma = Ki === "value" ? va : stringTrim(va);
      if (si.attrName = ua, si.attrValue = ma, si.keepAttr = !0, si.forceKeepAttr = void 0, uo("uponSanitizeAttribute", qr, si), ma = si.attrValue, si.forceKeepAttr || (so(Ki, qr), !si.keepAttr))
        continue;
      if (!bi && regExpTest(/\/>/i, ma)) {
        so(Ki, qr);
        continue;
      }
      Ei && arrayForEach([Qr, ei, ui], (fo) => {
        ma = stringReplace(ma, fo, " ");
      });
      const Fa = Hi(qr.nodeName);
      if ($i(Fa, ua, ma)) {
        if (Ua && (ua === "id" || ua === "name") && (so(Ki, qr), ma = Va + ma), Mr && typeof Sr == "object" && typeof Sr.getAttributeType == "function" && !ta)
          switch (Sr.getAttributeType(Fa, ua)) {
            case "TrustedHTML": {
              ma = Mr.createHTML(ma);
              break;
            }
            case "TrustedScriptURL": {
              ma = Mr.createScriptURL(ma);
              break;
            }
          }
        try {
          ta ? qr.setAttributeNS(ta, Ki, ma) : qr.setAttribute(Ki, ma), arrayPop(ar.removed);
        } catch (fo) {
        }
      }
    }
    uo("afterSanitizeAttributes", qr, null);
  }, ti = function Ur(qr) {
    let Yr = null;
    const si = Ro(qr);
    for (uo("beforeSanitizeShadowDOM", qr, null); Yr = si.nextNode(); )
      uo("uponSanitizeShadowNode", Yr, null), !wa(Yr) && (Yr.content instanceof dr && Ur(Yr.content), ci(Yr));
    uo("afterSanitizeShadowDOM", qr, null);
  };
  return ar.sanitize = function(Ur) {
    let qr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Yr = null, si = null, yi = null, Ii = null;
    if (za = !Ur, za && (Ur = "<!-->"), typeof Ur != "string" && !Co(Ur))
      if (typeof Ur.toString == "function") {
        if (Ur = Ur.toString(), typeof Ur != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!ar.isSupported)
      return Ur;
    if (Vi || ja(qr), ar.removed = [], typeof Ur == "string" && (Fi = !1), Fi) {
      if (Ur.nodeName) {
        const va = Hi(Ur.nodeName);
        if (!vi[va] || ki[va])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ur instanceof mr)
      Yr = ho("<!---->"), si = Yr.ownerDocument.importNode(Ur, !0), si.nodeType === 1 && si.nodeName === "BODY" || si.nodeName === "HTML" ? Yr = si : Yr.appendChild(si);
    else {
      if (!sa && !Ei && !Si && // eslint-disable-next-line unicorn/prefer-includes
      Ur.indexOf("<") === -1)
        return Mr && fa ? Mr.createHTML(Ur) : Ur;
      if (Yr = ho(Ur), !Yr)
        return sa ? null : fa ? Hr : "";
    }
    Yr && Di && lo(Yr.firstChild);
    const Ki = Ro(Fi ? Ur : Yr);
    for (; yi = Ki.nextNode(); )
      wa(yi) || (yi.content instanceof dr && ti(yi.content), ci(yi));
    if (Fi)
      return Ur;
    if (sa) {
      if (ra)
        for (Ii = Gr.call(Yr.ownerDocument); Yr.firstChild; )
          Ii.appendChild(Yr.firstChild);
      else
        Ii = Yr;
      return (di.shadowroot || di.shadowrootmode) && (Ii = Jr.call(ur, Ii, !0)), Ii;
    }
    let ta = Si ? Yr.outerHTML : Yr.innerHTML;
    return Si && vi["!doctype"] && Yr.ownerDocument && Yr.ownerDocument.doctype && Yr.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, Yr.ownerDocument.doctype.name) && (ta = "<!DOCTYPE " + Yr.ownerDocument.doctype.name + `>
` + ta), Ei && arrayForEach([Qr, ei, ui], (va) => {
      ta = stringReplace(ta, va, " ");
    }), Mr && fa ? Mr.createHTML(ta) : ta;
  }, ar.setConfig = function() {
    let Ur = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ja(Ur), Vi = !0;
  }, ar.clearConfig = function() {
    da = null, Vi = !1;
  }, ar.isValidAttribute = function(Ur, qr, Yr) {
    da || ja({});
    const si = Hi(Ur), yi = Hi(qr);
    return $i(si, yi, Yr);
  }, ar.addHook = function(Ur, qr) {
    typeof qr == "function" && (li[Ur] = li[Ur] || [], arrayPush(li[Ur], qr));
  }, ar.removeHook = function(Ur) {
    if (li[Ur])
      return arrayPop(li[Ur]);
  }, ar.removeHooks = function(Ur) {
    li[Ur] && (li[Ur] = []);
  }, ar.removeAllHooks = function() {
    li = {};
  }, ar;
}
var purify = createDOMPurify();
function add_css$4(lr) {
  append_styles(lr, "svelte-oisaua", ".tooltip1.svelte-oisaua.svelte-oisaua{position:relative;display:inline-block;cursor:pointer}.tooltip1.svelte-oisaua .tooltip1text.svelte-oisaua{visibility:hidden;width:max-content;background-color:#4da84d;color:#fff;text-align:center;border-radius:4px;padding:8px;position:absolute;z-index:1;bottom:calc(100% + 8px);left:100%;transform:translateX(-50%);opacity:0;transition:opacity 0.3s, transform 0.3s;box-shadow:0 2px 4px rgba(0, 0, 0, 0.2)}.tooltip1.svelte-oisaua:hover .tooltip1text.svelte-oisaua,.tooltip1.svelte-oisaua:focus-within .tooltip1text.svelte-oisaua{visibility:visible;opacity:1;transform:translateX(-50%) translateY(-8px)}");
}
const get_tooltip1Text_slot_changes = (lr) => ({}), get_tooltip1Text_slot_context = (lr) => ({});
function create_fragment$4(lr) {
  let ar, cr, ur, fr, dr, gr;
  const mr = (
    /*#slots*/
    lr[2].default
  ), vr = create_slot(
    mr,
    lr,
    /*$$scope*/
    lr[1],
    null
  ), yr = (
    /*#slots*/
    lr[2].tooltip1Text
  ), kr = create_slot(
    yr,
    lr,
    /*$$scope*/
    lr[1],
    get_tooltip1Text_slot_context
  );
  return {
    c() {
      ar = element("div"), vr && vr.c(), cr = space(), ur = element("span"), kr && kr.c(), attr(ur, "class", "tooltip1text svelte-oisaua"), attr(ar, "class", "tooltip1 svelte-oisaua"), attr(ar, "role", "tooltip1");
    },
    m(_r, xr) {
      insert(_r, ar, xr), vr && vr.m(ar, null), append(ar, cr), append(ar, ur), kr && kr.m(ur, null), fr = !0, dr || (gr = [
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          lr[3]
        ),
        listen(
          ar,
          "mouseout",
          /*mouseout_handler*/
          lr[4]
        ),
        listen(
          ar,
          "focusin",
          /*focusin_handler*/
          lr[5]
        ),
        listen(
          ar,
          "focusout",
          /*focusout_handler*/
          lr[6]
        )
      ], dr = !0);
    },
    p(_r, [xr]) {
      vr && vr.p && (!fr || xr & /*$$scope*/
      2) && update_slot_base(
        vr,
        mr,
        _r,
        /*$$scope*/
        _r[1],
        fr ? get_slot_changes(
          mr,
          /*$$scope*/
          _r[1],
          xr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          _r[1]
        ),
        null
      ), kr && kr.p && (!fr || xr & /*$$scope*/
      2) && update_slot_base(
        kr,
        yr,
        _r,
        /*$$scope*/
        _r[1],
        fr ? get_slot_changes(
          yr,
          /*$$scope*/
          _r[1],
          xr,
          get_tooltip1Text_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          _r[1]
        ),
        get_tooltip1Text_slot_context
      );
    },
    i(_r) {
      fr || (transition_in(vr, _r), transition_in(kr, _r), fr = !0);
    },
    o(_r) {
      transition_out(vr, _r), transition_out(kr, _r), fr = !1;
    },
    d(_r) {
      _r && detach(ar), vr && vr.d(_r), kr && kr.d(_r), dr = !1, run_all(gr);
    }
  };
}
function instance$4(lr, ar, cr) {
  let { $$slots: ur = {}, $$scope: fr } = ar, dr = !1;
  const gr = () => cr(0, dr = !0), mr = () => cr(0, dr = !1), vr = () => cr(0, dr = !0), yr = () => cr(0, dr = !1);
  return lr.$$set = (kr) => {
    "$$scope" in kr && cr(1, fr = kr.$$scope);
  }, [
    dr,
    fr,
    ur,
    gr,
    mr,
    vr,
    yr
  ];
}
class Tooltip extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$4, create_fragment$4, safe_not_equal, {}, add_css$4);
  }
}
create_custom_element(Tooltip, {}, ["default", "tooltip1Text"], [], !0);
var toastuiEditorViewer = { exports: {} };
/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function(lr, ar) {
  (function(ur, fr) {
    lr.exports = fr(requireDist$1(), requireDist$2(), requireDist$5(), requireDist$4(), requireDist$3());
  })(self, function(cr, ur, fr, dr, gr) {
    return (
      /******/
      function() {
        var mr = {
          /***/
          368: (
            /***/
            function(_r) {
              /*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
              (function(xr, Sr) {
                _r.exports = Sr();
              })(this, function() {
                function xr(ga) {
                  if (Array.isArray(ga)) {
                    for (var pa = 0, Sa = Array(ga.length); pa < ga.length; pa++)
                      Sa[pa] = ga[pa];
                    return Sa;
                  } else
                    return Array.from(ga);
                }
                var Sr = Object.hasOwnProperty, Er = Object.setPrototypeOf, Cr = Object.isFrozen, Tr = Object.getPrototypeOf, Ar = Object.getOwnPropertyDescriptor, Ir = Object.freeze, Mr = Object.seal, Hr = Object.create, Br = typeof Reflect != "undefined" && Reflect, zr = Br.apply, Gr = Br.construct;
                zr || (zr = function(pa, Sa, Na) {
                  return pa.apply(Sa, Na);
                }), Ir || (Ir = function(pa) {
                  return pa;
                }), Mr || (Mr = function(pa) {
                  return pa;
                }), Gr || (Gr = function(pa, Sa) {
                  return new (Function.prototype.bind.apply(pa, [null].concat(xr(Sa))))();
                });
                var Xr = mi(Array.prototype.forEach), Jr = mi(Array.prototype.pop), li = mi(Array.prototype.push), Qr = mi(String.prototype.toLowerCase), ei = mi(String.prototype.match), ui = mi(String.prototype.replace), Ai = mi(String.prototype.indexOf), fi = mi(String.prototype.trim), gi = mi(RegExp.prototype.test), Ci = vi(TypeError);
                function mi(ga) {
                  return function(pa) {
                    for (var Sa = arguments.length, Na = Array(Sa > 1 ? Sa - 1 : 0), Oa = 1; Oa < Sa; Oa++)
                      Na[Oa - 1] = arguments[Oa];
                    return zr(ga, pa, Na);
                  };
                }
                function vi(ga) {
                  return function() {
                    for (var pa = arguments.length, Sa = Array(pa), Na = 0; Na < pa; Na++)
                      Sa[Na] = arguments[Na];
                    return Gr(ga, Sa);
                  };
                }
                function Ri(ga, pa) {
                  Er && Er(ga, null);
                  for (var Sa = pa.length; Sa--; ) {
                    var Na = pa[Sa];
                    if (typeof Na == "string") {
                      var Oa = Qr(Na);
                      Oa !== Na && (Cr(pa) || (pa[Sa] = Oa), Na = Oa);
                    }
                    ga[Na] = !0;
                  }
                  return ga;
                }
                function di(ga) {
                  var pa = Hr(null), Sa = void 0;
                  for (Sa in ga)
                    zr(Sr, ga, [Sa]) && (pa[Sa] = ga[Sa]);
                  return pa;
                }
                function Ti(ga, pa) {
                  for (; ga !== null; ) {
                    var Sa = Ar(ga, pa);
                    if (Sa) {
                      if (Sa.get)
                        return mi(Sa.get);
                      if (typeof Sa.value == "function")
                        return mi(Sa.value);
                    }
                    ga = Tr(ga);
                  }
                  function Na(Oa) {
                    return console.warn("fallback value for", Oa), null;
                  }
                  return Na;
                }
                var qi = Ir(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ki = Ir(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Ji = Ir(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Bi = Ir(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Ni = Ir(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), Mi = Ir(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), bi = Ir(["#text"]), Ei = Ir(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Si = Ir(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Vi = Ir(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Di = Ir(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), sa = Mr(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ra = Mr(/<%[\s\S]*|[\s\S]*%>/gm), fa = Mr(/^data-[\-\w.\u00B7-\uFFFF]/), ba = Mr(/^aria-[\-\w]+$/), Ua = Mr(
                  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
                  // eslint-disable-line no-useless-escape
                ), Va = Mr(/^(?:\w+script|data):/i), Ma = Mr(
                  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
                  // eslint-disable-line no-control-regex
                ), Fi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ga) {
                  return typeof ga;
                } : function(ga) {
                  return ga && typeof Symbol == "function" && ga.constructor === Symbol && ga !== Symbol.prototype ? "symbol" : typeof ga;
                };
                function na(ga) {
                  if (Array.isArray(ga)) {
                    for (var pa = 0, Sa = Array(ga.length); pa < ga.length; pa++)
                      Sa[pa] = ga[pa];
                    return Sa;
                  } else
                    return Array.from(ga);
                }
                var Gi = function() {
                  return typeof window == "undefined" ? null : window;
                }, Ca = function(pa, Sa) {
                  if ((typeof pa == "undefined" ? "undefined" : Fi(pa)) !== "object" || typeof pa.createPolicy != "function")
                    return null;
                  var Na = null, Oa = "data-tt-policy-suffix";
                  Sa.currentScript && Sa.currentScript.hasAttribute(Oa) && (Na = Sa.currentScript.getAttribute(Oa));
                  var Ja = "dompurify" + (Na ? "#" + Na : "");
                  try {
                    return pa.createPolicy(Ja, {
                      createHTML: function(Ia) {
                        return Ia;
                      }
                    });
                  } catch (za) {
                    return console.warn("TrustedTypes policy " + Ja + " could not be created."), null;
                  }
                };
                function $a() {
                  var ga = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Gi(), pa = function(Zi) {
                    return $a(Zi);
                  };
                  if (pa.version = "2.3.3", pa.removed = [], !ga || !ga.document || ga.document.nodeType !== 9)
                    return pa.isSupported = !1, pa;
                  var Sa = ga.document, Na = ga.document, Oa = ga.DocumentFragment, Ja = ga.HTMLTemplateElement, za = ga.Node, Ia = ga.Element, Yi = ga.NodeFilter, La = ga.NamedNodeMap, Ka = La === void 0 ? ga.NamedNodeMap || ga.MozNamedAttrMap : La, Qa = ga.Text, Hi = ga.Comment, da = ga.DOMParser, aa = ga.trustedTypes, oa = Ia.prototype, ja = Ti(oa, "cloneNode"), Ga = Ti(oa, "nextSibling"), xa = Ti(oa, "childNodes"), qa = Ti(oa, "parentNode");
                  if (typeof Ja == "function") {
                    var Ya = Na.createElement("template");
                    Ya.content && Ya.content.ownerDocument && (Na = Ya.content.ownerDocument);
                  }
                  var Za = Ca(aa, Sa), ko = Za && hs ? Za.createHTML("") : "", lo = Na, so = lo.implementation, ho = lo.createNodeIterator, Ro = lo.createDocumentFragment, Mo = lo.getElementsByTagName, Co = Sa.importNode, uo = {};
                  try {
                    uo = di(Na).documentMode ? Na.documentMode : {};
                  } catch (Ba) {
                  }
                  var wa = {};
                  pa.isSupported = typeof qa == "function" && so && typeof so.createHTMLDocument != "undefined" && uo !== 9;
                  var $i = sa, ca = ra, ci = fa, ti = ba, Ur = Va, qr = Ma, Yr = Ua, si = null, yi = Ri({}, [].concat(na(qi), na(ki), na(Ji), na(Ni), na(bi))), Ii = null, Ki = Ri({}, [].concat(na(Ei), na(Si), na(Vi), na(Di))), ta = null, va = null, ua = !0, ma = !0, Fa = !1, fo = !1, _o = !1, No = !1, Bo = !1, Po = !1, ds = !1, Ho = !0, hs = !1, Fs = !0, ps = !0, rs = !1, ns = {}, is = null, qs = Ri({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), js = null, Ls = Ri({}, ["audio", "video", "img", "source", "image", "track"]), Rs = null, $s = Ri({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Vs = "http://www.w3.org/1998/Math/MathML", gs = "http://www.w3.org/2000/svg", To = "http://www.w3.org/1999/xhtml", vs = To, as = !1, Uo = void 0, ss = ["application/xhtml+xml", "text/html"], wl = "text/html", ls = void 0, Yo = null, xl = Na.createElement("form"), Ks = function(Zi) {
                    Yo && Yo === Zi || ((!Zi || (typeof Zi == "undefined" ? "undefined" : Fi(Zi)) !== "object") && (Zi = {}), Zi = di(Zi), si = "ALLOWED_TAGS" in Zi ? Ri({}, Zi.ALLOWED_TAGS) : yi, Ii = "ALLOWED_ATTR" in Zi ? Ri({}, Zi.ALLOWED_ATTR) : Ki, Rs = "ADD_URI_SAFE_ATTR" in Zi ? Ri(di($s), Zi.ADD_URI_SAFE_ATTR) : $s, js = "ADD_DATA_URI_TAGS" in Zi ? Ri(di(Ls), Zi.ADD_DATA_URI_TAGS) : Ls, is = "FORBID_CONTENTS" in Zi ? Ri({}, Zi.FORBID_CONTENTS) : qs, ta = "FORBID_TAGS" in Zi ? Ri({}, Zi.FORBID_TAGS) : {}, va = "FORBID_ATTR" in Zi ? Ri({}, Zi.FORBID_ATTR) : {}, ns = "USE_PROFILES" in Zi ? Zi.USE_PROFILES : !1, ua = Zi.ALLOW_ARIA_ATTR !== !1, ma = Zi.ALLOW_DATA_ATTR !== !1, Fa = Zi.ALLOW_UNKNOWN_PROTOCOLS || !1, fo = Zi.SAFE_FOR_TEMPLATES || !1, _o = Zi.WHOLE_DOCUMENT || !1, Po = Zi.RETURN_DOM || !1, ds = Zi.RETURN_DOM_FRAGMENT || !1, Ho = Zi.RETURN_DOM_IMPORT !== !1, hs = Zi.RETURN_TRUSTED_TYPE || !1, Bo = Zi.FORCE_BODY || !1, Fs = Zi.SANITIZE_DOM !== !1, ps = Zi.KEEP_CONTENT !== !1, rs = Zi.IN_PLACE || !1, Yr = Zi.ALLOWED_URI_REGEXP || Yr, vs = Zi.NAMESPACE || To, Uo = // eslint-disable-next-line unicorn/prefer-includes
                    ss.indexOf(Zi.PARSER_MEDIA_TYPE) === -1 ? Uo = wl : Uo = Zi.PARSER_MEDIA_TYPE, ls = Uo === "application/xhtml+xml" ? function(ya) {
                      return ya;
                    } : Qr, fo && (ma = !1), ds && (Po = !0), ns && (si = Ri({}, [].concat(na(bi))), Ii = [], ns.html === !0 && (Ri(si, qi), Ri(Ii, Ei)), ns.svg === !0 && (Ri(si, ki), Ri(Ii, Si), Ri(Ii, Di)), ns.svgFilters === !0 && (Ri(si, Ji), Ri(Ii, Si), Ri(Ii, Di)), ns.mathMl === !0 && (Ri(si, Ni), Ri(Ii, Vi), Ri(Ii, Di))), Zi.ADD_TAGS && (si === yi && (si = di(si)), Ri(si, Zi.ADD_TAGS)), Zi.ADD_ATTR && (Ii === Ki && (Ii = di(Ii)), Ri(Ii, Zi.ADD_ATTR)), Zi.ADD_URI_SAFE_ATTR && Ri(Rs, Zi.ADD_URI_SAFE_ATTR), Zi.FORBID_CONTENTS && (is === qs && (is = di(is)), Ri(is, Zi.FORBID_CONTENTS)), ps && (si["#text"] = !0), _o && Ri(si, ["html", "head", "body"]), si.table && (Ri(si, ["tbody"]), delete ta.tbody), Ir && Ir(Zi), Yo = Zi);
                  }, Ms = Ri({}, ["mi", "mo", "mn", "ms", "mtext"]), Gs = Ri({}, ["foreignobject", "desc", "title", "annotation-xml"]), bs = Ri({}, ki);
                  Ri(bs, Ji), Ri(bs, Bi);
                  var Ns = Ri({}, Ni);
                  Ri(Ns, Mi);
                  var cl = function(Zi) {
                    var ya = qa(Zi);
                    (!ya || !ya.tagName) && (ya = {
                      namespaceURI: To,
                      tagName: "template"
                    });
                    var Ra = Qr(Zi.tagName), io = Qr(ya.tagName);
                    if (Zi.namespaceURI === gs)
                      return ya.namespaceURI === To ? Ra === "svg" : ya.namespaceURI === Vs ? Ra === "svg" && (io === "annotation-xml" || Ms[io]) : !!bs[Ra];
                    if (Zi.namespaceURI === Vs)
                      return ya.namespaceURI === To ? Ra === "math" : ya.namespaceURI === gs ? Ra === "math" && Gs[io] : !!Ns[Ra];
                    if (Zi.namespaceURI === To) {
                      if (ya.namespaceURI === gs && !Gs[io] || ya.namespaceURI === Vs && !Ms[io])
                        return !1;
                      var wo = Ri({}, ["title", "style", "font", "a", "script"]);
                      return !Ns[Ra] && (wo[Ra] || !bs[Ra]);
                    }
                    return !1;
                  }, Fo = function(Zi) {
                    li(pa.removed, { element: Zi });
                    try {
                      Zi.parentNode.removeChild(Zi);
                    } catch (ya) {
                      try {
                        Zi.outerHTML = ko;
                      } catch (Ra) {
                        Zi.remove();
                      }
                    }
                  }, ul = function(Zi, ya) {
                    try {
                      li(pa.removed, {
                        attribute: ya.getAttributeNode(Zi),
                        from: ya
                      });
                    } catch (Ra) {
                      li(pa.removed, {
                        attribute: null,
                        from: ya
                      });
                    }
                    if (ya.removeAttribute(Zi), Zi === "is" && !Ii[Zi])
                      if (Po || ds)
                        try {
                          Fo(ya);
                        } catch (Ra) {
                        }
                      else
                        try {
                          ya.setAttribute(Zi, "");
                        } catch (Ra) {
                        }
                  }, fl = function(Zi) {
                    var ya = void 0, Ra = void 0;
                    if (Bo)
                      Zi = "<remove></remove>" + Zi;
                    else {
                      var io = ei(Zi, /^[\r\n\t ]+/);
                      Ra = io && io[0];
                    }
                    Uo === "application/xhtml+xml" && (Zi = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Zi + "</body></html>");
                    var wo = Za ? Za.createHTML(Zi) : Zi;
                    if (vs === To)
                      try {
                        ya = new da().parseFromString(wo, Uo);
                      } catch (ro) {
                      }
                    if (!ya || !ya.documentElement) {
                      ya = so.createDocument(vs, "template", null);
                      try {
                        ya.documentElement.innerHTML = as ? "" : wo;
                      } catch (ro) {
                      }
                    }
                    var xo = ya.body || ya.documentElement;
                    return Zi && Ra && xo.insertBefore(Na.createTextNode(Ra), xo.childNodes[0] || null), vs === To ? Mo.call(ya, _o ? "html" : "body")[0] : _o ? ya.documentElement : xo;
                  }, Os = function(Zi) {
                    return ho.call(Zi.ownerDocument || Zi, Zi, Yi.SHOW_ELEMENT | Yi.SHOW_COMMENT | Yi.SHOW_TEXT, null, !1);
                  }, Ws = function(Zi) {
                    return Zi instanceof Qa || Zi instanceof Hi ? !1 : typeof Zi.nodeName != "string" || typeof Zi.textContent != "string" || typeof Zi.removeChild != "function" || !(Zi.attributes instanceof Ka) || typeof Zi.removeAttribute != "function" || typeof Zi.setAttribute != "function" || typeof Zi.namespaceURI != "string" || typeof Zi.insertBefore != "function";
                  }, ys = function(Zi) {
                    return (typeof za == "undefined" ? "undefined" : Fi(za)) === "object" ? Zi instanceof za : Zi && (typeof Zi == "undefined" ? "undefined" : Fi(Zi)) === "object" && typeof Zi.nodeType == "number" && typeof Zi.nodeName == "string";
                  }, qo = function(Zi, ya, Ra) {
                    wa[Zi] && Xr(wa[Zi], function(io) {
                      io.call(pa, ya, Ra, Yo);
                    });
                  }, Zs = function(Zi) {
                    var ya = void 0;
                    if (qo("beforeSanitizeElements", Zi, null), Ws(Zi) || ei(Zi.nodeName, /[\u0080-\uFFFF]/))
                      return Fo(Zi), !0;
                    var Ra = ls(Zi.nodeName);
                    if (qo("uponSanitizeElement", Zi, {
                      tagName: Ra,
                      allowedTags: si
                    }), !ys(Zi.firstElementChild) && (!ys(Zi.content) || !ys(Zi.content.firstElementChild)) && gi(/<[/\w]/g, Zi.innerHTML) && gi(/<[/\w]/g, Zi.textContent) || Ra === "select" && gi(/<template/i, Zi.innerHTML))
                      return Fo(Zi), !0;
                    if (!si[Ra] || ta[Ra]) {
                      if (ps && !is[Ra]) {
                        var io = qa(Zi) || Zi.parentNode, wo = xa(Zi) || Zi.childNodes;
                        if (wo && io)
                          for (var xo = wo.length, ro = xo - 1; ro >= 0; --ro)
                            io.insertBefore(ja(wo[ro], !0), Ga(Zi));
                      }
                      return Fo(Zi), !0;
                    }
                    return Zi instanceof Ia && !cl(Zi) || (Ra === "noscript" || Ra === "noembed") && gi(/<\/no(script|embed)/i, Zi.innerHTML) ? (Fo(Zi), !0) : (fo && Zi.nodeType === 3 && (ya = Zi.textContent, ya = ui(ya, $i, " "), ya = ui(ya, ca, " "), Zi.textContent !== ya && (li(pa.removed, { element: Zi.cloneNode() }), Zi.textContent = ya)), qo("afterSanitizeElements", Zi, null), !1);
                  }, Xs = function(Zi, ya, Ra) {
                    if (Fs && (ya === "id" || ya === "name") && (Ra in Na || Ra in xl))
                      return !1;
                    if (!(ma && !va[ya] && gi(ci, ya))) {
                      if (!(ua && gi(ti, ya))) {
                        if (!Ii[ya] || va[ya])
                          return !1;
                        if (!Rs[ya]) {
                          if (!gi(Yr, ui(Ra, qr, ""))) {
                            if (!((ya === "src" || ya === "xlink:href" || ya === "href") && Zi !== "script" && Ai(Ra, "data:") === 0 && js[Zi])) {
                              if (!(Fa && !gi(Ur, ui(Ra, qr, "")))) {
                                if (Ra)
                                  return !1;
                              }
                            }
                          }
                        }
                      }
                    }
                    return !0;
                  }, Js = function(Zi) {
                    var ya = void 0, Ra = void 0, io = void 0, wo = void 0;
                    qo("beforeSanitizeAttributes", Zi, null);
                    var xo = Zi.attributes;
                    if (xo) {
                      var ro = {
                        attrName: "",
                        attrValue: "",
                        keepAttr: !0,
                        allowedAttributes: Ii
                      };
                      for (wo = xo.length; wo--; ) {
                        ya = xo[wo];
                        var po = ya, ks = po.name, dl = po.namespaceURI;
                        if (Ra = fi(ya.value), io = ls(ks), ro.attrName = io, ro.attrValue = Ra, ro.keepAttr = !0, ro.forceKeepAttr = void 0, qo("uponSanitizeAttribute", Zi, ro), Ra = ro.attrValue, !ro.forceKeepAttr && (ul(ks, Zi), !!ro.keepAttr)) {
                          if (gi(/\/>/i, Ra)) {
                            ul(ks, Zi);
                            continue;
                          }
                          fo && (Ra = ui(Ra, $i, " "), Ra = ui(Ra, ca, " "));
                          var El = ls(Zi.nodeName);
                          if (Xs(El, io, Ra))
                            try {
                              dl ? Zi.setAttributeNS(dl, ks, Ra) : Zi.setAttribute(ks, Ra), Jr(pa.removed);
                            } catch (Qo) {
                            }
                        }
                      }
                      qo("afterSanitizeAttributes", Zi, null);
                    }
                  }, Ys = function Ba(Zi) {
                    var ya = void 0, Ra = Os(Zi);
                    for (qo("beforeSanitizeShadowDOM", Zi, null); ya = Ra.nextNode(); )
                      qo("uponSanitizeShadowNode", ya, null), !Zs(ya) && (ya.content instanceof Oa && Ba(ya.content), Js(ya));
                    qo("afterSanitizeShadowDOM", Zi, null);
                  };
                  return pa.sanitize = function(Ba, Zi) {
                    var ya = void 0, Ra = void 0, io = void 0, wo = void 0, xo = void 0;
                    if (as = !Ba, as && (Ba = "<!-->"), typeof Ba != "string" && !ys(Ba)) {
                      if (typeof Ba.toString != "function")
                        throw Ci("toString is not a function");
                      if (Ba = Ba.toString(), typeof Ba != "string")
                        throw Ci("dirty is not a string, aborting");
                    }
                    if (!pa.isSupported) {
                      if (Fi(ga.toStaticHTML) === "object" || typeof ga.toStaticHTML == "function") {
                        if (typeof Ba == "string")
                          return ga.toStaticHTML(Ba);
                        if (ys(Ba))
                          return ga.toStaticHTML(Ba.outerHTML);
                      }
                      return Ba;
                    }
                    if (No || Ks(Zi), pa.removed = [], typeof Ba == "string" && (rs = !1), !rs)
                      if (Ba instanceof za)
                        ya = fl("<!---->"), Ra = ya.ownerDocument.importNode(Ba, !0), Ra.nodeType === 1 && Ra.nodeName === "BODY" || Ra.nodeName === "HTML" ? ya = Ra : ya.appendChild(Ra);
                      else {
                        if (!Po && !fo && !_o && // eslint-disable-next-line unicorn/prefer-includes
                        Ba.indexOf("<") === -1)
                          return Za && hs ? Za.createHTML(Ba) : Ba;
                        if (ya = fl(Ba), !ya)
                          return Po ? null : ko;
                      }
                    ya && Bo && Fo(ya.firstChild);
                    for (var ro = Os(rs ? Ba : ya); io = ro.nextNode(); )
                      io.nodeType === 3 && io === wo || Zs(io) || (io.content instanceof Oa && Ys(io.content), Js(io), wo = io);
                    if (wo = null, rs)
                      return Ba;
                    if (Po) {
                      if (ds)
                        for (xo = Ro.call(ya.ownerDocument); ya.firstChild; )
                          xo.appendChild(ya.firstChild);
                      else
                        xo = ya;
                      return Ho && (xo = Co.call(Sa, xo, !0)), xo;
                    }
                    var po = _o ? ya.outerHTML : ya.innerHTML;
                    return fo && (po = ui(po, $i, " "), po = ui(po, ca, " ")), Za && hs ? Za.createHTML(po) : po;
                  }, pa.setConfig = function(Ba) {
                    Ks(Ba), No = !0;
                  }, pa.clearConfig = function() {
                    Yo = null, No = !1;
                  }, pa.isValidAttribute = function(Ba, Zi, ya) {
                    Yo || Ks({});
                    var Ra = ls(Ba), io = ls(Zi);
                    return Xs(Ra, io, ya);
                  }, pa.addHook = function(Ba, Zi) {
                    typeof Zi == "function" && (wa[Ba] = wa[Ba] || [], li(wa[Ba], Zi));
                  }, pa.removeHook = function(Ba) {
                    wa[Ba] && Jr(wa[Ba]);
                  }, pa.removeHooks = function(Ba) {
                    wa[Ba] && (wa[Ba] = []);
                  }, pa.removeAllHooks = function() {
                    wa = {};
                  }, pa;
                }
                var no = $a();
                return no;
              });
            }
          ),
          /***/
          928: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(322);
              function Cr(Tr, Ar, Ir) {
                var Mr, Hr;
                if (Ir = Ir || 0, !Er(Ar))
                  return -1;
                if (Array.prototype.indexOf)
                  return Array.prototype.indexOf.call(Ar, Tr, Ir);
                for (Hr = Ar.length, Mr = Ir; Ir >= 0 && Mr < Hr; Mr += 1)
                  if (Ar[Mr] === Tr)
                    return Mr;
                return -1;
              }
              _r.exports = Cr;
            }
          ),
          /***/
          690: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(322), Cr = Sr(893), Tr = Sr(956);
              function Ar(Ir, Mr, Hr) {
                Er(Ir) ? Cr(Ir, Mr, Hr) : Tr(Ir, Mr, Hr);
              }
              _r.exports = Ar;
            }
          ),
          /***/
          893: (
            /***/
            function(_r) {
              function xr(Sr, Er, Cr) {
                var Tr = 0, Ar = Sr.length;
                for (Cr = Cr || null; Tr < Ar && Er.call(Cr, Sr[Tr], Tr, Sr) !== !1; Tr += 1)
                  ;
              }
              _r.exports = xr;
            }
          ),
          /***/
          956: (
            /***/
            function(_r) {
              function xr(Sr, Er, Cr) {
                var Tr;
                Cr = Cr || null;
                for (Tr in Sr)
                  if (Sr.hasOwnProperty(Tr) && Er.call(Cr, Sr[Tr], Tr, Sr) === !1)
                    break;
              }
              _r.exports = xr;
            }
          ),
          /***/
          990: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(893);
              function Cr(Tr) {
                var Ar;
                try {
                  Ar = Array.prototype.slice.call(Tr);
                } catch (Ir) {
                  Ar = [], Er(Tr, function(Mr) {
                    Ar.push(Mr);
                  });
                }
                return Ar;
              }
              _r.exports = Cr;
            }
          ),
          /***/
          755: (
            /***/
            function(_r) {
              var xr = "_feEventKey";
              function Sr(Er, Cr) {
                var Tr = Er[xr], Ar;
                return Tr || (Tr = Er[xr] = {}), Ar = Tr[Cr], Ar || (Ar = Tr[Cr] = []), Ar;
              }
              _r.exports = Sr;
            }
          ),
          /***/
          349: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(758), Cr = Sr(690), Tr = Sr(755);
              function Ar(Hr, Br, zr) {
                if (Er(Br)) {
                  Cr(Br.split(/\s+/g), function(Gr) {
                    Ir(Hr, Gr, zr);
                  });
                  return;
                }
                Cr(Br, function(Gr, Xr) {
                  Ir(Hr, Xr, Gr);
                });
              }
              function Ir(Hr, Br, zr) {
                var Gr = Tr(Hr, Br), Xr;
                zr ? (Cr(Gr, function(Jr, li) {
                  return zr === Jr.handler ? (Mr(Hr, Br, Jr.wrappedHandler), Xr = li, !1) : !0;
                }), Gr.splice(Xr, 1)) : (Cr(Gr, function(Jr) {
                  Mr(Hr, Br, Jr.wrappedHandler);
                }), Gr.splice(0, Gr.length));
              }
              function Mr(Hr, Br, zr) {
                "removeEventListener" in Hr ? Hr.removeEventListener(Br, zr) : "detachEvent" in Hr && Hr.detachEvent("on" + Br, zr);
              }
              _r.exports = Ar;
            }
          ),
          /***/
          348: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(758), Cr = Sr(690), Tr = Sr(755);
              function Ar(Hr, Br, zr, Gr) {
                if (Er(Br)) {
                  Cr(Br.split(/\s+/g), function(Xr) {
                    Ir(Hr, Xr, zr, Gr);
                  });
                  return;
                }
                Cr(Br, function(Xr, Jr) {
                  Ir(Hr, Jr, Xr, zr);
                });
              }
              function Ir(Hr, Br, zr, Gr) {
                function Xr(Jr) {
                  zr.call(Gr || Hr, Jr || window.event);
                }
                "addEventListener" in Hr ? Hr.addEventListener(Br, Xr) : "attachEvent" in Hr && Hr.attachEvent("on" + Br, Xr), Mr(Hr, Br, zr, Xr);
              }
              function Mr(Hr, Br, zr, Gr) {
                var Xr = Tr(Hr, Br), Jr = !1;
                Cr(Xr, function(li) {
                  return li.handler === zr ? (Jr = !0, !1) : !0;
                }), Jr || Xr.push({
                  handler: zr,
                  wrappedHandler: Gr
                });
              }
              _r.exports = Ar;
            }
          ),
          /***/
          24: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(322), Cr = Sr(929);
              function Tr(Ar, Ir) {
                if (Ir = Er(Ir) ? Ir.join(" ") : Ir, Ir = Ir.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), Cr(Ar.className.baseVal)) {
                  Ar.className = Ir;
                  return;
                }
                Ar.className.baseVal = Ir;
              }
              _r.exports = Tr;
            }
          ),
          /***/
          204: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(690), Cr = Sr(928), Tr = Sr(902), Ar = Sr(24);
              function Ir(Mr) {
                var Hr = Array.prototype.slice.call(arguments, 1), Br = Mr.classList, zr = [], Gr;
                if (Br) {
                  Er(Hr, function(Xr) {
                    Mr.classList.add(Xr);
                  });
                  return;
                }
                Gr = Tr(Mr), Gr && (Hr = [].concat(Gr.split(/\s+/), Hr)), Er(Hr, function(Xr) {
                  Cr(Xr, zr) < 0 && zr.push(Xr);
                }), Ar(Mr, zr);
              }
              _r.exports = Ir;
            }
          ),
          /***/
          522: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(758), Cr = Sr(690);
              function Tr(Ar, Ir, Mr) {
                var Hr = Ar.style;
                if (Er(Ir)) {
                  Hr[Ir] = Mr;
                  return;
                }
                Cr(Ir, function(Br, zr) {
                  Hr[zr] = Br;
                });
              }
              _r.exports = Tr;
            }
          ),
          /***/
          902: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(929);
              function Cr(Tr) {
                return !Tr || !Tr.className ? "" : Er(Tr.className.baseVal) ? Tr.className : Tr.className.baseVal;
              }
              _r.exports = Cr;
            }
          ),
          /***/
          714: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(928), Cr = Sr(902);
              function Tr(Ar, Ir) {
                var Mr;
                return Ar.classList ? Ar.classList.contains(Ir) : (Mr = Cr(Ar).split(/\s+/), Er(Ir, Mr) > -1);
              }
              _r.exports = Tr;
            }
          ),
          /***/
          471: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(928), Cr = Sr(990), Tr = Element.prototype, Ar = Tr.matches || Tr.webkitMatchesSelector || Tr.mozMatchesSelector || Tr.msMatchesSelector || function(Mr) {
                var Hr = this.document || this.ownerDocument;
                return Er(this, Cr(Hr.querySelectorAll(Mr))) > -1;
              };
              function Ir(Mr, Hr) {
                return Ar.call(Mr, Hr);
              }
              _r.exports = Ir;
            }
          ),
          /***/
          462: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(893), Cr = Sr(928), Tr = Sr(902), Ar = Sr(24);
              function Ir(Mr) {
                var Hr = Array.prototype.slice.call(arguments, 1), Br = Mr.classList, zr, Gr;
                if (Br) {
                  Er(Hr, function(Xr) {
                    Br.remove(Xr);
                  });
                  return;
                }
                zr = Tr(Mr).split(/\s+/), Gr = [], Er(zr, function(Xr) {
                  Cr(Xr, Hr) < 0 && Gr.push(Xr);
                }), Ar(Mr, Gr);
              }
              _r.exports = Ir;
            }
          ),
          /***/
          969: (
            /***/
            function(_r) {
              function xr(Sr, Er) {
                var Cr = Object.prototype.hasOwnProperty, Tr, Ar, Ir, Mr;
                for (Ir = 1, Mr = arguments.length; Ir < Mr; Ir += 1) {
                  Tr = arguments[Ir];
                  for (Ar in Tr)
                    Cr.call(Tr, Ar) && (Sr[Ar] = Tr[Ar]);
                }
                return Sr;
              }
              _r.exports = xr;
            }
          ),
          /***/
          254: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(956);
              function Cr(Tr, Ar) {
                var Ir = document.createElement("img"), Mr = "";
                return Er(Ar, function(Hr, Br) {
                  Mr += "&" + Br + "=" + Hr;
                }), Mr = Mr.substring(1), Ir.src = Tr + "?" + Mr, Ir.style.display = "none", document.body.appendChild(Ir), document.body.removeChild(Ir), Ir;
              }
              _r.exports = Cr;
            }
          ),
          /***/
          391: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(929), Cr = Sr(254), Tr = 7 * 24 * 60 * 60 * 1e3;
              function Ar(Mr) {
                var Hr = (/* @__PURE__ */ new Date()).getTime();
                return Hr - Mr > Tr;
              }
              function Ir(Mr, Hr) {
                var Br = "https://www.google-analytics.com/collect", zr = location.hostname, Gr = "event", Xr = "use", Jr = "TOAST UI " + Mr + " for " + zr + ": Statistics", li = window.localStorage.getItem(Jr);
                !Er(window.tui) && window.tui.usageStatistics === !1 || li && !Ar(li) || (window.localStorage.setItem(Jr, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
                  (document.readyState === "interactive" || document.readyState === "complete") && Cr(Br, {
                    v: 1,
                    t: Gr,
                    tid: Hr,
                    cid: zr,
                    dp: zr,
                    dh: Mr,
                    el: Mr,
                    ec: Xr
                  });
                }, 1e3));
              }
              _r.exports = Ir;
            }
          ),
          /***/
          322: (
            /***/
            function(_r) {
              function xr(Sr) {
                return Sr instanceof Array;
              }
              _r.exports = xr;
            }
          ),
          /***/
          65: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(929), Cr = Sr(934);
              function Tr(Ar) {
                return !Er(Ar) && !Cr(Ar);
              }
              _r.exports = Tr;
            }
          ),
          /***/
          404: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(790);
              function Cr(Tr) {
                return !Er(Tr);
              }
              _r.exports = Cr;
            }
          ),
          /***/
          294: (
            /***/
            function(_r) {
              function xr(Sr) {
                return Sr instanceof Function;
              }
              _r.exports = xr;
            }
          ),
          /***/
          934: (
            /***/
            function(_r) {
              function xr(Sr) {
                return Sr === null;
              }
              _r.exports = xr;
            }
          ),
          /***/
          758: (
            /***/
            function(_r) {
              function xr(Sr) {
                return typeof Sr == "string" || Sr instanceof String;
              }
              _r.exports = xr;
            }
          ),
          /***/
          790: (
            /***/
            function(_r, xr, Sr) {
              var Er = Sr(65);
              function Cr(Tr) {
                return Er(Tr) && Tr !== !1;
              }
              _r.exports = Cr;
            }
          ),
          /***/
          929: (
            /***/
            function(_r) {
              function xr(Sr) {
                return Sr === void 0;
              }
              _r.exports = xr;
            }
          ),
          /***/
          479: (
            /***/
            function(_r) {
              _r.exports = cr;
            }
          ),
          /***/
          481: (
            /***/
            function(_r) {
              _r.exports = ur;
            }
          ),
          /***/
          43: (
            /***/
            function(_r) {
              _r.exports = fr;
            }
          ),
          /***/
          814: (
            /***/
            function(_r) {
              _r.exports = dr;
            }
          ),
          /***/
          311: (
            /***/
            function(_r) {
              _r.exports = gr;
            }
          )
          /******/
        }, vr = {};
        function yr(_r) {
          var xr = vr[_r];
          if (xr !== void 0)
            return xr.exports;
          var Sr = vr[_r] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return mr[_r].call(Sr.exports, Sr, Sr.exports, yr), Sr.exports;
        }
        (function() {
          yr.n = function(_r) {
            var xr = _r && _r.__esModule ? (
              /******/
              function() {
                return _r.default;
              }
            ) : (
              /******/
              function() {
                return _r;
              }
            );
            return yr.d(xr, { a: xr }), xr;
          };
        })(), function() {
          yr.d = function(_r, xr) {
            for (var Sr in xr)
              yr.o(xr, Sr) && !yr.o(_r, Sr) && Object.defineProperty(_r, Sr, { enumerable: !0, get: xr[Sr] });
          };
        }(), function() {
          yr.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (_r) {
              if (typeof window == "object")
                return window;
            }
          }();
        }(), function() {
          yr.o = function(_r, xr) {
            return Object.prototype.hasOwnProperty.call(_r, xr);
          };
        }();
        var kr = {};
        return function() {
          yr.d(kr, {
            default: function() {
              return (
                /* binding */
                Oj
              );
            }
          });
          var _r = function() {
            return _r = Object.assign || function(Nr) {
              for (var $r, Zr = 1, oi = arguments.length; Zr < oi; Zr++) {
                $r = arguments[Zr];
                for (var _i in $r)
                  Object.prototype.hasOwnProperty.call($r, _i) && (Nr[_i] = $r[_i]);
              }
              return Nr;
            }, _r.apply(this, arguments);
          };
          function xr(Dr, Nr, $r) {
            if ($r || arguments.length === 2)
              for (var Zr = 0, oi = Nr.length, _i; Zr < oi; Zr++)
                (_i || !(Zr in Nr)) && (_i || (_i = Array.prototype.slice.call(Nr, 0, Zr)), _i[Zr] = Nr[Zr]);
            return Dr.concat(_i || Array.prototype.slice.call(Nr));
          }
          /*! *****************************************************************************
          	Copyright (c) Microsoft Corporation.
          
          	Permission to use, copy, modify, and/or distribute this software for any
          	purpose with or without fee is hereby granted.
          
          	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          	PERFORMANCE OF THIS SOFTWARE.
          	***************************************************************************** */
          var Sr = function(Dr, Nr) {
            return Sr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function($r, Zr) {
              $r.__proto__ = Zr;
            } || function($r, Zr) {
              for (var oi in Zr)
                Object.prototype.hasOwnProperty.call(Zr, oi) && ($r[oi] = Zr[oi]);
            }, Sr(Dr, Nr);
          };
          function Er(Dr, Nr) {
            if (typeof Nr != "function" && Nr !== null)
              throw new TypeError("Class extends value " + String(Nr) + " is not a constructor or null");
            Sr(Dr, Nr);
            function $r() {
              this.constructor = Dr;
            }
            Dr.prototype = Nr === null ? Object.create(Nr) : ($r.prototype = Nr.prototype, new $r());
          }
          var Cr = function() {
            return Cr = Object.assign || function(Nr) {
              for (var $r, Zr = 1, oi = arguments.length; Zr < oi; Zr++) {
                $r = arguments[Zr];
                for (var _i in $r)
                  Object.prototype.hasOwnProperty.call($r, _i) && (Nr[_i] = $r[_i]);
              }
              return Nr;
            }, Cr.apply(this, arguments);
          };
          function Tr(Dr, Nr, $r) {
            if ($r || arguments.length === 2)
              for (var Zr = 0, oi = Nr.length, _i; Zr < oi; Zr++)
                (_i || !(Zr in Nr)) && (_i || (_i = Array.prototype.slice.call(Nr, 0, Zr)), _i[Zr] = Nr[Zr]);
            return Dr.concat(_i || Array.prototype.slice.call(Nr));
          }
          var Ar = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof yr.g != "undefined" ? yr.g : typeof self != "undefined" ? self : {}, Ir = {};
          function Mr(Dr) {
            var Nr, $r, Zr = Ir[Dr];
            if (Zr)
              return Zr;
            for (Zr = Ir[Dr] = [], Nr = 0; Nr < 128; Nr++)
              $r = String.fromCharCode(Nr), /^[0-9a-z]$/i.test($r) ? Zr.push($r) : Zr.push("%" + ("0" + Nr.toString(16).toUpperCase()).slice(-2));
            for (Nr = 0; Nr < Dr.length; Nr++)
              Zr[Dr.charCodeAt(Nr)] = Dr[Nr];
            return Zr;
          }
          function Hr(Dr, Nr, $r) {
            var Zr, oi, _i, Li, Ui, ea = "";
            for (typeof Nr != "string" && ($r = Nr, Nr = Hr.defaultChars), typeof $r == "undefined" && ($r = !0), Ui = Mr(Nr), Zr = 0, oi = Dr.length; Zr < oi; Zr++) {
              if (_i = Dr.charCodeAt(Zr), $r && _i === 37 && Zr + 2 < oi && /^[0-9a-f]{2}$/i.test(Dr.slice(Zr + 1, Zr + 3))) {
                ea += Dr.slice(Zr, Zr + 3), Zr += 2;
                continue;
              }
              if (_i < 128) {
                ea += Ui[_i];
                continue;
              }
              if (_i >= 55296 && _i <= 57343) {
                if (_i >= 55296 && _i <= 56319 && Zr + 1 < oi && (Li = Dr.charCodeAt(Zr + 1), Li >= 56320 && Li <= 57343)) {
                  ea += encodeURIComponent(Dr[Zr] + Dr[Zr + 1]), Zr++;
                  continue;
                }
                ea += "%EF%BF%BD";
                continue;
              }
              ea += encodeURIComponent(Dr[Zr]);
            }
            return ea;
          }
          Hr.defaultChars = ";/?:@&=+$,-_.!~*'()#", Hr.componentChars = "-_.!~*'()";
          var Br = Hr, zr = {}, Gr = {}, Xr = "Á", Jr = "á", li = "Ă", Qr = "ă", ei = "∾", ui = "∿", Ai = "∾̳", fi = "Â", gi = "â", Ci = "´", mi = "А", vi = "а", Ri = "Æ", di = "æ", Ti = "⁡", qi = "𝔄", ki = "𝔞", Ji = "À", Bi = "à", Ni = "ℵ", Mi = "ℵ", bi = "Α", Ei = "α", Si = "Ā", Vi = "ā", Di = "⨿", sa = "&", ra = "&", fa = "⩕", ba = "⩓", Ua = "∧", Va = "⩜", Ma = "⩘", Fi = "⩚", na = "∠", Gi = "⦤", Ca = "∠", $a = "⦨", no = "⦩", ga = "⦪", pa = "⦫", Sa = "⦬", Na = "⦭", Oa = "⦮", Ja = "⦯", za = "∡", Ia = "∟", Yi = "⊾", La = "⦝", Ka = "∢", Qa = "Å", Hi = "⍼", da = "Ą", aa = "ą", oa = "𝔸", ja = "𝕒", Ga = "⩯", xa = "≈", qa = "⩰", Ya = "≊", Za = "≋", ko = "'", lo = "⁡", so = "≈", ho = "≊", Ro = "Å", Mo = "å", Co = "𝒜", uo = "𝒶", wa = "≔", $i = "*", ca = "≈", ci = "≍", ti = "Ã", Ur = "ã", qr = "Ä", Yr = "ä", si = "∳", yi = "⨑", Ii = "≌", Ki = "϶", ta = "‵", va = "∽", ua = "⋍", ma = "∖", Fa = "⫧", fo = "⊽", _o = "⌅", No = "⌆", Bo = "⌅", Po = "⎵", ds = "⎶", Ho = "≌", hs = "Б", Fs = "б", ps = "„", rs = "∵", ns = "∵", is = "∵", qs = "⦰", js = "϶", Ls = "ℬ", Rs = "ℬ", $s = "Β", Vs = "β", gs = "ℶ", To = "≬", vs = "𝔅", as = "𝔟", Uo = "⋂", ss = "◯", wl = "⋃", ls = "⨀", Yo = "⨁", xl = "⨂", Ks = "⨆", Ms = "★", Gs = "▽", bs = "△", Ns = "⨄", cl = "⋁", Fo = "⋀", ul = "⤍", fl = "⧫", Os = "▪", Ws = "▴", ys = "▾", qo = "◂", Zs = "▸", Xs = "␣", Js = "▒", Ys = "░", Ba = "▓", Zi = "█", ya = "=⃥", Ra = "≡⃥", io = "⫭", wo = "⌐", xo = "𝔹", ro = "𝕓", po = "⊥", ks = "⊥", dl = "⋈", El = "⧉", Qo = "┐", Lc = "╕", Cl = "╖", Tl = "╗", Rc = "┌", Mc = "╒", hl = "╓", Nc = "╔", Al = "─", Ds = "═", Oc = "┬", Dc = "╤", Bc = "╥", Pc = "╦", Hc = "┴", Uc = "╧", Sl = "╨", Hl = "╩", zc = "⊟", Ul = "⊞", Fc = "⊠", zl = "┘", Fl = "╛", qc = "╜", Qs = "╝", jc = "└", tl = "╘", $c = "╙", Vc = "╚", rl = "│", ql = "║", jl = "┼", $l = "╪", Vl = "╫", nl = "╬", Gl = "┤", il = "╡", Kc = "╢", _s = "╣", Bs = "├", ws = "╞", jo = "╟", Io = "╠", Wl = "‵", Gc = "˘", Zl = "˘", Wc = "¦", Xl = "𝒷", Jl = "ℬ", pl = "⁏", xs = "∽", Il = "⋍", Yl = "⧅", Rl = "\\", Zc = "⟈", Xc = "•", Jc = "•", Yc = "≎", Ql = "⪮", ec = "≏", Qc = "≎", eu = "≏", tu = "Ć", ru = "ć", iu = "⩄", au = "⩉", tc = "⩋", ou = "∩", su = "⋒", Ml = "⩇", lu = "⩀", rc = "ⅅ", cu = "∩︀", uu = "⁁", fu = "ˇ", du = "ℭ", nc = "⩍", oc = "Č", lc = "č", hu = "Ç", cc = "ç", pu = "Ĉ", uc = "ĉ", Lr = "∰", jr = "⩌", Rr = "⩐", Fr = "Ċ", Vr = "ċ", Wr = "¸", ri = "¸", ai = "⦲", hi = "¢", wi = "·", Oi = "·", Wi = "𝔠", zi = "ℭ", Qi = "Ч", ia = "ч", Ta = "✓", Da = "✓", ha = "Χ", co = "χ", Xa = "ˆ", ao = "≗", Wa = "↺", eo = "↻", mo = "⊛", Do = "⊚", $o = "⊝", Ao = "⊙", Zo = "®", Oo = "Ⓢ", Ps = "⊖", Xo = "⊕", Hs = "⊗", Vo = "○", vo = "⧃", fc = "≗", gu = "⨐", ml = "⫯", Es = "⧂", dc = "∲", hc = "”", Td = "’", Ad = "♣", Sd = "♣", Ld = ":", Rd = "∷", Md = "⩴", Nd = "≔", Od = "≔", Dd = ",", Bd = "@", Pd = "∁", Hd = "∘", Ud = "∁", zd = "ℂ", Fd = "≅", qd = "⩭", jd = "≡", $d = "∮", Vd = "∯", Kd = "∮", Gd = "𝕔", Wd = "ℂ", Zd = "∐", Xd = "∐", Jd = "©", Yd = "©", Qd = "℗", eh = "∳", th = "↵", rh = "✗", nh = "⨯", ih = "𝒞", ah = "𝒸", oh = "⫏", sh = "⫑", lh = "⫐", ch = "⫒", uh = "⋯", fh = "⤸", dh = "⤵", hh = "⋞", ph = "⋟", gh = "↶", mh = "⤽", vh = "⩈", bh = "⩆", yh = "≍", kh = "∪", _h = "⋓", wh = "⩊", xh = "⊍", Eh = "⩅", Ch = "∪︀", Th = "↷", Ah = "⤼", Sh = "⋞", Ih = "⋟", Lh = "⋎", Rh = "⋏", Mh = "¤", Nh = "↶", Oh = "↷", Dh = "⋎", Bh = "⋏", Ph = "∲", Hh = "∱", Uh = "⌭", zh = "†", Fh = "‡", qh = "ℸ", jh = "↓", $h = "↡", Vh = "⇓", Kh = "‐", Gh = "⫤", Wh = "⊣", Zh = "⤏", Xh = "˝", Jh = "Ď", Yh = "ď", Qh = "Д", ep = "д", tp = "‡", rp = "⇊", np = "ⅅ", ip = "ⅆ", op = "⤑", sp = "⩷", lp = "°", cp = "∇", up = "Δ", fp = "δ", dp = "⦱", hp = "⥿", pp = "𝔇", gp = "𝔡", vp = "⥥", bp = "⇃", yp = "⇂", kp = "´", _p = "˙", xp = "˝", Ep = "`", Cp = "˜", Tp = "⋄", Ap = "⋄", Sp = "⋄", Ip = "♦", Lp = "♦", Rp = "¨", Mp = "ⅆ", Np = "ϝ", Op = "⋲", Dp = "÷", Bp = "÷", Pp = "⋇", Hp = "⋇", Up = "Ђ", zp = "ђ", qp = "⌞", jp = "⌍", $p = "$", Vp = "𝔻", Kp = "𝕕", Gp = "¨", Wp = "˙", Zp = "⃜", Xp = "≐", Jp = "≑", Yp = "≐", Qp = "∸", tg = "∔", rg = "⊡", ng = "⌆", ig = "∯", ag = "¨", og = "⇓", sg = "⇐", cg = "⇔", ug = "⫤", fg = "⟸", dg = "⟺", hg = "⟹", pg = "⇒", mg = "⊨", vg = "⇑", bg = "⇕", yg = "∥", kg = "⤓", _g = "↓", wg = "↓", xg = "⇓", Eg = "⇵", Cg = "̑", Tg = "⇊", Ag = "⇃", Sg = "⇂", Ig = "⥐", Lg = "⥞", Rg = "⥖", Mg = "↽", Ng = "⥟", Og = "⥗", Dg = "⇁", Bg = "↧", Pg = "⊤", Hg = "⤐", Ug = "⌟", zg = "⌌", Fg = "𝒟", qg = "𝒹", jg = "Ѕ", $g = "ѕ", Vg = "⧶", Kg = "Đ", Wg = "đ", Zg = "⋱", Xg = "▿", Jg = "▾", Yg = "⇵", Qg = "⥯", em = "⦦", tm = "Џ", rm = "џ", nm = "⟿", im = "É", am = "é", om = "⩮", sm = "Ě", lm = "ě", cm = "Ê", um = "ê", fm = "≖", dm = "≕", hm = "Э", gm = "э", mm = "⩷", vm = "Ė", bm = "ė", ym = "≑", km = "ⅇ", _m = "≒", wm = "𝔈", xm = "𝔢", Em = "⪚", Cm = "È", Tm = "è", Am = "⪖", Sm = "⪘", Lm = "⪙", Rm = "∈", Mm = "⏧", Nm = "ℓ", Om = "⪕", Dm = "⪗", Bm = "Ē", Pm = "ē", Hm = "∅", Um = "∅", zm = "◻", Fm = "∅", qm = "▫", jm = " ", $m = " ", Vm = " ", Km = "Ŋ", Gm = "ŋ", Wm = " ", Zm = "Ę", Xm = "ę", Jm = "𝔼", Ym = "𝕖", Qm = "⋕", ev = "⧣", tv = "⩱", rv = "ε", nv = "Ε", iv = "ε", av = "ϵ", ov = "≖", sv = "≕", lv = "≂", cv = "⪖", uv = "⪕", fv = "⩵", dv = "=", hv = "≂", pv = "≟", gv = "⇌", mv = "≡", vv = "⩸", bv = "⧥", yv = "⥱", kv = "≓", _v = "ℯ", wv = "ℰ", xv = "≐", Ev = "⩳", Cv = "≂", Tv = "Η", Av = "η", Sv = "Ð", Iv = "ð", Lv = "Ë", Rv = "ë", Mv = "€", Nv = "!", Ov = "∃", Dv = "∃", Bv = "ℰ", Pv = "ⅇ", Hv = "ⅇ", Uv = "≒", zv = "Ф", Fv = "ф", qv = "♀", jv = "ﬃ", $v = "ﬀ", Vv = "ﬄ", Kv = "𝔉", Gv = "𝔣", Wv = "ﬁ", Zv = "◼", Xv = "▪", Jv = "fj", Yv = "♭", Qv = "ﬂ", eb = "▱", tb = "ƒ", rb = "𝔽", nb = "𝕗", ib = "∀", ab = "∀", ob = "⋔", sb = "⫙", lb = "ℱ", cb = "⨍", ub = "½", fb = "⅓", hb = "¼", pb = "⅕", gb = "⅙", mb = "⅛", vb = "⅔", bb = "⅖", yb = "¾", kb = "⅗", _b = "⅜", wb = "⅘", xb = "⅚", Eb = "⅝", Cb = "⅞", Tb = "⁄", Ab = "⌢", Sb = "𝒻", Ib = "ℱ", Lb = "ǵ", Rb = "Γ", Mb = "γ", Nb = "Ϝ", Ob = "ϝ", Db = "⪆", Bb = "Ğ", Pb = "ğ", Hb = "Ģ", Ub = "Ĝ", zb = "ĝ", Fb = "Г", qb = "г", jb = "Ġ", $b = "ġ", Vb = "≥", Kb = "≧", Gb = "⪌", Wb = "⋛", Zb = "≥", Xb = "≧", Jb = "⩾", Yb = "⪩", Qb = "⩾", e1 = "⪀", t1 = "⪂", r1 = "⪄", n1 = "⋛︀", i1 = "⪔", a1 = "𝔊", o1 = "𝔤", s1 = "≫", l1 = "⋙", c1 = "⋙", u1 = "ℷ", f1 = "Ѓ", d1 = "ѓ", h1 = "⪥", p1 = "≷", g1 = "⪒", m1 = "⪤", v1 = "⪊", b1 = "⪊", y1 = "⪈", k1 = "≩", _1 = "⪈", w1 = "≩", x1 = "⋧", E1 = "𝔾", C1 = "𝕘", T1 = "`", A1 = "≥", S1 = "⋛", I1 = "≧", L1 = "⪢", R1 = "≷", M1 = "⩾", N1 = "≳", O1 = "𝒢", D1 = "ℊ", B1 = "≳", P1 = "⪎", H1 = "⪐", U1 = "⪧", z1 = "⩺", F1 = ">", q1 = ">", j1 = "≫", $1 = "⋗", V1 = "⦕", K1 = "⩼", G1 = "⪆", W1 = "⥸", Z1 = "⋗", X1 = "⋛", J1 = "⪌", Y1 = "≷", Q1 = "≳", ey = "≩︀", ty = "≩︀", ry = "ˇ", ny = " ", iy = "½", ay = "ℋ", oy = "Ъ", sy = "ъ", ly = "⥈", cy = "↔", uy = "⇔", fy = "↭", dy = "^", hy = "ℏ", py = "Ĥ", gy = "ĥ", my = "♥", vy = "♥", by = "…", yy = "⊹", ky = "𝔥", _y = "ℌ", wy = "ℋ", xy = "⤥", Ey = "⤦", Cy = "⇿", Ty = "∻", Ay = "↩", Sy = "↪", Iy = "𝕙", Ly = "ℍ", Ry = "―", My = "─", Ny = "𝒽", Oy = "ℋ", Dy = "ℏ", By = "Ħ", Py = "ħ", Hy = "≎", Uy = "≏", zy = "⁃", Fy = "‐", qy = "Í", jy = "í", $y = "⁣", Vy = "Î", Ky = "î", Gy = "И", Wy = "и", Zy = "İ", Xy = "Е", Jy = "е", Yy = "¡", Qy = "⇔", e0 = "𝔦", t0 = "ℑ", r0 = "Ì", n0 = "ì", i0 = "ⅈ", a0 = "⨌", o0 = "∭", s0 = "⧜", l0 = "℩", c0 = "Ĳ", u0 = "ĳ", f0 = "Ī", d0 = "ī", h0 = "ℑ", p0 = "ⅈ", g0 = "ℐ", m0 = "ℑ", v0 = "ı", b0 = "ℑ", y0 = "⊷", k0 = "Ƶ", _0 = "⇒", w0 = "℅", x0 = "∞", E0 = "⧝", C0 = "ı", T0 = "⊺", A0 = "∫", S0 = "∬", I0 = "ℤ", L0 = "∫", R0 = "⊺", M0 = "⋂", N0 = "⨗", O0 = "⨼", D0 = "⁣", B0 = "⁢", P0 = "Ё", H0 = "ё", U0 = "Į", z0 = "į", F0 = "𝕀", q0 = "𝕚", j0 = "Ι", $0 = "ι", V0 = "⨼", K0 = "¿", G0 = "𝒾", W0 = "ℐ", Z0 = "∈", X0 = "⋵", J0 = "⋹", Y0 = "⋴", Q0 = "⋳", ek = "∈", tk = "⁢", rk = "Ĩ", nk = "ĩ", ik = "І", ak = "і", ok = "Ï", sk = "ï", lk = "Ĵ", ck = "ĵ", uk = "Й", fk = "й", dk = "𝔍", hk = "𝔧", pk = "ȷ", gk = "𝕁", mk = "𝕛", vk = "𝒥", bk = "𝒿", yk = "Ј", kk = "ј", _k = "Є", wk = "є", xk = "Κ", Ek = "κ", Ck = "ϰ", Tk = "Ķ", Ak = "ķ", Sk = "К", Ik = "к", Lk = "𝔎", Rk = "𝔨", Mk = "ĸ", Nk = "Х", Ok = "х", Dk = "Ќ", Bk = "ќ", Pk = "𝕂", Hk = "𝕜", Uk = "𝒦", zk = "𝓀", Fk = "⇚", qk = "Ĺ", jk = "ĺ", $k = "⦴", Vk = "ℒ", Kk = "Λ", Gk = "λ", Wk = "⟨", Zk = "⟪", Xk = "⦑", Jk = "⟨", Yk = "⪅", Qk = "ℒ", e_ = "«", t_ = "⇤", r_ = "⤟", n_ = "←", i_ = "↞", a_ = "⇐", o_ = "⤝", s_ = "↩", l_ = "↫", c_ = "⤹", u_ = "⥳", f_ = "↢", d_ = "⤙", h_ = "⤛", p_ = "⪫", g_ = "⪭", m_ = "⪭︀", v_ = "⤌", b_ = "⤎", y_ = "❲", k_ = "{", __ = "[", w_ = "⦋", x_ = "⦏", E_ = "⦍", C_ = "Ľ", T_ = "ľ", A_ = "Ļ", S_ = "ļ", I_ = "⌈", L_ = "{", R_ = "Л", M_ = "л", N_ = "⤶", O_ = "“", D_ = "„", B_ = "⥧", P_ = "⥋", H_ = "↲", U_ = "≤", z_ = "≦", F_ = "⟨", q_ = "⇤", j_ = "←", $_ = "←", V_ = "⇐", K_ = "⇆", G_ = "↢", W_ = "⌈", Z_ = "⟦", X_ = "⥡", J_ = "⥙", Y_ = "⇃", Q_ = "⌊", ew = "↽", tw = "↼", rw = "⇇", nw = "↔", iw = "↔", aw = "⇔", ow = "⇆", sw = "⇋", lw = "↭", cw = "⥎", uw = "↤", fw = "⊣", dw = "⥚", hw = "⋋", pw = "⧏", gw = "⊲", mw = "⊴", vw = "⥑", bw = "⥠", yw = "⥘", kw = "↿", _w = "⥒", ww = "↼", xw = "⪋", Ew = "⋚", Cw = "≤", Tw = "≦", Aw = "⩽", Sw = "⪨", Iw = "⩽", Lw = "⩿", Rw = "⪁", Mw = "⪃", Nw = "⋚︀", Ow = "⪓", Dw = "⪅", Bw = "⋖", Pw = "⋚", Hw = "⪋", Uw = "⋚", zw = "≦", Fw = "≶", qw = "≶", jw = "⪡", $w = "≲", Vw = "⩽", Kw = "≲", Gw = "⥼", Ww = "⌊", Zw = "𝔏", Xw = "𝔩", Jw = "≶", Yw = "⪑", Qw = "⥢", e2 = "↽", t2 = "↼", r2 = "⥪", n2 = "▄", i2 = "Љ", a2 = "љ", o2 = "⇇", s2 = "≪", l2 = "⋘", c2 = "⌞", u2 = "⇚", f2 = "⥫", d2 = "◺", h2 = "Ŀ", p2 = "ŀ", g2 = "⎰", m2 = "⎰", b2 = "⪉", y2 = "⪉", k2 = "⪇", _2 = "≨", w2 = "⪇", x2 = "≨", E2 = "⋦", C2 = "⟬", T2 = "⇽", A2 = "⟦", S2 = "⟵", I2 = "⟵", L2 = "⟸", R2 = "⟷", M2 = "⟷", N2 = "⟺", O2 = "⟼", D2 = "⟶", B2 = "⟶", P2 = "⟹", H2 = "↫", U2 = "↬", z2 = "⦅", F2 = "𝕃", q2 = "𝕝", j2 = "⨭", $2 = "⨴", V2 = "∗", K2 = "_", G2 = "↙", W2 = "↘", Z2 = "◊", X2 = "◊", J2 = "⧫", Y2 = "(", Q2 = "⦓", ex = "⇆", tx = "⌟", nx = "⇋", ix = "⥭", ax = "‎", ox = "⊿", sx = "‹", lx = "𝓁", cx = "ℒ", ux = "↰", fx = "↰", dx = "≲", hx = "⪍", px = "⪏", gx = "[", mx = "‘", vx = "‚", bx = "Ł", yx = "ł", kx = "⪦", _x = "⩹", wx = "<", xx = "<", Ex = "≪", Cx = "⋖", Tx = "⋋", Ax = "⋉", Sx = "⥶", Ix = "⩻", Lx = "◃", Rx = "⊴", Mx = "◂", Nx = "⦖", Ox = "⥊", Dx = "⥦", Bx = "≨︀", Px = "≨︀", Hx = "¯", Ux = "♂", zx = "✠", Fx = "✠", qx = "↦", jx = "↦", $x = "↧", Vx = "↤", Kx = "↥", Gx = "▮", Wx = "⨩", Zx = "М", Xx = "м", Jx = "—", Yx = "∺", Qx = "∡", eE = " ", tE = "ℳ", rE = "𝔐", nE = "𝔪", iE = "℧", aE = "µ", oE = "*", sE = "⫰", cE = "∣", uE = "·", fE = "⊟", dE = "−", hE = "∸", pE = "⨪", mE = "∓", vE = "⫛", bE = "…", yE = "∓", kE = "⊧", _E = "𝕄", wE = "𝕞", xE = "∓", EE = "𝓂", CE = "ℳ", TE = "∾", AE = "Μ", SE = "μ", IE = "⊸", LE = "⊸", RE = "∇", ME = "Ń", NE = "ń", OE = "∠⃒", DE = "≉", BE = "⩰̸", PE = "≋̸", HE = "ŉ", UE = "≉", zE = "♮", FE = "ℕ", qE = "♮", jE = " ", $E = "≎̸", VE = "≏̸", KE = "⩃", GE = "Ň", WE = "ň", ZE = "Ņ", XE = "ņ", JE = "≇", YE = "⩭̸", QE = "⩂", eC = "Н", tC = "н", rC = "–", nC = "⤤", iC = "↗", aC = "⇗", oC = "↗", sC = "≠", lC = "≐̸", cC = "​", uC = "​", fC = "​", dC = "​", hC = "≢", pC = "⤨", gC = "≂̸", mC = "≫", vC = "≪", bC = `
`, yC = "∄", kC = "∄", _C = "𝔑", wC = "𝔫", xC = "≧̸", EC = "≱", CC = "≱", TC = "≧̸", AC = "⩾̸", SC = "⩾̸", IC = "⋙̸", LC = "≵", RC = "≫⃒", MC = "≯", NC = "≯", OC = "≫̸", DC = "↮", BC = "⇎", PC = "⫲", HC = "∋", UC = "⋼", zC = "⋺", FC = "∋", qC = "Њ", jC = "њ", $C = "↚", VC = "⇍", KC = "‥", GC = "≦̸", WC = "≰", ZC = "↚", XC = "⇍", JC = "↮", YC = "⇎", QC = "≰", eT = "≦̸", tT = "⩽̸", rT = "⩽̸", nT = "≮", iT = "⋘̸", aT = "≴", oT = "≪⃒", sT = "≮", lT = "⋪", cT = "⋬", uT = "≪̸", fT = "∤", dT = "⁠", hT = " ", pT = "𝕟", gT = "ℕ", mT = "⫬", vT = "¬", bT = "≢", yT = "≭", kT = "∦", _T = "∉", wT = "≠", xT = "≂̸", ET = "∄", CT = "≯", TT = "≱", AT = "≧̸", ST = "≫̸", IT = "≹", RT = "⩾̸", MT = "≵", NT = "≎̸", OT = "≏̸", DT = "∉", BT = "⋵̸", PT = "⋹̸", HT = "∉", UT = "⋷", zT = "⋶", FT = "⧏̸", qT = "⋪", jT = "⋬", $T = "≮", VT = "≰", KT = "≸", WT = "≪̸", ZT = "⩽̸", XT = "≴", JT = "⪢̸", YT = "⪡̸", QT = "∌", e3 = "∌", t3 = "⋾", r3 = "⋽", n3 = "⊀", i3 = "⪯̸", a3 = "⋠", o3 = "∌", s3 = "⧐̸", l3 = "⋫", c3 = "⋭", u3 = "⊏̸", f3 = "⋢", d3 = "⊐̸", h3 = "⋣", p3 = "⊂⃒", g3 = "⊈", m3 = "⊁", v3 = "⪰̸", b3 = "⋡", y3 = "≿̸", k3 = "⊃⃒", _3 = "⊉", w3 = "≁", x3 = "≄", E3 = "≇", C3 = "≉", T3 = "∤", A3 = "∦", S3 = "∦", I3 = "⫽⃥", L3 = "∂̸", R3 = "⨔", M3 = "⊀", N3 = "⋠", O3 = "⊀", D3 = "⪯̸", B3 = "⪯̸", P3 = "⤳̸", H3 = "↛", U3 = "⇏", z3 = "↝̸", F3 = "↛", q3 = "⇏", j3 = "⋫", $3 = "⋭", V3 = "⊁", K3 = "⋡", G3 = "⪰̸", W3 = "𝒩", Z3 = "𝓃", X3 = "∤", J3 = "∦", Y3 = "≁", Q3 = "≄", eA = "≄", tA = "∤", rA = "∦", nA = "⋢", iA = "⋣", aA = "⊄", oA = "⫅̸", sA = "⊈", lA = "⊂⃒", cA = "⊈", uA = "⫅̸", fA = "⊁", dA = "⪰̸", hA = "⊅", pA = "⫆̸", gA = "⊉", mA = "⊃⃒", vA = "⊉", bA = "⫆̸", yA = "≹", kA = "Ñ", _A = "ñ", wA = "≸", xA = "⋪", EA = "⋬", CA = "⋫", TA = "⋭", AA = "Ν", SA = "ν", IA = "#", LA = "№", RA = " ", MA = "≍⃒", NA = "⊬", OA = "⊭", DA = "⊮", BA = "⊯", PA = "≥⃒", HA = ">⃒", UA = "⤄", zA = "⧞", FA = "⤂", qA = "≤⃒", jA = "<⃒", $A = "⊴⃒", VA = "⤃", KA = "⊵⃒", GA = "∼⃒", WA = "⤣", ZA = "↖", XA = "⇖", JA = "↖", YA = "⤧", QA = "Ó", eS = "ó", tS = "⊛", rS = "Ô", nS = "ô", iS = "⊚", aS = "О", sS = "о", lS = "⊝", cS = "Ő", uS = "ő", fS = "⨸", dS = "⊙", hS = "⦼", pS = "Œ", gS = "œ", mS = "⦿", vS = "𝔒", bS = "𝔬", yS = "˛", kS = "Ò", _S = "ò", wS = "⧁", xS = "⦵", ES = "Ω", CS = "∮", TS = "↺", AS = "⦾", SS = "⦻", IS = "‾", LS = "⧀", RS = "Ō", MS = "ō", NS = "Ω", OS = "ω", DS = "Ο", BS = "ο", PS = "⦶", HS = "⊖", US = "𝕆", zS = "𝕠", FS = "⦷", qS = "“", jS = "‘", $S = "⦹", VS = "⊕", KS = "↻", GS = "⩔", WS = "∨", ZS = "⩝", XS = "ℴ", YS = "ℴ", QS = "ª", e5 = "º", t5 = "⊶", r5 = "⩖", n5 = "⩗", i5 = "⩛", a5 = "Ⓢ", o5 = "𝒪", s5 = "ℴ", l5 = "Ø", c5 = "ø", u5 = "⊘", f5 = "Õ", d5 = "õ", h5 = "⨶", p5 = "⨷", g5 = "⊗", m5 = "Ö", v5 = "ö", b5 = "⌽", y5 = "‾", k5 = "⏞", _5 = "⎴", w5 = "⏜", x5 = "¶", E5 = "∥", C5 = "∥", T5 = "⫳", A5 = "⫽", S5 = "∂", I5 = "∂", L5 = "П", R5 = "п", M5 = "%", N5 = ".", O5 = "‰", D5 = "⊥", B5 = "‱", P5 = "𝔓", H5 = "𝔭", U5 = "Φ", z5 = "φ", F5 = "ϕ", q5 = "ℳ", j5 = "☎", $5 = "Π", V5 = "π", K5 = "⋔", G5 = "ϖ", W5 = "ℏ", Z5 = "ℎ", X5 = "ℏ", J5 = "⨣", Y5 = "⊞", Q5 = "⨢", eI = "+", tI = "∔", rI = "⨥", nI = "⩲", iI = "±", aI = "±", oI = "⨦", sI = "⨧", lI = "±", cI = "ℌ", uI = "⨕", fI = "𝕡", dI = "ℙ", hI = "£", pI = "⪷", gI = "⪻", mI = "≺", vI = "≼", bI = "⪷", yI = "≺", kI = "≼", _I = "≺", wI = "⪯", xI = "≼", EI = "≾", CI = "⪯", TI = "⪹", AI = "⪵", SI = "⋨", II = "⪯", LI = "⪳", RI = "≾", MI = "′", NI = "″", OI = "ℙ", DI = "⪹", BI = "⪵", PI = "⋨", HI = "∏", UI = "∏", zI = "⌮", FI = "⌒", qI = "⌓", jI = "∝", $I = "∝", VI = "∷", KI = "∝", GI = "≾", WI = "⊰", ZI = "𝒫", XI = "𝓅", JI = "Ψ", YI = "ψ", QI = " ", eL = "𝔔", tL = "𝔮", rL = "⨌", nL = "𝕢", iL = "ℚ", aL = "⁗", oL = "𝒬", sL = "𝓆", lL = "ℍ", cL = "⨖", uL = "?", fL = "≟", dL = '"', hL = '"', pL = "⇛", gL = "∽̱", mL = "Ŕ", vL = "ŕ", bL = "√", yL = "⦳", kL = "⟩", _L = "⟫", wL = "⦒", xL = "⦥", EL = "⟩", CL = "»", TL = "⥵", AL = "⇥", SL = "⤠", IL = "⤳", LL = "→", RL = "↠", ML = "⇒", NL = "⤞", OL = "↪", DL = "↬", BL = "⥅", PL = "⥴", HL = "⤖", UL = "↣", zL = "↝", FL = "⤚", qL = "⤜", jL = "∶", $L = "ℚ", VL = "⤍", KL = "⤏", GL = "⤐", WL = "❳", ZL = "}", XL = "]", JL = "⦌", YL = "⦎", QL = "⦐", e4 = "Ř", t4 = "ř", r4 = "Ŗ", n4 = "ŗ", i4 = "⌉", a4 = "}", o4 = "Р", s4 = "р", l4 = "⤷", c4 = "⥩", u4 = "”", f4 = "”", d4 = "↳", h4 = "ℜ", p4 = "ℛ", g4 = "ℜ", m4 = "ℝ", v4 = "ℜ", b4 = "▭", y4 = "®", k4 = "®", _4 = "∋", w4 = "⇋", x4 = "⥯", E4 = "⥽", C4 = "⌋", T4 = "𝔯", A4 = "ℜ", S4 = "⥤", I4 = "⇁", L4 = "⇀", R4 = "⥬", M4 = "Ρ", N4 = "ρ", O4 = "ϱ", D4 = "⟩", B4 = "⇥", P4 = "→", H4 = "→", U4 = "⇒", z4 = "⇄", F4 = "↣", q4 = "⌉", j4 = "⟧", $4 = "⥝", V4 = "⥕", K4 = "⇂", G4 = "⌋", W4 = "⇁", Z4 = "⇀", X4 = "⇄", J4 = "⇌", Y4 = "⇉", Q4 = "↝", eR = "↦", tR = "⊢", rR = "⥛", nR = "⋌", iR = "⧐", aR = "⊳", oR = "⊵", sR = "⥏", lR = "⥜", cR = "⥔", uR = "↾", fR = "⥓", dR = "⇀", hR = "˚", pR = "≓", gR = "⇄", mR = "⇌", vR = "‏", bR = "⎱", yR = "⎱", kR = "⫮", _R = "⟭", wR = "⇾", xR = "⟧", ER = "⦆", CR = "𝕣", TR = "ℝ", AR = "⨮", SR = "⨵", IR = "⥰", LR = ")", RR = "⦔", MR = "⨒", NR = "⇉", OR = "⇛", DR = "›", BR = "𝓇", PR = "ℛ", HR = "↱", UR = "↱", zR = "]", FR = "’", qR = "’", jR = "⋌", $R = "⋊", VR = "▹", KR = "⊵", GR = "▸", WR = "⧎", ZR = "⧴", XR = "⥨", JR = "℞", YR = "Ś", QR = "ś", eM = "‚", tM = "⪸", rM = "Š", nM = "š", iM = "⪼", aM = "≻", oM = "≽", sM = "⪰", lM = "⪴", cM = "Ş", uM = "ş", fM = "Ŝ", dM = "ŝ", hM = "⪺", pM = "⪶", gM = "⋩", mM = "⨓", vM = "≿", bM = "С", yM = "с", kM = "⊡", _M = "⋅", wM = "⩦", xM = "⤥", EM = "↘", CM = "⇘", TM = "↘", AM = "§", SM = ";", IM = "⤩", LM = "∖", RM = "∖", MM = "✶", NM = "𝔖", OM = "𝔰", DM = "⌢", BM = "♯", PM = "Щ", HM = "щ", UM = "Ш", zM = "ш", FM = "↓", qM = "←", jM = "∣", $M = "∥", VM = "→", KM = "↑", GM = "­", WM = "Σ", ZM = "σ", XM = "ς", JM = "ς", YM = "∼", QM = "⩪", eN = "≃", tN = "≃", rN = "⪞", nN = "⪠", iN = "⪝", aN = "⪟", oN = "≆", sN = "⨤", lN = "⥲", cN = "←", uN = "∘", fN = "∖", dN = "⨳", hN = "⧤", pN = "∣", gN = "⌣", mN = "⪪", vN = "⪬", bN = "⪬︀", yN = "Ь", kN = "ь", _N = "⌿", wN = "⧄", xN = "/", EN = "𝕊", CN = "𝕤", TN = "♠", AN = "♠", SN = "∥", IN = "⊓", LN = "⊓︀", RN = "⊔", MN = "⊔︀", NN = "√", ON = "⊏", DN = "⊑", BN = "⊏", PN = "⊑", HN = "⊐", UN = "⊒", zN = "⊐", FN = "⊒", qN = "□", jN = "□", $N = "⊓", VN = "⊏", KN = "⊑", GN = "⊐", WN = "⊒", ZN = "⊔", XN = "▪", JN = "□", YN = "▪", QN = "→", e8 = "𝒮", t8 = "𝓈", r8 = "∖", n8 = "⌣", i8 = "⋆", a8 = "⋆", o8 = "☆", s8 = "★", l8 = "ϵ", c8 = "ϕ", u8 = "¯", f8 = "⊂", d8 = "⋐", h8 = "⪽", p8 = "⫅", g8 = "⊆", m8 = "⫃", v8 = "⫁", b8 = "⫋", y8 = "⊊", k8 = "⪿", _8 = "⥹", w8 = "⊂", x8 = "⋐", E8 = "⊆", C8 = "⫅", T8 = "⊆", A8 = "⊊", S8 = "⫋", I8 = "⫇", L8 = "⫕", R8 = "⫓", M8 = "⪸", N8 = "≻", O8 = "≽", D8 = "≻", B8 = "⪰", P8 = "≽", H8 = "≿", U8 = "⪰", z8 = "⪺", F8 = "⪶", q8 = "⋩", j8 = "≿", $8 = "∋", V8 = "∑", K8 = "∑", G8 = "♪", W8 = "¹", Z8 = "²", X8 = "³", J8 = "⊃", Y8 = "⋑", Q8 = "⪾", eO = "⫘", tO = "⫆", rO = "⊇", nO = "⫄", iO = "⊃", aO = "⊇", oO = "⟉", sO = "⫗", lO = "⥻", cO = "⫂", uO = "⫌", fO = "⊋", dO = "⫀", hO = "⊃", pO = "⋑", gO = "⊇", mO = "⫆", vO = "⊋", bO = "⫌", yO = "⫈", kO = "⫔", _O = "⫖", wO = "⤦", xO = "↙", EO = "⇙", CO = "↙", TO = "⤪", AO = "ß", SO = "	", IO = "⌖", LO = "Τ", RO = "τ", MO = "⎴", NO = "Ť", OO = "ť", DO = "Ţ", BO = "ţ", PO = "Т", HO = "т", UO = "⃛", zO = "⌕", FO = "𝔗", qO = "𝔱", jO = "∴", $O = "∴", VO = "∴", KO = "Θ", GO = "θ", WO = "ϑ", ZO = "ϑ", XO = "≈", JO = "∼", YO = "  ", QO = " ", e6 = " ", t6 = "≈", r6 = "∼", n6 = "Þ", i6 = "þ", a6 = "˜", o6 = "∼", s6 = "≃", l6 = "≅", c6 = "≈", u6 = "⨱", f6 = "⊠", d6 = "×", h6 = "⨰", p6 = "∭", g6 = "⤨", m6 = "⌶", v6 = "⫱", b6 = "⊤", y6 = "𝕋", k6 = "𝕥", _6 = "⫚", w6 = "⤩", x6 = "‴", E6 = "™", C6 = "™", T6 = "▵", A6 = "▿", S6 = "◃", I6 = "⊴", L6 = "≜", R6 = "▹", M6 = "⊵", N6 = "◬", O6 = "≜", D6 = "⨺", B6 = "⃛", P6 = "⨹", H6 = "⧍", U6 = "⨻", z6 = "⏢", F6 = "𝒯", q6 = "𝓉", j6 = "Ц", $6 = "ц", V6 = "Ћ", K6 = "ћ", G6 = "Ŧ", W6 = "ŧ", Z6 = "≬", X6 = "↞", J6 = "↠", Y6 = "Ú", Q6 = "ú", eD = "↑", tD = "↟", rD = "⇑", nD = "⥉", iD = "Ў", aD = "ў", oD = "Ŭ", sD = "ŭ", lD = "Û", cD = "û", uD = "У", fD = "у", dD = "⇅", hD = "Ű", pD = "ű", gD = "⥮", mD = "⥾", vD = "𝔘", bD = "𝔲", yD = "Ù", kD = "ù", _D = "⥣", wD = "↿", xD = "↾", ED = "▀", CD = "⌜", TD = "⌜", AD = "⌏", SD = "◸", ID = "Ū", LD = "ū", RD = "¨", MD = "_", ND = "⏟", OD = "⎵", BD = "⏝", PD = "⋃", HD = "⊎", UD = "Ų", zD = "ų", FD = "𝕌", qD = "𝕦", jD = "⤒", $D = "↑", VD = "↑", KD = "⇑", GD = "⇅", WD = "↕", ZD = "↕", XD = "⇕", JD = "⥮", YD = "↿", QD = "↾", eB = "⊎", tB = "↖", rB = "↗", nB = "υ", iB = "ϒ", aB = "ϒ", oB = "Υ", sB = "υ", lB = "↥", cB = "⊥", uB = "⇈", fB = "⌝", dB = "⌝", hB = "⌎", pB = "Ů", gB = "ů", mB = "◹", vB = "𝒰", bB = "𝓊", yB = "⋰", kB = "Ũ", _B = "ũ", wB = "▵", xB = "▴", EB = "⇈", CB = "Ü", TB = "ü", AB = "⦧", SB = "⦜", IB = "ϵ", LB = "ϰ", RB = "∅", MB = "ϕ", NB = "ϖ", OB = "∝", DB = "↕", BB = "⇕", PB = "ϱ", HB = "ς", UB = "⊊︀", zB = "⫋︀", FB = "⊋︀", qB = "⫌︀", jB = "ϑ", $B = "⊲", VB = "⊳", KB = "⫨", GB = "⫫", WB = "⫩", ZB = "В", XB = "в", JB = "⊢", YB = "⊨", QB = "⊩", eP = "⊫", tP = "⫦", rP = "⊻", nP = "∨", iP = "⋁", aP = "≚", oP = "⋮", sP = "|", lP = "‖", cP = "|", uP = "‖", fP = "∣", dP = "|", hP = "❘", pP = "≀", gP = " ", mP = "𝔙", vP = "𝔳", bP = "⊲", yP = "⊂⃒", kP = "⊃⃒", _P = "𝕍", wP = "𝕧", xP = "∝", EP = "⊳", CP = "𝒱", TP = "𝓋", AP = "⫋︀", SP = "⊊︀", IP = "⫌︀", LP = "⊋︀", RP = "⊪", MP = "⦚", NP = "Ŵ", OP = "ŵ", DP = "⩟", BP = "∧", PP = "⋀", HP = "≙", UP = "℘", zP = "𝔚", FP = "𝔴", qP = "𝕎", jP = "𝕨", $P = "℘", VP = "≀", KP = "≀", GP = "𝒲", WP = "𝓌", ZP = "⋂", XP = "◯", JP = "⋃", YP = "▽", QP = "𝔛", e7 = "𝔵", t7 = "⟷", r7 = "⟺", n7 = "Ξ", i7 = "ξ", a7 = "⟵", o7 = "⟸", s7 = "⟼", l7 = "⋻", c7 = "⨀", u7 = "𝕏", f7 = "𝕩", d7 = "⨁", h7 = "⨂", p7 = "⟶", g7 = "⟹", m7 = "𝒳", v7 = "𝓍", b7 = "⨆", y7 = "⨄", k7 = "△", _7 = "⋁", w7 = "⋀", x7 = "Ý", E7 = "ý", C7 = "Я", T7 = "я", A7 = "Ŷ", S7 = "ŷ", I7 = "Ы", L7 = "ы", R7 = "¥", M7 = "𝔜", N7 = "𝔶", O7 = "Ї", D7 = "ї", B7 = "𝕐", P7 = "𝕪", H7 = "𝒴", U7 = "𝓎", z7 = "Ю", F7 = "ю", q7 = "ÿ", j7 = "Ÿ", $7 = "Ź", V7 = "ź", K7 = "Ž", G7 = "ž", W7 = "З", Z7 = "з", X7 = "Ż", J7 = "ż", Y7 = "ℨ", Q7 = "​", e9 = "Ζ", t9 = "ζ", r9 = "𝔷", n9 = "ℨ", i9 = "Ж", a9 = "ж", o9 = "⇝", s9 = "𝕫", l9 = "ℤ", c9 = "𝒵", u9 = "𝓏", f9 = "‍", d9 = "‌", Qu = {
            Aacute: Xr,
            aacute: Jr,
            Abreve: li,
            abreve: Qr,
            ac: ei,
            acd: ui,
            acE: Ai,
            Acirc: fi,
            acirc: gi,
            acute: Ci,
            Acy: mi,
            acy: vi,
            AElig: Ri,
            aelig: di,
            af: Ti,
            Afr: qi,
            afr: ki,
            Agrave: Ji,
            agrave: Bi,
            alefsym: Ni,
            aleph: Mi,
            Alpha: bi,
            alpha: Ei,
            Amacr: Si,
            amacr: Vi,
            amalg: Di,
            amp: sa,
            AMP: ra,
            andand: fa,
            And: ba,
            and: Ua,
            andd: Va,
            andslope: Ma,
            andv: Fi,
            ang: na,
            ange: Gi,
            angle: Ca,
            angmsdaa: $a,
            angmsdab: no,
            angmsdac: ga,
            angmsdad: pa,
            angmsdae: Sa,
            angmsdaf: Na,
            angmsdag: Oa,
            angmsdah: Ja,
            angmsd: za,
            angrt: Ia,
            angrtvb: Yi,
            angrtvbd: La,
            angsph: Ka,
            angst: Qa,
            angzarr: Hi,
            Aogon: da,
            aogon: aa,
            Aopf: oa,
            aopf: ja,
            apacir: Ga,
            ap: xa,
            apE: qa,
            ape: Ya,
            apid: Za,
            apos: ko,
            ApplyFunction: lo,
            approx: so,
            approxeq: ho,
            Aring: Ro,
            aring: Mo,
            Ascr: Co,
            ascr: uo,
            Assign: wa,
            ast: $i,
            asymp: ca,
            asympeq: ci,
            Atilde: ti,
            atilde: Ur,
            Auml: qr,
            auml: Yr,
            awconint: si,
            awint: yi,
            backcong: Ii,
            backepsilon: Ki,
            backprime: ta,
            backsim: va,
            backsimeq: ua,
            Backslash: ma,
            Barv: Fa,
            barvee: fo,
            barwed: _o,
            Barwed: No,
            barwedge: Bo,
            bbrk: Po,
            bbrktbrk: ds,
            bcong: Ho,
            Bcy: hs,
            bcy: Fs,
            bdquo: ps,
            becaus: rs,
            because: ns,
            Because: is,
            bemptyv: qs,
            bepsi: js,
            bernou: Ls,
            Bernoullis: Rs,
            Beta: $s,
            beta: Vs,
            beth: gs,
            between: To,
            Bfr: vs,
            bfr: as,
            bigcap: Uo,
            bigcirc: ss,
            bigcup: wl,
            bigodot: ls,
            bigoplus: Yo,
            bigotimes: xl,
            bigsqcup: Ks,
            bigstar: Ms,
            bigtriangledown: Gs,
            bigtriangleup: bs,
            biguplus: Ns,
            bigvee: cl,
            bigwedge: Fo,
            bkarow: ul,
            blacklozenge: fl,
            blacksquare: Os,
            blacktriangle: Ws,
            blacktriangledown: ys,
            blacktriangleleft: qo,
            blacktriangleright: Zs,
            blank: Xs,
            blk12: Js,
            blk14: Ys,
            blk34: Ba,
            block: Zi,
            bne: ya,
            bnequiv: Ra,
            bNot: io,
            bnot: wo,
            Bopf: xo,
            bopf: ro,
            bot: po,
            bottom: ks,
            bowtie: dl,
            boxbox: El,
            boxdl: Qo,
            boxdL: Lc,
            boxDl: Cl,
            boxDL: Tl,
            boxdr: Rc,
            boxdR: Mc,
            boxDr: hl,
            boxDR: Nc,
            boxh: Al,
            boxH: Ds,
            boxhd: Oc,
            boxHd: Dc,
            boxhD: Bc,
            boxHD: Pc,
            boxhu: Hc,
            boxHu: Uc,
            boxhU: Sl,
            boxHU: Hl,
            boxminus: zc,
            boxplus: Ul,
            boxtimes: Fc,
            boxul: zl,
            boxuL: Fl,
            boxUl: qc,
            boxUL: Qs,
            boxur: jc,
            boxuR: tl,
            boxUr: $c,
            boxUR: Vc,
            boxv: rl,
            boxV: ql,
            boxvh: jl,
            boxvH: $l,
            boxVh: Vl,
            boxVH: nl,
            boxvl: Gl,
            boxvL: il,
            boxVl: Kc,
            boxVL: _s,
            boxvr: Bs,
            boxvR: ws,
            boxVr: jo,
            boxVR: Io,
            bprime: Wl,
            breve: Gc,
            Breve: Zl,
            brvbar: Wc,
            bscr: Xl,
            Bscr: Jl,
            bsemi: pl,
            bsim: xs,
            bsime: Il,
            bsolb: Yl,
            bsol: Rl,
            bsolhsub: Zc,
            bull: Xc,
            bullet: Jc,
            bump: Yc,
            bumpE: Ql,
            bumpe: ec,
            Bumpeq: Qc,
            bumpeq: eu,
            Cacute: tu,
            cacute: ru,
            capand: iu,
            capbrcup: au,
            capcap: tc,
            cap: ou,
            Cap: su,
            capcup: Ml,
            capdot: lu,
            CapitalDifferentialD: rc,
            caps: cu,
            caret: uu,
            caron: fu,
            Cayleys: du,
            ccaps: nc,
            Ccaron: oc,
            ccaron: lc,
            Ccedil: hu,
            ccedil: cc,
            Ccirc: pu,
            ccirc: uc,
            Cconint: Lr,
            ccups: jr,
            ccupssm: Rr,
            Cdot: Fr,
            cdot: Vr,
            cedil: Wr,
            Cedilla: ri,
            cemptyv: ai,
            cent: hi,
            centerdot: wi,
            CenterDot: Oi,
            cfr: Wi,
            Cfr: zi,
            CHcy: Qi,
            chcy: ia,
            check: Ta,
            checkmark: Da,
            Chi: ha,
            chi: co,
            circ: Xa,
            circeq: ao,
            circlearrowleft: Wa,
            circlearrowright: eo,
            circledast: mo,
            circledcirc: Do,
            circleddash: $o,
            CircleDot: Ao,
            circledR: Zo,
            circledS: Oo,
            CircleMinus: Ps,
            CirclePlus: Xo,
            CircleTimes: Hs,
            cir: Vo,
            cirE: vo,
            cire: fc,
            cirfnint: gu,
            cirmid: ml,
            cirscir: Es,
            ClockwiseContourIntegral: dc,
            CloseCurlyDoubleQuote: hc,
            CloseCurlyQuote: Td,
            clubs: Ad,
            clubsuit: Sd,
            colon: Ld,
            Colon: Rd,
            Colone: Md,
            colone: Nd,
            coloneq: Od,
            comma: Dd,
            commat: Bd,
            comp: Pd,
            compfn: Hd,
            complement: Ud,
            complexes: zd,
            cong: Fd,
            congdot: qd,
            Congruent: jd,
            conint: $d,
            Conint: Vd,
            ContourIntegral: Kd,
            copf: Gd,
            Copf: Wd,
            coprod: Zd,
            Coproduct: Xd,
            copy: Jd,
            COPY: Yd,
            copysr: Qd,
            CounterClockwiseContourIntegral: eh,
            crarr: th,
            cross: rh,
            Cross: nh,
            Cscr: ih,
            cscr: ah,
            csub: oh,
            csube: sh,
            csup: lh,
            csupe: ch,
            ctdot: uh,
            cudarrl: fh,
            cudarrr: dh,
            cuepr: hh,
            cuesc: ph,
            cularr: gh,
            cularrp: mh,
            cupbrcap: vh,
            cupcap: bh,
            CupCap: yh,
            cup: kh,
            Cup: _h,
            cupcup: wh,
            cupdot: xh,
            cupor: Eh,
            cups: Ch,
            curarr: Th,
            curarrm: Ah,
            curlyeqprec: Sh,
            curlyeqsucc: Ih,
            curlyvee: Lh,
            curlywedge: Rh,
            curren: Mh,
            curvearrowleft: Nh,
            curvearrowright: Oh,
            cuvee: Dh,
            cuwed: Bh,
            cwconint: Ph,
            cwint: Hh,
            cylcty: Uh,
            dagger: zh,
            Dagger: Fh,
            daleth: qh,
            darr: jh,
            Darr: $h,
            dArr: Vh,
            dash: Kh,
            Dashv: Gh,
            dashv: Wh,
            dbkarow: Zh,
            dblac: Xh,
            Dcaron: Jh,
            dcaron: Yh,
            Dcy: Qh,
            dcy: ep,
            ddagger: tp,
            ddarr: rp,
            DD: np,
            dd: ip,
            DDotrahd: op,
            ddotseq: sp,
            deg: lp,
            Del: cp,
            Delta: up,
            delta: fp,
            demptyv: dp,
            dfisht: hp,
            Dfr: pp,
            dfr: gp,
            dHar: vp,
            dharl: bp,
            dharr: yp,
            DiacriticalAcute: kp,
            DiacriticalDot: _p,
            DiacriticalDoubleAcute: xp,
            DiacriticalGrave: Ep,
            DiacriticalTilde: Cp,
            diam: Tp,
            diamond: Ap,
            Diamond: Sp,
            diamondsuit: Ip,
            diams: Lp,
            die: Rp,
            DifferentialD: Mp,
            digamma: Np,
            disin: Op,
            div: Dp,
            divide: Bp,
            divideontimes: Pp,
            divonx: Hp,
            DJcy: Up,
            djcy: zp,
            dlcorn: qp,
            dlcrop: jp,
            dollar: $p,
            Dopf: Vp,
            dopf: Kp,
            Dot: Gp,
            dot: Wp,
            DotDot: Zp,
            doteq: Xp,
            doteqdot: Jp,
            DotEqual: Yp,
            dotminus: Qp,
            dotplus: tg,
            dotsquare: rg,
            doublebarwedge: ng,
            DoubleContourIntegral: ig,
            DoubleDot: ag,
            DoubleDownArrow: og,
            DoubleLeftArrow: sg,
            DoubleLeftRightArrow: cg,
            DoubleLeftTee: ug,
            DoubleLongLeftArrow: fg,
            DoubleLongLeftRightArrow: dg,
            DoubleLongRightArrow: hg,
            DoubleRightArrow: pg,
            DoubleRightTee: mg,
            DoubleUpArrow: vg,
            DoubleUpDownArrow: bg,
            DoubleVerticalBar: yg,
            DownArrowBar: kg,
            downarrow: _g,
            DownArrow: wg,
            Downarrow: xg,
            DownArrowUpArrow: Eg,
            DownBreve: Cg,
            downdownarrows: Tg,
            downharpoonleft: Ag,
            downharpoonright: Sg,
            DownLeftRightVector: Ig,
            DownLeftTeeVector: Lg,
            DownLeftVectorBar: Rg,
            DownLeftVector: Mg,
            DownRightTeeVector: Ng,
            DownRightVectorBar: Og,
            DownRightVector: Dg,
            DownTeeArrow: Bg,
            DownTee: Pg,
            drbkarow: Hg,
            drcorn: Ug,
            drcrop: zg,
            Dscr: Fg,
            dscr: qg,
            DScy: jg,
            dscy: $g,
            dsol: Vg,
            Dstrok: Kg,
            dstrok: Wg,
            dtdot: Zg,
            dtri: Xg,
            dtrif: Jg,
            duarr: Yg,
            duhar: Qg,
            dwangle: em,
            DZcy: tm,
            dzcy: rm,
            dzigrarr: nm,
            Eacute: im,
            eacute: am,
            easter: om,
            Ecaron: sm,
            ecaron: lm,
            Ecirc: cm,
            ecirc: um,
            ecir: fm,
            ecolon: dm,
            Ecy: hm,
            ecy: gm,
            eDDot: mm,
            Edot: vm,
            edot: bm,
            eDot: ym,
            ee: km,
            efDot: _m,
            Efr: wm,
            efr: xm,
            eg: Em,
            Egrave: Cm,
            egrave: Tm,
            egs: Am,
            egsdot: Sm,
            el: Lm,
            Element: Rm,
            elinters: Mm,
            ell: Nm,
            els: Om,
            elsdot: Dm,
            Emacr: Bm,
            emacr: Pm,
            empty: Hm,
            emptyset: Um,
            EmptySmallSquare: zm,
            emptyv: Fm,
            EmptyVerySmallSquare: qm,
            emsp13: jm,
            emsp14: $m,
            emsp: Vm,
            ENG: Km,
            eng: Gm,
            ensp: Wm,
            Eogon: Zm,
            eogon: Xm,
            Eopf: Jm,
            eopf: Ym,
            epar: Qm,
            eparsl: ev,
            eplus: tv,
            epsi: rv,
            Epsilon: nv,
            epsilon: iv,
            epsiv: av,
            eqcirc: ov,
            eqcolon: sv,
            eqsim: lv,
            eqslantgtr: cv,
            eqslantless: uv,
            Equal: fv,
            equals: dv,
            EqualTilde: hv,
            equest: pv,
            Equilibrium: gv,
            equiv: mv,
            equivDD: vv,
            eqvparsl: bv,
            erarr: yv,
            erDot: kv,
            escr: _v,
            Escr: wv,
            esdot: xv,
            Esim: Ev,
            esim: Cv,
            Eta: Tv,
            eta: Av,
            ETH: Sv,
            eth: Iv,
            Euml: Lv,
            euml: Rv,
            euro: Mv,
            excl: Nv,
            exist: Ov,
            Exists: Dv,
            expectation: Bv,
            exponentiale: Pv,
            ExponentialE: Hv,
            fallingdotseq: Uv,
            Fcy: zv,
            fcy: Fv,
            female: qv,
            ffilig: jv,
            fflig: $v,
            ffllig: Vv,
            Ffr: Kv,
            ffr: Gv,
            filig: Wv,
            FilledSmallSquare: Zv,
            FilledVerySmallSquare: Xv,
            fjlig: Jv,
            flat: Yv,
            fllig: Qv,
            fltns: eb,
            fnof: tb,
            Fopf: rb,
            fopf: nb,
            forall: ib,
            ForAll: ab,
            fork: ob,
            forkv: sb,
            Fouriertrf: lb,
            fpartint: cb,
            frac12: ub,
            frac13: fb,
            frac14: hb,
            frac15: pb,
            frac16: gb,
            frac18: mb,
            frac23: vb,
            frac25: bb,
            frac34: yb,
            frac35: kb,
            frac38: _b,
            frac45: wb,
            frac56: xb,
            frac58: Eb,
            frac78: Cb,
            frasl: Tb,
            frown: Ab,
            fscr: Sb,
            Fscr: Ib,
            gacute: Lb,
            Gamma: Rb,
            gamma: Mb,
            Gammad: Nb,
            gammad: Ob,
            gap: Db,
            Gbreve: Bb,
            gbreve: Pb,
            Gcedil: Hb,
            Gcirc: Ub,
            gcirc: zb,
            Gcy: Fb,
            gcy: qb,
            Gdot: jb,
            gdot: $b,
            ge: Vb,
            gE: Kb,
            gEl: Gb,
            gel: Wb,
            geq: Zb,
            geqq: Xb,
            geqslant: Jb,
            gescc: Yb,
            ges: Qb,
            gesdot: e1,
            gesdoto: t1,
            gesdotol: r1,
            gesl: n1,
            gesles: i1,
            Gfr: a1,
            gfr: o1,
            gg: s1,
            Gg: l1,
            ggg: c1,
            gimel: u1,
            GJcy: f1,
            gjcy: d1,
            gla: h1,
            gl: p1,
            glE: g1,
            glj: m1,
            gnap: v1,
            gnapprox: b1,
            gne: y1,
            gnE: k1,
            gneq: _1,
            gneqq: w1,
            gnsim: x1,
            Gopf: E1,
            gopf: C1,
            grave: T1,
            GreaterEqual: A1,
            GreaterEqualLess: S1,
            GreaterFullEqual: I1,
            GreaterGreater: L1,
            GreaterLess: R1,
            GreaterSlantEqual: M1,
            GreaterTilde: N1,
            Gscr: O1,
            gscr: D1,
            gsim: B1,
            gsime: P1,
            gsiml: H1,
            gtcc: U1,
            gtcir: z1,
            gt: F1,
            GT: q1,
            Gt: j1,
            gtdot: $1,
            gtlPar: V1,
            gtquest: K1,
            gtrapprox: G1,
            gtrarr: W1,
            gtrdot: Z1,
            gtreqless: X1,
            gtreqqless: J1,
            gtrless: Y1,
            gtrsim: Q1,
            gvertneqq: ey,
            gvnE: ty,
            Hacek: ry,
            hairsp: ny,
            half: iy,
            hamilt: ay,
            HARDcy: oy,
            hardcy: sy,
            harrcir: ly,
            harr: cy,
            hArr: uy,
            harrw: fy,
            Hat: dy,
            hbar: hy,
            Hcirc: py,
            hcirc: gy,
            hearts: my,
            heartsuit: vy,
            hellip: by,
            hercon: yy,
            hfr: ky,
            Hfr: _y,
            HilbertSpace: wy,
            hksearow: xy,
            hkswarow: Ey,
            hoarr: Cy,
            homtht: Ty,
            hookleftarrow: Ay,
            hookrightarrow: Sy,
            hopf: Iy,
            Hopf: Ly,
            horbar: Ry,
            HorizontalLine: My,
            hscr: Ny,
            Hscr: Oy,
            hslash: Dy,
            Hstrok: By,
            hstrok: Py,
            HumpDownHump: Hy,
            HumpEqual: Uy,
            hybull: zy,
            hyphen: Fy,
            Iacute: qy,
            iacute: jy,
            ic: $y,
            Icirc: Vy,
            icirc: Ky,
            Icy: Gy,
            icy: Wy,
            Idot: Zy,
            IEcy: Xy,
            iecy: Jy,
            iexcl: Yy,
            iff: Qy,
            ifr: e0,
            Ifr: t0,
            Igrave: r0,
            igrave: n0,
            ii: i0,
            iiiint: a0,
            iiint: o0,
            iinfin: s0,
            iiota: l0,
            IJlig: c0,
            ijlig: u0,
            Imacr: f0,
            imacr: d0,
            image: h0,
            ImaginaryI: p0,
            imagline: g0,
            imagpart: m0,
            imath: v0,
            Im: b0,
            imof: y0,
            imped: k0,
            Implies: _0,
            incare: w0,
            in: "∈",
            infin: x0,
            infintie: E0,
            inodot: C0,
            intcal: T0,
            int: A0,
            Int: S0,
            integers: I0,
            Integral: L0,
            intercal: R0,
            Intersection: M0,
            intlarhk: N0,
            intprod: O0,
            InvisibleComma: D0,
            InvisibleTimes: B0,
            IOcy: P0,
            iocy: H0,
            Iogon: U0,
            iogon: z0,
            Iopf: F0,
            iopf: q0,
            Iota: j0,
            iota: $0,
            iprod: V0,
            iquest: K0,
            iscr: G0,
            Iscr: W0,
            isin: Z0,
            isindot: X0,
            isinE: J0,
            isins: Y0,
            isinsv: Q0,
            isinv: ek,
            it: tk,
            Itilde: rk,
            itilde: nk,
            Iukcy: ik,
            iukcy: ak,
            Iuml: ok,
            iuml: sk,
            Jcirc: lk,
            jcirc: ck,
            Jcy: uk,
            jcy: fk,
            Jfr: dk,
            jfr: hk,
            jmath: pk,
            Jopf: gk,
            jopf: mk,
            Jscr: vk,
            jscr: bk,
            Jsercy: yk,
            jsercy: kk,
            Jukcy: _k,
            jukcy: wk,
            Kappa: xk,
            kappa: Ek,
            kappav: Ck,
            Kcedil: Tk,
            kcedil: Ak,
            Kcy: Sk,
            kcy: Ik,
            Kfr: Lk,
            kfr: Rk,
            kgreen: Mk,
            KHcy: Nk,
            khcy: Ok,
            KJcy: Dk,
            kjcy: Bk,
            Kopf: Pk,
            kopf: Hk,
            Kscr: Uk,
            kscr: zk,
            lAarr: Fk,
            Lacute: qk,
            lacute: jk,
            laemptyv: $k,
            lagran: Vk,
            Lambda: Kk,
            lambda: Gk,
            lang: Wk,
            Lang: Zk,
            langd: Xk,
            langle: Jk,
            lap: Yk,
            Laplacetrf: Qk,
            laquo: e_,
            larrb: t_,
            larrbfs: r_,
            larr: n_,
            Larr: i_,
            lArr: a_,
            larrfs: o_,
            larrhk: s_,
            larrlp: l_,
            larrpl: c_,
            larrsim: u_,
            larrtl: f_,
            latail: d_,
            lAtail: h_,
            lat: p_,
            late: g_,
            lates: m_,
            lbarr: v_,
            lBarr: b_,
            lbbrk: y_,
            lbrace: k_,
            lbrack: __,
            lbrke: w_,
            lbrksld: x_,
            lbrkslu: E_,
            Lcaron: C_,
            lcaron: T_,
            Lcedil: A_,
            lcedil: S_,
            lceil: I_,
            lcub: L_,
            Lcy: R_,
            lcy: M_,
            ldca: N_,
            ldquo: O_,
            ldquor: D_,
            ldrdhar: B_,
            ldrushar: P_,
            ldsh: H_,
            le: U_,
            lE: z_,
            LeftAngleBracket: F_,
            LeftArrowBar: q_,
            leftarrow: j_,
            LeftArrow: $_,
            Leftarrow: V_,
            LeftArrowRightArrow: K_,
            leftarrowtail: G_,
            LeftCeiling: W_,
            LeftDoubleBracket: Z_,
            LeftDownTeeVector: X_,
            LeftDownVectorBar: J_,
            LeftDownVector: Y_,
            LeftFloor: Q_,
            leftharpoondown: ew,
            leftharpoonup: tw,
            leftleftarrows: rw,
            leftrightarrow: nw,
            LeftRightArrow: iw,
            Leftrightarrow: aw,
            leftrightarrows: ow,
            leftrightharpoons: sw,
            leftrightsquigarrow: lw,
            LeftRightVector: cw,
            LeftTeeArrow: uw,
            LeftTee: fw,
            LeftTeeVector: dw,
            leftthreetimes: hw,
            LeftTriangleBar: pw,
            LeftTriangle: gw,
            LeftTriangleEqual: mw,
            LeftUpDownVector: vw,
            LeftUpTeeVector: bw,
            LeftUpVectorBar: yw,
            LeftUpVector: kw,
            LeftVectorBar: _w,
            LeftVector: ww,
            lEg: xw,
            leg: Ew,
            leq: Cw,
            leqq: Tw,
            leqslant: Aw,
            lescc: Sw,
            les: Iw,
            lesdot: Lw,
            lesdoto: Rw,
            lesdotor: Mw,
            lesg: Nw,
            lesges: Ow,
            lessapprox: Dw,
            lessdot: Bw,
            lesseqgtr: Pw,
            lesseqqgtr: Hw,
            LessEqualGreater: Uw,
            LessFullEqual: zw,
            LessGreater: Fw,
            lessgtr: qw,
            LessLess: jw,
            lesssim: $w,
            LessSlantEqual: Vw,
            LessTilde: Kw,
            lfisht: Gw,
            lfloor: Ww,
            Lfr: Zw,
            lfr: Xw,
            lg: Jw,
            lgE: Yw,
            lHar: Qw,
            lhard: e2,
            lharu: t2,
            lharul: r2,
            lhblk: n2,
            LJcy: i2,
            ljcy: a2,
            llarr: o2,
            ll: s2,
            Ll: l2,
            llcorner: c2,
            Lleftarrow: u2,
            llhard: f2,
            lltri: d2,
            Lmidot: h2,
            lmidot: p2,
            lmoustache: g2,
            lmoust: m2,
            lnap: b2,
            lnapprox: y2,
            lne: k2,
            lnE: _2,
            lneq: w2,
            lneqq: x2,
            lnsim: E2,
            loang: C2,
            loarr: T2,
            lobrk: A2,
            longleftarrow: S2,
            LongLeftArrow: I2,
            Longleftarrow: L2,
            longleftrightarrow: R2,
            LongLeftRightArrow: M2,
            Longleftrightarrow: N2,
            longmapsto: O2,
            longrightarrow: D2,
            LongRightArrow: B2,
            Longrightarrow: P2,
            looparrowleft: H2,
            looparrowright: U2,
            lopar: z2,
            Lopf: F2,
            lopf: q2,
            loplus: j2,
            lotimes: $2,
            lowast: V2,
            lowbar: K2,
            LowerLeftArrow: G2,
            LowerRightArrow: W2,
            loz: Z2,
            lozenge: X2,
            lozf: J2,
            lpar: Y2,
            lparlt: Q2,
            lrarr: ex,
            lrcorner: tx,
            lrhar: nx,
            lrhard: ix,
            lrm: ax,
            lrtri: ox,
            lsaquo: sx,
            lscr: lx,
            Lscr: cx,
            lsh: ux,
            Lsh: fx,
            lsim: dx,
            lsime: hx,
            lsimg: px,
            lsqb: gx,
            lsquo: mx,
            lsquor: vx,
            Lstrok: bx,
            lstrok: yx,
            ltcc: kx,
            ltcir: _x,
            lt: wx,
            LT: xx,
            Lt: Ex,
            ltdot: Cx,
            lthree: Tx,
            ltimes: Ax,
            ltlarr: Sx,
            ltquest: Ix,
            ltri: Lx,
            ltrie: Rx,
            ltrif: Mx,
            ltrPar: Nx,
            lurdshar: Ox,
            luruhar: Dx,
            lvertneqq: Bx,
            lvnE: Px,
            macr: Hx,
            male: Ux,
            malt: zx,
            maltese: Fx,
            Map: "⤅",
            map: qx,
            mapsto: jx,
            mapstodown: $x,
            mapstoleft: Vx,
            mapstoup: Kx,
            marker: Gx,
            mcomma: Wx,
            Mcy: Zx,
            mcy: Xx,
            mdash: Jx,
            mDDot: Yx,
            measuredangle: Qx,
            MediumSpace: eE,
            Mellintrf: tE,
            Mfr: rE,
            mfr: nE,
            mho: iE,
            micro: aE,
            midast: oE,
            midcir: sE,
            mid: cE,
            middot: uE,
            minusb: fE,
            minus: dE,
            minusd: hE,
            minusdu: pE,
            MinusPlus: mE,
            mlcp: vE,
            mldr: bE,
            mnplus: yE,
            models: kE,
            Mopf: _E,
            mopf: wE,
            mp: xE,
            mscr: EE,
            Mscr: CE,
            mstpos: TE,
            Mu: AE,
            mu: SE,
            multimap: IE,
            mumap: LE,
            nabla: RE,
            Nacute: ME,
            nacute: NE,
            nang: OE,
            nap: DE,
            napE: BE,
            napid: PE,
            napos: HE,
            napprox: UE,
            natural: zE,
            naturals: FE,
            natur: qE,
            nbsp: jE,
            nbump: $E,
            nbumpe: VE,
            ncap: KE,
            Ncaron: GE,
            ncaron: WE,
            Ncedil: ZE,
            ncedil: XE,
            ncong: JE,
            ncongdot: YE,
            ncup: QE,
            Ncy: eC,
            ncy: tC,
            ndash: rC,
            nearhk: nC,
            nearr: iC,
            neArr: aC,
            nearrow: oC,
            ne: sC,
            nedot: lC,
            NegativeMediumSpace: cC,
            NegativeThickSpace: uC,
            NegativeThinSpace: fC,
            NegativeVeryThinSpace: dC,
            nequiv: hC,
            nesear: pC,
            nesim: gC,
            NestedGreaterGreater: mC,
            NestedLessLess: vC,
            NewLine: bC,
            nexist: yC,
            nexists: kC,
            Nfr: _C,
            nfr: wC,
            ngE: xC,
            nge: EC,
            ngeq: CC,
            ngeqq: TC,
            ngeqslant: AC,
            nges: SC,
            nGg: IC,
            ngsim: LC,
            nGt: RC,
            ngt: MC,
            ngtr: NC,
            nGtv: OC,
            nharr: DC,
            nhArr: BC,
            nhpar: PC,
            ni: HC,
            nis: UC,
            nisd: zC,
            niv: FC,
            NJcy: qC,
            njcy: jC,
            nlarr: $C,
            nlArr: VC,
            nldr: KC,
            nlE: GC,
            nle: WC,
            nleftarrow: ZC,
            nLeftarrow: XC,
            nleftrightarrow: JC,
            nLeftrightarrow: YC,
            nleq: QC,
            nleqq: eT,
            nleqslant: tT,
            nles: rT,
            nless: nT,
            nLl: iT,
            nlsim: aT,
            nLt: oT,
            nlt: sT,
            nltri: lT,
            nltrie: cT,
            nLtv: uT,
            nmid: fT,
            NoBreak: dT,
            NonBreakingSpace: hT,
            nopf: pT,
            Nopf: gT,
            Not: mT,
            not: vT,
            NotCongruent: bT,
            NotCupCap: yT,
            NotDoubleVerticalBar: kT,
            NotElement: _T,
            NotEqual: wT,
            NotEqualTilde: xT,
            NotExists: ET,
            NotGreater: CT,
            NotGreaterEqual: TT,
            NotGreaterFullEqual: AT,
            NotGreaterGreater: ST,
            NotGreaterLess: IT,
            NotGreaterSlantEqual: RT,
            NotGreaterTilde: MT,
            NotHumpDownHump: NT,
            NotHumpEqual: OT,
            notin: DT,
            notindot: BT,
            notinE: PT,
            notinva: HT,
            notinvb: UT,
            notinvc: zT,
            NotLeftTriangleBar: FT,
            NotLeftTriangle: qT,
            NotLeftTriangleEqual: jT,
            NotLess: $T,
            NotLessEqual: VT,
            NotLessGreater: KT,
            NotLessLess: WT,
            NotLessSlantEqual: ZT,
            NotLessTilde: XT,
            NotNestedGreaterGreater: JT,
            NotNestedLessLess: YT,
            notni: QT,
            notniva: e3,
            notnivb: t3,
            notnivc: r3,
            NotPrecedes: n3,
            NotPrecedesEqual: i3,
            NotPrecedesSlantEqual: a3,
            NotReverseElement: o3,
            NotRightTriangleBar: s3,
            NotRightTriangle: l3,
            NotRightTriangleEqual: c3,
            NotSquareSubset: u3,
            NotSquareSubsetEqual: f3,
            NotSquareSuperset: d3,
            NotSquareSupersetEqual: h3,
            NotSubset: p3,
            NotSubsetEqual: g3,
            NotSucceeds: m3,
            NotSucceedsEqual: v3,
            NotSucceedsSlantEqual: b3,
            NotSucceedsTilde: y3,
            NotSuperset: k3,
            NotSupersetEqual: _3,
            NotTilde: w3,
            NotTildeEqual: x3,
            NotTildeFullEqual: E3,
            NotTildeTilde: C3,
            NotVerticalBar: T3,
            nparallel: A3,
            npar: S3,
            nparsl: I3,
            npart: L3,
            npolint: R3,
            npr: M3,
            nprcue: N3,
            nprec: O3,
            npreceq: D3,
            npre: B3,
            nrarrc: P3,
            nrarr: H3,
            nrArr: U3,
            nrarrw: z3,
            nrightarrow: F3,
            nRightarrow: q3,
            nrtri: j3,
            nrtrie: $3,
            nsc: V3,
            nsccue: K3,
            nsce: G3,
            Nscr: W3,
            nscr: Z3,
            nshortmid: X3,
            nshortparallel: J3,
            nsim: Y3,
            nsime: Q3,
            nsimeq: eA,
            nsmid: tA,
            nspar: rA,
            nsqsube: nA,
            nsqsupe: iA,
            nsub: aA,
            nsubE: oA,
            nsube: sA,
            nsubset: lA,
            nsubseteq: cA,
            nsubseteqq: uA,
            nsucc: fA,
            nsucceq: dA,
            nsup: hA,
            nsupE: pA,
            nsupe: gA,
            nsupset: mA,
            nsupseteq: vA,
            nsupseteqq: bA,
            ntgl: yA,
            Ntilde: kA,
            ntilde: _A,
            ntlg: wA,
            ntriangleleft: xA,
            ntrianglelefteq: EA,
            ntriangleright: CA,
            ntrianglerighteq: TA,
            Nu: AA,
            nu: SA,
            num: IA,
            numero: LA,
            numsp: RA,
            nvap: MA,
            nvdash: NA,
            nvDash: OA,
            nVdash: DA,
            nVDash: BA,
            nvge: PA,
            nvgt: HA,
            nvHarr: UA,
            nvinfin: zA,
            nvlArr: FA,
            nvle: qA,
            nvlt: jA,
            nvltrie: $A,
            nvrArr: VA,
            nvrtrie: KA,
            nvsim: GA,
            nwarhk: WA,
            nwarr: ZA,
            nwArr: XA,
            nwarrow: JA,
            nwnear: YA,
            Oacute: QA,
            oacute: eS,
            oast: tS,
            Ocirc: rS,
            ocirc: nS,
            ocir: iS,
            Ocy: aS,
            ocy: sS,
            odash: lS,
            Odblac: cS,
            odblac: uS,
            odiv: fS,
            odot: dS,
            odsold: hS,
            OElig: pS,
            oelig: gS,
            ofcir: mS,
            Ofr: vS,
            ofr: bS,
            ogon: yS,
            Ograve: kS,
            ograve: _S,
            ogt: wS,
            ohbar: xS,
            ohm: ES,
            oint: CS,
            olarr: TS,
            olcir: AS,
            olcross: SS,
            oline: IS,
            olt: LS,
            Omacr: RS,
            omacr: MS,
            Omega: NS,
            omega: OS,
            Omicron: DS,
            omicron: BS,
            omid: PS,
            ominus: HS,
            Oopf: US,
            oopf: zS,
            opar: FS,
            OpenCurlyDoubleQuote: qS,
            OpenCurlyQuote: jS,
            operp: $S,
            oplus: VS,
            orarr: KS,
            Or: GS,
            or: WS,
            ord: ZS,
            order: XS,
            orderof: YS,
            ordf: QS,
            ordm: e5,
            origof: t5,
            oror: r5,
            orslope: n5,
            orv: i5,
            oS: a5,
            Oscr: o5,
            oscr: s5,
            Oslash: l5,
            oslash: c5,
            osol: u5,
            Otilde: f5,
            otilde: d5,
            otimesas: h5,
            Otimes: p5,
            otimes: g5,
            Ouml: m5,
            ouml: v5,
            ovbar: b5,
            OverBar: y5,
            OverBrace: k5,
            OverBracket: _5,
            OverParenthesis: w5,
            para: x5,
            parallel: E5,
            par: C5,
            parsim: T5,
            parsl: A5,
            part: S5,
            PartialD: I5,
            Pcy: L5,
            pcy: R5,
            percnt: M5,
            period: N5,
            permil: O5,
            perp: D5,
            pertenk: B5,
            Pfr: P5,
            pfr: H5,
            Phi: U5,
            phi: z5,
            phiv: F5,
            phmmat: q5,
            phone: j5,
            Pi: $5,
            pi: V5,
            pitchfork: K5,
            piv: G5,
            planck: W5,
            planckh: Z5,
            plankv: X5,
            plusacir: J5,
            plusb: Y5,
            pluscir: Q5,
            plus: eI,
            plusdo: tI,
            plusdu: rI,
            pluse: nI,
            PlusMinus: iI,
            plusmn: aI,
            plussim: oI,
            plustwo: sI,
            pm: lI,
            Poincareplane: cI,
            pointint: uI,
            popf: fI,
            Popf: dI,
            pound: hI,
            prap: pI,
            Pr: gI,
            pr: mI,
            prcue: vI,
            precapprox: bI,
            prec: yI,
            preccurlyeq: kI,
            Precedes: _I,
            PrecedesEqual: wI,
            PrecedesSlantEqual: xI,
            PrecedesTilde: EI,
            preceq: CI,
            precnapprox: TI,
            precneqq: AI,
            precnsim: SI,
            pre: II,
            prE: LI,
            precsim: RI,
            prime: MI,
            Prime: NI,
            primes: OI,
            prnap: DI,
            prnE: BI,
            prnsim: PI,
            prod: HI,
            Product: UI,
            profalar: zI,
            profline: FI,
            profsurf: qI,
            prop: jI,
            Proportional: $I,
            Proportion: VI,
            propto: KI,
            prsim: GI,
            prurel: WI,
            Pscr: ZI,
            pscr: XI,
            Psi: JI,
            psi: YI,
            puncsp: QI,
            Qfr: eL,
            qfr: tL,
            qint: rL,
            qopf: nL,
            Qopf: iL,
            qprime: aL,
            Qscr: oL,
            qscr: sL,
            quaternions: lL,
            quatint: cL,
            quest: uL,
            questeq: fL,
            quot: dL,
            QUOT: hL,
            rAarr: pL,
            race: gL,
            Racute: mL,
            racute: vL,
            radic: bL,
            raemptyv: yL,
            rang: kL,
            Rang: _L,
            rangd: wL,
            range: xL,
            rangle: EL,
            raquo: CL,
            rarrap: TL,
            rarrb: AL,
            rarrbfs: SL,
            rarrc: IL,
            rarr: LL,
            Rarr: RL,
            rArr: ML,
            rarrfs: NL,
            rarrhk: OL,
            rarrlp: DL,
            rarrpl: BL,
            rarrsim: PL,
            Rarrtl: HL,
            rarrtl: UL,
            rarrw: zL,
            ratail: FL,
            rAtail: qL,
            ratio: jL,
            rationals: $L,
            rbarr: VL,
            rBarr: KL,
            RBarr: GL,
            rbbrk: WL,
            rbrace: ZL,
            rbrack: XL,
            rbrke: JL,
            rbrksld: YL,
            rbrkslu: QL,
            Rcaron: e4,
            rcaron: t4,
            Rcedil: r4,
            rcedil: n4,
            rceil: i4,
            rcub: a4,
            Rcy: o4,
            rcy: s4,
            rdca: l4,
            rdldhar: c4,
            rdquo: u4,
            rdquor: f4,
            rdsh: d4,
            real: h4,
            realine: p4,
            realpart: g4,
            reals: m4,
            Re: v4,
            rect: b4,
            reg: y4,
            REG: k4,
            ReverseElement: _4,
            ReverseEquilibrium: w4,
            ReverseUpEquilibrium: x4,
            rfisht: E4,
            rfloor: C4,
            rfr: T4,
            Rfr: A4,
            rHar: S4,
            rhard: I4,
            rharu: L4,
            rharul: R4,
            Rho: M4,
            rho: N4,
            rhov: O4,
            RightAngleBracket: D4,
            RightArrowBar: B4,
            rightarrow: P4,
            RightArrow: H4,
            Rightarrow: U4,
            RightArrowLeftArrow: z4,
            rightarrowtail: F4,
            RightCeiling: q4,
            RightDoubleBracket: j4,
            RightDownTeeVector: $4,
            RightDownVectorBar: V4,
            RightDownVector: K4,
            RightFloor: G4,
            rightharpoondown: W4,
            rightharpoonup: Z4,
            rightleftarrows: X4,
            rightleftharpoons: J4,
            rightrightarrows: Y4,
            rightsquigarrow: Q4,
            RightTeeArrow: eR,
            RightTee: tR,
            RightTeeVector: rR,
            rightthreetimes: nR,
            RightTriangleBar: iR,
            RightTriangle: aR,
            RightTriangleEqual: oR,
            RightUpDownVector: sR,
            RightUpTeeVector: lR,
            RightUpVectorBar: cR,
            RightUpVector: uR,
            RightVectorBar: fR,
            RightVector: dR,
            ring: hR,
            risingdotseq: pR,
            rlarr: gR,
            rlhar: mR,
            rlm: vR,
            rmoustache: bR,
            rmoust: yR,
            rnmid: kR,
            roang: _R,
            roarr: wR,
            robrk: xR,
            ropar: ER,
            ropf: CR,
            Ropf: TR,
            roplus: AR,
            rotimes: SR,
            RoundImplies: IR,
            rpar: LR,
            rpargt: RR,
            rppolint: MR,
            rrarr: NR,
            Rrightarrow: OR,
            rsaquo: DR,
            rscr: BR,
            Rscr: PR,
            rsh: HR,
            Rsh: UR,
            rsqb: zR,
            rsquo: FR,
            rsquor: qR,
            rthree: jR,
            rtimes: $R,
            rtri: VR,
            rtrie: KR,
            rtrif: GR,
            rtriltri: WR,
            RuleDelayed: ZR,
            ruluhar: XR,
            rx: JR,
            Sacute: YR,
            sacute: QR,
            sbquo: eM,
            scap: tM,
            Scaron: rM,
            scaron: nM,
            Sc: iM,
            sc: aM,
            sccue: oM,
            sce: sM,
            scE: lM,
            Scedil: cM,
            scedil: uM,
            Scirc: fM,
            scirc: dM,
            scnap: hM,
            scnE: pM,
            scnsim: gM,
            scpolint: mM,
            scsim: vM,
            Scy: bM,
            scy: yM,
            sdotb: kM,
            sdot: _M,
            sdote: wM,
            searhk: xM,
            searr: EM,
            seArr: CM,
            searrow: TM,
            sect: AM,
            semi: SM,
            seswar: IM,
            setminus: LM,
            setmn: RM,
            sext: MM,
            Sfr: NM,
            sfr: OM,
            sfrown: DM,
            sharp: BM,
            SHCHcy: PM,
            shchcy: HM,
            SHcy: UM,
            shcy: zM,
            ShortDownArrow: FM,
            ShortLeftArrow: qM,
            shortmid: jM,
            shortparallel: $M,
            ShortRightArrow: VM,
            ShortUpArrow: KM,
            shy: GM,
            Sigma: WM,
            sigma: ZM,
            sigmaf: XM,
            sigmav: JM,
            sim: YM,
            simdot: QM,
            sime: eN,
            simeq: tN,
            simg: rN,
            simgE: nN,
            siml: iN,
            simlE: aN,
            simne: oN,
            simplus: sN,
            simrarr: lN,
            slarr: cN,
            SmallCircle: uN,
            smallsetminus: fN,
            smashp: dN,
            smeparsl: hN,
            smid: pN,
            smile: gN,
            smt: mN,
            smte: vN,
            smtes: bN,
            SOFTcy: yN,
            softcy: kN,
            solbar: _N,
            solb: wN,
            sol: xN,
            Sopf: EN,
            sopf: CN,
            spades: TN,
            spadesuit: AN,
            spar: SN,
            sqcap: IN,
            sqcaps: LN,
            sqcup: RN,
            sqcups: MN,
            Sqrt: NN,
            sqsub: ON,
            sqsube: DN,
            sqsubset: BN,
            sqsubseteq: PN,
            sqsup: HN,
            sqsupe: UN,
            sqsupset: zN,
            sqsupseteq: FN,
            square: qN,
            Square: jN,
            SquareIntersection: $N,
            SquareSubset: VN,
            SquareSubsetEqual: KN,
            SquareSuperset: GN,
            SquareSupersetEqual: WN,
            SquareUnion: ZN,
            squarf: XN,
            squ: JN,
            squf: YN,
            srarr: QN,
            Sscr: e8,
            sscr: t8,
            ssetmn: r8,
            ssmile: n8,
            sstarf: i8,
            Star: a8,
            star: o8,
            starf: s8,
            straightepsilon: l8,
            straightphi: c8,
            strns: u8,
            sub: f8,
            Sub: d8,
            subdot: h8,
            subE: p8,
            sube: g8,
            subedot: m8,
            submult: v8,
            subnE: b8,
            subne: y8,
            subplus: k8,
            subrarr: _8,
            subset: w8,
            Subset: x8,
            subseteq: E8,
            subseteqq: C8,
            SubsetEqual: T8,
            subsetneq: A8,
            subsetneqq: S8,
            subsim: I8,
            subsub: L8,
            subsup: R8,
            succapprox: M8,
            succ: N8,
            succcurlyeq: O8,
            Succeeds: D8,
            SucceedsEqual: B8,
            SucceedsSlantEqual: P8,
            SucceedsTilde: H8,
            succeq: U8,
            succnapprox: z8,
            succneqq: F8,
            succnsim: q8,
            succsim: j8,
            SuchThat: $8,
            sum: V8,
            Sum: K8,
            sung: G8,
            sup1: W8,
            sup2: Z8,
            sup3: X8,
            sup: J8,
            Sup: Y8,
            supdot: Q8,
            supdsub: eO,
            supE: tO,
            supe: rO,
            supedot: nO,
            Superset: iO,
            SupersetEqual: aO,
            suphsol: oO,
            suphsub: sO,
            suplarr: lO,
            supmult: cO,
            supnE: uO,
            supne: fO,
            supplus: dO,
            supset: hO,
            Supset: pO,
            supseteq: gO,
            supseteqq: mO,
            supsetneq: vO,
            supsetneqq: bO,
            supsim: yO,
            supsub: kO,
            supsup: _O,
            swarhk: wO,
            swarr: xO,
            swArr: EO,
            swarrow: CO,
            swnwar: TO,
            szlig: AO,
            Tab: SO,
            target: IO,
            Tau: LO,
            tau: RO,
            tbrk: MO,
            Tcaron: NO,
            tcaron: OO,
            Tcedil: DO,
            tcedil: BO,
            Tcy: PO,
            tcy: HO,
            tdot: UO,
            telrec: zO,
            Tfr: FO,
            tfr: qO,
            there4: jO,
            therefore: $O,
            Therefore: VO,
            Theta: KO,
            theta: GO,
            thetasym: WO,
            thetav: ZO,
            thickapprox: XO,
            thicksim: JO,
            ThickSpace: YO,
            ThinSpace: QO,
            thinsp: e6,
            thkap: t6,
            thksim: r6,
            THORN: n6,
            thorn: i6,
            tilde: a6,
            Tilde: o6,
            TildeEqual: s6,
            TildeFullEqual: l6,
            TildeTilde: c6,
            timesbar: u6,
            timesb: f6,
            times: d6,
            timesd: h6,
            tint: p6,
            toea: g6,
            topbot: m6,
            topcir: v6,
            top: b6,
            Topf: y6,
            topf: k6,
            topfork: _6,
            tosa: w6,
            tprime: x6,
            trade: E6,
            TRADE: C6,
            triangle: T6,
            triangledown: A6,
            triangleleft: S6,
            trianglelefteq: I6,
            triangleq: L6,
            triangleright: R6,
            trianglerighteq: M6,
            tridot: N6,
            trie: O6,
            triminus: D6,
            TripleDot: B6,
            triplus: P6,
            trisb: H6,
            tritime: U6,
            trpezium: z6,
            Tscr: F6,
            tscr: q6,
            TScy: j6,
            tscy: $6,
            TSHcy: V6,
            tshcy: K6,
            Tstrok: G6,
            tstrok: W6,
            twixt: Z6,
            twoheadleftarrow: X6,
            twoheadrightarrow: J6,
            Uacute: Y6,
            uacute: Q6,
            uarr: eD,
            Uarr: tD,
            uArr: rD,
            Uarrocir: nD,
            Ubrcy: iD,
            ubrcy: aD,
            Ubreve: oD,
            ubreve: sD,
            Ucirc: lD,
            ucirc: cD,
            Ucy: uD,
            ucy: fD,
            udarr: dD,
            Udblac: hD,
            udblac: pD,
            udhar: gD,
            ufisht: mD,
            Ufr: vD,
            ufr: bD,
            Ugrave: yD,
            ugrave: kD,
            uHar: _D,
            uharl: wD,
            uharr: xD,
            uhblk: ED,
            ulcorn: CD,
            ulcorner: TD,
            ulcrop: AD,
            ultri: SD,
            Umacr: ID,
            umacr: LD,
            uml: RD,
            UnderBar: MD,
            UnderBrace: ND,
            UnderBracket: OD,
            UnderParenthesis: BD,
            Union: PD,
            UnionPlus: HD,
            Uogon: UD,
            uogon: zD,
            Uopf: FD,
            uopf: qD,
            UpArrowBar: jD,
            uparrow: $D,
            UpArrow: VD,
            Uparrow: KD,
            UpArrowDownArrow: GD,
            updownarrow: WD,
            UpDownArrow: ZD,
            Updownarrow: XD,
            UpEquilibrium: JD,
            upharpoonleft: YD,
            upharpoonright: QD,
            uplus: eB,
            UpperLeftArrow: tB,
            UpperRightArrow: rB,
            upsi: nB,
            Upsi: iB,
            upsih: aB,
            Upsilon: oB,
            upsilon: sB,
            UpTeeArrow: lB,
            UpTee: cB,
            upuparrows: uB,
            urcorn: fB,
            urcorner: dB,
            urcrop: hB,
            Uring: pB,
            uring: gB,
            urtri: mB,
            Uscr: vB,
            uscr: bB,
            utdot: yB,
            Utilde: kB,
            utilde: _B,
            utri: wB,
            utrif: xB,
            uuarr: EB,
            Uuml: CB,
            uuml: TB,
            uwangle: AB,
            vangrt: SB,
            varepsilon: IB,
            varkappa: LB,
            varnothing: RB,
            varphi: MB,
            varpi: NB,
            varpropto: OB,
            varr: DB,
            vArr: BB,
            varrho: PB,
            varsigma: HB,
            varsubsetneq: UB,
            varsubsetneqq: zB,
            varsupsetneq: FB,
            varsupsetneqq: qB,
            vartheta: jB,
            vartriangleleft: $B,
            vartriangleright: VB,
            vBar: KB,
            Vbar: GB,
            vBarv: WB,
            Vcy: ZB,
            vcy: XB,
            vdash: JB,
            vDash: YB,
            Vdash: QB,
            VDash: eP,
            Vdashl: tP,
            veebar: rP,
            vee: nP,
            Vee: iP,
            veeeq: aP,
            vellip: oP,
            verbar: sP,
            Verbar: lP,
            vert: cP,
            Vert: uP,
            VerticalBar: fP,
            VerticalLine: dP,
            VerticalSeparator: hP,
            VerticalTilde: pP,
            VeryThinSpace: gP,
            Vfr: mP,
            vfr: vP,
            vltri: bP,
            vnsub: yP,
            vnsup: kP,
            Vopf: _P,
            vopf: wP,
            vprop: xP,
            vrtri: EP,
            Vscr: CP,
            vscr: TP,
            vsubnE: AP,
            vsubne: SP,
            vsupnE: IP,
            vsupne: LP,
            Vvdash: RP,
            vzigzag: MP,
            Wcirc: NP,
            wcirc: OP,
            wedbar: DP,
            wedge: BP,
            Wedge: PP,
            wedgeq: HP,
            weierp: UP,
            Wfr: zP,
            wfr: FP,
            Wopf: qP,
            wopf: jP,
            wp: $P,
            wr: VP,
            wreath: KP,
            Wscr: GP,
            wscr: WP,
            xcap: ZP,
            xcirc: XP,
            xcup: JP,
            xdtri: YP,
            Xfr: QP,
            xfr: e7,
            xharr: t7,
            xhArr: r7,
            Xi: n7,
            xi: i7,
            xlarr: a7,
            xlArr: o7,
            xmap: s7,
            xnis: l7,
            xodot: c7,
            Xopf: u7,
            xopf: f7,
            xoplus: d7,
            xotime: h7,
            xrarr: p7,
            xrArr: g7,
            Xscr: m7,
            xscr: v7,
            xsqcup: b7,
            xuplus: y7,
            xutri: k7,
            xvee: _7,
            xwedge: w7,
            Yacute: x7,
            yacute: E7,
            YAcy: C7,
            yacy: T7,
            Ycirc: A7,
            ycirc: S7,
            Ycy: I7,
            ycy: L7,
            yen: R7,
            Yfr: M7,
            yfr: N7,
            YIcy: O7,
            yicy: D7,
            Yopf: B7,
            yopf: P7,
            Yscr: H7,
            yscr: U7,
            YUcy: z7,
            yucy: F7,
            yuml: q7,
            Yuml: j7,
            Zacute: $7,
            zacute: V7,
            Zcaron: K7,
            zcaron: G7,
            Zcy: W7,
            zcy: Z7,
            Zdot: X7,
            zdot: J7,
            zeetrf: Y7,
            ZeroWidthSpace: Q7,
            Zeta: e9,
            zeta: t9,
            zfr: r9,
            Zfr: n9,
            ZHcy: i9,
            zhcy: a9,
            zigrarr: o9,
            zopf: s9,
            Zopf: l9,
            Zscr: c9,
            zscr: u9,
            zwj: f9,
            zwnj: d9
          }, h9 = "Á", p9 = "á", g9 = "Â", m9 = "â", v9 = "´", b9 = "Æ", y9 = "æ", k9 = "À", _9 = "à", w9 = "&", x9 = "&", E9 = "Å", C9 = "å", T9 = "Ã", A9 = "ã", S9 = "Ä", I9 = "ä", L9 = "¦", R9 = "Ç", M9 = "ç", N9 = "¸", O9 = "¢", D9 = "©", B9 = "©", P9 = "¤", H9 = "°", U9 = "÷", z9 = "É", F9 = "é", q9 = "Ê", j9 = "ê", $9 = "È", V9 = "è", K9 = "Ð", G9 = "ð", W9 = "Ë", Z9 = "ë", X9 = "½", J9 = "¼", Y9 = "¾", Q9 = ">", eH = ">", tH = "Í", rH = "í", nH = "Î", iH = "î", aH = "¡", oH = "Ì", sH = "ì", lH = "¿", cH = "Ï", uH = "ï", fH = "«", dH = "<", hH = "<", pH = "¯", gH = "µ", mH = "·", vH = " ", bH = "¬", yH = "Ñ", kH = "ñ", _H = "Ó", wH = "ó", xH = "Ô", EH = "ô", CH = "Ò", TH = "ò", AH = "ª", SH = "º", IH = "Ø", LH = "ø", RH = "Õ", MH = "õ", NH = "Ö", OH = "ö", DH = "¶", BH = "±", PH = "£", HH = '"', UH = '"', zH = "»", FH = "®", qH = "®", jH = "§", $H = "­", VH = "¹", KH = "²", GH = "³", WH = "ß", ZH = "Þ", XH = "þ", JH = "×", YH = "Ú", QH = "ú", eU = "Û", tU = "û", rU = "Ù", nU = "ù", iU = "¨", aU = "Ü", oU = "ü", sU = "Ý", lU = "ý", cU = "¥", uU = "ÿ", fU = {
            Aacute: h9,
            aacute: p9,
            Acirc: g9,
            acirc: m9,
            acute: v9,
            AElig: b9,
            aelig: y9,
            Agrave: k9,
            agrave: _9,
            amp: w9,
            AMP: x9,
            Aring: E9,
            aring: C9,
            Atilde: T9,
            atilde: A9,
            Auml: S9,
            auml: I9,
            brvbar: L9,
            Ccedil: R9,
            ccedil: M9,
            cedil: N9,
            cent: O9,
            copy: D9,
            COPY: B9,
            curren: P9,
            deg: H9,
            divide: U9,
            Eacute: z9,
            eacute: F9,
            Ecirc: q9,
            ecirc: j9,
            Egrave: $9,
            egrave: V9,
            ETH: K9,
            eth: G9,
            Euml: W9,
            euml: Z9,
            frac12: X9,
            frac14: J9,
            frac34: Y9,
            gt: Q9,
            GT: eH,
            Iacute: tH,
            iacute: rH,
            Icirc: nH,
            icirc: iH,
            iexcl: aH,
            Igrave: oH,
            igrave: sH,
            iquest: lH,
            Iuml: cH,
            iuml: uH,
            laquo: fH,
            lt: dH,
            LT: hH,
            macr: pH,
            micro: gH,
            middot: mH,
            nbsp: vH,
            not: bH,
            Ntilde: yH,
            ntilde: kH,
            Oacute: _H,
            oacute: wH,
            Ocirc: xH,
            ocirc: EH,
            Ograve: CH,
            ograve: TH,
            ordf: AH,
            ordm: SH,
            Oslash: IH,
            oslash: LH,
            Otilde: RH,
            otilde: MH,
            Ouml: NH,
            ouml: OH,
            para: DH,
            plusmn: BH,
            pound: PH,
            quot: HH,
            QUOT: UH,
            raquo: zH,
            reg: FH,
            REG: qH,
            sect: jH,
            shy: $H,
            sup1: VH,
            sup2: KH,
            sup3: GH,
            szlig: WH,
            THORN: ZH,
            thorn: XH,
            times: JH,
            Uacute: YH,
            uacute: QH,
            Ucirc: eU,
            ucirc: tU,
            Ugrave: rU,
            ugrave: nU,
            uml: iU,
            Uuml: aU,
            uuml: oU,
            Yacute: sU,
            yacute: lU,
            yen: cU,
            yuml: uU
          }, dU = "&", hU = "'", pU = ">", gU = "<", mU = '"', ef = {
            amp: dU,
            apos: hU,
            gt: pU,
            lt: gU,
            quot: mU
          }, vu = {}, vU = {
            0: 65533,
            128: 8364,
            130: 8218,
            131: 402,
            132: 8222,
            133: 8230,
            134: 8224,
            135: 8225,
            136: 710,
            137: 8240,
            138: 352,
            139: 8249,
            140: 338,
            142: 381,
            145: 8216,
            146: 8217,
            147: 8220,
            148: 8221,
            149: 8226,
            150: 8211,
            151: 8212,
            152: 732,
            153: 8482,
            154: 353,
            155: 8250,
            156: 339,
            158: 382,
            159: 376
          }, bU = Ar && Ar.__importDefault || function(Dr) {
            return Dr && Dr.__esModule ? Dr : { default: Dr };
          };
          Object.defineProperty(vu, "__esModule", { value: !0 });
          var tf = bU(vU), yU = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.fromCodePoint || function(Dr) {
              var Nr = "";
              return Dr > 65535 && (Dr -= 65536, Nr += String.fromCharCode(Dr >>> 10 & 1023 | 55296), Dr = 56320 | Dr & 1023), Nr += String.fromCharCode(Dr), Nr;
            }
          );
          function kU(Dr) {
            return Dr >= 55296 && Dr <= 57343 || Dr > 1114111 ? "�" : (Dr in tf.default && (Dr = tf.default[Dr]), yU(Dr));
          }
          vu.default = kU;
          var pc = Ar && Ar.__importDefault || function(Dr) {
            return Dr && Dr.__esModule ? Dr : { default: Dr };
          };
          Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.decodeHTML = Gr.decodeHTMLStrict = Gr.decodeXML = void 0;
          var bu = pc(Qu), _U = pc(fU), wU = pc(ef), rf = pc(vu), xU = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
          Gr.decodeXML = nf(wU.default), Gr.decodeHTMLStrict = nf(bu.default);
          function nf(Dr) {
            var Nr = sf(Dr);
            return function($r) {
              return String($r).replace(xU, Nr);
            };
          }
          var of = function(Dr, Nr) {
            return Dr < Nr ? 1 : -1;
          };
          Gr.decodeHTML = function() {
            for (var Dr = Object.keys(_U.default).sort(of), Nr = Object.keys(bu.default).sort(of), $r = 0, Zr = 0; $r < Nr.length; $r++)
              Dr[Zr] === Nr[$r] ? (Nr[$r] += ";?", Zr++) : Nr[$r] += ";";
            var oi = new RegExp("&(?:" + Nr.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), _i = sf(bu.default);
            function Li(Ui) {
              return Ui.substr(-1) !== ";" && (Ui += ";"), _i(Ui);
            }
            return function(Ui) {
              return String(Ui).replace(oi, Li);
            };
          }();
          function sf(Dr) {
            return function($r) {
              if ($r.charAt(1) === "#") {
                var Zr = $r.charAt(2);
                return Zr === "X" || Zr === "x" ? rf.default(parseInt($r.substr(3), 16)) : rf.default(parseInt($r.substr(2), 10));
              }
              return Dr[$r.slice(1, -1)] || $r;
            };
          }
          var Ko = {}, lf = Ar && Ar.__importDefault || function(Dr) {
            return Dr && Dr.__esModule ? Dr : { default: Dr };
          };
          Object.defineProperty(Ko, "__esModule", { value: !0 }), Ko.escapeUTF8 = Ko.escape = Ko.encodeNonAsciiHTML = Ko.encodeHTML = Ko.encodeXML = void 0;
          var EU = lf(ef), cf = ff(EU.default), uf = df(cf);
          Ko.encodeXML = gf(cf);
          var CU = lf(Qu), yu = ff(CU.default), TU = df(yu);
          Ko.encodeHTML = SU(yu, TU), Ko.encodeNonAsciiHTML = gf(yu);
          function ff(Dr) {
            return Object.keys(Dr).sort().reduce(function(Nr, $r) {
              return Nr[Dr[$r]] = "&" + $r + ";", Nr;
            }, {});
          }
          function df(Dr) {
            for (var Nr = [], $r = [], Zr = 0, oi = Object.keys(Dr); Zr < oi.length; Zr++) {
              var _i = oi[Zr];
              _i.length === 1 ? Nr.push("\\" + _i) : $r.push(_i);
            }
            Nr.sort();
            for (var Li = 0; Li < Nr.length - 1; Li++) {
              for (var Ui = Li; Ui < Nr.length - 1 && Nr[Ui].charCodeAt(1) + 1 === Nr[Ui + 1].charCodeAt(1); )
                Ui += 1;
              var ea = 1 + Ui - Li;
              ea < 3 || Nr.splice(Li, ea, Nr[Li] + "-" + Nr[Ui]);
            }
            return $r.unshift("[" + Nr.join("") + "]"), new RegExp($r.join("|"), "g");
          }
          var hf = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, AU = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.prototype.codePointAt != null ? (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              function(Dr) {
                return Dr.codePointAt(0);
              }
            ) : (
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              function(Dr) {
                return (Dr.charCodeAt(0) - 55296) * 1024 + Dr.charCodeAt(1) - 56320 + 65536;
              }
            )
          );
          function gc(Dr) {
            return "&#x" + (Dr.length > 1 ? AU(Dr) : Dr.charCodeAt(0)).toString(16).toUpperCase() + ";";
          }
          function SU(Dr, Nr) {
            return function($r) {
              return $r.replace(Nr, function(Zr) {
                return Dr[Zr];
              }).replace(hf, gc);
            };
          }
          var pf = new RegExp(uf.source + "|" + hf.source, "g");
          function IU(Dr) {
            return Dr.replace(pf, gc);
          }
          Ko.escape = IU;
          function LU(Dr) {
            return Dr.replace(uf, gc);
          }
          Ko.escapeUTF8 = LU;
          function gf(Dr) {
            return function(Nr) {
              return Nr.replace(pf, function($r) {
                return Dr[$r] || gc($r);
              });
            };
          }
          (function(Dr) {
            Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.decodeXMLStrict = Dr.decodeHTML5Strict = Dr.decodeHTML4Strict = Dr.decodeHTML5 = Dr.decodeHTML4 = Dr.decodeHTMLStrict = Dr.decodeHTML = Dr.decodeXML = Dr.encodeHTML5 = Dr.encodeHTML4 = Dr.escapeUTF8 = Dr.escape = Dr.encodeNonAsciiHTML = Dr.encodeHTML = Dr.encodeXML = Dr.encode = Dr.decodeStrict = Dr.decode = void 0;
            var Nr = Gr, $r = Ko;
            function Zr(ea, la) {
              return (!la || la <= 0 ? Nr.decodeXML : Nr.decodeHTML)(ea);
            }
            Dr.decode = Zr;
            function oi(ea, la) {
              return (!la || la <= 0 ? Nr.decodeXML : Nr.decodeHTMLStrict)(ea);
            }
            Dr.decodeStrict = oi;
            function _i(ea, la) {
              return (!la || la <= 0 ? $r.encodeXML : $r.encodeHTML)(ea);
            }
            Dr.encode = _i;
            var Li = Ko;
            Object.defineProperty(Dr, "encodeXML", { enumerable: !0, get: function() {
              return Li.encodeXML;
            } }), Object.defineProperty(Dr, "encodeHTML", { enumerable: !0, get: function() {
              return Li.encodeHTML;
            } }), Object.defineProperty(Dr, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
              return Li.encodeNonAsciiHTML;
            } }), Object.defineProperty(Dr, "escape", { enumerable: !0, get: function() {
              return Li.escape;
            } }), Object.defineProperty(Dr, "escapeUTF8", { enumerable: !0, get: function() {
              return Li.escapeUTF8;
            } }), Object.defineProperty(Dr, "encodeHTML4", { enumerable: !0, get: function() {
              return Li.encodeHTML;
            } }), Object.defineProperty(Dr, "encodeHTML5", { enumerable: !0, get: function() {
              return Li.encodeHTML;
            } });
            var Ui = Gr;
            Object.defineProperty(Dr, "decodeXML", { enumerable: !0, get: function() {
              return Ui.decodeXML;
            } }), Object.defineProperty(Dr, "decodeHTML", { enumerable: !0, get: function() {
              return Ui.decodeHTML;
            } }), Object.defineProperty(Dr, "decodeHTMLStrict", { enumerable: !0, get: function() {
              return Ui.decodeHTMLStrict;
            } }), Object.defineProperty(Dr, "decodeHTML4", { enumerable: !0, get: function() {
              return Ui.decodeHTML;
            } }), Object.defineProperty(Dr, "decodeHTML5", { enumerable: !0, get: function() {
              return Ui.decodeHTML;
            } }), Object.defineProperty(Dr, "decodeHTML4Strict", { enumerable: !0, get: function() {
              return Ui.decodeHTMLStrict;
            } }), Object.defineProperty(Dr, "decodeHTML5Strict", { enumerable: !0, get: function() {
              return Ui.decodeHTMLStrict;
            } }), Object.defineProperty(Dr, "decodeXMLStrict", { enumerable: !0, get: function() {
              return Ui.decodeXML;
            } });
          })(zr);
          var mf = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", RU = 92, MU = /[\\&]/, ku = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", NU = new RegExp("\\\\" + ku + "|" + mf, "gi"), OU = '[&<>"]', vf = new RegExp(OU, "g"), DU = function(Dr) {
            return Dr.charCodeAt(0) === RU ? Dr.charAt(1) : zr.decodeHTML(Dr);
          };
          function Nl(Dr) {
            return MU.test(Dr) ? Dr.replace(NU, DU) : Dr;
          }
          function mc(Dr) {
            try {
              return Br(Dr);
            } catch (Nr) {
              return Dr;
            }
          }
          function BU(Dr) {
            switch (Dr) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              default:
                return Dr;
            }
          }
          function vl(Dr) {
            return vf.test(Dr) ? Dr.replace(vf, BU) : Dr;
          }
          function _u(Dr, Nr) {
            for (var $r = [], Zr = 0; Zr < Nr; Zr++)
              $r.push(Dr);
            return $r.join("");
          }
          function bf(Dr) {
            return Dr ? !/[^ \t]+/.test(Dr) : !0;
          }
          var PU = (
            /** @class */
            function() {
              function Dr(Nr) {
                this.current = Nr, this.root = Nr, this.entering = !0;
              }
              return Dr.prototype.next = function() {
                var Nr = this.current, $r = this.entering;
                if (Nr === null)
                  return null;
                var Zr = wu(Nr);
                return $r && Zr ? Nr.firstChild ? (this.current = Nr.firstChild, this.entering = !0) : this.entering = !1 : Nr === this.root ? this.current = null : Nr.next === null ? (this.current = Nr.parent, this.entering = !1) : (this.current = Nr.next, this.entering = !0), { entering: $r, node: Nr };
              }, Dr.prototype.resumeAt = function(Nr, $r) {
                this.current = Nr, this.entering = $r === !0;
              }, Dr;
            }()
          );
          function wu(Dr) {
            switch (Dr.type) {
              case "document":
              case "blockQuote":
              case "list":
              case "item":
              case "paragraph":
              case "heading":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "table":
              case "tableHead":
              case "tableBody":
              case "tableRow":
              case "tableCell":
              case "tableDelimRow":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          var HU = 1, vc = {};
          function UU(Dr) {
            return vc[Dr];
          }
          function xu(Dr) {
            delete vc[Dr];
          }
          function zU() {
            vc = {};
          }
          var Ol = (
            /** @class */
            function() {
              function Dr(Nr, $r) {
                this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, Nr === "document" ? this.id = -1 : this.id = HU++, this.type = Nr, this.sourcepos = $r, vc[this.id] = this;
              }
              return Dr.prototype.isContainer = function() {
                return wu(this);
              }, Dr.prototype.unlink = function() {
                this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
              }, Dr.prototype.replaceWith = function(Nr) {
                this.insertBefore(Nr), this.unlink();
              }, Dr.prototype.insertAfter = function(Nr) {
                Nr.unlink(), Nr.next = this.next, Nr.next && (Nr.next.prev = Nr), Nr.prev = this, this.next = Nr, this.parent && (Nr.parent = this.parent, Nr.next || (Nr.parent.lastChild = Nr));
              }, Dr.prototype.insertBefore = function(Nr) {
                Nr.unlink(), Nr.prev = this.prev, Nr.prev && (Nr.prev.next = Nr), Nr.next = this, this.prev = Nr, Nr.parent = this.parent, Nr.prev || (Nr.parent.firstChild = Nr);
              }, Dr.prototype.appendChild = function(Nr) {
                Nr.unlink(), Nr.parent = this, this.lastChild ? (this.lastChild.next = Nr, Nr.prev = this.lastChild, this.lastChild = Nr) : (this.firstChild = Nr, this.lastChild = Nr);
              }, Dr.prototype.prependChild = function(Nr) {
                Nr.unlink(), Nr.parent = this, this.firstChild ? (this.firstChild.prev = Nr, Nr.next = this.firstChild, this.firstChild = Nr) : (this.firstChild = Nr, this.lastChild = Nr);
              }, Dr.prototype.walker = function() {
                return new PU(this);
              }, Dr;
            }()
          ), Cs = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr($r, Zr) {
                var oi = Dr.call(this, $r, Zr) || this;
                return oi.open = !0, oi.lineOffsets = null, oi.stringContent = null, oi.lastLineBlank = !1, oi.lastLineChecked = !1, oi.type = $r, oi;
              }
              return Nr;
            }(Ol)
          ), FU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.listData = null, $r;
              }
              return Nr;
            }(Cs)
          ), qU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.level = 0, $r.headingType = "atx", $r;
              }
              return Nr;
            }(Cs)
          ), jU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.isFenced = !1, $r.fenceChar = null, $r.fenceLength = 0, $r.fenceOffset = -1, $r.info = null, $r.infoPadding = 0, $r;
              }
              return Nr;
            }(Cs)
          ), $U = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.columns = [], $r;
              }
              return Nr;
            }(Cs)
          ), VU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.startIdx = 0, $r.endIdx = 0, $r.paddingLeft = 0, $r.paddingRight = 0, $r.ignored = !1, $r;
              }
              return Nr;
            }(Cs)
          ), KU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.title = "", $r.dest = "", $r.label = "", $r;
              }
              return Nr;
            }(Cs)
          ), GU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.syntaxLength = 0, $r.offset = -1, $r.info = "", $r;
              }
              return Nr;
            }(Cs)
          ), WU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.htmlBlockType = -1, $r;
              }
              return Nr;
            }(Cs)
          ), ZU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.destination = null, $r.title = null, $r.extendedAutolink = !1, $r;
              }
              return Nr;
            }(Ol)
          ), XU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.tickCount = 0, $r;
              }
              return Nr;
            }(Ol)
          ), JU = (
            /** @class */
            function(Dr) {
              Er(Nr, Dr);
              function Nr() {
                var $r = Dr !== null && Dr.apply(this, arguments) || this;
                return $r.info = "", $r;
              }
              return Nr;
            }(Ol)
          );
          function bo(Dr, Nr) {
            switch (Dr) {
              case "heading":
                return new qU(Dr, Nr);
              case "list":
              case "item":
                return new FU(Dr, Nr);
              case "link":
              case "image":
                return new ZU(Dr, Nr);
              case "codeBlock":
                return new jU(Dr, Nr);
              case "htmlBlock":
                return new WU(Dr, Nr);
              case "table":
                return new $U(Dr, Nr);
              case "tableCell":
                return new VU(Dr, Nr);
              case "document":
              case "paragraph":
              case "blockQuote":
              case "thematicBreak":
              case "tableRow":
              case "tableBody":
              case "tableHead":
              case "frontMatter":
                return new Cs(Dr, Nr);
              case "code":
                return new XU(Dr, Nr);
              case "refDef":
                return new KU(Dr, Nr);
              case "customBlock":
                return new GU(Dr, Nr);
              case "customInline":
                return new JU(Dr, Nr);
              default:
                return new Ol(Dr, Nr);
            }
          }
          function yf(Dr) {
            return Dr.type === "codeBlock";
          }
          function YU(Dr) {
            return Dr.type === "htmlBlock";
          }
          function QU(Dr) {
            return Dr.type === "heading";
          }
          function kf(Dr) {
            return Dr.type === "list";
          }
          function ez(Dr) {
            return Dr.type === "table";
          }
          function bl(Dr) {
            return Dr.type === "refDef";
          }
          function _f(Dr) {
            return Dr.type === "customBlock";
          }
          function tz(Dr) {
            return Dr.type === "customInline";
          }
          function So(Dr, Nr) {
            var $r = bo("text", Nr);
            return $r.literal = Dr, $r;
          }
          var wf = "[A-Za-z][A-Za-z0-9-]*", rz = "[a-zA-Z_:][a-zA-Z0-9:._-]*", nz = "[^\"'=<>`\\x00-\\x20]+", iz = "'[^']*'", az = '"[^"]*"', oz = "(?:" + nz + "|" + iz + "|" + az + ")", sz = "(?:\\s*=\\s*" + oz + ")", lz = "(?:\\s+" + rz + sz + "?)", xf = "<" + wf + lz + "*\\s*/?>", Ef = "</" + wf + "\\s*[>]", cz = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", uz = "[<][?].*?[?][>]", fz = "<![A-Z]+\\s+[^>]*>", dz = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", hz = "(?:" + xf + "|" + Ef + "|" + cz + "|" + uz + "|" + fz + "|" + dz + ")", pz = new RegExp("^" + hz, "i");
          /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
          var Eu;
          if (String.fromCodePoint)
            Eu = function(Dr) {
              try {
                return String.fromCodePoint(Dr);
              } catch (Nr) {
                if (Nr instanceof RangeError)
                  return String.fromCharCode(65533);
                throw Nr;
              }
            };
          else {
            var gz = String.fromCharCode, mz = Math.floor;
            Eu = function() {
              for (var Dr = [], Nr = 0; Nr < arguments.length; Nr++)
                Dr[Nr] = arguments[Nr];
              var $r = 16384, Zr = [], oi, _i, Li = -1, Ui = Dr.length;
              if (!Ui)
                return "";
              for (var ea = ""; ++Li < Ui; ) {
                var la = Number(Dr[Li]);
                if (!isFinite(la) || // `NaN`, `+Infinity`, or `-Infinity`
                la < 0 || // not a valid Unicode code point
                la > 1114111 || // not a valid Unicode code point
                mz(la) !== la)
                  return String.fromCharCode(65533);
                la <= 65535 ? Zr.push(la) : (la -= 65536, oi = (la >> 10) + 55296, _i = la % 1024 + 56320, Zr.push(oi, _i)), (Li + 1 === Ui || Zr.length > $r) && (ea += gz.apply(void 0, Zr), Zr.length = 0);
              }
              return ea;
            };
          }
          var Cu = Eu, vz = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", bz = "[^<\\s]*[^<?!.,:*_?~\\s]", yz = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
          function kz(Dr) {
            var Nr = /\)+$/.exec(Dr);
            if (Nr) {
              for (var $r = 0, Zr = 0, oi = Dr; Zr < oi.length; Zr++) {
                var _i = oi[Zr];
                _i === "(" ? $r < 0 ? $r = 1 : $r += 1 : _i === ")" && ($r -= 1);
              }
              if ($r < 0) {
                var Li = Math.min(-$r, Nr[0].length);
                return Dr.substring(0, Dr.length - Li);
              }
            }
            return Dr;
          }
          function _z(Dr) {
            return Dr.replace(/&[A-Za-z0-9]+;$/, "");
          }
          function wz(Dr) {
            for (var Nr = new RegExp(yz, "g"), $r = [], Zr; Zr = Nr.exec(Dr); ) {
              var oi = Zr[0];
              /[_-]+$/.test(oi) || $r.push({
                text: oi,
                range: [Zr.index, Zr.index + oi.length - 1],
                url: "mailto:" + oi
              });
            }
            return $r;
          }
          function xz(Dr) {
            for (var Nr = new RegExp("(www|https?://)." + vz + bz, "g"), $r = [], Zr; Zr = Nr.exec(Dr); ) {
              var oi = _z(kz(Zr[0])), _i = Zr[1] === "www" ? "http://" : "";
              $r.push({
                text: oi,
                range: [Zr.index, Zr.index + oi.length - 1],
                url: "" + _i + oi
              });
            }
            return $r;
          }
          function Ez(Dr) {
            return Tr(Tr([], xz(Dr)), wz(Dr)).sort(function(Nr, $r) {
              return Nr.range[0] - $r.range[0];
            });
          }
          function Cz(Dr, Nr) {
            typeof Nr == "boolean" && (Nr = Ez);
            for (var $r, Zr = function() {
              var oi = $r.entering, _i = $r.node;
              if (oi && _i.type === "text" && _i.parent.type !== "link") {
                var Li = _i.literal, Ui = Nr(Li);
                if (!Ui || !Ui.length)
                  return "continue";
                for (var ea = 0, la = _i.sourcepos[0], Ea = la[0], Aa = la[1], ka = function(Is, Dj) {
                  return [
                    [Ea, Aa + Is],
                    [Ea, Aa + Dj]
                  ];
                }, Ha = [], Pa = 0, oo = Ui; Pa < oo.length; Pa++) {
                  var yo = oo[Pa], Lo = yo.range, Ts = yo.url, Jo = yo.text;
                  Lo[0] > ea && Ha.push(So(Li.substring(ea, Lo[0]), ka(ea, Lo[0] - 1)));
                  var Wo = bo("link", ka.apply(void 0, Lo));
                  Wo.appendChild(So(Jo, ka.apply(void 0, Lo))), Wo.destination = Ts, Wo.extendedAutolink = !0, Ha.push(Wo), ea = Lo[1] + 1;
                }
                ea < Li.length && Ha.push(So(Li.substring(ea), ka(ea, Li.length - 1)));
                for (var es = 0, As = Ha; es < As.length; es++) {
                  var Ss = As[es];
                  _i.insertBefore(Ss);
                }
                _i.unlink();
              }
            }; $r = Dr.next(); )
              Zr();
          }
          function bc(Dr) {
            return Dr[Dr.length - 1];
          }
          function Cf(Dr) {
            return Dr.slice(1, Dr.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
          }
          function yc(Dr, Nr) {
            Object.keys(Dr).forEach(function($r) {
              Nr($r, Dr[$r]);
            });
          }
          function Tz(Dr) {
            for (var Nr = [], $r = 1; $r < arguments.length; $r++)
              Nr[$r - 1] = arguments[$r];
            var Zr = Cr({}, Dr);
            return Nr.forEach(function(oi) {
              delete Zr[oi];
            }), Zr;
          }
          function yl(Dr) {
            return !Object.keys(Dr).length;
          }
          function Az(Dr) {
            Object.keys(Dr).forEach(function(Nr) {
              delete Dr[Nr];
            });
          }
          var Tu = 10, Au = 42, kc = 95, Sz = 96, Tf = 91, Iz = 93, _c = 126, Af = 60, Lz = 33, Sf = 92, Rz = 38, If = 40, Su = 41, Mz = 58, al = 39, ol = 34, sl = 36, Iu = "\\\\" + ku, Lf = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), Nz = new RegExp('^(?:"(' + Iu + '|[^"\\x00])*"|' + ("'(" + Iu + "|[^'\\x00])*'") + "|" + ("\\((" + Iu + "|[^()\\x00])*\\))")), Oz = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, Rf = new RegExp("^" + ku), Dz = new RegExp("^" + mf, "i"), Bz = /`+/, Pz = /^`+/, Hz = /\.\.\./g, Uz = /--+/g, zz = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, Fz = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, qz = /^ *(?:\n *)?/, Lu = /^[ \t\n\x0b\x0c\x0d]/, Mf = /^\s/, jz = / *$/, $z = /^ */, Nf = /^ *(?:\n|$)/, Vz = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, Kz = /^[^\n`\[\]\\!<&*_'"~$]+/m, Gz = (
            /** @class */
            function() {
              function Dr(Nr) {
                this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = Nr;
              }
              return Dr.prototype.sourcepos = function(Nr, $r) {
                var Zr = this.linePosOffset + this.lineOffsets[this.lineIdx], oi = this.lineStartNum + this.lineIdx, _i = [oi, Nr + Zr];
                return typeof $r == "number" ? [_i, [oi, $r + Zr]] : _i;
              }, Dr.prototype.nextLine = function() {
                this.lineIdx += 1, this.linePosOffset = -this.pos;
              }, Dr.prototype.match = function(Nr) {
                var $r = Nr.exec(this.subject.slice(this.pos));
                return $r === null ? null : (this.pos += $r.index + $r[0].length, $r[0]);
              }, Dr.prototype.peek = function() {
                return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
              }, Dr.prototype.spnl = function() {
                return this.match(qz), !0;
              }, Dr.prototype.parseBackticks = function(Nr) {
                var $r = this.pos + 1, Zr = this.match(Pz);
                if (Zr === null)
                  return !1;
                for (var oi = this.pos, _i; (_i = this.match(Bz)) !== null; )
                  if (_i === Zr) {
                    var Li = this.subject.slice(oi, this.pos - Zr.length), Ui = this.sourcepos($r, this.pos), ea = Li.split(`
`);
                    if (ea.length > 1) {
                      var la = bc(ea);
                      this.lineIdx += ea.length - 1, this.linePosOffset = -(this.pos - la.length - Zr.length), Ui[1] = this.sourcepos(this.pos), Li = ea.join(" ");
                    }
                    var Ea = bo("code", Ui);
                    return Li.length > 0 && Li.match(/[^ ]/) !== null && Li[0] == " " && Li[Li.length - 1] == " " ? Ea.literal = Li.slice(1, Li.length - 1) : Ea.literal = Li, Ea.tickCount = Zr.length, Nr.appendChild(Ea), !0;
                  }
                return this.pos = oi, Nr.appendChild(So(Zr, this.sourcepos($r, this.pos - 1))), !0;
              }, Dr.prototype.parseBackslash = function(Nr) {
                var $r = this.subject, Zr;
                this.pos += 1;
                var oi = this.pos;
                return this.peek() === Tu ? (this.pos += 1, Zr = bo("linebreak", this.sourcepos(this.pos - 1, this.pos)), Nr.appendChild(Zr), this.nextLine()) : Rf.test($r.charAt(this.pos)) ? (Nr.appendChild(So($r.charAt(this.pos), this.sourcepos(oi, this.pos))), this.pos += 1) : Nr.appendChild(So("\\", this.sourcepos(oi, oi))), !0;
              }, Dr.prototype.parseAutolink = function(Nr) {
                var $r, Zr, oi, _i = this.pos + 1;
                return ($r = this.match(zz)) ? (Zr = $r.slice(1, $r.length - 1), oi = bo("link", this.sourcepos(_i, this.pos)), oi.destination = mc("mailto:" + Zr), oi.title = "", oi.appendChild(So(Zr, this.sourcepos(_i + 1, this.pos - 1))), Nr.appendChild(oi), !0) : ($r = this.match(Fz)) ? (Zr = $r.slice(1, $r.length - 1), oi = bo("link", this.sourcepos(_i, this.pos)), oi.destination = mc(Zr), oi.title = "", oi.appendChild(So(Zr, this.sourcepos(_i + 1, this.pos - 1))), Nr.appendChild(oi), !0) : !1;
              }, Dr.prototype.parseHtmlTag = function(Nr) {
                var $r = this.pos + 1, Zr = this.match(pz);
                if (Zr === null)
                  return !1;
                var oi = bo("htmlInline", this.sourcepos($r, this.pos));
                return oi.literal = Zr, Nr.appendChild(oi), !0;
              }, Dr.prototype.scanDelims = function(Nr) {
                var $r = 0, Zr = this.pos;
                if (Nr === al || Nr === ol)
                  $r++, this.pos++;
                else
                  for (; this.peek() === Nr; )
                    $r++, this.pos++;
                if ($r === 0 || $r < 2 && (Nr === _c || Nr === sl))
                  return this.pos = Zr, null;
                var oi = Zr === 0 ? `
` : this.subject.charAt(Zr - 1), _i = this.peek(), Li;
                _i === -1 ? Li = `
` : Li = Cu(_i);
                var Ui = Mf.test(Li), ea = Lf.test(Li), la = Mf.test(oi), Ea = Lf.test(oi), Aa = !Ui && (!ea || la || Ea), ka = !la && (!Ea || Ui || ea), Ha, Pa;
                return Nr === kc ? (Ha = Aa && (!ka || Ea), Pa = ka && (!Aa || ea)) : Nr === al || Nr === ol ? (Ha = Aa && !ka, Pa = ka) : Nr === sl ? (Ha = !Ui, Pa = !la) : (Ha = Aa, Pa = ka), this.pos = Zr, { numdelims: $r, canOpen: Ha, canClose: Pa };
              }, Dr.prototype.handleDelim = function(Nr, $r) {
                var Zr = this.scanDelims(Nr);
                if (!Zr)
                  return !1;
                var oi = Zr.numdelims, _i = this.pos + 1, Li;
                this.pos += oi, Nr === al ? Li = "’" : Nr === ol ? Li = "“" : Li = this.subject.slice(_i - 1, this.pos);
                var Ui = So(Li, this.sourcepos(_i, this.pos));
                return $r.appendChild(Ui), (Zr.canOpen || Zr.canClose) && (this.options.smart || Nr !== al && Nr !== ol) && (this.delimiters = {
                  cc: Nr,
                  numdelims: oi,
                  origdelims: oi,
                  node: Ui,
                  previous: this.delimiters,
                  next: null,
                  canOpen: Zr.canOpen,
                  canClose: Zr.canClose
                }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
              }, Dr.prototype.removeDelimiter = function(Nr) {
                Nr.previous !== null && (Nr.previous.next = Nr.next), Nr.next === null ? this.delimiters = Nr.previous : Nr.next.previous = Nr.previous;
              }, Dr.prototype.removeDelimitersBetween = function(Nr, $r) {
                Nr.next !== $r && (Nr.next = $r, $r.previous = Nr);
              }, Dr.prototype.processEmphasis = function(Nr) {
                var $r, Zr, oi, _i, Li, Ui, ea, la = !1, Ea = ($r = {}, $r[kc] = [Nr, Nr, Nr], $r[Au] = [Nr, Nr, Nr], $r[al] = [Nr], $r[ol] = [Nr], $r[_c] = [Nr], $r[sl] = [Nr], $r);
                for (oi = this.delimiters; oi !== null && oi.previous !== Nr; )
                  oi = oi.previous;
                for (; oi !== null; ) {
                  var Aa = oi.cc, ka = Aa === kc || Aa === Au;
                  if (!oi.canClose)
                    oi = oi.next;
                  else {
                    for (Zr = oi.previous, ea = !1; Zr !== null && Zr !== Nr && Zr !== Ea[Aa][ka ? oi.origdelims % 3 : 0]; ) {
                      if (la = ka && (oi.canOpen || Zr.canClose) && oi.origdelims % 3 !== 0 && (Zr.origdelims + oi.origdelims) % 3 === 0, Zr.cc === oi.cc && Zr.canOpen && !la) {
                        ea = !0;
                        break;
                      }
                      Zr = Zr.previous;
                    }
                    if (_i = oi, ka || Aa === _c || Aa === sl) {
                      if (!ea)
                        oi = oi.next;
                      else if (Zr) {
                        var Ha = oi.numdelims >= 2 && Zr.numdelims >= 2 ? 2 : 1, Pa = ka ? 0 : 1;
                        Li = Zr.node, Ui = oi.node;
                        var oo = ka ? Ha === 1 ? "emph" : "strong" : "strike";
                        Aa === sl && (oo = "customInline");
                        var yo = bo(oo), Lo = Li.sourcepos[1], Ts = Ui.sourcepos[0];
                        yo.sourcepos = [
                          [Lo[0], Lo[1] - Ha + 1],
                          [Ts[0], Ts[1] + Ha - 1]
                        ], Li.sourcepos[1][1] -= Ha, Ui.sourcepos[0][1] += Ha, Li.literal = Li.literal.slice(Ha), Ui.literal = Ui.literal.slice(Ha), Zr.numdelims -= Ha, oi.numdelims -= Ha;
                        for (var Jo = Li.next, Wo = void 0; Jo && Jo !== Ui; )
                          Wo = Jo.next, Jo.unlink(), yo.appendChild(Jo), Jo = Wo;
                        if (Aa === sl) {
                          var es = yo.firstChild, As = es.literal || "", Ss = As.split(/\s/)[0];
                          yo.info = Ss, As.length <= Ss.length ? es.unlink() : (es.sourcepos[0][1] += Ss.length, es.literal = As.replace(Ss + " ", ""));
                        }
                        if (Li.insertAfter(yo), this.removeDelimitersBetween(Zr, oi), Zr.numdelims <= Pa && (Zr.numdelims === 0 && Li.unlink(), this.removeDelimiter(Zr)), oi.numdelims <= Pa) {
                          oi.numdelims === 0 && Ui.unlink();
                          var Is = oi.next;
                          this.removeDelimiter(oi), oi = Is;
                        }
                      }
                    } else
                      Aa === al ? (oi.node.literal = "’", ea && (Zr.node.literal = "‘"), oi = oi.next) : Aa === ol && (oi.node.literal = "”", ea && (Zr.node.literal = "“"), oi = oi.next);
                    ea || (Ea[Aa][ka ? _i.origdelims % 3 : 0] = _i.previous, _i.canOpen || this.removeDelimiter(_i));
                  }
                }
                for (; this.delimiters !== null && this.delimiters !== Nr; )
                  this.removeDelimiter(this.delimiters);
              }, Dr.prototype.parseLinkTitle = function() {
                var Nr = this.match(Nz);
                return Nr === null ? null : Nl(Nr.substr(1, Nr.length - 2));
              }, Dr.prototype.parseLinkDestination = function() {
                var Nr = this.match(Oz);
                if (Nr === null) {
                  if (this.peek() === Af)
                    return null;
                  for (var $r = this.pos, Zr = 0, oi = void 0; (oi = this.peek()) !== -1; )
                    if (oi === Sf && Rf.test(this.subject.charAt(this.pos + 1)))
                      this.pos += 1, this.peek() !== -1 && (this.pos += 1);
                    else if (oi === If)
                      this.pos += 1, Zr += 1;
                    else if (oi === Su) {
                      if (Zr < 1)
                        break;
                      this.pos += 1, Zr -= 1;
                    } else {
                      if (Lu.exec(Cu(oi)) !== null)
                        break;
                      this.pos += 1;
                    }
                  return this.pos === $r && oi !== Su || Zr !== 0 ? null : (Nr = this.subject.substr($r, this.pos - $r), mc(Nl(Nr)));
                }
                return mc(Nl(Nr.substr(1, Nr.length - 2)));
              }, Dr.prototype.parseLinkLabel = function() {
                var Nr = this.match(Vz);
                return Nr === null || Nr.length > 1001 ? 0 : Nr.length;
              }, Dr.prototype.parseOpenBracket = function(Nr) {
                var $r = this.pos;
                this.pos += 1;
                var Zr = So("[", this.sourcepos(this.pos, this.pos));
                return Nr.appendChild(Zr), this.addBracket(Zr, $r, !1), !0;
              }, Dr.prototype.parseBang = function(Nr) {
                var $r = this.pos;
                if (this.pos += 1, this.peek() === Tf) {
                  this.pos += 1;
                  var Zr = So("![", this.sourcepos(this.pos - 1, this.pos));
                  Nr.appendChild(Zr), this.addBracket(Zr, $r + 1, !0);
                } else {
                  var Zr = So("!", this.sourcepos(this.pos, this.pos));
                  Nr.appendChild(Zr);
                }
                return !0;
              }, Dr.prototype.parseCloseBracket = function(Nr) {
                var $r = null, Zr = null, oi = !1;
                this.pos += 1;
                var _i = this.pos, Li = this.brackets;
                if (Li === null)
                  return Nr.appendChild(So("]", this.sourcepos(_i, _i))), !0;
                if (!Li.active)
                  return Nr.appendChild(So("]", this.sourcepos(_i, _i))), this.removeBracket(), !0;
                var Ui = Li.image, ea = this.pos;
                this.peek() === If && (this.pos++, this.spnl() && ($r = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
                (Lu.test(this.subject.charAt(this.pos - 1)) && (Zr = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === Su ? (this.pos += 1, oi = !0) : this.pos = ea);
                var la = "";
                if (!oi) {
                  var Ea = this.pos, Aa = this.parseLinkLabel();
                  if (Aa > 2 ? la = this.subject.slice(Ea, Ea + Aa) : Li.bracketAfter || (la = this.subject.slice(Li.index, _i)), Aa === 0 && (this.pos = ea), la) {
                    la = Cf(la);
                    var ka = this.refMap[la];
                    ka && ($r = ka.destination, Zr = ka.title, oi = !0);
                  }
                }
                if (oi) {
                  var Ha = bo(Ui ? "image" : "link");
                  Ha.destination = $r, Ha.title = Zr || "", Ha.sourcepos = [Li.startpos, this.sourcepos(this.pos)];
                  for (var Pa = Li.node.next, oo = void 0; Pa; )
                    oo = Pa.next, Pa.unlink(), Ha.appendChild(Pa), Pa = oo;
                  if (Nr.appendChild(Ha), this.processEmphasis(Li.previousDelimiter), this.removeBracket(), Li.node.unlink(), !Ui)
                    for (Li = this.brackets; Li !== null; )
                      Li.image || (Li.active = !1), Li = Li.previous;
                  return this.options.referenceDefinition && (this.refLinkCandidateMap[Nr.id] = { node: Nr, refLabel: la }), !0;
                }
                return this.removeBracket(), this.pos = _i, Nr.appendChild(So("]", this.sourcepos(_i, _i))), this.options.referenceDefinition && (this.refLinkCandidateMap[Nr.id] = { node: Nr, refLabel: la }), !0;
              }, Dr.prototype.addBracket = function(Nr, $r, Zr) {
                this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
                  node: Nr,
                  startpos: this.sourcepos($r + (Zr ? 0 : 1)),
                  previous: this.brackets,
                  previousDelimiter: this.delimiters,
                  index: $r,
                  image: Zr,
                  active: !0
                };
              }, Dr.prototype.removeBracket = function() {
                this.brackets && (this.brackets = this.brackets.previous);
              }, Dr.prototype.parseEntity = function(Nr) {
                var $r, Zr = this.pos + 1;
                return ($r = this.match(Dz)) ? (Nr.appendChild(So(zr.decodeHTML($r), this.sourcepos(Zr, this.pos))), !0) : !1;
              }, Dr.prototype.parseString = function(Nr) {
                var $r, Zr = this.pos + 1;
                if ($r = this.match(Kz)) {
                  if (this.options.smart) {
                    var oi = $r.replace(Hz, "…").replace(Uz, function(Li) {
                      var Ui = 0, ea = 0;
                      return Li.length % 3 === 0 ? ea = Li.length / 3 : Li.length % 2 === 0 ? Ui = Li.length / 2 : Li.length % 3 === 2 ? (Ui = 1, ea = (Li.length - 2) / 3) : (Ui = 2, ea = (Li.length - 4) / 3), _u("—", ea) + _u("–", Ui);
                    });
                    Nr.appendChild(So(oi, this.sourcepos(Zr, this.pos)));
                  } else {
                    var _i = So($r, this.sourcepos(Zr, this.pos));
                    Nr.appendChild(_i);
                  }
                  return !0;
                }
                return !1;
              }, Dr.prototype.parseNewline = function(Nr) {
                this.pos += 1;
                var $r = Nr.lastChild;
                if ($r && $r.type === "text" && $r.literal[$r.literal.length - 1] === " ") {
                  var Zr = $r.literal[$r.literal.length - 2] === " ", oi = $r.literal.length;
                  $r.literal = $r.literal.replace(jz, "");
                  var _i = oi - $r.literal.length;
                  $r.sourcepos[1][1] -= _i, Nr.appendChild(bo(Zr ? "linebreak" : "softbreak", this.sourcepos(this.pos - _i, this.pos)));
                } else
                  Nr.appendChild(bo("softbreak", this.sourcepos(this.pos, this.pos)));
                return this.nextLine(), this.match($z), !0;
              }, Dr.prototype.parseReference = function(Nr, $r) {
                if (!this.options.referenceDefinition)
                  return 0;
                this.subject = Nr.stringContent, this.pos = 0;
                var Zr = null, oi = this.pos, _i = this.parseLinkLabel();
                if (_i === 0)
                  return 0;
                var Li = this.subject.substr(0, _i);
                if (this.peek() === Mz)
                  this.pos++;
                else
                  return this.pos = oi, 0;
                this.spnl();
                var Ui = this.parseLinkDestination();
                if (Ui === null)
                  return this.pos = oi, 0;
                var ea = this.pos;
                this.spnl(), this.pos !== ea && (Zr = this.parseLinkTitle()), Zr === null && (Zr = "", this.pos = ea);
                var la = !0;
                if (this.match(Nf) === null && (Zr === "" ? la = !1 : (Zr = "", this.pos = ea, la = this.match(Nf) !== null)), !la)
                  return this.pos = oi, 0;
                var Ea = Cf(Li);
                if (Ea === "")
                  return this.pos = oi, 0;
                var Aa = this.getReferenceDefSourcepos(Nr);
                Nr.sourcepos[0][0] = Aa[1][0] + 1;
                var ka = bo("refDef", Aa);
                return ka.title = Zr, ka.dest = Ui, ka.label = Ea, Nr.insertBefore(ka), $r[Ea] ? this.refDefCandidateMap[ka.id] = ka : $r[Ea] = Hu(ka), this.pos - oi;
              }, Dr.prototype.mergeTextNodes = function(Nr) {
                for (var $r, Zr = []; $r = Nr.next(); ) {
                  var oi = $r.entering, _i = $r.node;
                  if (oi && _i.type === "text")
                    Zr.push(_i);
                  else if (Zr.length === 1)
                    Zr = [];
                  else if (Zr.length > 1) {
                    var Li = Zr[0], Ui = Zr[Zr.length - 1];
                    Li.sourcepos && Ui.sourcepos && (Li.sourcepos[1] = Ui.sourcepos[1]), Li.next = Ui.next, Li.next && (Li.next.prev = Li);
                    for (var ea = 1; ea < Zr.length; ea += 1)
                      Li.literal += Zr[ea].literal, Zr[ea].unlink();
                    Zr = [];
                  }
                }
              }, Dr.prototype.getReferenceDefSourcepos = function(Nr) {
                for (var $r = Nr.stringContent.split(/\n|\r\n/), Zr = !1, oi = 0, _i = { line: 0, ch: 0 }, Li = 0; Li < $r.length; Li += 1) {
                  var Ui = $r[Li];
                  if (Lu.test(Ui))
                    break;
                  if (/\:/.test(Ui) && oi === 0) {
                    if (Zr)
                      break;
                    var ea = Ui.indexOf(":") === Ui.length - 1 ? Li + 1 : Li;
                    _i = { line: ea, ch: $r[ea].length }, Zr = !0;
                  }
                  var la = Ui.match(/'|"/g);
                  if (la && (oi += la.length), oi === 2) {
                    _i = { line: Li, ch: Ui.length };
                    break;
                  }
                }
                return [
                  [Nr.sourcepos[0][0], Nr.sourcepos[0][1]],
                  [Nr.sourcepos[0][0] + _i.line, _i.ch]
                ];
              }, Dr.prototype.parseInline = function(Nr) {
                var $r, Zr = !1, oi = this.peek();
                if (oi === -1)
                  return !1;
                switch (oi) {
                  case Tu:
                    Zr = this.parseNewline(Nr);
                    break;
                  case Sf:
                    Zr = this.parseBackslash(Nr);
                    break;
                  case Sz:
                    Zr = this.parseBackticks(Nr);
                    break;
                  case Au:
                  case kc:
                  case _c:
                  case sl:
                    Zr = this.handleDelim(oi, Nr);
                    break;
                  case al:
                  case ol:
                    Zr = !!(!(($r = this.options) === null || $r === void 0) && $r.smart) && this.handleDelim(oi, Nr);
                    break;
                  case Tf:
                    Zr = this.parseOpenBracket(Nr);
                    break;
                  case Lz:
                    Zr = this.parseBang(Nr);
                    break;
                  case Iz:
                    Zr = this.parseCloseBracket(Nr);
                    break;
                  case Af:
                    Zr = this.parseAutolink(Nr) || this.parseHtmlTag(Nr);
                    break;
                  case Rz:
                    Nr.disabledEntityParse || (Zr = this.parseEntity(Nr));
                    break;
                  default:
                    Zr = this.parseString(Nr);
                    break;
                }
                return Zr || (this.pos += 1, Nr.appendChild(So(Cu(oi), this.sourcepos(this.pos, this.pos + 1)))), !0;
              }, Dr.prototype.parse = function(Nr) {
                for (this.subject = Nr.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = Nr.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = Nr.sourcepos[0][0], QU(Nr) && (this.lineOffsets[0] += Nr.level + 1); this.parseInline(Nr); )
                  ;
                Nr.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(Nr.walker());
                var $r = this.options, Zr = $r.extendedAutolinks, oi = $r.customParser;
                if (Zr && Cz(Nr.walker(), Zr), oi && Nr.firstChild)
                  for (var _i, Li = Nr.firstChild.walker(); _i = Li.next(); ) {
                    var Ui = _i.node, ea = _i.entering;
                    oi[Ui.type] && oi[Ui.type](Ui, { entering: ea, options: this.options });
                  }
              }, Dr;
            }()
          ), Wz = /^\[([ \txX])\][ \t]+/;
          function Zz(Dr, Nr) {
            if (Nr.firstChild && Nr.firstChild.type === "paragraph") {
              var $r = Nr.firstChild, Zr = $r.stringContent.match(Wz);
              if (Zr) {
                var oi = Zr[0].length;
                $r.stringContent = $r.stringContent.substring(oi - 1), $r.sourcepos[0][1] += oi, $r.lineOffsets[0] += oi, Nr.listData.task = !0, Nr.listData.checked = /[xX]/.test(Zr[1]);
              }
            }
          }
          var Xz = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr === "tableHead" || Dr === "tableBody";
            },
            acceptsLines: !1
          }, Jz = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr === "tableRow";
            },
            acceptsLines: !1
          }, Yz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr === "tableRow" || Dr === "tableDelimRow";
            },
            acceptsLines: !1
          }, Qz = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr === "tableDelimCell";
            },
            acceptsLines: !1
          }, eF = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, tF = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr === "tableCell";
            },
            acceptsLines: !1
          }, rF = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, wc = 4, Of = 9, Df = 62, nF = 60, Bf = 32, Pf = 91, Hf = /[^ \t\f\v\r\n]/, iF = /^(?:`{3,}|~{3,})(?= *$)/;
          function Uf(Dr) {
            for (var Nr = Dr; Nr; ) {
              if (Nr.lastLineBlank)
                return !0;
              var $r = Nr.type;
              if (!Nr.lastLineChecked && ($r === "list" || $r === "item"))
                Nr.lastLineChecked = !0, Nr = Nr.lastChild;
              else {
                Nr.lastLineChecked = !0;
                break;
              }
            }
            return !1;
          }
          function Go(Dr, Nr) {
            return Nr < Dr.length ? Dr.charCodeAt(Nr) : -1;
          }
          function zf(Dr) {
            return !Hf.test(Dr);
          }
          function kl(Dr) {
            return Dr === Bf || Dr === Of;
          }
          var aF = /^\$\$$/, oF = {
            continue: function(Dr, Nr) {
              var $r = Dr.currentLine, Zr = $r.match(aF);
              if (Zr)
                return Dr.lastLineLength = Zr[0].length, Dr.finalize(Nr, Dr.lineNumber), 2;
              for (var oi = Nr.offset; oi > 0 && kl(Go($r, Dr.offset)); )
                Dr.advanceOffset(1, !0), oi--;
              return 0;
            },
            finalize: function(Dr, Nr) {
              if (Nr.stringContent !== null) {
                var $r = Nr.stringContent, Zr = $r.indexOf(`
`), oi = $r.slice(0, Zr), _i = $r.slice(Zr + 1), Li = oi.match(/^(\s*)(.*)/);
                Nr.info = Nl(Li[2].trim()), Nr.literal = _i, Nr.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, Ff = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, sF = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr !== "item";
            },
            acceptsLines: !1
          }, lF = {
            continue: function() {
              return 0;
            },
            finalize: function(Dr, Nr) {
              for (var $r = Nr.firstChild; $r; ) {
                if (Uf($r) && $r.next) {
                  Nr.listData.tight = !1;
                  break;
                }
                for (var Zr = $r.firstChild; Zr; ) {
                  if (Uf(Zr) && ($r.next || Zr.next)) {
                    Nr.listData.tight = !1;
                    break;
                  }
                  Zr = Zr.next;
                }
                $r = $r.next;
              }
            },
            canContain: function(Dr) {
              return Dr === "item";
            },
            acceptsLines: !1
          }, cF = {
            continue: function(Dr) {
              var Nr = Dr.currentLine;
              if (!Dr.indented && Go(Nr, Dr.nextNonspace) === Df)
                Dr.advanceNextNonspace(), Dr.advanceOffset(1, !1), kl(Go(Nr, Dr.offset)) && Dr.advanceOffset(1, !0);
              else
                return 1;
              return 0;
            },
            finalize: function() {
            },
            canContain: function(Dr) {
              return Dr !== "item";
            },
            acceptsLines: !1
          }, uF = {
            continue: function(Dr, Nr) {
              if (Dr.blank) {
                if (Nr.firstChild === null)
                  return 1;
                Dr.advanceNextNonspace();
              } else if (Dr.indent >= Nr.listData.markerOffset + Nr.listData.padding)
                Dr.advanceOffset(Nr.listData.markerOffset + Nr.listData.padding, !0);
              else
                return 1;
              return 0;
            },
            finalize: Zz,
            canContain: function(Dr) {
              return Dr !== "item";
            },
            acceptsLines: !1
          }, fF = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, dF = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, hF = {
            continue: function(Dr, Nr) {
              var $r = Dr.currentLine, Zr = Dr.indent;
              if (Nr.isFenced) {
                var oi = Zr <= 3 && $r.charAt(Dr.nextNonspace) === Nr.fenceChar && $r.slice(Dr.nextNonspace).match(iF);
                if (oi && oi[0].length >= Nr.fenceLength)
                  return Dr.lastLineLength = Dr.offset + Zr + oi[0].length, Dr.finalize(Nr, Dr.lineNumber), 2;
                for (var _i = Nr.fenceOffset; _i > 0 && kl(Go($r, Dr.offset)); )
                  Dr.advanceOffset(1, !0), _i--;
              } else if (Zr >= wc)
                Dr.advanceOffset(wc, !0);
              else if (Dr.blank)
                Dr.advanceNextNonspace();
              else
                return 1;
              return 0;
            },
            finalize: function(Dr, Nr) {
              var $r;
              if (Nr.stringContent !== null) {
                if (Nr.isFenced) {
                  var Zr = Nr.stringContent, oi = Zr.indexOf(`
`), _i = Zr.slice(0, oi), Li = Zr.slice(oi + 1), Ui = _i.match(/^(\s*)(.*)/);
                  Nr.infoPadding = Ui[1].length, Nr.info = Nl(Ui[2].trim()), Nr.literal = Li;
                } else
                  Nr.literal = ($r = Nr.stringContent) === null || $r === void 0 ? void 0 : $r.replace(/(\n *)+$/, `
`);
                Nr.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, pF = {
            continue: function(Dr, Nr) {
              return Dr.blank && (Nr.htmlBlockType === 6 || Nr.htmlBlockType === 7) ? 1 : 0;
            },
            finalize: function(Dr, Nr) {
              var $r;
              Nr.literal = (($r = Nr.stringContent) === null || $r === void 0 ? void 0 : $r.replace(/(\n *)+$/, "")) || null, Nr.stringContent = null;
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, gF = {
            continue: function(Dr) {
              return Dr.blank ? 1 : 0;
            },
            finalize: function(Dr, Nr) {
              if (Nr.stringContent !== null) {
                for (var $r, Zr = !1; Go(Nr.stringContent, 0) === Pf && ($r = Dr.inlineParser.parseReference(Nr, Dr.refMap)); )
                  Nr.stringContent = Nr.stringContent.slice($r), Zr = !0;
                Zr && zf(Nr.stringContent) && Nr.unlink();
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, mF = Ff, vF = Ff, _l = {
            document: sF,
            list: lF,
            blockQuote: cF,
            item: uF,
            heading: fF,
            thematicBreak: dF,
            codeBlock: hF,
            htmlBlock: pF,
            paragraph: gF,
            table: Xz,
            tableBody: Jz,
            tableHead: Yz,
            tableRow: tF,
            tableCell: rF,
            tableDelimRow: Qz,
            tableDelimCell: eF,
            refDef: mF,
            customBlock: oF,
            frontMatter: vF
          };
          function Ru(Dr) {
            for (var Nr = 0, $r = 0, Zr = [], oi = 0; oi < Dr.length; oi += 1)
              if (Dr[oi] === "|" && Dr[oi - 1] !== "\\") {
                var _i = Dr.substring(Nr, oi);
                Nr === 0 && bf(_i) ? $r = oi + 1 : Zr.push(_i), Nr = oi + 1;
              }
            if (Nr < Dr.length) {
              var _i = Dr.substring(Nr, Dr.length);
              bf(_i) || Zr.push(_i);
            }
            return [$r, Zr];
          }
          function Ou(Dr, Nr, $r, Zr) {
            for (var oi = [], _i = 0, Li = Nr; _i < Li.length; _i++) {
              var Ui = Li[_i], ea = Ui.match(/^[ \t]+/), la = ea ? ea[0].length : 0, Ea = void 0, Aa = void 0;
              if (la === Ui.length)
                la = 0, Ea = 0, Aa = "";
              else {
                var ka = Ui.match(/[ \t]+$/);
                Ea = ka ? ka[0].length : 0, Aa = Ui.slice(la, Ui.length - Ea);
              }
              var Ha = Zr + la, Pa = bo(Dr, [
                [$r, Zr],
                [$r, Zr + Ui.length - 1]
              ]);
              Pa.stringContent = Aa.replace(/\\\|/g, "|"), Pa.startIdx = oi.length, Pa.endIdx = oi.length, Pa.lineOffsets = [Ha - 1], Pa.paddingLeft = la, Pa.paddingRight = Ea, oi.push(Pa), Zr += Ui.length + 1;
            }
            return oi;
          }
          function bF(Dr) {
            var Nr = null, $r = Dr.stringContent, Zr = $r[0], oi = $r[$r.length - 1];
            return oi === ":" ? Nr = Zr === ":" ? "center" : "right" : Zr === ":" && (Nr = "left"), { align: Nr };
          }
          var yF = function(Dr, Nr) {
            var $r = Nr.stringContent;
            if (Nr.type === "paragraph" && !Dr.indented && !Dr.blank) {
              var Zr = $r.length - 1, oi = $r.lastIndexOf(`
`, Zr - 1) + 1, _i = $r.slice(oi, Zr), Li = Dr.currentLine.slice(Dr.nextNonspace), Ui = Ru(_i), ea = Ui[0], la = Ui[1], Ea = Ru(Li), Aa = Ea[0], ka = Ea[1], Ha = /^[ \t]*:?-+:?[ \t]*$/;
              if (
                // not checking if the number of header cells and delimiter cells are the same
                // to consider the case of merged-column (via plugin)
                !la.length || !ka.length || ka.some(function(Is) {
                  return !Ha.test(Is);
                }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
                ka.length === 1 && Li.indexOf("|") !== 0
              )
                return 0;
              var Pa = Nr.lineOffsets, oo = Dr.lineNumber - 1, yo = bc(Pa) + 1, Lo = bo("table", [
                [oo, yo],
                [Dr.lineNumber, Dr.offset]
              ]);
              if (Lo.columns = ka.map(function() {
                return { align: null };
              }), Nr.insertAfter(Lo), Pa.length === 1)
                Nr.unlink();
              else {
                Nr.stringContent = $r.slice(0, oi);
                var Ts = $r.lastIndexOf(`
`, oi - 2) + 1, Jo = oi - Ts - 1;
                Dr.lastLineLength = Pa[Pa.length - 2] + Jo, Dr.finalize(Nr, oo - 1);
              }
              Dr.advanceOffset(Dr.currentLine.length - Dr.offset, !1);
              var Wo = bo("tableHead", [
                [oo, yo],
                [Dr.lineNumber, Dr.offset]
              ]);
              Lo.appendChild(Wo);
              var es = bo("tableRow", [
                [oo, yo],
                [oo, yo + _i.length - 1]
              ]), As = bo("tableDelimRow", [
                [Dr.lineNumber, Dr.nextNonspace + 1],
                [Dr.lineNumber, Dr.offset]
              ]);
              Wo.appendChild(es), Wo.appendChild(As), Ou("tableCell", la, oo, yo + ea).forEach(function(Is) {
                es.appendChild(Is);
              });
              var Ss = Ou("tableDelimCell", ka, Dr.lineNumber, Dr.nextNonspace + 1 + Aa);
              return Ss.forEach(function(Is) {
                As.appendChild(Is);
              }), Lo.columns = Ss.map(bF), Dr.tip = Lo, 2;
            }
            return 0;
          }, kF = function(Dr, Nr) {
            if (Nr.type !== "table" && Nr.type !== "tableBody" || !Dr.blank && Dr.currentLine.indexOf("|") === -1)
              return 0;
            if (Dr.advanceOffset(Dr.currentLine.length - Dr.offset, !1), Dr.blank) {
              var $r = Nr;
              return Nr.type === "tableBody" && ($r = Nr.parent, Dr.finalize(Nr, Dr.lineNumber - 1)), Dr.finalize($r, Dr.lineNumber - 1), 0;
            }
            var Zr = Nr;
            Nr.type === "table" && (Zr = Dr.addChild("tableBody", Dr.nextNonspace), Zr.stringContent = null);
            var oi = bo("tableRow", [
              [Dr.lineNumber, Dr.nextNonspace + 1],
              [Dr.lineNumber, Dr.currentLine.length]
            ]);
            Zr.appendChild(oi);
            var _i = Zr.parent, Li = Dr.currentLine.slice(Dr.nextNonspace), Ui = Ru(Li), ea = Ui[0], la = Ui[1];
            return Ou("tableCell", la, Dr.lineNumber, Dr.nextNonspace + 1 + ea).forEach(function(Ea, Aa) {
              Aa >= _i.columns.length && (Ea.ignored = !0), oi.appendChild(Ea);
            }), 2;
          }, _F = /^(\$\$)(\s*[a-zA-Z])+/, wF = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, xF = function(Dr) {
            var Nr;
            if (!Dr.indented && !wF.test(Dr.currentLine) && (Nr = Dr.currentLine.match(_F))) {
              var $r = Nr[1].length;
              Dr.closeUnmatchedBlocks();
              var Zr = Dr.addChild("customBlock", Dr.nextNonspace);
              return Zr.syntaxLength = $r, Zr.offset = Dr.indent, Dr.advanceNextNonspace(), Dr.advanceOffset($r, !1), 2;
            }
            return 0;
          }, EF = /^`{3,}(?!.*`)|^~{3,}/, CF = [
            /./,
            /^<(?:script|pre|style)(?:\s|>|$)/i,
            /^<!--/,
            /^<[?]/,
            /^<![A-Z]/,
            /^<!\[CDATA\[/,
            /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
            new RegExp("^(?:" + xf + "|" + Ef + ")\\s*$", "i")
          ], TF = /^(?:=+|-+)[ \t]*$/, AF = /^#{1,6}(?:[ \t]+|$)/, SF = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, qf = /^[*+-]/, jf = /^(\d{1,9})([.)])/;
          function IF(Dr, Nr) {
            var $r = Dr.currentLine.slice(Dr.nextNonspace), Zr, oi, _i = {
              type: "bullet",
              tight: !0,
              bulletChar: "",
              start: 0,
              delimiter: "",
              padding: 0,
              markerOffset: Dr.indent,
              // GFM: Task List Item
              task: !1,
              checked: !1
            };
            if (Dr.indent >= 4)
              return null;
            if (Zr = $r.match(qf))
              _i.type = "bullet", _i.bulletChar = Zr[0][0];
            else if ((Zr = $r.match(jf)) && (Nr.type !== "paragraph" || Zr[1] === "1"))
              _i.type = "ordered", _i.start = parseInt(Zr[1], 10), _i.delimiter = Zr[2];
            else
              return null;
            if (oi = Go(Dr.currentLine, Dr.nextNonspace + Zr[0].length), !(oi === -1 || oi === Of || oi === Bf) || Nr.type === "paragraph" && !Dr.currentLine.slice(Dr.nextNonspace + Zr[0].length).match(Hf))
              return null;
            Dr.advanceNextNonspace(), Dr.advanceOffset(Zr[0].length, !0);
            var Li = Dr.column, Ui = Dr.offset;
            do
              Dr.advanceOffset(1, !0), oi = Go(Dr.currentLine, Dr.offset);
            while (Dr.column - Li < 5 && kl(oi));
            var ea = Go(Dr.currentLine, Dr.offset) === -1, la = Dr.column - Li;
            return la >= 5 || la < 1 || ea ? (_i.padding = Zr[0].length + 1, Dr.column = Li, Dr.offset = Ui, kl(Go(Dr.currentLine, Dr.offset)) && Dr.advanceOffset(1, !0)) : _i.padding = Zr[0].length + la, _i;
          }
          function LF(Dr, Nr) {
            return Dr.type === Nr.type && Dr.delimiter === Nr.delimiter && Dr.bulletChar === Nr.bulletChar;
          }
          function $f(Dr, Nr) {
            return Dr.options.disallowDeepHeading && (Nr.type === "blockQuote" || Nr.type === "item");
          }
          var RF = function(Dr) {
            return !Dr.indented && Go(Dr.currentLine, Dr.nextNonspace) === Df ? (Dr.advanceNextNonspace(), Dr.advanceOffset(1, !1), kl(Go(Dr.currentLine, Dr.offset)) && Dr.advanceOffset(1, !0), Dr.closeUnmatchedBlocks(), Dr.addChild("blockQuote", Dr.nextNonspace), 1) : 0;
          }, MF = function(Dr, Nr) {
            var $r;
            if (!Dr.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !$f(Dr, Nr) && ($r = Dr.currentLine.slice(Dr.nextNonspace).match(AF))) {
              Dr.advanceNextNonspace(), Dr.advanceOffset($r[0].length, !1), Dr.closeUnmatchedBlocks();
              var Zr = Dr.addChild("heading", Dr.nextNonspace);
              return Zr.level = $r[0].trim().length, Zr.headingType = "atx", Zr.stringContent = Dr.currentLine.slice(Dr.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), Dr.advanceOffset(Dr.currentLine.length - Dr.offset), 2;
            }
            return 0;
          }, NF = function(Dr) {
            var Nr;
            if (!Dr.indented && (Nr = Dr.currentLine.slice(Dr.nextNonspace).match(EF))) {
              var $r = Nr[0].length;
              Dr.closeUnmatchedBlocks();
              var Zr = Dr.addChild("codeBlock", Dr.nextNonspace);
              return Zr.isFenced = !0, Zr.fenceLength = $r, Zr.fenceChar = Nr[0][0], Zr.fenceOffset = Dr.indent, Dr.advanceNextNonspace(), Dr.advanceOffset($r, !1), 2;
            }
            return 0;
          }, OF = function(Dr, Nr) {
            if (!Dr.indented && Go(Dr.currentLine, Dr.nextNonspace) === nF) {
              var $r = Dr.currentLine.slice(Dr.nextNonspace), Zr = Dr.options.disallowedHtmlBlockTags, oi = void 0;
              for (oi = 1; oi <= 7; oi++) {
                var _i = $r.match(CF[oi]);
                if (_i) {
                  if (oi === 7) {
                    if (Nr.type === "paragraph")
                      return 0;
                    if (Zr.length > 0) {
                      var Li = new RegExp("</?(?:" + Zr.join("|") + ")", "i");
                      if (Li.test(_i[0]))
                        return 0;
                    }
                  }
                  Dr.closeUnmatchedBlocks();
                  var Ui = Dr.addChild("htmlBlock", Dr.offset);
                  return Ui.htmlBlockType = oi, 2;
                }
              }
            }
            return 0;
          }, DF = function(Dr, Nr) {
            var $r;
            if (Nr.stringContent !== null && !Dr.indented && Nr.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !$f(Dr, Nr.parent) && ($r = Dr.currentLine.slice(Dr.nextNonspace).match(TF))) {
              Dr.closeUnmatchedBlocks();
              for (var Zr = void 0; Go(Nr.stringContent, 0) === Pf && (Zr = Dr.inlineParser.parseReference(Nr, Dr.refMap)); )
                Nr.stringContent = Nr.stringContent.slice(Zr);
              if (Nr.stringContent.length > 0) {
                var oi = bo("heading", Nr.sourcepos);
                return oi.level = $r[0][0] === "=" ? 1 : 2, oi.headingType = "setext", oi.stringContent = Nr.stringContent, Nr.insertAfter(oi), Nr.unlink(), Dr.tip = oi, Dr.advanceOffset(Dr.currentLine.length - Dr.offset, !1), 2;
              }
              return 0;
            }
            return 0;
          }, BF = function(Dr) {
            return !Dr.indented && SF.test(Dr.currentLine.slice(Dr.nextNonspace)) ? (Dr.closeUnmatchedBlocks(), Dr.addChild("thematicBreak", Dr.nextNonspace), Dr.advanceOffset(Dr.currentLine.length - Dr.offset, !1), 2) : 0;
          }, PF = function(Dr, Nr) {
            var $r, Zr = Nr;
            return (!Dr.indented || Nr.type === "list") && ($r = IF(Dr, Zr)) ? (Dr.closeUnmatchedBlocks(), (Dr.tip.type !== "list" || !LF(Zr.listData, $r)) && (Zr = Dr.addChild("list", Dr.nextNonspace), Zr.listData = $r), Zr = Dr.addChild("item", Dr.nextNonspace), Zr.listData = $r, 1) : 0;
          }, HF = function(Dr) {
            return Dr.indented && Dr.tip.type !== "paragraph" && !Dr.blank ? (Dr.advanceOffset(wc, !0), Dr.closeUnmatchedBlocks(), Dr.addChild("codeBlock", Dr.offset), 2) : 0;
          }, Du = [
            RF,
            MF,
            NF,
            OF,
            DF,
            BF,
            PF,
            HF,
            yF,
            kF,
            xF
          ], Vf = /^(-{3}|\+{3}|;{3})$/, UF = function(Dr, Nr) {
            var $r = Dr.currentLine, Zr = Dr.lineNumber, oi = Dr.indented;
            if (Zr === 1 && !oi && Nr.type === "document" && Vf.test($r)) {
              Dr.closeUnmatchedBlocks();
              var _i = Dr.addChild("frontMatter", Dr.nextNonspace);
              return _i.stringContent = $r, Dr.advanceNextNonspace(), Dr.advanceOffset($r.length, !1), 2;
            }
            return 0;
          }, zF = {
            continue: function(Dr, Nr) {
              var $r = Dr.currentLine, Zr = $r.match(Vf);
              return Nr.type === "frontMatter" && Zr ? (Nr.stringContent += $r, Dr.lastLineLength = Zr[0].length, Dr.finalize(Nr, Dr.lineNumber), 2) : 0;
            },
            finalize: function(Dr, Nr) {
              Nr.stringContent !== null && (Nr.literal = Nr.stringContent, Nr.stringContent = null);
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, FF = [
            /./,
            /<\/(?:script|pre|style)>/i,
            /-->/,
            /\?>/,
            />/,
            /\]\]>/
          ], qF = /^[#`~*+_=<>0-9-;$]/, jF = /\r\n|\n|\r/;
          function Bu() {
            return bo("document", [
              [1, 1],
              [0, 0]
            ]);
          }
          var $F = {
            smart: !1,
            tagFilter: !1,
            extendedAutolinks: !1,
            disallowedHtmlBlockTags: [],
            referenceDefinition: !1,
            disallowDeepHeading: !1,
            customParser: null,
            frontMatter: !1
          }, VF = (
            /** @class */
            function() {
              function Dr(Nr) {
                this.options = Cr(Cr({}, $F), Nr), this.doc = Bu(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (_l.frontMatter = zF, Du.unshift(UF)), this.inlineParser = new Gz(this.options);
              }
              return Dr.prototype.advanceOffset = function(Nr, $r) {
                $r === void 0 && ($r = !1);
                for (var Zr = this.currentLine, oi, _i, Li; Nr > 0 && (Li = Zr[this.offset]); )
                  Li === "	" ? (oi = 4 - this.column % 4, $r ? (this.partiallyConsumedTab = oi > Nr, _i = oi > Nr ? Nr : oi, this.column += _i, this.offset += this.partiallyConsumedTab ? 0 : 1, Nr -= _i) : (this.partiallyConsumedTab = !1, this.column += oi, this.offset += 1, Nr -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, Nr -= 1);
              }, Dr.prototype.advanceNextNonspace = function() {
                this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
              }, Dr.prototype.findNextNonspace = function() {
                for (var Nr = this.currentLine, $r = this.offset, Zr = this.column, oi; (oi = Nr.charAt($r)) !== ""; )
                  if (oi === " ")
                    $r++, Zr++;
                  else if (oi === "	")
                    $r++, Zr += 4 - Zr % 4;
                  else
                    break;
                this.blank = oi === `
` || oi === "\r" || oi === "", this.nextNonspace = $r, this.nextNonspaceColumn = Zr, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= wc;
              }, Dr.prototype.addLine = function() {
                if (this.partiallyConsumedTab) {
                  this.offset += 1;
                  var Nr = 4 - this.column % 4;
                  this.tip.stringContent += _u(" ", Nr);
                }
                this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
              }, Dr.prototype.addChild = function(Nr, $r) {
                for (; !_l[this.tip.type].canContain(Nr); )
                  this.finalize(this.tip, this.lineNumber - 1);
                var Zr = $r + 1, oi = bo(Nr, [
                  [this.lineNumber, Zr],
                  [0, 0]
                ]);
                return oi.stringContent = "", this.tip.appendChild(oi), this.tip = oi, oi;
              }, Dr.prototype.closeUnmatchedBlocks = function() {
                if (!this.allClosed) {
                  for (; this.oldtip !== this.lastMatchedContainer; ) {
                    var Nr = this.oldtip.parent;
                    this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = Nr;
                  }
                  this.allClosed = !0;
                }
              }, Dr.prototype.finalize = function(Nr, $r) {
                var Zr = Nr.parent;
                Nr.open = !1, Nr.sourcepos[1] = [$r, this.lastLineLength], _l[Nr.type].finalize(this, Nr), this.tip = Zr;
              }, Dr.prototype.processInlines = function(Nr) {
                var $r, Zr = this.options.customParser, oi = Nr.walker();
                for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; $r = oi.next(); ) {
                  var _i = $r.node, Li = $r.entering, Ui = _i.type;
                  Zr && Zr[Ui] && Zr[Ui](_i, { entering: Li, options: this.options }), !Li && (Ui === "paragraph" || Ui === "heading" || Ui === "tableCell" && !_i.ignored) && this.inlineParser.parse(_i);
                }
              }, Dr.prototype.incorporateLine = function(Nr) {
                var $r = this.doc;
                this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, Nr.indexOf("\0") !== -1 && (Nr = Nr.replace(/\0/g, "�")), this.currentLine = Nr;
                for (var Zr = !0, oi; (oi = $r.lastChild) && oi.open; ) {
                  switch ($r = oi, this.findNextNonspace(), _l[$r.type].continue(this, $r)) {
                    case 0:
                      break;
                    case 1:
                      Zr = !1;
                      break;
                    case 2:
                      this.lastLineLength = Nr.length;
                      return;
                    default:
                      throw new Error("continue returned illegal value, must be 0, 1, or 2");
                  }
                  if (!Zr) {
                    $r = $r.parent;
                    break;
                  }
                }
                this.allClosed = $r === this.oldtip, this.lastMatchedContainer = $r;
                for (var _i = $r.type !== "paragraph" && _l[$r.type].acceptsLines, Li = Du.length; !_i; ) {
                  if (this.findNextNonspace(), $r.type !== "table" && $r.type !== "tableBody" && $r.type !== "paragraph" && !this.indented && !qF.test(Nr.slice(this.nextNonspace))) {
                    this.advanceNextNonspace();
                    break;
                  }
                  for (var Ui = 0; Ui < Li; ) {
                    var ea = Du[Ui](this, $r);
                    if (ea === 1) {
                      $r = this.tip;
                      break;
                    } else if (ea === 2) {
                      $r = this.tip, _i = !0;
                      break;
                    } else
                      Ui++;
                  }
                  if (Ui === Li) {
                    this.advanceNextNonspace();
                    break;
                  }
                }
                if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
                  this.addLine();
                else {
                  this.closeUnmatchedBlocks(), this.blank && $r.lastChild && ($r.lastChild.lastLineBlank = !0);
                  for (var la = $r.type, Ea = this.blank && !(la === "blockQuote" || yf($r) && $r.isFenced || la === "item" && !$r.firstChild && $r.sourcepos[0][0] === this.lineNumber), Aa = $r; Aa; )
                    Aa.lastLineBlank = Ea, Aa = Aa.parent;
                  _l[la].acceptsLines ? (this.addLine(), YU($r) && $r.htmlBlockType >= 1 && $r.htmlBlockType <= 5 && FF[$r.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = Nr.length, this.finalize($r, this.lineNumber))) : this.offset < Nr.length && !this.blank && ($r = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
                }
                this.lastLineLength = Nr.length;
              }, Dr.prototype.parse = function(Nr, $r) {
                this.doc = Bu(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                var Zr = Nr.split(jF), oi = Zr.length;
                this.lines = $r || Zr, this.options.referenceDefinition && this.clearRefMaps(), Nr.charCodeAt(Nr.length - 1) === Tu && (oi -= 1);
                for (var _i = 0; _i < oi; _i++)
                  this.incorporateLine(Zr[_i]);
                for (; this.tip; )
                  this.finalize(this.tip, oi);
                return this.processInlines(this.doc), this.doc;
              }, Dr.prototype.partialParseStart = function(Nr, $r) {
                this.doc = Bu(), this.tip = this.doc, this.lineNumber = Nr - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                for (var Zr = $r.length, oi = 0; oi < Zr; oi++)
                  this.incorporateLine($r[oi]);
                return this.doc;
              }, Dr.prototype.partialParseExtends = function(Nr) {
                for (var $r = 0; $r < Nr.length; $r++)
                  this.incorporateLine(Nr[$r]);
              }, Dr.prototype.partialParseFinish = function() {
                for (; this.tip; )
                  this.finalize(this.tip, this.lineNumber);
                this.processInlines(this.doc);
              }, Dr.prototype.setRefMaps = function(Nr, $r, Zr) {
                this.refMap = Nr, this.refLinkCandidateMap = $r, this.refDefCandidateMap = Zr;
              }, Dr.prototype.clearRefMaps = function() {
                [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(Nr) {
                  Az(Nr);
                });
              }, Dr;
            }()
          );
          function Kf(Dr, Nr) {
            return Dr[0] < Nr[0] ? 1 : Dr[0] > Nr[0] ? -1 : Dr[1] < Nr[1] ? 1 : Dr[1] > Nr[1] ? -1 : 0;
          }
          function KF(Dr, Nr) {
            var $r = Dr[0], Zr = Dr[1];
            return Kf(Zr, Nr) === 1 ? 1 : Kf($r, Nr) === -1 ? -1 : 0;
          }
          function GF(Dr, Nr) {
            if (!(Dr.parent !== Nr.parent || Dr === Nr)) {
              for (var $r = Dr.next; $r && $r !== Nr; ) {
                for (var Zr = $r.next, oi = 0, _i = ["parent", "prev", "next"]; oi < _i.length; oi++) {
                  var Li = _i[oi];
                  $r[Li] && (xu($r[Li].id), $r[Li] = null);
                }
                $r = Zr;
              }
              Dr.next = Nr.next, Nr.next ? Nr.next.prev = Dr : Dr.parent.lastChild = Dr;
            }
          }
          function WF(Dr) {
            for (var Nr = [], $r = Dr.firstChild; $r; )
              Nr.push($r), $r = $r.next;
            return Nr;
          }
          function Gf(Dr, Nr) {
            for (var $r = 0, Zr = Nr; $r < Zr.length; $r++) {
              var oi = Zr[$r];
              Dr.insertBefore(oi);
            }
          }
          function ZF(Dr, Nr) {
            for (var $r = Nr.length - 1; $r >= 0; $r -= 1)
              Dr.prependChild(Nr[$r]);
          }
          function XF(Dr, Nr) {
            if (!(!Dr || !Dr.parent || Nr === 0)) {
              var $r = Dr.parent.walker();
              $r.resumeAt(Dr, !0);
              for (var Zr; Zr = $r.next(); ) {
                var oi = Zr.node, _i = Zr.entering;
                _i && (oi.sourcepos[0][0] += Nr, oi.sourcepos[1][0] += Nr);
              }
            }
          }
          function Wf(Dr, Nr) {
            var $r = Dr[0], Zr = Dr[1];
            return Zr[0] < Nr ? 1 : $r[0] > Nr ? -1 : 0;
          }
          function xc(Dr, Nr) {
            for (var $r = Dr.firstChild; $r; ) {
              var Zr = Wf($r.sourcepos, Nr);
              if (Zr === 0)
                return $r;
              if (Zr === -1)
                return $r.prev || $r;
              $r = $r.next;
            }
            return Dr.lastChild;
          }
          function JF(Dr) {
            for (; Dr.lastChild; )
              Dr = Dr.lastChild;
            return Dr;
          }
          function YF(Dr) {
            for (; Dr.parent && Dr.parent.type !== "document" && Dr.parent.sourcepos[0][0] === Dr.sourcepos[0][0]; )
              Dr = Dr.parent;
            return Dr;
          }
          function QF(Dr, Nr) {
            for (var $r = Dr.firstChild, Zr = null; $r; ) {
              var oi = Wf($r.sourcepos, Nr);
              if (oi === 0) {
                if ($r.sourcepos[0][0] === Nr || !$r.firstChild)
                  return $r;
                Zr = $r, $r = $r.firstChild;
              } else {
                if (oi === -1)
                  break;
                Zr = $r, $r = $r.next;
              }
            }
            return Zr ? YF(JF(Zr)) : null;
          }
          function eq(Dr, Nr) {
            for (var $r = Dr, Zr = null; $r; ) {
              var oi = KF($r.sourcepos, Nr);
              if (oi === 0)
                if ($r.firstChild)
                  Zr = $r, $r = $r.firstChild;
                else
                  return $r;
              else {
                if (oi === -1)
                  return Zr;
                if ($r.next)
                  $r = $r.next;
                else
                  return Zr;
              }
            }
            return $r;
          }
          function Zf(Dr) {
            return UU(Dr) || null;
          }
          function Pu(Dr, Nr, $r) {
            if ($r === void 0 && ($r = null), Nr)
              for (var Zr = Nr.walker(); Nr && Nr !== $r; ) {
                Dr(Nr);
                var oi = Zr.next();
                if (oi)
                  Nr = oi.node;
                else
                  break;
              }
          }
          function tq(Dr) {
            var Nr = Zf(Dr);
            if (!Nr)
              return !0;
            for (; Nr && Nr.type !== "document"; ) {
              if (!Nr.parent && !Nr.prev && !Nr.next)
                return !0;
              Nr = Nr.parent;
            }
            return !1;
          }
          var Xf = /\r\n|\n|\r/;
          function rq(Dr) {
            var Nr = Dr.match(/^[ \t]+/);
            if (Nr && (Nr[0].length >= 2 || /\t/.test(Nr[0])))
              return !0;
            var $r = Nr ? Dr.slice(Nr.length) : Dr;
            return qf.test($r) || jf.test($r);
          }
          function nq(Dr) {
            return !zf(Dr) && Dr.indexOf("|") !== -1;
          }
          function Hu(Dr) {
            var Nr = Dr.id, $r = Dr.title, Zr = Dr.sourcepos, oi = Dr.dest;
            return {
              id: Nr,
              title: $r,
              sourcepos: Zr,
              unlinked: !1,
              destination: oi
            };
          }
          var iq = (
            /** @class */
            function() {
              function Dr(Nr, $r) {
                this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!($r != null && $r.referenceDefinition), this.parser = new VF($r), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, Nr = Nr || "", this.lineTexts = Nr.split(Xf), this.root = this.parser.parse(Nr, this.lineTexts);
              }
              return Dr.prototype.updateLineTexts = function(Nr, $r, Zr) {
                var oi, _i = Nr[0], Li = Nr[1], Ui = $r[0], ea = $r[1], la = Zr.split(Xf), Ea = la.length, Aa = this.lineTexts[_i - 1], ka = this.lineTexts[Ui - 1];
                la[0] = Aa.slice(0, Li - 1) + la[0], la[Ea - 1] = la[Ea - 1] + ka.slice(ea - 1);
                var Ha = Ui - _i + 1;
                return (oi = this.lineTexts).splice.apply(oi, Tr([_i - 1, Ha], la)), Ea - Ha;
              }, Dr.prototype.updateRootNodeState = function() {
                if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
                  this.root.lastLineBlank = !0, this.root.sourcepos = [
                    [1, 1],
                    [1, 0]
                  ];
                  return;
                }
                this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
                for (var Nr = this.lineTexts, $r = Nr.length - 1; Nr[$r] === ""; )
                  $r -= 1;
                Nr.length - 2 > $r && ($r += 1), this.root.sourcepos[1] = [$r + 1, Nr[$r].length];
              }, Dr.prototype.replaceRangeNodes = function(Nr, $r, Zr) {
                Nr ? (Gf(Nr, Zr), GF(Nr, $r), [Nr.id, $r.id].forEach(function(oi) {
                  return xu(oi);
                }), Nr.unlink()) : $r ? (Gf($r, Zr), xu($r.id), $r.unlink()) : ZF(this.root, Zr);
              }, Dr.prototype.getNodeRange = function(Nr, $r) {
                var Zr = xc(this.root, Nr[0]), oi = xc(this.root, $r[0]);
                return oi && oi.next && $r[0] + 1 === oi.next.sourcepos[0][0] && (oi = oi.next), [Zr, oi];
              }, Dr.prototype.trigger = function(Nr, $r) {
                this.eventHandlerMap[Nr].forEach(function(Zr) {
                  Zr($r);
                });
              }, Dr.prototype.extendEndLine = function(Nr) {
                for (; this.lineTexts[Nr] === ""; )
                  Nr += 1;
                return Nr;
              }, Dr.prototype.parseRange = function(Nr, $r, Zr, oi) {
                Nr && Nr.prev && (kf(Nr.prev) && rq(this.lineTexts[Zr - 1]) || ez(Nr.prev) && nq(this.lineTexts[Zr - 1])) && (Nr = Nr.prev, Zr = Nr.sourcepos[0][0]);
                for (var _i = this.lineTexts.slice(Zr - 1, oi), Li = this.parser.partialParseStart(Zr, _i), Ui = $r ? $r.next : this.root.firstChild, ea = Li.lastChild, la = ea && yf(ea) && ea.open, Ea = ea && _f(ea) && ea.open, Aa = ea && kf(ea); (la || Ea) && Ui || Aa && Ui && (Ui.type === "list" || Ui.sourcepos[0][1] >= 2); ) {
                  var ka = this.extendEndLine(Ui.sourcepos[1][0]);
                  this.parser.partialParseExtends(this.lineTexts.slice(oi, ka)), Nr || (Nr = $r), $r = Ui, oi = ka, Ui = Ui.next;
                }
                this.parser.partialParseFinish();
                var Ha = WF(Li);
                return { newNodes: Ha, extStartNode: Nr, extEndNode: $r };
              }, Dr.prototype.getRemovedNodeRange = function(Nr, $r) {
                return !Nr || Nr && bl(Nr) || $r && bl($r) ? null : {
                  id: [Nr.id, $r.id],
                  line: [Nr.sourcepos[0][0] - 1, $r.sourcepos[1][0] - 1]
                };
              }, Dr.prototype.markDeletedRefMap = function(Nr, $r) {
                var Zr = this;
                if (!yl(this.refMap)) {
                  var oi = function(_i) {
                    if (bl(_i)) {
                      var Li = Zr.refMap[_i.label];
                      Li && _i.id === Li.id && (Li.unlinked = !0);
                    }
                  };
                  Nr && Pu(oi, Nr.parent, $r), $r && Pu(oi, $r);
                }
              }, Dr.prototype.replaceWithNewRefDefState = function(Nr) {
                var $r = this;
                if (!yl(this.refMap)) {
                  var Zr = function(oi) {
                    if (bl(oi)) {
                      var _i = oi.label, Li = $r.refMap[_i];
                      (!Li || Li.unlinked) && ($r.refMap[_i] = Hu(oi));
                    }
                  };
                  Nr.forEach(function(oi) {
                    Pu(Zr, oi);
                  });
                }
              }, Dr.prototype.replaceWithRefDefCandidate = function() {
                var Nr = this;
                yl(this.refDefCandidateMap) || yc(this.refDefCandidateMap, function($r, Zr) {
                  var oi = Zr.label, _i = Zr.sourcepos, Li = Nr.refMap[oi];
                  (!Li || Li.unlinked || Li.sourcepos[0][0] > _i[0][0]) && (Nr.refMap[oi] = Hu(Zr));
                });
              }, Dr.prototype.getRangeWithRefDef = function(Nr, $r, Zr, oi, _i) {
                if (this.referenceDefinition && !yl(this.refMap)) {
                  var Li = xc(this.root, Nr - 1), Ui = xc(this.root, $r + 1);
                  Li && bl(Li) && Li !== Zr && Li !== oi && (Zr = Li, Nr = Zr.sourcepos[0][0]), Ui && bl(Ui) && Ui !== Zr && Ui !== oi && (oi = Ui, $r = this.extendEndLine(oi.sourcepos[1][0] + _i));
                }
                return [Zr, oi, Nr, $r];
              }, Dr.prototype.parse = function(Nr, $r, Zr) {
                Zr === void 0 && (Zr = 0);
                var oi = this.getNodeRange(Nr, $r), _i = oi[0], Li = oi[1], Ui = _i ? Math.min(_i.sourcepos[0][0], Nr[0]) : Nr[0], ea = this.extendEndLine((Li ? Math.max(Li.sourcepos[1][0], $r[0]) : $r[0]) + Zr), la = this.parseRange.apply(this, this.getRangeWithRefDef(Ui, ea, _i, Li, Zr)), Ea = la.newNodes, Aa = la.extStartNode, ka = la.extEndNode, Ha = this.getRemovedNodeRange(Aa, ka), Pa = ka ? ka.next : this.root.firstChild;
                return this.referenceDefinition ? (this.markDeletedRefMap(Aa, ka), this.replaceRangeNodes(Aa, ka, Ea), this.replaceWithNewRefDefState(Ea)) : this.replaceRangeNodes(Aa, ka, Ea), { nodes: Ea, removedNodeRange: Ha, nextNode: Pa };
              }, Dr.prototype.parseRefLink = function() {
                var Nr = this, $r = [];
                return yl(this.refMap) || yc(this.refMap, function(Zr, oi) {
                  oi.unlinked && delete Nr.refMap[Zr], yc(Nr.refLinkCandidateMap, function(_i, Li) {
                    var Ui = Li.node, ea = Li.refLabel;
                    ea === Zr && $r.push(Nr.parse(Ui.sourcepos[0], Ui.sourcepos[1]));
                  });
                }), $r;
              }, Dr.prototype.removeUnlinkedCandidate = function() {
                yl(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(Nr) {
                  yc(Nr, function($r) {
                    tq($r) && delete Nr[$r];
                  });
                });
              }, Dr.prototype.editMarkdown = function(Nr, $r, Zr) {
                var oi = this.updateLineTexts(Nr, $r, Zr), _i = this.parse(Nr, $r, oi), Li = Tz(_i, "nextNode");
                XF(_i.nextNode, oi), this.updateRootNodeState();
                var Ui = [Li];
                return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), Ui = Ui.concat(this.parseRefLink())), this.trigger("change", Ui), Ui;
              }, Dr.prototype.getLineTexts = function() {
                return this.lineTexts;
              }, Dr.prototype.getRootNode = function() {
                return this.root;
              }, Dr.prototype.findNodeAtPosition = function(Nr) {
                var $r = eq(this.root, Nr);
                return !$r || $r === this.root ? null : $r;
              }, Dr.prototype.findFirstNodeAtLine = function(Nr) {
                return QF(this.root, Nr);
              }, Dr.prototype.on = function(Nr, $r) {
                this.eventHandlerMap[Nr].push($r);
              }, Dr.prototype.off = function(Nr, $r) {
                var Zr = this.eventHandlerMap[Nr], oi = Zr.indexOf($r);
                Zr.splice(oi, 1);
              }, Dr.prototype.findNodeById = function(Nr) {
                return Zf(Nr);
              }, Dr.prototype.removeAllNode = function() {
                zU();
              }, Dr;
            }()
          ), aq = [
            "title",
            "textarea",
            "style",
            "xmp",
            "iframe",
            "noembed",
            "noframes",
            "script",
            "plaintext"
          ], Jf = new RegExp("<(/?(?:" + aq.join("|") + ")[^>]*>)", "ig");
          function Yf(Dr) {
            return Jf.test(Dr) ? Dr.replace(Jf, function(Nr, $r) {
              return "&lt;" + $r;
            }) : Dr;
          }
          var Qf = {
            heading: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "h" + Dr.level,
                outerNewLine: !0
              };
            },
            text: function(Dr) {
              return {
                type: "text",
                content: Dr.literal
              };
            },
            softbreak: function(Dr, Nr) {
              var $r = Nr.options;
              return {
                type: "html",
                content: $r.softbreak
              };
            },
            linebreak: function() {
              return {
                type: "html",
                content: `<br />
`
              };
            },
            emph: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "em"
              };
            },
            strong: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "strong"
              };
            },
            paragraph: function(Dr, Nr) {
              var $r, Zr = Nr.entering, oi = ($r = Dr.parent) === null || $r === void 0 ? void 0 : $r.parent;
              return oi && oi.type === "list" && oi.listData.tight ? null : {
                type: Zr ? "openTag" : "closeTag",
                tagName: "p",
                outerNewLine: !0
              };
            },
            thematicBreak: function() {
              return {
                type: "openTag",
                tagName: "hr",
                outerNewLine: !0,
                selfClose: !0
              };
            },
            blockQuote: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "blockquote",
                outerNewLine: !0,
                innerNewLine: !0
              };
            },
            list: function(Dr, Nr) {
              var $r = Nr.entering, Zr = Dr.listData, oi = Zr.type, _i = Zr.start, Li = oi === "bullet" ? "ul" : "ol", Ui = {};
              return Li === "ol" && _i !== null && _i !== 1 && (Ui.start = _i.toString()), {
                type: $r ? "openTag" : "closeTag",
                tagName: Li,
                attributes: Ui,
                outerNewLine: !0
              };
            },
            item: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            htmlInline: function(Dr, Nr) {
              var $r = Nr.options, Zr = $r.tagFilter ? Yf(Dr.literal) : Dr.literal;
              return { type: "html", content: Zr };
            },
            htmlBlock: function(Dr, Nr) {
              var $r = Nr.options, Zr = $r.tagFilter ? Yf(Dr.literal) : Dr.literal;
              return $r.nodeId ? [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "html", content: Zr },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ] : { type: "html", content: Zr, outerNewLine: !0 };
            },
            code: function(Dr) {
              return [
                { type: "openTag", tagName: "code" },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(Dr) {
              var Nr = Dr.info, $r = Nr ? Nr.split(/\s+/) : [], Zr = [];
              return $r.length > 0 && $r[0].length > 0 && Zr.push("language-" + vl($r[0])), [
                { type: "openTag", tagName: "pre", outerNewLine: !0 },
                { type: "openTag", tagName: "code", classNames: Zr },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre", outerNewLine: !0 }
              ];
            },
            link: function(Dr, Nr) {
              var $r = Nr.entering;
              if ($r) {
                var Zr = Dr, oi = Zr.title, _i = Zr.destination;
                return {
                  type: "openTag",
                  tagName: "a",
                  attributes: Cr({ href: vl(_i) }, oi && { title: vl(oi) })
                };
              }
              return { type: "closeTag", tagName: "a" };
            },
            image: function(Dr, Nr) {
              var $r = Nr.getChildrenText, Zr = Nr.skipChildren, oi = Dr, _i = oi.title, Li = oi.destination;
              return Zr(), {
                type: "openTag",
                tagName: "img",
                selfClose: !0,
                attributes: Cr({ src: vl(Li), alt: $r(Dr) }, _i && { title: vl(_i) })
              };
            },
            customBlock: function(Dr, Nr, $r) {
              var Zr = Dr.info.trim().toLowerCase(), oi = $r[Zr];
              if (oi)
                try {
                  return oi(Dr, Nr);
                } catch (_i) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + Zr + " block node was parsed in markdown renderer: " + _i);
                }
              return [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            frontMatter: function(Dr) {
              return [
                {
                  type: "openTag",
                  tagName: "div",
                  outerNewLine: !0,
                  // Because front matter is metadata, it should not be render.
                  attributes: { style: "white-space: pre; display: none;" }
                },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            customInline: function(Dr, Nr, $r) {
              var Zr = Dr, oi = Zr.info, _i = Zr.firstChild, Li = oi.trim().toLowerCase(), Ui = $r[Li], ea = Nr.entering;
              if (Ui)
                try {
                  return Ui(Dr, Nr);
                } catch (la) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + Li + " inline node was parsed in markdown renderer: " + la);
                }
              return ea ? [
                { type: "openTag", tagName: "span" },
                { type: "text", content: "$$" + oi + (_i ? " " : "") }
              ] : [
                { type: "text", content: "$$" },
                { type: "closeTag", tagName: "span" }
              ];
            }
          }, ed = {
            strike: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "del"
              };
            },
            item: function(Dr, Nr) {
              var $r = Nr.entering, Zr = Dr.listData, oi = Zr.checked, _i = Zr.task;
              if ($r) {
                var Li = {
                  type: "openTag",
                  tagName: "li",
                  outerNewLine: !0
                };
                return _i ? [
                  Li,
                  {
                    type: "openTag",
                    tagName: "input",
                    selfClose: !0,
                    attributes: Cr(Cr({}, oi && { checked: "" }), { disabled: "", type: "checkbox" })
                  },
                  {
                    type: "text",
                    content: " "
                  }
                ] : Li;
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            table: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "table",
                outerNewLine: !0
              };
            },
            tableHead: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "thead",
                outerNewLine: !0
              };
            },
            tableBody: function(Dr, Nr) {
              var $r = Nr.entering;
              return {
                type: $r ? "openTag" : "closeTag",
                tagName: "tbody",
                outerNewLine: !0
              };
            },
            tableRow: function(Dr, Nr) {
              var $r = Nr.entering;
              if ($r)
                return {
                  type: "openTag",
                  tagName: "tr",
                  outerNewLine: !0
                };
              var Zr = [];
              if (Dr.lastChild)
                for (var oi = Dr.parent.parent.columns.length, _i = Dr.lastChild.endIdx, Li = _i + 1; Li < oi; Li += 1)
                  Zr.push({
                    type: "openTag",
                    tagName: "td",
                    outerNewLine: !0
                  }, {
                    type: "closeTag",
                    tagName: "td",
                    outerNewLine: !0
                  });
              return Zr.push({
                type: "closeTag",
                tagName: "tr",
                outerNewLine: !0
              }), Zr;
            },
            tableCell: function(Dr, Nr) {
              var $r = Nr.entering;
              if (Dr.ignored)
                return {
                  type: "text",
                  content: ""
                };
              var Zr = Dr.parent.parent, oi = Zr.type === "tableHead" ? "th" : "td", _i = Zr.parent, Li = _i.columns[Dr.startIdx], Ui = Li != null && Li.align ? { align: Li.align } : null;
              return $r ? Cr({ type: "openTag", tagName: oi, outerNewLine: !0 }, Ui && { attributes: Ui }) : {
                type: "closeTag",
                tagName: oi,
                outerNewLine: !0
              };
            }
          }, oq = {
            softbreak: `
`,
            gfm: !1,
            tagFilter: !1,
            nodeId: !1
          };
          function sq(Dr) {
            for (var Nr = [], $r = Dr.walker(), Zr = null; Zr = $r.next(); ) {
              var oi = Zr.node;
              oi.type === "text" && Nr.push(oi.literal);
            }
            return Nr.join("");
          }
          var lq = (
            /** @class */
            function() {
              function Dr(Nr) {
                this.buffer = [], this.options = Cr(Cr({}, oq), Nr), this.convertors = this.createConvertors(), delete this.options.convertors;
              }
              return Dr.prototype.createConvertors = function() {
                var Nr = Cr({}, Qf);
                if (this.options.gfm && (Nr = Cr(Cr({}, Nr), ed)), this.options.convertors) {
                  var $r = this.options.convertors, Zr = Object.keys($r), oi = Cr(Cr({}, Qf), ed);
                  Zr.forEach(function(_i) {
                    var Li = Nr[_i], Ui = $r[_i], ea = Object.keys(oi).indexOf(_i) === -1 ? _i.toLowerCase() : _i;
                    Li ? Nr[ea] = function(la, Ea, Aa) {
                      return Ea.origin = function() {
                        return Li(la, Ea, Aa);
                      }, Ui(la, Ea);
                    } : Nr[ea] = Ui;
                  });
                }
                return Nr;
              }, Dr.prototype.getConvertors = function() {
                return this.convertors;
              }, Dr.prototype.getOptions = function() {
                return this.options;
              }, Dr.prototype.render = function(Nr) {
                var $r = this;
                this.buffer = [];
                for (var Zr = Nr.walker(), oi = null, _i = function() {
                  var Ui = oi.node, ea = oi.entering, la = Li.convertors[Ui.type];
                  if (!la)
                    return "continue";
                  var Ea = !1, Aa = {
                    entering: ea,
                    leaf: !wu(Ui),
                    options: Li.options,
                    getChildrenText: sq,
                    skipChildren: function() {
                      Ea = !0;
                    }
                  }, ka = _f(Ui) || tz(Ui) ? la(Ui, Aa, Li.convertors) : la(Ui, Aa);
                  if (ka) {
                    var Ha = Array.isArray(ka) ? ka : [ka];
                    Ha.forEach(function(Pa, oo) {
                      Pa.type === "openTag" && $r.options.nodeId && oo === 0 && (Pa.attributes || (Pa.attributes = {}), Pa.attributes["data-nodeid"] = String(Ui.id)), $r.renderHTMLNode(Pa);
                    }), Ea && (Zr.resumeAt(Ui, !1), Zr.next());
                  }
                }, Li = this; oi = Zr.next(); )
                  _i();
                return this.addNewLine(), this.buffer.join("");
              }, Dr.prototype.renderHTMLNode = function(Nr) {
                switch (Nr.type) {
                  case "openTag":
                  case "closeTag":
                    this.renderElementNode(Nr);
                    break;
                  case "text":
                    this.renderTextNode(Nr);
                    break;
                  case "html":
                    this.renderRawHtmlNode(Nr);
                    break;
                }
              }, Dr.prototype.generateOpenTagString = function(Nr) {
                var $r = this, Zr = Nr.tagName, oi = Nr.classNames, _i = Nr.attributes;
                this.buffer.push("<" + Zr), oi && oi.length > 0 && this.buffer.push(' class="' + oi.join(" ") + '"'), _i && Object.keys(_i).forEach(function(Li) {
                  var Ui = _i[Li];
                  $r.buffer.push(" " + Li + '="' + Ui + '"');
                }), Nr.selfClose && this.buffer.push(" /"), this.buffer.push(">");
              }, Dr.prototype.generateCloseTagString = function(Nr) {
                var $r = Nr.tagName;
                this.buffer.push("</" + $r + ">");
              }, Dr.prototype.addNewLine = function() {
                this.buffer.length && bc(bc(this.buffer)) !== `
` && this.buffer.push(`
`);
              }, Dr.prototype.addOuterNewLine = function(Nr) {
                Nr.outerNewLine && this.addNewLine();
              }, Dr.prototype.addInnerNewLine = function(Nr) {
                Nr.innerNewLine && this.addNewLine();
              }, Dr.prototype.renderTextNode = function(Nr) {
                this.buffer.push(vl(Nr.content));
              }, Dr.prototype.renderRawHtmlNode = function(Nr) {
                this.addOuterNewLine(Nr), this.buffer.push(Nr.content), this.addOuterNewLine(Nr);
              }, Dr.prototype.renderElementNode = function(Nr) {
                Nr.type === "openTag" ? (this.addOuterNewLine(Nr), this.generateOpenTagString(Nr), Nr.selfClose ? this.addOuterNewLine(Nr) : this.addInnerNewLine(Nr)) : (this.addInnerNewLine(Nr), this.generateCloseTagString(Nr), this.addOuterNewLine(Nr));
              }, Dr;
            }()
          ), cq = yr(956), uq = /* @__PURE__ */ yr.n(cq), fq = yr(969), td = /* @__PURE__ */ yr.n(fq), dq = yr(348), rd = /* @__PURE__ */ yr.n(dq), hq = yr(349), nd = /* @__PURE__ */ yr.n(hq), pq = yr(204), id = /* @__PURE__ */ yr.n(pq), gq = yr(462), Uu = /* @__PURE__ */ yr.n(gq), mq = yr(522), ad = /* @__PURE__ */ yr.n(mq), vq = yr(990), bq = /* @__PURE__ */ yr.n(vq), yq = yr(322), kq = /* @__PURE__ */ yr.n(yq), _q = yr(758), wq = /* @__PURE__ */ yr.n(_q), xq = yr(929), Ec = /* @__PURE__ */ yr.n(xq), Eq = yr(714), Cq = /* @__PURE__ */ yr.n(Eq);
          yr(471);
          var od = "[A-Za-z][A-Za-z0-9-]*", Tq = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Aq = "[^\"'=<>`\\x00-\\x20]+", Sq = "'[^']*'", Iq = '"[^"]*"', Lq = "(?:" + Aq + "|" + Sq + "|" + Iq + ")", Rq = "(?:\\s*=\\s*" + Lq + ")", sd = "(?:\\s+" + Tq + Rq + "?)", Mq = "<(" + od + ")(" + sd + ")*\\s*/?>", Nq = "</(" + od + ")\\s*[>]", Oq = "(?:" + Mq + "|" + Nq + ")", ld = new RegExp("^" + Oq, "i");
          yr(934), yr(391);
          function zu(Dr, Nr) {
            return Dr.indexOf(Nr) !== -1;
          }
          var Dq = ["rel", "target", "hreflang", "type"];
          function Bq(Dr) {
            if (!Dr)
              return null;
            var Nr = {};
            return Dq.forEach(function($r) {
              Ec()(Dr[$r]) || (Nr[$r] = Dr[$r]);
            }), Nr;
          }
          function Pq(Dr) {
            return Dr[Dr.length - 1];
          }
          function Fu(Dr) {
            return typeof Dr == "object" && Dr !== null;
          }
          function qu(Dr, Nr) {
            var $r = _r({}, Dr);
            return Dr && Nr && Object.keys(Nr).forEach(function(Zr) {
              Fu($r[Zr]) ? Array.isArray(Nr[Zr]) ? $r[Zr] = ju(Nr[Zr]) : $r.hasOwnProperty(Zr) ? $r[Zr] = qu($r[Zr], Nr[Zr]) : $r[Zr] = $u(Nr[Zr]) : $r[Zr] = Nr[Zr];
            }), $r;
          }
          function ju(Dr) {
            return Dr.map(function(Nr) {
              return Fu(Nr) ? Array.isArray(Nr) ? ju(Nr) : $u(Nr) : Nr;
            });
          }
          function $u(Dr) {
            var Nr = Object.keys(Dr);
            return Nr.length ? Nr.reduce(function($r, Zr) {
              return Fu(Dr[Zr]) ? $r[Zr] = Array.isArray(Dr[Zr]) ? ju(Dr[Zr]) : $u(Dr[Zr]) : $r[Zr] = Dr[Zr], $r;
            }, {}) : Dr;
          }
          function cd(Dr, Nr) {
            return Nr === void 0 && (Nr = {}), Object.keys(Nr).forEach(function($r) {
              Dr.hasOwnProperty($r) && typeof Dr[$r] == "object" ? Array.isArray(Nr[$r]) ? Dr[$r] = Nr[$r] : cd(Dr[$r], Nr[$r]) : Dr[$r] = Nr[$r];
            }), Dr;
          }
          function ud(Dr, Nr) {
            return Dr > Nr ? [Nr, Dr] : [Dr, Nr];
          }
          function Hq(Dr, Nr, $r) {
            var Zr = parseInt(Dr.left, 10), oi = parseInt(Dr.top, 10), _i = parseInt(Dr.width, 10) + parseInt(Dr.paddingLeft, 10) + parseInt(Dr.paddingRight, 10), Li = parseInt(Dr.height, 10) + parseInt(Dr.paddingTop, 10) + parseInt(Dr.paddingBottom, 10);
            return Nr >= Zr && Nr <= Zr + _i && $r >= oi && $r <= oi + Li;
          }
          var Uq = "toastui-editor-";
          function Cc() {
            for (var Dr = [], Nr = 0; Nr < arguments.length; Nr++)
              Dr[Nr] = arguments[Nr];
            for (var $r = [], Zr = 0, oi = Dr; Zr < oi.length; Zr++) {
              var _i = oi[Zr], Li = void 0;
              Array.isArray(_i) ? Li = _i[0] ? _i[1] : null : Li = _i, Li && $r.push("" + Uq + Li);
            }
            return $r.join(" ");
          }
          function fd(Dr) {
            Dr.parentNode && Dr.parentNode.removeChild(Dr);
          }
          function hd(Dr, Nr, $r) {
            Ec()($r) && ($r = !Cq()(Dr, Nr));
            var Zr = $r ? id() : Uu();
            Zr(Dr, Nr);
          }
          function zq(Dr, Nr) {
            var $r = document.createElement("div");
            wq()(Dr) ? $r.innerHTML = Dr : $r.appendChild(Dr);
            var Zr = $r.firstChild;
            return Nr && Nr.appendChild(Zr), Zr;
          }
          function Fq(Dr) {
            var Nr = /<img class="ProseMirror-separator" alt="">/g, $r = / class="ProseMirror-trailingBreak"/g, Zr = Dr;
            return Zr = Zr.replace(Nr, ""), Zr = Zr.replace($r, ""), Zr;
          }
          var qq = yr(294), pd = /* @__PURE__ */ yr.n(qq);
          function jq(Dr) {
            return Dr.sourcepos[0][1];
          }
          function $q(Dr) {
            switch (Dr.type) {
              case "code":
              case "text":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "htmlInline":
              case "linebreak":
              case "softbreak":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          function Vq(Dr, Nr, $r) {
            for ($r === void 0 && ($r = !0), Dr = $r ? Dr : Dr.parent; Dr && Dr.type !== "document"; ) {
              if (Nr(Dr))
                return Dr;
              Dr = Dr.parent;
            }
            return null;
          }
          function Kq(Dr) {
            var Nr = Dr.firstChild.literal;
            switch (Dr.type) {
              case "emph":
                return "*" + Nr + "*";
              case "strong":
                return "**" + Nr + "**";
              case "strike":
                return "~~" + Nr + "~~";
              case "code":
                return "`" + Nr + "`";
              case "link":
              case "image":
                var $r = Dr, Zr = $r.destination, oi = $r.title, _i = Dr.type === "link" ? "" : "!";
                return _i + "[" + Nr + "](" + Zr + (oi ? ' "' + oi + '"' : "") + ")";
              default:
                return null;
            }
          }
          var Gq = {}, gd = /\$\$widget\d+\s/;
          function md(Dr) {
            var Nr = Dr.search(gd);
            if (Nr !== -1) {
              var $r = Dr.substring(Nr), Zr = $r.replace(gd, "").replace("$$", "");
              Dr = Dr.substring(0, Nr), Dr += md(Zr);
            }
            return Dr;
          }
          function Wq(Dr, Nr) {
            var $r = Gq[Dr], Zr = $r.rule, oi = $r.toDOM, _i = md(Nr).match(Zr);
            return _i && (Nr = _i[0]), oi(Nr);
          }
          function Zq(Dr) {
            for (var Nr, $r = "", Zr = Dr.walker(); Nr = Zr.next(); ) {
              var oi = Nr.node, _i = Nr.entering;
              _i && (oi !== Dr && oi.type !== "text" ? ($r += Kq(oi), Zr.resumeAt(Dr, !1), Zr.next()) : oi.type === "text" && ($r += oi.literal));
            }
            return $r;
          }
          var Xq = yr(368), Jq = /* @__PURE__ */ yr.n(Xq), Yq = ["iframe", "embed"], vd = [];
          function Qq(Dr) {
            zu(Yq, Dr) && vd.push(Dr.toLowerCase());
          }
          function ej(Dr, Nr) {
            return Jq().sanitize(Dr, _r({ ADD_TAGS: vd, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
              "input",
              "script",
              "textarea",
              "form",
              "button",
              "select",
              "meta",
              "style",
              "link",
              "title",
              "object",
              "base"
            ] }, Nr));
          }
          function tj(Dr, Nr) {
            return Dr.literal.replace(new RegExp("(<\\s*" + Nr + "[^>]*>)|(</" + Nr + "\\s*[>])", "ig"), "").trim();
          }
          function rj(Dr) {
            Dr = Dr.match(ld)[0];
            var Nr = Dr.match(new RegExp(sd, "g"));
            return Nr ? Nr.reduce(function($r, Zr) {
              var oi = Zr.trim().split("="), _i = oi[0], Li = oi.slice(1);
              return Li.length && ($r[_i] = Li.join("=").replace(/'|"/g, "").trim()), $r;
            }, {}) : {};
          }
          var nj = /^\s*<\s*\//, ij = {
            paragraph: function(Dr, Nr) {
              var $r = Nr.entering, Zr = Nr.origin, oi = Nr.options;
              return oi.nodeId ? {
                type: $r ? "openTag" : "closeTag",
                outerNewLine: !0,
                tagName: "p"
              } : Zr();
            },
            softbreak: function(Dr) {
              var Nr = Dr.prev && Dr.prev.type === "htmlInline", $r = Nr && /<br ?\/?>/.test(Dr.prev.literal), Zr = $r ? `
` : `<br>
`;
              return { type: "html", content: Zr };
            },
            item: function(Dr, Nr) {
              var $r = Nr.entering;
              if ($r) {
                var Zr = {}, oi = [];
                return Dr.listData.task && (Zr["data-task"] = "", oi.push("task-list-item"), Dr.listData.checked && (oi.push("checked"), Zr["data-task-checked"] = "")), {
                  type: "openTag",
                  tagName: "li",
                  classNames: oi,
                  attributes: Zr,
                  outerNewLine: !0
                };
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            code: function(Dr) {
              var Nr = { "data-backticks": String(Dr.tickCount) };
              return [
                { type: "openTag", tagName: "code", attributes: Nr },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(Dr) {
              var Nr = Dr, $r = Nr.fenceLength, Zr = Nr.info, oi = Zr ? Zr.split(/\s+/) : [], _i = [], Li = {};
              if ($r > 3 && (Li["data-backticks"] = $r), oi.length > 0 && oi[0].length > 0) {
                var Ui = oi[0];
                _i.push("lang-" + Ui), Li["data-language"] = Ui;
              }
              return [
                { type: "openTag", tagName: "pre", classNames: _i },
                { type: "openTag", tagName: "code", attributes: Li },
                { type: "text", content: Dr.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre" }
              ];
            },
            customInline: function(Dr, Nr) {
              var $r = Nr.origin, Zr = Nr.entering, oi = Nr.skipChildren, _i = Dr.info;
              if (_i.indexOf("widget") !== -1 && Zr) {
                oi();
                var Li = Zq(Dr), Ui = Wq(_i, Li).outerHTML;
                return [
                  { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
                  { type: "html", content: Ui },
                  { type: "closeTag", tagName: "span" }
                ];
              }
              return $r();
            }
          };
          function aj(Dr, Nr) {
            var $r = _r({}, ij);
            return Dr && ($r.link = function(Zr, oi) {
              var _i = oi.entering, Li = oi.origin, Ui = Li();
              return _i && (Ui.attributes = _r(_r({}, Ui.attributes), Dr)), Ui;
            }), Nr && Object.keys(Nr).forEach(function(Zr) {
              var oi = $r[Zr], _i = Nr[Zr];
              oi && pd()(_i) ? $r[Zr] = function(Li, Ui) {
                var ea = _r({}, Ui);
                return ea.origin = function() {
                  return oi(Li, Ui);
                }, _i(Li, ea);
              } : zu(["htmlBlock", "htmlInline"], Zr) && !pd()(_i) ? $r[Zr] = function(Li, Ui) {
                var ea = Li.literal.match(ld);
                if (ea) {
                  var la = ea[0], Ea = ea[1], Aa = ea[3], ka = (Ea || Aa).toLowerCase(), Ha = _i[ka], Pa = tj(Li, ka);
                  if (Ha) {
                    var oo = _r({}, Li);
                    return oo.attrs = rj(la), oo.childrenHTML = Pa, oo.type = ka, Ui.entering = !nj.test(Li.literal), Ha(oo, Ui);
                  }
                }
                return Ui.origin();
              } : $r[Zr] = _i;
            }), $r;
          }
          var oj = ["UL", "OL", "BLOCKQUOTE"];
          function sj(Dr, Nr) {
            for (var $r = 0; Dr && Dr !== Nr && (zu(oj, Dr.tagName) || ($r += Dr.offsetTop), Dr.offsetParent !== Nr.offsetParent); )
              Dr = Dr.parentElement;
            return $r;
          }
          function lj(Dr, Nr) {
            for (var $r = Nr, Zr = null; $r; ) {
              var oi = $r.firstElementChild;
              if (!oi)
                break;
              var _i = bd(oi, Dr, sj($r, Nr));
              Zr = $r, $r = _i;
            }
            var Li = $r || Zr;
            return Li === Nr ? null : Li;
          }
          function bd(Dr, Nr, $r) {
            return Dr && Nr > $r + Dr.offsetTop ? bd(Dr.nextElementSibling, Nr, $r) || Dr : null;
          }
          var cj = {};
          function Vu(Dr) {
            Dr && (delete cj[Number(Dr.getAttribute("data-nodeid"))], bq()(Dr.children).forEach(function(Nr) {
              Vu(Nr);
            }));
          }
          var Ku = Cc("md-preview-highlight");
          function uj(Dr, Nr) {
            for (var $r = Dr.firstChild; $r && $r.next && !(jq($r.next) > Nr + 1); )
              $r = $r.next;
            return $r;
          }
          var fj = (
            /** @class */
            function() {
              function Dr(Nr, $r) {
                var Zr = document.createElement("div");
                this.el = Zr, this.eventEmitter = Nr, this.isViewer = !!$r.isViewer, this.el.className = Cc("md-preview");
                var oi = $r.linkAttributes, _i = $r.customHTMLRenderer, Li = $r.sanitizer, Ui = $r.highlight, ea = Ui === void 0 ? !1 : Ui;
                this.renderer = new lq({
                  gfm: !0,
                  nodeId: !0,
                  convertors: aj(oi, _i)
                }), this.cursorNodeId = null, this.sanitizer = Li, this.initEvent(ea), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
              }
              return Dr.prototype.initContentSection = function() {
                this.previewContent = zq('<div class="' + Cc("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
              }, Dr.prototype.toggleActive = function(Nr) {
                hd(this.el, "active", Nr);
              }, Dr.prototype.initEvent = function(Nr) {
                var $r = this;
                this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (Nr && (this.eventEmitter.listen("changeToolbarState", function(Zr) {
                  var oi = Zr.mdNode, _i = Zr.cursorPos;
                  $r.updateCursorNode(oi, _i);
                }), this.eventEmitter.listen("blur", function() {
                  $r.removeHighlight();
                })), rd()(this.el, "scroll", function(Zr) {
                  $r.eventEmitter.emit("scroll", "preview", lj(Zr.target.scrollTop, $r.previewContent));
                }), this.eventEmitter.listen("changePreviewTabPreview", function() {
                  return $r.toggleActive(!0);
                }), this.eventEmitter.listen("changePreviewTabWrite", function() {
                  return $r.toggleActive(!1);
                }));
              }, Dr.prototype.removeHighlight = function() {
                if (this.cursorNodeId) {
                  var Nr = this.getElementByNodeId(this.cursorNodeId);
                  Nr && Uu()(Nr, Ku);
                }
              }, Dr.prototype.updateCursorNode = function(Nr, $r) {
                Nr && (Nr = Vq(Nr, function(Li) {
                  return !$q(Li);
                }), Nr.type === "tableRow" ? Nr = uj(Nr, $r[1]) : Nr.type === "tableBody" && (Nr = null));
                var Zr = Nr ? Nr.id : null;
                if (this.cursorNodeId !== Zr) {
                  var oi = this.getElementByNodeId(this.cursorNodeId), _i = this.getElementByNodeId(Zr);
                  oi && Uu()(oi, Ku), _i && id()(_i, Ku), this.cursorNodeId = Zr;
                }
              }, Dr.prototype.getElementByNodeId = function(Nr) {
                return Nr ? this.previewContent.querySelector('[data-nodeid="' + Nr + '"]') : null;
              }, Dr.prototype.update = function(Nr) {
                var $r = this;
                Nr.forEach(function(Zr) {
                  return $r.replaceRangeNodes(Zr);
                }), this.eventEmitter.emit("afterPreviewRender", this);
              }, Dr.prototype.replaceRangeNodes = function(Nr) {
                var $r = this, Zr = Nr.nodes, oi = Nr.removedNodeRange, _i = this.previewContent, Li = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(Zr.map(function(Pa) {
                  return $r.renderer.render(Pa);
                }).join("")));
                if (!oi)
                  _i.insertAdjacentHTML("afterbegin", Li);
                else {
                  var Ui = oi.id, ea = Ui[0], la = Ui[1], Ea = this.getElementByNodeId(ea), Aa = this.getElementByNodeId(la);
                  if (Ea) {
                    Ea.insertAdjacentHTML("beforebegin", Li);
                    for (var ka = Ea; ka && ka !== Aa; ) {
                      var Ha = ka.nextElementSibling;
                      fd(ka), Vu(ka), ka = Ha;
                    }
                    ka != null && ka.parentNode && (fd(ka), Vu(ka));
                  }
                }
              }, Dr.prototype.getRenderer = function() {
                return this.renderer;
              }, Dr.prototype.destroy = function() {
                nd()(this.el, "scroll"), this.el = null;
              }, Dr.prototype.getElement = function() {
                return this.el;
              }, Dr.prototype.getHTML = function() {
                return Fq(this.previewContent.innerHTML);
              }, Dr.prototype.setHTML = function(Nr) {
                this.previewContent.innerHTML = Nr;
              }, Dr.prototype.setHeight = function(Nr) {
                ad()(this.el, { height: Nr + "px" });
              }, Dr.prototype.setMinHeight = function(Nr) {
                ad()(this.el, { minHeight: Nr + "px" });
              }, Dr;
            }()
          ), dj = fj, Tc = yr(814), Gu = yr(479), yd = yr(311), hj = yr(481), pj = yr(43), gj = yr(928), mj = /* @__PURE__ */ yr.n(gj), vj = (
            /** @class */
            function() {
              function Dr() {
                this.keys = [], this.values = [];
              }
              return Dr.prototype.getKeyIndex = function(Nr) {
                return mj()(Nr, this.keys);
              }, Dr.prototype.get = function(Nr) {
                return this.values[this.getKeyIndex(Nr)];
              }, Dr.prototype.set = function(Nr, $r) {
                var Zr = this.getKeyIndex(Nr);
                return Zr > -1 ? this.values[Zr] = $r : (this.keys.push(Nr), this.values.push($r)), this;
              }, Dr.prototype.has = function(Nr) {
                return this.getKeyIndex(Nr) > -1;
              }, Dr.prototype.delete = function(Nr) {
                var $r = this.getKeyIndex(Nr);
                return $r > -1 ? (this.keys.splice($r, 1), this.values.splice($r, 1), !0) : !1;
              }, Dr.prototype.forEach = function(Nr, $r) {
                var Zr = this;
                $r === void 0 && ($r = this), this.values.forEach(function(oi, _i) {
                  oi && Zr.keys[_i] && Nr.call($r, oi, Zr.keys[_i], Zr);
                });
              }, Dr.prototype.clear = function() {
                this.keys = [], this.values = [];
              }, Dr;
            }()
          ), kd = vj, Wu = "en-US", bj = (
            /** @class */
            function() {
              function Dr() {
                this.code = Wu, this.langs = new kd();
              }
              return Dr.prototype.setCode = function(Nr) {
                this.code = Nr || Wu;
              }, Dr.prototype.setLanguage = function(Nr, $r) {
                var Zr = this;
                Nr = [].concat(Nr), Nr.forEach(function(oi) {
                  if (!Zr.langs.has(oi))
                    Zr.langs.set(oi, $r);
                  else {
                    var _i = Zr.langs.get(oi);
                    Zr.langs.set(oi, td()(_i, $r));
                  }
                });
              }, Dr.prototype.get = function(Nr, $r) {
                $r || ($r = this.code);
                var Zr = this.langs.get($r);
                Zr || (Zr = this.langs.get(Wu));
                var oi = Zr[Nr];
                if (!oi)
                  throw new Error('There is no text key "' + Nr + '" in ' + $r);
                return oi;
              }, Dr;
            }()
          ), yj = new bj();
          function kj(Dr, Nr) {
            for (var $r = Dr.depth; $r; ) {
              var Zr = Dr.node($r);
              if (Nr(Zr, $r))
                return {
                  node: Zr,
                  depth: $r,
                  offset: $r > 0 ? Dr.before($r) : 0
                };
              $r -= 1;
            }
            return null;
          }
          var _d = /* @__PURE__ */ new Map(), wd = (
            /** @class */
            function() {
              function Dr(Nr, $r, Zr, oi) {
                this.table = Nr, this.tableRows = $r, this.tableStartPos = Zr, this.rowInfo = oi;
              }
              return Dr.create = function(Nr) {
                var $r = kj(Nr, function(Pa) {
                  var oo = Pa.type;
                  return oo.name === "table";
                });
                if ($r) {
                  var Zr = $r.node, oi = $r.depth, _i = $r.offset, Li = _d.get(Zr);
                  if ((Li == null ? void 0 : Li.tableStartPos) === _i + 1)
                    return Li;
                  var Ui = [], ea = Nr.start(oi), la = Zr.child(0), Ea = Zr.child(1), Aa = Zu(la, ea), ka = Zu(Ea, ea + la.nodeSize);
                  la.forEach(function(Pa) {
                    return Ui.push(Pa);
                  }), Ea.forEach(function(Pa) {
                    return Ui.push(Pa);
                  });
                  var Ha = new Dr(Zr, Ui, ea, Aa.concat(ka));
                  return _d.set(Zr, Ha), Ha;
                }
                return null;
              }, Object.defineProperty(Dr.prototype, "totalRowCount", {
                get: function() {
                  return this.rowInfo.length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Dr.prototype, "totalColumnCount", {
                get: function() {
                  return this.rowInfo[0].length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Dr.prototype, "tableStartOffset", {
                get: function() {
                  return this.tableStartPos;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(Dr.prototype, "tableEndOffset", {
                get: function() {
                  return this.tableStartPos + this.table.nodeSize - 1;
                },
                enumerable: !1,
                configurable: !0
              }), Dr.prototype.getCellInfo = function(Nr, $r) {
                return this.rowInfo[Nr][$r];
              }, Dr.prototype.posAt = function(Nr, $r) {
                for (var Zr = 0, oi = this.tableStartPos; ; Zr += 1) {
                  var _i = oi + this.tableRows[Zr].nodeSize;
                  if (Zr === Nr) {
                    for (var Li = $r; Li < this.totalColumnCount && this.rowInfo[Zr][Li].offset < oi; )
                      Li += 1;
                    return Li === this.totalColumnCount ? _i : this.rowInfo[Zr][Li].offset;
                  }
                  oi = _i;
                }
              }, Dr.prototype.getNodeAndPos = function(Nr, $r) {
                var Zr = this.rowInfo[Nr][$r];
                return {
                  node: this.table.nodeAt(Zr.offset - this.tableStartOffset),
                  pos: Zr.offset
                };
              }, Dr.prototype.extendedRowspan = function(Nr, $r) {
                return !1;
              }, Dr.prototype.extendedColspan = function(Nr, $r) {
                return !1;
              }, Dr.prototype.getRowspanCount = function(Nr, $r) {
                return 0;
              }, Dr.prototype.getColspanCount = function(Nr, $r) {
                return 0;
              }, Dr.prototype.decreaseColspanCount = function(Nr, $r) {
                return 0;
              }, Dr.prototype.decreaseRowspanCount = function(Nr, $r) {
                return 0;
              }, Dr.prototype.getColspanStartInfo = function(Nr, $r) {
                return null;
              }, Dr.prototype.getRowspanStartInfo = function(Nr, $r) {
                return null;
              }, Dr.prototype.getCellStartOffset = function(Nr, $r) {
                var Zr = this.rowInfo[Nr][$r].offset;
                return this.extendedRowspan(Nr, $r) ? this.posAt(Nr, $r) : Zr;
              }, Dr.prototype.getCellEndOffset = function(Nr, $r) {
                var Zr = this.rowInfo[Nr][$r], oi = Zr.offset, _i = Zr.nodeSize;
                return this.extendedRowspan(Nr, $r) ? this.posAt(Nr, $r) : oi + _i;
              }, Dr.prototype.getCellIndex = function(Nr) {
                for (var $r = 0; $r < this.totalRowCount; $r += 1)
                  for (var Zr = this.rowInfo[$r], oi = 0; oi < this.totalColumnCount; oi += 1)
                    if (Zr[oi].offset + 1 > Nr.pos)
                      return [$r, oi];
                return [0, 0];
              }, Dr.prototype.getRectOffsets = function(Nr, $r) {
                var Zr, oi, _i;
                $r === void 0 && ($r = Nr), Nr.pos > $r.pos && (Zr = [$r, Nr], Nr = Zr[0], $r = Zr[1]);
                var Li = this.getCellIndex(Nr), Ui = Li[0], ea = Li[1], la = this.getCellIndex($r), Ea = la[0], Aa = la[1];
                return oi = ud(Ui, Ea), Ui = oi[0], Ea = oi[1], _i = ud(ea, Aa), ea = _i[0], Aa = _i[1], this.getSpannedOffsets({ startRowIdx: Ui, startColIdx: ea, endRowIdx: Ea, endColIdx: Aa });
              }, Dr.prototype.getSpannedOffsets = function(Nr) {
                return Nr;
              }, Dr;
            }()
          ), Zu = function(Dr, Nr) {
            var $r = [];
            return Dr.forEach(function(Zr, oi) {
              var _i = { rowspanMap: {}, colspanMap: {}, length: 0 };
              Zr.forEach(function(Li, Ui) {
                for (var ea = Li.nodeSize, la = 0; _i[la]; )
                  la += 1;
                _i[la] = {
                  // 2 is the sum of the front and back positions of the tag
                  offset: Nr + oi + Ui + 2,
                  nodeSize: ea
                }, _i.length += 1;
              }), $r.push(_i);
            }), $r;
          };
          function _j(Dr, Nr) {
            return cd(wd.prototype, Dr), Zu = Nr, wd;
          }
          function wj(Dr) {
            var Nr = Dr.plugin, $r = Dr.eventEmitter, Zr = Dr.usageStatistics, oi = Dr.instance, _i = { Plugin: Tc.Plugin, PluginKey: Tc.PluginKey, Selection: Tc.Selection, TextSelection: Tc.TextSelection }, Li = { Decoration: yd.Decoration, DecorationSet: yd.DecorationSet }, Ui = { Fragment: pj.Fragment }, ea = { InputRule: Gu.InputRule, inputRules: Gu.inputRules, undoInputRule: Gu.undoInputRule }, la = { keymap: hj.keymap }, Ea = {
              eventEmitter: $r,
              usageStatistics: Zr,
              instance: oi,
              pmState: _i,
              pmView: Li,
              pmModel: Ui,
              pmRules: ea,
              pmKeymap: la,
              i18n: yj
            };
            if (kq()(Nr)) {
              var Aa = Nr[0], ka = Nr[1], Ha = ka === void 0 ? {} : ka;
              return Aa(Ea, Ha);
            }
            return Nr(Ea);
          }
          function xj(Dr) {
            var Nr = Dr.plugins, $r = Dr.eventEmitter, Zr = Dr.usageStatistics, oi = Dr.instance;
            return $r.listen("mixinTableOffsetMapPrototype", _j), (Nr != null ? Nr : []).reduce(function(_i, Li) {
              var Ui = wj({
                plugin: Li,
                eventEmitter: $r,
                usageStatistics: Zr,
                instance: oi
              });
              if (!Ui)
                throw new Error("The return value of the executed plugin is empty.");
              var ea = Ui.markdownParsers, la = Ui.toHTMLRenderers, Ea = Ui.toMarkdownRenderers, Aa = Ui.markdownPlugins, ka = Ui.wysiwygPlugins, Ha = Ui.wysiwygNodeViews, Pa = Ui.markdownCommands, oo = Ui.wysiwygCommands, yo = Ui.toolbarItems;
              return la && (_i.toHTMLRenderers = qu(_i.toHTMLRenderers, la)), Ea && (_i.toMarkdownRenderers = qu(_i.toMarkdownRenderers, Ea)), Aa && (_i.mdPlugins = _i.mdPlugins.concat(Aa)), ka && (_i.wwPlugins = _i.wwPlugins.concat(ka)), Ha && (_i.wwNodeViews = _r(_r({}, _i.wwNodeViews), Ha)), Pa && (_i.mdCommands = _r(_r({}, _i.mdCommands), Pa)), oo && (_i.wwCommands = _r(_r({}, _i.wwCommands), oo)), yo && (_i.toolbarItems = _i.toolbarItems.concat(yo)), ea && (_i.markdownParsers = _r(_r({}, _i.markdownParsers), ea)), _i;
            }, {
              toHTMLRenderers: {},
              toMarkdownRenderers: {},
              mdPlugins: [],
              wwPlugins: [],
              wwNodeViews: {},
              mdCommands: {},
              wwCommands: {},
              toolbarItems: [],
              markdownParsers: {}
            });
          }
          var Ej = yr(404), Cj = /* @__PURE__ */ yr.n(Ej), xd = [
            "afterPreviewRender",
            "updatePreview",
            "changeMode",
            "needChangeMode",
            "command",
            "changePreviewStyle",
            "changePreviewTabPreview",
            "changePreviewTabWrite",
            "scroll",
            "contextmenu",
            "show",
            "hide",
            "changeLanguage",
            "changeToolbarState",
            "toggleScrollSync",
            "mixinTableOffsetMapPrototype",
            "setFocusedNode",
            "removePopupWidget",
            "query",
            // provide event for user
            "openPopup",
            "closePopup",
            "addImageBlobHook",
            "beforePreviewRender",
            "beforeConvertWysiwygToMarkdown",
            "load",
            "loadUI",
            "change",
            "caretChange",
            "destroy",
            "focus",
            "blur",
            "keydown",
            "keyup"
          ], Tj = (
            /** @class */
            function() {
              function Dr() {
                var Nr = this;
                this.events = new kd(), this.eventTypes = xd.reduce(function($r, Zr) {
                  return _r(_r({}, $r), { type: Zr });
                }, {}), this.hold = !1, xd.forEach(function($r) {
                  Nr.addEventType($r);
                });
              }
              return Dr.prototype.listen = function(Nr, $r) {
                var Zr = this.getTypeInfo(Nr), oi = this.events.get(Zr.type) || [];
                if (!this.hasEventType(Zr.type))
                  throw new Error("There is no event type " + Zr.type);
                Zr.namespace && ($r.namespace = Zr.namespace), oi.push($r), this.events.set(Zr.type, oi);
              }, Dr.prototype.emit = function(Nr) {
                for (var $r = [], Zr = 1; Zr < arguments.length; Zr++)
                  $r[Zr - 1] = arguments[Zr];
                var oi = this.getTypeInfo(Nr), _i = this.events.get(oi.type), Li = [];
                return !this.hold && _i && _i.forEach(function(Ui) {
                  var ea = Ui.apply(void 0, $r);
                  Ec()(ea) || Li.push(ea);
                }), Li;
              }, Dr.prototype.emitReduce = function(Nr, $r) {
                for (var Zr = [], oi = 2; oi < arguments.length; oi++)
                  Zr[oi - 2] = arguments[oi];
                var _i = this.events.get(Nr);
                return !this.hold && _i && _i.forEach(function(Li) {
                  var Ui = Li.apply(void 0, xr([$r], Zr));
                  Cj()(Ui) || ($r = Ui);
                }), $r;
              }, Dr.prototype.getTypeInfo = function(Nr) {
                var $r = Nr.split(".");
                return {
                  type: $r[0],
                  namespace: $r[1]
                };
              }, Dr.prototype.hasEventType = function(Nr) {
                return !Ec()(this.eventTypes[this.getTypeInfo(Nr).type]);
              }, Dr.prototype.addEventType = function(Nr) {
                if (this.hasEventType(Nr))
                  throw new Error("There is already have event type " + Nr);
                this.eventTypes[Nr] = Nr;
              }, Dr.prototype.removeEventHandler = function(Nr, $r) {
                var Zr = this, oi = this.getTypeInfo(Nr), _i = oi.type, Li = oi.namespace;
                _i && $r ? this.removeEventHandlerWithHandler(_i, $r) : _i && !Li ? this.events.delete(_i) : !_i && Li ? this.events.forEach(function(Ui, ea) {
                  Zr.removeEventHandlerWithTypeInfo(ea, Li);
                }) : _i && Li && this.removeEventHandlerWithTypeInfo(_i, Li);
              }, Dr.prototype.removeEventHandlerWithHandler = function(Nr, $r) {
                var Zr = this.events.get(Nr);
                if (Zr) {
                  var oi = Zr.indexOf($r);
                  Zr.indexOf($r) >= 0 && Zr.splice(oi, 1);
                }
              }, Dr.prototype.removeEventHandlerWithTypeInfo = function(Nr, $r) {
                var Zr = [], oi = this.events.get(Nr);
                oi && (oi.map(function(_i) {
                  return _i.namespace !== $r && Zr.push(_i), null;
                }), this.events.set(Nr, Zr));
              }, Dr.prototype.getEvents = function() {
                return this.events;
              }, Dr.prototype.holdEventInvoke = function(Nr) {
                this.hold = !0, Nr(), this.hold = !1;
              }, Dr;
            }()
          ), Aj = Tj, Sj = "data-task", Ij = "data-task-disabled", Lj = "checked";
          function Rj(Dr) {
            ["htmlBlock", "htmlInline"].forEach(function(Nr) {
              Dr[Nr] && Object.keys(Dr[Nr]).forEach(function($r) {
                return Qq($r);
              });
            });
          }
          var Mj = (
            /** @class */
            function() {
              function Dr(Nr) {
                var $r = this;
                this.options = td()({
                  linkAttributes: null,
                  extendedAutolinks: !1,
                  customHTMLRenderer: null,
                  referenceDefinition: !1,
                  customHTMLSanitizer: null,
                  frontMatter: !1,
                  usageStatistics: !0,
                  theme: "light"
                }, Nr), this.eventEmitter = new Aj();
                var Zr = Bq(this.options.linkAttributes), oi = xj({
                  plugins: this.options.plugins,
                  eventEmitter: this.eventEmitter,
                  usageStatistics: this.options.usageStatistics,
                  instance: this
                }) || {}, _i = oi.toHTMLRenderers, Li = oi.markdownParsers, Ui = this.options, ea = Ui.customHTMLRenderer, la = Ui.extendedAutolinks, Ea = Ui.referenceDefinition, Aa = Ui.frontMatter, ka = Ui.customHTMLSanitizer, Ha = {
                  linkAttributes: Zr,
                  customHTMLRenderer: _r(_r({}, _i), ea),
                  extendedAutolinks: la,
                  referenceDefinition: Ea,
                  frontMatter: Aa,
                  sanitizer: ka || ej
                };
                Rj(Ha.customHTMLRenderer), this.options.events && uq()(this.options.events, function(Jo, Wo) {
                  $r.on(Wo, Jo);
                });
                var Pa = this.options, oo = Pa.el, yo = Pa.initialValue, Lo = Pa.theme, Ts = oo.innerHTML;
                Lo !== "light" && oo.classList.add(Cc(Lo)), oo.innerHTML = "", this.toastMark = new iq("", {
                  disallowedHtmlBlockTags: ["br", "img"],
                  extendedAutolinks: la,
                  referenceDefinition: Ea,
                  disallowDeepHeading: !0,
                  frontMatter: Aa,
                  customParser: Li
                }), this.preview = new dj(this.eventEmitter, _r(_r({}, Ha), { isViewer: !0 })), rd()(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), yo ? this.setMarkdown(yo) : Ts && this.preview.setHTML(Ts), oo.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
              }
              return Dr.prototype.toggleTask = function(Nr) {
                var $r = Nr.target, Zr = getComputedStyle($r, ":before");
                !$r.hasAttribute(Ij) && $r.hasAttribute(Sj) && Hq(Zr, Nr.offsetX, Nr.offsetY) && (hd($r, Lj), this.eventEmitter.emit("change", {
                  source: "viewer",
                  date: Nr
                }));
              }, Dr.prototype.setMarkdown = function(Nr) {
                var $r = this.toastMark.getLineTexts(), Zr = $r.length, oi = Pq($r), _i = [Zr, oi.length + 1], Li = this.toastMark.editMarkdown([1, 1], _i, Nr || "");
                this.eventEmitter.emit("updatePreview", Li);
              }, Dr.prototype.on = function(Nr, $r) {
                this.eventEmitter.listen(Nr, $r);
              }, Dr.prototype.off = function(Nr) {
                this.eventEmitter.removeEventHandler(Nr);
              }, Dr.prototype.addHook = function(Nr, $r) {
                this.eventEmitter.removeEventHandler(Nr), this.eventEmitter.listen(Nr, $r);
              }, Dr.prototype.destroy = function() {
                nd()(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
              }, Dr.prototype.isViewer = function() {
                return !0;
              }, Dr.prototype.isMarkdownMode = function() {
                return !1;
              }, Dr.prototype.isWysiwygMode = function() {
                return !1;
              }, Dr;
            }()
          ), Nj = Mj, Oj = Nj;
        }(), kr = kr.default, kr;
      }()
    );
  });
})(toastuiEditorViewer);
var toastuiEditorViewerExports = toastuiEditorViewer.exports;
const Viewer = /* @__PURE__ */ getDefaultExportFromCjs(toastuiEditorViewerExports), css = `/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */.ProseMirror{font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;color:#222;font-size:13px;overflow-y:auto;overflow-X:hidden;height:calc(100% - 36px)}.ProseMirror .placeholder{color:#999}.ProseMirror:focus{outline:none}.ProseMirror-selectednode{outline:none}table.ProseMirror-selectednode,.html-block.ProseMirror-selectednode{border-radius:2px;outline:2px solid #00a9ff}.toastui-editor-contents{margin:0;padding:0;font-size:13px;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,나눔바른고딕,Nanum Barun Gothic,맑은고딕,Malgun Gothic,sans-serif;z-index:20}.toastui-editor-contents *:not(table){line-height:160%;-webkit-box-sizing:content-box;box-sizing:content-box}.toastui-editor-contents i,.toastui-editor-contents cite,.toastui-editor-contents em,.toastui-editor-contents var,.toastui-editor-contents address,.toastui-editor-contents dfn{font-style:italic}.toastui-editor-contents strong{font-weight:700}.toastui-editor-contents p{margin:10px 0;color:#222}.toastui-editor-contents>h1:first-of-type,.toastui-editor-contents>div>div:first-of-type h1{margin-top:14px}.toastui-editor-contents h1,.toastui-editor-contents h2,.toastui-editor-contents h3,.toastui-editor-contents h4,.toastui-editor-contents h5,.toastui-editor-contents h6{font-weight:700;color:#222}.toastui-editor-contents h1{font-size:24px;line-height:28px;border-bottom:3px double #999;margin:52px 0 15px;padding-bottom:7px}.toastui-editor-contents h2{font-size:22px;line-height:23px;border-bottom:1px solid #dbdbdb;margin:20px 0 13px;padding-bottom:7px}.toastui-editor-contents h3{font-size:20px;margin:18px 0 2px}.toastui-editor-contents h4{font-size:18px;margin:10px 0 2px}.toastui-editor-contents h3,.toastui-editor-contents h4{line-height:18px}.toastui-editor-contents h5{font-size:16px}.toastui-editor-contents h6{font-size:14px}.toastui-editor-contents h5,.toastui-editor-contents h6{line-height:17px;margin:9px 0 -4px}.toastui-editor-contents del{color:#999}.toastui-editor-contents blockquote{margin:14px 0;border-left:4px solid #e5e5e5;padding:0 16px;color:#999}.toastui-editor-contents blockquote p,.toastui-editor-contents blockquote ul,.toastui-editor-contents blockquote ol{color:#999}.toastui-editor-contents blockquote>:first-child{margin-top:0}.toastui-editor-contents blockquote>:last-child{margin-bottom:0}.toastui-editor-contents pre,.toastui-editor-contents code{font-family:Consolas,Courier,Apple SD 산돌고딕 Neo,-apple-system,Lucida Grande,Apple SD Gothic Neo,맑은 고딕,Malgun Gothic,Segoe UI,돋움,dotum,sans-serif;border:0;border-radius:0}.toastui-editor-contents pre{margin:2px 0 8px;padding:18px;background-color:#f4f7f8}.toastui-editor-contents code{color:#c1798b;background-color:#f9f2f4;padding:2px 3px;letter-spacing:-.3px;border-radius:2px}.toastui-editor-contents pre code{padding:0;color:inherit;white-space:pre-wrap;background-color:transparent}.toastui-editor-contents img{margin:4px 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box;vertical-align:top;max-width:100%}.toastui-editor-contents table{border:1px solid rgba(0,0,0,.1);margin:12px 0 14px;color:#222;width:auto;border-collapse:collapse;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-contents table th,.toastui-editor-contents table td{border:1px solid rgba(0,0,0,.1);padding:5px 14px 5px 12px;height:32px}.toastui-editor-contents table th{background-color:#555;font-weight:300;color:#fff;padding-top:6px}.toastui-editor-contents th p{margin:0;color:#fff}.toastui-editor-contents td p{margin:0;padding:0 2px}.toastui-editor-contents td.toastui-editor-cell-selected{background-color:#d8dfec}.toastui-editor-contents th.toastui-editor-cell-selected{background-color:#908f8f}.toastui-editor-contents ul,.toastui-editor-contents menu,.toastui-editor-contents ol,.toastui-editor-contents dir{display:block;list-style-type:none;padding-left:24px;margin:6px 0 10px;color:#222}.toastui-editor-contents ol{list-style-type:none;counter-reset:li}.toastui-editor-contents ol>li{counter-increment:li}.toastui-editor-contents ul>li:before,.toastui-editor-contents ol>li:before{display:inline-block;position:absolute}.toastui-editor-contents ul>li:before{content:"";margin-top:6px;margin-left:-17px;width:5px;height:5px;border-radius:50%;background-color:#ccc}.toastui-editor-contents ol>li:before{content:"." counter(li);margin-left:-28px;width:24px;text-align:right;direction:rtl;color:#aaa}.toastui-editor-contents ul ul,.toastui-editor-contents ul ol,.toastui-editor-contents ol ol,.toastui-editor-contents ol ul{margin-top:0!important;margin-bottom:0!important}.toastui-editor-contents ul li,.toastui-editor-contents ol li{position:relative}.toastui-editor-contents ul p,.toastui-editor-contents ol p{margin:0}.toastui-editor-contents hr{border-top:1px solid #eee;margin:16px 0}.toastui-editor-contents a{text-decoration:underline;color:#4b96e6}.toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-contents .image-link{position:relative}.toastui-editor-contents .image-link:hover:before{content:"";position:absolute;width:30px;height:30px;right:0;border-radius:50%;border:1px solid #c9ccd5;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiM1NTUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAwIC00NTgxKSB0cmFuc2xhdGUoOTk1IDQ1NzYpIHRyYW5zbGF0ZSg1IDUpIHNjYWxlKDEgLTEpIHJvdGF0ZSg0NSAzNy4yOTMgMCkiLz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzI2IDQuOTM0bDEuODIyLjAwMmMxLjQ4NyAwIDIuNjkzIDEuMjI4IDIuNjkzIDIuNzQ0di4xOTJjMCAxLjUxNS0xLjIwNiAyLjc0NC0yLjY5MyAyLjc0NGgtMy44NDVjLTEuNDg3IDAtMi42OTItMS4yMjktMi42OTItMi43NDRWNy42OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMDAgLTQ1ODEpIHRyYW5zbGF0ZSg5OTUgNDU3NikgdHJhbnNsYXRlKDUgNSkgc2NhbGUoMSAtMSkgcm90YXRlKDQ1IDMwLjk5NiAwKSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K) no-repeat;background-position:center;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;cursor:pointer}.toastui-editor-contents .task-list-item{border:0;list-style:none;padding-left:24px;margin-left:-24px}.toastui-editor-contents .task-list-item:before{background-repeat:no-repeat;background-size:18px 18px;background-position:center;content:"";margin-left:0;margin-top:0;border-radius:2px;height:18px;width:18px;position:absolute;left:0;top:1px;cursor:pointer;background:transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQ0NDIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMjk2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMDQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==)}.toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-custom-block .toastui-editor-custom-block-editor{background:#f9f7fd;color:#452d6b;border:solid 1px #dbd4ea}.toastui-editor-custom-block .toastui-editor-custom-block-view{position:relative;padding:9px 13px 8px 12px}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{border:solid 1px #dbd4ea;border-radius:2px}.toastui-editor-custom-block .toastui-editor-custom-block-view .tool{position:absolute;right:10px;top:7px;display:none}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view .tool{display:block}.toastui-editor-custom-block-view button{vertical-align:middle;width:15px;height:15px;margin-left:8px;padding:3px;border:solid 1px #cccccc;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:center;background-size:30px 30px}.toastui-editor-custom-block-view .info{font-size:13px;font-weight:700;color:#5200d0;vertical-align:middle}.toastui-editor-contents .toastui-editor-ww-code-block{position:relative}.toastui-editor-contents .toastui-editor-ww-code-block:after{content:attr(data-language);position:absolute;display:inline-block;top:10px;right:10px;height:24px;padding:3px 35px 0 10px;font-weight:700;font-size:13px;color:#333;background:#e5e9ea url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:right;border-radius:2px;background-size:30px 30px;cursor:pointer}.toastui-editor-ww-code-block-language{position:fixed;display:inline-block;width:100px;height:27px;right:35px;border:1px solid #ccc;border-radius:2px;background-color:#fff;z-index:30}.toastui-editor-ww-code-block-language input{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:0 10px;height:100%;width:100%;background-color:transparent;border:none;outline:none}.toastui-editor-contents-placeholder:before{content:attr(data-placeholder);color:gray;line-height:160%;position:absolute}.toastui-editor-md-preview .toastui-editor-contents h1{min-height:28px}.toastui-editor-md-preview .toastui-editor-contents h2{min-height:23px}.toastui-editor-md-preview .toastui-editor-contents blockquote{min-height:20px}.toastui-editor-md-preview .toastui-editor-contents li{min-height:22px}.toastui-editor-pseudo-clipboard{position:fixed;opacity:0;width:0;height:0;left:-1000px;top:-1000px;z-index:-1}
`;
function add_css$3(lr) {
  append_styles(lr, "svelte-769iua", ".hidden.svelte-769iua{display:none}");
}
function create_fragment$3(lr) {
  let ar, cr, ur, fr, dr, gr, mr;
  return {
    c() {
      ar = element("style"), cr = space(), ur = element("style"), fr = space(), dr = element("div"), gr = space(), mr = element("div"), attr(dr, "class", "svelte-769iua"), toggle_class(
        dr,
        "hidden",
        /*$theme*/
        lr[0] === "dark"
      ), attr(mr, "class", "svelte-769iua"), toggle_class(
        mr,
        "hidden",
        /*$theme*/
        lr[0] === "light"
      );
    },
    m(vr, yr) {
      insert(vr, ar, yr), ar.innerHTML = css, insert(vr, cr, yr), insert(vr, ur, yr), ur.innerHTML = dark, insert(vr, fr, yr), insert(vr, dr, yr), lr[6](dr), insert(vr, gr, yr), insert(vr, mr, yr), lr[7](mr);
    },
    p(vr, [yr]) {
      yr & /*$theme*/
      1 && toggle_class(
        dr,
        "hidden",
        /*$theme*/
        vr[0] === "dark"
      ), yr & /*$theme*/
      1 && toggle_class(
        mr,
        "hidden",
        /*$theme*/
        vr[0] === "light"
      );
    },
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && (detach(ar), detach(cr), detach(ur), detach(fr), detach(dr), detach(gr), detach(mr)), lr[6](null), lr[7](null);
    }
  };
}
function instance$3(lr, ar, cr) {
  let ur;
  component_subscribe(lr, theme, (xr) => cr(0, ur = xr));
  let fr, dr, gr, mr, { content: vr } = ar;
  function yr() {
    cr(4, gr = new Viewer({
      el: fr,
      theme: "light",
      initialValue: vr
    })), cr(5, mr = new Viewer({
      el: dr,
      theme: "dark",
      initialValue: vr
    }));
  }
  onMount(() => {
    yr();
  });
  function kr(xr) {
    binding_callbacks[xr ? "unshift" : "push"](() => {
      fr = xr, cr(1, fr);
    });
  }
  function _r(xr) {
    binding_callbacks[xr ? "unshift" : "push"](() => {
      dr = xr, cr(2, dr);
    });
  }
  return lr.$$set = (xr) => {
    "content" in xr && cr(3, vr = xr.content);
  }, lr.$$.update = () => {
    lr.$$.dirty & /*$theme, viewer, viewerDark, content*/
    57 && ur && gr && mr && vr && (gr.destroy(), mr.destroy(), yr());
  }, [
    ur,
    fr,
    dr,
    vr,
    gr,
    mr,
    kr,
    _r
  ];
}
class ContentView extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$3, create_fragment$3, safe_not_equal, { content: 3 }, add_css$3);
  }
  get content() {
    return this.$$.ctx[3];
  }
  set content(ar) {
    this.$$set({ content: ar }), flush();
  }
}
create_custom_element(ContentView, { content: {} }, [], [], !0);
function add_css$2(lr) {
  append_styles(lr, "svelte-1aaaf7r", ".opinion-container.svelte-1aaaf7r{border:1px solid #e0e0e0;border-radius:8px;padding:16px;margin-bottom:16px;background-color:var(--neutral-6, white);color:var(--neutral-0, black);font-family:'Barlow', sans-serif}.opinion-top.svelte-1aaaf7r{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.pubkey.svelte-1aaaf7r{display:flex;align-items:center;gap:10px;font-size:16px;font-weight:500}.profile-header.svelte-1aaaf7r{display:flex;align-items:center;gap:0.5rem;color:var(--neutral-0, black);font-size:18px}.profile-image.svelte-1aaaf7r{border-radius:50%;width:40px;height:40px;object-fit:cover}.date.svelte-1aaaf7r{color:var(--neutral-0, black);font-size:14px}.content.svelte-1aaaf7r{padding:1rem;color:var(--neutral-0, black);margin-bottom:16px}.read-more.svelte-1aaaf7r{color:#4da84d;cursor:pointer;display:block}.loader.svelte-1aaaf7r{display:flex;justify-content:center;align-items:center;margin:2rem 0}.reply-section.svelte-1aaaf7r{padding:1rem}.reply-file-preview.svelte-1aaaf7r{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}.reply-footer.svelte-1aaaf7r{display:flex;align-content:center}.reply-button.svelte-1aaaf7r{padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem;background-color:#4da84d;color:white}.card-button.svelte-1aaaf7r{display:inline-flex;align-items:center;gap:2px}.option-button.svelte-1aaaf7r{background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}#allReply.svelte-1aaaf7r{background:none;border:none;cursor:pointer;display:flex;align-items:center;font-size:large;padding:8px;color:var(--neutral-0, black)}#replyButton.svelte-1aaaf7r{background:none;background-color:transparent;border:none;cursor:pointer}.reactionButton.svelte-1aaaf7r{background:none;background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}.reactionDiv.svelte-1aaaf7r{display:flex;gap:2rem}.dark.svelte-1aaaf7r{background-color:#434343;color:white}.selected.svelte-1aaaf7r{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center;background-color:#4da84d;color:white}.deselected.svelte-1aaaf7r{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center}.postButton.svelte-1aaaf7r{color:#ffffff;background-color:#4da84d;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}.opinion-container.mine.svelte-1aaaf7r{background-color:var(--neutral-6,#faefd9)}#filePreview.svelte-1aaaf7r{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}");
}
function get_each_context$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[3] = ar[cr], ur;
}
function get_each_context_1$1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[70] = ar[cr], ur;
}
function get_each_context_2(lr, ar, cr) {
  const ur = lr.slice();
  return ur[70] = ar[cr], ur;
}
function create_if_block$1(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_1$1, create_else_block_5], gr = [];
  function mr(vr, yr) {
    return !/*loading*/
    vr[20] && /*expertOpinions*/
    vr[14] ? 0 : 1;
  }
  return ar = mr(lr), cr = gr[ar] = dr[ar](lr), {
    c() {
      cr.c(), ur = empty$1();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), fr = !0;
    },
    p(vr, yr) {
      let kr = ar;
      ar = mr(vr), ar === kr ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), cr = gr[ar], cr ? cr.p(vr, yr) : (cr = gr[ar] = dr[ar](vr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur));
    },
    i(vr) {
      fr || (transition_in(cr), fr = !0);
    },
    o(vr) {
      transition_out(cr), fr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_else_block_5(lr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "Loading...", attr(ar, "class", "loader svelte-1aaaf7r");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_1$1(lr) {
  var Ka, Qa;
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r = (
    /*trustedAuthors*/
    lr[10].includes(
      /*event*/
      lr[3].pubkey
    )
  ), xr, Sr, Er, Cr, Tr, Ar, Ir, Mr, Hr, Br, zr, Gr, Xr, Jr, li, Qr = (
    /*likeCount*/
    (lr[15] || 0) + ""
  ), ei, ui, Ai, fi, gi, Ci, mi, vi, Ri = (
    /*dislikeCount*/
    (lr[16] || 0) + ""
  ), di, Ti, qi, ki, Ji, Bi, Ni, Mi, bi, Ei, Si, Vi, Di, sa, ra;
  const fa = [create_if_block_15, create_if_block_16, create_if_block_17], ba = [];
  function Ua(Hi, da) {
    var aa, oa;
    return da[0] & /*event, editLvl*/
    12 && (dr = null), da[0] & /*event, editLvl*/
    12 && (gr = null), dr == null && (dr = /*event*/
    ((aa = Hi[3].tags.find(func)) == null ? void 0 : aa[1]) === "-1" && /*editLvl*/
    Hi[2] === 1), dr ? 0 : (gr == null && (gr = /*event*/
    ((oa = Hi[3].tags.find(func_1)) == null ? void 0 : oa[1]) === "0" && /*editLvl*/
    Hi[2] === 1), gr ? 1 : (
      /*editLvl*/
      Hi[2] === 1 ? 2 : -1
    ));
  }
  ~(mr = Ua(lr, [-1, -1, -1])) && (vr = ba[mr] = fa[mr](lr));
  function Va(Hi, da) {
    return (
      /*profiles*/
      Hi[4][
        /*event*/
        Hi[3].pubkey
      ] ? create_if_block_14 : create_else_block_4
    );
  }
  let Ma = Va(lr), Fi = Ma(lr), na = _r && create_if_block_13(), Gi = (
    /*published_at*/
    lr[24] && /*published_at*/
    lr[24] < /*created_at*/
    lr[25] && create_if_block_12()
  );
  const Ca = [create_if_block_8, create_else_block_3], $a = [];
  function no(Hi, da) {
    return (
      /*edit*/
      Hi[17] ? 1 : 0
    );
  }
  Ar = no(lr), Ir = $a[Ar] = Ca[Ar](lr);
  const ga = [create_if_block_7$1, create_else_block_1$1], pa = [];
  function Sa(Hi, da) {
    return (
      /*liked*/
      Hi[21] === !0 ? 0 : 1
    );
  }
  Gr = Sa(lr), Xr = pa[Gr] = ga[Gr](lr);
  const Na = [create_if_block_6$1, create_else_block$1], Oa = [];
  function Ja(Hi, da) {
    return (
      /*disliked*/
      Hi[22] === !0 ? 0 : 1
    );
  }
  gi = Ja(lr), Ci = Oa[gi] = Na[gi](lr), ki = new Tooltip({
    props: {
      $$slots: {
        tooltip1Text: [create_tooltip1Text_slot_1],
        default: [create_default_slot_1]
      },
      $$scope: { ctx: lr }
    }
  }), Bi = new Tooltip({
    props: {
      $$slots: {
        tooltip1Text: [create_tooltip1Text_slot],
        default: [create_default_slot]
      },
      $$scope: { ctx: lr }
    }
  });
  let za = (
    /*$ndkUser*/
    ((Ka = lr[28]) == null ? void 0 : Ka.pubkey) === /*event*/
    lr[3].pubkey && create_if_block_5$1(lr)
  ), Ia = (
    /*$ndkUser*/
    ((Qa = lr[28]) == null ? void 0 : Qa.pubkey) === /*event*/
    lr[3].pubkey && /*editLvl*/
    lr[2] == 1 && create_if_block_4$1(lr)
  ), Yi = (
    /*reply*/
    lr[18] && create_if_block_3$1(lr)
  ), La = (
    /*replyContent*/
    lr[19] && create_if_block_2$1(lr)
  );
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("div"), fr = element("div"), vr && vr.c(), yr = space(), Fi.c(), kr = space(), na && na.c(), xr = space(), Sr = element("p"), Gi && Gi.c(), Er = space(), Cr = text$3(
        /*relativeTime*/
        lr[23]
      ), Tr = space(), Ir.c(), Mr = space(), Hr = element("div"), Br = element("div"), zr = element("button"), Xr.c(), Jr = space(), li = element("span"), ei = text$3(Qr), ui = space(), Ai = element("div"), fi = element("button"), Ci.c(), mi = space(), vi = element("span"), di = text$3(Ri), Ti = space(), qi = element("div"), create_component(ki.$$.fragment), Ji = space(), create_component(Bi.$$.fragment), Ni = space(), za && za.c(), Mi = space(), Ia && Ia.c(), bi = space(), Yi && Yi.c(), Ei = space(), La && La.c(), attr(ur, "class", "pubkey svelte-1aaaf7r"), attr(Sr, "class", "date svelte-1aaaf7r"), attr(cr, "class", "opinion-top svelte-1aaaf7r"), attr(zr, "class", "reactionButton svelte-1aaaf7r"), attr(Br, "class", "card-button svelte-1aaaf7r"), attr(fi, "class", "reactionButton svelte-1aaaf7r"), attr(Ai, "class", "card-button svelte-1aaaf7r"), attr(qi, "class", "card-button svelte-1aaaf7r"), attr(Hr, "class", "reactionDiv svelte-1aaaf7r"), attr(ar, "class", Si = "opinion-container " + /*isMine*/
      (lr[7] ? "mine" : "") + " svelte-1aaaf7r");
    },
    m(Hi, da) {
      insert(Hi, ar, da), append(ar, cr), append(cr, ur), append(ur, fr), ~mr && ba[mr].m(fr, null), append(ur, yr), Fi.m(ur, null), append(ur, kr), na && na.m(ur, null), append(cr, xr), append(cr, Sr), Gi && Gi.m(Sr, null), append(Sr, Er), append(Sr, Cr), append(ar, Tr), $a[Ar].m(ar, null), append(ar, Mr), append(ar, Hr), append(Hr, Br), append(Br, zr), pa[Gr].m(zr, null), append(Br, Jr), append(Br, li), append(li, ei), append(Hr, ui), append(Hr, Ai), append(Ai, fi), Oa[gi].m(fi, null), append(Ai, mi), append(Ai, vi), append(vi, di), append(Hr, Ti), append(Hr, qi), mount_component(ki, qi, null), append(qi, Ji), mount_component(Bi, qi, null), append(Hr, Ni), za && za.m(Hr, null), append(Hr, Mi), Ia && Ia.m(Hr, null), append(ar, bi), Yi && Yi.m(ar, null), append(ar, Ei), La && La.m(ar, null), Di = !0, sa || (ra = [
        listen(
          zr,
          "click",
          /*click_handler_3*/
          lr[46]
        ),
        listen(
          fi,
          "click",
          /*click_handler_4*/
          lr[47]
        )
      ], sa = !0);
    },
    p(Hi, da) {
      var Ya, Za;
      let aa = mr;
      mr = Ua(Hi, da), mr !== aa && (vr && (group_outros(), transition_out(ba[aa], 1, 1, () => {
        ba[aa] = null;
      }), check_outros()), ~mr ? (vr = ba[mr], vr || (vr = ba[mr] = fa[mr](Hi), vr.c()), transition_in(vr, 1), vr.m(fr, null)) : vr = null), Ma === (Ma = Va(Hi)) && Fi ? Fi.p(Hi, da) : (Fi.d(1), Fi = Ma(Hi), Fi && (Fi.c(), Fi.m(ur, kr))), da[0] & /*trustedAuthors, event*/
      1032 && (_r = /*trustedAuthors*/
      Hi[10].includes(
        /*event*/
        Hi[3].pubkey
      )), _r ? na ? da[0] & /*trustedAuthors, event*/
      1032 && transition_in(na, 1) : (na = create_if_block_13(), na.c(), transition_in(na, 1), na.m(ur, null)) : na && (group_outros(), transition_out(na, 1, 1, () => {
        na = null;
      }), check_outros()), /*published_at*/
      Hi[24] && /*published_at*/
      Hi[24] < /*created_at*/
      Hi[25] ? Gi || (Gi = create_if_block_12(), Gi.c(), Gi.m(Sr, Er)) : Gi && (Gi.d(1), Gi = null), (!Di || da[0] & /*relativeTime*/
      8388608) && set_data(
        Cr,
        /*relativeTime*/
        Hi[23]
      );
      let oa = Ar;
      Ar = no(Hi), Ar === oa ? $a[Ar].p(Hi, da) : (group_outros(), transition_out($a[oa], 1, 1, () => {
        $a[oa] = null;
      }), check_outros(), Ir = $a[Ar], Ir ? Ir.p(Hi, da) : (Ir = $a[Ar] = Ca[Ar](Hi), Ir.c()), transition_in(Ir, 1), Ir.m(ar, Mr));
      let ja = Gr;
      Gr = Sa(Hi), Gr !== ja && (group_outros(), transition_out(pa[ja], 1, 1, () => {
        pa[ja] = null;
      }), check_outros(), Xr = pa[Gr], Xr || (Xr = pa[Gr] = ga[Gr](Hi), Xr.c()), transition_in(Xr, 1), Xr.m(zr, null)), (!Di || da[0] & /*likeCount*/
      32768) && Qr !== (Qr = /*likeCount*/
      (Hi[15] || 0) + "") && set_data(ei, Qr);
      let Ga = gi;
      gi = Ja(Hi), gi !== Ga && (group_outros(), transition_out(Oa[Ga], 1, 1, () => {
        Oa[Ga] = null;
      }), check_outros(), Ci = Oa[gi], Ci || (Ci = Oa[gi] = Na[gi](Hi), Ci.c()), transition_in(Ci, 1), Ci.m(fi, null)), (!Di || da[0] & /*dislikeCount*/
      65536) && Ri !== (Ri = /*dislikeCount*/
      (Hi[16] || 0) + "") && set_data(di, Ri);
      const xa = {};
      da[0] & /*reply, edit, opinionContent, replyContent*/
      917536 | da[2] & /*$$scope*/
      8192 && (xa.$$scope = { dirty: da, ctx: Hi }), ki.$set(xa);
      const qa = {};
      da[0] & /*replyContent, replyEvents*/
      532480 | da[2] & /*$$scope*/
      8192 && (qa.$$scope = { dirty: da, ctx: Hi }), Bi.$set(qa), /*$ndkUser*/
      ((Ya = Hi[28]) == null ? void 0 : Ya.pubkey) === /*event*/
      Hi[3].pubkey ? za ? (za.p(Hi, da), da[0] & /*$ndkUser, event*/
      268435464 && transition_in(za, 1)) : (za = create_if_block_5$1(Hi), za.c(), transition_in(za, 1), za.m(Hr, Mi)) : za && (group_outros(), transition_out(za, 1, 1, () => {
        za = null;
      }), check_outros()), /*$ndkUser*/
      ((Za = Hi[28]) == null ? void 0 : Za.pubkey) === /*event*/
      Hi[3].pubkey && /*editLvl*/
      Hi[2] == 1 ? Ia ? (Ia.p(Hi, da), da[0] & /*$ndkUser, event, editLvl*/
      268435468 && transition_in(Ia, 1)) : (Ia = create_if_block_4$1(Hi), Ia.c(), transition_in(Ia, 1), Ia.m(Hr, null)) : Ia && (group_outros(), transition_out(Ia, 1, 1, () => {
        Ia = null;
      }), check_outros()), /*reply*/
      Hi[18] ? Yi ? (Yi.p(Hi, da), da[0] & /*reply*/
      262144 && transition_in(Yi, 1)) : (Yi = create_if_block_3$1(Hi), Yi.c(), transition_in(Yi, 1), Yi.m(ar, Ei)) : Yi && (group_outros(), transition_out(Yi, 1, 1, () => {
        Yi = null;
      }), check_outros()), /*replyContent*/
      Hi[19] ? La ? (La.p(Hi, da), da[0] & /*replyContent*/
      524288 && transition_in(La, 1)) : (La = create_if_block_2$1(Hi), La.c(), transition_in(La, 1), La.m(ar, null)) : La && (group_outros(), transition_out(La, 1, 1, () => {
        La = null;
      }), check_outros()), (!Di || da[0] & /*isMine*/
      128 && Si !== (Si = "opinion-container " + /*isMine*/
      (Hi[7] ? "mine" : "") + " svelte-1aaaf7r")) && attr(ar, "class", Si);
    },
    i(Hi) {
      Di || (transition_in(vr), transition_in(na), transition_in(Ir), transition_in(Xr), transition_in(Ci), transition_in(ki.$$.fragment, Hi), transition_in(Bi.$$.fragment, Hi), transition_in(za), transition_in(Ia), transition_in(Yi), transition_in(La), Hi && add_render_callback(() => {
        Di && (Vi || (Vi = create_bidirectional_transition(ar, slide, {}, !0)), Vi.run(1));
      }), Di = !0);
    },
    o(Hi) {
      transition_out(vr), transition_out(na), transition_out(Ir), transition_out(Xr), transition_out(Ci), transition_out(ki.$$.fragment, Hi), transition_out(Bi.$$.fragment, Hi), transition_out(za), transition_out(Ia), transition_out(Yi), transition_out(La), Hi && (Vi || (Vi = create_bidirectional_transition(ar, slide, {}, !1)), Vi.run(0)), Di = !1;
    },
    d(Hi) {
      Hi && detach(ar), ~mr && ba[mr].d(), Fi.d(), na && na.d(), Gi && Gi.d(), $a[Ar].d(), pa[Gr].d(), Oa[gi].d(), destroy_component(ki), destroy_component(Bi), za && za.d(), Ia && Ia.d(), Yi && Yi.d(), La && La.d(), Hi && Vi && Vi.end(), sa = !1, run_all(ra);
    }
  };
}
function create_if_block_17(lr) {
  let ar, cr;
  return ar = new Positive({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_16(lr) {
  let ar, cr;
  return ar = new Neutral({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_15(lr) {
  let ar, cr;
  return ar = new Negative({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block_4(lr) {
  let ar, cr, ur, fr, dr, gr = convertNostrPubKeyToBech32(
    /*event*/
    lr[3].pubkey
  ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
    /*event*/
    lr[3].pubkey
  ).slice(-4), mr;
  return {
    c() {
      ar = element("div"), cr = element("img"), fr = space(), dr = element("span"), mr = text$3(gr), attr(cr, "class", "profile-image svelte-1aaaf7r"), src_url_equal(cr.src, ur = profileImageUrl + /*event*/
      lr[3].pubkey) || attr(cr, "src", ur), attr(cr, "alt", "Profile"), attr(ar, "class", "profile-header svelte-1aaaf7r");
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, cr), append(ar, fr), append(ar, dr), append(dr, mr);
    },
    p(vr, yr) {
      yr[0] & /*event*/
      8 && !src_url_equal(cr.src, ur = profileImageUrl + /*event*/
      vr[3].pubkey) && attr(cr, "src", ur), yr[0] & /*event*/
      8 && gr !== (gr = convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(-4)) && set_data(mr, gr);
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_if_block_14(lr) {
  var vr;
  let ar, cr, ur, fr, dr, gr = (
    /*profiles*/
    (((vr = lr[4][
      /*event*/
      lr[3].pubkey
    ].content) == null ? void 0 : vr.name) || convertNostrPubKeyToBech32(
      /*event*/
      lr[3].pubkey
    ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
      /*event*/
      lr[3].pubkey
    ).slice(-5)) + ""
  ), mr;
  return {
    c() {
      var yr, kr;
      ar = element("div"), cr = element("img"), fr = space(), dr = element("span"), mr = text$3(gr), attr(cr, "class", "profile-image svelte-1aaaf7r"), src_url_equal(cr.src, ur = /*profiles*/
      (yr = lr[4][
        /*event*/
        lr[3].pubkey
      ].content) != null && yr.image ? (
        /*profiles*/
        (kr = lr[4][
          /*event*/
          lr[3].pubkey
        ].content) == null ? void 0 : kr.image
      ) : profileImageUrl + /*event*/
      lr[3].pubkey) || attr(cr, "src", ur), attr(cr, "alt", "Profile Picture"), attr(ar, "class", "profile-header svelte-1aaaf7r");
    },
    m(yr, kr) {
      insert(yr, ar, kr), append(ar, cr), append(ar, fr), append(ar, dr), append(dr, mr);
    },
    p(yr, kr) {
      var _r, xr, Sr;
      kr[0] & /*profiles, event*/
      24 && !src_url_equal(cr.src, ur = /*profiles*/
      (_r = yr[4][
        /*event*/
        yr[3].pubkey
      ].content) != null && _r.image ? (
        /*profiles*/
        (xr = yr[4][
          /*event*/
          yr[3].pubkey
        ].content) == null ? void 0 : xr.image
      ) : profileImageUrl + /*event*/
      yr[3].pubkey) && attr(cr, "src", ur), kr[0] & /*profiles, event*/
      24 && gr !== (gr = /*profiles*/
      (((Sr = yr[4][
        /*event*/
        yr[3].pubkey
      ].content) == null ? void 0 : Sr.name) || convertNostrPubKeyToBech32(
        /*event*/
        yr[3].pubkey
      ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        yr[3].pubkey
      ).slice(-5)) + "") && set_data(mr, gr);
    },
    d(yr) {
      yr && detach(ar);
    }
  };
}
function create_if_block_13(lr) {
  let ar, cr;
  return ar = new ApprovedBadge({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_12(lr) {
  let ar;
  return {
    c() {
      ar = text$3("Edited.");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_else_block_3(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir, Mr, Hr, Br, zr, Gr, Xr, Jr, li, Qr = [], ei = /* @__PURE__ */ new Map(), ui, Ai, fi, gi, Ci, mi, vi, Ri, di, Ti, qi, ki, Ji, Bi;
  function Ni(ra) {
    lr[37](ra);
  }
  function Mi(ra) {
    lr[38](ra);
  }
  let bi = {};
  /*fileArray*/
  lr[27] !== void 0 && (bi.fileArray = /*fileArray*/
  lr[27]), /*opinionContent*/
  lr[5] !== void 0 && (bi.opinionContent = /*opinionContent*/
  lr[5]), ur = new Editor_1({ props: bi }), binding_callbacks.push(() => bind(ur, "fileArray", Ni)), binding_callbacks.push(() => bind(ur, "opinionContent", Mi)), xr = new Positive({}), Ar = new Neutral({}), zr = new Negative({});
  let Ei = ensure_array_like(
    /*fileArray*/
    lr[27]
  );
  const Si = (ra) => (
    /*file*/
    ra[70].url
  );
  for (let ra = 0; ra < Ei.length; ra += 1) {
    let fa = get_each_context_2(lr, Ei, ra), ba = Si(fa);
    ei.set(ba, Qr[ra] = create_each_block_2(ba, fa));
  }
  function Vi(ra) {
    lr[43](ra);
  }
  function Di(ra) {
    lr[44](ra);
  }
  let sa = {};
  return (
    /*fileArray*/
    lr[27] !== void 0 && (sa.fileArray = /*fileArray*/
    lr[27]), /*opinionContent*/
    lr[5] !== void 0 && (sa.opinionContent = /*opinionContent*/
    lr[5]), vi = new Upload({ props: sa }), binding_callbacks.push(() => bind(vi, "fileArray", Vi)), binding_callbacks.push(() => bind(vi, "opinionContent", Di)), {
      c() {
        ar = element("div"), cr = element("form"), create_component(ur.$$.fragment), gr = space(), mr = element("div"), vr = element("label"), vr.textContent = "Choose your overall sentiment", yr = space(), kr = element("div"), _r = element("button"), create_component(xr.$$.fragment), Sr = space(), Er = element("span"), Er.textContent = "Positive", Cr = space(), Tr = element("button"), create_component(Ar.$$.fragment), Ir = space(), Mr = element("span"), Mr.textContent = "Neutral", Hr = space(), Br = element("button"), create_component(zr.$$.fragment), Gr = space(), Xr = element("span"), Xr.textContent = "Negative", Jr = space(), li = element("div");
        for (let ra = 0; ra < Qr.length; ra += 1)
          Qr[ra].c();
        ui = space(), Ai = element("div"), fi = element("button"), gi = text$3("Post"), mi = space(), create_component(vi.$$.fragment), attr(vr, "for", "sentiment"), set_style(vr, "font-weight", "600"), attr(_r, "class", "deselected svelte-1aaaf7r"), toggle_class(
          _r,
          "dark",
          /*$theme*/
          lr[29] === "dark"
        ), toggle_class(
          _r,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "1"
        ), attr(Tr, "class", "deselected svelte-1aaaf7r"), toggle_class(
          Tr,
          "dark",
          /*$theme*/
          lr[29] === "dark"
        ), toggle_class(
          Tr,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "0"
        ), attr(Br, "class", "deselected svelte-1aaaf7r"), toggle_class(
          Br,
          "dark",
          /*$theme*/
          lr[29] === "dark"
        ), toggle_class(
          Br,
          "selected",
          /*newOpinion*/
          lr[0].sentiment === "-1"
        ), set_style(kr, "display", "flex"), set_style(kr, "gap", "0.4rem"), attr(mr, "id", "sentiment-box"), set_style(mr, "display", "flex"), set_style(mr, "flex-direction", "column"), set_style(mr, "gap", "0.3rem"), set_style(mr, "margin-bottom", "1rem"), attr(li, "id", "filePreview"), attr(li, "class", "svelte-1aaaf7r"), attr(fi, "type", "submit"), fi.disabled = Ci = !/*$ndkUser*/
        lr[28], attr(fi, "class", "postButton svelte-1aaaf7r"), set_style(Ai, "display", "flex"), set_style(Ai, "align-contents", "center"), attr(ar, "class", Ti = "opinion-container " + /*isMine*/
        (lr[7] ? "mine" : "") + " svelte-1aaaf7r");
      },
      m(ra, fa) {
        insert(ra, ar, fa), append(ar, cr), mount_component(ur, cr, null), append(cr, gr), append(cr, mr), append(mr, vr), append(mr, yr), append(mr, kr), append(kr, _r), mount_component(xr, _r, null), append(_r, Sr), append(_r, Er), append(kr, Cr), append(kr, Tr), mount_component(Ar, Tr, null), append(Tr, Ir), append(Tr, Mr), append(kr, Hr), append(kr, Br), mount_component(zr, Br, null), append(Br, Gr), append(Br, Xr), append(cr, Jr), append(cr, li);
        for (let ba = 0; ba < Qr.length; ba += 1)
          Qr[ba] && Qr[ba].m(li, null);
        append(cr, ui), append(cr, Ai), append(Ai, fi), append(fi, gi), append(Ai, mi), mount_component(vi, Ai, null), ki = !0, Ji || (Bi = [
          listen(_r, "click", prevent_default(
            /*click_handler*/
            lr[39]
          )),
          listen(Tr, "click", prevent_default(
            /*click_handler_1*/
            lr[40]
          )),
          listen(Br, "click", prevent_default(
            /*click_handler_2*/
            lr[41]
          )),
          listen(cr, "submit", prevent_default(
            /*submit_handler*/
            lr[45]
          ))
        ], Ji = !0);
      },
      p(ra, fa) {
        const ba = {};
        !fr && fa[0] & /*fileArray*/
        134217728 && (fr = !0, ba.fileArray = /*fileArray*/
        ra[27], add_flush_callback(() => fr = !1)), !dr && fa[0] & /*opinionContent*/
        32 && (dr = !0, ba.opinionContent = /*opinionContent*/
        ra[5], add_flush_callback(() => dr = !1)), ur.$set(ba), (!ki || fa[0] & /*$theme*/
        536870912) && toggle_class(
          _r,
          "dark",
          /*$theme*/
          ra[29] === "dark"
        ), (!ki || fa[0] & /*newOpinion*/
        1) && toggle_class(
          _r,
          "selected",
          /*newOpinion*/
          ra[0].sentiment === "1"
        ), (!ki || fa[0] & /*$theme*/
        536870912) && toggle_class(
          Tr,
          "dark",
          /*$theme*/
          ra[29] === "dark"
        ), (!ki || fa[0] & /*newOpinion*/
        1) && toggle_class(
          Tr,
          "selected",
          /*newOpinion*/
          ra[0].sentiment === "0"
        ), (!ki || fa[0] & /*$theme*/
        536870912) && toggle_class(
          Br,
          "dark",
          /*$theme*/
          ra[29] === "dark"
        ), (!ki || fa[0] & /*newOpinion*/
        1) && toggle_class(
          Br,
          "selected",
          /*newOpinion*/
          ra[0].sentiment === "-1"
        ), fa[0] & /*fileArray*/
        134217728 | fa[1] & /*deleteFile*/
        8 && (Ei = ensure_array_like(
          /*fileArray*/
          ra[27]
        ), group_outros(), Qr = update_keyed_each(Qr, fa, Si, 1, ra, Ei, ei, li, outro_and_destroy_block, create_each_block_2, null, get_each_context_2), check_outros()), (!ki || fa[0] & /*$ndkUser*/
        268435456 && Ci !== (Ci = !/*$ndkUser*/
        ra[28])) && (fi.disabled = Ci);
        const Ua = {};
        !Ri && fa[0] & /*fileArray*/
        134217728 && (Ri = !0, Ua.fileArray = /*fileArray*/
        ra[27], add_flush_callback(() => Ri = !1)), !di && fa[0] & /*opinionContent*/
        32 && (di = !0, Ua.opinionContent = /*opinionContent*/
        ra[5], add_flush_callback(() => di = !1)), vi.$set(Ua), (!ki || fa[0] & /*isMine*/
        128 && Ti !== (Ti = "opinion-container " + /*isMine*/
        (ra[7] ? "mine" : "") + " svelte-1aaaf7r")) && attr(ar, "class", Ti);
      },
      i(ra) {
        if (!ki) {
          transition_in(ur.$$.fragment, ra), transition_in(xr.$$.fragment, ra), transition_in(Ar.$$.fragment, ra), transition_in(zr.$$.fragment, ra);
          for (let fa = 0; fa < Ei.length; fa += 1)
            transition_in(Qr[fa]);
          transition_in(vi.$$.fragment, ra), ra && add_render_callback(() => {
            ki && (qi || (qi = create_bidirectional_transition(ar, slide, {}, !0)), qi.run(1));
          }), ki = !0;
        }
      },
      o(ra) {
        transition_out(ur.$$.fragment, ra), transition_out(xr.$$.fragment, ra), transition_out(Ar.$$.fragment, ra), transition_out(zr.$$.fragment, ra);
        for (let fa = 0; fa < Qr.length; fa += 1)
          transition_out(Qr[fa]);
        transition_out(vi.$$.fragment, ra), ra && (qi || (qi = create_bidirectional_transition(ar, slide, {}, !1)), qi.run(0)), ki = !1;
      },
      d(ra) {
        ra && detach(ar), destroy_component(ur), destroy_component(xr), destroy_component(Ar), destroy_component(zr);
        for (let fa = 0; fa < Qr.length; fa += 1)
          Qr[fa].d();
        destroy_component(vi), ra && qi && qi.end(), Ji = !1, run_all(Bi);
      }
    }
  );
}
function create_if_block_8(lr) {
  let ar, cr, ur, fr;
  const dr = [create_if_block_9, create_else_block_2], gr = [];
  function mr(vr, yr) {
    return (
      /*editLvl*/
      vr[2] == 1 ? 0 : 1
    );
  }
  return cr = mr(lr), ur = gr[cr] = dr[cr](lr), {
    c() {
      ar = element("p"), ur.c(), attr(ar, "class", "content svelte-1aaaf7r");
    },
    m(vr, yr) {
      insert(vr, ar, yr), gr[cr].m(ar, null), fr = !0;
    },
    p(vr, yr) {
      let kr = cr;
      cr = mr(vr), cr === kr ? gr[cr].p(vr, yr) : (group_outros(), transition_out(gr[kr], 1, 1, () => {
        gr[kr] = null;
      }), check_outros(), ur = gr[cr], ur ? ur.p(vr, yr) : (ur = gr[cr] = dr[cr](vr), ur.c()), transition_in(ur, 1), ur.m(ar, null));
    },
    i(vr) {
      fr || (transition_in(ur), fr = !0);
    },
    o(vr) {
      transition_out(ur), fr = !1;
    },
    d(vr) {
      vr && detach(ar), gr[cr].d();
    }
  };
}
function create_each_block_2(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func_2*/
      ar[42](
        /*file*/
        ar[70]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[70].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(gr, mr) {
      insert(gr, cr, mr), mount_component(ur, gr, mr), fr = !0;
    },
    p(gr, mr) {
      ar = gr;
      const vr = {};
      mr[0] & /*fileArray*/
      134217728 && (vr.file = /*file*/
      ar[70].files), mr[0] & /*fileArray*/
      134217728 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(gr) {
      fr || (transition_in(ur.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && detach(cr), destroy_component(ur, gr);
    }
  };
}
function create_else_block_2(lr) {
  let ar, cr, ur, fr = (
    /*event*/
    lr[3].content.length > maxLength && /*editLvl*/
    lr[2] > 1 && create_if_block_11(lr)
  );
  return {
    c() {
      ar = new HtmlTag(!1), cr = space(), fr && fr.c(), ur = empty$1(), ar.a = cr;
    },
    m(dr, gr) {
      ar.m(
        /*processedContent*/
        lr[26],
        dr,
        gr
      ), insert(dr, cr, gr), fr && fr.m(dr, gr), insert(dr, ur, gr);
    },
    p(dr, gr) {
      gr[0] & /*processedContent*/
      67108864 && ar.p(
        /*processedContent*/
        dr[26]
      ), /*event*/
      dr[3].content.length > maxLength && /*editLvl*/
      dr[2] > 1 ? fr ? fr.p(dr, gr) : (fr = create_if_block_11(dr), fr.c(), fr.m(ur.parentNode, ur)) : fr && (fr.d(1), fr = null);
    },
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && (ar.d(), detach(cr), detach(ur)), fr && fr.d(dr);
    }
  };
}
function create_if_block_9(lr) {
  let ar, cr, ur, fr;
  ar = new ContentView({
    props: { content: (
      /*processedContent*/
      lr[26]
    ) }
  });
  let dr = (
    /*event*/
    lr[3].content.length > maxLength && /*editLvl*/
    lr[2] == 1 && create_if_block_10(lr)
  );
  return {
    c() {
      create_component(ar.$$.fragment), cr = space(), dr && dr.c(), ur = empty$1();
    },
    m(gr, mr) {
      mount_component(ar, gr, mr), insert(gr, cr, mr), dr && dr.m(gr, mr), insert(gr, ur, mr), fr = !0;
    },
    p(gr, mr) {
      const vr = {};
      mr[0] & /*processedContent*/
      67108864 && (vr.content = /*processedContent*/
      gr[26]), ar.$set(vr), /*event*/
      gr[3].content.length > maxLength && /*editLvl*/
      gr[2] == 1 ? dr ? dr.p(gr, mr) : (dr = create_if_block_10(gr), dr.c(), dr.m(ur.parentNode, ur)) : dr && (dr.d(1), dr = null);
    },
    i(gr) {
      fr || (transition_in(ar.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ar.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && (detach(cr), detach(ur)), destroy_component(ar, gr), dr && dr.d(gr);
    }
  };
}
function create_if_block_11(lr) {
  let ar, cr = (
    /*showFullText*/
    lr[11] ? "Read Less" : "Read More"
  ), ur, fr, dr;
  return {
    c() {
      ar = element("span"), ur = text$3(cr), attr(ar, "class", "read-more svelte-1aaaf7r");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, ur), fr || (dr = listen(
        ar,
        "click",
        /*toggleFullText*/
        lr[30]
      ), fr = !0);
    },
    p(gr, mr) {
      mr[0] & /*showFullText*/
      2048 && cr !== (cr = /*showFullText*/
      gr[11] ? "Read Less" : "Read More") && set_data(ur, cr);
    },
    d(gr) {
      gr && detach(ar), fr = !1, dr();
    }
  };
}
function create_if_block_10(lr) {
  let ar, cr = (
    /*showFullText*/
    lr[11] ? "Read Less" : "Read More"
  ), ur, fr, dr;
  return {
    c() {
      ar = element("span"), ur = text$3(cr), attr(ar, "class", "read-more svelte-1aaaf7r");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, ur), fr || (dr = listen(
        ar,
        "click",
        /*toggleFullText*/
        lr[30]
      ), fr = !0);
    },
    p(gr, mr) {
      mr[0] & /*showFullText*/
      2048 && cr !== (cr = /*showFullText*/
      gr[11] ? "Read Less" : "Read More") && set_data(ur, cr);
    },
    d(gr) {
      gr && detach(ar), fr = !1, dr();
    }
  };
}
function create_else_block_1$1(lr) {
  let ar, cr;
  return ar = new LikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_7$1(lr) {
  let ar, cr;
  return ar = new LikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block$1(lr) {
  let ar, cr;
  return ar = new DislikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_6$1(lr) {
  let ar, cr;
  return ar = new DislikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_default_slot_1(lr) {
  let ar, cr, ur, fr, dr;
  return cr = new ReplyButton({}), {
    c() {
      ar = element("button"), create_component(cr.$$.fragment), attr(ar, "id", "replyButton"), attr(ar, "class", "svelte-1aaaf7r");
    },
    m(gr, mr) {
      insert(gr, ar, mr), mount_component(cr, ar, null), ur = !0, fr || (dr = listen(
        ar,
        "click",
        /*click_handler_5*/
        lr[48]
      ), fr = !0);
    },
    p: noop$1,
    i(gr) {
      ur || (transition_in(cr.$$.fragment, gr), ur = !0);
    },
    o(gr) {
      transition_out(cr.$$.fragment, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_component(cr), fr = !1, dr();
    }
  };
}
function create_tooltip1Text_slot_1(lr) {
  let ar;
  return {
    c() {
      ar = element("span"), ar.textContent = "Add Reply", attr(ar, "slot", "tooltip1Text");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_default_slot(lr) {
  let ar, cr, ur = (
    /*replyEvents*/
    lr[13].length + ""
  ), fr, dr, gr;
  return {
    c() {
      ar = element("button"), cr = element("span"), fr = text$3(ur), set_style(cr, "pointer", "cursor"), attr(ar, "id", "allReply"), attr(ar, "class", "svelte-1aaaf7r");
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, cr), append(cr, fr), dr || (gr = listen(
        ar,
        "click",
        /*click_handler_6*/
        lr[49]
      ), dr = !0);
    },
    p(mr, vr) {
      vr[0] & /*replyEvents*/
      8192 && ur !== (ur = /*replyEvents*/
      mr[13].length + "") && set_data(fr, ur);
    },
    d(mr) {
      mr && detach(ar), dr = !1, gr();
    }
  };
}
function create_tooltip1Text_slot(lr) {
  let ar;
  return {
    c() {
      ar = element("span"), ar.textContent = "Replies", attr(ar, "slot", "tooltip1Text");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_5$1(lr) {
  let ar, cr, ur, fr;
  function dr(vr) {
    lr[50](vr);
  }
  function gr(vr) {
    lr[51](vr);
  }
  let mr = { eventID: (
    /*event*/
    lr[3].id
  ) };
  return (
    /*isDeleted*/
    lr[12] !== void 0 && (mr.isDeleted = /*isDeleted*/
    lr[12]), /*count*/
    lr[6] !== void 0 && (mr.count = /*count*/
    lr[6]), ar = new DeleteEventData({ props: mr }), binding_callbacks.push(() => bind(ar, "isDeleted", dr)), binding_callbacks.push(() => bind(ar, "count", gr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, yr) {
        mount_component(ar, vr, yr), fr = !0;
      },
      p(vr, yr) {
        const kr = {};
        yr[0] & /*event*/
        8 && (kr.eventID = /*event*/
        vr[3].id), !cr && yr[0] & /*isDeleted*/
        4096 && (cr = !0, kr.isDeleted = /*isDeleted*/
        vr[12], add_flush_callback(() => cr = !1)), !ur && yr[0] & /*count*/
        64 && (ur = !0, kr.count = /*count*/
        vr[6], add_flush_callback(() => ur = !1)), ar.$set(kr);
      },
      i(vr) {
        fr || (transition_in(ar.$$.fragment, vr), fr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), fr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_4$1(lr) {
  let ar, cr, ur, fr, dr, gr;
  return ur = new OptionButton({}), {
    c() {
      ar = element("div"), cr = element("button"), create_component(ur.$$.fragment), attr(cr, "class", "option-button svelte-1aaaf7r"), attr(ar, "class", "card-button svelte-1aaaf7r");
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, cr), mount_component(ur, cr, null), fr = !0, dr || (gr = listen(
        cr,
        "click",
        /*click_handler_7*/
        lr[52]
      ), dr = !0);
    },
    p: noop$1,
    i(mr) {
      fr || (transition_in(ur.$$.fragment, mr), fr = !0);
    },
    o(mr) {
      transition_out(ur.$$.fragment, mr), fr = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_component(ur), dr = !1, gr();
    }
  };
}
function create_if_block_3$1(lr) {
  let ar, cr, ur, fr, dr, gr = [], mr = /* @__PURE__ */ new Map(), vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar, Ir, Mr, Hr;
  function Br(ei) {
    lr[53](ei);
  }
  let zr = {};
  /*opinionContent*/
  lr[5] !== void 0 && (zr.opinionContent = /*opinionContent*/
  lr[5]), cr = new TextArea({ props: zr }), binding_callbacks.push(() => bind(cr, "opinionContent", Br));
  let Gr = ensure_array_like(
    /*fileArray*/
    lr[27]
  );
  const Xr = (ei) => (
    /*file*/
    ei[70].url
  );
  for (let ei = 0; ei < Gr.length; ei += 1) {
    let ui = get_each_context_1$1(lr, Gr, ei), Ai = Xr(ui);
    mr.set(Ai, gr[ei] = create_each_block_1$1(Ai, ui));
  }
  function Jr(ei) {
    lr[56](ei);
  }
  function li(ei) {
    lr[57](ei);
  }
  let Qr = {};
  return (
    /*fileArray*/
    lr[27] !== void 0 && (Qr.fileArray = /*fileArray*/
    lr[27]), /*opinionContent*/
    lr[5] !== void 0 && (Qr.opinionContent = /*opinionContent*/
    lr[5]), Er = new Upload({ props: Qr }), binding_callbacks.push(() => bind(Er, "fileArray", Jr)), binding_callbacks.push(() => bind(Er, "opinionContent", li)), {
      c() {
        ar = element("div"), create_component(cr.$$.fragment), fr = space(), dr = element("div");
        for (let ei = 0; ei < gr.length; ei += 1)
          gr[ei].c();
        vr = space(), yr = element("div"), kr = element("button"), _r = text$3("Reply"), Sr = space(), create_component(Er.$$.fragment), attr(dr, "class", "reply-file-preview svelte-1aaaf7r"), attr(kr, "class", "reply-button svelte-1aaaf7r"), kr.disabled = xr = !/*$ndkUser*/
        lr[28], attr(yr, "class", "reply-footer svelte-1aaaf7r"), attr(ar, "class", "reply-section svelte-1aaaf7r");
      },
      m(ei, ui) {
        insert(ei, ar, ui), mount_component(cr, ar, null), append(ar, fr), append(ar, dr);
        for (let Ai = 0; Ai < gr.length; Ai += 1)
          gr[Ai] && gr[Ai].m(dr, null);
        append(ar, vr), append(ar, yr), append(yr, kr), append(kr, _r), append(yr, Sr), mount_component(Er, yr, null), Ir = !0, Mr || (Hr = listen(
          kr,
          "click",
          /*click_handler_8*/
          lr[55]
        ), Mr = !0);
      },
      p(ei, ui) {
        const Ai = {};
        !ur && ui[0] & /*opinionContent*/
        32 && (ur = !0, Ai.opinionContent = /*opinionContent*/
        ei[5], add_flush_callback(() => ur = !1)), cr.$set(Ai), ui[0] & /*fileArray*/
        134217728 | ui[1] & /*deleteFile*/
        8 && (Gr = ensure_array_like(
          /*fileArray*/
          ei[27]
        ), group_outros(), gr = update_keyed_each(gr, ui, Xr, 1, ei, Gr, mr, dr, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1), check_outros()), (!Ir || ui[0] & /*$ndkUser*/
        268435456 && xr !== (xr = !/*$ndkUser*/
        ei[28])) && (kr.disabled = xr);
        const fi = {};
        !Cr && ui[0] & /*fileArray*/
        134217728 && (Cr = !0, fi.fileArray = /*fileArray*/
        ei[27], add_flush_callback(() => Cr = !1)), !Tr && ui[0] & /*opinionContent*/
        32 && (Tr = !0, fi.opinionContent = /*opinionContent*/
        ei[5], add_flush_callback(() => Tr = !1)), Er.$set(fi);
      },
      i(ei) {
        if (!Ir) {
          transition_in(cr.$$.fragment, ei);
          for (let ui = 0; ui < Gr.length; ui += 1)
            transition_in(gr[ui]);
          transition_in(Er.$$.fragment, ei), ei && add_render_callback(() => {
            Ir && (Ar || (Ar = create_bidirectional_transition(ar, fade, {}, !0)), Ar.run(1));
          }), Ir = !0;
        }
      },
      o(ei) {
        transition_out(cr.$$.fragment, ei);
        for (let ui = 0; ui < gr.length; ui += 1)
          transition_out(gr[ui]);
        transition_out(Er.$$.fragment, ei), ei && (Ar || (Ar = create_bidirectional_transition(ar, fade, {}, !1)), Ar.run(0)), Ir = !1;
      },
      d(ei) {
        ei && detach(ar), destroy_component(cr);
        for (let ui = 0; ui < gr.length; ui += 1)
          gr[ui].d();
        destroy_component(Er), ei && Ar && Ar.end(), Mr = !1, Hr();
      }
    }
  );
}
function create_each_block_1$1(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func_3*/
      ar[54](
        /*file*/
        ar[70]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[70].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(gr, mr) {
      insert(gr, cr, mr), mount_component(ur, gr, mr), fr = !0;
    },
    p(gr, mr) {
      ar = gr;
      const vr = {};
      mr[0] & /*fileArray*/
      134217728 && (vr.file = /*file*/
      ar[70].files), mr[0] & /*fileArray*/
      134217728 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(gr) {
      fr || (transition_in(ur.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && detach(cr), destroy_component(ur, gr);
    }
  };
}
function create_if_block_2$1(lr) {
  let ar = [], cr = /* @__PURE__ */ new Map(), ur, fr, dr = ensure_array_like(
    /*replyEvents*/
    lr[13]
  );
  const gr = (mr) => (
    /*event*/
    mr[3].id
  );
  for (let mr = 0; mr < dr.length; mr += 1) {
    let vr = get_each_context$1(lr, dr, mr), yr = gr(vr);
    cr.set(yr, ar[mr] = create_each_block$1(yr, vr));
  }
  return {
    c() {
      for (let mr = 0; mr < ar.length; mr += 1)
        ar[mr].c();
      ur = empty$1();
    },
    m(mr, vr) {
      for (let yr = 0; yr < ar.length; yr += 1)
        ar[yr] && ar[yr].m(mr, vr);
      insert(mr, ur, vr), fr = !0;
    },
    p(mr, vr) {
      vr[0] & /*replyEvents, profiles, editLvl, subject, sentimentCount, opinionContent, newOpinion*/
      8759 && (dr = ensure_array_like(
        /*replyEvents*/
        mr[13]
      ), group_outros(), ar = update_keyed_each(ar, vr, gr, 1, mr, dr, cr, ur.parentNode, outro_and_destroy_block, create_each_block$1, ur, get_each_context$1), check_outros());
    },
    i(mr) {
      if (!fr) {
        for (let vr = 0; vr < dr.length; vr += 1)
          transition_in(ar[vr]);
        fr = !0;
      }
    },
    o(mr) {
      for (let vr = 0; vr < ar.length; vr += 1)
        transition_out(ar[vr]);
      fr = !1;
    },
    d(mr) {
      mr && detach(ur);
      for (let vr = 0; vr < ar.length; vr += 1)
        ar[vr].d(mr);
    }
  };
}
function create_each_block$1(lr, ar) {
  let cr, ur, fr, dr, gr, mr, vr;
  function yr(Er) {
    ar[58](Er);
  }
  function kr(Er) {
    ar[59](Er);
  }
  function _r(Er) {
    ar[60](Er);
  }
  function xr(Er) {
    ar[61](Er);
  }
  let Sr = {
    event: (
      /*event*/
      ar[3]
    ),
    profiles: (
      /*profiles*/
      ar[4]
    ),
    editLvl: (
      /*editLvl*/
      ar[2]
    ),
    subject: (
      /*subject*/
      ar[9]
    )
  };
  return (
    /*sentimentCount*/
    ar[1] !== void 0 && (Sr.sentimentCount = /*sentimentCount*/
    ar[1]), /*opinionContent*/
    ar[5] !== void 0 && (Sr.opinionContent = /*opinionContent*/
    ar[5]), /*newOpinion*/
    ar[0] !== void 0 && (Sr.newOpinion = /*newOpinion*/
    ar[0]), /*replyEvents*/
    ar[13].length !== void 0 && (Sr.count = /*replyEvents*/
    ar[13].length), ur = new OpinionCard({ props: Sr }), binding_callbacks.push(() => bind(ur, "sentimentCount", yr)), binding_callbacks.push(() => bind(ur, "opinionContent", kr)), binding_callbacks.push(() => bind(ur, "newOpinion", _r)), binding_callbacks.push(() => bind(ur, "count", xr)), {
      key: lr,
      first: null,
      c() {
        cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
      },
      m(Er, Cr) {
        insert(Er, cr, Cr), mount_component(ur, Er, Cr), vr = !0;
      },
      p(Er, Cr) {
        ar = Er;
        const Tr = {};
        Cr[0] & /*replyEvents*/
        8192 && (Tr.event = /*event*/
        ar[3]), Cr[0] & /*profiles*/
        16 && (Tr.profiles = /*profiles*/
        ar[4]), Cr[0] & /*editLvl*/
        4 && (Tr.editLvl = /*editLvl*/
        ar[2]), Cr[0] & /*subject*/
        512 && (Tr.subject = /*subject*/
        ar[9]), !fr && Cr[0] & /*sentimentCount*/
        2 && (fr = !0, Tr.sentimentCount = /*sentimentCount*/
        ar[1], add_flush_callback(() => fr = !1)), !dr && Cr[0] & /*opinionContent*/
        32 && (dr = !0, Tr.opinionContent = /*opinionContent*/
        ar[5], add_flush_callback(() => dr = !1)), !gr && Cr[0] & /*newOpinion*/
        1 && (gr = !0, Tr.newOpinion = /*newOpinion*/
        ar[0], add_flush_callback(() => gr = !1)), !mr && Cr[0] & /*replyEvents*/
        8192 && (mr = !0, Tr.count = /*replyEvents*/
        ar[13].length, add_flush_callback(() => mr = !1)), ur.$set(Tr);
      },
      i(Er) {
        vr || (transition_in(ur.$$.fragment, Er), vr = !0);
      },
      o(Er) {
        transition_out(ur.$$.fragment, Er), vr = !1;
      },
      d(Er) {
        Er && detach(cr), destroy_component(ur, Er);
      }
    }
  );
}
function create_fragment$2(lr) {
  let ar, cr, ur = !/*isDeleted*/
  lr[12] && create_if_block$1(lr);
  return {
    c() {
      ur && ur.c(), ar = empty$1();
    },
    m(fr, dr) {
      ur && ur.m(fr, dr), insert(fr, ar, dr), cr = !0;
    },
    p(fr, dr) {
      /*isDeleted*/
      fr[12] ? ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros()) : ur ? (ur.p(fr, dr), dr[0] & /*isDeleted*/
      4096 && transition_in(ur, 1)) : (ur = create_if_block$1(fr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar));
    },
    i(fr) {
      cr || (transition_in(ur), cr = !0);
    },
    o(fr) {
      transition_out(ur), cr = !1;
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(fr);
    }
  };
}
const maxLength = 500;
function truncateText(lr, ar) {
  return lr.length > ar ? lr.slice(0, ar) + "..." : lr;
}
const func = (lr) => lr[0] === "sentiment", func_1 = (lr) => lr[0] === "sentiment";
function instance$2(lr, ar, cr) {
  let ur, fr, dr, gr;
  component_subscribe(lr, ndkStore, (Yi) => cr(64, ur = Yi)), component_subscribe(lr, ndkUser, (Yi) => cr(28, fr = Yi)), component_subscribe(lr, localStore, (Yi) => cr(65, dr = Yi)), component_subscribe(lr, theme, (Yi) => cr(29, gr = Yi));
  let { event: mr } = ar, { profiles: vr } = ar, { submit: yr = () => {
  } } = ar, { opinionContent: kr } = ar, { newOpinion: _r } = ar, { sentimentCount: xr } = ar, { editLvl: Sr } = ar, { subject: Er } = ar, { count: Cr } = ar, { deletedEventsArray: Tr = [] } = ar, { isMine: Ar = !1 } = ar, { trustedAuthors: Ir = [] } = ar;
  kr = kr.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "");
  let Mr = [], Hr = [], Br, zr = 0, Gr = 0, Xr = !1, Jr = !1, li = !1, Qr = !0, ei = !1, ui = !1, Ai = !1, fi = mr.id, gi = "", Ci, mi, vi = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), Ri = !1, di = mr.content, Ti = truncateText(di, maxLength), qi = [];
  Sr === 0 && (fi = kindOpinion + ":" + mr.pubkey + ":" + Er);
  function ki() {
    cr(11, Ai = !Ai);
  }
  function Ji(Yi) {
    cr(0, _r = { ..._r, sentiment: Yi });
  }
  async function Bi(Yi) {
    const La = dr.pk;
    if (La ? !ur.signer && await privkeyLogin(La) : !ur.signer && await NDKlogin(), !fr)
      return;
    let Ka = Hr.findIndex((Hi) => Hi.pubkey === fr.pubkey);
    Ka != -1 && Hr[Ka].content === Yi && (Yi = "");
    const Qa = new NDKEvent(ur);
    Qa.kind = NDKKind.Reaction, Qa.content = Yi, Qa.tags = [["a", fi], ["p", fr.pubkey]], await Qa.publish(NDKRelaySet.fromRelayUrls(vi.write, ur)), Ka = Hr.findIndex((Hi) => Hi.pubkey === fr.pubkey), Ka != -1 ? Hr[Ka] = {
      pubkey: fr.pubkey,
      content: Yi,
      timestamp: Date.now()
    } : Hr.push({
      pubkey: fr.pubkey,
      content: Yi,
      timestamp: Date.now()
    }), cr(15, zr = Hr.filter((Hi) => Hi.content === "+").length), cr(16, Gr = Hr.filter((Hi) => Hi.content === "-").length), Yi === "+" ? (cr(21, ei = !0), cr(22, ui = !1)) : Yi === "-" ? (cr(21, ei = !1), cr(22, ui = !0)) : (cr(21, ei = !1), cr(22, ui = !1));
  }
  (async () => {
    var ja, Ga;
    cr(3, mr.content = mr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""), mr);
    const Yi = new marked.Renderer(), La = "max-width: 100px; height: 100px; border-radius:10px; object-fit: cover;";
    Yi.image = (xa, qa, Ya) => `<img src="${xa}" alt="${Ya}" title="${qa}" style="${La}" />`, Yi.link = (xa, qa, Ya) => xa.match(/\.(jpeg|jpg|gif|png|svg|webp)$/i) != null ? `<a href="${xa}" target="_blank"><img src="${xa}" alt="${Ya}" title="${qa}" style="${La}" /></a>` : `<a href="${xa}" title="${qa}" target="_blank">${Ya}</a>`, marked.setOptions({ renderer: Yi }), cr(14, Br = (await Promise.resolve().then(() => main)).expertOpinions), cr(2, Sr += 1), cr(23, gi = calculateRelativeTime(mr.created_at)), cr(20, Qr = !1);
    let Ka = { kinds: [kindNotes], "#a": [fi] };
    (await ur.fetchEvents(Ka, { closeOnEose: !1 })).forEach(async (xa) => {
      cr(13, Mr = [...Mr, { ...xa }]);
      const qa = await fetchUserProfile(xa.pubkey);
      qa.image || (qa.image = profileImageUrl + xa.pubkey), qa.pubkey || (qa.pubkey = xa.pubkey), cr(4, vr[xa.pubkey] = { content: qa }, vr);
    });
    let Hi = 0;
    Ka = { kinds: [kindReaction], "#a": [fi] }, (await ur.fetchEvents(Ka, { closeOnEose: !1 })).forEach((xa) => {
      let qa = Hr.findIndex((Ya) => Ya.pubkey === xa.pubkey);
      xa.created_at && (qa != -1 ? Hr[qa].timestamp < xa.created_at && (Hr[qa] = {
        pubkey: xa.pubkey,
        content: xa.content,
        timestamp: xa.created_at
      }) : Hr.push({
        pubkey: xa.pubkey,
        content: xa.content,
        timestamp: xa.created_at
      }), cr(15, zr = Hr.filter((Ya) => Ya.content === "+").length), cr(16, Gr = Hr.filter((Ya) => Ya.content === "-").length), fr != null && fr.pubkey && xa.pubkey === fr.pubkey && Hi < xa.created_at && (Hi = xa.created_at, xa.content === "+" ? (cr(21, ei = !0), cr(22, ui = !1)) : xa.content === "-" ? (cr(21, ei = !1), cr(22, ui = !0)) : (cr(21, ei = !1), cr(22, ui = !1))));
    });
    let aa = await ur.fetchEvent({ kinds: [10002], authors: [mr.pubkey] }, { closeOnEose: !0 });
    aa && aa.getMatchingTags("r").map((xa) => {
      xa.length === 3 ? xa[2] === "write" && !vi.write.includes(xa[1]) ? vi.write.push(xa[1]) : xa[2] === "read" && !vi.read.includes(xa[1]) && vi.read.push(xa[1]) : xa.length === 2 && (vi.write.includes(xa[1]) || vi.write.push(xa[1]), vi.read.includes(xa[1]) || vi.read.push(xa[1]));
    });
    const oa = (Ga = (ja = mr.tags.filter((xa) => xa[0] === "published_at")[0]) == null ? void 0 : ja[1]) == null ? void 0 : Ga.slice(0, 10);
    oa && cr(24, Ci = parseInt(oa)), cr(25, mi = mr.created_at);
  })();
  const Mi = async () => {
    if (!fr) {
      console.log("Can't submit reply. $ndkUser is undefined");
      return;
    }
    const Yi = dr.pk;
    if (Yi ? !ur.signer && await privkeyLogin(Yi) : !ur.signer && await NDKlogin(), kr === "" || !kr)
      return;
    const La = new NDKEvent(ur);
    La.kind = NDKKind.Text, La.content = kr, La.tags = [["a", fi], ["p", fr.pubkey]], await La.publish(NDKRelaySet.fromRelayUrls(vi.write, ur)), cr(13, Mr = [...Mr, { ...La }]), cr(5, kr = "");
  };
  function bi(Yi) {
    const La = qi.filter((Ka) => Ka === Yi)[0].url;
    cr(5, kr = kr.replace(La, "")), cr(27, qi = qi.filter((Ka) => Ka !== Yi));
  }
  function Ei(Yi) {
    qi = Yi, cr(27, qi);
  }
  function Si(Yi) {
    kr = Yi, cr(5, kr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  const Vi = () => Ji("1"), Di = () => Ji("0"), sa = () => Ji("-1"), ra = (Yi) => bi(Yi);
  function fa(Yi) {
    qi = Yi, cr(27, qi);
  }
  function ba(Yi) {
    kr = Yi, cr(5, kr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  const Ua = () => yr((Ci || /* @__PURE__ */ new Date()).toString()), Va = () => Bi("+"), Ma = () => Bi("-"), Fi = () => {
    cr(18, Jr = !Jr), cr(17, Xr = !1), cr(5, kr = ""), cr(19, li = !1);
  }, na = () => {
    cr(19, li = !li);
  };
  function Gi(Yi) {
    Ri = Yi, cr(12, Ri);
  }
  function Ca(Yi) {
    Cr = Yi, cr(6, Cr);
  }
  const $a = () => {
    cr(17, Xr = !Xr), cr(5, kr = mr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), cr(0, _r = {
      content: kr,
      sentiment: mr.tagValue("sentiment") || "0"
    }), cr(18, Jr = !1), cr(19, li = !1);
  };
  function no(Yi) {
    kr = Yi, cr(5, kr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  const ga = (Yi) => bi(Yi), pa = () => {
    Mi(), cr(18, Jr = !1), cr(19, li = !1);
  };
  function Sa(Yi) {
    qi = Yi, cr(27, qi);
  }
  function Na(Yi) {
    kr = Yi, cr(5, kr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  function Oa(Yi) {
    xr = Yi, cr(1, xr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(35, Tr), cr(3, mr);
  }
  function Ja(Yi) {
    kr = Yi, cr(5, kr), cr(12, Ri), cr(2, Sr), cr(0, _r), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  function za(Yi) {
    _r = Yi, cr(0, _r), cr(12, Ri), cr(2, Sr), cr(1, xr), cr(35, Tr), cr(3, mr);
  }
  function Ia(Yi) {
    lr.$$.not_equal(Mr.length, Yi) && (Mr.length = Yi, cr(13, Mr));
  }
  return lr.$$set = (Yi) => {
    "event" in Yi && cr(3, mr = Yi.event), "profiles" in Yi && cr(4, vr = Yi.profiles), "submit" in Yi && cr(8, yr = Yi.submit), "opinionContent" in Yi && cr(5, kr = Yi.opinionContent), "newOpinion" in Yi && cr(0, _r = Yi.newOpinion), "sentimentCount" in Yi && cr(1, xr = Yi.sentimentCount), "editLvl" in Yi && cr(2, Sr = Yi.editLvl), "subject" in Yi && cr(9, Er = Yi.subject), "count" in Yi && cr(6, Cr = Yi.count), "deletedEventsArray" in Yi && cr(35, Tr = Yi.deletedEventsArray), "isMine" in Yi && cr(7, Ar = Yi.isMine), "trustedAuthors" in Yi && cr(10, Ir = Yi.trustedAuthors);
  }, lr.$$.update = () => {
    if (lr.$$.dirty[0] & /*editLvl, event*/
    12 && cr(36, di = Sr > 1 ? mr.content : purify.sanitize(mr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""))), lr.$$.dirty[0] & /*showFullText*/
    2048 | lr.$$.dirty[1] & /*displayContent*/
    32 && cr(26, Ti = Ai ? di : truncateText(di, maxLength)), lr.$$.dirty[0] & /*isDeleted, editLvl, newOpinion, sentimentCount, event*/
    4111 | lr.$$.dirty[1] & /*deletedEventsArray*/
    16 && Ri) {
      if (Sr == 1) {
        cr(7, Ar = !1);
        let Yi = _r.sentiment, La = xr[Yi] - 1;
        Yi === "1" ? cr(1, xr = { ...xr, 1: La }) : Yi === "0" ? cr(1, xr = { ...xr, 0: La }) : cr(1, xr = { ...xr, "-1": La }), cr(0, _r = { content: "", sentiment: "0" }), cr(5, kr = "");
      }
      cr(35, Tr = [...Tr, mr]);
    }
  }, [
    _r,
    xr,
    Sr,
    mr,
    vr,
    kr,
    Cr,
    Ar,
    yr,
    Er,
    Ir,
    Ai,
    Ri,
    Mr,
    Br,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    Qr,
    ei,
    ui,
    gi,
    Ci,
    mi,
    Ti,
    qi,
    fr,
    gr,
    ki,
    Ji,
    Bi,
    Mi,
    bi,
    Tr,
    di,
    Ei,
    Si,
    Vi,
    Di,
    sa,
    ra,
    fa,
    ba,
    Ua,
    Va,
    Ma,
    Fi,
    na,
    Gi,
    Ca,
    $a,
    no,
    ga,
    pa,
    Sa,
    Na,
    Oa,
    Ja,
    za,
    Ia
  ];
}
class OpinionCard extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$2,
      create_fragment$2,
      safe_not_equal,
      {
        event: 3,
        profiles: 4,
        submit: 8,
        opinionContent: 5,
        newOpinion: 0,
        sentimentCount: 1,
        editLvl: 2,
        subject: 9,
        count: 6,
        deletedEventsArray: 35,
        isMine: 7,
        trustedAuthors: 10
      },
      add_css$2,
      [-1, -1, -1]
    );
  }
  get event() {
    return this.$$.ctx[3];
  }
  set event(ar) {
    this.$$set({ event: ar }), flush();
  }
  get profiles() {
    return this.$$.ctx[4];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get submit() {
    return this.$$.ctx[8];
  }
  set submit(ar) {
    this.$$set({ submit: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[5];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get newOpinion() {
    return this.$$.ctx[0];
  }
  set newOpinion(ar) {
    this.$$set({ newOpinion: ar }), flush();
  }
  get sentimentCount() {
    return this.$$.ctx[1];
  }
  set sentimentCount(ar) {
    this.$$set({ sentimentCount: ar }), flush();
  }
  get editLvl() {
    return this.$$.ctx[2];
  }
  set editLvl(ar) {
    this.$$set({ editLvl: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[9];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get count() {
    return this.$$.ctx[6];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
  get deletedEventsArray() {
    return this.$$.ctx[35];
  }
  set deletedEventsArray(ar) {
    this.$$set({ deletedEventsArray: ar }), flush();
  }
  get isMine() {
    return this.$$.ctx[7];
  }
  set isMine(ar) {
    this.$$set({ isMine: ar }), flush();
  }
  get trustedAuthors() {
    return this.$$.ctx[10];
  }
  set trustedAuthors(ar) {
    this.$$set({ trustedAuthors: ar }), flush();
  }
}
create_custom_element(OpinionCard, { event: {}, profiles: {}, submit: {}, opinionContent: {}, newOpinion: {}, sentimentCount: {}, editLvl: {}, subject: {}, count: {}, deletedEventsArray: {}, isMine: { type: "Boolean" }, trustedAuthors: {} }, [], [], !0);
function add_css$1(lr) {
  append_styles(lr, "svelte-6mkbgl", ".modal-overlay.svelte-6mkbgl{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.5);display:flex;justify-content:center;align-items:center;z-index:2}.modal.svelte-6mkbgl{background-color:var(--neutral-6, white);color:var(--neutral-0, black);border:1px solid var(--neutral-7);padding:20px;border-radius:5px;display:flex;flex-direction:column;gap:10px}.primary-btn.svelte-6mkbgl{color:#ffffff;background-color:#4da84d;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}");
}
function create_fragment$1(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er;
  return {
    c() {
      ar = element("div"), cr = element("div"), ur = element("p"), ur.textContent = "Are you sure you want to display all opinions?", fr = space(), dr = element("p"), dr.innerHTML = "<center>⚠️ Viewer discretion advised.</center>", gr = space(), mr = element("button"), mr.textContent = "Agree", vr = space(), yr = element("button"), yr.textContent = "Cancel", attr(mr, "class", "primary-btn svelte-6mkbgl"), attr(yr, "class", "primary-btn svelte-6mkbgl"), attr(cr, "class", "modal svelte-6mkbgl"), attr(ar, "class", "modal-overlay svelte-6mkbgl");
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, gr), append(cr, mr), append(cr, vr), append(cr, yr), xr = !0, Sr || (Er = [
        listen(mr, "click", function() {
          is_function(
            /*onAgree*/
            lr[0]
          ) && lr[0].apply(this, arguments);
        }),
        listen(yr, "click", function() {
          is_function(
            /*onCancel*/
            lr[1]
          ) && lr[1].apply(this, arguments);
        })
      ], Sr = !0);
    },
    p(Cr, [Tr]) {
      lr = Cr;
    },
    i(Cr) {
      xr || (Cr && add_render_callback(() => {
        xr && (kr || (kr = create_bidirectional_transition(cr, fly, { y: 300, duration: 500, delay: 0 }, !0)), kr.run(1));
      }), Cr && add_render_callback(() => {
        xr && (_r || (_r = create_bidirectional_transition(ar, fade, { duration: 1e3 }, !0)), _r.run(1));
      }), xr = !0);
    },
    o(Cr) {
      Cr && (kr || (kr = create_bidirectional_transition(cr, fly, { y: 300, duration: 500, delay: 0 }, !1)), kr.run(0)), Cr && (_r || (_r = create_bidirectional_transition(ar, fade, { duration: 1e3 }, !1)), _r.run(0)), xr = !1;
    },
    d(Cr) {
      Cr && detach(ar), Cr && kr && kr.end(), Cr && _r && _r.end(), Sr = !1, run_all(Er);
    }
  };
}
function instance$1(lr, ar, cr) {
  let { onAgree: ur = () => {
  } } = ar, { onCancel: fr = () => {
  } } = ar;
  return lr.$$set = (dr) => {
    "onAgree" in dr && cr(0, ur = dr.onAgree), "onCancel" in dr && cr(1, fr = dr.onCancel);
  }, [ur, fr];
}
class ConfirmationModal extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$1, create_fragment$1, safe_not_equal, { onAgree: 0, onCancel: 1 }, add_css$1);
  }
  get onAgree() {
    return this.$$.ctx[0];
  }
  set onAgree(ar) {
    this.$$set({ onAgree: ar }), flush();
  }
  get onCancel() {
    return this.$$.ctx[1];
  }
  set onCancel(ar) {
    this.$$set({ onCancel: ar }), flush();
  }
}
create_custom_element(ConfirmationModal, { onAgree: {}, onCancel: {} }, [], [], !0);
async function initializeApprovedAuthors() {
  const lr = (await Promise.resolve().then(() => main)).expertOpinions;
  let ar = [];
  ar = lr.trustedAuthors.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((mr) => mr != null);
  const cr = lr.trustedBadgeAuthors.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((mr) => mr != null), ur = lr.trustedBadges.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "naddr" && vr.data.kind == NDKKind.BadgeDefinition)
      return `${vr.data.kind}:${vr.data.pubkey}:${vr.data.identifier}`;
  }).filter((mr) => mr != null), fr = get_store_value(ndkStore);
  await fr.connect(), (await fr.fetchEvents({
    kinds: [NDKKind.BadgeDefinition],
    authors: cr
  })).forEach((mr) => {
    const vr = mr.tags.find((yr) => yr[0] == "d");
    vr && ur.push(`${mr.kind}:${mr.pubkey}:${vr[1]}`);
  });
  const gr = [];
  return (await fr.fetchEvents({
    kinds: [NDKKind.BadgeAward],
    "#a": ur
  })).forEach((mr) => {
    const vr = mr.tags.filter((yr) => yr[0] == "p");
    vr.length && vr.forEach((yr) => gr.push(yr[1]));
  }), ar.push(...gr), lr.trustedAuthors.push(...ar.map((mr) => nip19_exports.npubEncode(mr))), ar;
}
function add_css(lr) {
  append_styles(lr, "svelte-tyus1a", `:host{--border-color:#dedede;--content-text-color:#606060;--pubkey-text-color:#7c2323;--date-text-color:#808080;--description-text-color:#808080;--filter-active-color:#000000;--filter-inactive-color:#e2e1e1;--button-text-color:#ffffff;--button-background-color:#4da84d;--sentiment-button-background-color:#4da84d;font-family:Arial, sans-serif}.svelte-tyus1a.svelte-tyus1a::-webkit-scrollbar{display:none}.svelte-tyus1a.svelte-tyus1a{-ms-overflow-style:none;scrollbar-width:none}.expertOpinionsHeadline.svelte-tyus1a.svelte-tyus1a{font-family:'Barlow'}.top-nav.svelte-tyus1a.svelte-tyus1a{display:flex;justify-content:space-between;border-top:#dedede 1px solid;border-bottom:#dedede 1px solid;padding:20px 0}.nav-count.svelte-tyus1a.svelte-tyus1a{display:flex;align-items:center}.count-container.svelte-tyus1a.svelte-tyus1a{display:flex;flex-direction:row}.description.svelte-tyus1a.svelte-tyus1a{margin:10px 0}.blank-btn.svelte-tyus1a.svelte-tyus1a{background-color:transparent;border:none;cursor:pointer}.filter-container.svelte-tyus1a.svelte-tyus1a{display:flex;flex-direction:row}.filter-container.svelte-tyus1a>.filter-active.svelte-tyus1a{color:#4da84d}.filter-btn.svelte-tyus1a.svelte-tyus1a{color:#808080}.primary-btn.svelte-tyus1a.svelte-tyus1a{color:#ffffff;background-color:#4da84d;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}#review-input-details-container.svelte-tyus1a.svelte-tyus1a{display:flex;flex-direction:column;gap:0.5rem;font-family:Arial, sans-serif}.btn-standard.svelte-tyus1a.svelte-tyus1a{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;padding-right:1.5rem;display:flex;justify-content:center;align-items:center;color:#808080}.dark.svelte-tyus1a.svelte-tyus1a{background-color:#434343;color:white}.btn-standard.svelte-tyus1a.svelte-tyus1a:hover{background-color:#4da84d}.btn-standard.svelte-tyus1a.svelte-tyus1a:hover{color:#ffffff}#sentiment-box.svelte-tyus1a.svelte-tyus1a{display:flex;flex-direction:column;gap:0.3rem}.selected-state.svelte-tyus1a.svelte-tyus1a{background-color:#4da84d;color:#ffffff}.placeholder.svelte-tyus1a.svelte-tyus1a{display:flex;font-family:Arial, sans-serif;align-items:center;gap:0.5rem;margin-top:1rem;margin-bottom:1rem}#imageContainer.svelte-tyus1a.svelte-tyus1a{display:block;border-radius:50%;width:50px;height:50px;object-fit:cover}#filePreview.svelte-tyus1a.svelte-tyus1a{display:flex;gap:1rem;flex-direction:row;flex-wrap:wrap;margin:1rem 0}.unfilterWarning.svelte-tyus1a.svelte-tyus1a{padding:7px;font-family:"Barlow", Arial, Helvetica, sans-serif;color:#808080;font-size:1em}.unfilterWarning.svelte-tyus1a button.svelte-tyus1a{background-color:transparent;border:none;cursor:pointer;margin:none;color:#808080;font-family:"Barlow", Arial, Helvetica, sans-serif;font-size:1em;text-decoration:underline;text-decoration-thickness:0.5px}.opinion-container.svelte-tyus1a.svelte-tyus1a{max-height:200rem;overflow-y:scroll;margin:1rem 0}`);
}
function get_each_context(lr, ar, cr) {
  const ur = lr.slice();
  return ur[72] = ar[cr], ur;
}
function get_each_context_1(lr, ar, cr) {
  const ur = lr.slice();
  return ur[75] = ar[cr], ur;
}
function create_else_block(lr) {
  let ar, cr = (
    /*expertOpinions*/
    lr[7].headline.replace(
      "$$nAll$$",
      /*allEventLength*/
      lr[17].toString() || "0"
    ).replace(
      "$$nTrusted$$",
      /*filter*/
      lr[12] === "approved" ? (
        /*filteredEventLength*/
        lr[18].toString()
      ) : (
        /*allEventLength*/
        lr[17].toString()
      )
    ) + ""
  ), ur, fr, dr, gr = (
    /*expertOpinions*/
    lr[7].description + ""
  ), mr, vr, yr, kr, _r, xr, Sr, Er, Cr = (
    /*sentimentCount*/
    lr[11][1] + ""
  ), Tr, Ar, Ir, Mr, Hr, Br, zr = (
    /*sentimentCount*/
    lr[11][0] + ""
  ), Gr, Xr, Jr, li, Qr, ei, ui = (
    /*sentimentCount*/
    lr[11][-1] + ""
  ), Ai, fi, gi, Ci, mi, vi, Ri, di, Ti, qi, ki = [], Ji = /* @__PURE__ */ new Map(), Bi, Ni, Mi, bi = /*isMine*/ lr[16] ? "Edit" : "Add", Ei, Si, Vi, Di, sa, ra, fa, ba = (
    /*filteredEventLength*/
    lr[18] < 1 && /*allEventLength*/
    lr[17] >= 1 && /*filter*/
    lr[12] === "approved" && create_if_block_7(lr)
  );
  Sr = new Positive({}), Hr = new Neutral({}), Qr = new Negative({});
  let Ua = ensure_array_like(
    /*filteredEvents*/
    lr[2]
  );
  const Va = (Fi) => (
    /*event*/
    Fi[75].id
  );
  for (let Fi = 0; Fi < Ua.length; Fi += 1) {
    let na = get_each_context_1(lr, Ua, Fi), Gi = Va(na);
    Ji.set(Gi, ki[Fi] = create_each_block_1(Gi, na));
  }
  let Ma = (
    /*showNewOpinion*/
    lr[4] && create_if_block_2(lr)
  );
  return {
    c() {
      ar = element("h1"), ur = text$3(cr), fr = space(), dr = element("p"), mr = text$3(gr), vr = space(), ba && ba.c(), yr = space(), kr = element("nav"), _r = element("div"), xr = element("span"), create_component(Sr.$$.fragment), Er = space(), Tr = text$3(Cr), Ar = text$3(" positive"), Ir = space(), Mr = element("span"), create_component(Hr.$$.fragment), Br = space(), Gr = text$3(zr), Xr = text$3(" neutral"), Jr = space(), li = element("span"), create_component(Qr.$$.fragment), ei = space(), Ai = text$3(ui), fi = text$3(" negative"), gi = space(), Ci = element("div"), mi = element("button"), mi.textContent = "Approved", vi = space(), Ri = element("button"), Ri.textContent = "All opinions", Ti = space(), qi = element("div");
      for (let Fi = 0; Fi < ki.length; Fi += 1)
        ki[Fi].c();
      Ni = space(), Mi = element("button"), Ei = text$3(bi), Si = text$3(" your opinion"), Vi = space(), Ma && Ma.c(), Di = empty$1(), attr(ar, "class", "expertOpinionsHeadline svelte-tyus1a"), attr(dr, "class", "description svelte-tyus1a"), attr(xr, "class", "nav-count svelte-tyus1a"), attr(Mr, "class", "nav-count svelte-tyus1a"), attr(li, "class", "nav-count svelte-tyus1a"), attr(_r, "class", "count-container svelte-tyus1a"), attr(mi, "class", "blank-btn filter-btn svelte-tyus1a"), attr(mi, "aria-label", "filter by approved"), toggle_class(
        mi,
        "filter-active",
        /*filter*/
        lr[12] === "approved"
      ), attr(Ri, "class", "blank-btn filter-btn svelte-tyus1a"), attr(Ri, "aria-label", "filter by all"), toggle_class(
        Ri,
        "filter-active",
        /*filter*/
        lr[12] === "all"
      ), attr(Ci, "class", "filter-container svelte-tyus1a"), attr(kr, "class", "top-nav svelte-tyus1a"), attr(qi, "class", "opinion-container svelte-tyus1a"), attr(Mi, "class", "primary-btn svelte-tyus1a");
    },
    m(Fi, na) {
      insert(Fi, ar, na), append(ar, ur), insert(Fi, fr, na), insert(Fi, dr, na), append(dr, mr), insert(Fi, vr, na), ba && ba.m(Fi, na), insert(Fi, yr, na), insert(Fi, kr, na), append(kr, _r), append(_r, xr), mount_component(Sr, xr, null), append(xr, Er), append(xr, Tr), append(xr, Ar), append(_r, Ir), append(_r, Mr), mount_component(Hr, Mr, null), append(Mr, Br), append(Mr, Gr), append(Mr, Xr), append(_r, Jr), append(_r, li), mount_component(Qr, li, null), append(li, ei), append(li, Ai), append(li, fi), append(kr, gi), append(kr, Ci), append(Ci, mi), append(Ci, vi), append(Ci, Ri), insert(Fi, Ti, na), insert(Fi, qi, na);
      for (let Gi = 0; Gi < ki.length; Gi += 1)
        ki[Gi] && ki[Gi].m(qi, null);
      insert(Fi, Ni, na), insert(Fi, Mi, na), append(Mi, Ei), append(Mi, Si), insert(Fi, Vi, na), Ma && Ma.m(Fi, na), insert(Fi, Di, na), sa = !0, ra || (fa = [
        listen(
          mi,
          "click",
          /*click_handler*/
          lr[39]
        ),
        listen(
          Ri,
          "click",
          /*handleAgree*/
          lr[26]
        ),
        listen(
          Mi,
          "click",
          /*click_handler_1*/
          lr[46]
        )
      ], ra = !0);
    },
    p(Fi, na) {
      (!sa || na[0] & /*expertOpinions, allEventLength, filter, filteredEventLength*/
      397440) && cr !== (cr = /*expertOpinions*/
      Fi[7].headline.replace(
        "$$nAll$$",
        /*allEventLength*/
        Fi[17].toString() || "0"
      ).replace(
        "$$nTrusted$$",
        /*filter*/
        Fi[12] === "approved" ? (
          /*filteredEventLength*/
          Fi[18].toString()
        ) : (
          /*allEventLength*/
          Fi[17].toString()
        )
      ) + "") && set_data(ur, cr), (!sa || na[0] & /*expertOpinions*/
      128) && gr !== (gr = /*expertOpinions*/
      Fi[7].description + "") && set_data(mr, gr), /*filteredEventLength*/
      Fi[18] < 1 && /*allEventLength*/
      Fi[17] >= 1 && /*filter*/
      Fi[12] === "approved" ? ba ? ba.p(Fi, na) : (ba = create_if_block_7(Fi), ba.c(), ba.m(yr.parentNode, yr)) : ba && (ba.d(1), ba = null), (!sa || na[0] & /*sentimentCount*/
      2048) && Cr !== (Cr = /*sentimentCount*/
      Fi[11][1] + "") && set_data(Tr, Cr), (!sa || na[0] & /*sentimentCount*/
      2048) && zr !== (zr = /*sentimentCount*/
      Fi[11][0] + "") && set_data(Gr, zr), (!sa || na[0] & /*sentimentCount*/
      2048) && ui !== (ui = /*sentimentCount*/
      Fi[11][-1] + "") && set_data(Ai, ui), (!sa || na[0] & /*filter*/
      4096) && toggle_class(
        mi,
        "filter-active",
        /*filter*/
        Fi[12] === "approved"
      ), (!sa || na[0] & /*filter*/
      4096) && toggle_class(
        Ri,
        "filter-active",
        /*filter*/
        Fi[12] === "all"
      ), na[0] & /*filteredEvents, isUserOpinion, profiles, submit, subject, sentimentCount, opinionContent, newOpinion, count, deletedEventsArray, trustedAuthors*/
      12602159 && (Ua = ensure_array_like(
        /*filteredEvents*/
        Fi[2]
      ), group_outros(), ki = update_keyed_each(ki, na, Va, 1, Fi, Ua, Ji, qi, outro_and_destroy_block, create_each_block_1, null, get_each_context_1), check_outros()), (!sa || na[0] & /*isMine*/
      65536) && bi !== (bi = /*isMine*/
      Fi[16] ? "Edit" : "Add") && set_data(Ei, bi), /*showNewOpinion*/
      Fi[4] ? Ma ? (Ma.p(Fi, na), na[0] & /*showNewOpinion*/
      16 && transition_in(Ma, 1)) : (Ma = create_if_block_2(Fi), Ma.c(), transition_in(Ma, 1), Ma.m(Di.parentNode, Di)) : Ma && (group_outros(), transition_out(Ma, 1, 1, () => {
        Ma = null;
      }), check_outros());
    },
    i(Fi) {
      if (!sa) {
        transition_in(Sr.$$.fragment, Fi), transition_in(Hr.$$.fragment, Fi), transition_in(Qr.$$.fragment, Fi), Fi && add_render_callback(() => {
          sa && (di || (di = create_bidirectional_transition(kr, fade, {}, !0)), di.run(1));
        });
        for (let na = 0; na < Ua.length; na += 1)
          transition_in(ki[na]);
        Fi && add_render_callback(() => {
          sa && (Bi || (Bi = create_bidirectional_transition(qi, slide, {}, !0)), Bi.run(1));
        }), transition_in(Ma), sa = !0;
      }
    },
    o(Fi) {
      transition_out(Sr.$$.fragment, Fi), transition_out(Hr.$$.fragment, Fi), transition_out(Qr.$$.fragment, Fi), Fi && (di || (di = create_bidirectional_transition(kr, fade, {}, !1)), di.run(0));
      for (let na = 0; na < ki.length; na += 1)
        transition_out(ki[na]);
      Fi && (Bi || (Bi = create_bidirectional_transition(qi, slide, {}, !1)), Bi.run(0)), transition_out(Ma), sa = !1;
    },
    d(Fi) {
      Fi && (detach(ar), detach(fr), detach(dr), detach(vr), detach(yr), detach(kr), detach(Ti), detach(qi), detach(Ni), detach(Mi), detach(Vi), detach(Di)), ba && ba.d(Fi), destroy_component(Sr), destroy_component(Hr), destroy_component(Qr), Fi && di && di.end();
      for (let na = 0; na < ki.length; na += 1)
        ki[na].d();
      Fi && Bi && Bi.end(), Ma && Ma.d(Fi), ra = !1, run_all(fa);
    }
  };
}
function create_if_block_1(lr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "loading...", set_style(ar, "display", "flex"), set_style(ar, "justify-content", "center"), set_style(ar, "align-items", "center"), set_style(ar, "margin", "2rem 0"), attr(ar, "class", "svelte-tyus1a");
    },
    m(cr, ur) {
      insert(cr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(cr) {
      cr && detach(ar);
    }
  };
}
function create_if_block_7(lr) {
  let ar, cr, ur, fr, dr, gr = (
    /*allEventLength*/
    lr[17] === 1 ? " of an unknown author" : "s of unknown authors"
  ), mr, vr, yr, kr, _r;
  return {
    c() {
      ar = element("div"), cr = element("button"), ur = text$3("Show "), fr = text$3(
        /*allEventLength*/
        lr[17]
      ), dr = text$3(" opinion"), mr = text$3(gr), vr = text$3(`.
			`), yr = text$3("⚠️ Viewer discretion advised."), attr(cr, "aria-label", "filter by all"), attr(cr, "class", "svelte-tyus1a"), toggle_class(
        cr,
        "filter-active",
        /*filter*/
        lr[12] === "approved"
      ), attr(ar, "class", "unfilterWarning svelte-tyus1a");
    },
    m(xr, Sr) {
      insert(xr, ar, Sr), append(ar, cr), append(cr, ur), append(cr, fr), append(cr, dr), append(cr, mr), append(cr, vr), append(ar, yr), kr || (_r = listen(
        cr,
        "click",
        /*handleAgree*/
        lr[26]
      ), kr = !0);
    },
    p(xr, Sr) {
      Sr[0] & /*allEventLength*/
      131072 && set_data(
        fr,
        /*allEventLength*/
        xr[17]
      ), Sr[0] & /*allEventLength*/
      131072 && gr !== (gr = /*allEventLength*/
      xr[17] === 1 ? " of an unknown author" : "s of unknown authors") && set_data(mr, gr), Sr[0] & /*filter*/
      4096 && toggle_class(
        cr,
        "filter-active",
        /*filter*/
        xr[12] === "approved"
      );
    },
    d(xr) {
      xr && detach(ar), kr = !1, _r();
    }
  };
}
function create_if_block_6(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr;
  function yr(Tr) {
    lr[40](Tr);
  }
  function kr(Tr) {
    lr[41](Tr);
  }
  function _r(Tr) {
    lr[42](Tr);
  }
  function xr(Tr) {
    lr[43](Tr);
  }
  function Sr(Tr) {
    lr[44](Tr);
  }
  function Er(Tr) {
    lr[45](Tr);
  }
  let Cr = {
    event: (
      /*event*/
      lr[75]
    ),
    isMine: (
      /*isUserOpinion*/
      lr[22](
        /*event*/
        lr[75].pubkey
      )
    ),
    profiles: (
      /*profiles*/
      lr[3]
    ),
    submit: (
      /*submit*/
      lr[23]
    ),
    editLvl,
    subject: (
      /*subject*/
      lr[0]
    )
  };
  return (
    /*sentimentCount*/
    lr[11] !== void 0 && (Cr.sentimentCount = /*sentimentCount*/
    lr[11]), /*opinionContent*/
    lr[9] !== void 0 && (Cr.opinionContent = /*opinionContent*/
    lr[9]), /*newOpinion*/
    lr[8] !== void 0 && (Cr.newOpinion = /*newOpinion*/
    lr[8]), /*count*/
    lr[14] !== void 0 && (Cr.count = /*count*/
    lr[14]), /*deletedEventsArray*/
    lr[5] !== void 0 && (Cr.deletedEventsArray = /*deletedEventsArray*/
    lr[5]), /*trustedAuthors*/
    lr[1] !== void 0 && (Cr.trustedAuthors = /*trustedAuthors*/
    lr[1]), ar = new OpinionCard({ props: Cr }), binding_callbacks.push(() => bind(ar, "sentimentCount", yr)), binding_callbacks.push(() => bind(ar, "opinionContent", kr)), binding_callbacks.push(() => bind(ar, "newOpinion", _r)), binding_callbacks.push(() => bind(ar, "count", xr)), binding_callbacks.push(() => bind(ar, "deletedEventsArray", Sr)), binding_callbacks.push(() => bind(ar, "trustedAuthors", Er)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(Tr, Ar) {
        mount_component(ar, Tr, Ar), vr = !0;
      },
      p(Tr, Ar) {
        const Ir = {};
        Ar[0] & /*filteredEvents*/
        4 && (Ir.event = /*event*/
        Tr[75]), Ar[0] & /*filteredEvents*/
        4 && (Ir.isMine = /*isUserOpinion*/
        Tr[22](
          /*event*/
          Tr[75].pubkey
        )), Ar[0] & /*profiles*/
        8 && (Ir.profiles = /*profiles*/
        Tr[3]), Ar[0] & /*subject*/
        1 && (Ir.subject = /*subject*/
        Tr[0]), !cr && Ar[0] & /*sentimentCount*/
        2048 && (cr = !0, Ir.sentimentCount = /*sentimentCount*/
        Tr[11], add_flush_callback(() => cr = !1)), !ur && Ar[0] & /*opinionContent*/
        512 && (ur = !0, Ir.opinionContent = /*opinionContent*/
        Tr[9], add_flush_callback(() => ur = !1)), !fr && Ar[0] & /*newOpinion*/
        256 && (fr = !0, Ir.newOpinion = /*newOpinion*/
        Tr[8], add_flush_callback(() => fr = !1)), !dr && Ar[0] & /*count*/
        16384 && (dr = !0, Ir.count = /*count*/
        Tr[14], add_flush_callback(() => dr = !1)), !gr && Ar[0] & /*deletedEventsArray*/
        32 && (gr = !0, Ir.deletedEventsArray = /*deletedEventsArray*/
        Tr[5], add_flush_callback(() => gr = !1)), !mr && Ar[0] & /*trustedAuthors*/
        2 && (mr = !0, Ir.trustedAuthors = /*trustedAuthors*/
        Tr[1], add_flush_callback(() => mr = !1)), ar.$set(Ir);
      },
      i(Tr) {
        vr || (transition_in(ar.$$.fragment, Tr), vr = !0);
      },
      o(Tr) {
        transition_out(ar.$$.fragment, Tr), vr = !1;
      },
      d(Tr) {
        destroy_component(ar, Tr);
      }
    }
  );
}
function create_each_block_1(lr, ar) {
  let cr, ur = (
    /*deletedEventsArray*/
    ar[5].includes(
      /*event*/
      ar[75]
    ) === !1
  ), fr, dr, gr = ur && create_if_block_6(ar);
  return {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), gr && gr.c(), fr = empty$1(), this.first = cr;
    },
    m(mr, vr) {
      insert(mr, cr, vr), gr && gr.m(mr, vr), insert(mr, fr, vr), dr = !0;
    },
    p(mr, vr) {
      ar = mr, vr[0] & /*deletedEventsArray, filteredEvents*/
      36 && (ur = /*deletedEventsArray*/
      ar[5].includes(
        /*event*/
        ar[75]
      ) === !1), ur ? gr ? (gr.p(ar, vr), vr[0] & /*deletedEventsArray, filteredEvents*/
      36 && transition_in(gr, 1)) : (gr = create_if_block_6(ar), gr.c(), transition_in(gr, 1), gr.m(fr.parentNode, fr)) : gr && (group_outros(), transition_out(gr, 1, 1, () => {
        gr = null;
      }), check_outros());
    },
    i(mr) {
      dr || (transition_in(gr), dr = !0);
    },
    o(mr) {
      transition_out(gr), dr = !1;
    },
    d(mr) {
      mr && (detach(cr), detach(fr)), gr && gr.d(mr);
    }
  };
}
function create_if_block_2(lr) {
  let ar, cr, ur = /*isMine*/ lr[16] ? "Edit" : "Add", fr, dr, gr, mr, vr = purify.sanitize(
    /*expertOpinions*/
    lr[7].newOpinionDescription
  ) + "", yr, kr, _r, xr, Sr;
  const Er = [create_if_block_3, create_else_block_1], Cr = [];
  function Tr(Ar, Ir) {
    var Mr, Hr;
    return (
      /*$ndkUser*/
      (Mr = Ar[6]) != null && Mr.pubkey && /*profiles*/
      Ar[3][
        /*$ndkUser*/
        (Hr = Ar[6]) == null ? void 0 : Hr.pubkey
      ] ? 0 : 1
    );
  }
  return kr = Tr(lr), _r = Cr[kr] = Er[kr](lr), {
    c() {
      ar = element("div"), cr = element("h3"), fr = text$3(ur), dr = text$3(" your opinion"), gr = space(), mr = element("div"), yr = space(), _r.c(), attr(cr, "class", "svelte-tyus1a"), attr(mr, "class", "description svelte-tyus1a"), attr(ar, "class", "add-opinion-init svelte-tyus1a");
    },
    m(Ar, Ir) {
      insert(Ar, ar, Ir), append(ar, cr), append(cr, fr), append(cr, dr), append(ar, gr), append(ar, mr), mr.innerHTML = vr, append(ar, yr), Cr[kr].m(ar, null), Sr = !0;
    },
    p(Ar, Ir) {
      (!Sr || Ir[0] & /*isMine*/
      65536) && ur !== (ur = /*isMine*/
      Ar[16] ? "Edit" : "Add") && set_data(fr, ur), (!Sr || Ir[0] & /*expertOpinions*/
      128) && vr !== (vr = purify.sanitize(
        /*expertOpinions*/
        Ar[7].newOpinionDescription
      ) + "") && (mr.innerHTML = vr);
      let Mr = kr;
      kr = Tr(Ar), kr === Mr ? Cr[kr].p(Ar, Ir) : (group_outros(), transition_out(Cr[Mr], 1, 1, () => {
        Cr[Mr] = null;
      }), check_outros(), _r = Cr[kr], _r ? _r.p(Ar, Ir) : (_r = Cr[kr] = Er[kr](Ar), _r.c()), transition_in(_r, 1), _r.m(ar, null));
    },
    i(Ar) {
      Sr || (transition_in(_r), Ar && add_render_callback(() => {
        Sr && (xr || (xr = create_bidirectional_transition(ar, fade, {}, !0)), xr.run(1));
      }), Sr = !0);
    },
    o(Ar) {
      transition_out(_r), Ar && (xr || (xr = create_bidirectional_transition(ar, fade, {}, !1)), xr.run(0)), Sr = !1;
    },
    d(Ar) {
      Ar && detach(ar), Cr[kr].d(), Ar && xr && xr.end();
    }
  };
}
function create_else_block_1(lr) {
  let ar, cr, ur, fr, dr, gr, mr, vr, yr, kr, _r;
  const xr = [create_if_block_4, create_if_block_5], Sr = [];
  function Er(Cr, Tr) {
    return (
      /*showLoginOrRegister*/
      Cr[13] === "login" ? 0 : (
        /*showLoginOrRegister*/
        Cr[13] === "register" ? 1 : -1
      )
    );
  }
  return ~(gr = Er(lr)) && (mr = Sr[gr] = xr[gr](lr)), {
    c() {
      ar = element("div"), cr = element("button"), cr.textContent = "Log in", ur = space(), fr = element("button"), fr.textContent = "Register", dr = space(), mr && mr.c(), attr(cr, "class", "primary-btn svelte-tyus1a"), attr(fr, "class", "primary-btn svelte-tyus1a"), attr(ar, "class", "svelte-tyus1a");
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), append(ar, cr), append(ar, ur), append(ar, fr), append(ar, dr), ~gr && Sr[gr].m(ar, null), yr = !0, kr || (_r = [
        listen(
          cr,
          "click",
          /*click_handler_5*/
          lr[56]
        ),
        listen(
          fr,
          "click",
          /*click_handler_6*/
          lr[57]
        )
      ], kr = !0);
    },
    p(Cr, Tr) {
      let Ar = gr;
      gr = Er(Cr), gr === Ar ? ~gr && Sr[gr].p(Cr, Tr) : (mr && (group_outros(), transition_out(Sr[Ar], 1, 1, () => {
        Sr[Ar] = null;
      }), check_outros()), ~gr ? (mr = Sr[gr], mr ? mr.p(Cr, Tr) : (mr = Sr[gr] = xr[gr](Cr), mr.c()), transition_in(mr, 1), mr.m(ar, null)) : mr = null);
    },
    i(Cr) {
      yr || (transition_in(mr), Cr && add_render_callback(() => {
        yr && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !0)), vr.run(1));
      }), yr = !0);
    },
    o(Cr) {
      transition_out(mr), Cr && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !1)), vr.run(0)), yr = !1;
    },
    d(Cr) {
      Cr && detach(ar), ~gr && Sr[gr].d(), Cr && vr && vr.end(), kr = !1, run_all(_r);
    }
  };
}
function create_if_block_3(lr) {
  var Oa, Ja, za, Ia, Yi, La, Ka, Qa, Hi, da;
  let ar, cr, ur = (
    /*$ndkUser*/
    (((Oa = lr[6]) == null ? void 0 : Oa.npub) || "0") + ""
  ), fr, dr, gr, mr, vr, yr, kr, _r, xr, Sr, Er, Cr, Tr, Ar = (!/*profiles*/
  ((Ia = (za = lr[3][
    /*$ndkUser*/
    (Ja = lr[6]) == null ? void 0 : Ja.pubkey
  ]) == null ? void 0 : za.content) != null && Ia.name) || /*profiles*/
  ((Ka = (La = lr[3][
    /*$ndkUser*/
    (Yi = lr[6]) == null ? void 0 : Yi.pubkey
  ]) == null ? void 0 : La.content) == null ? void 0 : Ka.name) == "" ? (
    /*$ndkUser*/
    lr[6].npub.slice(0, 4) + "..." + /*$ndkUser*/
    lr[6].npub.slice(-4)
  ) : (
    /*profiles*/
    (da = (Hi = lr[3][
      /*$ndkUser*/
      (Qa = lr[6]) == null ? void 0 : Qa.pubkey
    ]) == null ? void 0 : Hi.content) == null ? void 0 : da.name
  )) + "", Ir, Mr, Hr, Br, zr, Gr, Xr, Jr, li, Qr, ei, ui, Ai, fi, gi, Ci, mi, vi, Ri, di, Ti, qi, ki, Ji, Bi, Ni, Mi, bi = [], Ei = /* @__PURE__ */ new Map(), Si, Vi, Di, sa, ra, fa, ba, Ua, Va, Ma, Fi, na;
  function Gi(aa) {
    lr[47](aa);
  }
  function Ca(aa) {
    lr[48](aa);
  }
  let $a = {};
  /*fileArray*/
  lr[15] !== void 0 && ($a.fileArray = /*fileArray*/
  lr[15]), /*opinionContent*/
  lr[9] !== void 0 && ($a.opinionContent = /*opinionContent*/
  lr[9]), Br = new Editor_1({ props: $a }), binding_callbacks.push(() => bind(Br, "fileArray", Gi)), binding_callbacks.push(() => bind(Br, "opinionContent", Ca)), Ai = new Positive({}), vi = new Neutral({}), ki = new Negative({});
  let no = ensure_array_like(
    /*fileArray*/
    lr[15]
  );
  const ga = (aa) => (
    /*file*/
    aa[72].url
  );
  for (let aa = 0; aa < no.length; aa += 1) {
    let oa = get_each_context(lr, no, aa), ja = ga(oa);
    Ei.set(ja, bi[aa] = create_each_block(ja, oa));
  }
  function pa(aa) {
    lr[53](aa);
  }
  function Sa(aa) {
    lr[54](aa);
  }
  let Na = {};
  return (
    /*fileArray*/
    lr[15] !== void 0 && (Na.fileArray = /*fileArray*/
    lr[15]), /*opinionContent*/
    lr[9] !== void 0 && (Na.opinionContent = /*opinionContent*/
    lr[9]), ba = new Upload({ props: Na }), binding_callbacks.push(() => bind(ba, "fileArray", pa)), binding_callbacks.push(() => bind(ba, "opinionContent", Sa)), {
      c() {
        var aa, oa, ja;
        ar = element("p"), cr = text$3("Logged in as "), fr = text$3(ur), dr = space(), gr = element("button"), gr.textContent = "Logout", mr = space(), vr = element("h3"), vr.textContent = "Share your opinion", yr = space(), kr = element("p"), kr.textContent = `We use Nostr to store opinions. You can post and access your posts via a unique private
					key.`, _r = space(), xr = element("div"), Sr = element("img"), Cr = space(), Tr = element("span"), Ir = text$3(Ar), Mr = space(), Hr = element("form"), create_component(Br.$$.fragment), Xr = space(), Jr = element("div"), li = element("label"), li.textContent = "Choose your overall sentiment", Qr = space(), ei = element("div"), ui = element("button"), create_component(Ai.$$.fragment), fi = space(), gi = element("span"), gi.textContent = "Positive", Ci = space(), mi = element("button"), create_component(vi.$$.fragment), Ri = space(), di = element("span"), di.textContent = "Neutral", Ti = space(), qi = element("button"), create_component(ki.$$.fragment), Ji = space(), Bi = element("span"), Bi.textContent = "Negative", Ni = space(), Mi = element("div");
        for (let Ga = 0; Ga < bi.length; Ga += 1)
          bi[Ga].c();
        Si = space(), Vi = element("div"), Di = element("button"), sa = text$3("Post"), fa = space(), create_component(ba.$$.fragment), attr(ar, "class", "svelte-tyus1a"), attr(gr, "class", "primary-btn svelte-tyus1a"), attr(vr, "class", "svelte-tyus1a"), attr(kr, "class", "description svelte-tyus1a"), set_style(kr, "margin-top", "-1rem"), attr(Sr, "id", "imageContainer"), src_url_equal(Sr.src, Er = /*profiles*/
        (ja = (oa = lr[3][
          /*$ndkUser*/
          (aa = lr[6]) == null ? void 0 : aa.pubkey
        ]) == null ? void 0 : oa.content) == null ? void 0 : ja.image) || attr(Sr, "src", Er), attr(Sr, "alt", "Miranda"), attr(Sr, "class", "svelte-tyus1a"), set_style(Tr, "font-size", "24px"), attr(Tr, "class", "svelte-tyus1a"), attr(xr, "class", "placeholder svelte-tyus1a"), attr(li, "for", "sentiment"), set_style(li, "font-weight", "600"), attr(li, "class", "svelte-tyus1a"), attr(gi, "class", "svelte-tyus1a"), attr(ui, "class", "btn-standard svelte-tyus1a"), toggle_class(
          ui,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          ui,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "1"
        ), attr(di, "class", "svelte-tyus1a"), attr(mi, "class", "btn-standard svelte-tyus1a"), toggle_class(
          mi,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          mi,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "0"
        ), attr(Bi, "class", "svelte-tyus1a"), attr(qi, "class", "btn-standard svelte-tyus1a"), toggle_class(
          qi,
          "dark",
          /*$theme*/
          lr[20] === "dark"
        ), toggle_class(
          qi,
          "selected-state",
          /*newOpinion*/
          lr[8].sentiment === "-1"
        ), set_style(ei, "display", "flex"), set_style(ei, "gap", "0.4rem"), attr(ei, "class", "svelte-tyus1a"), attr(Jr, "id", "sentiment-box"), attr(Jr, "class", "svelte-tyus1a"), attr(Mi, "id", "filePreview"), attr(Mi, "class", "svelte-tyus1a"), attr(Di, "class", "primary-btn svelte-tyus1a"), set_style(Di, "width", "5rem"), attr(Di, "type", "submit"), Di.disabled = ra = !/*$ndkUser*/
        lr[6], set_style(Vi, "display", "flex"), set_style(Vi, "align-contents", "center"), attr(Vi, "class", "svelte-tyus1a"), attr(Hr, "id", "review-input-details-container"), attr(Hr, "class", "svelte-tyus1a");
      },
      m(aa, oa) {
        insert(aa, ar, oa), append(ar, cr), append(ar, fr), insert(aa, dr, oa), insert(aa, gr, oa), insert(aa, mr, oa), insert(aa, vr, oa), insert(aa, yr, oa), insert(aa, kr, oa), insert(aa, _r, oa), insert(aa, xr, oa), append(xr, Sr), append(xr, Cr), append(xr, Tr), append(Tr, Ir), insert(aa, Mr, oa), insert(aa, Hr, oa), mount_component(Br, Hr, null), append(Hr, Xr), append(Hr, Jr), append(Jr, li), append(Jr, Qr), append(Jr, ei), append(ei, ui), mount_component(Ai, ui, null), append(ui, fi), append(ui, gi), append(ei, Ci), append(ei, mi), mount_component(vi, mi, null), append(mi, Ri), append(mi, di), append(ei, Ti), append(ei, qi), mount_component(ki, qi, null), append(qi, Ji), append(qi, Bi), append(Hr, Ni), append(Hr, Mi);
        for (let ja = 0; ja < bi.length; ja += 1)
          bi[ja] && bi[ja].m(Mi, null);
        append(Hr, Si), append(Hr, Vi), append(Vi, Di), append(Di, sa), append(Vi, fa), mount_component(ba, Vi, null), Ma = !0, Fi || (na = [
          listen(
            gr,
            "click",
            /*Logout*/
            lr[25]
          ),
          listen(ui, "click", prevent_default(
            /*click_handler_2*/
            lr[49]
          )),
          listen(mi, "click", prevent_default(
            /*click_handler_3*/
            lr[50]
          )),
          listen(qi, "click", prevent_default(
            /*click_handler_4*/
            lr[51]
          )),
          listen(Hr, "submit", prevent_default(
            /*submit_handler*/
            lr[55]
          ))
        ], Fi = !0);
      },
      p(aa, oa) {
        var xa, qa, Ya, Za, ko, lo, so, ho, Ro, Mo, Co, uo, wa;
        (!Ma || oa[0] & /*$ndkUser*/
        64) && ur !== (ur = /*$ndkUser*/
        (((xa = aa[6]) == null ? void 0 : xa.npub) || "0") + "") && set_data(fr, ur), (!Ma || oa[0] & /*profiles, $ndkUser*/
        72 && !src_url_equal(Sr.src, Er = /*profiles*/
        (Za = (Ya = aa[3][
          /*$ndkUser*/
          (qa = aa[6]) == null ? void 0 : qa.pubkey
        ]) == null ? void 0 : Ya.content) == null ? void 0 : Za.image)) && attr(Sr, "src", Er), (!Ma || oa[0] & /*profiles, $ndkUser*/
        72) && Ar !== (Ar = (!/*profiles*/
        ((so = (lo = aa[3][
          /*$ndkUser*/
          (ko = aa[6]) == null ? void 0 : ko.pubkey
        ]) == null ? void 0 : lo.content) != null && so.name) || /*profiles*/
        ((Mo = (Ro = aa[3][
          /*$ndkUser*/
          (ho = aa[6]) == null ? void 0 : ho.pubkey
        ]) == null ? void 0 : Ro.content) == null ? void 0 : Mo.name) == "" ? (
          /*$ndkUser*/
          aa[6].npub.slice(0, 4) + "..." + /*$ndkUser*/
          aa[6].npub.slice(-4)
        ) : (
          /*profiles*/
          (wa = (uo = aa[3][
            /*$ndkUser*/
            (Co = aa[6]) == null ? void 0 : Co.pubkey
          ]) == null ? void 0 : uo.content) == null ? void 0 : wa.name
        )) + "") && set_data(Ir, Ar);
        const ja = {};
        !zr && oa[0] & /*fileArray*/
        32768 && (zr = !0, ja.fileArray = /*fileArray*/
        aa[15], add_flush_callback(() => zr = !1)), !Gr && oa[0] & /*opinionContent*/
        512 && (Gr = !0, ja.opinionContent = /*opinionContent*/
        aa[9], add_flush_callback(() => Gr = !1)), Br.$set(ja), (!Ma || oa[0] & /*$theme*/
        1048576) && toggle_class(
          ui,
          "dark",
          /*$theme*/
          aa[20] === "dark"
        ), (!Ma || oa[0] & /*newOpinion*/
        256) && toggle_class(
          ui,
          "selected-state",
          /*newOpinion*/
          aa[8].sentiment === "1"
        ), (!Ma || oa[0] & /*$theme*/
        1048576) && toggle_class(
          mi,
          "dark",
          /*$theme*/
          aa[20] === "dark"
        ), (!Ma || oa[0] & /*newOpinion*/
        256) && toggle_class(
          mi,
          "selected-state",
          /*newOpinion*/
          aa[8].sentiment === "0"
        ), (!Ma || oa[0] & /*$theme*/
        1048576) && toggle_class(
          qi,
          "dark",
          /*$theme*/
          aa[20] === "dark"
        ), (!Ma || oa[0] & /*newOpinion*/
        256) && toggle_class(
          qi,
          "selected-state",
          /*newOpinion*/
          aa[8].sentiment === "-1"
        ), oa[0] & /*fileArray, deleteFile*/
        536903680 && (no = ensure_array_like(
          /*fileArray*/
          aa[15]
        ), group_outros(), bi = update_keyed_each(bi, oa, ga, 1, aa, no, Ei, Mi, outro_and_destroy_block, create_each_block, null, get_each_context), check_outros()), (!Ma || oa[0] & /*$ndkUser*/
        64 && ra !== (ra = !/*$ndkUser*/
        aa[6])) && (Di.disabled = ra);
        const Ga = {};
        !Ua && oa[0] & /*fileArray*/
        32768 && (Ua = !0, Ga.fileArray = /*fileArray*/
        aa[15], add_flush_callback(() => Ua = !1)), !Va && oa[0] & /*opinionContent*/
        512 && (Va = !0, Ga.opinionContent = /*opinionContent*/
        aa[9], add_flush_callback(() => Va = !1)), ba.$set(Ga);
      },
      i(aa) {
        if (!Ma) {
          transition_in(Br.$$.fragment, aa), transition_in(Ai.$$.fragment, aa), transition_in(vi.$$.fragment, aa), transition_in(ki.$$.fragment, aa);
          for (let oa = 0; oa < no.length; oa += 1)
            transition_in(bi[oa]);
          transition_in(ba.$$.fragment, aa), Ma = !0;
        }
      },
      o(aa) {
        transition_out(Br.$$.fragment, aa), transition_out(Ai.$$.fragment, aa), transition_out(vi.$$.fragment, aa), transition_out(ki.$$.fragment, aa);
        for (let oa = 0; oa < bi.length; oa += 1)
          transition_out(bi[oa]);
        transition_out(ba.$$.fragment, aa), Ma = !1;
      },
      d(aa) {
        aa && (detach(ar), detach(dr), detach(gr), detach(mr), detach(vr), detach(yr), detach(kr), detach(_r), detach(xr), detach(Mr), detach(Hr)), destroy_component(Br), destroy_component(Ai), destroy_component(vi), destroy_component(ki);
        for (let oa = 0; oa < bi.length; oa += 1)
          bi[oa].d();
        destroy_component(ba), Fi = !1, run_all(na);
      }
    }
  );
}
function create_if_block_5(lr) {
  let ar, cr, ur, fr;
  function dr(vr) {
    lr[61](vr);
  }
  function gr(vr) {
    lr[62](vr);
  }
  let mr = {};
  return (
    /*profiles*/
    lr[3] !== void 0 && (mr.profiles = /*profiles*/
    lr[3]), /*showNewOpinion*/
    lr[4] !== void 0 && (mr.showNewOpinion = /*showNewOpinion*/
    lr[4]), ar = new Register({ props: mr }), binding_callbacks.push(() => bind(ar, "profiles", dr)), binding_callbacks.push(() => bind(ar, "showNewOpinion", gr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, yr) {
        mount_component(ar, vr, yr), fr = !0;
      },
      p(vr, yr) {
        const kr = {};
        !cr && yr[0] & /*profiles*/
        8 && (cr = !0, kr.profiles = /*profiles*/
        vr[3], add_flush_callback(() => cr = !1)), !ur && yr[0] & /*showNewOpinion*/
        16 && (ur = !0, kr.showNewOpinion = /*showNewOpinion*/
        vr[4], add_flush_callback(() => ur = !1)), ar.$set(kr);
      },
      i(vr) {
        fr || (transition_in(ar.$$.fragment, vr), fr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), fr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_4(lr) {
  let ar, cr, ur, fr, dr;
  function gr(kr) {
    lr[58](kr);
  }
  function mr(kr) {
    lr[59](kr);
  }
  function vr(kr) {
    lr[60](kr);
  }
  let yr = { subject: (
    /*subject*/
    lr[0]
  ) };
  return (
    /*profiles*/
    lr[3] !== void 0 && (yr.profiles = /*profiles*/
    lr[3]), /*opinionContent*/
    lr[9] !== void 0 && (yr.opinionContent = /*opinionContent*/
    lr[9]), /*showNewOpinion*/
    lr[4] !== void 0 && (yr.showNewOpinion = /*showNewOpinion*/
    lr[4]), ar = new Login({ props: yr }), binding_callbacks.push(() => bind(ar, "profiles", gr)), binding_callbacks.push(() => bind(ar, "opinionContent", mr)), binding_callbacks.push(() => bind(ar, "showNewOpinion", vr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(kr, _r) {
        mount_component(ar, kr, _r), dr = !0;
      },
      p(kr, _r) {
        const xr = {};
        _r[0] & /*subject*/
        1 && (xr.subject = /*subject*/
        kr[0]), !cr && _r[0] & /*profiles*/
        8 && (cr = !0, xr.profiles = /*profiles*/
        kr[3], add_flush_callback(() => cr = !1)), !ur && _r[0] & /*opinionContent*/
        512 && (ur = !0, xr.opinionContent = /*opinionContent*/
        kr[9], add_flush_callback(() => ur = !1)), !fr && _r[0] & /*showNewOpinion*/
        16 && (fr = !0, xr.showNewOpinion = /*showNewOpinion*/
        kr[4], add_flush_callback(() => fr = !1)), ar.$set(xr);
      },
      i(kr) {
        dr || (transition_in(ar.$$.fragment, kr), dr = !0);
      },
      o(kr) {
        transition_out(ar.$$.fragment, kr), dr = !1;
      },
      d(kr) {
        destroy_component(ar, kr);
      }
    }
  );
}
function create_each_block(lr, ar) {
  let cr, ur, fr;
  function dr() {
    return (
      /*func*/
      ar[52](
        /*file*/
        ar[72]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[72].files
      ),
      onDelete: dr
    }
  }), {
    key: lr,
    first: null,
    c() {
      cr = empty$1(), create_component(ur.$$.fragment), this.first = cr;
    },
    m(gr, mr) {
      insert(gr, cr, mr), mount_component(ur, gr, mr), fr = !0;
    },
    p(gr, mr) {
      ar = gr;
      const vr = {};
      mr[0] & /*fileArray*/
      32768 && (vr.file = /*file*/
      ar[72].files), mr[0] & /*fileArray*/
      32768 && (vr.onDelete = dr), ur.$set(vr);
    },
    i(gr) {
      fr || (transition_in(ur.$$.fragment, gr), fr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), fr = !1;
    },
    d(gr) {
      gr && detach(cr), destroy_component(ur, gr);
    }
  };
}
function create_if_block(lr) {
  let ar, cr;
  return ar = new ConfirmationModal({
    props: {
      onAgree: (
        /*agreeToShowAll*/
        lr[27]
      ),
      onCancel: (
        /*onCancel*/
        lr[28]
      )
    }
  }), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, fr) {
      mount_component(ar, ur, fr), cr = !0;
    },
    p: noop$1,
    i(ur) {
      cr || (transition_in(ar.$$.fragment, ur), cr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), cr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_fragment(lr) {
  let ar, cr, ur, fr, dr;
  const gr = [create_if_block_1, create_else_block], mr = [];
  function vr(kr, _r) {
    return (
      /*loading*/
      kr[10] ? 0 : 1
    );
  }
  ar = vr(lr), cr = mr[ar] = gr[ar](lr);
  let yr = (
    /*showModal*/
    lr[19] && create_if_block(lr)
  );
  return {
    c() {
      cr.c(), ur = space(), yr && yr.c(), fr = empty$1();
    },
    m(kr, _r) {
      mr[ar].m(kr, _r), insert(kr, ur, _r), yr && yr.m(kr, _r), insert(kr, fr, _r), dr = !0;
    },
    p(kr, _r) {
      let xr = ar;
      ar = vr(kr), ar === xr ? mr[ar].p(kr, _r) : (group_outros(), transition_out(mr[xr], 1, 1, () => {
        mr[xr] = null;
      }), check_outros(), cr = mr[ar], cr ? cr.p(kr, _r) : (cr = mr[ar] = gr[ar](kr), cr.c()), transition_in(cr, 1), cr.m(ur.parentNode, ur)), /*showModal*/
      kr[19] ? yr ? (yr.p(kr, _r), _r[0] & /*showModal*/
      524288 && transition_in(yr, 1)) : (yr = create_if_block(kr), yr.c(), transition_in(yr, 1), yr.m(fr.parentNode, fr)) : yr && (group_outros(), transition_out(yr, 1, 1, () => {
        yr = null;
      }), check_outros());
    },
    i(kr) {
      dr || (transition_in(cr), transition_in(yr), dr = !0);
    },
    o(kr) {
      transition_out(cr), transition_out(yr), dr = !1;
    },
    d(kr) {
      kr && (detach(ur), detach(fr)), mr[ar].d(kr), yr && yr.d(kr);
    }
  };
}
let editLvl = 0;
function instance(lr, ar, cr) {
  let ur, fr, dr, gr, mr;
  component_subscribe(lr, ndkStore, (Hi) => cr(65, ur = Hi)), component_subscribe(lr, ndkUser, (Hi) => cr(6, fr = Hi)), component_subscribe(lr, localStore, (Hi) => cr(66, dr = Hi)), component_subscribe(lr, theme, (Hi) => cr(20, mr = Hi));
  let { subject: vr } = ar, { opinionTitle: yr } = ar, { opinionHeader: kr = yr } = ar, { opinionFooter: _r = void 0 } = ar, { opinionImage: xr = void 0 } = ar, { opinionTags: Sr = "NostrOpinion" } = ar, { summary: Er = `An opinion made about ${vr} generated using nostr-opinion-plugin.` } = ar, { themeModeLocalStorageHandle: Cr = "colour-scheme" } = ar, Tr = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), Ar, Ir = [], Mr = [], Hr = [], Br = {}, zr = { content: "", sentiment: "0" }, Gr = "", Xr = !0, Jr = { "-1": 0, 0: 0, 1: 0 }, li = "approved", Qr = !1, ei = !1, ui = 0, Ai = [], fi = [], gi = !1, Ci = 0, mi = 0, vi = !1, Ri = { kinds: [kindOpinion], "#d": [vr] };
  const di = ur.storeSubscribe(Ri, { closeOnEose: !1 });
  component_subscribe(lr, di, (Hi) => cr(38, gr = Hi));
  function Ti(Hi) {
    return fr ? fr && Hi === fr.pubkey : !1;
  }
  const qi = setInterval(
    () => {
      theme.set(localStorage.getItem(Cr) || "light");
    },
    1e3
  );
  onDestroy(() => {
    clearInterval(qi);
  });
  const ki = async (Hi) => {
    var Ga;
    const da = dr.pk;
    if (console.log("Published_at "), console.log(Hi), da ? !ur.signer && await privkeyLogin(da) : !ur.signer && await NDKlogin(), !Gr || !ur.signer)
      return;
    cr(
      8,
      zr.content = kr ? kr + opinionHeaderSeparator : "",
      zr
    ), cr(8, zr.content += Gr + opinionFooterSeparator, zr);
    const aa = (Ga = await ur.fetchEvent({
      kinds: [kindOpinion],
      authors: [fr.pubkey]
    })) == null ? void 0 : Ga.tags;
    (aa == null ? void 0 : aa.length) === 3 && aa[2][1] && (Hi = aa[2][1]);
    const oa = new NDKEvent(ur);
    oa.kind = kindOpinion, (!Hi || !Hi.length || Hi.length === 1) && (Hi = (Date.now() + 5e3).toString()), oa.tags = [
      ["d", vr],
      ["sentiment", zr.sentiment],
      ["summary", Er],
      ["published_at", Hi]
    ], yr && oa.tags.push(["title", yr]), xr && oa.tags.push(["image", xr]), Sr.split(",").map((xa) => {
      xa == "" || !xa || (oa.tags.push(["t", xa]), cr(8, zr.content += `#${xa} `, zr));
    }), _r && cr(8, zr.content += `

` + _r, zr), oa.content = zr.content, oa.publish(NDKRelaySet.fromRelayUrls(Tr.write, ur)).then(() => {
      const xa = Mr.findIndex((qa) => qa.pubkey === oa.pubkey);
      xa !== -1 ? cr(37, Mr[xa] = { ...oa }, Mr) : cr(37, Mr = [{ ...oa }, ...Mr]), Ji();
    });
    let ja = fi.filter((xa) => xa.pubkey != (fr == null ? void 0 : fr.pubkey));
    cr(5, fi = [...ja]), cr(16, gi = !0), cr(4, Qr = !1);
  }, Ji = () => {
    cr(11, Jr = { "-1": 0, 0: 0, 1: 0 }), cr(2, Hr = Mr.filter((Hi) => {
      var aa;
      if (li === "approved" && !Ir.includes(Hi.pubkey))
        return !1;
      const da = (aa = Hi.tags.find((oa) => oa[0] === "sentiment")) == null ? void 0 : aa[1];
      return da && !fi.includes(Hi) && cr(11, Jr[da] += 1, Jr), !0;
    })), cr(2, Hr = Hr.sort((Hi, da) => {
      const aa = Ir.includes(Hi.pubkey), oa = Ir.includes(da.pubkey);
      if (aa && !oa)
        return -1;
      if (!aa && oa)
        return 1;
      let ja = (Hi == null ? void 0 : Hi.created_at) || 0, Ga = (da == null ? void 0 : da.created_at) || 0;
      return ja > Ga ? -1 : ja < Ga ? 1 : 0;
    }));
  };
  async function Bi(Hi) {
    if (!fr) {
      console.log("Can't find user profile. $ndkUser is undefined");
      return;
    }
    let da = await fetchUserProfile(Hi);
    return da || (da = {
      image: profileImageUrl + fr.pubkey,
      pubkey: fr.pubkey
    }), da.image || (da.image = profileImageUrl + Hi), da.pubkey || (da.pubkey = Hi), { content: da };
  }
  (async () => {
    cr(7, Ar = (await Promise.resolve().then(() => main)).expertOpinions), themeModeLocalStorageObject.set(Cr);
    try {
      cr(1, Ir = await initializeApprovedAuthors());
      const Hi = dr.lastUserLogged;
      if (cr(10, Xr = !1), Hi && window) {
        let da = ur.getUser({ npub: Hi });
        sa();
        let aa = await ur.fetchEvent({ kinds: [10002], authors: [da.pubkey] });
        aa && aa.getMatchingTags("r").map((oa) => {
          Tr.read.includes(oa[1]) || (oa.length === 3 ? oa[2] === "write" && !Tr.write.includes(oa[1]) ? Tr.write.push(oa[1]) : oa[2] === "read" && !Tr.read.includes(oa[1]) && Tr.read.push(oa[1]) : oa.length === 2 && (Tr.write.includes(oa[1]) || Tr.write.push(oa[1]), Tr.read.includes(oa[1]) || Tr.read.push(oa[1])));
        }), ndkUser.set(da), fr && cr(3, Br[fr.pubkey] = await Bi(fr.pubkey), Br), Mr.map((oa) => {
          oa.pubkey === (fr == null ? void 0 : fr.pubkey) && cr(16, gi = !0);
        });
      }
    } catch (Hi) {
      console.log(Hi);
    }
  })();
  let Mi = !1;
  const bi = () => {
    console.log(DEFAULT_RELAY_URLS), console.log(Tr), Tr = JSON.parse(JSON.stringify(DEFAULT_RELAY_URLS)), console.log(Tr), cr(16, gi = !1), logout(), cr(9, Gr = "");
  };
  localStorage.getItem("userHasAgreed") === null && localStorage.setItem("userHasAgreed", "false");
  function Ei() {
    Mi ? (cr(12, li = "all"), Ji(), cr(4, Qr = !1)) : cr(19, vi = !0);
  }
  function Si() {
    if (cr(12, li = "all"), Ji(), cr(4, Qr = !1), cr(19, vi = !1), Mi = !0, fr != null && fr.pubkey) {
      const Hi = `userHasAgreed_${fr.pubkey}`;
      localStorage.setItem(Hi, Mi.toString());
    }
  }
  function Vi() {
    cr(19, vi = !1);
  }
  function Di(Hi) {
    const da = Ai.filter((aa) => aa === Hi)[0].url;
    cr(9, Gr = Gr.replace(da, "")), cr(9, Gr = Gr.replace("![]()", "")), cr(9, Gr = Gr.replace("![image]()", "")), cr(15, Ai = Ai.filter((aa) => aa !== Hi));
  }
  const sa = async () => {
    if (fr) {
      let Hi = {
        kinds: [kindOpinion],
        "#d": [vr],
        authors: [fr.pubkey]
      };
      const da = await ur.fetchEvent(Hi);
      let aa = {
        kinds: [kindDelete],
        "#a": [`${kindOpinion}:${fr.pubkey}:${vr}`],
        authors: [fr.pubkey]
      };
      const oa = await ur.fetchEvent(aa);
      if ((oa == null ? void 0 : oa.created_at) < (da == null ? void 0 : da.created_at) || !oa && da) {
        cr(16, gi = !0);
        let ja = (da == null ? void 0 : da.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")) || "";
        const Ga = (da == null ? void 0 : da.tagValue("sentiment")) || "0";
        cr(8, zr = { content: ja, sentiment: Ga }), cr(9, Gr = ja);
      } else
        Qr && (cr(16, gi = !1), cr(8, zr = { content: "", sentiment: "0" }), cr(9, Gr = ""));
    }
  }, ra = () => {
    cr(12, li = "approved"), Ji(), cr(4, Qr = !1);
  };
  function fa(Hi) {
    Jr = Hi, cr(11, Jr);
  }
  function ba(Hi) {
    Gr = Hi, cr(9, Gr);
  }
  function Ua(Hi) {
    zr = Hi, cr(8, zr);
  }
  function Va(Hi) {
    ui = Hi, cr(14, ui);
  }
  function Ma(Hi) {
    fi = Hi, cr(5, fi);
  }
  function Fi(Hi) {
    Ir = Hi, cr(1, Ir);
  }
  const na = () => cr(4, Qr = !Qr);
  function Gi(Hi) {
    Ai = Hi, cr(15, Ai);
  }
  function Ca(Hi) {
    Gr = Hi, cr(9, Gr);
  }
  const $a = () => {
    cr(8, zr = { ...zr, sentiment: "1" });
  }, no = () => {
    cr(8, zr = { ...zr, sentiment: "0" });
  }, ga = () => {
    cr(8, zr = { ...zr, sentiment: "-1" });
  }, pa = (Hi) => Di(Hi);
  function Sa(Hi) {
    Ai = Hi, cr(15, Ai);
  }
  function Na(Hi) {
    Gr = Hi, cr(9, Gr);
  }
  const Oa = () => {
    ki(" ");
  }, Ja = () => cr(13, ei = "login"), za = () => cr(13, ei = "register");
  function Ia(Hi) {
    Br = Hi, cr(3, Br), cr(38, gr), cr(37, Mr);
  }
  function Yi(Hi) {
    Gr = Hi, cr(9, Gr);
  }
  function La(Hi) {
    Qr = Hi, cr(4, Qr);
  }
  function Ka(Hi) {
    Br = Hi, cr(3, Br), cr(38, gr), cr(37, Mr);
  }
  function Qa(Hi) {
    Qr = Hi, cr(4, Qr);
  }
  return lr.$$set = (Hi) => {
    "subject" in Hi && cr(0, vr = Hi.subject), "opinionTitle" in Hi && cr(30, yr = Hi.opinionTitle), "opinionHeader" in Hi && cr(31, kr = Hi.opinionHeader), "opinionFooter" in Hi && cr(32, _r = Hi.opinionFooter), "opinionImage" in Hi && cr(33, xr = Hi.opinionImage), "opinionTags" in Hi && cr(34, Sr = Hi.opinionTags), "summary" in Hi && cr(35, Er = Hi.summary), "themeModeLocalStorageHandle" in Hi && cr(36, Cr = Hi.themeModeLocalStorageHandle);
  }, lr.$$.update = () => {
    if (lr.$$.dirty[0] & /*trustedAuthors*/
    2 && Ir && Ji(), lr.$$.dirty[0] & /*showNewOpinion*/
    16 && sa(), lr.$$.dirty[1] & /*$sub, allEvents*/
    192 && gr.forEach(async (Hi) => {
      Mr.filter((aa) => aa.pubkey === Hi.pubkey).length ? cr(37, Mr = Mr.map((aa) => aa.pubkey === Hi.pubkey ? Hi : aa)) : (cr(37, Mr = [...Mr, { ...Hi }]), cr(3, Br[Hi.pubkey] = await Bi(Hi.pubkey), Br)), Ji();
    }), lr.$$.dirty[0] & /*deletedEventsArray, filteredEvents*/
    36 | lr.$$.dirty[1] & /*allEvents*/
    64 && (cr(17, Ci = Mr.filter((Hi) => !fi.includes(Hi)).length), cr(18, mi = Hr.filter((Hi) => !fi.includes(Hi)).length)), lr.$$.dirty[0] & /*$ndkUser, profiles*/
    72)
      if (fr != null && fr.pubkey && Br[fr == null ? void 0 : fr.pubkey]) {
        const Hi = `userHasAgreed_${fr.pubkey}`;
        Mi = localStorage.getItem(Hi) === "true";
      } else
        Mi = !1;
  }, [
    vr,
    Ir,
    Hr,
    Br,
    Qr,
    fi,
    fr,
    Ar,
    zr,
    Gr,
    Xr,
    Jr,
    li,
    ei,
    ui,
    Ai,
    gi,
    Ci,
    mi,
    vi,
    mr,
    di,
    Ti,
    ki,
    Ji,
    bi,
    Ei,
    Si,
    Vi,
    Di,
    yr,
    kr,
    _r,
    xr,
    Sr,
    Er,
    Cr,
    Mr,
    gr,
    ra,
    fa,
    ba,
    Ua,
    Va,
    Ma,
    Fi,
    na,
    Gi,
    Ca,
    $a,
    no,
    ga,
    pa,
    Sa,
    Na,
    Oa,
    Ja,
    za,
    Ia,
    Yi,
    La,
    Ka,
    Qa
  ];
}
class App extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance,
      create_fragment,
      safe_not_equal,
      {
        subject: 0,
        opinionTitle: 30,
        opinionHeader: 31,
        opinionFooter: 32,
        opinionImage: 33,
        opinionTags: 34,
        summary: 35,
        themeModeLocalStorageHandle: 36
      },
      add_css,
      [-1, -1, -1]
    );
  }
  get subject() {
    return this.$$.ctx[0];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get opinionTitle() {
    return this.$$.ctx[30];
  }
  set opinionTitle(ar) {
    this.$$set({ opinionTitle: ar }), flush();
  }
  get opinionHeader() {
    return this.$$.ctx[31];
  }
  set opinionHeader(ar) {
    this.$$set({ opinionHeader: ar }), flush();
  }
  get opinionFooter() {
    return this.$$.ctx[32];
  }
  set opinionFooter(ar) {
    this.$$set({ opinionFooter: ar }), flush();
  }
  get opinionImage() {
    return this.$$.ctx[33];
  }
  set opinionImage(ar) {
    this.$$set({ opinionImage: ar }), flush();
  }
  get opinionTags() {
    return this.$$.ctx[34];
  }
  set opinionTags(ar) {
    this.$$set({ opinionTags: ar }), flush();
  }
  get summary() {
    return this.$$.ctx[35];
  }
  set summary(ar) {
    this.$$set({ summary: ar }), flush();
  }
  get themeModeLocalStorageHandle() {
    return this.$$.ctx[36];
  }
  set themeModeLocalStorageHandle(ar) {
    this.$$set({ themeModeLocalStorageHandle: ar }), flush();
  }
}
customElements.define("nostr-opinion", create_custom_element(App, { subject: {}, opinionTitle: {}, opinionHeader: {}, opinionFooter: {}, opinionImage: {}, opinionTags: {}, summary: {}, themeModeLocalStorageHandle: {} }, [], [], !0));
class ExpertOpinions {
  constructor() {
    ji(this, "headline", "Community Opinions ($$nTrusted$$/$$nAll$$)");
    ji(this, "description", "These comments are contributed by nostr users using the nostr-opinions-plugin.");
    ji(this, "newOpinionDescription", `<p>
	Thank you for contributing your opinion. Please make sure to follow these
	simple guidelines:
</p>
<ul>
	<li>Be objective</li>
	<li>Be polite</li>
</ul>`);
    ji(this, "trustedAuthors", []);
    ji(this, "trustedBadgeAuthors", []);
    ji(this, "trustedBadges", []);
  }
}
const expertOpinions = new ExpertOpinions(), main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  expertOpinions
}, Symbol.toStringTag, { value: "Module" }));
export {
  expertOpinions
};
