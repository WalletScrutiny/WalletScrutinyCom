var Go = Object.defineProperty;
var Zo = (cr, ar, lr) => ar in cr ? Go(cr, ar, { enumerable: !0, configurable: !0, writable: !0, value: lr }) : cr[ar] = lr;
var ti = (cr, ar, lr) => (Zo(cr, typeof ar != "symbol" ? ar + "" : ar, lr), lr), Ho = (cr, ar, lr) => {
  if (!ar.has(cr))
    throw TypeError("Cannot " + lr);
};
var Ki = (cr, ar, lr) => (Ho(cr, ar, "read from private field"), lr ? lr.call(cr) : ar.get(cr)), mo = (cr, ar, lr) => {
  if (ar.has(cr))
    throw TypeError("Cannot add the same private member more than once");
  ar instanceof WeakSet ? ar.add(cr) : ar.set(cr, lr);
}, xo = (cr, ar, lr, ur) => (Ho(cr, ar, "write to private field"), ur ? ur.call(cr, lr) : ar.set(cr, lr), lr);
var no = (cr, ar, lr) => (Ho(cr, ar, "access private method"), lr);
function noop$1() {
}
const identity = (cr) => cr;
function assign$1(cr, ar) {
  for (const lr in ar)
    cr[lr] = ar[lr];
  return (
    /** @type {T & S} */
    cr
  );
}
function run$2(cr) {
  return cr();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(cr) {
  cr.forEach(run$2);
}
function is_function(cr) {
  return typeof cr == "function";
}
function safe_not_equal(cr, ar) {
  return cr != cr ? ar == ar : cr !== ar || cr && typeof cr == "object" || typeof cr == "function";
}
let src_url_equal_anchor;
function src_url_equal(cr, ar) {
  return cr === ar ? !0 : (src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = ar, cr === src_url_equal_anchor.href);
}
function is_empty(cr) {
  return Object.keys(cr).length === 0;
}
function subscribe(cr, ...ar) {
  if (cr == null) {
    for (const ur of ar)
      ur(void 0);
    return noop$1;
  }
  const lr = cr.subscribe(...ar);
  return lr.unsubscribe ? () => lr.unsubscribe() : lr;
}
function get_store_value(cr) {
  let ar;
  return subscribe(cr, (lr) => ar = lr)(), ar;
}
function component_subscribe(cr, ar, lr) {
  cr.$$.on_destroy.push(subscribe(ar, lr));
}
function create_slot(cr, ar, lr, ur) {
  if (cr) {
    const dr = get_slot_context(cr, ar, lr, ur);
    return cr[0](dr);
  }
}
function get_slot_context(cr, ar, lr, ur) {
  return cr[1] && ur ? assign$1(lr.ctx.slice(), cr[1](ur(ar))) : lr.ctx;
}
function get_slot_changes(cr, ar, lr, ur) {
  if (cr[2] && ur) {
    const dr = cr[2](ur(lr));
    if (ar.dirty === void 0)
      return dr;
    if (typeof dr == "object") {
      const fr = [], gr = Math.max(ar.dirty.length, dr.length);
      for (let mr = 0; mr < gr; mr += 1)
        fr[mr] = ar.dirty[mr] | dr[mr];
      return fr;
    }
    return ar.dirty | dr;
  }
  return ar.dirty;
}
function update_slot_base(cr, ar, lr, ur, dr, fr) {
  if (dr) {
    const gr = get_slot_context(ar, lr, ur, fr);
    cr.p(gr, dr);
  }
}
function get_all_dirty_from_scope(cr) {
  if (cr.ctx.length > 32) {
    const ar = [], lr = cr.ctx.length / 32;
    for (let ur = 0; ur < lr; ur++)
      ar[ur] = -1;
    return ar;
  }
  return -1;
}
function exclude_internal_props(cr) {
  const ar = {};
  for (const lr in cr)
    lr[0] !== "$" && (ar[lr] = cr[lr]);
  return ar;
}
function compute_rest_props(cr, ar) {
  const lr = {};
  ar = new Set(ar);
  for (const ur in cr)
    !ar.has(ur) && ur[0] !== "$" && (lr[ur] = cr[ur]);
  return lr;
}
function compute_slots(cr) {
  const ar = {};
  for (const lr in cr)
    ar[lr] = !0;
  return ar;
}
function set_store_value(cr, ar, lr) {
  return cr.set(lr), ar;
}
function action_destroyer(cr) {
  return cr && is_function(cr.destroy) ? cr.destroy : noop$1;
}
function split_css_unit(cr) {
  const ar = typeof cr == "string" && cr.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return ar ? [parseFloat(ar[1]), ar[2] || "px"] : [
    /** @type {number} */
    cr,
    "px"
  ];
}
const is_client = typeof window != "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (cr) => requestAnimationFrame(cr) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(cr) {
  tasks.forEach((ar) => {
    ar.c(cr) || (tasks.delete(ar), ar.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(cr) {
  let ar;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((lr) => {
      tasks.add(ar = { c: cr, f: lr });
    }),
    abort() {
      tasks.delete(ar);
    }
  };
}
const globals = typeof window != "undefined" ? window : typeof globalThis != "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function append(cr, ar) {
  cr.appendChild(ar);
}
function append_styles(cr, ar, lr) {
  const ur = get_root_for_style(cr);
  if (!ur.getElementById(ar)) {
    const dr = element("style");
    dr.id = ar, dr.textContent = lr, append_stylesheet(ur, dr);
  }
}
function get_root_for_style(cr) {
  if (!cr)
    return document;
  const ar = cr.getRootNode ? cr.getRootNode() : cr.ownerDocument;
  return ar && /** @type {ShadowRoot} */
  ar.host ? (
    /** @type {ShadowRoot} */
    ar
  ) : cr.ownerDocument;
}
function append_empty_stylesheet(cr) {
  const ar = element("style");
  return ar.textContent = "/* empty */", append_stylesheet(get_root_for_style(cr), ar), ar.sheet;
}
function append_stylesheet(cr, ar) {
  return append(
    /** @type {Document} */
    cr.head || cr,
    ar
  ), ar.sheet;
}
function insert(cr, ar, lr) {
  cr.insertBefore(ar, lr || null);
}
function detach(cr) {
  cr.parentNode && cr.parentNode.removeChild(cr);
}
function destroy_each(cr, ar) {
  for (let lr = 0; lr < cr.length; lr += 1)
    cr[lr] && cr[lr].d(ar);
}
function element(cr) {
  return document.createElement(cr);
}
function svg_element(cr) {
  return document.createElementNS("http://www.w3.org/2000/svg", cr);
}
function text$3(cr) {
  return document.createTextNode(cr);
}
function space() {
  return text$3(" ");
}
function empty$2() {
  return text$3("");
}
function listen(cr, ar, lr, ur) {
  return cr.addEventListener(ar, lr, ur), () => cr.removeEventListener(ar, lr, ur);
}
function prevent_default(cr) {
  return function(ar) {
    return ar.preventDefault(), cr.call(this, ar);
  };
}
function attr(cr, ar, lr) {
  lr == null ? cr.removeAttribute(ar) : cr.getAttribute(ar) !== lr && cr.setAttribute(ar, lr);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(cr, ar) {
  const lr = Object.getOwnPropertyDescriptors(cr.__proto__);
  for (const ur in ar)
    ar[ur] == null ? cr.removeAttribute(ur) : ur === "style" ? cr.style.cssText = ar[ur] : ur === "__value" ? cr.value = cr[ur] = ar[ur] : lr[ur] && lr[ur].set && always_set_through_set_attribute.indexOf(ur) === -1 ? cr[ur] = ar[ur] : attr(cr, ur, ar[ur]);
}
function init_binding_group(cr) {
  let ar;
  return {
    /* push */
    p(...lr) {
      ar = lr, ar.forEach((ur) => cr.push(ur));
    },
    /* remove */
    r() {
      ar.forEach((lr) => cr.splice(cr.indexOf(lr), 1));
    }
  };
}
function to_number(cr) {
  return cr === "" ? null : +cr;
}
function children(cr) {
  return Array.from(cr.childNodes);
}
function set_data(cr, ar) {
  ar = "" + ar, cr.data !== ar && (cr.data = /** @type {string} */
  ar);
}
function set_input_value(cr, ar) {
  cr.value = ar == null ? "" : ar;
}
function set_style(cr, ar, lr, ur) {
  lr == null ? cr.style.removeProperty(ar) : cr.style.setProperty(ar, lr, ur ? "important" : "");
}
function select_option(cr, ar, lr) {
  for (let ur = 0; ur < cr.options.length; ur += 1) {
    const dr = cr.options[ur];
    if (dr.__value === ar) {
      dr.selected = !0;
      return;
    }
  }
  (!lr || ar !== void 0) && (cr.selectedIndex = -1);
}
function select_options(cr, ar) {
  for (let lr = 0; lr < cr.options.length; lr += 1) {
    const ur = cr.options[lr];
    ur.selected = ~ar.indexOf(ur.__value);
  }
}
function select_value(cr) {
  const ar = cr.querySelector(":checked");
  return ar && ar.__value;
}
function select_multiple_value(cr) {
  return [].map.call(cr.querySelectorAll(":checked"), (ar) => ar.__value);
}
function toggle_class(cr, ar, lr) {
  cr.classList.toggle(ar, !!lr);
}
function custom_event(cr, ar, { bubbles: lr = !1, cancelable: ur = !1 } = {}) {
  return new CustomEvent(cr, { detail: ar, bubbles: lr, cancelable: ur });
}
class HtmlTag {
  constructor(ar = !1) {
    /**
     * @private
     * @default false
     */
    ti(this, "is_svg", !1);
    /** parent for creating node */
    ti(this, "e");
    /** html tag nodes */
    ti(this, "n");
    /** target */
    ti(this, "t");
    /** anchor */
    ti(this, "a");
    this.is_svg = ar, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(ar) {
    this.h(ar);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(ar, lr, ur = null) {
    this.e || (this.is_svg ? this.e = svg_element(
      /** @type {keyof SVGElementTagNameMap} */
      lr.nodeName
    ) : this.e = element(
      /** @type {keyof HTMLElementTagNameMap} */
      lr.nodeType === 11 ? "TEMPLATE" : lr.nodeName
    ), this.t = lr.tagName !== "TEMPLATE" ? lr : (
      /** @type {HTMLTemplateElement} */
      lr.content
    ), this.c(ar)), this.i(ur);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(ar) {
    this.e.innerHTML = ar, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(ar) {
    for (let lr = 0; lr < this.n.length; lr += 1)
      insert(this.t, this.n[lr], ar);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(ar) {
    this.d(), this.h(ar), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function get_custom_elements_slots(cr) {
  const ar = {};
  return cr.childNodes.forEach(
    /** @param {Element} node */
    (lr) => {
      ar[lr.slot || "default"] = !0;
    }
  ), ar;
}
function construct_svelte_component(cr, ar) {
  return new cr(ar);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash$7(cr) {
  let ar = 5381, lr = cr.length;
  for (; lr--; )
    ar = (ar << 5) - ar ^ cr.charCodeAt(lr);
  return ar >>> 0;
}
function create_style_information(cr, ar) {
  const lr = { stylesheet: append_empty_stylesheet(ar), rules: {} };
  return managed_styles.set(cr, lr), lr;
}
function create_rule(cr, ar, lr, ur, dr, fr, gr, mr = 0) {
  const vr = 16.666 / ur;
  let yr = `{
`;
  for (let Tr = 0; Tr <= 1; Tr += vr) {
    const Sr = ar + (lr - ar) * fr(Tr);
    yr += Tr * 100 + `%{${gr(Sr, 1 - Sr)}}
`;
  }
  const _r = yr + `100% {${gr(lr, 1 - lr)}}
}`, kr = `__svelte_${hash$7(_r)}_${mr}`, xr = get_root_for_style(cr), { stylesheet: Ar, rules: Er } = managed_styles.get(xr) || create_style_information(xr, cr);
  Er[kr] || (Er[kr] = !0, Ar.insertRule(`@keyframes ${kr} ${_r}`, Ar.cssRules.length));
  const Cr = cr.style.animation || "";
  return cr.style.animation = `${Cr ? `${Cr}, ` : ""}${kr} ${ur}ms linear ${dr}ms 1 both`, active += 1, kr;
}
function delete_rule(cr, ar) {
  const lr = (cr.style.animation || "").split(", "), ur = lr.filter(
    ar ? (fr) => fr.indexOf(ar) < 0 : (fr) => fr.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), dr = lr.length - ur.length;
  dr && (cr.style.animation = ur.join(", "), active -= dr, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((cr) => {
      const { ownerNode: ar } = cr.stylesheet;
      ar && detach(ar);
    }), managed_styles.clear());
  });
}
function create_animation(cr, ar, lr, ur) {
  if (!ar)
    return noop$1;
  const dr = cr.getBoundingClientRect();
  if (ar.left === dr.left && ar.right === dr.right && ar.top === dr.top && ar.bottom === dr.bottom)
    return noop$1;
  const {
    delay: fr = 0,
    duration: gr = 300,
    easing: mr = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: vr = now() + fr,
    // @ts-ignore todo:
    end: yr = vr + gr,
    tick: _r = noop$1,
    css: kr
  } = lr(cr, { from: ar, to: dr }, ur);
  let xr = !0, Ar = !1, Er;
  function Cr() {
    kr && (Er = create_rule(cr, 0, 1, gr, fr, mr, kr)), fr || (Ar = !0);
  }
  function Tr() {
    kr && delete_rule(cr, Er), xr = !1;
  }
  return loop((Sr) => {
    if (!Ar && Sr >= vr && (Ar = !0), Ar && Sr >= yr && (_r(1, 0), Tr()), !xr)
      return !1;
    if (Ar) {
      const Lr = Sr - vr, Ir = 0 + 1 * mr(Lr / gr);
      _r(Ir, 1 - Ir);
    }
    return !0;
  }), Cr(), _r(0, 1), Tr;
}
function fix_position(cr) {
  const ar = getComputedStyle(cr);
  if (ar.position !== "absolute" && ar.position !== "fixed") {
    const { width: lr, height: ur } = ar, dr = cr.getBoundingClientRect();
    cr.style.position = "absolute", cr.style.width = lr, cr.style.height = ur, add_transform(cr, dr);
  }
}
function add_transform(cr, ar) {
  const lr = cr.getBoundingClientRect();
  if (ar.left !== lr.left || ar.top !== lr.top) {
    const ur = getComputedStyle(cr), dr = ur.transform === "none" ? "" : ur.transform;
    cr.style.transform = `${dr} translate(${ar.left - lr.left}px, ${ar.top - lr.top}px)`;
  }
}
let current_component;
function set_current_component(cr) {
  current_component = cr;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(cr) {
  get_current_component().$$.on_mount.push(cr);
}
function afterUpdate(cr) {
  get_current_component().$$.after_update.push(cr);
}
function onDestroy(cr) {
  get_current_component().$$.on_destroy.push(cr);
}
function createEventDispatcher() {
  const cr = get_current_component();
  return (ar, lr, { cancelable: ur = !1 } = {}) => {
    const dr = cr.$$.callbacks[ar];
    if (dr) {
      const fr = custom_event(
        /** @type {string} */
        ar,
        lr,
        { cancelable: ur }
      );
      return dr.slice().forEach((gr) => {
        gr.call(cr, fr);
      }), !fr.defaultPrevented;
    }
    return !0;
  };
}
function setContext(cr, ar) {
  return get_current_component().$$.context.set(cr, ar), ar;
}
function getContext(cr) {
  return get_current_component().$$.context.get(cr);
}
function bubble(cr, ar) {
  const lr = cr.$$.callbacks[ar.type];
  lr && lr.slice().forEach((ur) => ur.call(this, ar));
}
const dirty_components = [], binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [], resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(cr) {
  render_callbacks.push(cr);
}
function add_flush_callback(cr) {
  flush_callbacks.push(cr);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const cr = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const ar = dirty_components[flushidx];
        flushidx++, set_current_component(ar), update(ar.$$);
      }
    } catch (ar) {
      throw dirty_components.length = 0, flushidx = 0, ar;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let ar = 0; ar < render_callbacks.length; ar += 1) {
      const lr = render_callbacks[ar];
      seen_callbacks.has(lr) || (seen_callbacks.add(lr), lr());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(cr);
}
function update(cr) {
  if (cr.fragment !== null) {
    cr.update(), run_all(cr.before_update);
    const ar = cr.dirty;
    cr.dirty = [-1], cr.fragment && cr.fragment.p(cr.ctx, ar), cr.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(cr) {
  const ar = [], lr = [];
  render_callbacks.forEach((ur) => cr.indexOf(ur) === -1 ? ar.push(ur) : lr.push(ur)), lr.forEach((ur) => ur()), render_callbacks = ar;
}
let promise;
function wait() {
  return promise || (promise = Promise.resolve(), promise.then(() => {
    promise = null;
  })), promise;
}
function dispatch(cr, ar, lr) {
  cr.dispatchEvent(custom_event(`${ar ? "intro" : "outro"}${lr}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(cr, ar) {
  cr && cr.i && (outroing.delete(cr), cr.i(ar));
}
function transition_out(cr, ar, lr, ur) {
  if (cr && cr.o) {
    if (outroing.has(cr))
      return;
    outroing.add(cr), outros.c.push(() => {
      outroing.delete(cr), ur && (lr && cr.d(1), ur());
    }), cr.o(ar);
  } else
    ur && ur();
}
const null_transition = { duration: 0 };
function create_in_transition(cr, ar, lr) {
  const ur = { direction: "in" };
  let dr = ar(cr, lr, ur), fr = !1, gr, mr, vr = 0;
  function yr() {
    gr && delete_rule(cr, gr);
  }
  function _r() {
    const {
      delay: xr = 0,
      duration: Ar = 300,
      easing: Er = identity,
      tick: Cr = noop$1,
      css: Tr
    } = dr || null_transition;
    Tr && (gr = create_rule(cr, 0, 1, Ar, xr, Er, Tr, vr++)), Cr(0, 1);
    const Sr = now() + xr, Lr = Sr + Ar;
    mr && mr.abort(), fr = !0, add_render_callback(() => dispatch(cr, !0, "start")), mr = loop((Ir) => {
      if (fr) {
        if (Ir >= Lr)
          return Cr(1, 0), dispatch(cr, !0, "end"), yr(), fr = !1;
        if (Ir >= Sr) {
          const Nr = Er((Ir - Sr) / Ar);
          Cr(Nr, 1 - Nr);
        }
      }
      return fr;
    });
  }
  let kr = !1;
  return {
    start() {
      kr || (kr = !0, delete_rule(cr), is_function(dr) ? (dr = dr(ur), wait().then(_r)) : _r());
    },
    invalidate() {
      kr = !1;
    },
    end() {
      fr && (yr(), fr = !1);
    }
  };
}
function create_out_transition(cr, ar, lr) {
  const ur = { direction: "out" };
  let dr = ar(cr, lr, ur), fr = !0, gr;
  const mr = outros;
  mr.r += 1;
  let vr;
  function yr() {
    const {
      delay: _r = 0,
      duration: kr = 300,
      easing: xr = identity,
      tick: Ar = noop$1,
      css: Er
    } = dr || null_transition;
    Er && (gr = create_rule(cr, 1, 0, kr, _r, xr, Er));
    const Cr = now() + _r, Tr = Cr + kr;
    add_render_callback(() => dispatch(cr, !1, "start")), "inert" in cr && (vr = /** @type {HTMLElement} */
    cr.inert, cr.inert = !0), loop((Sr) => {
      if (fr) {
        if (Sr >= Tr)
          return Ar(0, 1), dispatch(cr, !1, "end"), --mr.r || run_all(mr.c), !1;
        if (Sr >= Cr) {
          const Lr = xr((Sr - Cr) / kr);
          Ar(1 - Lr, Lr);
        }
      }
      return fr;
    });
  }
  return is_function(dr) ? wait().then(() => {
    dr = dr(ur), yr();
  }) : yr(), {
    end(_r) {
      _r && "inert" in cr && (cr.inert = vr), _r && dr.tick && dr.tick(1, 0), fr && (gr && delete_rule(cr, gr), fr = !1);
    }
  };
}
function create_bidirectional_transition(cr, ar, lr, ur) {
  let fr = ar(cr, lr, { direction: "both" }), gr = ur ? 0 : 1, mr = null, vr = null, yr = null, _r;
  function kr() {
    yr && delete_rule(cr, yr);
  }
  function xr(Er, Cr) {
    const Tr = (
      /** @type {Program['d']} */
      Er.b - gr
    );
    return Cr *= Math.abs(Tr), {
      a: gr,
      b: Er.b,
      d: Tr,
      duration: Cr,
      start: Er.start,
      end: Er.start + Cr,
      group: Er.group
    };
  }
  function Ar(Er) {
    const {
      delay: Cr = 0,
      duration: Tr = 300,
      easing: Sr = identity,
      tick: Lr = noop$1,
      css: Ir
    } = fr || null_transition, Nr = {
      start: now() + Cr,
      b: Er
    };
    Er || (Nr.group = outros, outros.r += 1), "inert" in cr && (Er ? _r !== void 0 && (cr.inert = _r) : (_r = /** @type {HTMLElement} */
    cr.inert, cr.inert = !0)), mr || vr ? vr = Nr : (Ir && (kr(), yr = create_rule(cr, gr, Er, Tr, Cr, Sr, Ir)), Er && Lr(0, 1), mr = xr(Nr, Tr), add_render_callback(() => dispatch(cr, Er, "start")), loop((Rr) => {
      if (vr && Rr > vr.start && (mr = xr(vr, Tr), vr = null, dispatch(cr, mr.b, "start"), Ir && (kr(), yr = create_rule(
        cr,
        gr,
        mr.b,
        mr.duration,
        0,
        Sr,
        fr.css
      ))), mr) {
        if (Rr >= mr.end)
          Lr(gr = mr.b, 1 - gr), dispatch(cr, mr.b, "end"), vr || (mr.b ? kr() : --mr.group.r || run_all(mr.group.c)), mr = null;
        else if (Rr >= mr.start) {
          const Mr = Rr - mr.start;
          gr = mr.a + mr.d * Sr(Mr / mr.duration), Lr(gr, 1 - gr);
        }
      }
      return !!(mr || vr);
    }));
  }
  return {
    run(Er) {
      is_function(fr) ? wait().then(() => {
        fr = fr({ direction: Er ? "in" : "out" }), Ar(Er);
      }) : Ar(Er);
    },
    end() {
      kr(), mr = vr = null;
    }
  };
}
function ensure_array_like(cr) {
  return (cr == null ? void 0 : cr.length) !== void 0 ? cr : Array.from(cr);
}
function outro_and_destroy_block(cr, ar) {
  transition_out(cr, 1, 1, () => {
    ar.delete(cr.key);
  });
}
function fix_and_outro_and_destroy_block(cr, ar) {
  cr.f(), outro_and_destroy_block(cr, ar);
}
function update_keyed_each(cr, ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr) {
  let xr = cr.length, Ar = fr.length, Er = xr;
  const Cr = {};
  for (; Er--; )
    Cr[cr[Er].key] = Er;
  const Tr = [], Sr = /* @__PURE__ */ new Map(), Lr = /* @__PURE__ */ new Map(), Ir = [];
  for (Er = Ar; Er--; ) {
    const Br = kr(dr, fr, Er), Dr = lr(Br);
    let Hr = gr.get(Dr);
    Hr ? ur && Ir.push(() => Hr.p(Br, ar)) : (Hr = yr(Dr, Br), Hr.c()), Sr.set(Dr, Tr[Er] = Hr), Dr in Cr && Lr.set(Dr, Math.abs(Er - Cr[Dr]));
  }
  const Nr = /* @__PURE__ */ new Set(), Rr = /* @__PURE__ */ new Set();
  function Mr(Br) {
    transition_in(Br, 1), Br.m(mr, _r), gr.set(Br.key, Br), _r = Br.first, Ar--;
  }
  for (; xr && Ar; ) {
    const Br = Tr[Ar - 1], Dr = cr[xr - 1], Hr = Br.key, Fr = Dr.key;
    Br === Dr ? (_r = Br.first, xr--, Ar--) : Sr.has(Fr) ? !gr.has(Hr) || Nr.has(Hr) ? Mr(Br) : Rr.has(Fr) ? xr-- : Lr.get(Hr) > Lr.get(Fr) ? (Rr.add(Hr), Mr(Br)) : (Nr.add(Fr), xr--) : (vr(Dr, gr), xr--);
  }
  for (; xr--; ) {
    const Br = cr[xr];
    Sr.has(Br.key) || vr(Br, gr);
  }
  for (; Ar; )
    Mr(Tr[Ar - 1]);
  return run_all(Ir), Tr;
}
function get_spread_update(cr, ar) {
  const lr = {}, ur = {}, dr = { $$scope: 1 };
  let fr = cr.length;
  for (; fr--; ) {
    const gr = cr[fr], mr = ar[fr];
    if (mr) {
      for (const vr in gr)
        vr in mr || (ur[vr] = 1);
      for (const vr in mr)
        dr[vr] || (lr[vr] = mr[vr], dr[vr] = 1);
      cr[fr] = mr;
    } else
      for (const vr in gr)
        dr[vr] = 1;
  }
  for (const gr in ur)
    gr in lr || (lr[gr] = void 0);
  return lr;
}
function get_spread_object(cr) {
  return typeof cr == "object" && cr !== null ? cr : {};
}
function bind$1(cr, ar, lr) {
  const ur = cr.$$.props[ar];
  ur !== void 0 && (cr.$$.bound[ur] = lr, lr(cr.$$.ctx[ur]));
}
function create_component(cr) {
  cr && cr.c();
}
function mount_component(cr, ar, lr) {
  const { fragment: ur, after_update: dr } = cr.$$;
  ur && ur.m(ar, lr), add_render_callback(() => {
    const fr = cr.$$.on_mount.map(run$2).filter(is_function);
    cr.$$.on_destroy ? cr.$$.on_destroy.push(...fr) : run_all(fr), cr.$$.on_mount = [];
  }), dr.forEach(add_render_callback);
}
function destroy_component(cr, ar) {
  const lr = cr.$$;
  lr.fragment !== null && (flush_render_callbacks(lr.after_update), run_all(lr.on_destroy), lr.fragment && lr.fragment.d(ar), lr.on_destroy = lr.fragment = null, lr.ctx = []);
}
function make_dirty(cr, ar) {
  cr.$$.dirty[0] === -1 && (dirty_components.push(cr), schedule_update(), cr.$$.dirty.fill(0)), cr.$$.dirty[ar / 31 | 0] |= 1 << ar % 31;
}
function init(cr, ar, lr, ur, dr, fr, gr = null, mr = [-1]) {
  const vr = current_component;
  set_current_component(cr);
  const yr = cr.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: fr,
    update: noop$1,
    not_equal: dr,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(ar.context || (vr ? vr.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: mr,
    skip_bound: !1,
    root: ar.target || vr.$$.root
  };
  gr && gr(yr.root);
  let _r = !1;
  if (yr.ctx = lr ? lr(cr, ar.props || {}, (kr, xr, ...Ar) => {
    const Er = Ar.length ? Ar[0] : xr;
    return yr.ctx && dr(yr.ctx[kr], yr.ctx[kr] = Er) && (!yr.skip_bound && yr.bound[kr] && yr.bound[kr](Er), _r && make_dirty(cr, kr)), xr;
  }) : [], yr.update(), _r = !0, run_all(yr.before_update), yr.fragment = ur ? ur(yr.ctx) : !1, ar.target) {
    if (ar.hydrate) {
      const kr = children(ar.target);
      yr.fragment && yr.fragment.l(kr), kr.forEach(detach);
    } else
      yr.fragment && yr.fragment.c();
    ar.intro && transition_in(cr.$$.fragment), mount_component(cr, ar.target, ar.anchor), flush();
  }
  set_current_component(vr);
}
let SvelteElement;
typeof HTMLElement == "function" && (SvelteElement = class extends HTMLElement {
  constructor(ar, lr, ur) {
    super();
    /** The Svelte component constructor */
    ti(this, "$$ctor");
    /** Slots */
    ti(this, "$$s");
    /** The Svelte component instance */
    ti(this, "$$c");
    /** Whether or not the custom element is connected */
    ti(this, "$$cn", !1);
    /** Component props data */
    ti(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    ti(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    ti(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    ti(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    ti(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = ar, this.$$s = lr, ur && this.attachShadow({ mode: "open" });
  }
  addEventListener(ar, lr, ur) {
    if (this.$$l[ar] = this.$$l[ar] || [], this.$$l[ar].push(lr), this.$$c) {
      const dr = this.$$c.$on(ar, lr);
      this.$$l_u.set(lr, dr);
    }
    super.addEventListener(ar, lr, ur);
  }
  removeEventListener(ar, lr, ur) {
    if (super.removeEventListener(ar, lr, ur), this.$$c) {
      const dr = this.$$l_u.get(lr);
      dr && (dr(), this.$$l_u.delete(lr));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let ar = function(fr) {
        return () => {
          let gr;
          return {
            c: function() {
              gr = element("slot"), fr !== "default" && attr(gr, "name", fr);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(yr, _r) {
              insert(yr, gr, _r);
            },
            d: function(yr) {
              yr && detach(gr);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn)
        return;
      const lr = {}, ur = get_custom_elements_slots(this);
      for (const fr of this.$$s)
        fr in ur && (lr[fr] = [ar(fr)]);
      for (const fr of this.attributes) {
        const gr = this.$$g_p(fr.name);
        gr in this.$$d || (this.$$d[gr] = get_custom_element_value(gr, fr.value, this.$$p_d, "toProp"));
      }
      for (const fr in this.$$p_d)
        !(fr in this.$$d) && this[fr] !== void 0 && (this.$$d[fr] = this[fr], delete this[fr]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: lr,
          $$scope: {
            ctx: []
          }
        }
      });
      const dr = () => {
        this.$$r = !0;
        for (const fr in this.$$p_d)
          if (this.$$d[fr] = this.$$c.$$.ctx[this.$$c.$$.props[fr]], this.$$p_d[fr].reflect) {
            const gr = get_custom_element_value(
              fr,
              this.$$d[fr],
              this.$$p_d,
              "toAttribute"
            );
            gr == null ? this.removeAttribute(this.$$p_d[fr].attribute || fr) : this.setAttribute(this.$$p_d[fr].attribute || fr, gr);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(dr), dr();
      for (const fr in this.$$l)
        for (const gr of this.$$l[fr]) {
          const mr = this.$$c.$on(fr, gr);
          this.$$l_u.set(gr, mr);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(ar, lr, ur) {
    var dr;
    this.$$r || (ar = this.$$g_p(ar), this.$$d[ar] = get_custom_element_value(ar, ur, this.$$p_d, "toProp"), (dr = this.$$c) == null || dr.$set({ [ar]: this.$$d[ar] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(ar) {
    return Object.keys(this.$$p_d).find(
      (lr) => this.$$p_d[lr].attribute === ar || !this.$$p_d[lr].attribute && lr.toLowerCase() === ar
    ) || ar;
  }
});
function get_custom_element_value(cr, ar, lr, ur) {
  var fr;
  const dr = (fr = lr[cr]) == null ? void 0 : fr.type;
  if (ar = dr === "Boolean" && typeof ar != "boolean" ? ar != null : ar, !ur || !lr[cr])
    return ar;
  if (ur === "toAttribute")
    switch (dr) {
      case "Object":
      case "Array":
        return ar == null ? null : JSON.stringify(ar);
      case "Boolean":
        return ar ? "" : null;
      case "Number":
        return ar == null ? null : ar;
      default:
        return ar;
    }
  else
    switch (dr) {
      case "Object":
      case "Array":
        return ar && JSON.parse(ar);
      case "Boolean":
        return ar;
      case "Number":
        return ar != null ? +ar : ar;
      default:
        return ar;
    }
}
function create_custom_element(cr, ar, lr, ur, dr, fr) {
  let gr = class extends SvelteElement {
    constructor() {
      super(cr, lr, dr), this.$$p_d = ar;
    }
    static get observedAttributes() {
      return Object.keys(ar).map(
        (mr) => (ar[mr].attribute || mr).toLowerCase()
      );
    }
  };
  return Object.keys(ar).forEach((mr) => {
    Object.defineProperty(gr.prototype, mr, {
      get() {
        return this.$$c && mr in this.$$c ? this.$$c[mr] : this.$$d[mr];
      },
      set(vr) {
        var yr;
        vr = get_custom_element_value(mr, vr, ar), this.$$d[mr] = vr, (yr = this.$$c) == null || yr.$set({ [mr]: vr });
      }
    });
  }), ur.forEach((mr) => {
    Object.defineProperty(gr.prototype, mr, {
      get() {
        var vr;
        return (vr = this.$$c) == null ? void 0 : vr[mr];
      }
    });
  }), fr && (gr = fr(gr)), cr.element = /** @type {any} */
  gr, gr;
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    ti(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    ti(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(ar, lr) {
    if (!is_function(lr))
      return noop$1;
    const ur = this.$$.callbacks[ar] || (this.$$.callbacks[ar] = []);
    return ur.push(lr), () => {
      const dr = ur.indexOf(lr);
      dr !== -1 && ur.splice(dr, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(ar) {
    this.$$set && !is_empty(ar) && (this.$$.skip_bound = !0, this.$$set(ar), this.$$.skip_bound = !1);
  }
}
const PUBLIC_VERSION = "4";
typeof window != "undefined" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function readable(cr, ar) {
  return {
    subscribe: writable(cr, ar).subscribe
  };
}
function writable(cr, ar = noop$1) {
  let lr;
  const ur = /* @__PURE__ */ new Set();
  function dr(mr) {
    if (safe_not_equal(cr, mr) && (cr = mr, lr)) {
      const vr = !subscriber_queue.length;
      for (const yr of ur)
        yr[1](), subscriber_queue.push(yr, cr);
      if (vr) {
        for (let yr = 0; yr < subscriber_queue.length; yr += 2)
          subscriber_queue[yr][0](subscriber_queue[yr + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function fr(mr) {
    dr(mr(cr));
  }
  function gr(mr, vr = noop$1) {
    const yr = [mr, vr];
    return ur.add(yr), ur.size === 1 && (lr = ar(dr, fr) || noop$1), mr(cr), () => {
      ur.delete(yr), ur.size === 0 && lr && (lr(), lr = null);
    };
  }
  return { set: dr, update: fr, subscribe: gr };
}
const storeHighlightJs = writable(void 0), tocStore = writable([]), tocActiveId = writable(void 0), DRAWER_STORE_KEY = "drawerStore";
function getDrawerStore() {
  const cr = getContext(DRAWER_STORE_KEY);
  if (!cr)
    throw new Error("drawerStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return cr;
}
const MODAL_STORE_KEY = "modalStore";
function getModalStore() {
  const cr = getContext(MODAL_STORE_KEY);
  if (!cr)
    throw new Error("modalStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return cr;
}
const TOAST_STORE_KEY = "toastStore";
function getToastStore() {
  const cr = getContext(TOAST_STORE_KEY);
  if (!cr)
    throw new Error("toastStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return cr;
}
const stores = {};
function getStorage(cr) {
  return cr === "local" ? localStorage : sessionStorage;
}
function localStorageStore(cr, ar, lr) {
  var gr, mr;
  const ur = (gr = lr == null ? void 0 : lr.serializer) != null ? gr : JSON, dr = (mr = lr == null ? void 0 : lr.storage) != null ? mr : "local";
  function fr(vr, yr) {
    getStorage(dr).setItem(vr, ur.stringify(yr));
  }
  if (!stores[cr]) {
    const vr = writable(ar, (kr) => {
      const xr = getStorage(dr).getItem(cr);
      xr && kr(ur.parse(xr));
      {
        const Ar = (Er) => {
          Er.key === cr && kr(Er.newValue ? ur.parse(Er.newValue) : null);
        };
        return window.addEventListener("storage", Ar), () => window.removeEventListener("storage", Ar);
      }
    }), { subscribe: yr, set: _r } = vr;
    stores[cr] = {
      set(kr) {
        fr(cr, kr), _r(kr);
      },
      update(kr) {
        const xr = kr(get_store_value(vr));
        fr(cr, xr), _r(xr);
      },
      subscribe: yr
    };
  }
  return stores[cr];
}
const modeOsPrefers = localStorageStore("modeOsPrefers", !1), modeUserPrefers = localStorageStore("modeUserPrefers", void 0), modeCurrent = localStorageStore("modeCurrent", !1);
function getModeOsPrefers() {
  const cr = window.matchMedia("(prefers-color-scheme: light)").matches;
  return modeOsPrefers.set(cr), cr;
}
function setModeUserPrefers(cr) {
  modeUserPrefers.set(cr);
}
function setModeCurrent(cr) {
  const ar = document.documentElement.classList, lr = "dark";
  cr === !0 ? ar.remove(lr) : ar.add(lr), modeCurrent.set(cr);
}
function setInitialClassState() {
  const cr = document.documentElement.classList, ar = localStorage.getItem("modeUserPrefers") === "false", lr = !("modeUserPrefers" in localStorage), ur = window.matchMedia("(prefers-color-scheme: dark)").matches;
  ar || lr && ur ? cr.add("dark") : cr.remove("dark");
}
const reducedMotionQuery = "(prefers-reduced-motion: reduce)";
function prefersReducedMotion() {
  return window.matchMedia(reducedMotionQuery).matches;
}
const prefersReducedMotionStore = readable(prefersReducedMotion(), (cr) => {
  {
    const ar = (ur) => {
      cr(ur.matches);
    }, lr = window.matchMedia(reducedMotionQuery);
    return lr.addEventListener("change", ar), () => {
      lr.removeEventListener("change", ar);
    };
  }
});
function clipboard(cr, ar) {
  if (!window.isSecureContext) {
    console.error("Clipboard action failed: app not running in secure context, see: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard");
    return;
  }
  const lr = () => {
    cr.dispatchEvent(new CustomEvent("copyComplete"));
  }, ur = () => {
    if (typeof ar == "object") {
      if ("element" in ar) {
        const dr = document.querySelector(`[data-clipboard="${ar.element}"]`);
        if (!dr)
          throw new Error(`Missing HTMLElement with an attribute of [data-clipboard="${ar.element}"]`);
        copyToClipboard(dr.innerHTML, "text/html").then(lr);
        return;
      }
      if ("input" in ar) {
        const dr = document.querySelector(`[data-clipboard="${ar.input}"]`);
        if (!dr)
          throw new Error(`Missing HTMLInputElement with an attribute of [data-clipboard="${ar.input}"]`);
        copyToClipboard(dr.value).then(lr);
        return;
      }
    }
    copyToClipboard(ar).then(lr);
  };
  return cr.addEventListener("click", ur), {
    update(dr) {
      ar = dr;
    },
    destroy() {
      cr.removeEventListener("click", ur);
    }
  };
}
async function copyToClipboard(cr, ar = "text/plain") {
  navigator.clipboard.write ? await navigator.clipboard.write([
    new ClipboardItem({
      [ar]: new Blob([cr], {
        type: ar
      }),
      "text/plain": new Blob([cr], {
        type: "text/plain"
      })
    })
  ]) : await new Promise((lr) => {
    lr(navigator.clipboard.writeText(String(cr)));
  });
}
function focusTrap(cr, ar) {
  const lr = 'a[href]:not([tabindex="-1"]), button:not([tabindex="-1"]), input:not([tabindex="-1"]), textarea:not([tabindex="-1"]), select:not([tabindex="-1"]), details:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])';
  let ur, dr;
  function fr(kr) {
    kr.shiftKey && kr.code === "Tab" && (kr.preventDefault(), dr.focus());
  }
  function gr(kr) {
    !kr.shiftKey && kr.code === "Tab" && (kr.preventDefault(), ur.focus());
  }
  const mr = (kr) => {
    if (ar === !1)
      return;
    const xr = Array.from(cr.querySelectorAll(lr));
    xr.length && (ur = xr[0], dr = xr[xr.length - 1], kr || ur.focus(), ur.addEventListener("keydown", fr), dr.addEventListener("keydown", gr));
  };
  mr(!1);
  function vr() {
    ur && ur.removeEventListener("keydown", fr), dr && dr.removeEventListener("keydown", gr);
  }
  const yr = (kr, xr) => (kr.length && (vr(), mr(!0)), xr), _r = new MutationObserver(yr);
  return _r.observe(cr, { childList: !0, subtree: !0 }), {
    update(kr) {
      ar = kr, kr ? mr(!1) : vr();
    },
    destroy() {
      vr(), _r.disconnect();
    }
  };
}
function cubicIn(cr) {
  return cr * cr * cr;
}
function cubicOut(cr) {
  const ar = cr - 1;
  return ar * ar * ar + 1;
}
function fade(cr, { delay: ar = 0, duration: lr = 400, easing: ur = identity } = {}) {
  const dr = +getComputedStyle(cr).opacity;
  return {
    delay: ar,
    duration: lr,
    easing: ur,
    css: (fr) => `opacity: ${fr * dr}`
  };
}
function fly(cr, { delay: ar = 0, duration: lr = 400, easing: ur = cubicOut, x: dr = 0, y: fr = 0, opacity: gr = 0 } = {}) {
  const mr = getComputedStyle(cr), vr = +mr.opacity, yr = mr.transform === "none" ? "" : mr.transform, _r = vr * (1 - gr), [kr, xr] = split_css_unit(dr), [Ar, Er] = split_css_unit(fr);
  return {
    delay: ar,
    duration: lr,
    easing: ur,
    css: (Cr, Tr) => `
			transform: ${yr} translate(${(1 - Cr) * kr}${xr}, ${(1 - Cr) * Ar}${Er});
			opacity: ${vr - _r * Tr}`
  };
}
function slide(cr, { delay: ar = 0, duration: lr = 400, easing: ur = cubicOut, axis: dr = "y" } = {}) {
  const fr = getComputedStyle(cr), gr = +fr.opacity, mr = dr === "y" ? "height" : "width", vr = parseFloat(fr[mr]), yr = dr === "y" ? ["top", "bottom"] : ["left", "right"], _r = yr.map(
    (Sr) => `${Sr[0].toUpperCase()}${Sr.slice(1)}`
  ), kr = parseFloat(fr[`padding${_r[0]}`]), xr = parseFloat(fr[`padding${_r[1]}`]), Ar = parseFloat(fr[`margin${_r[0]}`]), Er = parseFloat(fr[`margin${_r[1]}`]), Cr = parseFloat(
    fr[`border${_r[0]}Width`]
  ), Tr = parseFloat(
    fr[`border${_r[1]}Width`]
  );
  return {
    delay: ar,
    duration: lr,
    easing: ur,
    css: (Sr) => `overflow: hidden;opacity: ${Math.min(Sr * 20, 1) * gr};${mr}: ${Sr * vr}px;padding-${yr[0]}: ${Sr * kr}px;padding-${yr[1]}: ${Sr * xr}px;margin-${yr[0]}: ${Sr * Ar}px;margin-${yr[1]}: ${Sr * Er}px;border-${yr[0]}-width: ${Sr * Cr}px;border-${yr[1]}-width: ${Sr * Tr}px;`
  };
}
function scale(cr, { delay: ar = 0, duration: lr = 400, easing: ur = cubicOut, start: dr = 0, opacity: fr = 0 } = {}) {
  const gr = getComputedStyle(cr), mr = +gr.opacity, vr = gr.transform === "none" ? "" : gr.transform, yr = 1 - dr, _r = mr * (1 - fr);
  return {
    delay: ar,
    duration: lr,
    easing: ur,
    css: (kr, xr) => `
			transform: ${vr} scale(${1 - yr * xr});
			opacity: ${mr - _r * xr}
		`
  };
}
function create_fragment$14(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[19].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[18],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "accordion " + /*classesBase*/
      cr[0]), attr(ar, "data-testid", "accordion");
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[18],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      1 && lr !== (lr = "accordion " + /*classesBase*/
      gr[0])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function instance$L(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, prefersReducedMotionStore, (Hr) => lr(20, dr = Hr));
  let { $$slots: fr = {}, $$scope: gr } = ar, { autocollapse: mr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: yr = "space-y-1" } = ar, { disabled: _r = !1 } = ar, { padding: kr = "py-2 px-4" } = ar, { hover: xr = "hover:bg-primary-hover-token" } = ar, { rounded: Ar = "rounded-container-token" } = ar, { caretOpen: Er = "rotate-180" } = ar, { caretClosed: Cr = "" } = ar, { regionControl: Tr = "" } = ar, { regionPanel: Sr = "space-y-4" } = ar, { regionCaret: Lr = "" } = ar, { transitions: Ir = !dr } = ar, { transitionIn: Nr = slide } = ar, { transitionInParams: Rr = { duration: 200 } } = ar, { transitionOut: Mr = slide } = ar, { transitionOutParams: Br = { duration: 200 } } = ar;
  const Dr = writable(null);
  return setContext("active", Dr), setContext("autocollapse", mr), setContext("disabled", _r), setContext("padding", kr), setContext("hover", xr), setContext("rounded", Ar), setContext("caretOpen", Er), setContext("caretClosed", Cr), setContext("regionControl", Tr), setContext("regionPanel", Sr), setContext("regionCaret", Lr), setContext("transitions", Ir), setContext("transitionIn", Nr), setContext("transitionInParams", Rr), setContext("transitionOut", Mr), setContext("transitionOutParams", Br), cr.$$set = (Hr) => {
    lr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Hr))), "autocollapse" in Hr && lr(1, mr = Hr.autocollapse), "width" in Hr && lr(2, vr = Hr.width), "spacing" in Hr && lr(3, yr = Hr.spacing), "disabled" in Hr && lr(4, _r = Hr.disabled), "padding" in Hr && lr(5, kr = Hr.padding), "hover" in Hr && lr(6, xr = Hr.hover), "rounded" in Hr && lr(7, Ar = Hr.rounded), "caretOpen" in Hr && lr(8, Er = Hr.caretOpen), "caretClosed" in Hr && lr(9, Cr = Hr.caretClosed), "regionControl" in Hr && lr(10, Tr = Hr.regionControl), "regionPanel" in Hr && lr(11, Sr = Hr.regionPanel), "regionCaret" in Hr && lr(12, Lr = Hr.regionCaret), "transitions" in Hr && lr(13, Ir = Hr.transitions), "transitionIn" in Hr && lr(14, Nr = Hr.transitionIn), "transitionInParams" in Hr && lr(15, Rr = Hr.transitionInParams), "transitionOut" in Hr && lr(16, Mr = Hr.transitionOut), "transitionOutParams" in Hr && lr(17, Br = Hr.transitionOutParams), "$$scope" in Hr && lr(18, gr = Hr.$$scope);
  }, cr.$$.update = () => {
    var Hr;
    lr(0, ur = `${vr} ${yr} ${(Hr = ar.class) != null ? Hr : ""}`);
  }, ar = exclude_internal_props(ar), [
    ur,
    mr,
    vr,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    gr,
    fr
  ];
}
class Accordion extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$L, create_fragment$14, safe_not_equal, {
      autocollapse: 1,
      width: 2,
      spacing: 3,
      disabled: 4,
      padding: 5,
      hover: 6,
      rounded: 7,
      caretOpen: 8,
      caretClosed: 9,
      regionControl: 10,
      regionPanel: 11,
      regionCaret: 12,
      transitions: 13,
      transitionIn: 14,
      transitionInParams: 15,
      transitionOut: 16,
      transitionOutParams: 17
    });
  }
  get autocollapse() {
    return this.$$.ctx[1];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get width() {
    return this.$$.ctx[2];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[4];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[5];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[7];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[8];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[9];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[10];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[11];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[12];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[13];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[14];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[15];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[16];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[17];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Accordion, { autocollapse: { type: "Boolean" }, width: {}, spacing: {}, disabled: { type: "Boolean" }, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
function dynamicTransition(cr, ar) {
  const { transition: lr, params: ur, enabled: dr } = ar;
  return dr ? lr(cr, ur) : "duration" in ur ? lr(cr, { duration: 0 }) : { duration: 0 };
}
const get_content_slot_changes = (cr) => ({}), get_content_slot_context = (cr) => ({}), get_summary_slot_changes = (cr) => ({}), get_summary_slot_context = (cr) => ({}), get_lead_slot_changes$9 = (cr) => ({}), get_lead_slot_context$9 = (cr) => ({});
function create_if_block_1$h(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[28].lead
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[27],
    get_lead_slot_context$9
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "accordion-lead");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr[0] & /*$$scope*/
      134217728) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[27],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[27],
          gr,
          get_lead_slot_changes$9
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[27]
        ),
        get_lead_slot_context$9
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function fallback_block_1$2(cr) {
  let ar;
  return {
    c() {
      ar = text$3("(summary)");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_if_block$y(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  const yr = (
    /*#slots*/
    cr[28].content
  ), _r = create_slot(
    yr,
    cr,
    /*$$scope*/
    cr[27],
    get_content_slot_context
  ), kr = _r || fallback_block$5();
  return {
    c() {
      ar = element("div"), kr && kr.c(), attr(ar, "class", lr = "accordion-panel " + /*classesPanel*/
      cr[9]), attr(ar, "id", ur = "accordion-panel-" + /*id*/
      cr[0]), attr(ar, "role", "region"), attr(ar, "aria-hidden", dr = !/*openState*/
      cr[8]), attr(ar, "aria-labelledby", fr = "accordion-control-" + /*id*/
      cr[0]);
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), kr && kr.m(ar, null), vr = !0;
    },
    p(xr, Ar) {
      cr = xr, _r && _r.p && (!vr || Ar[0] & /*$$scope*/
      134217728) && update_slot_base(
        _r,
        yr,
        cr,
        /*$$scope*/
        cr[27],
        vr ? get_slot_changes(
          yr,
          /*$$scope*/
          cr[27],
          Ar,
          get_content_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          cr[27]
        ),
        get_content_slot_context
      ), (!vr || Ar[0] & /*classesPanel*/
      512 && lr !== (lr = "accordion-panel " + /*classesPanel*/
      cr[9])) && attr(ar, "class", lr), (!vr || Ar[0] & /*id*/
      1 && ur !== (ur = "accordion-panel-" + /*id*/
      cr[0])) && attr(ar, "id", ur), (!vr || Ar[0] & /*openState*/
      256 && dr !== (dr = !/*openState*/
      cr[8])) && attr(ar, "aria-hidden", dr), (!vr || Ar[0] & /*id*/
      1 && fr !== (fr = "accordion-control-" + /*id*/
      cr[0])) && attr(ar, "aria-labelledby", fr);
    },
    i(xr) {
      vr || (transition_in(kr, xr), xr && add_render_callback(() => {
        vr && (mr && mr.end(1), gr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            cr[4]
          ),
          params: (
            /*transitionInParams*/
            cr[5]
          ),
          enabled: (
            /*transitions*/
            cr[3]
          )
        }), gr.start());
      }), vr = !0);
    },
    o(xr) {
      transition_out(kr, xr), gr && gr.invalidate(), xr && (mr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          cr[6]
        ),
        params: (
          /*transitionOutParams*/
          cr[7]
        ),
        enabled: (
          /*transitions*/
          cr[3]
        )
      })), vr = !1;
    },
    d(xr) {
      xr && detach(ar), kr && kr.d(xr), xr && mr && mr.end();
    }
  };
}
function fallback_block$5(cr) {
  let ar;
  return {
    c() {
      ar = text$3("(content)");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_fragment$13(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr = (
    /*$$slots*/
    cr[14].lead && create_if_block_1$h(cr)
  );
  const Ir = (
    /*#slots*/
    cr[28].summary
  ), Nr = create_slot(
    Ir,
    cr,
    /*$$scope*/
    cr[27],
    get_summary_slot_context
  ), Rr = Nr || fallback_block_1$2();
  let Mr = (
    /*openState*/
    cr[8] && create_if_block$y(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("button"), Lr && Lr.c(), ur = space(), dr = element("div"), Rr && Rr.c(), fr = space(), gr = element("div"), mr = svg_element("svg"), vr = svg_element("path"), Ar = space(), Mr && Mr.c(), attr(dr, "class", "accordion-summary flex-1"), attr(vr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(mr, "xmlns", "http://www.w3.org/2000/svg"), attr(mr, "viewBox", "0 0 448 512"), attr(gr, "class", yr = "accordion-summary-caret " + /*classesControlCaret*/
      cr[10]), attr(lr, "type", "button"), attr(lr, "class", _r = "accordion-control " + /*classesControl*/
      cr[11]), attr(lr, "id", kr = "accordion-control-" + /*id*/
      cr[0]), attr(
        lr,
        "aria-expanded",
        /*openState*/
        cr[8]
      ), attr(lr, "aria-controls", xr = "accordion-panel-" + /*id*/
      cr[0]), lr.disabled = /*disabled*/
      cr[2], attr(ar, "class", Er = "accordion-item " + /*classesBase*/
      cr[12]), attr(ar, "data-testid", "accordion-item");
    },
    m(Br, Dr) {
      insert(Br, ar, Dr), append(ar, lr), Lr && Lr.m(lr, null), append(lr, ur), append(lr, dr), Rr && Rr.m(dr, null), append(lr, fr), append(lr, gr), append(gr, mr), append(mr, vr), append(ar, Ar), Mr && Mr.m(ar, null), Cr = !0, Tr || (Sr = [
        listen(
          lr,
          "click",
          /*setActive*/
          cr[13]
        ),
        listen(
          lr,
          "click",
          /*click_handler*/
          cr[29]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[30]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[31]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[32]
        )
      ], Tr = !0);
    },
    p(Br, Dr) {
      /*$$slots*/
      Br[14].lead ? Lr ? (Lr.p(Br, Dr), Dr[0] & /*$$slots*/
      16384 && transition_in(Lr, 1)) : (Lr = create_if_block_1$h(Br), Lr.c(), transition_in(Lr, 1), Lr.m(lr, ur)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!Cr || Dr[0] & /*$$scope*/
      134217728) && update_slot_base(
        Nr,
        Ir,
        Br,
        /*$$scope*/
        Br[27],
        Cr ? get_slot_changes(
          Ir,
          /*$$scope*/
          Br[27],
          Dr,
          get_summary_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Br[27]
        ),
        get_summary_slot_context
      ), (!Cr || Dr[0] & /*classesControlCaret*/
      1024 && yr !== (yr = "accordion-summary-caret " + /*classesControlCaret*/
      Br[10])) && attr(gr, "class", yr), (!Cr || Dr[0] & /*classesControl*/
      2048 && _r !== (_r = "accordion-control " + /*classesControl*/
      Br[11])) && attr(lr, "class", _r), (!Cr || Dr[0] & /*id*/
      1 && kr !== (kr = "accordion-control-" + /*id*/
      Br[0])) && attr(lr, "id", kr), (!Cr || Dr[0] & /*openState*/
      256) && attr(
        lr,
        "aria-expanded",
        /*openState*/
        Br[8]
      ), (!Cr || Dr[0] & /*id*/
      1 && xr !== (xr = "accordion-panel-" + /*id*/
      Br[0])) && attr(lr, "aria-controls", xr), (!Cr || Dr[0] & /*disabled*/
      4) && (lr.disabled = /*disabled*/
      Br[2]), /*openState*/
      Br[8] ? Mr ? (Mr.p(Br, Dr), Dr[0] & /*openState*/
      256 && transition_in(Mr, 1)) : (Mr = create_if_block$y(Br), Mr.c(), transition_in(Mr, 1), Mr.m(ar, null)) : Mr && (group_outros(), transition_out(Mr, 1, 1, () => {
        Mr = null;
      }), check_outros()), (!Cr || Dr[0] & /*classesBase*/
      4096 && Er !== (Er = "accordion-item " + /*classesBase*/
      Br[12])) && attr(ar, "class", Er);
    },
    i(Br) {
      Cr || (transition_in(Lr), transition_in(Rr, Br), transition_in(Mr), Cr = !0);
    },
    o(Br) {
      transition_out(Lr), transition_out(Rr, Br), transition_out(Mr), Cr = !1;
    },
    d(Br) {
      Br && detach(ar), Lr && Lr.d(), Rr && Rr.d(Br), Mr && Mr.d(), Tr = !1, run_all(Sr);
    }
  };
}
const cBase$p = "", cControl = "text-start w-full flex items-center space-x-4", cControlCaret = "fill-current w-3 transition-transform duration-[200ms]", cPanel$1 = "";
function instance$K(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r = noop$1, kr = () => (_r(), _r = subscribe(Ir, (Zr) => lr(26, yr = Zr)), Ir);
  cr.$$.on_destroy.push(() => _r());
  let { $$slots: xr = {}, $$scope: Ar } = ar;
  const Er = compute_slots(xr), Cr = createEventDispatcher();
  let { open: Tr = !1 } = ar, { id: Sr = String(Math.random()) } = ar, { autocollapse: Lr = getContext("autocollapse") } = ar, { active: Ir = getContext("active") } = ar;
  kr();
  let { disabled: Nr = getContext("disabled") } = ar, { padding: Rr = getContext("padding") } = ar, { hover: Mr = getContext("hover") } = ar, { rounded: Br = getContext("rounded") } = ar, { caretOpen: Dr = getContext("caretOpen") } = ar, { caretClosed: Hr = getContext("caretClosed") } = ar, { regionControl: Fr = getContext("regionControl") } = ar, { regionPanel: zr = getContext("regionPanel") } = ar, { regionCaret: Ur = getContext("regionCaret") } = ar, { transitions: jr = getContext("transitions") } = ar, { transitionIn: Yr = getContext("transitionIn") } = ar, { transitionInParams: qr = getContext("transitionInParams") } = ar, { transitionOut: Wr = getContext("transitionOut") } = ar, { transitionOutParams: Jr = getContext("transitionOutParams") } = ar;
  function Gr(Zr) {
    Lr === !0 ? Ir.set(Sr) : lr(15, Tr = !Tr), Vr(Zr);
  }
  function Vr(Zr) {
    const li = Lr ? yr === Sr : Tr;
    Cr("toggle", {
      event: Zr,
      id: `accordion-control-${Sr}`,
      open: li,
      autocollapse: Lr
    });
  }
  Lr && Tr && Gr();
  function Qr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function $r(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Xr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function si(Zr) {
    bubble.call(this, cr, Zr);
  }
  return cr.$$set = (Zr) => {
    lr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Zr))), "open" in Zr && lr(15, Tr = Zr.open), "id" in Zr && lr(0, Sr = Zr.id), "autocollapse" in Zr && lr(16, Lr = Zr.autocollapse), "active" in Zr && kr(lr(1, Ir = Zr.active)), "disabled" in Zr && lr(2, Nr = Zr.disabled), "padding" in Zr && lr(17, Rr = Zr.padding), "hover" in Zr && lr(18, Mr = Zr.hover), "rounded" in Zr && lr(19, Br = Zr.rounded), "caretOpen" in Zr && lr(20, Dr = Zr.caretOpen), "caretClosed" in Zr && lr(21, Hr = Zr.caretClosed), "regionControl" in Zr && lr(22, Fr = Zr.regionControl), "regionPanel" in Zr && lr(23, zr = Zr.regionPanel), "regionCaret" in Zr && lr(24, Ur = Zr.regionCaret), "transitions" in Zr && lr(3, jr = Zr.transitions), "transitionIn" in Zr && lr(4, Yr = Zr.transitionIn), "transitionInParams" in Zr && lr(5, qr = Zr.transitionInParams), "transitionOut" in Zr && lr(6, Wr = Zr.transitionOut), "transitionOutParams" in Zr && lr(7, Jr = Zr.transitionOutParams), "$$scope" in Zr && lr(27, Ar = Zr.$$scope);
  }, cr.$$.update = () => {
    var Zr;
    cr.$$.dirty[0] & /*open, autocollapse*/
    98304 && Tr && Lr && Gr(), cr.$$.dirty[0] & /*autocollapse, $active, id, open*/
    67207169 && lr(8, ur = Lr ? yr === Sr : Tr), lr(12, dr = `${cBase$p} ${(Zr = ar.class) != null ? Zr : ""}`), cr.$$.dirty[0] & /*padding, hover, rounded, regionControl*/
    5111808 && lr(11, fr = `${cControl} ${Rr} ${Mr} ${Br} ${Fr}`), cr.$$.dirty[0] & /*openState, caretOpen, caretClosed*/
    3145984 && lr(25, gr = ur ? Dr : Hr), cr.$$.dirty[0] & /*regionCaret, classesCaretState*/
    50331648 && lr(10, mr = `${cControlCaret} ${Ur} ${gr}`), cr.$$.dirty[0] & /*padding, rounded, regionPanel*/
    9043968 && lr(9, vr = `${cPanel$1} ${Rr} ${Br} ${zr}`);
  }, ar = exclude_internal_props(ar), [
    Sr,
    Ir,
    Nr,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    ur,
    vr,
    mr,
    fr,
    dr,
    Gr,
    Er,
    Tr,
    Lr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    gr,
    yr,
    Ar,
    xr,
    Qr,
    $r,
    Xr,
    si
  ];
}
class AccordionItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$K,
      create_fragment$13,
      safe_not_equal,
      {
        open: 15,
        id: 0,
        autocollapse: 16,
        active: 1,
        disabled: 2,
        padding: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        regionControl: 22,
        regionPanel: 23,
        regionCaret: 24,
        transitions: 3,
        transitionIn: 4,
        transitionInParams: 5,
        transitionOut: 6,
        transitionOutParams: 7
      },
      null,
      [-1, -1]
    );
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get autocollapse() {
    return this.$$.ctx[16];
  }
  set autocollapse(ar) {
    this.$$set({ autocollapse: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[2];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[22];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[23];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get regionCaret() {
    return this.$$.ctx[24];
  }
  set regionCaret(ar) {
    this.$$set({ regionCaret: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[3];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[4];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[5];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[6];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[7];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(AccordionItem, { open: { type: "Boolean" }, id: {}, autocollapse: {}, active: {}, disabled: {}, padding: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, regionControl: {}, regionPanel: {}, regionCaret: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["lead", "summary", "content"], [], !0);
const get_headline_slot_changes = (cr) => ({}), get_headline_slot_context = (cr) => ({}), get_trail_slot_changes$3 = (cr) => ({}), get_trail_slot_context$3 = (cr) => ({}), get_lead_slot_changes$8 = (cr) => ({}), get_lead_slot_context$8 = (cr) => ({});
function create_if_block_2$d(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[22].lead
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[21],
    get_lead_slot_context$8
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "app-bar-slot-lead " + /*classesSlotLead*/
      cr[4]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[21],
          mr,
          get_lead_slot_changes$8
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_lead_slot_context$8
      ), (!ur || mr & /*classesSlotLead*/
      16 && lr !== (lr = "app-bar-slot-lead " + /*classesSlotLead*/
      gr[4])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_if_block_1$g(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[22].trail
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[21],
    get_trail_slot_context$3
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "app-bar-slot-trail " + /*classesSlotTrail*/
      cr[2]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[21],
          mr,
          get_trail_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_trail_slot_context$3
      ), (!ur || mr & /*classesSlotTrail*/
      4 && lr !== (lr = "app-bar-slot-trail " + /*classesSlotTrail*/
      gr[2])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_if_block$x(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[22].headline
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[21],
    get_headline_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "app-bar-row-headline " + /*classesRowHeadline*/
      cr[5]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[21],
          mr,
          get_headline_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        get_headline_slot_context
      ), (!ur || mr & /*classesRowHeadline*/
      32 && lr !== (lr = "app-bar-row-headline " + /*classesRowHeadline*/
      gr[5])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$12(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr = (
    /*$$slots*/
    cr[8].lead && create_if_block_2$d(cr)
  );
  const xr = (
    /*#slots*/
    cr[22].default
  ), Ar = create_slot(
    xr,
    cr,
    /*$$scope*/
    cr[21],
    null
  );
  let Er = (
    /*$$slots*/
    cr[8].trail && create_if_block_1$g(cr)
  ), Cr = (
    /*$$slots*/
    cr[8].headline && create_if_block$x(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("div"), kr && kr.c(), ur = space(), dr = element("div"), Ar && Ar.c(), gr = space(), Er && Er.c(), vr = space(), Cr && Cr.c(), attr(dr, "class", fr = "app-bar-slot-default " + /*classesSlotDefault*/
      cr[3]), attr(lr, "class", mr = "app-bar-row-main " + /*classesRowMain*/
      cr[6]), attr(ar, "class", yr = "app-bar " + /*classesBase*/
      cr[7]), attr(ar, "data-testid", "app-bar"), attr(ar, "role", "toolbar"), attr(
        ar,
        "aria-label",
        /*label*/
        cr[0]
      ), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        cr[1]
      );
    },
    m(Tr, Sr) {
      insert(Tr, ar, Sr), append(ar, lr), kr && kr.m(lr, null), append(lr, ur), append(lr, dr), Ar && Ar.m(dr, null), append(lr, gr), Er && Er.m(lr, null), append(ar, vr), Cr && Cr.m(ar, null), _r = !0;
    },
    p(Tr, [Sr]) {
      /*$$slots*/
      Tr[8].lead ? kr ? (kr.p(Tr, Sr), Sr & /*$$slots*/
      256 && transition_in(kr, 1)) : (kr = create_if_block_2$d(Tr), kr.c(), transition_in(kr, 1), kr.m(lr, ur)) : kr && (group_outros(), transition_out(kr, 1, 1, () => {
        kr = null;
      }), check_outros()), Ar && Ar.p && (!_r || Sr & /*$$scope*/
      2097152) && update_slot_base(
        Ar,
        xr,
        Tr,
        /*$$scope*/
        Tr[21],
        _r ? get_slot_changes(
          xr,
          /*$$scope*/
          Tr[21],
          Sr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[21]
        ),
        null
      ), (!_r || Sr & /*classesSlotDefault*/
      8 && fr !== (fr = "app-bar-slot-default " + /*classesSlotDefault*/
      Tr[3])) && attr(dr, "class", fr), /*$$slots*/
      Tr[8].trail ? Er ? (Er.p(Tr, Sr), Sr & /*$$slots*/
      256 && transition_in(Er, 1)) : (Er = create_if_block_1$g(Tr), Er.c(), transition_in(Er, 1), Er.m(lr, null)) : Er && (group_outros(), transition_out(Er, 1, 1, () => {
        Er = null;
      }), check_outros()), (!_r || Sr & /*classesRowMain*/
      64 && mr !== (mr = "app-bar-row-main " + /*classesRowMain*/
      Tr[6])) && attr(lr, "class", mr), /*$$slots*/
      Tr[8].headline ? Cr ? (Cr.p(Tr, Sr), Sr & /*$$slots*/
      256 && transition_in(Cr, 1)) : (Cr = create_if_block$x(Tr), Cr.c(), transition_in(Cr, 1), Cr.m(ar, null)) : Cr && (group_outros(), transition_out(Cr, 1, 1, () => {
        Cr = null;
      }), check_outros()), (!_r || Sr & /*classesBase*/
      128 && yr !== (yr = "app-bar " + /*classesBase*/
      Tr[7])) && attr(ar, "class", yr), (!_r || Sr & /*label*/
      1) && attr(
        ar,
        "aria-label",
        /*label*/
        Tr[0]
      ), (!_r || Sr & /*labelledby*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        Tr[1]
      );
    },
    i(Tr) {
      _r || (transition_in(kr), transition_in(Ar, Tr), transition_in(Er), transition_in(Cr), _r = !0);
    },
    o(Tr) {
      transition_out(kr), transition_out(Ar, Tr), transition_out(Er), transition_out(Cr), _r = !1;
    },
    d(Tr) {
      Tr && detach(ar), kr && kr.d(), Ar && Ar.d(Tr), Er && Er.d(), Cr && Cr.d();
    }
  };
}
const cBase$o = "flex flex-col", cRowMain = "grid items-center", cRowHeadline = "", cSlotLead = "flex-none flex justify-between items-center", cSlotDefault = "flex-auto", cSlotTrail = "flex-none flex items-center space-x-4";
function instance$J(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, { $$slots: yr = {}, $$scope: _r } = ar;
  const kr = compute_slots(yr);
  let { background: xr = "bg-surface-100-800-token" } = ar, { border: Ar = "" } = ar, { padding: Er = "p-4" } = ar, { shadow: Cr = "" } = ar, { spacing: Tr = "space-y-4" } = ar, { gridColumns: Sr = "grid-cols-[auto_1fr_auto]" } = ar, { gap: Lr = "gap-4" } = ar, { regionRowMain: Ir = "" } = ar, { regionRowHeadline: Nr = "" } = ar, { slotLead: Rr = "" } = ar, { slotDefault: Mr = "" } = ar, { slotTrail: Br = "" } = ar, { label: Dr = "" } = ar, { labelledby: Hr = "" } = ar;
  return cr.$$set = (Fr) => {
    lr(23, ar = assign$1(assign$1({}, ar), exclude_internal_props(Fr))), "background" in Fr && lr(9, xr = Fr.background), "border" in Fr && lr(10, Ar = Fr.border), "padding" in Fr && lr(11, Er = Fr.padding), "shadow" in Fr && lr(12, Cr = Fr.shadow), "spacing" in Fr && lr(13, Tr = Fr.spacing), "gridColumns" in Fr && lr(14, Sr = Fr.gridColumns), "gap" in Fr && lr(15, Lr = Fr.gap), "regionRowMain" in Fr && lr(16, Ir = Fr.regionRowMain), "regionRowHeadline" in Fr && lr(17, Nr = Fr.regionRowHeadline), "slotLead" in Fr && lr(18, Rr = Fr.slotLead), "slotDefault" in Fr && lr(19, Mr = Fr.slotDefault), "slotTrail" in Fr && lr(20, Br = Fr.slotTrail), "label" in Fr && lr(0, Dr = Fr.label), "labelledby" in Fr && lr(1, Hr = Fr.labelledby), "$$scope" in Fr && lr(21, _r = Fr.$$scope);
  }, cr.$$.update = () => {
    var Fr;
    lr(7, ur = `${cBase$o} ${xr} ${Ar} ${Tr} ${Er} ${Cr} ${(Fr = ar.class) != null ? Fr : ""}`), cr.$$.dirty & /*gridColumns, gap, regionRowMain*/
    114688 && lr(6, dr = `${cRowMain} ${Sr} ${Lr} ${Ir}`), cr.$$.dirty & /*regionRowHeadline*/
    131072 && lr(5, fr = `${cRowHeadline} ${Nr}`), cr.$$.dirty & /*slotLead*/
    262144 && lr(4, gr = `${cSlotLead} ${Rr}`), cr.$$.dirty & /*slotDefault*/
    524288 && lr(3, mr = `${cSlotDefault} ${Mr}`), cr.$$.dirty & /*slotTrail*/
    1048576 && lr(2, vr = `${cSlotTrail} ${Br}`);
  }, ar = exclude_internal_props(ar), [
    Dr,
    Hr,
    vr,
    mr,
    gr,
    fr,
    dr,
    ur,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    _r,
    yr
  ];
}
class AppBar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$J, create_fragment$12, safe_not_equal, {
      background: 9,
      border: 10,
      padding: 11,
      shadow: 12,
      spacing: 13,
      gridColumns: 14,
      gap: 15,
      regionRowMain: 16,
      regionRowHeadline: 17,
      slotLead: 18,
      slotDefault: 19,
      slotTrail: 20,
      label: 0,
      labelledby: 1
    });
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[10];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[12];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get gridColumns() {
    return this.$$.ctx[14];
  }
  set gridColumns(ar) {
    this.$$set({ gridColumns: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[15];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionRowMain() {
    return this.$$.ctx[16];
  }
  set regionRowMain(ar) {
    this.$$set({ regionRowMain: ar }), flush();
  }
  get regionRowHeadline() {
    return this.$$.ctx[17];
  }
  set regionRowHeadline(ar) {
    this.$$set({ regionRowHeadline: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[18];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotDefault() {
    return this.$$.ctx[19];
  }
  set slotDefault(ar) {
    this.$$set({ slotDefault: ar }), flush();
  }
  get slotTrail() {
    return this.$$.ctx[20];
  }
  set slotTrail(ar) {
    this.$$set({ slotTrail: ar }), flush();
  }
  get label() {
    return this.$$.ctx[0];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[1];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(AppBar, { background: {}, border: {}, padding: {}, shadow: {}, spacing: {}, gridColumns: {}, gap: {}, regionRowMain: {}, regionRowHeadline: {}, slotLead: {}, slotDefault: {}, slotTrail: {}, label: {}, labelledby: {} }, ["lead", "default", "trail", "headline"], [], !0);
const get_trail_slot_changes$2 = (cr) => ({}), get_trail_slot_context$2 = (cr) => ({}), get_lead_slot_changes$7 = (cr) => ({}), get_lead_slot_context$7 = (cr) => ({});
function create_fragment$11(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr;
  const xr = (
    /*#slots*/
    cr[17].lead
  ), Ar = create_slot(
    xr,
    cr,
    /*$$scope*/
    cr[16],
    get_lead_slot_context$7
  ), Er = (
    /*#slots*/
    cr[17].default
  ), Cr = create_slot(
    Er,
    cr,
    /*$$scope*/
    cr[16],
    null
  ), Tr = (
    /*#slots*/
    cr[17].trail
  ), Sr = create_slot(
    Tr,
    cr,
    /*$$scope*/
    cr[16],
    get_trail_slot_context$2
  );
  return {
    c() {
      ar = element("div"), lr = element("div"), Ar && Ar.c(), dr = space(), fr = element("div"), Cr && Cr.c(), mr = space(), vr = element("div"), Sr && Sr.c(), attr(lr, "class", ur = "app-bar-lead " + /*classesRegionLead*/
      cr[2]), attr(fr, "class", gr = "app-bar-default " + /*classesRegionDefault*/
      cr[1]), attr(vr, "class", yr = "app-bar-trail " + /*classesRegionTrail*/
      cr[0]), attr(ar, "class", _r = "app-rail " + /*classesBase*/
      cr[3]), attr(ar, "data-testid", "app-rail");
    },
    m(Lr, Ir) {
      insert(Lr, ar, Ir), append(ar, lr), Ar && Ar.m(lr, null), append(ar, dr), append(ar, fr), Cr && Cr.m(fr, null), append(ar, mr), append(ar, vr), Sr && Sr.m(vr, null), kr = !0;
    },
    p(Lr, [Ir]) {
      Ar && Ar.p && (!kr || Ir & /*$$scope*/
      65536) && update_slot_base(
        Ar,
        xr,
        Lr,
        /*$$scope*/
        Lr[16],
        kr ? get_slot_changes(
          xr,
          /*$$scope*/
          Lr[16],
          Ir,
          get_lead_slot_changes$7
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Lr[16]
        ),
        get_lead_slot_context$7
      ), (!kr || Ir & /*classesRegionLead*/
      4 && ur !== (ur = "app-bar-lead " + /*classesRegionLead*/
      Lr[2])) && attr(lr, "class", ur), Cr && Cr.p && (!kr || Ir & /*$$scope*/
      65536) && update_slot_base(
        Cr,
        Er,
        Lr,
        /*$$scope*/
        Lr[16],
        kr ? get_slot_changes(
          Er,
          /*$$scope*/
          Lr[16],
          Ir,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Lr[16]
        ),
        null
      ), (!kr || Ir & /*classesRegionDefault*/
      2 && gr !== (gr = "app-bar-default " + /*classesRegionDefault*/
      Lr[1])) && attr(fr, "class", gr), Sr && Sr.p && (!kr || Ir & /*$$scope*/
      65536) && update_slot_base(
        Sr,
        Tr,
        Lr,
        /*$$scope*/
        Lr[16],
        kr ? get_slot_changes(
          Tr,
          /*$$scope*/
          Lr[16],
          Ir,
          get_trail_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Lr[16]
        ),
        get_trail_slot_context$2
      ), (!kr || Ir & /*classesRegionTrail*/
      1 && yr !== (yr = "app-bar-trail " + /*classesRegionTrail*/
      Lr[0])) && attr(vr, "class", yr), (!kr || Ir & /*classesBase*/
      8 && _r !== (_r = "app-rail " + /*classesBase*/
      Lr[3])) && attr(ar, "class", _r);
    },
    i(Lr) {
      kr || (transition_in(Ar, Lr), transition_in(Cr, Lr), transition_in(Sr, Lr), kr = !0);
    },
    o(Lr) {
      transition_out(Ar, Lr), transition_out(Cr, Lr), transition_out(Sr, Lr), kr = !1;
    },
    d(Lr) {
      Lr && detach(ar), Ar && Ar.d(Lr), Cr && Cr.d(Lr), Sr && Sr.d(Lr);
    }
  };
}
const cBase$n = "grid grid-rows-[auto_1fr_auto] overflow-y-auto", cRegionLead$1 = "box-border", cRegionDefault$1 = "box-border", cRegionTrail$1 = "box-border";
function instance$I(cr, ar, lr) {
  let ur, dr, fr, gr, { $$slots: mr = {}, $$scope: vr } = ar, { background: yr = "bg-surface-100-800-token" } = ar, { border: _r = "" } = ar, { width: kr = "w-20" } = ar, { height: xr = "h-full" } = ar, { gap: Ar = "gap-0" } = ar, { regionLead: Er = "" } = ar, { regionDefault: Cr = "" } = ar, { regionTrail: Tr = "" } = ar, { hover: Sr = "bg-primary-hover-token" } = ar, { active: Lr = "bg-primary-active-token" } = ar, { spacing: Ir = "space-y-1" } = ar, { aspectRatio: Nr = "aspect-square" } = ar;
  return setContext("active", Lr), setContext("hover", Sr), setContext("spacing", Ir), setContext("aspectRatio", Nr), cr.$$set = (Rr) => {
    lr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Rr))), "background" in Rr && lr(4, yr = Rr.background), "border" in Rr && lr(5, _r = Rr.border), "width" in Rr && lr(6, kr = Rr.width), "height" in Rr && lr(7, xr = Rr.height), "gap" in Rr && lr(8, Ar = Rr.gap), "regionLead" in Rr && lr(9, Er = Rr.regionLead), "regionDefault" in Rr && lr(10, Cr = Rr.regionDefault), "regionTrail" in Rr && lr(11, Tr = Rr.regionTrail), "hover" in Rr && lr(12, Sr = Rr.hover), "active" in Rr && lr(13, Lr = Rr.active), "spacing" in Rr && lr(14, Ir = Rr.spacing), "aspectRatio" in Rr && lr(15, Nr = Rr.aspectRatio), "$$scope" in Rr && lr(16, vr = Rr.$$scope);
  }, cr.$$.update = () => {
    lr(3, ur = `${cBase$n} ${yr} ${_r} ${kr} ${xr} ${Ar} ${ar.class || ""}`), cr.$$.dirty & /*regionLead*/
    512 && lr(2, dr = `${cRegionLead$1} ${Er}`), cr.$$.dirty & /*regionDefault*/
    1024 && lr(1, fr = `${cRegionDefault$1} ${Cr}`), cr.$$.dirty & /*regionTrail*/
    2048 && lr(0, gr = `${cRegionTrail$1} ${Tr}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    fr,
    dr,
    ur,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    vr,
    mr
  ];
}
class AppRail extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$I, create_fragment$11, safe_not_equal, {
      background: 4,
      border: 5,
      width: 6,
      height: 7,
      gap: 8,
      regionLead: 9,
      regionDefault: 10,
      regionTrail: 11,
      hover: 12,
      active: 13,
      spacing: 14,
      aspectRatio: 15
    });
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[7];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[8];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[9];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[10];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[11];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[12];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[15];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRail, { background: {}, border: {}, width: {}, height: {}, gap: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default", "trail"], [], !0);
const get_lead_slot_changes$6 = (cr) => ({}), get_lead_slot_context$6 = (cr) => ({});
function create_if_block$w(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[23].lead
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[22],
    get_lead_slot_context$6
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "app-rail-lead " + /*classesLead*/
      cr[6]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[22],
          mr,
          get_lead_slot_changes$6
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_lead_slot_context$6
      ), (!ur || mr[0] & /*classesLead*/
      64 && lr !== (lr = "app-rail-lead " + /*classesLead*/
      gr[6])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$10(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr = [
    { type: "radio" },
    { name: (
      /*name*/
      cr[1]
    ) },
    { __value: (
      /*value*/
      cr[2]
    ) },
    /*prunedRestProps*/
    cr[12](),
    { tabindex: "-1" }
  ], Lr = {};
  for (let Mr = 0; Mr < Sr.length; Mr += 1)
    Lr = assign$1(Lr, Sr[Mr]);
  let Ir = (
    /*$$slots*/
    cr[13].lead && create_if_block$w(cr)
  );
  const Nr = (
    /*#slots*/
    cr[23].default
  ), Rr = create_slot(
    Nr,
    cr,
    /*$$scope*/
    cr[22],
    null
  );
  return Er = init_binding_group(
    /*$$binding_groups*/
    cr[34][0]
  ), {
    c() {
      ar = element("label"), lr = element("button"), ur = element("div"), dr = element("input"), fr = space(), gr = element("div"), Ir && Ir.c(), mr = space(), vr = element("div"), Rr && Rr.c(), set_attributes(dr, Lr), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", yr = "app-rail-label " + /*classesLabel*/
      cr[5]), attr(gr, "class", _r = "app-rail-interface " + /*classesInterface*/
      cr[7]), attr(lr, "class", kr = "app-rail-wrapper " + /*classesWrapper*/
      cr[8]), attr(lr, "tabindex", "0"), attr(ar, "class", xr = "app-rail-tile " + /*classesBase*/
      cr[9]), attr(ar, "data-testid", "app-rail-tile"), attr(
        ar,
        "title",
        /*title*/
        cr[3]
      ), Er.p(dr);
    },
    m(Mr, Br) {
      insert(Mr, ar, Br), append(ar, lr), append(lr, ur), append(ur, dr), dr.autofocus && dr.focus(), cr[32](dr), dr.checked = dr.__value === /*group*/
      cr[0], append(lr, fr), append(lr, gr), Ir && Ir.m(gr, null), append(gr, mr), append(gr, vr), Rr && Rr.m(vr, null), Ar = !0, Cr || (Tr = [
        listen(
          dr,
          "change",
          /*input_change_handler*/
          cr[33]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          cr[30]
        ),
        listen(
          dr,
          "change",
          /*change_handler*/
          cr[31]
        ),
        listen(
          lr,
          "click",
          /*selectElemInput*/
          cr[11]
        ),
        listen(
          lr,
          "keydown",
          /*onKeyDown*/
          cr[10]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[28]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[29]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          cr[24]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          cr[25]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          cr[26]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          cr[27]
        )
      ], Cr = !0);
    },
    p(Mr, Br) {
      set_attributes(dr, Lr = get_spread_update(Sr, [
        { type: "radio" },
        (!Ar || Br[0] & /*name*/
        2) && { name: (
          /*name*/
          Mr[1]
        ) },
        (!Ar || Br[0] & /*value*/
        4) && { __value: (
          /*value*/
          Mr[2]
        ) },
        /*prunedRestProps*/
        Mr[12](),
        { tabindex: "-1" }
      ])), Br[0] & /*group*/
      1 && (dr.checked = dr.__value === /*group*/
      Mr[0]), /*$$slots*/
      Mr[13].lead ? Ir ? (Ir.p(Mr, Br), Br[0] & /*$$slots*/
      8192 && transition_in(Ir, 1)) : (Ir = create_if_block$w(Mr), Ir.c(), transition_in(Ir, 1), Ir.m(gr, mr)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Rr && Rr.p && (!Ar || Br[0] & /*$$scope*/
      4194304) && update_slot_base(
        Rr,
        Nr,
        Mr,
        /*$$scope*/
        Mr[22],
        Ar ? get_slot_changes(
          Nr,
          /*$$scope*/
          Mr[22],
          Br,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Mr[22]
        ),
        null
      ), (!Ar || Br[0] & /*classesLabel*/
      32 && yr !== (yr = "app-rail-label " + /*classesLabel*/
      Mr[5])) && attr(vr, "class", yr), (!Ar || Br[0] & /*classesInterface*/
      128 && _r !== (_r = "app-rail-interface " + /*classesInterface*/
      Mr[7])) && attr(gr, "class", _r), (!Ar || Br[0] & /*classesWrapper*/
      256 && kr !== (kr = "app-rail-wrapper " + /*classesWrapper*/
      Mr[8])) && attr(lr, "class", kr), (!Ar || Br[0] & /*classesBase*/
      512 && xr !== (xr = "app-rail-tile " + /*classesBase*/
      Mr[9])) && attr(ar, "class", xr), (!Ar || Br[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        Mr[3]
      );
    },
    i(Mr) {
      Ar || (transition_in(Ir), transition_in(Rr, Mr), Ar = !0);
    },
    o(Mr) {
      transition_out(Ir), transition_out(Rr, Mr), Ar = !1;
    },
    d(Mr) {
      Mr && detach(ar), cr[32](null), Ir && Ir.d(), Rr && Rr.d(Mr), Er.r(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$m = "cursor-pointer", cWrapper$3 = "flex flex-col justify-center items-stretch w-full", cInterface$3 = "text-center", cLabel$4 = "font-bold text-xs";
function instance$H(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr;
  const yr = [
    "group",
    "name",
    "value",
    "title",
    "regionLead",
    "regionLabel",
    "hover",
    "active",
    "spacing",
    "width",
    "aspectRatio"
  ];
  let _r = compute_rest_props(ar, yr), { $$slots: kr = {}, $$scope: xr } = ar;
  const Ar = compute_slots(kr);
  let { group: Er } = ar, { name: Cr } = ar, { value: Tr } = ar, { title: Sr = "" } = ar, { regionLead: Lr = "" } = ar, { regionLabel: Ir = "" } = ar, { hover: Nr = getContext("hover") } = ar, { active: Rr = getContext("active") } = ar, { spacing: Mr = getContext("spacing") } = ar, { width: Br = getContext("width") } = ar, { aspectRatio: Dr = getContext("aspectRatio") } = ar, Hr;
  function Fr(Zr) {
    ["Enter", "Space"].includes(Zr.code) && (Zr.preventDefault(), zr());
  }
  function zr() {
    Hr.click();
  }
  function Ur() {
    return delete _r.class, _r;
  }
  const jr = [[]];
  function Yr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function qr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Wr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Jr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Gr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Vr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Qr(Zr) {
    bubble.call(this, cr, Zr);
  }
  function $r(Zr) {
    bubble.call(this, cr, Zr);
  }
  function Xr(Zr) {
    binding_callbacks[Zr ? "unshift" : "push"](() => {
      Hr = Zr, lr(4, Hr);
    });
  }
  function si() {
    Er = this.__value, lr(0, Er);
  }
  return cr.$$set = (Zr) => {
    lr(36, ar = assign$1(assign$1({}, ar), exclude_internal_props(Zr))), lr(35, _r = compute_rest_props(ar, yr)), "group" in Zr && lr(0, Er = Zr.group), "name" in Zr && lr(1, Cr = Zr.name), "value" in Zr && lr(2, Tr = Zr.value), "title" in Zr && lr(3, Sr = Zr.title), "regionLead" in Zr && lr(14, Lr = Zr.regionLead), "regionLabel" in Zr && lr(15, Ir = Zr.regionLabel), "hover" in Zr && lr(16, Nr = Zr.hover), "active" in Zr && lr(17, Rr = Zr.active), "spacing" in Zr && lr(18, Mr = Zr.spacing), "width" in Zr && lr(19, Br = Zr.width), "aspectRatio" in Zr && lr(20, Dr = Zr.aspectRatio), "$$scope" in Zr && lr(22, xr = Zr.$$scope);
  }, cr.$$.update = () => {
    cr.$$.dirty[0] & /*group, value, active*/
    131077 && lr(21, ur = Er === Tr ? Rr : ""), lr(9, dr = `${cBase$m} ${ar.class || ""}`), cr.$$.dirty[0] & /*aspectRatio, width, hover, classActive*/
    3735552 && lr(8, fr = `${cWrapper$3} ${Dr} ${Br} ${Nr} ${ur}`), cr.$$.dirty[0] & /*spacing*/
    262144 && lr(7, gr = `${cInterface$3} ${Mr}`), cr.$$.dirty[0] & /*regionLead*/
    16384 && lr(6, mr = `${Lr}`), cr.$$.dirty[0] & /*regionLabel*/
    32768 && lr(5, vr = `${cLabel$4} ${Ir}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Cr,
    Tr,
    Sr,
    Hr,
    vr,
    mr,
    gr,
    fr,
    dr,
    Fr,
    zr,
    Ur,
    Ar,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    ur,
    xr,
    kr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr,
    $r,
    Xr,
    si,
    jr
  ];
}
class AppRailTile extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$H,
      create_fragment$10,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        regionLead: 14,
        regionLabel: 15,
        hover: 16,
        active: 17,
        spacing: 18,
        width: 19,
        aspectRatio: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[14];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[15];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[17];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[18];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[20];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailTile, { group: {}, name: {}, value: {}, title: {}, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, width: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$5 = (cr) => ({}), get_lead_slot_context$5 = (cr) => ({});
function create_if_block$v(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[16].lead
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[15],
    get_lead_slot_context$5
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "app-rail-lead " + /*classesLead*/
      cr[1]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      32768) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[15],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[15],
          mr,
          get_lead_slot_changes$5
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[15]
        ),
        get_lead_slot_context$5
      ), (!ur || mr & /*classesLead*/
      2 && lr !== (lr = "app-rail-lead " + /*classesLead*/
      gr[1])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$$(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr = (
    /*$$slots*/
    cr[6].lead && create_if_block$v(cr)
  );
  const Ar = (
    /*#slots*/
    cr[16].default
  ), Er = create_slot(
    Ar,
    cr,
    /*$$scope*/
    cr[15],
    null
  );
  let Cr = [
    {
      class: mr = "app-rail-anchor " + /*classesBase*/
      cr[3]
    },
    {
      href: vr = /*$$props*/
      cr[5].href
    },
    /*prunedRestProps*/
    cr[4](),
    { "data-testid": "app-rail-anchor" }
  ], Tr = {};
  for (let Sr = 0; Sr < Cr.length; Sr += 1)
    Tr = assign$1(Tr, Cr[Sr]);
  return {
    c() {
      ar = element("a"), lr = element("div"), xr && xr.c(), ur = space(), dr = element("div"), Er && Er.c(), attr(dr, "class", fr = "app-rail-label " + /*classesLabel*/
      cr[0]), attr(lr, "class", gr = "app-rail-wrapper " + /*classesWrapper*/
      cr[2]), set_attributes(ar, Tr);
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), xr && xr.m(lr, null), append(lr, ur), append(lr, dr), Er && Er.m(dr, null), yr = !0, _r || (kr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[17]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          cr[18]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          cr[19]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[20]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          cr[21]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          cr[22]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          cr[23]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          cr[24]
        )
      ], _r = !0);
    },
    p(Sr, [Lr]) {
      /*$$slots*/
      Sr[6].lead ? xr ? (xr.p(Sr, Lr), Lr & /*$$slots*/
      64 && transition_in(xr, 1)) : (xr = create_if_block$v(Sr), xr.c(), transition_in(xr, 1), xr.m(lr, ur)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), Er && Er.p && (!yr || Lr & /*$$scope*/
      32768) && update_slot_base(
        Er,
        Ar,
        Sr,
        /*$$scope*/
        Sr[15],
        yr ? get_slot_changes(
          Ar,
          /*$$scope*/
          Sr[15],
          Lr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Sr[15]
        ),
        null
      ), (!yr || Lr & /*classesLabel*/
      1 && fr !== (fr = "app-rail-label " + /*classesLabel*/
      Sr[0])) && attr(dr, "class", fr), (!yr || Lr & /*classesWrapper*/
      4 && gr !== (gr = "app-rail-wrapper " + /*classesWrapper*/
      Sr[2])) && attr(lr, "class", gr), set_attributes(ar, Tr = get_spread_update(Cr, [
        (!yr || Lr & /*classesBase*/
        8 && mr !== (mr = "app-rail-anchor " + /*classesBase*/
        Sr[3])) && { class: mr },
        (!yr || Lr & /*$$props*/
        32 && vr !== (vr = /*$$props*/
        Sr[5].href)) && { href: vr },
        /*prunedRestProps*/
        Sr[4](),
        { "data-testid": "app-rail-anchor" }
      ]));
    },
    i(Sr) {
      yr || (transition_in(xr), transition_in(Er, Sr), yr = !0);
    },
    o(Sr) {
      transition_out(xr), transition_out(Er, Sr), yr = !1;
    },
    d(Sr) {
      Sr && detach(ar), xr && xr.d(), Er && Er.d(Sr), _r = !1, run_all(kr);
    }
  };
}
const cBase$l = "unstyled", cWrapper$2 = "w-full flex flex-col justify-center items-stretch text-center space-y-1", cLabel$3 = "font-bold text-xs";
function instance$G(cr, ar, lr) {
  let ur, dr, fr, gr, mr;
  const vr = ["selected", "regionLead", "regionLabel", "hover", "active", "spacing", "aspectRatio"];
  let yr = compute_rest_props(ar, vr), { $$slots: _r = {}, $$scope: kr } = ar;
  const xr = compute_slots(_r);
  let { selected: Ar = !1 } = ar, { regionLead: Er = "flex justify-center items-center" } = ar, { regionLabel: Cr = "" } = ar, { hover: Tr = getContext("hover") } = ar, { active: Sr = getContext("active") } = ar, { spacing: Lr = getContext("spacing") } = ar, { aspectRatio: Ir = getContext("aspectRatio") } = ar;
  function Nr() {
    return delete yr.class, yr;
  }
  function Rr(jr) {
    bubble.call(this, cr, jr);
  }
  function Mr(jr) {
    bubble.call(this, cr, jr);
  }
  function Br(jr) {
    bubble.call(this, cr, jr);
  }
  function Dr(jr) {
    bubble.call(this, cr, jr);
  }
  function Hr(jr) {
    bubble.call(this, cr, jr);
  }
  function Fr(jr) {
    bubble.call(this, cr, jr);
  }
  function zr(jr) {
    bubble.call(this, cr, jr);
  }
  function Ur(jr) {
    bubble.call(this, cr, jr);
  }
  return cr.$$set = (jr) => {
    lr(5, ar = assign$1(assign$1({}, ar), exclude_internal_props(jr))), lr(25, yr = compute_rest_props(ar, vr)), "selected" in jr && lr(7, Ar = jr.selected), "regionLead" in jr && lr(8, Er = jr.regionLead), "regionLabel" in jr && lr(9, Cr = jr.regionLabel), "hover" in jr && lr(10, Tr = jr.hover), "active" in jr && lr(11, Sr = jr.active), "spacing" in jr && lr(12, Lr = jr.spacing), "aspectRatio" in jr && lr(13, Ir = jr.aspectRatio), "$$scope" in jr && lr(15, kr = jr.$$scope);
  }, cr.$$.update = () => {
    cr.$$.dirty & /*selected, active*/
    2176 && lr(14, ur = Ar ? Sr : ""), lr(3, dr = `${cBase$l} ${ar.class || ""}`), cr.$$.dirty & /*aspectRatio, hover, spacing, classActive*/
    29696 && lr(2, fr = `${cWrapper$2} ${Ir} ${Tr} ${Lr} ${ur}`), cr.$$.dirty & /*regionLead*/
    256 && lr(1, gr = `${Er}`), cr.$$.dirty & /*regionLabel*/
    512 && lr(0, mr = `${cLabel$3} ${Cr}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    gr,
    fr,
    dr,
    Nr,
    ar,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    ur,
    kr,
    _r,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur
  ];
}
class AppRailAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$G, create_fragment$$, safe_not_equal, {
      selected: 7,
      regionLead: 8,
      regionLabel: 9,
      hover: 10,
      active: 11,
      spacing: 12,
      aspectRatio: 13
    });
  }
  get selected() {
    return this.$$.ctx[7];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[9];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[10];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get active() {
    return this.$$.ctx[11];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get aspectRatio() {
    return this.$$.ctx[13];
  }
  set aspectRatio(ar) {
    this.$$set({ aspectRatio: ar }), flush();
  }
}
create_custom_element(AppRailAnchor, { selected: { type: "Boolean" }, regionLead: {}, regionLabel: {}, hover: {}, active: {}, spacing: {}, aspectRatio: {} }, ["lead", "default"], [], !0);
const get_footer_slot_changes = (cr) => ({}), get_footer_slot_context = (cr) => ({}), get_sidebarRight_slot_changes = (cr) => ({}), get_sidebarRight_slot_context = (cr) => ({}), get_pageFooter_slot_changes = (cr) => ({}), get_pageFooter_slot_context = (cr) => ({}), get_pageHeader_slot_changes = (cr) => ({}), get_pageHeader_slot_context = (cr) => ({}), get_sidebarLeft_slot_changes = (cr) => ({}), get_sidebarLeft_slot_context = (cr) => ({}), get_header_slot_changes$1 = (cr) => ({}), get_header_slot_context$1 = (cr) => ({});
function create_if_block_5$4(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[19].header
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[18],
    get_header_slot_context$1
  );
  return {
    c() {
      ar = element("header"), fr && fr.c(), attr(ar, "id", "shell-header"), attr(ar, "class", lr = "flex-none " + /*classesHeader*/
      cr[8]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[18],
          mr,
          get_header_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_header_slot_context$1
      ), (!ur || mr & /*classesHeader*/
      256 && lr !== (lr = "flex-none " + /*classesHeader*/
      gr[8])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_if_block_4$6(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[19].sidebarLeft
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[18],
    get_sidebarLeft_slot_context
  );
  return {
    c() {
      ar = element("aside"), dr && dr.c(), attr(ar, "id", "sidebar-left"), attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        cr[7]
      );
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[18],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[18],
          gr,
          get_sidebarLeft_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[18]
        ),
        get_sidebarLeft_slot_context
      ), (!lr || gr & /*classesSidebarLeft*/
      128) && attr(
        ar,
        "class",
        /*classesSidebarLeft*/
        fr[7]
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_if_block_3$8(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[19].pageHeader
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[18],
    get_pageHeader_slot_context
  ), gr = fr || fallback_block_1$1();
  return {
    c() {
      ar = element("header"), gr && gr.c(), attr(ar, "id", "page-header"), attr(ar, "class", lr = "flex-none " + /*classesPageHeader*/
      cr[5]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), gr && gr.m(ar, null), ur = !0;
    },
    p(mr, vr) {
      fr && fr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        dr,
        mr,
        /*$$scope*/
        mr[18],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          mr[18],
          vr,
          get_pageHeader_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          mr[18]
        ),
        get_pageHeader_slot_context
      ), (!ur || vr & /*classesPageHeader*/
      32 && lr !== (lr = "flex-none " + /*classesPageHeader*/
      mr[5])) && attr(ar, "class", lr);
    },
    i(mr) {
      ur || (transition_in(gr, mr), ur = !0);
    },
    o(mr) {
      transition_out(gr, mr), ur = !1;
    },
    d(mr) {
      mr && detach(ar), gr && gr.d(mr);
    }
  };
}
function fallback_block_1$1(cr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:header)");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_if_block_2$c(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[19].pageFooter
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[18],
    get_pageFooter_slot_context
  ), gr = fr || fallback_block$4();
  return {
    c() {
      ar = element("footer"), gr && gr.c(), attr(ar, "id", "page-footer"), attr(ar, "class", lr = "flex-none " + /*classesPageFooter*/
      cr[3]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), gr && gr.m(ar, null), ur = !0;
    },
    p(mr, vr) {
      fr && fr.p && (!ur || vr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        dr,
        mr,
        /*$$scope*/
        mr[18],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          mr[18],
          vr,
          get_pageFooter_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          mr[18]
        ),
        get_pageFooter_slot_context
      ), (!ur || vr & /*classesPageFooter*/
      8 && lr !== (lr = "flex-none " + /*classesPageFooter*/
      mr[3])) && attr(ar, "class", lr);
    },
    i(mr) {
      ur || (transition_in(gr, mr), ur = !0);
    },
    o(mr) {
      transition_out(gr, mr), ur = !1;
    },
    d(mr) {
      mr && detach(ar), gr && gr.d(mr);
    }
  };
}
function fallback_block$4(cr) {
  let ar;
  return {
    c() {
      ar = text$3("(slot:footer)");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_if_block_1$f(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[19].sidebarRight
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[18],
    get_sidebarRight_slot_context
  );
  return {
    c() {
      ar = element("aside"), dr && dr.c(), attr(ar, "id", "sidebar-right"), attr(
        ar,
        "class",
        /*classesSidebarRight*/
        cr[6]
      );
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr & /*$$scope*/
      262144) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[18],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[18],
          gr,
          get_sidebarRight_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[18]
        ),
        get_sidebarRight_slot_context
      ), (!lr || gr & /*classesSidebarRight*/
      64) && attr(
        ar,
        "class",
        /*classesSidebarRight*/
        fr[6]
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_if_block$u(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[19].footer
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[18],
    get_footer_slot_context
  );
  return {
    c() {
      ar = element("footer"), fr && fr.c(), attr(ar, "id", "shell-footer"), attr(ar, "class", lr = "flex-none " + /*classesFooter*/
      cr[2]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      262144) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[18],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[18],
          mr,
          get_footer_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[18]
        ),
        get_footer_slot_context
      ), (!ur || mr & /*classesFooter*/
      4 && lr !== (lr = "flex-none " + /*classesFooter*/
      gr[2])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$_(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr = (
    /*$$slots*/
    cr[10].header && create_if_block_5$4(cr)
  ), Sr = (
    /*$$slots*/
    cr[10].sidebarLeft && create_if_block_4$6(cr)
  ), Lr = (
    /*$$slots*/
    cr[10].pageHeader && create_if_block_3$8(cr)
  );
  const Ir = (
    /*#slots*/
    cr[19].default
  ), Nr = create_slot(
    Ir,
    cr,
    /*$$scope*/
    cr[18],
    null
  );
  let Rr = (
    /*$$slots*/
    cr[10].pageFooter && create_if_block_2$c(cr)
  ), Mr = (
    /*$$slots*/
    cr[10].sidebarRight && create_if_block_1$f(cr)
  ), Br = (
    /*$$slots*/
    cr[10].footer && create_if_block$u(cr)
  );
  return {
    c() {
      ar = element("div"), Tr && Tr.c(), lr = space(), ur = element("div"), Sr && Sr.c(), dr = space(), fr = element("div"), Lr && Lr.c(), gr = space(), mr = element("main"), Nr && Nr.c(), yr = space(), Rr && Rr.c(), kr = space(), Mr && Mr.c(), xr = space(), Br && Br.c(), attr(mr, "id", "page-content"), attr(mr, "class", vr = "flex-auto " + /*classesPageContent*/
      cr[4]), attr(fr, "id", "page"), attr(fr, "class", _r = /*regionPage*/
      cr[1] + " " + cPage), set_style(
        fr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        cr[0]
      ), attr(ur, "class", "flex-auto " + cContentArea), attr(ar, "id", "appShell"), attr(
        ar,
        "class",
        /*classesBase*/
        cr[9]
      ), attr(ar, "data-testid", "app-shell");
    },
    m(Dr, Hr) {
      insert(Dr, ar, Hr), Tr && Tr.m(ar, null), append(ar, lr), append(ar, ur), Sr && Sr.m(ur, null), append(ur, dr), append(ur, fr), Lr && Lr.m(fr, null), append(fr, gr), append(fr, mr), Nr && Nr.m(mr, null), append(fr, yr), Rr && Rr.m(fr, null), append(ur, kr), Mr && Mr.m(ur, null), append(ar, xr), Br && Br.m(ar, null), Ar = !0, Er || (Cr = listen(
        fr,
        "scroll",
        /*scroll_handler*/
        cr[20]
      ), Er = !0);
    },
    p(Dr, [Hr]) {
      /*$$slots*/
      Dr[10].header ? Tr ? (Tr.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Tr, 1)) : (Tr = create_if_block_5$4(Dr), Tr.c(), transition_in(Tr, 1), Tr.m(ar, lr)) : Tr && (group_outros(), transition_out(Tr, 1, 1, () => {
        Tr = null;
      }), check_outros()), /*$$slots*/
      Dr[10].sidebarLeft ? Sr ? (Sr.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Sr, 1)) : (Sr = create_if_block_4$6(Dr), Sr.c(), transition_in(Sr, 1), Sr.m(ur, dr)) : Sr && (group_outros(), transition_out(Sr, 1, 1, () => {
        Sr = null;
      }), check_outros()), /*$$slots*/
      Dr[10].pageHeader ? Lr ? (Lr.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Lr, 1)) : (Lr = create_if_block_3$8(Dr), Lr.c(), transition_in(Lr, 1), Lr.m(fr, gr)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!Ar || Hr & /*$$scope*/
      262144) && update_slot_base(
        Nr,
        Ir,
        Dr,
        /*$$scope*/
        Dr[18],
        Ar ? get_slot_changes(
          Ir,
          /*$$scope*/
          Dr[18],
          Hr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Dr[18]
        ),
        null
      ), (!Ar || Hr & /*classesPageContent*/
      16 && vr !== (vr = "flex-auto " + /*classesPageContent*/
      Dr[4])) && attr(mr, "class", vr), /*$$slots*/
      Dr[10].pageFooter ? Rr ? (Rr.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Rr, 1)) : (Rr = create_if_block_2$c(Dr), Rr.c(), transition_in(Rr, 1), Rr.m(fr, null)) : Rr && (group_outros(), transition_out(Rr, 1, 1, () => {
        Rr = null;
      }), check_outros()), (!Ar || Hr & /*regionPage*/
      2 && _r !== (_r = /*regionPage*/
      Dr[1] + " " + cPage)) && attr(fr, "class", _r), Hr & /*scrollbarGutter*/
      1 && set_style(
        fr,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        Dr[0]
      ), /*$$slots*/
      Dr[10].sidebarRight ? Mr ? (Mr.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Mr, 1)) : (Mr = create_if_block_1$f(Dr), Mr.c(), transition_in(Mr, 1), Mr.m(ur, null)) : Mr && (group_outros(), transition_out(Mr, 1, 1, () => {
        Mr = null;
      }), check_outros()), /*$$slots*/
      Dr[10].footer ? Br ? (Br.p(Dr, Hr), Hr & /*$$slots*/
      1024 && transition_in(Br, 1)) : (Br = create_if_block$u(Dr), Br.c(), transition_in(Br, 1), Br.m(ar, null)) : Br && (group_outros(), transition_out(Br, 1, 1, () => {
        Br = null;
      }), check_outros()), (!Ar || Hr & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Dr[9]
      );
    },
    i(Dr) {
      Ar || (transition_in(Tr), transition_in(Sr), transition_in(Lr), transition_in(Nr, Dr), transition_in(Rr), transition_in(Mr), transition_in(Br), Ar = !0);
    },
    o(Dr) {
      transition_out(Tr), transition_out(Sr), transition_out(Lr), transition_out(Nr, Dr), transition_out(Rr), transition_out(Mr), transition_out(Br), Ar = !1;
    },
    d(Dr) {
      Dr && detach(ar), Tr && Tr.d(), Sr && Sr.d(), Lr && Lr.d(), Nr && Nr.d(Dr), Rr && Rr.d(), Mr && Mr.d(), Br && Br.d(), Er = !1, Cr();
    }
  };
}
const cBaseAppShell = "w-full h-full flex flex-col overflow-hidden", cContentArea = "w-full h-full flex overflow-hidden", cPage = "flex-1 overflow-x-hidden flex flex-col", cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto", cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance$F(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r, { $$slots: kr = {}, $$scope: xr } = ar;
  const Ar = compute_slots(kr);
  let { scrollbarGutter: Er = "auto" } = ar, { regionPage: Cr = "" } = ar, { slotHeader: Tr = "z-10" } = ar, { slotSidebarLeft: Sr = "w-auto" } = ar, { slotSidebarRight: Lr = "w-auto" } = ar, { slotPageHeader: Ir = "" } = ar, { slotPageContent: Nr = "" } = ar, { slotPageFooter: Rr = "" } = ar, { slotFooter: Mr = "" } = ar;
  function Br(Dr) {
    bubble.call(this, cr, Dr);
  }
  return cr.$$set = (Dr) => {
    lr(21, ar = assign$1(assign$1({}, ar), exclude_internal_props(Dr))), "scrollbarGutter" in Dr && lr(0, Er = Dr.scrollbarGutter), "regionPage" in Dr && lr(1, Cr = Dr.regionPage), "slotHeader" in Dr && lr(11, Tr = Dr.slotHeader), "slotSidebarLeft" in Dr && lr(12, Sr = Dr.slotSidebarLeft), "slotSidebarRight" in Dr && lr(13, Lr = Dr.slotSidebarRight), "slotPageHeader" in Dr && lr(14, Ir = Dr.slotPageHeader), "slotPageContent" in Dr && lr(15, Nr = Dr.slotPageContent), "slotPageFooter" in Dr && lr(16, Rr = Dr.slotPageFooter), "slotFooter" in Dr && lr(17, Mr = Dr.slotFooter), "$$scope" in Dr && lr(18, xr = Dr.$$scope);
  }, cr.$$.update = () => {
    var Dr;
    lr(9, ur = `${cBaseAppShell} ${(Dr = ar.class) != null ? Dr : ""}`), cr.$$.dirty & /*slotHeader*/
    2048 && lr(8, dr = `${Tr}`), cr.$$.dirty & /*slotSidebarLeft*/
    4096 && lr(7, fr = `${cSidebarLeft} ${Sr}`), cr.$$.dirty & /*slotSidebarRight*/
    8192 && lr(6, gr = `${cSidebarRight} ${Lr}`), cr.$$.dirty & /*slotPageHeader*/
    16384 && lr(5, mr = `${Ir}`), cr.$$.dirty & /*slotPageContent*/
    32768 && lr(4, vr = `${Nr}`), cr.$$.dirty & /*slotPageFooter*/
    65536 && lr(3, yr = `${Rr}`), cr.$$.dirty & /*slotFooter*/
    131072 && lr(2, _r = `${Mr}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Cr,
    _r,
    yr,
    vr,
    mr,
    gr,
    fr,
    dr,
    ur,
    Ar,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    xr,
    kr,
    Br
  ];
}
class AppShell extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$F, create_fragment$_, safe_not_equal, {
      scrollbarGutter: 0,
      regionPage: 1,
      slotHeader: 11,
      slotSidebarLeft: 12,
      slotSidebarRight: 13,
      slotPageHeader: 14,
      slotPageContent: 15,
      slotPageFooter: 16,
      slotFooter: 17
    });
  }
  get scrollbarGutter() {
    return this.$$.ctx[0];
  }
  set scrollbarGutter(ar) {
    this.$$set({ scrollbarGutter: ar }), flush();
  }
  get regionPage() {
    return this.$$.ctx[1];
  }
  set regionPage(ar) {
    this.$$set({ regionPage: ar }), flush();
  }
  get slotHeader() {
    return this.$$.ctx[11];
  }
  set slotHeader(ar) {
    this.$$set({ slotHeader: ar }), flush();
  }
  get slotSidebarLeft() {
    return this.$$.ctx[12];
  }
  set slotSidebarLeft(ar) {
    this.$$set({ slotSidebarLeft: ar }), flush();
  }
  get slotSidebarRight() {
    return this.$$.ctx[13];
  }
  set slotSidebarRight(ar) {
    this.$$set({ slotSidebarRight: ar }), flush();
  }
  get slotPageHeader() {
    return this.$$.ctx[14];
  }
  set slotPageHeader(ar) {
    this.$$set({ slotPageHeader: ar }), flush();
  }
  get slotPageContent() {
    return this.$$.ctx[15];
  }
  set slotPageContent(ar) {
    this.$$set({ slotPageContent: ar }), flush();
  }
  get slotPageFooter() {
    return this.$$.ctx[16];
  }
  set slotPageFooter(ar) {
    this.$$set({ slotPageFooter: ar }), flush();
  }
  get slotFooter() {
    return this.$$.ctx[17];
  }
  set slotFooter(ar) {
    this.$$set({ slotFooter: ar }), flush();
  }
}
create_custom_element(
  AppShell,
  { scrollbarGutter: {}, regionPage: {}, slotHeader: {}, slotSidebarLeft: {}, slotSidebarRight: {}, slotPageHeader: {}, slotPageContent: {}, slotPageFooter: {}, slotFooter: {} },
  [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ],
  [],
  !0
);
function get_each_context$c(cr, ar, lr) {
  const ur = cr.slice();
  return ur[35] = ar[lr], ur;
}
function create_else_block$d(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("div"), lr = text$3(
        /*emptyState*/
        cr[0]
      ), attr(ar, "class", ur = "autocomplete-empty " + /*classesEmpty*/
      cr[7]);
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr);
    },
    p(dr, fr) {
      fr[0] & /*emptyState*/
      1 && set_data(
        lr,
        /*emptyState*/
        dr[0]
      ), fr[0] & /*classesEmpty*/
      128 && ur !== (ur = "autocomplete-empty " + /*classesEmpty*/
      dr[7]) && attr(ar, "class", ur);
    },
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block$t(cr) {
  let ar, lr, ur = [], dr = /* @__PURE__ */ new Map(), fr, gr, mr, vr = ensure_array_like(
    /*optionsFiltered*/
    cr[6].slice(
      0,
      /*sliceLimit*/
      cr[13]
    )
  );
  const yr = (_r) => (
    /*option*/
    _r[35]
  );
  for (let _r = 0; _r < vr.length; _r += 1) {
    let kr = get_each_context$c(cr, vr, _r), xr = yr(kr);
    dr.set(xr, ur[_r] = create_each_block$c(xr, kr));
  }
  return {
    c() {
      ar = element("nav"), lr = element("ul");
      for (let _r = 0; _r < ur.length; _r += 1)
        ur[_r].c();
      attr(lr, "class", fr = "autocomplete-list " + /*classesList*/
      cr[10]), attr(ar, "class", gr = "autocomplete-nav " + /*classesNav*/
      cr[11]);
    },
    m(_r, kr) {
      insert(_r, ar, kr), append(ar, lr);
      for (let xr = 0; xr < ur.length; xr += 1)
        ur[xr] && ur[xr].m(lr, null);
      mr = !0;
    },
    p(_r, kr) {
      kr[0] & /*classesItem, transitionOut, transitionOutParams, transitions, classesButton, onSelection, optionsFiltered, sliceLimit*/
      25458 && (vr = ensure_array_like(
        /*optionsFiltered*/
        _r[6].slice(
          0,
          /*sliceLimit*/
          _r[13]
        )
      ), group_outros(), ur = update_keyed_each(ur, kr, yr, 1, _r, vr, dr, lr, outro_and_destroy_block, create_each_block$c, null, get_each_context$c), check_outros()), (!mr || kr[0] & /*classesList*/
      1024 && fr !== (fr = "autocomplete-list " + /*classesList*/
      _r[10])) && attr(lr, "class", fr), (!mr || kr[0] & /*classesNav*/
      2048 && gr !== (gr = "autocomplete-nav " + /*classesNav*/
      _r[11])) && attr(ar, "class", gr);
    },
    i(_r) {
      if (!mr) {
        for (let kr = 0; kr < vr.length; kr += 1)
          transition_in(ur[kr]);
        mr = !0;
      }
    },
    o(_r) {
      for (let kr = 0; kr < ur.length; kr += 1)
        transition_out(ur[kr]);
      mr = !1;
    },
    d(_r) {
      _r && detach(ar);
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr].d();
    }
  };
}
function create_each_block$c(cr, ar) {
  let lr, ur, dr = (
    /*option*/
    ar[35].label + ""
  ), fr, gr, mr, vr, yr, _r, kr, xr;
  function Ar() {
    return (
      /*click_handler_1*/
      ar[29](
        /*option*/
        ar[35]
      )
    );
  }
  return {
    key: cr,
    first: null,
    c() {
      lr = element("li"), ur = element("button"), gr = space(), attr(ur, "class", fr = "autocomplete-button " + /*classesButton*/
      ar[8]), attr(ur, "type", "button"), attr(lr, "class", mr = "autocomplete-item " + /*classesItem*/
      ar[9]), this.first = lr;
    },
    m(Er, Cr) {
      insert(Er, lr, Cr), append(lr, ur), ur.innerHTML = dr, append(lr, gr), _r = !0, kr || (xr = [
        listen(ur, "click", Ar),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[27]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[28]
        )
      ], kr = !0);
    },
    p(Er, Cr) {
      ar = Er, (!_r || Cr[0] & /*optionsFiltered, sliceLimit*/
      8256) && dr !== (dr = /*option*/
      ar[35].label + "") && (ur.innerHTML = dr), (!_r || Cr[0] & /*classesButton*/
      256 && fr !== (fr = "autocomplete-button " + /*classesButton*/
      ar[8])) && attr(ur, "class", fr), (!_r || Cr[0] & /*classesItem*/
      512 && mr !== (mr = "autocomplete-item " + /*classesItem*/
      ar[9])) && attr(lr, "class", mr);
    },
    i(Er) {
      _r || (Er && add_render_callback(() => {
        _r && (yr && yr.end(1), vr = create_in_transition(lr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[2]
          ),
          params: (
            /*transitionInParams*/
            ar[3]
          ),
          enabled: (
            /*transitions*/
            ar[1]
          )
        }), vr.start());
      }), _r = !0);
    },
    o(Er) {
      vr && vr.invalidate(), Er && (yr = create_out_transition(lr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[4]
        ),
        params: (
          /*transitionOutParams*/
          ar[5]
        ),
        enabled: (
          /*transitions*/
          ar[1]
        )
      })), _r = !1;
    },
    d(Er) {
      Er && detach(lr), Er && yr && yr.end(), kr = !1, run_all(xr);
    }
  };
}
function create_fragment$Z(cr) {
  let ar, lr, ur, dr, fr;
  const gr = [create_if_block$t, create_else_block$d], mr = [];
  function vr(yr, _r) {
    return (
      /*optionsFiltered*/
      yr[6].length > 0 ? 0 : 1
    );
  }
  return lr = vr(cr), ur = mr[lr] = gr[lr](cr), {
    c() {
      ar = element("div"), ur.c(), attr(ar, "class", dr = "autocomplete " + /*classesBase*/
      cr[12]), attr(ar, "data-testid", "autocomplete");
    },
    m(yr, _r) {
      insert(yr, ar, _r), mr[lr].m(ar, null), fr = !0;
    },
    p(yr, _r) {
      let kr = lr;
      lr = vr(yr), lr === kr ? mr[lr].p(yr, _r) : (group_outros(), transition_out(mr[kr], 1, 1, () => {
        mr[kr] = null;
      }), check_outros(), ur = mr[lr], ur ? ur.p(yr, _r) : (ur = mr[lr] = gr[lr](yr), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!fr || _r[0] & /*classesBase*/
      4096 && dr !== (dr = "autocomplete " + /*classesBase*/
      yr[12])) && attr(ar, "class", dr);
    },
    i(yr) {
      fr || (transition_in(ur), fr = !0);
    },
    o(yr) {
      transition_out(ur), fr = !1;
    },
    d(yr) {
      yr && detach(ar), mr[lr].d();
    }
  };
}
function instance$E(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r, kr, xr;
  component_subscribe(cr, prefersReducedMotionStore, ($r) => lr(30, xr = $r));
  const Ar = createEventDispatcher();
  let { input: Er = void 0 } = ar, { options: Cr = [] } = ar, { limit: Tr = void 0 } = ar, { allowlist: Sr = [] } = ar, { denylist: Lr = [] } = ar, { emptyState: Ir = "No Results Found." } = ar, { regionNav: Nr = "" } = ar, { regionList: Rr = "list-nav" } = ar, { regionItem: Mr = "" } = ar, { regionButton: Br = "w-full" } = ar, { regionEmpty: Dr = "text-center" } = ar, { filter: Hr = Wr } = ar, { transitions: Fr = !xr } = ar, { transitionIn: zr = slide } = ar, { transitionInParams: Ur = { duration: 200 } } = ar, { transitionOut: jr = slide } = ar, { transitionOutParams: Yr = { duration: 200 } } = ar;
  function qr($r, Xr) {
    let si = [...Cr];
    $r.length && (si = si.filter((Zr) => $r.includes(Zr.value))), Xr.length && (si = si.filter((Zr) => !Xr.includes(Zr.value))), !$r.length && !Xr.length && (si = Cr), lr(26, ur = si);
  }
  function Wr() {
    let $r = [...ur];
    return $r = $r.filter((Xr) => {
      const si = String(Er).toLowerCase().trim();
      if (JSON.stringify([Xr.label, Xr.value, Xr.keywords]).toLowerCase().includes(si))
        return Xr;
    }), $r;
  }
  function Jr($r) {
    Ar("selection", $r);
  }
  function Gr($r) {
    bubble.call(this, cr, $r);
  }
  function Vr($r) {
    bubble.call(this, cr, $r);
  }
  const Qr = ($r) => Jr($r);
  return cr.$$set = ($r) => {
    lr(34, ar = assign$1(assign$1({}, ar), exclude_internal_props($r))), "input" in $r && lr(15, Er = $r.input), "options" in $r && lr(16, Cr = $r.options), "limit" in $r && lr(17, Tr = $r.limit), "allowlist" in $r && lr(18, Sr = $r.allowlist), "denylist" in $r && lr(19, Lr = $r.denylist), "emptyState" in $r && lr(0, Ir = $r.emptyState), "regionNav" in $r && lr(20, Nr = $r.regionNav), "regionList" in $r && lr(21, Rr = $r.regionList), "regionItem" in $r && lr(22, Mr = $r.regionItem), "regionButton" in $r && lr(23, Br = $r.regionButton), "regionEmpty" in $r && lr(24, Dr = $r.regionEmpty), "filter" in $r && lr(25, Hr = $r.filter), "transitions" in $r && lr(1, Fr = $r.transitions), "transitionIn" in $r && lr(2, zr = $r.transitionIn), "transitionInParams" in $r && lr(3, Ur = $r.transitionInParams), "transitionOut" in $r && lr(4, jr = $r.transitionOut), "transitionOutParams" in $r && lr(5, Yr = $r.transitionOutParams);
  }, cr.$$.update = () => {
    var $r;
    cr.$$.dirty[0] & /*options*/
    65536 && lr(26, ur = Cr), cr.$$.dirty[0] & /*allowlist, denylist*/
    786432 && qr(Sr, Lr), cr.$$.dirty[0] & /*input, filter, listedOptions*/
    100696064 && lr(6, dr = Er ? Hr() : ur), cr.$$.dirty[0] & /*limit, optionsFiltered*/
    131136 && lr(13, fr = Tr != null ? Tr : dr.length), lr(12, gr = `${($r = ar.class) != null ? $r : ""}`), cr.$$.dirty[0] & /*regionNav*/
    1048576 && lr(11, mr = `${Nr}`), cr.$$.dirty[0] & /*regionList*/
    2097152 && lr(10, vr = `${Rr}`), cr.$$.dirty[0] & /*regionItem*/
    4194304 && lr(9, yr = `${Mr}`), cr.$$.dirty[0] & /*regionButton*/
    8388608 && lr(8, _r = `${Br}`), cr.$$.dirty[0] & /*regionEmpty*/
    16777216 && lr(7, kr = `${Dr}`);
  }, ar = exclude_internal_props(ar), [
    Ir,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    dr,
    kr,
    _r,
    yr,
    vr,
    mr,
    gr,
    fr,
    Jr,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    ur,
    Gr,
    Vr,
    Qr
  ];
}
class Autocomplete extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$E,
      create_fragment$Z,
      safe_not_equal,
      {
        input: 15,
        options: 16,
        limit: 17,
        allowlist: 18,
        denylist: 19,
        emptyState: 0,
        regionNav: 20,
        regionList: 21,
        regionItem: 22,
        regionButton: 23,
        regionEmpty: 24,
        filter: 25,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get input() {
    return this.$$.ctx[15];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get options() {
    return this.$$.ctx[16];
  }
  set options(ar) {
    this.$$set({ options: ar }), flush();
  }
  get limit() {
    return this.$$.ctx[17];
  }
  set limit(ar) {
    this.$$set({ limit: ar }), flush();
  }
  get allowlist() {
    return this.$$.ctx[18];
  }
  set allowlist(ar) {
    this.$$set({ allowlist: ar }), flush();
  }
  get denylist() {
    return this.$$.ctx[19];
  }
  set denylist(ar) {
    this.$$set({ denylist: ar }), flush();
  }
  get emptyState() {
    return this.$$.ctx[0];
  }
  set emptyState(ar) {
    this.$$set({ emptyState: ar }), flush();
  }
  get regionNav() {
    return this.$$.ctx[20];
  }
  set regionNav(ar) {
    this.$$set({ regionNav: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[21];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionItem() {
    return this.$$.ctx[22];
  }
  set regionItem(ar) {
    this.$$set({ regionItem: ar }), flush();
  }
  get regionButton() {
    return this.$$.ctx[23];
  }
  set regionButton(ar) {
    this.$$set({ regionButton: ar }), flush();
  }
  get regionEmpty() {
    return this.$$.ctx[24];
  }
  set regionEmpty(ar) {
    this.$$set({ regionEmpty: ar }), flush();
  }
  get filter() {
    return this.$$.ctx[25];
  }
  set filter(ar) {
    this.$$set({ filter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Autocomplete, { input: {}, options: {}, limit: {}, allowlist: {}, denylist: {}, emptyState: {}, regionNav: {}, regionList: {}, regionItem: {}, regionButton: {}, regionEmpty: {}, filter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function create_else_block$c(cr) {
  let ar, lr, ur = String(
    /*initials*/
    cr[1]
  ).substring(0, 2).toUpperCase() + "", dr, fr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("text"), dr = text$3(ur), attr(lr, "x", "50%"), attr(lr, "y", "50%"), attr(lr, "dominant-baseline", "central"), attr(lr, "text-anchor", "middle"), attr(lr, "font-weight", "bold"), attr(lr, "font-size", 150), attr(lr, "class", fr = "avatar-text " + /*fill*/
      cr[2]), attr(ar, "class", "avatar-initials w-full h-full"), attr(ar, "viewBox", "0 0 512 512");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, lr), append(lr, dr);
    },
    p(gr, mr) {
      mr & /*initials*/
      2 && ur !== (ur = String(
        /*initials*/
        gr[1]
      ).substring(0, 2).toUpperCase() + "") && set_data(dr, ur), mr & /*fill*/
      4 && fr !== (fr = "avatar-text " + /*fill*/
      gr[2]) && attr(lr, "class", fr);
    },
    d(gr) {
      gr && detach(ar);
    }
  };
}
function create_if_block$s(cr) {
  var kr;
  let ar, lr, ur, dr, fr, gr, mr, vr, yr = [
    {
      class: lr = "avatar-image " + cImage
    },
    {
      style: ur = /*$$props*/
      (kr = cr[8].style) != null ? kr : ""
    },
    { src: dr = /*src*/
    cr[0] },
    {
      alt: fr = /*$$props*/
      cr[8].alt || ""
    },
    /*prunedRestProps*/
    cr[7]()
  ], _r = {};
  for (let xr = 0; xr < yr.length; xr += 1)
    _r = assign$1(_r, yr[xr]);
  return {
    c() {
      ar = element("img"), set_attributes(ar, _r);
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), mr || (vr = [
        action_destroyer(gr = /*action*/
        cr[4].call(
          null,
          ar,
          /*actionParams*/
          cr[5]
        )),
        listen(
          ar,
          "error",
          /*error_handler*/
          cr[19]
        )
      ], mr = !0);
    },
    p(xr, Ar) {
      var Er;
      set_attributes(ar, _r = get_spread_update(yr, [
        { class: lr },
        Ar & /*$$props*/
        256 && ur !== (ur = /*$$props*/
        (Er = xr[8].style) != null ? Er : "") && { style: ur },
        Ar & /*src*/
        1 && !src_url_equal(ar.src, dr = /*src*/
        xr[0]) && { src: dr },
        Ar & /*$$props*/
        256 && fr !== (fr = /*$$props*/
        xr[8].alt || "") && { alt: fr },
        /*prunedRestProps*/
        xr[7]()
      ])), gr && is_function(gr.update) && Ar & /*actionParams*/
      32 && gr.update.call(
        null,
        /*actionParams*/
        xr[5]
      );
    },
    d(xr) {
      xr && detach(ar), mr = !1, run_all(vr);
    }
  };
}
function create_fragment$Y(cr) {
  let ar, lr, ur, dr;
  function fr(vr, yr) {
    return (
      /*src*/
      vr[0] ? create_if_block$s : create_else_block$c
    );
  }
  let gr = fr(cr), mr = gr(cr);
  return {
    c() {
      ar = element("figure"), mr.c(), attr(ar, "class", lr = "avatar " + /*classesBase*/
      cr[6]), attr(ar, "data-testid", "avatar");
    },
    m(vr, yr) {
      insert(vr, ar, yr), mr.m(ar, null), ur || (dr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[15]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          cr[16]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          cr[17]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[18]
        )
      ], ur = !0);
    },
    p(vr, [yr]) {
      gr === (gr = fr(vr)) && mr ? mr.p(vr, yr) : (mr.d(1), mr = gr(vr), mr && (mr.c(), mr.m(ar, null))), yr & /*classesBase*/
      64 && lr !== (lr = "avatar " + /*classesBase*/
      vr[6]) && attr(ar, "class", lr);
    },
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar), mr.d(), ur = !1, run_all(dr);
    }
  };
}
let cBase$k = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate", cImage = "w-full h-full object-cover";
function instance$D(cr, ar, lr) {
  let ur;
  const dr = [
    "initials",
    "fill",
    "src",
    "fallback",
    "action",
    "actionParams",
    "background",
    "width",
    "border",
    "rounded",
    "shadow",
    "cursor"
  ];
  let fr = compute_rest_props(ar, dr), { initials: gr = "AB" } = ar, { fill: mr = "fill-token" } = ar, { src: vr = "" } = ar, { fallback: yr = "" } = ar, { action: _r = () => {
  } } = ar, { actionParams: kr = "" } = ar, { background: xr = "bg-surface-400-500-token" } = ar, { width: Ar = "w-16" } = ar, { border: Er = "" } = ar, { rounded: Cr = "rounded-full" } = ar, { shadow: Tr = "" } = ar, { cursor: Sr = "" } = ar;
  function Lr() {
    return delete fr.class, fr;
  }
  function Ir(Dr) {
    bubble.call(this, cr, Dr);
  }
  function Nr(Dr) {
    bubble.call(this, cr, Dr);
  }
  function Rr(Dr) {
    bubble.call(this, cr, Dr);
  }
  function Mr(Dr) {
    bubble.call(this, cr, Dr);
  }
  const Br = () => lr(0, vr = yr);
  return cr.$$set = (Dr) => {
    lr(8, ar = assign$1(assign$1({}, ar), exclude_internal_props(Dr))), lr(20, fr = compute_rest_props(ar, dr)), "initials" in Dr && lr(1, gr = Dr.initials), "fill" in Dr && lr(2, mr = Dr.fill), "src" in Dr && lr(0, vr = Dr.src), "fallback" in Dr && lr(3, yr = Dr.fallback), "action" in Dr && lr(4, _r = Dr.action), "actionParams" in Dr && lr(5, kr = Dr.actionParams), "background" in Dr && lr(9, xr = Dr.background), "width" in Dr && lr(10, Ar = Dr.width), "border" in Dr && lr(11, Er = Dr.border), "rounded" in Dr && lr(12, Cr = Dr.rounded), "shadow" in Dr && lr(13, Tr = Dr.shadow), "cursor" in Dr && lr(14, Sr = Dr.cursor);
  }, cr.$$.update = () => {
    var Dr;
    lr(6, ur = `${cBase$k} ${xr} ${Ar} ${Er} ${Cr} ${Tr} ${Sr} ${(Dr = ar.class) != null ? Dr : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    gr,
    mr,
    yr,
    _r,
    kr,
    ur,
    Lr,
    ar,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br
  ];
}
class Avatar extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$D, create_fragment$Y, safe_not_equal, {
      initials: 1,
      fill: 2,
      src: 0,
      fallback: 3,
      action: 4,
      actionParams: 5,
      background: 9,
      width: 10,
      border: 11,
      rounded: 12,
      shadow: 13,
      cursor: 14
    });
  }
  get initials() {
    return this.$$.ctx[1];
  }
  set initials(ar) {
    this.$$set({ initials: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[2];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get src() {
    return this.$$.ctx[0];
  }
  set src(ar) {
    this.$$set({ src: ar }), flush();
  }
  get fallback() {
    return this.$$.ctx[3];
  }
  set fallback(ar) {
    this.$$set({ fallback: ar }), flush();
  }
  get action() {
    return this.$$.ctx[4];
  }
  set action(ar) {
    this.$$set({ action: ar }), flush();
  }
  get actionParams() {
    return this.$$.ctx[5];
  }
  set actionParams(ar) {
    this.$$set({ actionParams: ar }), flush();
  }
  get background() {
    return this.$$.ctx[9];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[10];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get border() {
    return this.$$.ctx[11];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[13];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get cursor() {
    return this.$$.ctx[14];
  }
  set cursor(ar) {
    this.$$set({ cursor: ar }), flush();
  }
}
create_custom_element(Avatar, { initials: {}, fill: {}, src: {}, fallback: {}, action: {}, actionParams: {}, background: {}, width: {}, border: {}, rounded: {}, shadow: {}, cursor: {} }, [], [], !0);
const tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      50: { hex: "#f8fafc", rgb: "248 250 252" },
      100: { hex: "#f1f5f9", rgb: "241 245 249" },
      200: { hex: "#e2e8f0", rgb: "226 232 240" },
      300: { hex: "#cbd5e1", rgb: "203 213 225" },
      400: { hex: "#94a3b8", rgb: "148 163 184" },
      500: { hex: "#64748b", rgb: "100 116 139" },
      600: { hex: "#475569", rgb: "71 85 105" },
      700: { hex: "#334155", rgb: "51 65 85" },
      800: { hex: "#1e293b", rgb: "30 41 59" },
      900: { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      50: { hex: "#f9fafb", rgb: "249 250 251" },
      100: { hex: "#f3f4f6", rgb: "243 244 246" },
      200: { hex: "#e5e7eb", rgb: "229 231 235" },
      300: { hex: "#d1d5db", rgb: "209 213 219" },
      400: { hex: "#9ca3af", rgb: "156 163 175" },
      500: { hex: "#6b7280", rgb: "107 114 128" },
      600: { hex: "#4b5563", rgb: "75 85 99" },
      700: { hex: "#374151", rgb: "55 65 81" },
      800: { hex: "#1f2937", rgb: "31 41 55" },
      900: { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f4f4f5", rgb: "244 244 245" },
      200: { hex: "#e4e4e7", rgb: "228 228 231" },
      300: { hex: "#d4d4d8", rgb: "212 212 216" },
      400: { hex: "#a1a1aa", rgb: "161 161 170" },
      500: { hex: "#71717a", rgb: "113 113 122" },
      600: { hex: "#52525b", rgb: "82 82 91" },
      700: { hex: "#3f3f46", rgb: "63 63 70" },
      800: { hex: "#27272a", rgb: "39 39 42" },
      900: { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      50: { hex: "#fafafa", rgb: "250 250 250" },
      100: { hex: "#f5f5f5", rgb: "245 245 245" },
      200: { hex: "#e5e5e5", rgb: "229 229 229" },
      300: { hex: "#d4d4d4", rgb: "212 212 212" },
      400: { hex: "#a3a3a3", rgb: "163 163 163" },
      500: { hex: "#737373", rgb: "115 115 115" },
      600: { hex: "#525252", rgb: "82 82 82" },
      700: { hex: "#404040", rgb: "64 64 64" },
      800: { hex: "#262626", rgb: "38 38 38" },
      900: { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      50: { hex: "#fafaf9", rgb: "250 250 249" },
      100: { hex: "#f5f5f4", rgb: "245 245 244" },
      200: { hex: "#e7e5e4", rgb: "231 229 228" },
      300: { hex: "#d6d3d1", rgb: "214 211 209" },
      400: { hex: "#a8a29e", rgb: "168 162 158" },
      500: { hex: "#78716c", rgb: "120 113 108" },
      600: { hex: "#57534e", rgb: "87 83 78" },
      700: { hex: "#44403c", rgb: "68 64 60" },
      800: { hex: "#292524", rgb: "41 37 36" },
      900: { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      50: { hex: "#fef2f2", rgb: "254 242 242" },
      100: { hex: "#fee2e2", rgb: "254 226 226" },
      200: { hex: "#fecaca", rgb: "254 202 202" },
      300: { hex: "#fca5a5", rgb: "252 165 165" },
      400: { hex: "#f87171", rgb: "248 113 113" },
      500: { hex: "#ef4444", rgb: "239 68 68" },
      600: { hex: "#dc2626", rgb: "220 38 38" },
      700: { hex: "#b91c1c", rgb: "185 28 28" },
      800: { hex: "#991b1b", rgb: "153 27 27" },
      900: { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      50: { hex: "#fff7ed", rgb: "255 247 237" },
      100: { hex: "#ffedd5", rgb: "255 237 213" },
      200: { hex: "#fed7aa", rgb: "254 215 170" },
      300: { hex: "#fdba74", rgb: "253 186 116" },
      400: { hex: "#fb923c", rgb: "251 146 60" },
      500: { hex: "#f97316", rgb: "249 115 22" },
      600: { hex: "#ea580c", rgb: "234 88 12" },
      700: { hex: "#c2410c", rgb: "194 65 12" },
      800: { hex: "#9a3412", rgb: "154 52 18" },
      900: { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      50: { hex: "#fffbeb", rgb: "255 251 235" },
      100: { hex: "#fef3c7", rgb: "254 243 199" },
      200: { hex: "#fde68a", rgb: "253 230 138" },
      300: { hex: "#fcd34d", rgb: "252 211 77" },
      400: { hex: "#fbbf24", rgb: "251 191 36" },
      500: { hex: "#f59e0b", rgb: "245 158 11" },
      600: { hex: "#d97706", rgb: "217 119 6" },
      700: { hex: "#b45309", rgb: "180 83 9" },
      800: { hex: "#92400e", rgb: "146 64 14" },
      900: { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      50: { hex: "#fefce8", rgb: "254 252 232" },
      100: { hex: "#fef9c3", rgb: "254 249 195" },
      200: { hex: "#fef08a", rgb: "254 240 138" },
      300: { hex: "#fde047", rgb: "253 224 71" },
      400: { hex: "#facc15", rgb: "250 204 21" },
      500: { hex: "#eab308", rgb: "234 179 8" },
      600: { hex: "#ca8a04", rgb: "202 138 4" },
      700: { hex: "#a16207", rgb: "161 98 7" },
      800: { hex: "#854d0e", rgb: "133 77 14" },
      900: { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      50: { hex: "#f7fee7", rgb: "247 254 231" },
      100: { hex: "#ecfccb", rgb: "236 252 203" },
      200: { hex: "#d9f99d", rgb: "217 249 157" },
      300: { hex: "#bef264", rgb: "190 242 100" },
      400: { hex: "#a3e635", rgb: "163 230 53" },
      500: { hex: "#84cc16", rgb: "132 204 22" },
      600: { hex: "#65a30d", rgb: "101 163 13" },
      700: { hex: "#4d7c0f", rgb: "77 124 15" },
      800: { hex: "#3f6212", rgb: "63 98 18" },
      900: { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      50: { hex: "#f0fdf4", rgb: "240 253 244" },
      100: { hex: "#dcfce7", rgb: "220 252 231" },
      200: { hex: "#bbf7d0", rgb: "187 247 208" },
      300: { hex: "#86efac", rgb: "134 239 172" },
      400: { hex: "#4ade80", rgb: "74 222 128" },
      500: { hex: "#22c55e", rgb: "34 197 94" },
      600: { hex: "#16a34a", rgb: "22 163 74" },
      700: { hex: "#15803d", rgb: "21 128 61" },
      800: { hex: "#166534", rgb: "22 101 52" },
      900: { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      50: { hex: "#ecfdf5", rgb: "236 253 245" },
      100: { hex: "#d1fae5", rgb: "209 250 229" },
      200: { hex: "#a7f3d0", rgb: "167 243 208" },
      300: { hex: "#6ee7b7", rgb: "110 231 183" },
      400: { hex: "#34d399", rgb: "52 211 153" },
      500: { hex: "#10b981", rgb: "16 185 129" },
      600: { hex: "#059669", rgb: "5 150 105" },
      700: { hex: "#047857", rgb: "4 120 87" },
      800: { hex: "#065f46", rgb: "6 95 70" },
      900: { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      50: { hex: "#f0fdfa", rgb: "240 253 250" },
      100: { hex: "#ccfbf1", rgb: "204 251 241" },
      200: { hex: "#99f6e4", rgb: "153 246 228" },
      300: { hex: "#5eead4", rgb: "94 234 212" },
      400: { hex: "#2dd4bf", rgb: "45 212 191" },
      500: { hex: "#14b8a6", rgb: "20 184 166" },
      600: { hex: "#0d9488", rgb: "13 148 136" },
      700: { hex: "#0f766e", rgb: "15 118 110" },
      800: { hex: "#115e59", rgb: "17 94 89" },
      900: { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      50: { hex: "#ecfeff", rgb: "236 254 255" },
      100: { hex: "#cffafe", rgb: "207 250 254" },
      200: { hex: "#a5f3fc", rgb: "165 243 252" },
      300: { hex: "#67e8f9", rgb: "103 232 249" },
      400: { hex: "#22d3ee", rgb: "34 211 238" },
      500: { hex: "#06b6d4", rgb: "6 182 212" },
      600: { hex: "#0891b2", rgb: "8 145 178" },
      700: { hex: "#0e7490", rgb: "14 116 144" },
      800: { hex: "#155e75", rgb: "21 94 117" },
      900: { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      50: { hex: "#f0f9ff", rgb: "240 249 255" },
      100: { hex: "#e0f2fe", rgb: "224 242 254" },
      200: { hex: "#bae6fd", rgb: "186 230 253" },
      300: { hex: "#7dd3fc", rgb: "125 211 252" },
      400: { hex: "#38bdf8", rgb: "56 189 248" },
      500: { hex: "#0ea5e9", rgb: "14 165 233" },
      600: { hex: "#0284c7", rgb: "2 132 199" },
      700: { hex: "#0369a1", rgb: "3 105 161" },
      800: { hex: "#075985", rgb: "7 89 133" },
      900: { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      50: { hex: "#eff6ff", rgb: "239 246 255" },
      100: { hex: "#dbeafe", rgb: "219 234 254" },
      200: { hex: "#bfdbfe", rgb: "191 219 254" },
      300: { hex: "#93c5fd", rgb: "147 197 253" },
      400: { hex: "#60a5fa", rgb: "96 165 250" },
      500: { hex: "#3b82f6", rgb: "59 130 246" },
      600: { hex: "#2563eb", rgb: "37 99 235" },
      700: { hex: "#1d4ed8", rgb: "29 78 216" },
      800: { hex: "#1e40af", rgb: "30 64 175" },
      900: { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      50: { hex: "#eef2ff", rgb: "238 242 255" },
      100: { hex: "#e0e7ff", rgb: "224 231 255" },
      200: { hex: "#c7d2fe", rgb: "199 210 254" },
      300: { hex: "#a5b4fc", rgb: "165 180 252" },
      400: { hex: "#818cf8", rgb: "129 140 248" },
      500: { hex: "#6366f1", rgb: "99 102 241" },
      600: { hex: "#4f46e5", rgb: "79 70 229" },
      700: { hex: "#4338ca", rgb: "67 56 202" },
      800: { hex: "#3730a3", rgb: "55 48 163" },
      900: { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      50: { hex: "#f5f3ff", rgb: "245 243 255" },
      100: { hex: "#ede9fe", rgb: "237 233 254" },
      200: { hex: "#ddd6fe", rgb: "221 214 254" },
      300: { hex: "#c4b5fd", rgb: "196 181 253" },
      400: { hex: "#a78bfa", rgb: "167 139 250" },
      500: { hex: "#8b5cf6", rgb: "139 92 246" },
      600: { hex: "#7c3aed", rgb: "124 58 237" },
      700: { hex: "#6d28d9", rgb: "109 40 217" },
      800: { hex: "#5b21b6", rgb: "91 33 182" },
      900: { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      50: { hex: "#faf5ff", rgb: "250 245 255" },
      100: { hex: "#f3e8ff", rgb: "243 232 255" },
      200: { hex: "#e9d5ff", rgb: "233 213 255" },
      300: { hex: "#d8b4fe", rgb: "216 180 254" },
      400: { hex: "#c084fc", rgb: "192 132 252" },
      500: { hex: "#a855f7", rgb: "168 85 247" },
      600: { hex: "#9333ea", rgb: "147 51 234" },
      700: { hex: "#7e22ce", rgb: "126 34 206" },
      800: { hex: "#6b21a8", rgb: "107 33 168" },
      900: { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      50: { hex: "#fdf4ff", rgb: "253 244 255" },
      100: { hex: "#fae8ff", rgb: "250 232 255" },
      200: { hex: "#f5d0fe", rgb: "245 208 254" },
      300: { hex: "#f0abfc", rgb: "240 171 252" },
      400: { hex: "#e879f9", rgb: "232 121 249" },
      500: { hex: "#d946ef", rgb: "217 70 239" },
      600: { hex: "#c026d3", rgb: "192 38 211" },
      700: { hex: "#a21caf", rgb: "162 28 175" },
      800: { hex: "#86198f", rgb: "134 25 143" },
      900: { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      50: { hex: "#fdf2f8", rgb: "253 242 248" },
      100: { hex: "#fce7f3", rgb: "252 231 243" },
      200: { hex: "#fbcfe8", rgb: "251 207 232" },
      300: { hex: "#f9a8d4", rgb: "249 168 212" },
      400: { hex: "#f472b6", rgb: "244 114 182" },
      500: { hex: "#ec4899", rgb: "236 72 153" },
      600: { hex: "#db2777", rgb: "219 39 119" },
      700: { hex: "#be185d", rgb: "190 24 93" },
      800: { hex: "#9d174d", rgb: "157 23 77" },
      900: { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      50: { hex: "#fff1f2", rgb: "255 241 242" },
      100: { hex: "#ffe4e6", rgb: "255 228 230" },
      200: { hex: "#fecdd3", rgb: "254 205 211" },
      300: { hex: "#fda4af", rgb: "253 164 175" },
      400: { hex: "#fb7185", rgb: "251 113 133" },
      500: { hex: "#f43f5e", rgb: "244 63 94" },
      600: { hex: "#e11d48", rgb: "225 29 72" },
      700: { hex: "#be123c", rgb: "190 18 60" },
      800: { hex: "#9f1239", rgb: "159 18 57" },
      900: { hex: "#881337", rgb: "136 19 55" }
    }
  }
];
function get_each_context$b(cr, ar, lr) {
  const ur = cr.slice();
  return ur[26] = ar[lr].color, ur[27] = ar[lr].label, ur[28] = ar[lr].value, ur;
}
function create_if_block_2$b(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[17].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[16],
    null
  );
  return {
    c() {
      ar = element("figcaption"), fr && fr.c(), attr(ar, "class", lr = "conic-caption " + /*classesCaption*/
      cr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      65536) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[16],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[16],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[16]
        ),
        null
      ), (!ur || mr & /*classesCaption*/
      128 && lr !== (lr = "conic-caption " + /*classesCaption*/
      gr[7])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_if_block_1$e(cr) {
  let ar, lr;
  return {
    c() {
      ar = element("div"), attr(ar, "class", lr = "conic-cone " + /*classesCone*/
      cr[6]), toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        cr[1]
      ), set_style(
        ar,
        "background",
        /*cone*/
        cr[3]
      );
    },
    m(ur, dr) {
      insert(ur, ar, dr);
    },
    p(ur, dr) {
      dr & /*classesCone*/
      64 && lr !== (lr = "conic-cone " + /*classesCone*/
      ur[6]) && attr(ar, "class", lr), dr & /*classesCone, spin*/
      66 && toggle_class(
        ar,
        "animate-spin",
        /*spin*/
        ur[1]
      ), dr & /*cone*/
      8 && set_style(
        ar,
        "background",
        /*cone*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block$r(cr) {
  let ar, lr, ur = ensure_array_like(
    /*generatedLegendList*/
    cr[4]
  ), dr = [];
  for (let fr = 0; fr < ur.length; fr += 1)
    dr[fr] = create_each_block$b(get_each_context$b(cr, ur, fr));
  return {
    c() {
      ar = element("ul");
      for (let fr = 0; fr < dr.length; fr += 1)
        dr[fr].c();
      attr(ar, "class", lr = "conic-list list " + /*classesLegend*/
      cr[5]);
    },
    m(fr, gr) {
      insert(fr, ar, gr);
      for (let mr = 0; mr < dr.length; mr += 1)
        dr[mr] && dr[mr].m(ar, null);
    },
    p(fr, gr) {
      if (gr & /*hover, generatedLegendList, cSwatch*/
      20) {
        ur = ensure_array_like(
          /*generatedLegendList*/
          fr[4]
        );
        let mr;
        for (mr = 0; mr < ur.length; mr += 1) {
          const vr = get_each_context$b(fr, ur, mr);
          dr[mr] ? dr[mr].p(vr, gr) : (dr[mr] = create_each_block$b(vr), dr[mr].c(), dr[mr].m(ar, null));
        }
        for (; mr < dr.length; mr += 1)
          dr[mr].d(1);
        dr.length = ur.length;
      }
      gr & /*classesLegend*/
      32 && lr !== (lr = "conic-list list " + /*classesLegend*/
      fr[5]) && attr(ar, "class", lr);
    },
    d(fr) {
      fr && detach(ar), destroy_each(dr, fr);
    }
  };
}
function create_each_block$b(cr) {
  let ar, lr, ur, dr, fr = (
    /*label*/
    cr[27] + ""
  ), gr, mr, vr, yr = (
    /*value*/
    cr[28] + ""
  ), _r, kr, xr, Ar, Er, Cr;
  return {
    c() {
      ar = element("li"), lr = element("span"), ur = space(), dr = element("span"), gr = text$3(fr), mr = space(), vr = element("strong"), _r = text$3(yr), kr = text$3("%"), xr = space(), attr(lr, "class", "conic-swatch " + cSwatch), set_style(
        lr,
        "background",
        /*color*/
        cr[26]
      ), attr(dr, "class", "conic-label flex-auto"), attr(vr, "class", "conic-value"), attr(ar, "class", Ar = "conic-item " + /*hover*/
      cr[2]);
    },
    m(Tr, Sr) {
      insert(Tr, ar, Sr), append(ar, lr), append(ar, ur), append(ar, dr), append(dr, gr), append(ar, mr), append(ar, vr), append(vr, _r), append(vr, kr), append(ar, xr), Er || (Cr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[18]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          cr[19]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          cr[20]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[21]
        )
      ], Er = !0);
    },
    p(Tr, Sr) {
      Sr & /*generatedLegendList*/
      16 && set_style(
        lr,
        "background",
        /*color*/
        Tr[26]
      ), Sr & /*generatedLegendList*/
      16 && fr !== (fr = /*label*/
      Tr[27] + "") && set_data(gr, fr), Sr & /*generatedLegendList*/
      16 && yr !== (yr = /*value*/
      Tr[28] + "") && set_data(_r, yr), Sr & /*hover*/
      4 && Ar !== (Ar = "conic-item " + /*hover*/
      Tr[2]) && attr(ar, "class", Ar);
    },
    d(Tr) {
      Tr && detach(ar), Er = !1, run_all(Cr);
    }
  };
}
function create_fragment$X(cr) {
  let ar, lr, ur, dr, fr, gr = (
    /*$$slots*/
    cr[9].default && create_if_block_2$b(cr)
  ), mr = (
    /*cone*/
    cr[3] && create_if_block_1$e(cr)
  ), vr = (
    /*legend*/
    cr[0] && /*generatedLegendList*/
    cr[4] && create_if_block$r(cr)
  );
  return {
    c() {
      ar = element("figure"), gr && gr.c(), lr = space(), mr && mr.c(), ur = space(), vr && vr.c(), attr(ar, "class", dr = "conic-gradient " + /*classesBase*/
      cr[8]), attr(ar, "data-testid", "conic-gradient");
    },
    m(yr, _r) {
      insert(yr, ar, _r), gr && gr.m(ar, null), append(ar, lr), mr && mr.m(ar, null), append(ar, ur), vr && vr.m(ar, null), fr = !0;
    },
    p(yr, [_r]) {
      /*$$slots*/
      yr[9].default ? gr ? (gr.p(yr, _r), _r & /*$$slots*/
      512 && transition_in(gr, 1)) : (gr = create_if_block_2$b(yr), gr.c(), transition_in(gr, 1), gr.m(ar, lr)) : gr && (group_outros(), transition_out(gr, 1, 1, () => {
        gr = null;
      }), check_outros()), /*cone*/
      yr[3] ? mr ? mr.p(yr, _r) : (mr = create_if_block_1$e(yr), mr.c(), mr.m(ar, ur)) : mr && (mr.d(1), mr = null), /*legend*/
      yr[0] && /*generatedLegendList*/
      yr[4] ? vr ? vr.p(yr, _r) : (vr = create_if_block$r(yr), vr.c(), vr.m(ar, null)) : vr && (vr.d(1), vr = null), (!fr || _r & /*classesBase*/
      256 && dr !== (dr = "conic-gradient " + /*classesBase*/
      yr[8])) && attr(ar, "class", dr);
    },
    i(yr) {
      fr || (transition_in(gr), fr = !0);
    },
    o(yr) {
      transition_out(gr), fr = !1;
    },
    d(yr) {
      yr && detach(ar), gr && gr.d(), mr && mr.d(), vr && vr.d();
    }
  };
}
const cBase$j = "flex flex-col items-center space-y-4 w-", cCaption = "text-center", cCone = "block aspect-square rounded-full", cLegend = "text-sm w-full", cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance$C(cr, ar, lr) {
  let ur, dr, fr, gr, { $$slots: mr = {}, $$scope: vr } = ar;
  const yr = compute_slots(mr);
  let { stops: _r = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = ar, { legend: kr = !1 } = ar, { spin: xr = !1 } = ar, { width: Ar = "w-24" } = ar, { hover: Er = "bg-primary-hover-token" } = ar, { digits: Cr = 0 } = ar, { regionCaption: Tr = "" } = ar, { regionCone: Sr = "" } = ar, { regionLegend: Lr = "" } = ar, Ir, Nr;
  function Rr(Ur) {
    if (typeof Ur == "string")
      return Ur;
    const jr = tailwindDefaultColors.find((Yr) => Yr.label === Ur[0]);
    return jr == null ? void 0 : jr.shades[Ur[1]].hex;
  }
  function Mr() {
    let Ur = _r.map((jr) => `${Rr(jr.color)} ${jr.start}% ${jr.end}%`);
    lr(3, Ir = `conic-gradient(${Ur.join(", ")})`);
  }
  function Br() {
    kr && lr(4, Nr = _r.map((Ur) => ({
      label: Ur.label,
      color: Rr(Ur.color),
      value: (Ur.end - Ur.start).toFixed(Cr)
    })));
  }
  afterUpdate(() => {
    Mr(), Br();
  });
  function Dr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Hr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Fr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function zr(Ur) {
    bubble.call(this, cr, Ur);
  }
  return cr.$$set = (Ur) => {
    lr(25, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ur))), "stops" in Ur && lr(10, _r = Ur.stops), "legend" in Ur && lr(0, kr = Ur.legend), "spin" in Ur && lr(1, xr = Ur.spin), "width" in Ur && lr(11, Ar = Ur.width), "hover" in Ur && lr(2, Er = Ur.hover), "digits" in Ur && lr(12, Cr = Ur.digits), "regionCaption" in Ur && lr(13, Tr = Ur.regionCaption), "regionCone" in Ur && lr(14, Sr = Ur.regionCone), "regionLegend" in Ur && lr(15, Lr = Ur.regionLegend), "$$scope" in Ur && lr(16, vr = Ur.$$scope);
  }, cr.$$.update = () => {
    var Ur;
    lr(8, ur = `${cBase$j} ${(Ur = ar.class) != null ? Ur : ""}`), cr.$$.dirty & /*regionCaption*/
    8192 && lr(7, dr = `${cCaption} ${Tr}`), cr.$$.dirty & /*width, regionCone*/
    18432 && lr(6, fr = `${cCone} ${Ar} ${Sr}`), cr.$$.dirty & /*regionLegend*/
    32768 && lr(5, gr = `${cLegend} ${Lr}`);
  }, ar = exclude_internal_props(ar), [
    kr,
    xr,
    Er,
    Ir,
    Nr,
    gr,
    fr,
    dr,
    ur,
    yr,
    _r,
    Ar,
    Cr,
    Tr,
    Sr,
    Lr,
    vr,
    mr,
    Dr,
    Hr,
    Fr,
    zr
  ];
}
class ConicGradient extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$C, create_fragment$X, safe_not_equal, {
      stops: 10,
      legend: 0,
      spin: 1,
      width: 11,
      hover: 2,
      digits: 12,
      regionCaption: 13,
      regionCone: 14,
      regionLegend: 15
    });
  }
  get stops() {
    return this.$$.ctx[10];
  }
  set stops(ar) {
    this.$$set({ stops: ar }), flush();
  }
  get legend() {
    return this.$$.ctx[0];
  }
  set legend(ar) {
    this.$$set({ legend: ar }), flush();
  }
  get spin() {
    return this.$$.ctx[1];
  }
  set spin(ar) {
    this.$$set({ spin: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[2];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get digits() {
    return this.$$.ctx[12];
  }
  set digits(ar) {
    this.$$set({ digits: ar }), flush();
  }
  get regionCaption() {
    return this.$$.ctx[13];
  }
  set regionCaption(ar) {
    this.$$set({ regionCaption: ar }), flush();
  }
  get regionCone() {
    return this.$$.ctx[14];
  }
  set regionCone(ar) {
    this.$$set({ regionCone: ar }), flush();
  }
  get regionLegend() {
    return this.$$.ctx[15];
  }
  set regionLegend(ar) {
    this.$$set({ regionLegend: ar }), flush();
  }
}
create_custom_element(ConicGradient, { stops: {}, legend: { type: "Boolean" }, spin: { type: "Boolean" }, width: {}, hover: {}, digits: {}, regionCaption: {}, regionCone: {}, regionLegend: {} }, ["default"], [], !0);
function fallback_block$3(cr) {
  let ar;
  return {
    c() {
      ar = text$3("Select a File");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_fragment$W(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr = [
    { type: "file" },
    { name: (
      /*name*/
      cr[2]
    ) },
    /*prunedRestProps*/
    cr[6]()
  ], Ar = {};
  for (let Sr = 0; Sr < xr.length; Sr += 1)
    Ar = assign$1(Ar, xr[Sr]);
  const Er = (
    /*#slots*/
    cr[11].default
  ), Cr = create_slot(
    Er,
    cr,
    /*$$scope*/
    cr[10],
    null
  ), Tr = Cr || fallback_block$3();
  return {
    c() {
      ar = element("div"), lr = element("div"), ur = element("input"), dr = space(), fr = element("button"), Tr && Tr.c(), set_attributes(ur, Ar), attr(lr, "class", "w-0 h-0 overflow-hidden"), attr(fr, "type", "button"), attr(fr, "class", gr = "file-button-btn " + /*classesButton*/
      cr[3]), fr.disabled = mr = /*$$restProps*/
      cr[7].disabled, attr(ar, "class", vr = "file-button " + /*classesBase*/
      cr[4]), attr(ar, "data-testid", "file-button");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), append(lr, ur), ur.autofocus && ur.focus(), cr[16](ur), append(ar, dr), append(ar, fr), Tr && Tr.m(fr, null), yr = !0, _r || (kr = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          cr[17]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          cr[15]
        ),
        listen(
          fr,
          "click",
          /*onButtonClick*/
          cr[5]
        ),
        listen(
          fr,
          "keydown",
          /*keydown_handler*/
          cr[12]
        ),
        listen(
          fr,
          "keyup",
          /*keyup_handler*/
          cr[13]
        ),
        listen(
          fr,
          "keypress",
          /*keypress_handler*/
          cr[14]
        )
      ], _r = !0);
    },
    p(Sr, [Lr]) {
      set_attributes(ur, Ar = get_spread_update(xr, [
        { type: "file" },
        (!yr || Lr & /*name*/
        4) && { name: (
          /*name*/
          Sr[2]
        ) },
        /*prunedRestProps*/
        Sr[6]()
      ])), Cr && Cr.p && (!yr || Lr & /*$$scope*/
      1024) && update_slot_base(
        Cr,
        Er,
        Sr,
        /*$$scope*/
        Sr[10],
        yr ? get_slot_changes(
          Er,
          /*$$scope*/
          Sr[10],
          Lr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Sr[10]
        ),
        null
      ), (!yr || Lr & /*classesButton*/
      8 && gr !== (gr = "file-button-btn " + /*classesButton*/
      Sr[3])) && attr(fr, "class", gr), (!yr || Lr & /*$$restProps*/
      128 && mr !== (mr = /*$$restProps*/
      Sr[7].disabled)) && (fr.disabled = mr), (!yr || Lr & /*classesBase*/
      16 && vr !== (vr = "file-button " + /*classesBase*/
      Sr[4])) && attr(ar, "class", vr);
    },
    i(Sr) {
      yr || (transition_in(Tr, Sr), yr = !0);
    },
    o(Sr) {
      transition_out(Tr, Sr), yr = !1;
    },
    d(Sr) {
      Sr && detach(ar), cr[16](null), Tr && Tr.d(Sr), _r = !1, run_all(kr);
    }
  };
}
function instance$B(cr, ar, lr) {
  let ur, dr;
  const fr = ["files", "fileInput", "name", "width", "button"];
  let gr = compute_rest_props(ar, fr), { $$slots: mr = {}, $$scope: vr } = ar, { files: yr = void 0 } = ar, { fileInput: _r = void 0 } = ar, { name: kr } = ar, { width: xr = "" } = ar, { button: Ar = "btn variant-filled" } = ar;
  function Er() {
    _r && _r.click();
  }
  function Cr() {
    return delete gr.class, gr;
  }
  function Tr(Mr) {
    bubble.call(this, cr, Mr);
  }
  function Sr(Mr) {
    bubble.call(this, cr, Mr);
  }
  function Lr(Mr) {
    bubble.call(this, cr, Mr);
  }
  function Ir(Mr) {
    bubble.call(this, cr, Mr);
  }
  function Nr(Mr) {
    binding_callbacks[Mr ? "unshift" : "push"](() => {
      _r = Mr, lr(1, _r);
    });
  }
  function Rr() {
    yr = this.files, lr(0, yr);
  }
  return cr.$$set = (Mr) => {
    lr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Mr))), lr(7, gr = compute_rest_props(ar, fr)), "files" in Mr && lr(0, yr = Mr.files), "fileInput" in Mr && lr(1, _r = Mr.fileInput), "name" in Mr && lr(2, kr = Mr.name), "width" in Mr && lr(8, xr = Mr.width), "button" in Mr && lr(9, Ar = Mr.button), "$$scope" in Mr && lr(10, vr = Mr.$$scope);
  }, cr.$$.update = () => {
    var Mr;
    lr(4, ur = `${(Mr = ar.class) != null ? Mr : ""}`), cr.$$.dirty & /*button, width*/
    768 && lr(3, dr = `${Ar} ${xr}`);
  }, ar = exclude_internal_props(ar), [
    yr,
    _r,
    kr,
    dr,
    ur,
    Er,
    Cr,
    gr,
    xr,
    Ar,
    vr,
    mr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr
  ];
}
class FileButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$B, create_fragment$W, safe_not_equal, {
      files: 0,
      fileInput: 1,
      name: 2,
      width: 8,
      button: 9
    });
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get width() {
    return this.$$.ctx[8];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get button() {
    return this.$$.ctx[9];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
}
create_custom_element(FileButton, { files: {}, fileInput: {}, name: {}, width: {}, button: {} }, ["default"], [], !0);
const get_meta_slot_changes = (cr) => ({}), get_meta_slot_context = (cr) => ({}), get_message_slot_changes = (cr) => ({}), get_message_slot_context = (cr) => ({}), get_lead_slot_changes$4 = (cr) => ({}), get_lead_slot_context$4 = (cr) => ({});
function create_if_block_1$d(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[18].lead
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[17],
    get_lead_slot_context$4
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "dropzone-lead " + /*slotLead*/
      cr[5]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr[0] & /*$$scope*/
      131072) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[17],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[17],
          mr,
          get_lead_slot_changes$4
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[17]
        ),
        get_lead_slot_context$4
      ), (!ur || mr[0] & /*slotLead*/
      32 && lr !== (lr = "dropzone-lead " + /*slotLead*/
      gr[5])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function fallback_block$2(cr) {
  let ar, lr;
  return {
    c() {
      ar = element("strong"), ar.textContent = "Upload a file", lr = text$3(" or drag and drop");
    },
    m(ur, dr) {
      insert(ur, ar, dr), insert(ur, lr, dr);
    },
    p: noop$1,
    d(ur) {
      ur && (detach(ar), detach(lr));
    }
  };
}
function create_if_block$q(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[18].meta
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[17],
    get_meta_slot_context
  );
  return {
    c() {
      ar = element("small"), fr && fr.c(), attr(ar, "class", lr = "dropzone-meta " + /*slotMeta*/
      cr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr[0] & /*$$scope*/
      131072) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[17],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[17],
          mr,
          get_meta_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[17]
        ),
        get_meta_slot_context
      ), (!ur || mr[0] & /*slotMeta*/
      128 && lr !== (lr = "dropzone-meta " + /*slotMeta*/
      gr[7])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$V(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr = [
    { type: "file" },
    { name: (
      /*name*/
      cr[2]
    ) },
    {
      class: ur = "dropzone-input " + /*classesInput*/
      cr[9]
    },
    /*prunedRestProps*/
    cr[11]()
  ], Lr = {};
  for (let Dr = 0; Dr < Sr.length; Dr += 1)
    Lr = assign$1(Lr, Sr[Dr]);
  let Ir = (
    /*$$slots*/
    cr[13].lead && create_if_block_1$d(cr)
  );
  const Nr = (
    /*#slots*/
    cr[18].message
  ), Rr = create_slot(
    Nr,
    cr,
    /*$$scope*/
    cr[17],
    get_message_slot_context
  ), Mr = Rr || fallback_block$2();
  let Br = (
    /*$$slots*/
    cr[13].meta && create_if_block$q(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("input"), dr = space(), fr = element("div"), gr = element("div"), Ir && Ir.c(), mr = space(), vr = element("div"), Mr && Mr.c(), _r = space(), Br && Br.c(), set_attributes(lr, Lr), attr(vr, "class", yr = "dropzone-message " + /*slotMessage*/
      cr[6]), attr(gr, "class", kr = "dropzone-interface-text " + /*regionInterfaceText*/
      cr[4]), attr(fr, "class", xr = "dropzone-interface " + /*classesInterface*/
      cr[8] + " " + /*regionInterface*/
      cr[3]), attr(ar, "class", Ar = "dropzone " + /*classesBase*/
      cr[10]), attr(ar, "data-testid", "file-dropzone"), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        cr[12].disabled
      );
    },
    m(Dr, Hr) {
      insert(Dr, ar, Hr), append(ar, lr), lr.autofocus && lr.focus(), cr[32](lr), append(ar, dr), append(ar, fr), append(fr, gr), Ir && Ir.m(gr, null), append(gr, mr), append(gr, vr), Mr && Mr.m(vr, null), append(gr, _r), Br && Br.m(gr, null), Er = !0, Cr || (Tr = [
        listen(
          lr,
          "change",
          /*input_change_handler*/
          cr[31]
        ),
        listen(
          lr,
          "change",
          /*change_handler*/
          cr[19]
        ),
        listen(
          lr,
          "dragenter",
          /*dragenter_handler*/
          cr[20]
        ),
        listen(
          lr,
          "dragover",
          /*dragover_handler*/
          cr[21]
        ),
        listen(
          lr,
          "dragleave",
          /*dragleave_handler*/
          cr[22]
        ),
        listen(
          lr,
          "drop",
          /*drop_handler*/
          cr[23]
        ),
        listen(
          lr,
          "click",
          /*click_handler*/
          cr[24]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[25]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[26]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[27]
        ),
        listen(
          lr,
          "focus",
          /*focus_handler*/
          cr[28]
        ),
        listen(
          lr,
          "focusin",
          /*focusin_handler*/
          cr[29]
        ),
        listen(
          lr,
          "focusout",
          /*focusout_handler*/
          cr[30]
        )
      ], Cr = !0);
    },
    p(Dr, Hr) {
      set_attributes(lr, Lr = get_spread_update(Sr, [
        { type: "file" },
        (!Er || Hr[0] & /*name*/
        4) && { name: (
          /*name*/
          Dr[2]
        ) },
        (!Er || Hr[0] & /*classesInput*/
        512 && ur !== (ur = "dropzone-input " + /*classesInput*/
        Dr[9])) && { class: ur },
        /*prunedRestProps*/
        Dr[11]()
      ])), /*$$slots*/
      Dr[13].lead ? Ir ? (Ir.p(Dr, Hr), Hr[0] & /*$$slots*/
      8192 && transition_in(Ir, 1)) : (Ir = create_if_block_1$d(Dr), Ir.c(), transition_in(Ir, 1), Ir.m(gr, mr)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), Rr && Rr.p && (!Er || Hr[0] & /*$$scope*/
      131072) && update_slot_base(
        Rr,
        Nr,
        Dr,
        /*$$scope*/
        Dr[17],
        Er ? get_slot_changes(
          Nr,
          /*$$scope*/
          Dr[17],
          Hr,
          get_message_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Dr[17]
        ),
        get_message_slot_context
      ), (!Er || Hr[0] & /*slotMessage*/
      64 && yr !== (yr = "dropzone-message " + /*slotMessage*/
      Dr[6])) && attr(vr, "class", yr), /*$$slots*/
      Dr[13].meta ? Br ? (Br.p(Dr, Hr), Hr[0] & /*$$slots*/
      8192 && transition_in(Br, 1)) : (Br = create_if_block$q(Dr), Br.c(), transition_in(Br, 1), Br.m(gr, null)) : Br && (group_outros(), transition_out(Br, 1, 1, () => {
        Br = null;
      }), check_outros()), (!Er || Hr[0] & /*regionInterfaceText*/
      16 && kr !== (kr = "dropzone-interface-text " + /*regionInterfaceText*/
      Dr[4])) && attr(gr, "class", kr), (!Er || Hr[0] & /*classesInterface, regionInterface*/
      264 && xr !== (xr = "dropzone-interface " + /*classesInterface*/
      Dr[8] + " " + /*regionInterface*/
      Dr[3])) && attr(fr, "class", xr), (!Er || Hr[0] & /*classesBase*/
      1024 && Ar !== (Ar = "dropzone " + /*classesBase*/
      Dr[10])) && attr(ar, "class", Ar), (!Er || Hr[0] & /*classesBase, $$restProps*/
      5120) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Dr[12].disabled
      );
    },
    i(Dr) {
      Er || (transition_in(Ir), transition_in(Mr, Dr), transition_in(Br), Er = !0);
    },
    o(Dr) {
      transition_out(Ir), transition_out(Mr, Dr), transition_out(Br), Er = !1;
    },
    d(Dr) {
      Dr && detach(ar), cr[32](null), Ir && Ir.d(), Mr && Mr.d(Dr), Br && Br.d(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$i = "textarea relative flex justify-center items-center", cInput = "w-full absolute top-0 left-0 right-0 bottom-0 z-[1] opacity-0 disabled:!opacity-0 cursor-pointer", cInterface$2 = "flex justify-center items-center text-center";
function instance$A(cr, ar, lr) {
  let ur, dr, fr;
  const gr = [
    "files",
    "fileInput",
    "name",
    "border",
    "padding",
    "rounded",
    "regionInterface",
    "regionInterfaceText",
    "slotLead",
    "slotMessage",
    "slotMeta"
  ];
  let mr = compute_rest_props(ar, gr), { $$slots: vr = {}, $$scope: yr } = ar;
  const _r = compute_slots(vr);
  let { files: kr = void 0 } = ar, { fileInput: xr = void 0 } = ar, { name: Ar } = ar, { border: Er = "border-2 border-dashed" } = ar, { padding: Cr = "p-4 py-8" } = ar, { rounded: Tr = "rounded-container-token" } = ar, { regionInterface: Sr = "" } = ar, { regionInterfaceText: Lr = "" } = ar, { slotLead: Ir = "mb-4" } = ar, { slotMessage: Nr = "" } = ar, { slotMeta: Rr = "opacity-75" } = ar;
  function Mr() {
    return delete mr.class, mr;
  }
  function Br($r) {
    bubble.call(this, cr, $r);
  }
  function Dr($r) {
    bubble.call(this, cr, $r);
  }
  function Hr($r) {
    bubble.call(this, cr, $r);
  }
  function Fr($r) {
    bubble.call(this, cr, $r);
  }
  function zr($r) {
    bubble.call(this, cr, $r);
  }
  function Ur($r) {
    bubble.call(this, cr, $r);
  }
  function jr($r) {
    bubble.call(this, cr, $r);
  }
  function Yr($r) {
    bubble.call(this, cr, $r);
  }
  function qr($r) {
    bubble.call(this, cr, $r);
  }
  function Wr($r) {
    bubble.call(this, cr, $r);
  }
  function Jr($r) {
    bubble.call(this, cr, $r);
  }
  function Gr($r) {
    bubble.call(this, cr, $r);
  }
  function Vr() {
    kr = this.files, lr(0, kr);
  }
  function Qr($r) {
    binding_callbacks[$r ? "unshift" : "push"](() => {
      xr = $r, lr(1, xr);
    });
  }
  return cr.$$set = ($r) => {
    lr(33, ar = assign$1(assign$1({}, ar), exclude_internal_props($r))), lr(12, mr = compute_rest_props(ar, gr)), "files" in $r && lr(0, kr = $r.files), "fileInput" in $r && lr(1, xr = $r.fileInput), "name" in $r && lr(2, Ar = $r.name), "border" in $r && lr(14, Er = $r.border), "padding" in $r && lr(15, Cr = $r.padding), "rounded" in $r && lr(16, Tr = $r.rounded), "regionInterface" in $r && lr(3, Sr = $r.regionInterface), "regionInterfaceText" in $r && lr(4, Lr = $r.regionInterfaceText), "slotLead" in $r && lr(5, Ir = $r.slotLead), "slotMessage" in $r && lr(6, Nr = $r.slotMessage), "slotMeta" in $r && lr(7, Rr = $r.slotMeta), "$$scope" in $r && lr(17, yr = $r.$$scope);
  }, cr.$$.update = () => {
    var $r;
    lr(10, ur = `${cBase$i} ${Er} ${Cr} ${Tr} ${($r = ar.class) != null ? $r : ""}`);
  }, lr(9, dr = `${cInput}`), lr(8, fr = `${cInterface$2}`), ar = exclude_internal_props(ar), [
    kr,
    xr,
    Ar,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    fr,
    dr,
    ur,
    Mr,
    mr,
    _r,
    Er,
    Cr,
    Tr,
    yr,
    vr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr
  ];
}
class FileDropzone extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$A,
      create_fragment$V,
      safe_not_equal,
      {
        files: 0,
        fileInput: 1,
        name: 2,
        border: 14,
        padding: 15,
        rounded: 16,
        regionInterface: 3,
        regionInterfaceText: 4,
        slotLead: 5,
        slotMessage: 6,
        slotMeta: 7
      },
      null,
      [-1, -1]
    );
  }
  get files() {
    return this.$$.ctx[0];
  }
  set files(ar) {
    this.$$set({ files: ar }), flush();
  }
  get fileInput() {
    return this.$$.ctx[1];
  }
  set fileInput(ar) {
    this.$$set({ fileInput: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[15];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[16];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionInterface() {
    return this.$$.ctx[3];
  }
  set regionInterface(ar) {
    this.$$set({ regionInterface: ar }), flush();
  }
  get regionInterfaceText() {
    return this.$$.ctx[4];
  }
  set regionInterfaceText(ar) {
    this.$$set({ regionInterfaceText: ar }), flush();
  }
  get slotLead() {
    return this.$$.ctx[5];
  }
  set slotLead(ar) {
    this.$$set({ slotLead: ar }), flush();
  }
  get slotMessage() {
    return this.$$.ctx[6];
  }
  set slotMessage(ar) {
    this.$$set({ slotMessage: ar }), flush();
  }
  get slotMeta() {
    return this.$$.ctx[7];
  }
  set slotMeta(ar) {
    this.$$set({ slotMeta: ar }), flush();
  }
}
create_custom_element(FileDropzone, { files: {}, fileInput: {}, name: {}, border: {}, padding: {}, rounded: {}, regionInterface: {}, regionInterfaceText: {}, slotLead: {}, slotMessage: {}, slotMeta: {} }, ["lead", "message", "meta"], [], !0);
function flip(cr, { from: ar, to: lr }, ur = {}) {
  const dr = getComputedStyle(cr), fr = dr.transform === "none" ? "" : dr.transform, [gr, mr] = dr.transformOrigin.split(" ").map(parseFloat), vr = ar.left + ar.width * gr / lr.width - (lr.left + gr), yr = ar.top + ar.height * mr / lr.height - (lr.top + mr), { delay: _r = 0, duration: kr = (Ar) => Math.sqrt(Ar) * 120, easing: xr = cubicOut } = ur;
  return {
    delay: _r,
    duration: is_function(kr) ? kr(Math.sqrt(vr * vr + yr * yr)) : kr,
    easing: xr,
    css: (Ar, Er) => {
      const Cr = Er * vr, Tr = Er * yr, Sr = Ar + Er * ar.width / lr.width, Lr = Ar + Er * ar.height / lr.height;
      return `transform: ${fr} translate(${Cr}px, ${Tr}px) scale(${Sr}, ${Lr});`;
    }
  };
}
function get_each_context$a(cr, ar, lr) {
  const ur = cr.slice();
  return ur[56] = ar[lr].id, ur[57] = ar[lr].val, ur[59] = lr, ur;
}
function get_each_context_1$4(cr, ar, lr) {
  const ur = cr.slice();
  return ur[60] = ar[lr], ur;
}
function create_each_block_1$4(cr) {
  let ar, lr = (
    /*option*/
    cr[60] + ""
  ), ur, dr;
  return {
    c() {
      ar = element("option"), ur = text$3(lr), ar.__value = dr = /*option*/
      cr[60], set_input_value(ar, ar.__value);
    },
    m(fr, gr) {
      insert(fr, ar, gr), append(ar, ur);
    },
    p(fr, gr) {
      gr[0] & /*value*/
      1 && lr !== (lr = /*option*/
      fr[60] + "") && set_data(ur, lr), gr[0] & /*value*/
      1 && dr !== (dr = /*option*/
      fr[60]) && (ar.__value = dr, set_input_value(ar, ar.__value));
    },
    d(fr) {
      fr && detach(ar);
    }
  };
}
function create_if_block$p(cr) {
  let ar, lr = [], ur = /* @__PURE__ */ new Map(), dr, fr, gr, mr, vr = ensure_array_like(
    /*chipValues*/
    cr[15]
  );
  const yr = (_r) => (
    /*id*/
    _r[56]
  );
  for (let _r = 0; _r < vr.length; _r += 1) {
    let kr = get_each_context$a(cr, vr, _r), xr = yr(kr);
    ur.set(xr, lr[_r] = create_each_block$a(xr, kr));
  }
  return {
    c() {
      ar = element("div");
      for (let _r = 0; _r < lr.length; _r += 1)
        lr[_r].c();
      attr(ar, "class", dr = "input-chip-list " + /*classesChipList*/
      cr[18]);
    },
    m(_r, kr) {
      insert(_r, ar, kr);
      for (let xr = 0; xr < lr.length; xr += 1)
        lr[xr] && lr[xr].m(ar, null);
      mr = !0;
    },
    p(_r, kr) {
      if (cr = _r, kr[0] & /*chips, chipTransitionOut, chipTransitionOutParams, transitions, removeChip, chipValues*/
      8446048) {
        vr = ensure_array_like(
          /*chipValues*/
          cr[15]
        ), group_outros();
        for (let xr = 0; xr < lr.length; xr += 1)
          lr[xr].r();
        lr = update_keyed_each(lr, kr, yr, 1, cr, vr, ur, ar, fix_and_outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
        for (let xr = 0; xr < lr.length; xr += 1)
          lr[xr].a();
        check_outros();
      }
      (!mr || kr[0] & /*classesChipList*/
      262144 && dr !== (dr = "input-chip-list " + /*classesChipList*/
      cr[18])) && attr(ar, "class", dr);
    },
    i(_r) {
      if (!mr) {
        for (let kr = 0; kr < vr.length; kr += 1)
          transition_in(lr[kr]);
        _r && add_render_callback(() => {
          mr && (gr && gr.end(1), fr = create_in_transition(ar, dynamicTransition, {
            transition: (
              /*listTransitionIn*/
              cr[7]
            ),
            params: (
              /*listTransitionInParams*/
              cr[8]
            ),
            enabled: (
              /*transitions*/
              cr[6]
            )
          }), fr.start());
        }), mr = !0;
      }
    },
    o(_r) {
      for (let kr = 0; kr < lr.length; kr += 1)
        transition_out(lr[kr]);
      fr && fr.invalidate(), _r && (gr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*listTransitionOut*/
          cr[9]
        ),
        params: (
          /*listTransitionOutParams*/
          cr[10]
        ),
        enabled: (
          /*transitions*/
          cr[6]
        )
      })), mr = !1;
    },
    d(_r) {
      _r && detach(ar);
      for (let kr = 0; kr < lr.length; kr += 1)
        lr[kr].d();
      _r && gr && gr.end();
    }
  };
}
function create_each_block$a(cr, ar) {
  let lr, ur, dr, fr = (
    /*val*/
    ar[57] + ""
  ), gr, mr, vr, yr, _r, kr, xr, Ar, Er = noop$1, Cr, Tr, Sr;
  function Lr(...Ir) {
    return (
      /*click_handler_1*/
      ar[50](
        /*i*/
        ar[59],
        /*val*/
        ar[57],
        ...Ir
      )
    );
  }
  return {
    key: cr,
    first: null,
    c() {
      lr = element("div"), ur = element("button"), dr = element("span"), gr = text$3(fr), mr = space(), vr = element("span"), vr.textContent = "", xr = space(), attr(ur, "type", "button"), attr(ur, "class", yr = "chip " + /*chips*/
      ar[5]), this.first = lr;
    },
    m(Ir, Nr) {
      insert(Ir, lr, Nr), append(lr, ur), append(ur, dr), append(dr, gr), append(ur, mr), append(ur, vr), append(lr, xr), Cr = !0, Tr || (Sr = [
        listen(ur, "click", Lr),
        listen(
          ur,
          "click",
          /*click_handler*/
          ar[40]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          ar[41]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          ar[42]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          ar[43]
        )
      ], Tr = !0);
    },
    p(Ir, Nr) {
      ar = Ir, (!Cr || Nr[0] & /*chipValues*/
      32768) && fr !== (fr = /*val*/
      ar[57] + "") && set_data(gr, fr), (!Cr || Nr[0] & /*chips*/
      32 && yr !== (yr = "chip " + /*chips*/
      ar[5])) && attr(ur, "class", yr);
    },
    r() {
      Ar = lr.getBoundingClientRect();
    },
    f() {
      fix_position(lr), Er();
    },
    a() {
      Er(), Er = create_animation(lr, Ar, flip, { duration: (
        /*duration*/
        ar[3]
      ) });
    },
    i(Ir) {
      Cr || (Ir && add_render_callback(() => {
        Cr && (kr && kr.end(1), _r = create_in_transition(ur, dynamicTransition, {
          transition: (
            /*chipTransitionIn*/
            ar[11]
          ),
          params: (
            /*chipTransitionInParams*/
            ar[12]
          ),
          enabled: (
            /*transitions*/
            ar[6]
          )
        }), _r.start());
      }), Cr = !0);
    },
    o(Ir) {
      _r && _r.invalidate(), Ir && (kr = create_out_transition(ur, dynamicTransition, {
        transition: (
          /*chipTransitionOut*/
          ar[13]
        ),
        params: (
          /*chipTransitionOutParams*/
          ar[14]
        ),
        enabled: (
          /*transitions*/
          ar[6]
        )
      })), Cr = !1;
    },
    d(Ir) {
      Ir && detach(lr), Ir && kr && kr.end(), Tr = !1, run_all(Sr);
    }
  };
}
function create_fragment$U(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr = ensure_array_like(
    /*value*/
    cr[0]
  ), Lr = [];
  for (let Nr = 0; Nr < Sr.length; Nr += 1)
    Lr[Nr] = create_each_block_1$4(get_each_context_1$4(cr, Sr, Nr));
  let Ir = (
    /*chipValues*/
    cr[15].length && create_if_block$p(cr)
  );
  return {
    c() {
      var Nr;
      ar = element("div"), lr = element("div"), ur = element("select");
      for (let Rr = 0; Rr < Lr.length; Rr += 1)
        Lr[Rr].c();
      dr = space(), fr = element("div"), gr = element("form"), mr = element("input"), kr = space(), Ir && Ir.c(), attr(
        ur,
        "name",
        /*name*/
        cr[2]
      ), ur.multiple = !0, ur.required = /*required*/
      cr[4], attr(ur, "tabindex", "-1"), /*value*/
      cr[0] === void 0 && add_render_callback(() => (
        /*select_change_handler*/
        cr[48].call(ur)
      )), attr(lr, "class", "h-0 overflow-hidden"), attr(mr, "type", "text"), attr(mr, "placeholder", vr = /*$$restProps*/
      (Nr = cr[24].placeholder) != null ? Nr : "Enter values..."), attr(mr, "class", yr = "input-chip-field " + /*classesInput*/
      cr[17]), mr.disabled = _r = /*$$restProps*/
      cr[24].disabled, attr(fr, "class", xr = "input-chip-wrapper " + /*classesChipWrapper*/
      cr[19]), attr(ar, "class", Ar = "input-chip " + /*classesBase*/
      cr[20]), toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        cr[24].disabled
      );
    },
    m(Nr, Rr) {
      insert(Nr, ar, Rr), append(ar, lr), append(lr, ur);
      for (let Mr = 0; Mr < Lr.length; Mr += 1)
        Lr[Mr] && Lr[Mr].m(ur, null);
      cr[47](ur), select_options(
        ur,
        /*value*/
        cr[0]
      ), append(ar, dr), append(ar, fr), append(fr, gr), append(gr, mr), set_input_value(
        mr,
        /*input*/
        cr[1]
      ), append(fr, kr), Ir && Ir.m(fr, null), Er = !0, Cr || (Tr = [
        listen(
          ur,
          "change",
          /*select_change_handler*/
          cr[48]
        ),
        listen(
          mr,
          "input",
          /*input_1_input_handler*/
          cr[49]
        ),
        listen(
          mr,
          "input",
          /*onInputHandler*/
          cr[21]
        ),
        listen(
          mr,
          "input",
          /*input_handler*/
          cr[44]
        ),
        listen(
          mr,
          "focus",
          /*focus_handler*/
          cr[45]
        ),
        listen(
          mr,
          "blur",
          /*blur_handler*/
          cr[46]
        ),
        listen(
          gr,
          "submit",
          /*addChip*/
          cr[22]
        )
      ], Cr = !0);
    },
    p(Nr, Rr) {
      var Mr;
      if (Rr[0] & /*value*/
      1) {
        Sr = ensure_array_like(
          /*value*/
          Nr[0]
        );
        let Br;
        for (Br = 0; Br < Sr.length; Br += 1) {
          const Dr = get_each_context_1$4(Nr, Sr, Br);
          Lr[Br] ? Lr[Br].p(Dr, Rr) : (Lr[Br] = create_each_block_1$4(Dr), Lr[Br].c(), Lr[Br].m(ur, null));
        }
        for (; Br < Lr.length; Br += 1)
          Lr[Br].d(1);
        Lr.length = Sr.length;
      }
      (!Er || Rr[0] & /*name*/
      4) && attr(
        ur,
        "name",
        /*name*/
        Nr[2]
      ), (!Er || Rr[0] & /*required*/
      16) && (ur.required = /*required*/
      Nr[4]), Rr[0] & /*value*/
      1 && select_options(
        ur,
        /*value*/
        Nr[0]
      ), (!Er || Rr[0] & /*$$restProps*/
      16777216 && vr !== (vr = /*$$restProps*/
      (Mr = Nr[24].placeholder) != null ? Mr : "Enter values...")) && attr(mr, "placeholder", vr), (!Er || Rr[0] & /*classesInput*/
      131072 && yr !== (yr = "input-chip-field " + /*classesInput*/
      Nr[17])) && attr(mr, "class", yr), (!Er || Rr[0] & /*$$restProps*/
      16777216 && _r !== (_r = /*$$restProps*/
      Nr[24].disabled)) && (mr.disabled = _r), Rr[0] & /*input*/
      2 && mr.value !== /*input*/
      Nr[1] && set_input_value(
        mr,
        /*input*/
        Nr[1]
      ), /*chipValues*/
      Nr[15].length ? Ir ? (Ir.p(Nr, Rr), Rr[0] & /*chipValues*/
      32768 && transition_in(Ir, 1)) : (Ir = create_if_block$p(Nr), Ir.c(), transition_in(Ir, 1), Ir.m(fr, null)) : Ir && (group_outros(), transition_out(Ir, 1, 1, () => {
        Ir = null;
      }), check_outros()), (!Er || Rr[0] & /*classesChipWrapper*/
      524288 && xr !== (xr = "input-chip-wrapper " + /*classesChipWrapper*/
      Nr[19])) && attr(fr, "class", xr), (!Er || Rr[0] & /*classesBase*/
      1048576 && Ar !== (Ar = "input-chip " + /*classesBase*/
      Nr[20])) && attr(ar, "class", Ar), (!Er || Rr[0] & /*classesBase, $$restProps*/
      17825792) && toggle_class(
        ar,
        "opacity-50",
        /*$$restProps*/
        Nr[24].disabled
      );
    },
    i(Nr) {
      Er || (transition_in(Ir), Er = !0);
    },
    o(Nr) {
      transition_out(Ir), Er = !1;
    },
    d(Nr) {
      Nr && detach(ar), destroy_each(Lr, Nr), cr[47](null), Ir && Ir.d(), Cr = !1, run_all(Tr);
    }
  };
}
const cBase$h = "textarea cursor-pointer", cChipWrapper = "space-y-4", cChipList = "flex flex-wrap gap-2", cInputField = "unstyled bg-transparent border-0 !ring-0 p-0 w-full";
function instance$z(cr, ar, lr) {
  let ur, dr, fr, gr, mr;
  const vr = [
    "input",
    "name",
    "value",
    "whitelist",
    "max",
    "minlength",
    "maxlength",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "duration",
    "required",
    "chips",
    "invalid",
    "padding",
    "rounded",
    "regionChipWrapper",
    "regionChipList",
    "regionInput",
    "transitions",
    "listTransitionIn",
    "listTransitionInParams",
    "listTransitionOut",
    "listTransitionOutParams",
    "chipTransitionIn",
    "chipTransitionInParams",
    "chipTransitionOut",
    "chipTransitionOutParams"
  ];
  let yr = compute_rest_props(ar, vr), _r;
  component_subscribe(cr, prefersReducedMotionStore, (ai) => lr(51, _r = ai));
  const kr = createEventDispatcher();
  let { input: xr = "" } = ar, { name: Ar } = ar, { value: Er = [] } = ar, { whitelist: Cr = [] } = ar, { max: Tr = -1 } = ar, { minlength: Sr = -1 } = ar, { maxlength: Lr = -1 } = ar, { allowUpperCase: Ir = !1 } = ar, { allowDuplicates: Nr = !1 } = ar, { validation: Rr = () => !0 } = ar, { duration: Mr = 150 } = ar, { required: Br = !1 } = ar, { chips: Dr = "variant-filled" } = ar, { invalid: Hr = "input-error" } = ar, { padding: Fr = "p-2" } = ar, { rounded: zr = "rounded-container-token" } = ar, { regionChipWrapper: Ur = "" } = ar, { regionChipList: jr = "" } = ar, { regionInput: Yr = "" } = ar, { transitions: qr = !_r } = ar, { listTransitionIn: Wr = fly } = ar, { listTransitionInParams: Jr = { duration: 150, opacity: 0, y: -20 } } = ar, { listTransitionOut: Gr = fly } = ar, { listTransitionOutParams: Vr = { duration: 150, opacity: 0, y: -20 } } = ar, { chipTransitionIn: Qr = scale } = ar, { chipTransitionInParams: $r = { duration: 150, opacity: 0 } } = ar, { chipTransitionOut: Xr = scale } = ar, { chipTransitionOutParams: si = { duration: 150, opacity: 0 } } = ar, Zr = !0, li = (Er == null ? void 0 : Er.map((ai) => ({ val: ai, id: Math.random() }))) || [];
  function Ei() {
    lr(0, Er = []);
  }
  let ki;
  onMount(() => {
    if (!ki.form)
      return;
    const ai = ki.form;
    return ai.addEventListener("reset", Ei), () => {
      ai.removeEventListener("reset", Ei);
    };
  });
  function Di() {
    lr(38, Zr = !0);
  }
  function hi() {
    return !(!xr || (lr(1, xr = xr.trim()), Rr !== void 0 && !Rr(xr)) || Tr !== -1 && Er.length >= Tr || Sr !== -1 && xr.length < Sr || Lr !== -1 && xr.length > Lr || Cr.length > 0 && !Cr.includes(xr) || Nr === !1 && Er.includes(xr));
  }
  function Ti(ai) {
    if (ai.preventDefault(), lr(38, Zr = hi()), Zr === !1) {
      kr("invalid", { event: ai, input: xr });
      return;
    }
    lr(1, xr = Ir ? xr : xr.toLowerCase()), Er.push(xr), lr(0, Er), li.push({ val: xr, id: Math.random() }), lr(15, li), lr(0, Er), kr("add", {
      event: ai,
      chipIndex: Er.length - 1,
      chipValue: xr
    }), lr(1, xr = "");
  }
  function fi(ai, Li, $i) {
    yr.disabled || (Er.splice(Li, 1), lr(0, Er), li.splice(Li, 1), lr(15, li), lr(0, Er), kr("remove", { event: ai, chipIndex: Li, chipValue: $i }));
  }
  function Mi(ai) {
    bubble.call(this, cr, ai);
  }
  function oi(ai) {
    bubble.call(this, cr, ai);
  }
  function Ri(ai) {
    bubble.call(this, cr, ai);
  }
  function qi(ai) {
    bubble.call(this, cr, ai);
  }
  function zi(ai) {
    bubble.call(this, cr, ai);
  }
  function to(ai) {
    bubble.call(this, cr, ai);
  }
  function Hi(ai) {
    bubble.call(this, cr, ai);
  }
  function _i(ai) {
    binding_callbacks[ai ? "unshift" : "push"](() => {
      ki = ai, lr(16, ki);
    });
  }
  function Ai() {
    Er = select_multiple_value(this), lr(0, Er);
  }
  function ui() {
    xr = this.value, lr(1, xr);
  }
  const ji = (ai, Li, $i) => {
    fi($i, ai, Li);
  };
  return cr.$$set = (ai) => {
    lr(55, ar = assign$1(assign$1({}, ar), exclude_internal_props(ai))), lr(24, yr = compute_rest_props(ar, vr)), "input" in ai && lr(1, xr = ai.input), "name" in ai && lr(2, Ar = ai.name), "value" in ai && lr(0, Er = ai.value), "whitelist" in ai && lr(25, Cr = ai.whitelist), "max" in ai && lr(26, Tr = ai.max), "minlength" in ai && lr(27, Sr = ai.minlength), "maxlength" in ai && lr(28, Lr = ai.maxlength), "allowUpperCase" in ai && lr(29, Ir = ai.allowUpperCase), "allowDuplicates" in ai && lr(30, Nr = ai.allowDuplicates), "validation" in ai && lr(31, Rr = ai.validation), "duration" in ai && lr(3, Mr = ai.duration), "required" in ai && lr(4, Br = ai.required), "chips" in ai && lr(5, Dr = ai.chips), "invalid" in ai && lr(32, Hr = ai.invalid), "padding" in ai && lr(33, Fr = ai.padding), "rounded" in ai && lr(34, zr = ai.rounded), "regionChipWrapper" in ai && lr(35, Ur = ai.regionChipWrapper), "regionChipList" in ai && lr(36, jr = ai.regionChipList), "regionInput" in ai && lr(37, Yr = ai.regionInput), "transitions" in ai && lr(6, qr = ai.transitions), "listTransitionIn" in ai && lr(7, Wr = ai.listTransitionIn), "listTransitionInParams" in ai && lr(8, Jr = ai.listTransitionInParams), "listTransitionOut" in ai && lr(9, Gr = ai.listTransitionOut), "listTransitionOutParams" in ai && lr(10, Vr = ai.listTransitionOutParams), "chipTransitionIn" in ai && lr(11, Qr = ai.chipTransitionIn), "chipTransitionInParams" in ai && lr(12, $r = ai.chipTransitionInParams), "chipTransitionOut" in ai && lr(13, Xr = ai.chipTransitionOut), "chipTransitionOutParams" in ai && lr(14, si = ai.chipTransitionOutParams);
  }, cr.$$.update = () => {
    var ai;
    cr.$$.dirty[1] & /*inputValid, invalid*/
    130 && lr(39, ur = Zr === !1 ? Hr : ""), lr(20, dr = `${cBase$h} ${Fr} ${zr} ${(ai = ar.class) != null ? ai : ""} ${ur}`), cr.$$.dirty[1] & /*regionChipWrapper*/
    16 && lr(19, fr = `${cChipWrapper} ${Ur}`), cr.$$.dirty[1] & /*regionChipList*/
    32 && lr(18, gr = `${cChipList} ${jr}`), cr.$$.dirty[1] & /*regionInput*/
    64 && lr(17, mr = `${cInputField} ${Yr}`), cr.$$.dirty[0] & /*value, chipValues*/
    32769 && lr(15, li = (Er == null ? void 0 : Er.map((Li, $i) => {
      var Wi;
      return ((Wi = li[$i]) == null ? void 0 : Wi.val) === Li ? li[$i] : { id: Math.random(), val: Li };
    })) || []);
  }, ar = exclude_internal_props(ar), [
    Er,
    xr,
    Ar,
    Mr,
    Br,
    Dr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr,
    $r,
    Xr,
    si,
    li,
    ki,
    mr,
    gr,
    fr,
    dr,
    Di,
    Ti,
    fi,
    yr,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    Zr,
    ur,
    Mi,
    oi,
    Ri,
    qi,
    zi,
    to,
    Hi,
    _i,
    Ai,
    ui,
    ji
  ];
}
class InputChip extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$z,
      create_fragment$U,
      safe_not_equal,
      {
        input: 1,
        name: 2,
        value: 0,
        whitelist: 25,
        max: 26,
        minlength: 27,
        maxlength: 28,
        allowUpperCase: 29,
        allowDuplicates: 30,
        validation: 31,
        duration: 3,
        required: 4,
        chips: 5,
        invalid: 32,
        padding: 33,
        rounded: 34,
        regionChipWrapper: 35,
        regionChipList: 36,
        regionInput: 37,
        transitions: 6,
        listTransitionIn: 7,
        listTransitionInParams: 8,
        listTransitionOut: 9,
        listTransitionOutParams: 10,
        chipTransitionIn: 11,
        chipTransitionInParams: 12,
        chipTransitionOut: 13,
        chipTransitionOutParams: 14
      },
      null,
      [-1, -1, -1]
    );
  }
  get input() {
    return this.$$.ctx[1];
  }
  set input(ar) {
    this.$$set({ input: ar }), flush();
  }
  get name() {
    return this.$$.ctx[2];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get whitelist() {
    return this.$$.ctx[25];
  }
  set whitelist(ar) {
    this.$$set({ whitelist: ar }), flush();
  }
  get max() {
    return this.$$.ctx[26];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get minlength() {
    return this.$$.ctx[27];
  }
  set minlength(ar) {
    this.$$set({ minlength: ar }), flush();
  }
  get maxlength() {
    return this.$$.ctx[28];
  }
  set maxlength(ar) {
    this.$$set({ maxlength: ar }), flush();
  }
  get allowUpperCase() {
    return this.$$.ctx[29];
  }
  set allowUpperCase(ar) {
    this.$$set({ allowUpperCase: ar }), flush();
  }
  get allowDuplicates() {
    return this.$$.ctx[30];
  }
  set allowDuplicates(ar) {
    this.$$set({ allowDuplicates: ar }), flush();
  }
  get validation() {
    return this.$$.ctx[31];
  }
  set validation(ar) {
    this.$$set({ validation: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[3];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get required() {
    return this.$$.ctx[4];
  }
  set required(ar) {
    this.$$set({ required: ar }), flush();
  }
  get chips() {
    return this.$$.ctx[5];
  }
  set chips(ar) {
    this.$$set({ chips: ar }), flush();
  }
  get invalid() {
    return this.$$.ctx[32];
  }
  set invalid(ar) {
    this.$$set({ invalid: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[33];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get regionChipWrapper() {
    return this.$$.ctx[35];
  }
  set regionChipWrapper(ar) {
    this.$$set({ regionChipWrapper: ar }), flush();
  }
  get regionChipList() {
    return this.$$.ctx[36];
  }
  set regionChipList(ar) {
    this.$$set({ regionChipList: ar }), flush();
  }
  get regionInput() {
    return this.$$.ctx[37];
  }
  set regionInput(ar) {
    this.$$set({ regionInput: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[6];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get listTransitionIn() {
    return this.$$.ctx[7];
  }
  set listTransitionIn(ar) {
    this.$$set({ listTransitionIn: ar }), flush();
  }
  get listTransitionInParams() {
    return this.$$.ctx[8];
  }
  set listTransitionInParams(ar) {
    this.$$set({ listTransitionInParams: ar }), flush();
  }
  get listTransitionOut() {
    return this.$$.ctx[9];
  }
  set listTransitionOut(ar) {
    this.$$set({ listTransitionOut: ar }), flush();
  }
  get listTransitionOutParams() {
    return this.$$.ctx[10];
  }
  set listTransitionOutParams(ar) {
    this.$$set({ listTransitionOutParams: ar }), flush();
  }
  get chipTransitionIn() {
    return this.$$.ctx[11];
  }
  set chipTransitionIn(ar) {
    this.$$set({ chipTransitionIn: ar }), flush();
  }
  get chipTransitionInParams() {
    return this.$$.ctx[12];
  }
  set chipTransitionInParams(ar) {
    this.$$set({ chipTransitionInParams: ar }), flush();
  }
  get chipTransitionOut() {
    return this.$$.ctx[13];
  }
  set chipTransitionOut(ar) {
    this.$$set({ chipTransitionOut: ar }), flush();
  }
  get chipTransitionOutParams() {
    return this.$$.ctx[14];
  }
  set chipTransitionOutParams(ar) {
    this.$$set({ chipTransitionOutParams: ar }), flush();
  }
}
create_custom_element(InputChip, { input: {}, name: {}, value: {}, whitelist: {}, max: {}, minlength: {}, maxlength: {}, allowUpperCase: { type: "Boolean" }, allowDuplicates: { type: "Boolean" }, validation: {}, duration: {}, required: { type: "Boolean" }, chips: {}, invalid: {}, padding: {}, rounded: {}, regionChipWrapper: {}, regionChipList: {}, regionInput: {}, transitions: {}, listTransitionIn: {}, listTransitionInParams: {}, listTransitionOut: {}, listTransitionOutParams: {}, chipTransitionIn: {}, chipTransitionInParams: {}, chipTransitionOut: {}, chipTransitionOutParams: {} }, [], [], !0);
function create_fragment$T(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[12].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[11],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "listbox " + /*classesBase*/
      cr[1]), attr(ar, "role", "listbox"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        cr[0]
      ), attr(ar, "data-testid", "listbox");
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      2048) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[11],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[11],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[11]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      2 && lr !== (lr = "listbox " + /*classesBase*/
      gr[1])) && attr(ar, "class", lr), (!ur || mr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        gr[0]
      );
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
const cBase$g = "";
function instance$y(cr, ar, lr) {
  let ur, { $$slots: dr = {}, $$scope: fr } = ar, { multiple: gr = !1 } = ar, { spacing: mr = "space-y-1" } = ar, { rounded: vr = "rounded-token" } = ar, { active: yr = "variant-filled" } = ar, { hover: _r = "hover:variant-soft" } = ar, { padding: kr = "px-4 py-2" } = ar, { regionLead: xr = "" } = ar, { regionDefault: Ar = "" } = ar, { regionTrail: Er = "" } = ar, { labelledby: Cr = "" } = ar;
  return setContext("multiple", gr), setContext("rounded", vr), setContext("active", yr), setContext("hover", _r), setContext("padding", kr), setContext("regionLead", xr), setContext("regionDefault", Ar), setContext("regionTrail", Er), cr.$$set = (Tr) => {
    lr(13, ar = assign$1(assign$1({}, ar), exclude_internal_props(Tr))), "multiple" in Tr && lr(2, gr = Tr.multiple), "spacing" in Tr && lr(3, mr = Tr.spacing), "rounded" in Tr && lr(4, vr = Tr.rounded), "active" in Tr && lr(5, yr = Tr.active), "hover" in Tr && lr(6, _r = Tr.hover), "padding" in Tr && lr(7, kr = Tr.padding), "regionLead" in Tr && lr(8, xr = Tr.regionLead), "regionDefault" in Tr && lr(9, Ar = Tr.regionDefault), "regionTrail" in Tr && lr(10, Er = Tr.regionTrail), "labelledby" in Tr && lr(0, Cr = Tr.labelledby), "$$scope" in Tr && lr(11, fr = Tr.$$scope);
  }, cr.$$.update = () => {
    var Tr;
    lr(1, ur = `${cBase$g} ${mr} ${vr} ${(Tr = ar.class) != null ? Tr : ""}`);
  }, ar = exclude_internal_props(ar), [
    Cr,
    ur,
    gr,
    mr,
    vr,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    fr,
    dr
  ];
}
class ListBox extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$y, create_fragment$T, safe_not_equal, {
      multiple: 2,
      spacing: 3,
      rounded: 4,
      active: 5,
      hover: 6,
      padding: 7,
      regionLead: 8,
      regionDefault: 9,
      regionTrail: 10,
      labelledby: 0
    });
  }
  get multiple() {
    return this.$$.ctx[2];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[3];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[4];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[5];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[6];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[8];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[9];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[10];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ListBox, { multiple: { type: "Boolean" }, spacing: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {}, labelledby: {} }, ["default"], [], !0);
const get_trail_slot_changes$1 = (cr) => ({}), get_trail_slot_context$1 = (cr) => ({}), get_lead_slot_changes$3 = (cr) => ({}), get_lead_slot_context$3 = (cr) => ({});
function create_else_block$b(cr) {
  let ar, lr = !1, ur, dr, fr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    cr[35][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        cr[1]
      ), ar.__value = /*value*/
      cr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1"), ur.p(ar);
    },
    m(gr, mr) {
      insert(gr, ar, mr), cr[33](ar), ar.checked = ar.__value === /*group*/
      cr[0], dr || (fr = [
        listen(
          ar,
          "change",
          /*input_change_handler_1*/
          cr[34]
        ),
        listen(
          ar,
          "click",
          /*click_handler_1*/
          cr[29]
        ),
        listen(
          ar,
          "change",
          /*change_handler_1*/
          cr[30]
        )
      ], dr = !0);
    },
    p(gr, mr) {
      mr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        gr[1]
      ), mr[0] & /*value*/
      4 && (ar.__value = /*value*/
      gr[2], set_input_value(ar, ar.__value), lr = !0), (lr || mr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      gr[0]);
    },
    d(gr) {
      gr && detach(ar), cr[33](null), ur.r(), dr = !1, run_all(fr);
    }
  };
}
function create_if_block_2$a(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        cr[1]
      ), ar.__value = /*value*/
      cr[2], set_input_value(ar, ar.__value), attr(ar, "tabindex", "-1");
    },
    m(dr, fr) {
      insert(dr, ar, fr), cr[31](ar), ar.checked = /*checked*/
      cr[4], lr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          cr[32]
        ),
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[27]
        ),
        listen(
          ar,
          "change",
          /*change_handler*/
          cr[28]
        )
      ], lr = !0);
    },
    p(dr, fr) {
      fr[0] & /*name*/
      2 && attr(
        ar,
        "name",
        /*name*/
        dr[1]
      ), fr[0] & /*value*/
      4 && (ar.__value = /*value*/
      dr[2], set_input_value(ar, ar.__value)), fr[0] & /*checked*/
      16 && (ar.checked = /*checked*/
      dr[4]);
    },
    d(dr) {
      dr && detach(ar), cr[31](null), lr = !1, run_all(ur);
    }
  };
}
function create_if_block_1$c(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[23].lead
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[22],
    get_lead_slot_context$3
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "listbox-label-lead " + /*classesRegionLead*/
      cr[9]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[22],
          mr,
          get_lead_slot_changes$3
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_lead_slot_context$3
      ), (!ur || mr[0] & /*classesRegionLead*/
      512 && lr !== (lr = "listbox-label-lead " + /*classesRegionLead*/
      gr[9])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_if_block$o(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[23].trail
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[22],
    get_trail_slot_context$1
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "listbox-label-trail " + /*classesRegionTrail*/
      cr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr[0] & /*$$scope*/
      4194304) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[22],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[22],
          mr,
          get_trail_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[22]
        ),
        get_trail_slot_context$1
      ), (!ur || mr[0] & /*classesRegionTrail*/
      128 && lr !== (lr = "listbox-label-trail " + /*classesRegionTrail*/
      gr[7])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$S(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er;
  function Cr(Mr, Br) {
    return (
      /*multiple*/
      Mr[3] ? create_if_block_2$a : create_else_block$b
    );
  }
  let Tr = Cr(cr), Sr = Tr(cr), Lr = (
    /*$$slots*/
    cr[13].lead && create_if_block_1$c(cr)
  );
  const Ir = (
    /*#slots*/
    cr[23].default
  ), Nr = create_slot(
    Ir,
    cr,
    /*$$scope*/
    cr[22],
    null
  );
  let Rr = (
    /*$$slots*/
    cr[13].trail && create_if_block$o(cr)
  );
  return {
    c() {
      ar = element("label"), lr = element("div"), ur = element("div"), Sr.c(), dr = space(), fr = element("div"), Lr && Lr.c(), gr = space(), mr = element("div"), Nr && Nr.c(), yr = space(), Rr && Rr.c(), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(mr, "class", vr = "listbox-label-content " + /*classesRegionDefault*/
      cr[8]), attr(fr, "class", _r = "listbox-label " + /*classesLabel*/
      cr[10]), attr(lr, "class", kr = "listbox-item " + /*classesBase*/
      cr[11]), attr(lr, "data-testid", "listbox-item"), attr(lr, "role", "option"), attr(
        lr,
        "aria-selected",
        /*selected*/
        cr[5]
      ), attr(lr, "tabindex", "0");
    },
    m(Mr, Br) {
      insert(Mr, ar, Br), append(ar, lr), append(lr, ur), Sr.m(ur, null), append(lr, dr), append(lr, fr), Lr && Lr.m(fr, null), append(fr, gr), append(fr, mr), Nr && Nr.m(mr, null), append(fr, yr), Rr && Rr.m(fr, null), xr = !0, Ar || (Er = [
        listen(
          lr,
          "keydown",
          /*onKeyDown*/
          cr[12]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[24]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[25]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[26]
        )
      ], Ar = !0);
    },
    p(Mr, Br) {
      Tr === (Tr = Cr(Mr)) && Sr ? Sr.p(Mr, Br) : (Sr.d(1), Sr = Tr(Mr), Sr && (Sr.c(), Sr.m(ur, null))), /*$$slots*/
      Mr[13].lead ? Lr ? (Lr.p(Mr, Br), Br[0] & /*$$slots*/
      8192 && transition_in(Lr, 1)) : (Lr = create_if_block_1$c(Mr), Lr.c(), transition_in(Lr, 1), Lr.m(fr, gr)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!xr || Br[0] & /*$$scope*/
      4194304) && update_slot_base(
        Nr,
        Ir,
        Mr,
        /*$$scope*/
        Mr[22],
        xr ? get_slot_changes(
          Ir,
          /*$$scope*/
          Mr[22],
          Br,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Mr[22]
        ),
        null
      ), (!xr || Br[0] & /*classesRegionDefault*/
      256 && vr !== (vr = "listbox-label-content " + /*classesRegionDefault*/
      Mr[8])) && attr(mr, "class", vr), /*$$slots*/
      Mr[13].trail ? Rr ? (Rr.p(Mr, Br), Br[0] & /*$$slots*/
      8192 && transition_in(Rr, 1)) : (Rr = create_if_block$o(Mr), Rr.c(), transition_in(Rr, 1), Rr.m(fr, null)) : Rr && (group_outros(), transition_out(Rr, 1, 1, () => {
        Rr = null;
      }), check_outros()), (!xr || Br[0] & /*classesLabel*/
      1024 && _r !== (_r = "listbox-label " + /*classesLabel*/
      Mr[10])) && attr(fr, "class", _r), (!xr || Br[0] & /*classesBase*/
      2048 && kr !== (kr = "listbox-item " + /*classesBase*/
      Mr[11])) && attr(lr, "class", kr), (!xr || Br[0] & /*selected*/
      32) && attr(
        lr,
        "aria-selected",
        /*selected*/
        Mr[5]
      );
    },
    i(Mr) {
      xr || (transition_in(Lr), transition_in(Nr, Mr), transition_in(Rr), xr = !0);
    },
    o(Mr) {
      transition_out(Lr), transition_out(Nr, Mr), transition_out(Rr), xr = !1;
    },
    d(Mr) {
      Mr && detach(ar), Sr.d(), Lr && Lr.d(), Nr && Nr.d(Mr), Rr && Rr.d(), Ar = !1, run_all(Er);
    }
  };
}
const cBase$f = "cursor-pointer -outline-offset-[3px]", cLabel$2 = "flex items-center space-x-4", cRegionLead = "", cRegionDefault = "flex-1", cRegionTrail = "";
function areDeeplyEqual(cr, ar) {
  if (cr === ar)
    return !0;
  if (!(cr instanceof Object) || !(ar instanceof Object))
    return !1;
  const lr = Object.keys(cr), ur = Object.keys(ar);
  if (lr.length !== ur.length)
    return !1;
  for (const dr of lr) {
    const fr = cr[dr], gr = ar[dr];
    if (!areDeeplyEqual(fr, gr))
      return !1;
  }
  return !0;
}
function instance$x(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, { $$slots: _r = {}, $$scope: kr } = ar;
  const xr = compute_slots(_r);
  let { group: Ar } = ar, { name: Er } = ar, { value: Cr } = ar, { multiple: Tr = getContext("multiple") } = ar, { rounded: Sr = getContext("rounded") } = ar, { active: Lr = getContext("active") } = ar, { hover: Ir = getContext("hover") } = ar, { padding: Nr = getContext("padding") } = ar, { regionLead: Rr = getContext("regionLead") } = ar, { regionDefault: Mr = getContext("regionDefault") } = ar, { regionTrail: Br = getContext("regionTrail") } = ar, Dr, Hr;
  function Fr(li) {
    lr(4, Dr = li.indexOf(Cr) >= 0);
  }
  function zr(li) {
    const Ei = Ar.indexOf(Cr);
    li ? Ei < 0 && (Ar.push(Cr), lr(0, Ar)) : Ei >= 0 && (Ar.splice(Ei, 1), lr(0, Ar));
  }
  function Ur(li) {
    ["Enter", "Space"].includes(li.code) && (li.preventDefault(), Hr.click());
  }
  const jr = [[]];
  function Yr(li) {
    bubble.call(this, cr, li);
  }
  function qr(li) {
    bubble.call(this, cr, li);
  }
  function Wr(li) {
    bubble.call(this, cr, li);
  }
  function Jr(li) {
    bubble.call(this, cr, li);
  }
  function Gr(li) {
    bubble.call(this, cr, li);
  }
  function Vr(li) {
    bubble.call(this, cr, li);
  }
  function Qr(li) {
    bubble.call(this, cr, li);
  }
  function $r(li) {
    binding_callbacks[li ? "unshift" : "push"](() => {
      Hr = li, lr(6, Hr);
    });
  }
  function Xr() {
    Dr = this.checked, lr(4, Dr);
  }
  function si(li) {
    binding_callbacks[li ? "unshift" : "push"](() => {
      Hr = li, lr(6, Hr);
    });
  }
  function Zr() {
    Ar = this.__value, lr(0, Ar);
  }
  return cr.$$set = (li) => {
    lr(38, ar = assign$1(assign$1({}, ar), exclude_internal_props(li))), "group" in li && lr(0, Ar = li.group), "name" in li && lr(1, Er = li.name), "value" in li && lr(2, Cr = li.value), "multiple" in li && lr(3, Tr = li.multiple), "rounded" in li && lr(14, Sr = li.rounded), "active" in li && lr(15, Lr = li.active), "hover" in li && lr(16, Ir = li.hover), "padding" in li && lr(17, Nr = li.padding), "regionLead" in li && lr(18, Rr = li.regionLead), "regionDefault" in li && lr(19, Mr = li.regionDefault), "regionTrail" in li && lr(20, Br = li.regionTrail), "$$scope" in li && lr(22, kr = li.$$scope);
  }, cr.$$.update = () => {
    var li;
    cr.$$.dirty[0] & /*multiple, group*/
    9 && Tr && Fr(Ar), cr.$$.dirty[0] & /*multiple, checked*/
    24 && Tr && zr(Dr), cr.$$.dirty[0] & /*multiple, group, value*/
    13 && lr(5, ur = Tr ? Ar.some((Ei) => areDeeplyEqual(Cr, Ei)) : areDeeplyEqual(Ar, Cr)), cr.$$.dirty[0] & /*selected, active, hover*/
    98336 && lr(21, dr = ur ? Lr : Ir), lr(11, fr = `${cBase$f} ${Sr} ${Nr} ${dr} ${(li = ar.class) != null ? li : ""}`), cr.$$.dirty[0] & /*regionLead*/
    262144 && lr(9, mr = `${cRegionLead} ${Rr}`), cr.$$.dirty[0] & /*regionDefault*/
    524288 && lr(8, vr = `${cRegionDefault} ${Mr}`), cr.$$.dirty[0] & /*regionTrail*/
    1048576 && lr(7, yr = `${cRegionTrail} ${Br}`);
  }, lr(10, gr = `${cLabel$2}`), ar = exclude_internal_props(ar), [
    Ar,
    Er,
    Cr,
    Tr,
    Dr,
    ur,
    Hr,
    yr,
    vr,
    mr,
    gr,
    fr,
    Ur,
    xr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    dr,
    kr,
    _r,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr,
    $r,
    Xr,
    si,
    Zr,
    jr
  ];
}
class ListBoxItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$x,
      create_fragment$S,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        multiple: 3,
        rounded: 14,
        active: 15,
        hover: 16,
        padding: 17,
        regionLead: 18,
        regionDefault: 19,
        regionTrail: 20
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[3];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get active() {
    return this.$$.ctx[15];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[16];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[18];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionDefault() {
    return this.$$.ctx[19];
  }
  set regionDefault(ar) {
    this.$$set({ regionDefault: ar }), flush();
  }
  get regionTrail() {
    return this.$$.ctx[20];
  }
  set regionTrail(ar) {
    this.$$set({ regionTrail: ar }), flush();
  }
}
create_custom_element(ListBoxItem, { group: {}, name: {}, value: {}, multiple: {}, rounded: {}, active: {}, hover: {}, padding: {}, regionLead: {}, regionDefault: {}, regionTrail: {} }, ["lead", "default", "trail"], [], !0);
const leftArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>', rightArrow = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"/></svg>', leftAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/></svg>', rightAngles = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>';
function get_each_context$9(cr, ar, lr) {
  const ur = cr.slice();
  return ur[43] = ar[lr], ur;
}
function get_each_context_1$3(cr, ar, lr) {
  const ur = cr.slice();
  return ur[46] = ar[lr], ur;
}
function create_if_block_5$3(cr) {
  let ar, lr, ur, dr, fr, gr, mr = ensure_array_like(
    /*settings*/
    cr[0].amounts
  ), vr = [];
  for (let yr = 0; yr < mr.length; yr += 1)
    vr[yr] = create_each_block_1$3(get_each_context_1$3(cr, mr, yr));
  return {
    c() {
      ar = element("label"), lr = element("select");
      for (let yr = 0; yr < vr.length; yr += 1)
        vr[yr].c();
      attr(lr, "class", ur = "paginator-select " + /*classesSelect*/
      cr[19]), lr.disabled = /*disabled*/
      cr[1], attr(lr, "aria-label", "Select Amount"), /*settings*/
      cr[0].limit === void 0 && add_render_callback(() => (
        /*select_1_change_handler*/
        cr[32].call(lr)
      )), attr(ar, "class", dr = "paginator-label " + /*classesLabel*/
      cr[20]);
    },
    m(yr, _r) {
      insert(yr, ar, _r), append(ar, lr);
      for (let kr = 0; kr < vr.length; kr += 1)
        vr[kr] && vr[kr].m(lr, null);
      select_option(
        lr,
        /*settings*/
        cr[0].limit,
        !0
      ), fr || (gr = [
        listen(
          lr,
          "change",
          /*select_1_change_handler*/
          cr[32]
        ),
        listen(
          lr,
          "change",
          /*onChangeLength*/
          cr[23]
        )
      ], fr = !0);
    },
    p(yr, _r) {
      if (_r[0] & /*settings, amountText*/
      33) {
        mr = ensure_array_like(
          /*settings*/
          yr[0].amounts
        );
        let kr;
        for (kr = 0; kr < mr.length; kr += 1) {
          const xr = get_each_context_1$3(yr, mr, kr);
          vr[kr] ? vr[kr].p(xr, _r) : (vr[kr] = create_each_block_1$3(xr), vr[kr].c(), vr[kr].m(lr, null));
        }
        for (; kr < vr.length; kr += 1)
          vr[kr].d(1);
        vr.length = mr.length;
      }
      _r[0] & /*classesSelect*/
      524288 && ur !== (ur = "paginator-select " + /*classesSelect*/
      yr[19]) && attr(lr, "class", ur), _r[0] & /*disabled*/
      2 && (lr.disabled = /*disabled*/
      yr[1]), _r[0] & /*settings*/
      1 && select_option(
        lr,
        /*settings*/
        yr[0].limit
      ), _r[0] & /*classesLabel*/
      1048576 && dr !== (dr = "paginator-label " + /*classesLabel*/
      yr[20]) && attr(ar, "class", dr);
    },
    d(yr) {
      yr && detach(ar), destroy_each(vr, yr), fr = !1, run_all(gr);
    }
  };
}
function create_each_block_1$3(cr) {
  let ar, lr = (
    /*amount*/
    cr[46] + ""
  ), ur, dr, fr, gr;
  return {
    c() {
      ar = element("option"), ur = text$3(lr), dr = space(), fr = text$3(
        /*amountText*/
        cr[5]
      ), ar.__value = gr = /*amount*/
      cr[46], set_input_value(ar, ar.__value);
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, ur), append(ar, dr), append(ar, fr);
    },
    p(mr, vr) {
      vr[0] & /*settings*/
      1 && lr !== (lr = /*amount*/
      mr[46] + "") && set_data(ur, lr), vr[0] & /*amountText*/
      32 && set_data(
        fr,
        /*amountText*/
        mr[5]
      ), vr[0] & /*settings*/
      1 && gr !== (gr = /*amount*/
      mr[46]) && (ar.__value = gr, set_input_value(ar, ar.__value));
    },
    d(mr) {
      mr && detach(ar);
    }
  };
}
function create_if_block_4$5(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelFirst*/
        cr[12]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        cr[6]
      ), ar.disabled = lr = /*disabled*/
      cr[1] || /*settings*/
      cr[0].page === 0;
    },
    m(fr, gr) {
      insert(fr, ar, gr), ar.innerHTML = /*buttonTextFirst*/
      cr[9], ur || (dr = listen(
        ar,
        "click",
        /*click_handler*/
        cr[33]
      ), ur = !0);
    },
    p(fr, gr) {
      gr[0] & /*buttonTextFirst*/
      512 && (ar.innerHTML = /*buttonTextFirst*/
      fr[9]), gr[0] & /*labelFirst*/
      4096 && attr(
        ar,
        "aria-label",
        /*labelFirst*/
        fr[12]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        fr[6]
      ), gr[0] & /*disabled, settings*/
      3 && lr !== (lr = /*disabled*/
      fr[1] || /*settings*/
      fr[0].page === 0) && (ar.disabled = lr);
    },
    d(fr) {
      fr && detach(ar), ur = !1, dr();
    }
  };
}
function create_if_block_3$7(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        cr[13]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        cr[6]
      ), ar.disabled = lr = /*disabled*/
      cr[1] || /*settings*/
      cr[0].page === 0;
    },
    m(fr, gr) {
      insert(fr, ar, gr), ar.innerHTML = /*buttonTextPrevious*/
      cr[7], ur || (dr = listen(
        ar,
        "click",
        /*click_handler_1*/
        cr[34]
      ), ur = !0);
    },
    p(fr, gr) {
      gr[0] & /*buttonTextPrevious*/
      128 && (ar.innerHTML = /*buttonTextPrevious*/
      fr[7]), gr[0] & /*labelPrevious*/
      8192 && attr(
        ar,
        "aria-label",
        /*labelPrevious*/
        fr[13]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        fr[6]
      ), gr[0] & /*disabled, settings*/
      3 && lr !== (lr = /*disabled*/
      fr[1] || /*settings*/
      fr[0].page === 0) && (ar.disabled = lr);
    },
    d(fr) {
      fr && detach(ar), ur = !1, dr();
    }
  };
}
function create_else_block$a(cr) {
  let ar, lr = ensure_array_like(
    /*controlPages*/
    cr[17]
  ), ur = [];
  for (let dr = 0; dr < lr.length; dr += 1)
    ur[dr] = create_each_block$9(get_each_context$9(cr, lr, dr));
  return {
    c() {
      for (let dr = 0; dr < ur.length; dr += 1)
        ur[dr].c();
      ar = empty$2();
    },
    m(dr, fr) {
      for (let gr = 0; gr < ur.length; gr += 1)
        ur[gr] && ur[gr].m(dr, fr);
      insert(dr, ar, fr);
    },
    p(dr, fr) {
      if (fr[0] & /*buttonClasses, classesButtonActive, controlPages, gotoPage*/
      21102656) {
        lr = ensure_array_like(
          /*controlPages*/
          dr[17]
        );
        let gr;
        for (gr = 0; gr < lr.length; gr += 1) {
          const mr = get_each_context$9(dr, lr, gr);
          ur[gr] ? ur[gr].p(mr, fr) : (ur[gr] = create_each_block$9(mr), ur[gr].c(), ur[gr].m(ar.parentNode, ar));
        }
        for (; gr < ur.length; gr += 1)
          ur[gr].d(1);
        ur.length = lr.length;
      }
    },
    d(dr) {
      dr && detach(ar), destroy_each(ur, dr);
    }
  };
}
function create_if_block_2$9(cr) {
  let ar, lr = (
    /*settings*/
    cr[0].page * /*settings*/
    cr[0].limit + 1 + ""
  ), ur, dr, fr = Math.min(
    /*settings*/
    cr[0].page * /*settings*/
    cr[0].limit + /*settings*/
    cr[0].limit,
    /*settings*/
    cr[0].size
  ) + "", gr, mr, vr, yr, _r, kr = (
    /*settings*/
    cr[0].size + ""
  ), xr, Ar;
  return {
    c() {
      ar = element("button"), ur = text$3(lr), dr = text$3("-"), gr = text$3(fr), mr = text$3(""), vr = element("span"), yr = text$3(
        /*separatorText*/
        cr[11]
      ), _r = space(), xr = text$3(kr), attr(vr, "class", "opacity-50"), attr(ar, "type", "button"), attr(ar, "class", Ar = /*buttonClasses*/
      cr[6] + " pointer-events-none !text-sm");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, ur), append(ar, dr), append(ar, gr), append(ar, mr), append(ar, vr), append(vr, yr), append(vr, _r), append(vr, xr);
    },
    p(Er, Cr) {
      Cr[0] & /*settings*/
      1 && lr !== (lr = /*settings*/
      Er[0].page * /*settings*/
      Er[0].limit + 1 + "") && set_data(ur, lr), Cr[0] & /*settings*/
      1 && fr !== (fr = Math.min(
        /*settings*/
        Er[0].page * /*settings*/
        Er[0].limit + /*settings*/
        Er[0].limit,
        /*settings*/
        Er[0].size
      ) + "") && set_data(gr, fr), Cr[0] & /*separatorText*/
      2048 && set_data(
        yr,
        /*separatorText*/
        Er[11]
      ), Cr[0] & /*settings*/
      1 && kr !== (kr = /*settings*/
      Er[0].size + "") && set_data(xr, kr), Cr[0] & /*buttonClasses*/
      64 && Ar !== (Ar = /*buttonClasses*/
      Er[6] + " pointer-events-none !text-sm") && attr(ar, "class", Ar);
    },
    d(Er) {
      Er && detach(ar);
    }
  };
}
function create_each_block$9(cr) {
  let ar, lr = (
    /*page*/
    (cr[43] >= 0 ? (
      /*page*/
      cr[43] + 1
    ) : "...") + ""
  ), ur, dr, fr, gr, mr;
  function vr() {
    return (
      /*click_handler_2*/
      cr[35](
        /*page*/
        cr[43]
      )
    );
  }
  return {
    c() {
      ar = element("button"), ur = text$3(lr), dr = space(), attr(ar, "type", "button"), attr(ar, "class", fr = /*buttonClasses*/
      cr[6] + " " + /*classesButtonActive*/
      cr[22](
        /*page*/
        cr[43]
      ));
    },
    m(yr, _r) {
      insert(yr, ar, _r), append(ar, ur), append(ar, dr), gr || (mr = listen(ar, "click", vr), gr = !0);
    },
    p(yr, _r) {
      cr = yr, _r[0] & /*controlPages*/
      131072 && lr !== (lr = /*page*/
      (cr[43] >= 0 ? (
        /*page*/
        cr[43] + 1
      ) : "...") + "") && set_data(ur, lr), _r[0] & /*buttonClasses, classesButtonActive, controlPages*/
      4325440 && fr !== (fr = /*buttonClasses*/
      cr[6] + " " + /*classesButtonActive*/
      cr[22](
        /*page*/
        cr[43]
      )) && attr(ar, "class", fr);
    },
    d(yr) {
      yr && detach(ar), gr = !1, mr();
    }
  };
}
function create_if_block_1$b(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelNext*/
        cr[14]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        cr[6]
      ), ar.disabled = lr = /*disabled*/
      cr[1] || /*settings*/
      (cr[0].page + 1) * /*settings*/
      cr[0].limit >= /*settings*/
      cr[0].size;
    },
    m(fr, gr) {
      insert(fr, ar, gr), ar.innerHTML = /*buttonTextNext*/
      cr[8], ur || (dr = listen(
        ar,
        "click",
        /*click_handler_3*/
        cr[36]
      ), ur = !0);
    },
    p(fr, gr) {
      gr[0] & /*buttonTextNext*/
      256 && (ar.innerHTML = /*buttonTextNext*/
      fr[8]), gr[0] & /*labelNext*/
      16384 && attr(
        ar,
        "aria-label",
        /*labelNext*/
        fr[14]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        fr[6]
      ), gr[0] & /*disabled, settings*/
      3 && lr !== (lr = /*disabled*/
      fr[1] || /*settings*/
      (fr[0].page + 1) * /*settings*/
      fr[0].limit >= /*settings*/
      fr[0].size) && (ar.disabled = lr);
    },
    d(fr) {
      fr && detach(ar), ur = !1, dr();
    }
  };
}
function create_if_block$n(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = element("button"), attr(ar, "type", "button"), attr(
        ar,
        "aria-label",
        /*labelLast*/
        cr[15]
      ), attr(
        ar,
        "class",
        /*buttonClasses*/
        cr[6]
      ), ar.disabled = lr = /*disabled*/
      cr[1] || /*settings*/
      (cr[0].page + 1) * /*settings*/
      cr[0].limit >= /*settings*/
      cr[0].size;
    },
    m(fr, gr) {
      insert(fr, ar, gr), ar.innerHTML = /*buttonTextLast*/
      cr[10], ur || (dr = listen(
        ar,
        "click",
        /*click_handler_4*/
        cr[37]
      ), ur = !0);
    },
    p(fr, gr) {
      gr[0] & /*buttonTextLast*/
      1024 && (ar.innerHTML = /*buttonTextLast*/
      fr[10]), gr[0] & /*labelLast*/
      32768 && attr(
        ar,
        "aria-label",
        /*labelLast*/
        fr[15]
      ), gr[0] & /*buttonClasses*/
      64 && attr(
        ar,
        "class",
        /*buttonClasses*/
        fr[6]
      ), gr[0] & /*disabled, settings*/
      3 && lr !== (lr = /*disabled*/
      fr[1] || /*settings*/
      (fr[0].page + 1) * /*settings*/
      fr[0].limit >= /*settings*/
      fr[0].size) && (ar.disabled = lr);
    },
    d(fr) {
      fr && detach(ar), ur = !1, dr();
    }
  };
}
function create_fragment$R(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r = (
    /*settings*/
    cr[0].amounts.length && create_if_block_5$3(cr)
  ), kr = (
    /*showFirstLastButtons*/
    cr[3] && create_if_block_4$5(cr)
  ), xr = (
    /*showPreviousNextButtons*/
    cr[2] && create_if_block_3$7(cr)
  );
  function Ar(Lr, Ir) {
    return (
      /*showNumerals*/
      Lr[4] === !1 ? create_if_block_2$9 : create_else_block$a
    );
  }
  let Er = Ar(cr), Cr = Er(cr), Tr = (
    /*showPreviousNextButtons*/
    cr[2] && create_if_block_1$b(cr)
  ), Sr = (
    /*showFirstLastButtons*/
    cr[3] && create_if_block$n(cr)
  );
  return {
    c() {
      ar = element("div"), _r && _r.c(), lr = space(), ur = element("div"), kr && kr.c(), dr = space(), xr && xr.c(), fr = space(), Cr.c(), gr = space(), Tr && Tr.c(), mr = space(), Sr && Sr.c(), attr(ur, "class", vr = "paginator-controls " + /*classesControls*/
      cr[18]), attr(ar, "class", yr = "paginator " + /*classesBase*/
      cr[21]), attr(ar, "data-testid", "paginator");
    },
    m(Lr, Ir) {
      insert(Lr, ar, Ir), _r && _r.m(ar, null), append(ar, lr), append(ar, ur), kr && kr.m(ur, null), append(ur, dr), xr && xr.m(ur, null), append(ur, fr), Cr.m(ur, null), append(ur, gr), Tr && Tr.m(ur, null), append(ur, mr), Sr && Sr.m(ur, null);
    },
    p(Lr, Ir) {
      /*settings*/
      Lr[0].amounts.length ? _r ? _r.p(Lr, Ir) : (_r = create_if_block_5$3(Lr), _r.c(), _r.m(ar, lr)) : _r && (_r.d(1), _r = null), /*showFirstLastButtons*/
      Lr[3] ? kr ? kr.p(Lr, Ir) : (kr = create_if_block_4$5(Lr), kr.c(), kr.m(ur, dr)) : kr && (kr.d(1), kr = null), /*showPreviousNextButtons*/
      Lr[2] ? xr ? xr.p(Lr, Ir) : (xr = create_if_block_3$7(Lr), xr.c(), xr.m(ur, fr)) : xr && (xr.d(1), xr = null), Er === (Er = Ar(Lr)) && Cr ? Cr.p(Lr, Ir) : (Cr.d(1), Cr = Er(Lr), Cr && (Cr.c(), Cr.m(ur, gr))), /*showPreviousNextButtons*/
      Lr[2] ? Tr ? Tr.p(Lr, Ir) : (Tr = create_if_block_1$b(Lr), Tr.c(), Tr.m(ur, mr)) : Tr && (Tr.d(1), Tr = null), /*showFirstLastButtons*/
      Lr[3] ? Sr ? Sr.p(Lr, Ir) : (Sr = create_if_block$n(Lr), Sr.c(), Sr.m(ur, null)) : Sr && (Sr.d(1), Sr = null), Ir[0] & /*classesControls*/
      262144 && vr !== (vr = "paginator-controls " + /*classesControls*/
      Lr[18]) && attr(ur, "class", vr), Ir[0] & /*classesBase*/
      2097152 && yr !== (yr = "paginator " + /*classesBase*/
      Lr[21]) && attr(ar, "class", yr);
    },
    i: noop$1,
    o: noop$1,
    d(Lr) {
      Lr && detach(ar), _r && _r.d(), kr && kr.d(), xr && xr.d(), Cr.d(), Tr && Tr.d(), Sr && Sr.d();
    }
  };
}
const cBase$e = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4", cLabel$1 = "w-full md:w-auto";
function instance$w(cr, ar, lr) {
  let ur, dr, fr, gr, mr;
  const vr = createEventDispatcher();
  let { settings: yr = {
    page: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = ar, { disabled: _r = !1 } = ar, { showPreviousNextButtons: kr = !0 } = ar, { showFirstLastButtons: xr = !1 } = ar, { showNumerals: Ar = !1 } = ar, { maxNumerals: Er = 1 } = ar, { justify: Cr = "justify-between" } = ar, { select: Tr = "select min-w-[150px]" } = ar, { amountText: Sr = "Items" } = ar, { regionControl: Lr = "btn-group" } = ar, { controlVariant: Ir = "variant-filled" } = ar, { controlSeparator: Nr = "" } = ar, { active: Rr = "variant-filled-primary" } = ar, { buttonClasses: Mr = "!px-3 !py-1.5 fill-current" } = ar, { buttonTextPrevious: Br = leftArrow } = ar, { buttonTextNext: Dr = rightArrow } = ar, { buttonTextFirst: Hr = leftAngles } = ar, { buttonTextLast: Fr = rightAngles } = ar, { separatorText: zr = "of" } = ar, { labelFirst: Ur = "First page" } = ar, { labelPrevious: jr = "Previous page" } = ar, { labelNext: Yr = "Next page" } = ar, { labelLast: qr = "Last page" } = ar, Wr = Math.max(0, Math.ceil(yr.size / yr.limit - 1)), Jr = $r();
  function Gr() {
    vr("amount", yr.limit), lr(16, Wr = Math.max(0, Math.ceil(yr.size / yr.limit - 1))), yr.page > Wr && lr(0, yr.page = Wr, yr), lr(17, Jr = $r());
  }
  function Vr(hi) {
    hi < 0 || (lr(0, yr.page = hi, yr), vr("page", yr.page), lr(17, Jr = $r()));
  }
  function Qr() {
    const hi = [];
    for (let Ti = 0; Ti <= Wr; Ti++)
      hi.push(Ti);
    return hi;
  }
  function $r() {
    const hi = [], Ti = yr.page < Er + 2, fi = yr.page > Wr - (Er + 2);
    if (Wr <= Er * 2 + 1)
      return Qr();
    if (hi.push(0), Ti || hi.push(-1), Ti || fi) {
      const Mi = Ti ? 1 : Wr - (Er + 2), oi = fi ? Wr - 1 : Er + 2;
      for (let Ri = Mi; Ri <= oi; Ri++)
        hi.push(Ri);
    } else
      for (let Mi = yr.page - Er; Mi <= yr.page + Er; Mi++)
        hi.push(Mi);
    return fi || hi.push(-1), hi.push(Wr), hi;
  }
  function Xr(hi) {
    lr(16, Wr = Math.max(0, Math.ceil(hi / yr.limit - 1))), lr(17, Jr = $r());
  }
  function si() {
    yr.limit = select_value(this), lr(0, yr);
  }
  const Zr = () => {
    Vr(0);
  }, li = () => {
    Vr(yr.page - 1);
  }, Ei = (hi) => Vr(hi), ki = () => {
    Vr(yr.page + 1);
  }, Di = () => {
    Vr(Wr);
  };
  return cr.$$set = (hi) => {
    lr(42, ar = assign$1(assign$1({}, ar), exclude_internal_props(hi))), "settings" in hi && lr(0, yr = hi.settings), "disabled" in hi && lr(1, _r = hi.disabled), "showPreviousNextButtons" in hi && lr(2, kr = hi.showPreviousNextButtons), "showFirstLastButtons" in hi && lr(3, xr = hi.showFirstLastButtons), "showNumerals" in hi && lr(4, Ar = hi.showNumerals), "maxNumerals" in hi && lr(25, Er = hi.maxNumerals), "justify" in hi && lr(26, Cr = hi.justify), "select" in hi && lr(27, Tr = hi.select), "amountText" in hi && lr(5, Sr = hi.amountText), "regionControl" in hi && lr(28, Lr = hi.regionControl), "controlVariant" in hi && lr(29, Ir = hi.controlVariant), "controlSeparator" in hi && lr(30, Nr = hi.controlSeparator), "active" in hi && lr(31, Rr = hi.active), "buttonClasses" in hi && lr(6, Mr = hi.buttonClasses), "buttonTextPrevious" in hi && lr(7, Br = hi.buttonTextPrevious), "buttonTextNext" in hi && lr(8, Dr = hi.buttonTextNext), "buttonTextFirst" in hi && lr(9, Hr = hi.buttonTextFirst), "buttonTextLast" in hi && lr(10, Fr = hi.buttonTextLast), "separatorText" in hi && lr(11, zr = hi.separatorText), "labelFirst" in hi && lr(12, Ur = hi.labelFirst), "labelPrevious" in hi && lr(13, jr = hi.labelPrevious), "labelNext" in hi && lr(14, Yr = hi.labelNext), "labelLast" in hi && lr(15, qr = hi.labelLast);
  }, cr.$$.update = () => {
    var hi;
    cr.$$.dirty[0] & /*settings*/
    1 | cr.$$.dirty[1] & /*active*/
    1 && lr(22, ur = (Ti) => Ti === yr.page ? `${Rr} pointer-events-none` : ""), cr.$$.dirty[0] & /*maxNumerals*/
    33554432 && Gr(), cr.$$.dirty[0] & /*settings*/
    1 && Xr(yr.size), lr(21, dr = `${cBase$e} ${Cr} ${(hi = ar.class) != null ? hi : ""}`), cr.$$.dirty[0] & /*select*/
    134217728 && lr(19, gr = `${Tr}`), cr.$$.dirty[0] & /*regionControl, controlVariant, controlSeparator*/
    1879048192 && lr(18, mr = `${Lr} ${Ir} ${Nr}`);
  }, lr(20, fr = `${cLabel$1}`), ar = exclude_internal_props(ar), [
    yr,
    _r,
    kr,
    xr,
    Ar,
    Sr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    mr,
    gr,
    fr,
    dr,
    ur,
    Gr,
    Vr,
    Er,
    Cr,
    Tr,
    Lr,
    Ir,
    Nr,
    Rr,
    si,
    Zr,
    li,
    Ei,
    ki,
    Di
  ];
}
class Paginator extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$w,
      create_fragment$R,
      safe_not_equal,
      {
        settings: 0,
        disabled: 1,
        showPreviousNextButtons: 2,
        showFirstLastButtons: 3,
        showNumerals: 4,
        maxNumerals: 25,
        justify: 26,
        select: 27,
        amountText: 5,
        regionControl: 28,
        controlVariant: 29,
        controlSeparator: 30,
        active: 31,
        buttonClasses: 6,
        buttonTextPrevious: 7,
        buttonTextNext: 8,
        buttonTextFirst: 9,
        buttonTextLast: 10,
        separatorText: 11,
        labelFirst: 12,
        labelPrevious: 13,
        labelNext: 14,
        labelLast: 15
      },
      null,
      [-1, -1]
    );
  }
  get settings() {
    return this.$$.ctx[0];
  }
  set settings(ar) {
    this.$$set({ settings: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get showPreviousNextButtons() {
    return this.$$.ctx[2];
  }
  set showPreviousNextButtons(ar) {
    this.$$set({ showPreviousNextButtons: ar }), flush();
  }
  get showFirstLastButtons() {
    return this.$$.ctx[3];
  }
  set showFirstLastButtons(ar) {
    this.$$set({ showFirstLastButtons: ar }), flush();
  }
  get showNumerals() {
    return this.$$.ctx[4];
  }
  set showNumerals(ar) {
    this.$$set({ showNumerals: ar }), flush();
  }
  get maxNumerals() {
    return this.$$.ctx[25];
  }
  set maxNumerals(ar) {
    this.$$set({ maxNumerals: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[26];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get select() {
    return this.$$.ctx[27];
  }
  set select(ar) {
    this.$$set({ select: ar }), flush();
  }
  get amountText() {
    return this.$$.ctx[5];
  }
  set amountText(ar) {
    this.$$set({ amountText: ar }), flush();
  }
  get regionControl() {
    return this.$$.ctx[28];
  }
  set regionControl(ar) {
    this.$$set({ regionControl: ar }), flush();
  }
  get controlVariant() {
    return this.$$.ctx[29];
  }
  set controlVariant(ar) {
    this.$$set({ controlVariant: ar }), flush();
  }
  get controlSeparator() {
    return this.$$.ctx[30];
  }
  set controlSeparator(ar) {
    this.$$set({ controlSeparator: ar }), flush();
  }
  get active() {
    return this.$$.ctx[31];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get buttonClasses() {
    return this.$$.ctx[6];
  }
  set buttonClasses(ar) {
    this.$$set({ buttonClasses: ar }), flush();
  }
  get buttonTextPrevious() {
    return this.$$.ctx[7];
  }
  set buttonTextPrevious(ar) {
    this.$$set({ buttonTextPrevious: ar }), flush();
  }
  get buttonTextNext() {
    return this.$$.ctx[8];
  }
  set buttonTextNext(ar) {
    this.$$set({ buttonTextNext: ar }), flush();
  }
  get buttonTextFirst() {
    return this.$$.ctx[9];
  }
  set buttonTextFirst(ar) {
    this.$$set({ buttonTextFirst: ar }), flush();
  }
  get buttonTextLast() {
    return this.$$.ctx[10];
  }
  set buttonTextLast(ar) {
    this.$$set({ buttonTextLast: ar }), flush();
  }
  get separatorText() {
    return this.$$.ctx[11];
  }
  set separatorText(ar) {
    this.$$set({ separatorText: ar }), flush();
  }
  get labelFirst() {
    return this.$$.ctx[12];
  }
  set labelFirst(ar) {
    this.$$set({ labelFirst: ar }), flush();
  }
  get labelPrevious() {
    return this.$$.ctx[13];
  }
  set labelPrevious(ar) {
    this.$$set({ labelPrevious: ar }), flush();
  }
  get labelNext() {
    return this.$$.ctx[14];
  }
  set labelNext(ar) {
    this.$$set({ labelNext: ar }), flush();
  }
  get labelLast() {
    return this.$$.ctx[15];
  }
  set labelLast(ar) {
    this.$$set({ labelLast: ar }), flush();
  }
}
create_custom_element(Paginator, { settings: {}, disabled: { type: "Boolean" }, showPreviousNextButtons: { type: "Boolean" }, showFirstLastButtons: { type: "Boolean" }, showNumerals: { type: "Boolean" }, maxNumerals: {}, justify: {}, select: {}, amountText: {}, regionControl: {}, controlVariant: {}, controlSeparator: {}, active: {}, buttonClasses: {}, buttonTextPrevious: {}, buttonTextNext: {}, buttonTextFirst: {}, buttonTextLast: {}, separatorText: {}, labelFirst: {}, labelPrevious: {}, labelNext: {}, labelLast: {} }, [], [], !0);
function add_css$8(cr) {
  append_styles(cr, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}");
}
function create_fragment$Q(cr) {
  let ar, lr, ur, dr = `${/*indeterminate*/
  cr[4] ? 100 : (
    /*fillPercent*/
    cr[7]
  )}%`, fr, gr;
  return {
    c() {
      ar = element("div"), lr = element("div"), attr(lr, "class", ur = "progress-bar-meter " + /*classesMeter*/
      cr[5] + " " + /*classesMeter*/
      cr[5] + " svelte-meqa4r"), set_style(lr, "width", dr), attr(ar, "class", fr = "progress-bar " + /*classesTrack*/
      cr[6] + " svelte-meqa4r"), attr(ar, "data-testid", "progress-bar"), attr(ar, "role", "progressbar"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        cr[3]
      ), attr(
        ar,
        "aria-valuenow",
        /*value*/
        cr[0]
      ), attr(
        ar,
        "aria-valuemin",
        /*min*/
        cr[1]
      ), attr(ar, "aria-valuemax", gr = /*max*/
      cr[2] - /*min*/
      cr[1]);
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, lr);
    },
    p(mr, [vr]) {
      vr & /*classesMeter*/
      32 && ur !== (ur = "progress-bar-meter " + /*classesMeter*/
      mr[5] + " " + /*classesMeter*/
      mr[5] + " svelte-meqa4r") && attr(lr, "class", ur), vr & /*indeterminate, fillPercent*/
      144 && dr !== (dr = `${/*indeterminate*/
      mr[4] ? 100 : (
        /*fillPercent*/
        mr[7]
      )}%`) && set_style(lr, "width", dr), vr & /*classesTrack*/
      64 && fr !== (fr = "progress-bar " + /*classesTrack*/
      mr[6] + " svelte-meqa4r") && attr(ar, "class", fr), vr & /*labelledby*/
      8 && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        mr[3]
      ), vr & /*value*/
      1 && attr(
        ar,
        "aria-valuenow",
        /*value*/
        mr[0]
      ), vr & /*min*/
      2 && attr(
        ar,
        "aria-valuemin",
        /*min*/
        mr[1]
      ), vr & /*max, min*/
      6 && gr !== (gr = /*max*/
      mr[2] - /*min*/
      mr[1]) && attr(ar, "aria-valuemax", gr);
    },
    i: noop$1,
    o: noop$1,
    d(mr) {
      mr && detach(ar);
    }
  };
}
const cTrack$2 = "w-full overflow-hidden", cMeter = "h-full";
function instance$v(cr, ar, lr) {
  let ur, dr, fr, gr, mr, { value: vr = void 0 } = ar, { min: yr = 0 } = ar, { max: _r = 100 } = ar, { height: kr = "h-2" } = ar, { rounded: xr = "rounded-token" } = ar, { transition: Ar = "transition-[width]" } = ar, { meter: Er = "bg-surface-900-50-token" } = ar, { track: Cr = "bg-surface-200-700-token" } = ar, { labelledby: Tr = "" } = ar;
  return cr.$$set = (Sr) => {
    lr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Sr))), "value" in Sr && lr(0, vr = Sr.value), "min" in Sr && lr(1, yr = Sr.min), "max" in Sr && lr(2, _r = Sr.max), "height" in Sr && lr(8, kr = Sr.height), "rounded" in Sr && lr(9, xr = Sr.rounded), "transition" in Sr && lr(10, Ar = Sr.transition), "meter" in Sr && lr(11, Er = Sr.meter), "track" in Sr && lr(12, Cr = Sr.track), "labelledby" in Sr && lr(3, Tr = Sr.labelledby);
  }, cr.$$.update = () => {
    var Sr;
    cr.$$.dirty & /*value, min, max*/
    7 && lr(7, ur = vr ? 100 * (vr - yr) / (_r - yr) : 0), cr.$$.dirty & /*value*/
    1 && lr(4, dr = vr === void 0 || vr < 0), cr.$$.dirty & /*indeterminate*/
    16 && lr(13, fr = dr ? "animIndeterminate" : ""), lr(6, gr = `${cTrack$2} ${Cr} ${kr} ${xr} ${(Sr = ar.class) != null ? Sr : ""}`), cr.$$.dirty & /*meter, rounded, classesIndeterminate, transition*/
    11776 && lr(5, mr = `${cMeter} ${Er} ${xr} ${fr} ${Ar}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    yr,
    _r,
    Tr,
    dr,
    mr,
    gr,
    ur,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    fr
  ];
}
class ProgressBar extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$v,
      create_fragment$Q,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        height: 8,
        rounded: 9,
        transition: 10,
        meter: 11,
        track: 12,
        labelledby: 3
      },
      add_css$8
    );
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[1];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[2];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get height() {
    return this.$$.ctx[8];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[9];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[10];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[11];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[12];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[3];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressBar, { value: {}, min: {}, max: {}, height: {}, rounded: {}, transition: {}, meter: {}, track: {}, labelledby: {} }, [], [], !0);
function create_if_block$m(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[16].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[15],
    null
  );
  return {
    c() {
      ar = svg_element("text"), fr && fr.c(), attr(ar, "x", "50%"), attr(ar, "y", "50%"), attr(ar, "text-anchor", "middle"), attr(ar, "dominant-baseline", "middle"), attr(ar, "font-weight", "bold"), attr(
        ar,
        "font-size",
        /*font*/
        cr[2]
      ), attr(ar, "class", lr = "progress-radial-text " + /*fill*/
      cr[7]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      32768) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[15],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[15],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[15]
        ),
        null
      ), (!ur || mr & /*font*/
      4) && attr(
        ar,
        "font-size",
        /*font*/
        gr[2]
      ), (!ur || mr & /*fill*/
      128 && lr !== (lr = "progress-radial-text " + /*fill*/
      gr[7])) && attr(ar, "class", lr);
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$P(cr) {
  let ar, lr, ur, dr, fr, gr, mr = `${/*circumference*/
  cr[9]}
			${/*circumference*/
  cr[9]}`, vr, yr, _r, kr, xr = (
    /*value*/
    cr[0] != null && /*value*/
    cr[0] >= 0 && /*$$slots*/
    cr[13].default && create_if_block$m(cr)
  );
  return {
    c() {
      ar = element("figure"), lr = svg_element("svg"), ur = svg_element("circle"), fr = svg_element("circle"), xr && xr.c(), attr(ur, "class", dr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      cr[6]), attr(
        ur,
        "stroke-width",
        /*stroke*/
        cr[1]
      ), attr(
        ur,
        "r",
        /*radius*/
        cr[12]
      ), attr(ur, "cx", "50%"), attr(ur, "cy", "50%"), attr(fr, "class", gr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      cr[5] + " " + /*transition*/
      cr[4]), attr(
        fr,
        "stroke-width",
        /*stroke*/
        cr[1]
      ), attr(
        fr,
        "r",
        /*radius*/
        cr[12]
      ), attr(fr, "cx", "50%"), attr(fr, "cy", "50%"), attr(
        fr,
        "stroke-linecap",
        /*strokeLinecap*/
        cr[3]
      ), set_style(fr, "stroke-dasharray", mr), set_style(
        fr,
        "stroke-dashoffset",
        /*dashoffset*/
        cr[10]
      ), attr(lr, "viewBox", "0 0 " + baseSize + " " + baseSize), attr(lr, "class", "rounded-full"), toggle_class(
        lr,
        "animate-spin",
        /*value*/
        cr[0] === void 0
      ), attr(ar, "class", vr = "progress-radial " + /*classesBase*/
      cr[11]), attr(ar, "data-testid", "progress-radial"), attr(ar, "role", "meter"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        cr[8]
      ), attr(ar, "aria-valuenow", yr = /*value*/
      cr[0] || 0), attr(ar, "aria-valuetext", _r = /*value*/
      cr[0] ? `${/*value*/
      cr[0]}%` : "Indeterminate Spinner"), attr(ar, "aria-valuemin", 0), attr(ar, "aria-valuemax", 100);
    },
    m(Ar, Er) {
      insert(Ar, ar, Er), append(ar, lr), append(lr, ur), append(lr, fr), xr && xr.m(lr, null), kr = !0;
    },
    p(Ar, [Er]) {
      (!kr || Er & /*track*/
      64 && dr !== (dr = "progress-radial-track " + cBaseTrack + " " + /*track*/
      Ar[6])) && attr(ur, "class", dr), (!kr || Er & /*stroke*/
      2) && attr(
        ur,
        "stroke-width",
        /*stroke*/
        Ar[1]
      ), (!kr || Er & /*meter, transition*/
      48 && gr !== (gr = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      Ar[5] + " " + /*transition*/
      Ar[4])) && attr(fr, "class", gr), (!kr || Er & /*stroke*/
      2) && attr(
        fr,
        "stroke-width",
        /*stroke*/
        Ar[1]
      ), (!kr || Er & /*strokeLinecap*/
      8) && attr(
        fr,
        "stroke-linecap",
        /*strokeLinecap*/
        Ar[3]
      ), Er & /*circumference*/
      512 && mr !== (mr = `${/*circumference*/
      Ar[9]}
			${/*circumference*/
      Ar[9]}`) && set_style(fr, "stroke-dasharray", mr), Er & /*dashoffset*/
      1024 && set_style(
        fr,
        "stroke-dashoffset",
        /*dashoffset*/
        Ar[10]
      ), /*value*/
      Ar[0] != null && /*value*/
      Ar[0] >= 0 && /*$$slots*/
      Ar[13].default ? xr ? (xr.p(Ar, Er), Er & /*value, $$slots*/
      8193 && transition_in(xr, 1)) : (xr = create_if_block$m(Ar), xr.c(), transition_in(xr, 1), xr.m(lr, null)) : xr && (group_outros(), transition_out(xr, 1, 1, () => {
        xr = null;
      }), check_outros()), (!kr || Er & /*value, undefined*/
      1) && toggle_class(
        lr,
        "animate-spin",
        /*value*/
        Ar[0] === void 0
      ), (!kr || Er & /*classesBase*/
      2048 && vr !== (vr = "progress-radial " + /*classesBase*/
      Ar[11])) && attr(ar, "class", vr), (!kr || Er & /*labelledby*/
      256) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        Ar[8]
      ), (!kr || Er & /*value*/
      1 && yr !== (yr = /*value*/
      Ar[0] || 0)) && attr(ar, "aria-valuenow", yr), (!kr || Er & /*value*/
      1 && _r !== (_r = /*value*/
      Ar[0] ? `${/*value*/
      Ar[0]}%` : "Indeterminate Spinner")) && attr(ar, "aria-valuetext", _r);
    },
    i(Ar) {
      kr || (transition_in(xr), kr = !0);
    },
    o(Ar) {
      transition_out(xr), kr = !1;
    },
    d(Ar) {
      Ar && detach(ar), xr && xr.d();
    }
  };
}
const cBase$d = "progress-radial relative overflow-hidden", cBaseTrack = "fill-transparent", cBaseMeter = "fill-transparent -rotate-90 origin-[50%_50%]", baseSize = 512;
function instance$u(cr, ar, lr) {
  let ur, { $$slots: dr = {}, $$scope: fr } = ar;
  const gr = compute_slots(dr);
  let { value: mr = void 0 } = ar, { stroke: vr = 40 } = ar, { font: yr = 56 } = ar, { strokeLinecap: _r = "butt" } = ar, { transition: kr = "transition-[stroke-dashoffset]" } = ar, { width: xr = "w-36" } = ar, { meter: Ar = "stroke-surface-900 dark:stroke-surface-50" } = ar, { track: Er = "stroke-surface-500/30" } = ar, { fill: Cr = "fill-token" } = ar, { labelledby: Tr = "" } = ar;
  const Sr = baseSize / 2 - vr / 2;
  let Lr = Sr, Ir;
  function Nr(Rr) {
    lr(9, Lr = Sr * 2 * Math.PI), lr(10, Ir = Lr - Rr / 100 * Lr);
  }
  return Nr(0), afterUpdate(() => {
    Nr(mr === void 0 ? 25 : mr);
  }), cr.$$set = (Rr) => {
    lr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Rr))), "value" in Rr && lr(0, mr = Rr.value), "stroke" in Rr && lr(1, vr = Rr.stroke), "font" in Rr && lr(2, yr = Rr.font), "strokeLinecap" in Rr && lr(3, _r = Rr.strokeLinecap), "transition" in Rr && lr(4, kr = Rr.transition), "width" in Rr && lr(14, xr = Rr.width), "meter" in Rr && lr(5, Ar = Rr.meter), "track" in Rr && lr(6, Er = Rr.track), "fill" in Rr && lr(7, Cr = Rr.fill), "labelledby" in Rr && lr(8, Tr = Rr.labelledby), "$$scope" in Rr && lr(15, fr = Rr.$$scope);
  }, cr.$$.update = () => {
    var Rr;
    lr(11, ur = `${cBase$d} ${xr} ${(Rr = ar.class) != null ? Rr : ""}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    vr,
    yr,
    _r,
    kr,
    Ar,
    Er,
    Cr,
    Tr,
    Lr,
    Ir,
    ur,
    Sr,
    gr,
    xr,
    fr,
    dr
  ];
}
class ProgressRadial extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$u, create_fragment$P, safe_not_equal, {
      value: 0,
      stroke: 1,
      font: 2,
      strokeLinecap: 3,
      transition: 4,
      width: 14,
      meter: 5,
      track: 6,
      fill: 7,
      labelledby: 8
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get stroke() {
    return this.$$.ctx[1];
  }
  set stroke(ar) {
    this.$$set({ stroke: ar }), flush();
  }
  get font() {
    return this.$$.ctx[2];
  }
  set font(ar) {
    this.$$set({ font: ar }), flush();
  }
  get strokeLinecap() {
    return this.$$.ctx[3];
  }
  set strokeLinecap(ar) {
    this.$$set({ strokeLinecap: ar }), flush();
  }
  get transition() {
    return this.$$.ctx[4];
  }
  set transition(ar) {
    this.$$set({ transition: ar }), flush();
  }
  get width() {
    return this.$$.ctx[14];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get meter() {
    return this.$$.ctx[5];
  }
  set meter(ar) {
    this.$$set({ meter: ar }), flush();
  }
  get track() {
    return this.$$.ctx[6];
  }
  set track(ar) {
    this.$$set({ track: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[8];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(ProgressRadial, { value: {}, stroke: {}, font: {}, strokeLinecap: {}, transition: {}, width: {}, meter: {}, track: {}, fill: {}, labelledby: {} }, ["default"], [], !0);
function get_each_context$8(cr, ar, lr) {
  const ur = cr.slice();
  return ur[15] = ar[lr], ur[17] = lr, ur;
}
const get_empty_slot_changes_1 = (cr) => ({}), get_empty_slot_context_1 = (cr) => ({}), get_half_slot_changes_1 = (cr) => ({}), get_half_slot_context_1 = (cr) => ({}), get_full_slot_changes_1 = (cr) => ({}), get_full_slot_context_1 = (cr) => ({}), get_empty_slot_changes = (cr) => ({}), get_empty_slot_context = (cr) => ({}), get_half_slot_changes = (cr) => ({}), get_half_slot_context = (cr) => ({}), get_full_slot_changes = (cr) => ({}), get_full_slot_context = (cr) => ({});
function create_else_block_1$6(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  const yr = [create_if_block_3$6, create_if_block_4$4, create_else_block_2$1], _r = [];
  function kr(xr, Ar) {
    return Ar & /*value*/
    1 && (lr = null), Ar & /*value*/
    1 && (ur = null), lr == null && (lr = !!isFull(
      /*value*/
      xr[0],
      /*i*/
      xr[17]
    )), lr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      xr[0],
      /*i*/
      xr[17]
    )), ur ? 1 : 2);
  }
  return dr = kr(cr, -1), fr = _r[dr] = yr[dr](cr), {
    c() {
      ar = element("span"), fr.c(), gr = space(), attr(ar, "class", mr = "rating-icon " + /*regionIcon*/
      cr[3]);
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), _r[dr].m(ar, null), append(ar, gr), vr = !0;
    },
    p(xr, Ar) {
      let Er = dr;
      dr = kr(xr, Ar), dr === Er ? _r[dr].p(xr, Ar) : (group_outros(), transition_out(_r[Er], 1, 1, () => {
        _r[Er] = null;
      }), check_outros(), fr = _r[dr], fr ? fr.p(xr, Ar) : (fr = _r[dr] = yr[dr](xr), fr.c()), transition_in(fr, 1), fr.m(ar, gr)), (!vr || Ar & /*regionIcon*/
      8 && mr !== (mr = "rating-icon " + /*regionIcon*/
      xr[3])) && attr(ar, "class", mr);
    },
    i(xr) {
      vr || (transition_in(fr), vr = !0);
    },
    o(xr) {
      transition_out(fr), vr = !1;
    },
    d(xr) {
      xr && detach(ar), _r[dr].d();
    }
  };
}
function create_if_block$l(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r;
  const kr = [create_if_block_1$a, create_if_block_2$8, create_else_block$9], xr = [];
  function Ar(Cr, Tr) {
    return Tr & /*value*/
    1 && (lr = null), Tr & /*value*/
    1 && (ur = null), lr == null && (lr = !!isFull(
      /*value*/
      Cr[0],
      /*i*/
      Cr[17]
    )), lr ? 0 : (ur == null && (ur = !!isHalf(
      /*value*/
      Cr[0],
      /*i*/
      Cr[17]
    )), ur ? 1 : 2);
  }
  dr = Ar(cr, -1), fr = xr[dr] = kr[dr](cr);
  function Er() {
    return (
      /*click_handler*/
      cr[12](
        /*i*/
        cr[17]
      )
    );
  }
  return {
    c() {
      ar = element("button"), fr.c(), gr = space(), attr(ar, "class", mr = "rating-icon " + /*regionIcon*/
      cr[3]), attr(ar, "type", "button");
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), xr[dr].m(ar, null), append(ar, gr), vr = !0, yr || (_r = listen(ar, "click", Er), yr = !0);
    },
    p(Cr, Tr) {
      cr = Cr;
      let Sr = dr;
      dr = Ar(cr, Tr), dr === Sr ? xr[dr].p(cr, Tr) : (group_outros(), transition_out(xr[Sr], 1, 1, () => {
        xr[Sr] = null;
      }), check_outros(), fr = xr[dr], fr ? fr.p(cr, Tr) : (fr = xr[dr] = kr[dr](cr), fr.c()), transition_in(fr, 1), fr.m(ar, gr)), (!vr || Tr & /*regionIcon*/
      8 && mr !== (mr = "rating-icon " + /*regionIcon*/
      cr[3])) && attr(ar, "class", mr);
    },
    i(Cr) {
      vr || (transition_in(fr), vr = !0);
    },
    o(Cr) {
      transition_out(fr), vr = !1;
    },
    d(Cr) {
      Cr && detach(ar), xr[dr].d(), yr = !1, _r();
    }
  };
}
function create_else_block_2$1(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].empty
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_empty_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_empty_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_empty_slot_context_1
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_if_block_4$4(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].half
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_half_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_half_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_half_slot_context_1
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_if_block_3$6(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].full
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_full_slot_context_1
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_full_slot_changes_1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_full_slot_context_1
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_else_block$9(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].empty
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_empty_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_empty_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_empty_slot_context
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_if_block_2$8(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].half
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_half_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_half_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_half_slot_context
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_if_block_1$a(cr) {
  let ar;
  const lr = (
    /*#slots*/
    cr[11].full
  ), ur = create_slot(
    lr,
    cr,
    /*$$scope*/
    cr[10],
    get_full_slot_context
  );
  return {
    c() {
      ur && ur.c();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), ar = !0;
    },
    p(dr, fr) {
      ur && ur.p && (!ar || fr & /*$$scope*/
      1024) && update_slot_base(
        ur,
        lr,
        dr,
        /*$$scope*/
        dr[10],
        ar ? get_slot_changes(
          lr,
          /*$$scope*/
          dr[10],
          fr,
          get_full_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          dr[10]
        ),
        get_full_slot_context
      );
    },
    i(dr) {
      ar || (transition_in(ur, dr), ar = !0);
    },
    o(dr) {
      transition_out(ur, dr), ar = !1;
    },
    d(dr) {
      ur && ur.d(dr);
    }
  };
}
function create_each_block$8(cr) {
  let ar, lr, ur, dr;
  const fr = [create_if_block$l, create_else_block_1$6], gr = [];
  function mr(vr, yr) {
    return (
      /*interactive*/
      vr[2] ? 0 : 1
    );
  }
  return ar = mr(cr), lr = gr[ar] = fr[ar](cr), {
    c() {
      lr.c(), ur = empty$2();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), dr = !0;
    },
    p(vr, yr) {
      let _r = ar;
      ar = mr(vr), ar === _r ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[_r], 1, 1, () => {
        gr[_r] = null;
      }), check_outros(), lr = gr[ar], lr ? lr.p(vr, yr) : (lr = gr[ar] = fr[ar](vr), lr.c()), transition_in(lr, 1), lr.m(ur.parentNode, ur));
    },
    i(vr) {
      dr || (transition_in(lr), dr = !0);
    },
    o(vr) {
      transition_out(lr), dr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_fragment$O(cr) {
  let ar, lr, ur, dr = ensure_array_like({ length: (
    /*max*/
    cr[1]
  ) }), fr = [];
  for (let mr = 0; mr < dr.length; mr += 1)
    fr[mr] = create_each_block$8(get_each_context$8(cr, dr, mr));
  const gr = (mr) => transition_out(fr[mr], 1, 1, () => {
    fr[mr] = null;
  });
  return {
    c() {
      ar = element("div");
      for (let mr = 0; mr < fr.length; mr += 1)
        fr[mr].c();
      attr(ar, "class", lr = "ratings " + /*classesBase*/
      cr[4]), attr(ar, "data-testid", "rating-bar");
    },
    m(mr, vr) {
      insert(mr, ar, vr);
      for (let yr = 0; yr < fr.length; yr += 1)
        fr[yr] && fr[yr].m(ar, null);
      ur = !0;
    },
    p(mr, [vr]) {
      if (vr & /*regionIcon, iconClick, $$scope, isFull, value, isHalf, interactive, max*/
      1071) {
        dr = ensure_array_like({ length: (
          /*max*/
          mr[1]
        ) });
        let yr;
        for (yr = 0; yr < dr.length; yr += 1) {
          const _r = get_each_context$8(mr, dr, yr);
          fr[yr] ? (fr[yr].p(_r, vr), transition_in(fr[yr], 1)) : (fr[yr] = create_each_block$8(_r), fr[yr].c(), transition_in(fr[yr], 1), fr[yr].m(ar, null));
        }
        for (group_outros(), yr = dr.length; yr < fr.length; yr += 1)
          gr(yr);
        check_outros();
      }
      (!ur || vr & /*classesBase*/
      16 && lr !== (lr = "ratings " + /*classesBase*/
      mr[4])) && attr(ar, "class", lr);
    },
    i(mr) {
      if (!ur) {
        for (let vr = 0; vr < dr.length; vr += 1)
          transition_in(fr[vr]);
        ur = !0;
      }
    },
    o(mr) {
      fr = fr.filter(Boolean);
      for (let vr = 0; vr < fr.length; vr += 1)
        transition_out(fr[vr]);
      ur = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_each(fr, mr);
    }
  };
}
const cBase$c = "w-full flex";
function isFull(cr, ar) {
  return Math.floor(cr) >= ar + 1;
}
function isHalf(cr, ar) {
  return cr === ar + 0.5;
}
function instance$t(cr, ar, lr) {
  let ur, { $$slots: dr = {}, $$scope: fr } = ar, { value: gr = 0 } = ar, { max: mr = 5 } = ar, { interactive: vr = !1 } = ar, { text: yr = "text-token" } = ar, { fill: _r = "fill-token" } = ar, { justify: kr = "justify-center" } = ar, { spacing: xr = "space-x-2" } = ar, { regionIcon: Ar = "" } = ar;
  const Er = createEventDispatcher();
  function Cr(Sr) {
    Er("icon", { index: Sr + 1 });
  }
  const Tr = (Sr) => Cr(Sr);
  return cr.$$set = (Sr) => {
    lr(14, ar = assign$1(assign$1({}, ar), exclude_internal_props(Sr))), "value" in Sr && lr(0, gr = Sr.value), "max" in Sr && lr(1, mr = Sr.max), "interactive" in Sr && lr(2, vr = Sr.interactive), "text" in Sr && lr(6, yr = Sr.text), "fill" in Sr && lr(7, _r = Sr.fill), "justify" in Sr && lr(8, kr = Sr.justify), "spacing" in Sr && lr(9, xr = Sr.spacing), "regionIcon" in Sr && lr(3, Ar = Sr.regionIcon), "$$scope" in Sr && lr(10, fr = Sr.$$scope);
  }, cr.$$.update = () => {
    var Sr;
    lr(4, ur = `${cBase$c} ${yr} ${_r} ${kr} ${xr} ${(Sr = ar.class) != null ? Sr : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    vr,
    Ar,
    ur,
    Cr,
    yr,
    _r,
    kr,
    xr,
    fr,
    dr,
    Tr
  ];
}
class Ratings extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$t, create_fragment$O, safe_not_equal, {
      value: 0,
      max: 1,
      interactive: 2,
      text: 6,
      fill: 7,
      justify: 8,
      spacing: 9,
      regionIcon: 3
    });
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get max() {
    return this.$$.ctx[1];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[2];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get text() {
    return this.$$.ctx[6];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[7];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[8];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[9];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionIcon() {
    return this.$$.ctx[3];
  }
  set regionIcon(ar) {
    this.$$set({ regionIcon: ar }), flush();
  }
}
create_custom_element(Ratings, { value: {}, max: {}, interactive: { type: "Boolean" }, text: {}, fill: {}, justify: {}, spacing: {}, regionIcon: {} }, ["full", "half", "empty"], [], !0);
function create_fragment$N(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[14].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[13],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "radio-group " + /*classesBase*/
      cr[1]), attr(ar, "data-testid", "radio-group"), attr(ar, "role", "radiogroup"), attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        cr[0]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, [mr]) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      8192) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[13],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[13],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[13]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      2 && lr !== (lr = "radio-group " + /*classesBase*/
      gr[1])) && attr(ar, "class", lr), (!ur || mr & /*labelledby*/
      1) && attr(
        ar,
        "aria-labelledby",
        /*labelledby*/
        gr[0]
      );
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
const cBase$b = "p-1";
function instance$s(cr, ar, lr) {
  let ur, { $$slots: dr = {}, $$scope: fr } = ar, { display: gr = "inline-flex" } = ar, { background: mr = "bg-surface-200-700-token" } = ar, { border: vr = "border-token border-surface-400-500-token" } = ar, { spacing: yr = "" } = ar, { rounded: _r = "rounded-token" } = ar, { padding: kr = "px-4 py-1" } = ar, { active: xr = "variant-filled" } = ar, { hover: Ar = "hover:variant-soft" } = ar, { color: Er = "" } = ar, { fill: Cr = "" } = ar, { regionLabel: Tr = "" } = ar, { labelledby: Sr = "" } = ar;
  return setContext("rounded", _r), setContext("padding", kr), setContext("active", xr), setContext("hover", Ar), setContext("color", Er), setContext("fill", Cr), setContext("regionLabel", Tr), cr.$$set = (Lr) => {
    lr(15, ar = assign$1(assign$1({}, ar), exclude_internal_props(Lr))), "display" in Lr && lr(3, gr = Lr.display), "background" in Lr && lr(4, mr = Lr.background), "border" in Lr && lr(5, vr = Lr.border), "spacing" in Lr && lr(2, yr = Lr.spacing), "rounded" in Lr && lr(6, _r = Lr.rounded), "padding" in Lr && lr(7, kr = Lr.padding), "active" in Lr && lr(8, xr = Lr.active), "hover" in Lr && lr(9, Ar = Lr.hover), "color" in Lr && lr(10, Er = Lr.color), "fill" in Lr && lr(11, Cr = Lr.fill), "regionLabel" in Lr && lr(12, Tr = Lr.regionLabel), "labelledby" in Lr && lr(0, Sr = Lr.labelledby), "$$scope" in Lr && lr(13, fr = Lr.$$scope);
  }, cr.$$.update = () => {
    var Lr;
    cr.$$.dirty & /*display*/
    8 && lr(2, yr = `${gr.includes("flex-col") ? "" : "space-x-1"}`), lr(1, ur = `${cBase$b} ${gr} ${mr} ${vr} ${yr} ${_r} ${(Lr = ar.class) != null ? Lr : ""}`);
  }, ar = exclude_internal_props(ar), [
    Sr,
    ur,
    yr,
    gr,
    mr,
    vr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    fr,
    dr
  ];
}
class RadioGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$s, create_fragment$N, safe_not_equal, {
      display: 3,
      background: 4,
      border: 5,
      spacing: 2,
      rounded: 6,
      padding: 7,
      active: 8,
      hover: 9,
      color: 10,
      fill: 11,
      regionLabel: 12,
      labelledby: 0
    });
  }
  get display() {
    return this.$$.ctx[3];
  }
  set display(ar) {
    this.$$set({ display: ar }), flush();
  }
  get background() {
    return this.$$.ctx[4];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get border() {
    return this.$$.ctx[5];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[2];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[6];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[7];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[10];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[11];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[12];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RadioGroup, { display: {}, background: {}, border: {}, spacing: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {}, labelledby: {} }, ["default"], [], !0);
function create_fragment$M(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr = [
    { type: "radio" },
    { name: (
      /*name*/
      cr[1]
    ) },
    { __value: (
      /*value*/
      cr[2]
    ) },
    /*prunedRestProps*/
    cr[11](),
    { tabindex: "-1" }
  ], Ar = {};
  for (let Tr = 0; Tr < xr.length; Tr += 1)
    Ar = assign$1(Ar, xr[Tr]);
  const Er = (
    /*#slots*/
    cr[21].default
  ), Cr = create_slot(
    Er,
    cr,
    /*$$scope*/
    cr[20],
    null
  );
  return yr = init_binding_group(
    /*$$binding_groups*/
    cr[29][0]
  ), {
    c() {
      ar = element("label"), lr = element("div"), ur = element("div"), dr = element("input"), fr = space(), Cr && Cr.c(), set_attributes(dr, Ar), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(lr, "class", gr = "radio-item " + /*classesWrapper*/
      cr[8]), attr(lr, "data-testid", "radio-item"), attr(lr, "role", "radio"), attr(
        lr,
        "aria-checked",
        /*checked*/
        cr[6]
      ), attr(
        lr,
        "aria-label",
        /*label*/
        cr[4]
      ), attr(lr, "tabindex", "0"), attr(
        lr,
        "title",
        /*title*/
        cr[3]
      ), attr(ar, "class", mr = "radio-label " + /*classsBase*/
      cr[9] + " " + /*regionLabel*/
      cr[5]), yr.p(dr);
    },
    m(Tr, Sr) {
      insert(Tr, ar, Sr), append(ar, lr), append(lr, ur), append(ur, dr), dr.autofocus && dr.focus(), cr[27](dr), dr.checked = dr.__value === /*group*/
      cr[0], append(lr, fr), Cr && Cr.m(lr, null), vr = !0, _r || (kr = [
        listen(
          dr,
          "change",
          /*input_change_handler*/
          cr[28]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          cr[25]
        ),
        listen(
          dr,
          "change",
          /*change_handler*/
          cr[26]
        ),
        listen(
          lr,
          "keydown",
          /*onKeyDown*/
          cr[10]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[22]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[23]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[24]
        )
      ], _r = !0);
    },
    p(Tr, Sr) {
      set_attributes(dr, Ar = get_spread_update(xr, [
        { type: "radio" },
        (!vr || Sr[0] & /*name*/
        2) && { name: (
          /*name*/
          Tr[1]
        ) },
        (!vr || Sr[0] & /*value*/
        4) && { __value: (
          /*value*/
          Tr[2]
        ) },
        /*prunedRestProps*/
        Tr[11](),
        { tabindex: "-1" }
      ])), Sr[0] & /*group*/
      1 && (dr.checked = dr.__value === /*group*/
      Tr[0]), Cr && Cr.p && (!vr || Sr[0] & /*$$scope*/
      1048576) && update_slot_base(
        Cr,
        Er,
        Tr,
        /*$$scope*/
        Tr[20],
        vr ? get_slot_changes(
          Er,
          /*$$scope*/
          Tr[20],
          Sr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[20]
        ),
        null
      ), (!vr || Sr[0] & /*classesWrapper*/
      256 && gr !== (gr = "radio-item " + /*classesWrapper*/
      Tr[8])) && attr(lr, "class", gr), (!vr || Sr[0] & /*checked*/
      64) && attr(
        lr,
        "aria-checked",
        /*checked*/
        Tr[6]
      ), (!vr || Sr[0] & /*label*/
      16) && attr(
        lr,
        "aria-label",
        /*label*/
        Tr[4]
      ), (!vr || Sr[0] & /*title*/
      8) && attr(
        lr,
        "title",
        /*title*/
        Tr[3]
      ), (!vr || Sr[0] & /*classsBase, regionLabel*/
      544 && mr !== (mr = "radio-label " + /*classsBase*/
      Tr[9] + " " + /*regionLabel*/
      Tr[5])) && attr(ar, "class", mr);
    },
    i(Tr) {
      vr || (transition_in(Cr, Tr), vr = !0);
    },
    o(Tr) {
      transition_out(Cr, Tr), vr = !1;
    },
    d(Tr) {
      Tr && detach(ar), cr[27](null), Cr && Cr.d(Tr), yr.r(), _r = !1, run_all(kr);
    }
  };
}
const cBase$a = "flex-auto", cWrapper$1 = "text-base text-center cursor-pointer", cDisabled$1 = "opacity-50 cursor-not-allowed";
function instance$r(cr, ar, lr) {
  let ur, dr, fr, gr, mr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "label",
    "rounded",
    "padding",
    "active",
    "hover",
    "color",
    "fill",
    "regionLabel"
  ];
  let yr = compute_rest_props(ar, vr), { $$slots: _r = {}, $$scope: kr } = ar, { group: xr } = ar, { name: Ar } = ar, { value: Er } = ar, { title: Cr = "" } = ar, { label: Tr = "" } = ar, { rounded: Sr = getContext("rounded") } = ar, { padding: Lr = getContext("padding") } = ar, { active: Ir = getContext("active") } = ar, { hover: Nr = getContext("hover") } = ar, { color: Rr = getContext("color") } = ar, { fill: Mr = getContext("fill") } = ar, { regionLabel: Br = getContext("regionLabel") } = ar, Dr;
  function Hr(Vr) {
    ["Enter", "Space"].includes(Vr.code) && (Vr.preventDefault(), Dr.click());
  }
  function Fr() {
    return delete yr.class, yr;
  }
  const zr = [[]];
  function Ur(Vr) {
    bubble.call(this, cr, Vr);
  }
  function jr(Vr) {
    bubble.call(this, cr, Vr);
  }
  function Yr(Vr) {
    bubble.call(this, cr, Vr);
  }
  function qr(Vr) {
    bubble.call(this, cr, Vr);
  }
  function Wr(Vr) {
    bubble.call(this, cr, Vr);
  }
  function Jr(Vr) {
    binding_callbacks[Vr ? "unshift" : "push"](() => {
      Dr = Vr, lr(7, Dr);
    });
  }
  function Gr() {
    xr = this.__value, lr(0, xr);
  }
  return cr.$$set = (Vr) => {
    lr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(Vr))), lr(30, yr = compute_rest_props(ar, vr)), "group" in Vr && lr(0, xr = Vr.group), "name" in Vr && lr(1, Ar = Vr.name), "value" in Vr && lr(2, Er = Vr.value), "title" in Vr && lr(3, Cr = Vr.title), "label" in Vr && lr(4, Tr = Vr.label), "rounded" in Vr && lr(12, Sr = Vr.rounded), "padding" in Vr && lr(13, Lr = Vr.padding), "active" in Vr && lr(14, Ir = Vr.active), "hover" in Vr && lr(15, Nr = Vr.hover), "color" in Vr && lr(16, Rr = Vr.color), "fill" in Vr && lr(17, Mr = Vr.fill), "regionLabel" in Vr && lr(5, Br = Vr.regionLabel), "$$scope" in Vr && lr(20, kr = Vr.$$scope);
  }, cr.$$.update = () => {
    var Vr;
    cr.$$.dirty[0] & /*value, group*/
    5 && lr(6, ur = Er === xr), cr.$$.dirty[0] & /*checked, active, color, fill, hover*/
    245824 && lr(19, dr = ur ? `${Ir} ${Rr} ${Mr}` : Nr), lr(18, fr = ar.disabled ? cDisabled$1 : ""), lr(8, mr = `${cWrapper$1} ${Lr} ${Sr} ${dr} ${fr} ${(Vr = ar.class) != null ? Vr : ""}`);
  }, lr(9, gr = `${cBase$a}`), ar = exclude_internal_props(ar), [
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Br,
    ur,
    Dr,
    mr,
    gr,
    Hr,
    Fr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    fr,
    dr,
    kr,
    _r,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    zr
  ];
}
class RadioItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$r,
      create_fragment$M,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        label: 4,
        rounded: 12,
        padding: 13,
        active: 14,
        hover: 15,
        color: 16,
        fill: 17,
        regionLabel: 5
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get label() {
    return this.$$.ctx[4];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[13];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get color() {
    return this.$$.ctx[16];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get fill() {
    return this.$$.ctx[17];
  }
  set fill(ar) {
    this.$$set({ fill: ar }), flush();
  }
  get regionLabel() {
    return this.$$.ctx[5];
  }
  set regionLabel(ar) {
    this.$$set({ regionLabel: ar }), flush();
  }
}
create_custom_element(RadioItem, { group: {}, name: {}, value: {}, title: {}, label: {}, rounded: {}, padding: {}, active: {}, hover: {}, color: {}, fill: {}, regionLabel: {} }, ["default"], [], !0);
const get_trail_slot_changes = (cr) => ({}), get_trail_slot_context = (cr) => ({});
function get_each_context$7(cr, ar, lr) {
  const ur = cr.slice();
  return ur[23] = ar[lr], ur;
}
function create_if_block_2$7(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[15].default
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[14],
    null
  );
  return {
    c() {
      ar = element("label"), dr && dr.c(), attr(ar, "class", "range-slider-label " + cBaseLabel), attr(
        ar,
        "for",
        /*id*/
        cr[2]
      );
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr & /*$$scope*/
      16384) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[14],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[14],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[14]
        ),
        null
      ), (!lr || gr & /*id*/
      4) && attr(
        ar,
        "for",
        /*id*/
        fr[2]
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_if_block_1$9(cr) {
  let ar, lr, ur = ensure_array_like(
    /*tickmarks*/
    cr[8]
  ), dr = [];
  for (let fr = 0; fr < ur.length; fr += 1)
    dr[fr] = create_each_block$7(get_each_context$7(cr, ur, fr));
  return {
    c() {
      ar = element("datalist");
      for (let fr = 0; fr < dr.length; fr += 1)
        dr[fr].c();
      attr(ar, "id", lr = "tickmarks-" + /*id*/
      cr[2]), attr(ar, "class", "range-slider-ticks");
    },
    m(fr, gr) {
      insert(fr, ar, gr);
      for (let mr = 0; mr < dr.length; mr += 1)
        dr[mr] && dr[mr].m(ar, null);
    },
    p(fr, gr) {
      if (gr & /*tickmarks*/
      256) {
        ur = ensure_array_like(
          /*tickmarks*/
          fr[8]
        );
        let mr;
        for (mr = 0; mr < ur.length; mr += 1) {
          const vr = get_each_context$7(fr, ur, mr);
          dr[mr] ? dr[mr].p(vr, gr) : (dr[mr] = create_each_block$7(vr), dr[mr].c(), dr[mr].m(ar, null));
        }
        for (; mr < dr.length; mr += 1)
          dr[mr].d(1);
        dr.length = ur.length;
      }
      gr & /*id*/
      4 && lr !== (lr = "tickmarks-" + /*id*/
      fr[2]) && attr(ar, "id", lr);
    },
    d(fr) {
      fr && detach(ar), destroy_each(dr, fr);
    }
  };
}
function create_each_block$7(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("option"), ar.__value = lr = /*tm*/
      cr[23], set_input_value(ar, ar.__value), attr(ar, "label", ur = /*tm*/
      cr[23]);
    },
    m(dr, fr) {
      insert(dr, ar, fr);
    },
    p(dr, fr) {
      fr & /*tickmarks*/
      256 && lr !== (lr = /*tm*/
      dr[23]) && (ar.__value = lr, set_input_value(ar, ar.__value)), fr & /*tickmarks*/
      256 && ur !== (ur = /*tm*/
      dr[23]) && attr(ar, "label", ur);
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block$k(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[15].trail
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[14],
    get_trail_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "range-slider-trail");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr & /*$$scope*/
      16384) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[14],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[14],
          gr,
          get_trail_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[14]
        ),
        get_trail_slot_context
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_fragment$L(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar = (
    /*$$slots*/
    cr[12].default && create_if_block_2$7(cr)
  ), Er = [
    { type: "range" },
    { id: (
      /*id*/
      cr[2]
    ) },
    { name: (
      /*name*/
      cr[1]
    ) },
    {
      class: fr = "range-slider-input " + /*classesInput*/
      cr[9]
    },
    {
      list: gr = "tickmarks-" + /*id*/
      cr[2]
    },
    { "aria-label": (
      /*label*/
      cr[7]
    ) },
    { min: (
      /*min*/
      cr[3]
    ) },
    { max: (
      /*max*/
      cr[4]
    ) },
    { step: (
      /*step*/
      cr[5]
    ) },
    /*prunedRestProps*/
    cr[11]()
  ], Cr = {};
  for (let Lr = 0; Lr < Er.length; Lr += 1)
    Cr = assign$1(Cr, Er[Lr]);
  let Tr = (
    /*ticked*/
    cr[6] && /*tickmarks*/
    cr[8] && /*tickmarks*/
    cr[8].length && create_if_block_1$9(cr)
  ), Sr = (
    /*$$slots*/
    cr[12].trail && create_if_block$k(cr)
  );
  return {
    c() {
      ar = element("div"), Ar && Ar.c(), lr = space(), ur = element("div"), dr = element("input"), mr = space(), Tr && Tr.c(), vr = space(), Sr && Sr.c(), set_attributes(dr, Cr), attr(ur, "class", "range-content " + cBaseContent), attr(ar, "class", yr = "range-slider " + /*classesBase*/
      cr[10]), attr(ar, "data-testid", "range-slider");
    },
    m(Lr, Ir) {
      insert(Lr, ar, Ir), Ar && Ar.m(ar, null), append(ar, lr), append(ar, ur), append(ur, dr), dr.autofocus && dr.focus(), set_input_value(
        dr,
        /*value*/
        cr[0]
      ), append(ur, mr), Tr && Tr.m(ur, null), append(ar, vr), Sr && Sr.m(ar, null), _r = !0, kr || (xr = [
        listen(
          dr,
          "change",
          /*input_change_input_handler*/
          cr[19]
        ),
        listen(
          dr,
          "input",
          /*input_change_input_handler*/
          cr[19]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          cr[16]
        ),
        listen(
          dr,
          "change",
          /*change_handler*/
          cr[17]
        ),
        listen(
          dr,
          "blur",
          /*blur_handler*/
          cr[18]
        )
      ], kr = !0);
    },
    p(Lr, [Ir]) {
      /*$$slots*/
      Lr[12].default ? Ar ? (Ar.p(Lr, Ir), Ir & /*$$slots*/
      4096 && transition_in(Ar, 1)) : (Ar = create_if_block_2$7(Lr), Ar.c(), transition_in(Ar, 1), Ar.m(ar, lr)) : Ar && (group_outros(), transition_out(Ar, 1, 1, () => {
        Ar = null;
      }), check_outros()), set_attributes(dr, Cr = get_spread_update(Er, [
        { type: "range" },
        (!_r || Ir & /*id*/
        4) && { id: (
          /*id*/
          Lr[2]
        ) },
        (!_r || Ir & /*name*/
        2) && { name: (
          /*name*/
          Lr[1]
        ) },
        (!_r || Ir & /*classesInput*/
        512 && fr !== (fr = "range-slider-input " + /*classesInput*/
        Lr[9])) && { class: fr },
        (!_r || Ir & /*id*/
        4 && gr !== (gr = "tickmarks-" + /*id*/
        Lr[2])) && { list: gr },
        (!_r || Ir & /*label*/
        128) && { "aria-label": (
          /*label*/
          Lr[7]
        ) },
        (!_r || Ir & /*min*/
        8) && { min: (
          /*min*/
          Lr[3]
        ) },
        (!_r || Ir & /*max*/
        16) && { max: (
          /*max*/
          Lr[4]
        ) },
        (!_r || Ir & /*step*/
        32) && { step: (
          /*step*/
          Lr[5]
        ) },
        /*prunedRestProps*/
        Lr[11]()
      ])), Ir & /*value*/
      1 && set_input_value(
        dr,
        /*value*/
        Lr[0]
      ), /*ticked*/
      Lr[6] && /*tickmarks*/
      Lr[8] && /*tickmarks*/
      Lr[8].length ? Tr ? Tr.p(Lr, Ir) : (Tr = create_if_block_1$9(Lr), Tr.c(), Tr.m(ur, null)) : Tr && (Tr.d(1), Tr = null), /*$$slots*/
      Lr[12].trail ? Sr ? (Sr.p(Lr, Ir), Ir & /*$$slots*/
      4096 && transition_in(Sr, 1)) : (Sr = create_if_block$k(Lr), Sr.c(), transition_in(Sr, 1), Sr.m(ar, null)) : Sr && (group_outros(), transition_out(Sr, 1, 1, () => {
        Sr = null;
      }), check_outros()), (!_r || Ir & /*classesBase*/
      1024 && yr !== (yr = "range-slider " + /*classesBase*/
      Lr[10])) && attr(ar, "class", yr);
    },
    i(Lr) {
      _r || (transition_in(Ar), transition_in(Sr), _r = !0);
    },
    o(Lr) {
      transition_out(Ar), transition_out(Sr), _r = !1;
    },
    d(Lr) {
      Lr && detach(ar), Ar && Ar.d(), Tr && Tr.d(), Sr && Sr.d(), kr = !1, run_all(xr);
    }
  };
}
const cBase$9 = "space-y-2", cBaseLabel = "", cBaseContent = "flex justify-center py-2", cBaseInput = "w-full h-2";
function instance$q(cr, ar, lr) {
  let ur, dr;
  const fr = ["name", "id", "value", "min", "max", "step", "ticked", "accent", "label"];
  let gr = compute_rest_props(ar, fr), { $$slots: mr = {}, $$scope: vr } = ar;
  const yr = compute_slots(mr);
  let { name: _r } = ar, { id: kr = String(Math.random()) } = ar, { value: xr = 0 } = ar, { min: Ar = 0 } = ar, { max: Er = 100 } = ar, { step: Cr = 1 } = ar, { ticked: Tr = !1 } = ar, { accent: Sr = "accent-surface-900 dark:accent-surface-50" } = ar, { label: Lr = "" } = ar, Ir;
  function Nr() {
    Tr != !1 && lr(8, Ir = Array.from({ length: Er - Ar + 1 }, (Fr, zr) => zr + Ar));
  }
  Tr && Nr(), afterUpdate(() => {
    Nr();
  });
  function Rr() {
    return delete gr.class, gr;
  }
  function Mr(Fr) {
    bubble.call(this, cr, Fr);
  }
  function Br(Fr) {
    bubble.call(this, cr, Fr);
  }
  function Dr(Fr) {
    bubble.call(this, cr, Fr);
  }
  function Hr() {
    xr = to_number(this.value), lr(0, xr);
  }
  return cr.$$set = (Fr) => {
    lr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Fr))), lr(21, gr = compute_rest_props(ar, fr)), "name" in Fr && lr(1, _r = Fr.name), "id" in Fr && lr(2, kr = Fr.id), "value" in Fr && lr(0, xr = Fr.value), "min" in Fr && lr(3, Ar = Fr.min), "max" in Fr && lr(4, Er = Fr.max), "step" in Fr && lr(5, Cr = Fr.step), "ticked" in Fr && lr(6, Tr = Fr.ticked), "accent" in Fr && lr(13, Sr = Fr.accent), "label" in Fr && lr(7, Lr = Fr.label), "$$scope" in Fr && lr(14, vr = Fr.$$scope);
  }, cr.$$.update = () => {
    var Fr;
    lr(10, ur = `${cBase$9} ${(Fr = ar.class) != null ? Fr : ""}`), cr.$$.dirty & /*accent*/
    8192 && lr(9, dr = `${cBaseInput} ${Sr}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    _r,
    kr,
    Ar,
    Er,
    Cr,
    Tr,
    Lr,
    Ir,
    dr,
    ur,
    Rr,
    yr,
    Sr,
    vr,
    mr,
    Mr,
    Br,
    Dr,
    Hr
  ];
}
class RangeSlider extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$q, create_fragment$L, safe_not_equal, {
      name: 1,
      id: 2,
      value: 0,
      min: 3,
      max: 4,
      step: 5,
      ticked: 6,
      accent: 13,
      label: 7
    });
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get id() {
    return this.$$.ctx[2];
  }
  set id(ar) {
    this.$$set({ id: ar }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get min() {
    return this.$$.ctx[3];
  }
  set min(ar) {
    this.$$set({ min: ar }), flush();
  }
  get max() {
    return this.$$.ctx[4];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get step() {
    return this.$$.ctx[5];
  }
  set step(ar) {
    this.$$set({ step: ar }), flush();
  }
  get ticked() {
    return this.$$.ctx[6];
  }
  set ticked(ar) {
    this.$$set({ ticked: ar }), flush();
  }
  get accent() {
    return this.$$.ctx[13];
  }
  set accent(ar) {
    this.$$set({ accent: ar }), flush();
  }
  get label() {
    return this.$$.ctx[7];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(RangeSlider, { name: {}, id: {}, value: {}, min: {}, max: {}, step: {}, ticked: { type: "Boolean" }, accent: {}, label: {} }, ["default", "trail"], [], !0);
function create_if_block$j(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[22].default
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[21],
    null
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "slide-toggle-text ml-3");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr[0] & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[21],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[21],
          gr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[21]
        ),
        null
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_fragment$K(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    { name: (
      /*name*/
      cr[1]
    ) },
    /*prunedRestProps*/
    cr[8](),
    {
      disabled: dr = /*$$props*/
      cr[9].disabled
    }
  ], Sr = {};
  for (let Ir = 0; Ir < Tr.length; Ir += 1)
    Sr = assign$1(Sr, Tr[Ir]);
  let Lr = (
    /*$$slots*/
    cr[10].default && create_if_block$j(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("label"), ur = element("input"), fr = space(), gr = element("div"), mr = element("div"), _r = space(), Lr && Lr.c(), set_attributes(ur, Sr), attr(mr, "class", vr = "slide-toggle-thumb " + /*classesThumb*/
      cr[3]), toggle_class(
        mr,
        "cursor-not-allowed",
        /*$$props*/
        cr[9].disabled
      ), attr(gr, "class", yr = "slide-toggle-track " + /*classesTrack*/
      cr[4]), toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        cr[9].disabled
      ), attr(lr, "class", kr = "slide-toggle-label " + /*classesLabel*/
      cr[5]), attr(
        ar,
        "id",
        /*label*/
        cr[2]
      ), attr(ar, "class", xr = "slide-toggle " + /*classesBase*/
      cr[6]), attr(ar, "data-testid", "slide-toggle"), attr(ar, "role", "switch"), attr(
        ar,
        "aria-label",
        /*label*/
        cr[2]
      ), attr(
        ar,
        "aria-checked",
        /*checked*/
        cr[0]
      ), attr(ar, "tabindex", "0");
    },
    m(Ir, Nr) {
      insert(Ir, ar, Nr), append(ar, lr), append(lr, ur), ur.autofocus && ur.focus(), ur.checked = /*checked*/
      cr[0], append(lr, fr), append(lr, gr), append(gr, mr), append(lr, _r), Lr && Lr.m(lr, null), Ar = !0, Er || (Cr = [
        listen(
          ur,
          "change",
          /*input_change_handler*/
          cr[31]
        ),
        listen(
          ur,
          "click",
          /*click_handler*/
          cr[23]
        ),
        listen(
          ur,
          "keydown",
          /*keydown_handler*/
          cr[24]
        ),
        listen(
          ur,
          "keyup",
          /*keyup_handler*/
          cr[25]
        ),
        listen(
          ur,
          "keypress",
          /*keypress_handler*/
          cr[26]
        ),
        listen(
          ur,
          "mouseover",
          /*mouseover_handler*/
          cr[27]
        ),
        listen(
          ur,
          "change",
          /*change_handler*/
          cr[28]
        ),
        listen(
          ur,
          "focus",
          /*focus_handler*/
          cr[29]
        ),
        listen(
          ur,
          "blur",
          /*blur_handler*/
          cr[30]
        ),
        listen(
          ar,
          "keydown",
          /*onKeyDown*/
          cr[7]
        )
      ], Er = !0);
    },
    p(Ir, Nr) {
      set_attributes(ur, Sr = get_spread_update(Tr, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        (!Ar || Nr[0] & /*name*/
        2) && { name: (
          /*name*/
          Ir[1]
        ) },
        /*prunedRestProps*/
        Ir[8](),
        (!Ar || Nr[0] & /*$$props*/
        512 && dr !== (dr = /*$$props*/
        Ir[9].disabled)) && { disabled: dr }
      ])), Nr[0] & /*checked*/
      1 && (ur.checked = /*checked*/
      Ir[0]), (!Ar || Nr[0] & /*classesThumb*/
      8 && vr !== (vr = "slide-toggle-thumb " + /*classesThumb*/
      Ir[3])) && attr(mr, "class", vr), (!Ar || Nr[0] & /*classesThumb, $$props*/
      520) && toggle_class(
        mr,
        "cursor-not-allowed",
        /*$$props*/
        Ir[9].disabled
      ), (!Ar || Nr[0] & /*classesTrack*/
      16 && yr !== (yr = "slide-toggle-track " + /*classesTrack*/
      Ir[4])) && attr(gr, "class", yr), (!Ar || Nr[0] & /*classesTrack, $$props*/
      528) && toggle_class(
        gr,
        "cursor-not-allowed",
        /*$$props*/
        Ir[9].disabled
      ), /*$$slots*/
      Ir[10].default ? Lr ? (Lr.p(Ir, Nr), Nr[0] & /*$$slots*/
      1024 && transition_in(Lr, 1)) : (Lr = create_if_block$j(Ir), Lr.c(), transition_in(Lr, 1), Lr.m(lr, null)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), (!Ar || Nr[0] & /*classesLabel*/
      32 && kr !== (kr = "slide-toggle-label " + /*classesLabel*/
      Ir[5])) && attr(lr, "class", kr), (!Ar || Nr[0] & /*label*/
      4) && attr(
        ar,
        "id",
        /*label*/
        Ir[2]
      ), (!Ar || Nr[0] & /*classesBase*/
      64 && xr !== (xr = "slide-toggle " + /*classesBase*/
      Ir[6])) && attr(ar, "class", xr), (!Ar || Nr[0] & /*label*/
      4) && attr(
        ar,
        "aria-label",
        /*label*/
        Ir[2]
      ), (!Ar || Nr[0] & /*checked*/
      1) && attr(
        ar,
        "aria-checked",
        /*checked*/
        Ir[0]
      );
    },
    i(Ir) {
      Ar || (transition_in(Lr), Ar = !0);
    },
    o(Ir) {
      transition_out(Lr), Ar = !1;
    },
    d(Ir) {
      Ir && detach(ar), Lr && Lr.d(), Er = !1, run_all(Cr);
    }
  };
}
const cBase$8 = "inline-block", cLabel = "unstyled flex items-center", cTrack$1 = "flex transition-all duration-[200ms] cursor-pointer", cThumb$1 = "w-[50%] h-full scale-[0.8] transition-all duration-[200ms] shadow";
function instance$p(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r;
  const kr = ["name", "checked", "size", "background", "active", "border", "rounded", "label"];
  let xr = compute_rest_props(ar, kr), { $$slots: Ar = {}, $$scope: Er } = ar;
  const Cr = compute_slots(Ar), Tr = createEventDispatcher();
  let { name: Sr } = ar, { checked: Lr = !1 } = ar, { size: Ir = "md" } = ar, { background: Nr = "bg-surface-400 dark:bg-surface-700" } = ar, { active: Rr = "bg-surface-900 dark:bg-surface-300" } = ar, { border: Mr = "" } = ar, { rounded: Br = "rounded-full" } = ar, { label: Dr = "" } = ar, Hr;
  switch (Ir) {
    case "sm":
      Hr = "w-12 h-6";
      break;
    case "lg":
      Hr = "w-20 h-10";
      break;
    default:
      Hr = "w-16 h-8";
  }
  function Fr($r) {
    ["Enter", "Space"].includes($r.code) && ($r.preventDefault(), Tr("keyup", $r), $r.currentTarget.firstChild.click());
  }
  function zr() {
    return delete xr.class, xr;
  }
  function Ur($r) {
    bubble.call(this, cr, $r);
  }
  function jr($r) {
    bubble.call(this, cr, $r);
  }
  function Yr($r) {
    bubble.call(this, cr, $r);
  }
  function qr($r) {
    bubble.call(this, cr, $r);
  }
  function Wr($r) {
    bubble.call(this, cr, $r);
  }
  function Jr($r) {
    bubble.call(this, cr, $r);
  }
  function Gr($r) {
    bubble.call(this, cr, $r);
  }
  function Vr($r) {
    bubble.call(this, cr, $r);
  }
  function Qr() {
    Lr = this.checked, lr(0, Lr);
  }
  return cr.$$set = ($r) => {
    lr(9, ar = assign$1(assign$1({}, ar), exclude_internal_props($r))), lr(33, xr = compute_rest_props(ar, kr)), "name" in $r && lr(1, Sr = $r.name), "checked" in $r && lr(0, Lr = $r.checked), "size" in $r && lr(11, Ir = $r.size), "background" in $r && lr(12, Nr = $r.background), "active" in $r && lr(13, Rr = $r.active), "border" in $r && lr(14, Mr = $r.border), "rounded" in $r && lr(15, Br = $r.rounded), "label" in $r && lr(2, Dr = $r.label), "$$scope" in $r && lr(21, Er = $r.$$scope);
  }, cr.$$.update = () => {
    var $r;
    cr.$$.dirty[0] & /*checked, active, background*/
    12289 && lr(19, ur = Lr ? Rr : `${Nr} cursor-pointer`), cr.$$.dirty[0] & /*checked*/
    1 && lr(18, dr = Lr ? "bg-white/75" : "bg-white"), cr.$$.dirty[0] & /*checked*/
    1 && lr(17, fr = Lr ? "translate-x-full" : ""), lr(20, gr = ar.disabled === !0 ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer"), lr(6, mr = `${cBase$8} ${Br} ${gr} ${($r = ar.class) != null ? $r : ""}`), cr.$$.dirty[0] & /*border, rounded, trackSize, cTrackActive*/
    638976 && lr(4, yr = `${cTrack$1} ${Mr} ${Br} ${Hr} ${ur}`), cr.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    425984 && lr(3, _r = `${cThumb$1} ${Br} ${dr} ${fr}`);
  }, lr(5, vr = `${cLabel}`), ar = exclude_internal_props(ar), [
    Lr,
    Sr,
    Dr,
    _r,
    yr,
    vr,
    mr,
    Fr,
    zr,
    ar,
    Cr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Hr,
    fr,
    dr,
    ur,
    gr,
    Er,
    Ar,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr
  ];
}
class SlideToggle extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$p,
      create_fragment$K,
      safe_not_equal,
      {
        name: 1,
        checked: 0,
        size: 11,
        background: 12,
        active: 13,
        border: 14,
        rounded: 15,
        label: 2
      },
      null,
      [-1, -1]
    );
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[0];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get size() {
    return this.$$.ctx[11];
  }
  set size(ar) {
    this.$$set({ size: ar }), flush();
  }
  get background() {
    return this.$$.ctx[12];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get active() {
    return this.$$.ctx[13];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[14];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get label() {
    return this.$$.ctx[2];
  }
  set label(ar) {
    this.$$set({ label: ar }), flush();
  }
}
create_custom_element(SlideToggle, { name: {}, checked: { type: "Boolean" }, size: {}, background: {}, active: {}, border: {}, rounded: {}, label: {} }, ["default"], [], !0);
function get_each_context$6(cr, ar, lr) {
  const ur = cr.slice();
  return ur[36] = ar[lr], ur;
}
function create_if_block$i(cr) {
  let ar, lr, ur, dr, fr, gr = ensure_array_like(Array.from(Array(
    /*$state*/
    cr[7].total
  ).keys())), mr = [];
  for (let vr = 0; vr < gr.length; vr += 1)
    mr[vr] = create_each_block$6(get_each_context$6(cr, gr, vr));
  return {
    c() {
      ar = element("header");
      for (let vr = 0; vr < mr.length; vr += 1)
        mr[vr].c();
      attr(ar, "class", lr = "stepper-header " + /*classesHeader*/
      cr[11]);
    },
    m(vr, yr) {
      insert(vr, ar, yr);
      for (let _r = 0; _r < mr.length; _r += 1)
        mr[_r] && mr[_r].m(ar, null);
      fr = !0;
    },
    p(vr, yr) {
      if (cr = vr, yr[0] & /*classesHeaderStep, isActive, $state, classesBadge, stepTerm*/
      1729) {
        gr = ensure_array_like(Array.from(Array(
          /*$state*/
          cr[7].total
        ).keys()));
        let _r;
        for (_r = 0; _r < gr.length; _r += 1) {
          const kr = get_each_context$6(cr, gr, _r);
          mr[_r] ? mr[_r].p(kr, yr) : (mr[_r] = create_each_block$6(kr), mr[_r].c(), mr[_r].m(ar, null));
        }
        for (; _r < mr.length; _r += 1)
          mr[_r].d(1);
        mr.length = gr.length;
      }
      (!fr || yr[0] & /*classesHeader*/
      2048 && lr !== (lr = "stepper-header " + /*classesHeader*/
      cr[11])) && attr(ar, "class", lr);
    },
    i(vr) {
      fr || (vr && add_render_callback(() => {
        fr && (dr && dr.end(1), ur = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            cr[2]
          ),
          params: (
            /*transitionInParams*/
            cr[3]
          ),
          enabled: (
            /*transitions*/
            cr[1]
          )
        }), ur.start());
      }), fr = !0);
    },
    o(vr) {
      ur && ur.invalidate(), vr && (dr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          cr[4]
        ),
        params: (
          /*transitionOutParams*/
          cr[5]
        ),
        enabled: (
          /*transitions*/
          cr[1]
        )
      })), fr = !1;
    },
    d(vr) {
      vr && detach(ar), destroy_each(mr, vr), vr && dr && dr.end();
    }
  };
}
function create_each_block$6(cr) {
  let ar, lr, ur = (
    /*isActive*/
    (cr[6](
      /*step*/
      cr[36]
    ) ? `${/*stepTerm*/
    cr[0]} ${/*step*/
    cr[36] + 1}` : (
      /*step*/
      cr[36] + 1
    )) + ""
  ), dr, fr, gr, mr;
  return {
    c() {
      ar = element("div"), lr = element("span"), dr = text$3(ur), gr = space(), attr(lr, "class", fr = "badge " + /*classesBadge*/
      cr[9](
        /*step*/
        cr[36]
      )), attr(ar, "class", mr = "stepper-header-step " + /*classesHeaderStep*/
      cr[10]), toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        cr[6](
          /*step*/
          cr[36]
        )
      );
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, lr), append(lr, dr), append(ar, gr);
    },
    p(vr, yr) {
      yr[0] & /*isActive, $state, stepTerm*/
      193 && ur !== (ur = /*isActive*/
      (vr[6](
        /*step*/
        vr[36]
      ) ? `${/*stepTerm*/
      vr[0]} ${/*step*/
      vr[36] + 1}` : (
        /*step*/
        vr[36] + 1
      )) + "") && set_data(dr, ur), yr[0] & /*classesBadge, $state*/
      640 && fr !== (fr = "badge " + /*classesBadge*/
      vr[9](
        /*step*/
        vr[36]
      )) && attr(lr, "class", fr), yr[0] & /*classesHeaderStep*/
      1024 && mr !== (mr = "stepper-header-step " + /*classesHeaderStep*/
      vr[10]) && attr(ar, "class", mr), yr[0] & /*classesHeaderStep, isActive, $state*/
      1216 && toggle_class(
        ar,
        "flex-1",
        /*isActive*/
        vr[6](
          /*step*/
          vr[36]
        )
      );
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_fragment$J(cr) {
  let ar, lr, ur, dr, fr, gr, mr = (
    /*$state*/
    cr[7].total && create_if_block$i(cr)
  );
  const vr = (
    /*#slots*/
    cr[32].default
  ), yr = create_slot(
    vr,
    cr,
    /*$$scope*/
    cr[31],
    null
  );
  return {
    c() {
      ar = element("div"), mr && mr.c(), lr = space(), ur = element("div"), yr && yr.c(), attr(ur, "class", dr = "stepper-content " + /*classesContent*/
      cr[8]), attr(ar, "class", fr = "stepper " + /*classesBase*/
      cr[12]), attr(ar, "data-testid", "stepper");
    },
    m(_r, kr) {
      insert(_r, ar, kr), mr && mr.m(ar, null), append(ar, lr), append(ar, ur), yr && yr.m(ur, null), gr = !0;
    },
    p(_r, kr) {
      /*$state*/
      _r[7].total ? mr ? (mr.p(_r, kr), kr[0] & /*$state*/
      128 && transition_in(mr, 1)) : (mr = create_if_block$i(_r), mr.c(), transition_in(mr, 1), mr.m(ar, lr)) : mr && (group_outros(), transition_out(mr, 1, 1, () => {
        mr = null;
      }), check_outros()), yr && yr.p && (!gr || kr[1] & /*$$scope*/
      1) && update_slot_base(
        yr,
        vr,
        _r,
        /*$$scope*/
        _r[31],
        gr ? get_slot_changes(
          vr,
          /*$$scope*/
          _r[31],
          kr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          _r[31]
        ),
        null
      ), (!gr || kr[0] & /*classesContent*/
      256 && dr !== (dr = "stepper-content " + /*classesContent*/
      _r[8])) && attr(ur, "class", dr), (!gr || kr[0] & /*classesBase*/
      4096 && fr !== (fr = "stepper " + /*classesBase*/
      _r[12])) && attr(ar, "class", fr);
    },
    i(_r) {
      gr || (transition_in(mr), transition_in(yr, _r), gr = !0);
    },
    o(_r) {
      transition_out(mr), transition_out(yr, _r), gr = !1;
    },
    d(_r) {
      _r && detach(ar), mr && mr.d(), yr && yr.d(_r);
    }
  };
}
const cBase$7 = "space-y-4", cHeader$2 = "flex items-center border-t mt-[15px]", cHeaderStep = "-mt-[15px] transition-all duration-300", cContent$1 = "";
function instance$o(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r;
  component_subscribe(cr, prefersReducedMotionStore, (Xr) => lr(33, _r = Xr));
  let { $$slots: kr = {}, $$scope: xr } = ar;
  const Ar = createEventDispatcher();
  let { gap: Er = "gap-4" } = ar, { stepTerm: Cr = "Step" } = ar, { badge: Tr = "variant-filled-surface" } = ar, { active: Sr = "variant-filled" } = ar, { border: Lr = "border-surface-400-500-token" } = ar, { start: Ir = 0 } = ar, { justify: Nr = "justify-between" } = ar, { buttonBack: Rr = "variant-ghost" } = ar, { buttonBackType: Mr = "button" } = ar, { buttonBackLabel: Br = "&larr; Back" } = ar, { buttonNext: Dr = "variant-filled" } = ar, { buttonNextType: Hr = "button" } = ar, { buttonNextLabel: Fr = "Next &rarr;" } = ar, { buttonComplete: zr = "variant-filled-primary" } = ar, { buttonCompleteType: Ur = "button" } = ar, { buttonCompleteLabel: jr = "Complete" } = ar, { regionHeader: Yr = "" } = ar, { regionContent: qr = "" } = ar, { transitions: Wr = !_r } = ar, { transitionIn: Jr = fade } = ar, { transitionInParams: Gr = { duration: 100 } } = ar, { transitionOut: Vr = fade } = ar, { transitionOutParams: Qr = { duration: 100 } } = ar, $r = writable({ current: Ir, total: 0 });
  return component_subscribe(cr, $r, (Xr) => lr(7, yr = Xr)), setContext("state", $r), setContext("dispatchParent", Ar), setContext("stepTerm", Cr), setContext("gap", Er), setContext("justify", Nr), setContext("buttonBack", Rr), setContext("buttonBackType", Mr), setContext("buttonBackLabel", Br), setContext("buttonNext", Dr), setContext("buttonNextType", Hr), setContext("buttonNextLabel", Fr), setContext("buttonComplete", zr), setContext("buttonCompleteType", Ur), setContext("buttonCompleteLabel", jr), setContext("transitions", Wr), setContext("transitionIn", Jr), setContext("transitionInParams", Gr), setContext("transitionOut", Vr), setContext("transitionOutParams", Qr), cr.$$set = (Xr) => {
    lr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Xr))), "gap" in Xr && lr(14, Er = Xr.gap), "stepTerm" in Xr && lr(0, Cr = Xr.stepTerm), "badge" in Xr && lr(15, Tr = Xr.badge), "active" in Xr && lr(16, Sr = Xr.active), "border" in Xr && lr(17, Lr = Xr.border), "start" in Xr && lr(18, Ir = Xr.start), "justify" in Xr && lr(19, Nr = Xr.justify), "buttonBack" in Xr && lr(20, Rr = Xr.buttonBack), "buttonBackType" in Xr && lr(21, Mr = Xr.buttonBackType), "buttonBackLabel" in Xr && lr(22, Br = Xr.buttonBackLabel), "buttonNext" in Xr && lr(23, Dr = Xr.buttonNext), "buttonNextType" in Xr && lr(24, Hr = Xr.buttonNextType), "buttonNextLabel" in Xr && lr(25, Fr = Xr.buttonNextLabel), "buttonComplete" in Xr && lr(26, zr = Xr.buttonComplete), "buttonCompleteType" in Xr && lr(27, Ur = Xr.buttonCompleteType), "buttonCompleteLabel" in Xr && lr(28, jr = Xr.buttonCompleteLabel), "regionHeader" in Xr && lr(29, Yr = Xr.regionHeader), "regionContent" in Xr && lr(30, qr = Xr.regionContent), "transitions" in Xr && lr(1, Wr = Xr.transitions), "transitionIn" in Xr && lr(2, Jr = Xr.transitionIn), "transitionInParams" in Xr && lr(3, Gr = Xr.transitionInParams), "transitionOut" in Xr && lr(4, Vr = Xr.transitionOut), "transitionOutParams" in Xr && lr(5, Qr = Xr.transitionOutParams), "$$scope" in Xr && lr(31, xr = Xr.$$scope);
  }, cr.$$.update = () => {
    var Xr;
    cr.$$.dirty[0] & /*$state*/
    128 && lr(6, ur = (si) => si === yr.current), lr(12, dr = `${cBase$7} ${(Xr = ar.class) != null ? Xr : ""}`), cr.$$.dirty[0] & /*border, gap, regionHeader*/
    537018368 && lr(11, fr = `${cHeader$2} ${Lr} ${Er} ${Yr}`), cr.$$.dirty[0] & /*isActive, active, badge*/
    98368 && lr(9, mr = (si) => ur(si) ? Sr : Tr), cr.$$.dirty[0] & /*regionContent*/
    1073741824 && lr(8, vr = `${cContent$1} ${qr}`);
  }, lr(10, gr = `${cHeaderStep}`), ar = exclude_internal_props(ar), [
    Cr,
    Wr,
    Jr,
    Gr,
    Vr,
    Qr,
    ur,
    yr,
    vr,
    mr,
    gr,
    fr,
    dr,
    $r,
    Er,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    xr,
    kr
  ];
}
class Stepper extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$o,
      create_fragment$J,
      safe_not_equal,
      {
        gap: 14,
        stepTerm: 0,
        badge: 15,
        active: 16,
        border: 17,
        start: 18,
        justify: 19,
        buttonBack: 20,
        buttonBackType: 21,
        buttonBackLabel: 22,
        buttonNext: 23,
        buttonNextType: 24,
        buttonNextLabel: 25,
        buttonComplete: 26,
        buttonCompleteType: 27,
        buttonCompleteLabel: 28,
        regionHeader: 29,
        regionContent: 30,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
  }
  get gap() {
    return this.$$.ctx[14];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[0];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get badge() {
    return this.$$.ctx[15];
  }
  set badge(ar) {
    this.$$set({ badge: ar }), flush();
  }
  get active() {
    return this.$$.ctx[16];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get border() {
    return this.$$.ctx[17];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get start() {
    return this.$$.ctx[18];
  }
  set start(ar) {
    this.$$set({ start: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[19];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[20];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[21];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[22];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[23];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[24];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[25];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[26];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[27];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[28];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[29];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[30];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[1];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[2];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[3];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[4];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[5];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Stepper, { gap: {}, stepTerm: {}, badge: {}, active: {}, border: {}, start: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, regionHeader: {}, regionContent: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["default"], [], !0);
const get_navigation_slot_changes = (cr) => ({}), get_navigation_slot_context = (cr) => ({}), get_header_slot_changes = (cr) => ({}), get_header_slot_context = (cr) => ({});
function create_if_block$h(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr;
  const _r = (
    /*#slots*/
    cr[34].header
  ), kr = create_slot(
    _r,
    cr,
    /*$$scope*/
    cr[33],
    get_header_slot_context
  ), xr = kr || fallback_block_1(cr), Ar = (
    /*#slots*/
    cr[34].default
  ), Er = create_slot(
    Ar,
    cr,
    /*$$scope*/
    cr[33],
    null
  ), Cr = Er || fallback_block$1(cr);
  let Tr = (
    /*$state*/
    cr[21].total > 1 && create_if_block_1$8(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("header"), xr && xr.c(), dr = space(), fr = element("div"), Cr && Cr.c(), mr = space(), Tr && Tr.c(), attr(lr, "class", ur = "step-header " + /*classesHeader*/
      cr[19]), attr(fr, "class", gr = "step-content " + /*classesContent*/
      cr[18]), attr(ar, "class", vr = "step " + /*classesBase*/
      cr[20]), attr(ar, "data-testid", "step");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), xr && xr.m(lr, null), append(ar, dr), append(ar, fr), Cr && Cr.m(fr, null), append(ar, mr), Tr && Tr.m(ar, null), yr = !0;
    },
    p(Sr, Lr) {
      kr ? kr.p && (!yr || Lr[1] & /*$$scope*/
      4) && update_slot_base(
        kr,
        _r,
        Sr,
        /*$$scope*/
        Sr[33],
        yr ? get_slot_changes(
          _r,
          /*$$scope*/
          Sr[33],
          Lr,
          get_header_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Sr[33]
        ),
        get_header_slot_context
      ) : xr && xr.p && (!yr || Lr[0] & /*stepTerm*/
      4) && xr.p(Sr, yr ? Lr : [-1, -1]), (!yr || Lr[0] & /*classesHeader*/
      524288 && ur !== (ur = "step-header " + /*classesHeader*/
      Sr[19])) && attr(lr, "class", ur), Er ? Er.p && (!yr || Lr[1] & /*$$scope*/
      4) && update_slot_base(
        Er,
        Ar,
        Sr,
        /*$$scope*/
        Sr[33],
        yr ? get_slot_changes(
          Ar,
          /*$$scope*/
          Sr[33],
          Lr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Sr[33]
        ),
        null
      ) : Cr && Cr.p && (!yr || Lr[0] & /*stepTerm*/
      4) && Cr.p(Sr, yr ? Lr : [-1, -1]), (!yr || Lr[0] & /*classesContent*/
      262144 && gr !== (gr = "step-content " + /*classesContent*/
      Sr[18])) && attr(fr, "class", gr), /*$state*/
      Sr[21].total > 1 ? Tr ? (Tr.p(Sr, Lr), Lr[0] & /*$state*/
      2097152 && transition_in(Tr, 1)) : (Tr = create_if_block_1$8(Sr), Tr.c(), transition_in(Tr, 1), Tr.m(ar, null)) : Tr && (group_outros(), transition_out(Tr, 1, 1, () => {
        Tr = null;
      }), check_outros()), (!yr || Lr[0] & /*classesBase*/
      1048576 && vr !== (vr = "step " + /*classesBase*/
      Sr[20])) && attr(ar, "class", vr);
    },
    i(Sr) {
      yr || (transition_in(xr, Sr), transition_in(Cr, Sr), transition_in(Tr), yr = !0);
    },
    o(Sr) {
      transition_out(xr, Sr), transition_out(Cr, Sr), transition_out(Tr), yr = !1;
    },
    d(Sr) {
      Sr && detach(ar), xr && xr.d(Sr), Cr && Cr.d(Sr), Tr && Tr.d();
    }
  };
}
function fallback_block_1(cr) {
  let ar, lr, ur = (
    /*stepIndex*/
    cr[22] + 1 + ""
  ), dr;
  return {
    c() {
      ar = text$3(
        /*stepTerm*/
        cr[2]
      ), lr = space(), dr = text$3(ur);
    },
    m(fr, gr) {
      insert(fr, ar, gr), insert(fr, lr, gr), insert(fr, dr, gr);
    },
    p(fr, gr) {
      gr[0] & /*stepTerm*/
      4 && set_data(
        ar,
        /*stepTerm*/
        fr[2]
      );
    },
    d(fr) {
      fr && (detach(ar), detach(lr), detach(dr));
    }
  };
}
function fallback_block$1(cr) {
  let ar, lr, ur, dr = (
    /*stepIndex*/
    cr[22] + 1 + ""
  ), fr, gr;
  return {
    c() {
      ar = text$3("("), lr = text$3(
        /*stepTerm*/
        cr[2]
      ), ur = space(), fr = text$3(dr), gr = text$3(" Content)");
    },
    m(mr, vr) {
      insert(mr, ar, vr), insert(mr, lr, vr), insert(mr, ur, vr), insert(mr, fr, vr), insert(mr, gr, vr);
    },
    p(mr, vr) {
      vr[0] & /*stepTerm*/
      4 && set_data(
        lr,
        /*stepTerm*/
        mr[2]
      );
    },
    d(mr) {
      mr && (detach(ar), detach(lr), detach(ur), detach(fr), detach(gr));
    }
  };
}
function create_if_block_1$8(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  const yr = [create_if_block_4$3, create_else_block_1$5], _r = [];
  function kr(Cr, Tr) {
    return (
      /*stepIndex*/
      Cr[22] === 0 && /*$$slots*/
      Cr[26].navigation ? 0 : 1
    );
  }
  lr = kr(cr), ur = _r[lr] = yr[lr](cr);
  function xr(Cr, Tr) {
    return (
      /*stepIndex*/
      Cr[22] < /*$state*/
      Cr[21].total - 1 ? create_if_block_2$6 : create_else_block$8
    );
  }
  let Ar = xr(cr), Er = Ar(cr);
  return {
    c() {
      ar = element("div"), ur.c(), dr = space(), Er.c(), attr(ar, "class", fr = "step-navigation " + /*classesNavigation*/
      cr[17]);
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), _r[lr].m(ar, null), append(ar, dr), Er.m(ar, null), vr = !0;
    },
    p(Cr, Tr) {
      cr = Cr;
      let Sr = lr;
      lr = kr(cr), lr === Sr ? _r[lr].p(cr, Tr) : (group_outros(), transition_out(_r[Sr], 1, 1, () => {
        _r[Sr] = null;
      }), check_outros(), ur = _r[lr], ur ? ur.p(cr, Tr) : (ur = _r[lr] = yr[lr](cr), ur.c()), transition_in(ur, 1), ur.m(ar, dr)), Ar === (Ar = xr(cr)) && Er ? Er.p(cr, Tr) : (Er.d(1), Er = Ar(cr), Er && (Er.c(), Er.m(ar, null))), (!vr || Tr[0] & /*classesNavigation*/
      131072 && fr !== (fr = "step-navigation " + /*classesNavigation*/
      cr[17])) && attr(ar, "class", fr);
    },
    i(Cr) {
      vr || (transition_in(ur), Cr && add_render_callback(() => {
        vr && (mr && mr.end(1), gr = create_in_transition(ar, dynamicTransition, {
          transition: (
            /*transitionIn*/
            cr[13]
          ),
          params: (
            /*transitionInParams*/
            cr[14]
          ),
          enabled: (
            /*transitions*/
            cr[12]
          )
        }), gr.start());
      }), vr = !0);
    },
    o(Cr) {
      transition_out(ur), gr && gr.invalidate(), Cr && (mr = create_out_transition(ar, dynamicTransition, {
        transition: (
          /*transitionOut*/
          cr[15]
        ),
        params: (
          /*transitionOutParams*/
          cr[16]
        ),
        enabled: (
          /*transitions*/
          cr[12]
        )
      })), vr = !1;
    },
    d(Cr) {
      Cr && detach(ar), _r[lr].d(), Er.d(), Cr && mr && mr.end();
    }
  };
}
function create_else_block_1$5(cr) {
  let ar, lr, ur, dr, fr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonBackType*/
        cr[4]
      ), attr(ar, "class", lr = "btn " + /*buttonBack*/
      cr[3]), ar.disabled = ur = /*$state*/
      cr[21].current === 0;
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.innerHTML = /*buttonBackLabel*/
      cr[5], dr || (fr = listen(
        ar,
        "click",
        /*onBack*/
        cr[24]
      ), dr = !0);
    },
    p(gr, mr) {
      mr[0] & /*buttonBackLabel*/
      32 && (ar.innerHTML = /*buttonBackLabel*/
      gr[5]), mr[0] & /*buttonBackType*/
      16 && attr(
        ar,
        "type",
        /*buttonBackType*/
        gr[4]
      ), mr[0] & /*buttonBack*/
      8 && lr !== (lr = "btn " + /*buttonBack*/
      gr[3]) && attr(ar, "class", lr), mr[0] & /*$state*/
      2097152 && ur !== (ur = /*$state*/
      gr[21].current === 0) && (ar.disabled = ur);
    },
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar), dr = !1, fr();
    }
  };
}
function create_if_block_4$3(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[34].navigation
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[33],
    get_navigation_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "step-navigation-slot");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr[1] & /*$$scope*/
      4) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[33],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[33],
          gr,
          get_navigation_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[33]
        ),
        get_navigation_slot_context
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_else_block$8(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "type",
        /*buttonCompleteType*/
        cr[10]
      ), attr(ar, "class", lr = "btn " + /*buttonComplete*/
      cr[9]), ar.disabled = /*locked*/
      cr[0];
    },
    m(fr, gr) {
      insert(fr, ar, gr), ar.innerHTML = /*buttonCompleteLabel*/
      cr[11], ur || (dr = listen(
        ar,
        "click",
        /*onComplete*/
        cr[25]
      ), ur = !0);
    },
    p(fr, gr) {
      gr[0] & /*buttonCompleteLabel*/
      2048 && (ar.innerHTML = /*buttonCompleteLabel*/
      fr[11]), gr[0] & /*buttonCompleteType*/
      1024 && attr(
        ar,
        "type",
        /*buttonCompleteType*/
        fr[10]
      ), gr[0] & /*buttonComplete*/
      512 && lr !== (lr = "btn " + /*buttonComplete*/
      fr[9]) && attr(ar, "class", lr), gr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      fr[0]);
    },
    d(fr) {
      fr && detach(ar), ur = !1, dr();
    }
  };
}
function create_if_block_2$6(cr) {
  let ar, lr, ur, dr, fr, gr, mr = (
    /*locked*/
    cr[0] && create_if_block_3$5()
  );
  return {
    c() {
      ar = element("button"), mr && mr.c(), lr = space(), ur = element("span"), attr(
        ar,
        "type",
        /*buttonNextType*/
        cr[7]
      ), attr(ar, "class", dr = "btn " + /*buttonNext*/
      cr[6]), ar.disabled = /*locked*/
      cr[0];
    },
    m(vr, yr) {
      insert(vr, ar, yr), mr && mr.m(ar, null), append(ar, lr), append(ar, ur), ur.innerHTML = /*buttonNextLabel*/
      cr[8], fr || (gr = listen(
        ar,
        "click",
        /*onNext*/
        cr[23]
      ), fr = !0);
    },
    p(vr, yr) {
      /*locked*/
      vr[0] ? mr || (mr = create_if_block_3$5(), mr.c(), mr.m(ar, lr)) : mr && (mr.d(1), mr = null), yr[0] & /*buttonNextLabel*/
      256 && (ur.innerHTML = /*buttonNextLabel*/
      vr[8]), yr[0] & /*buttonNextType*/
      128 && attr(
        ar,
        "type",
        /*buttonNextType*/
        vr[7]
      ), yr[0] & /*buttonNext*/
      64 && dr !== (dr = "btn " + /*buttonNext*/
      vr[6]) && attr(ar, "class", dr), yr[0] & /*locked*/
      1 && (ar.disabled = /*locked*/
      vr[0]);
    },
    d(vr) {
      vr && detach(ar), mr && mr.d(), fr = !1, gr();
    }
  };
}
function create_if_block_3$5(cr) {
  let ar, lr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), attr(lr, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z"), attr(ar, "class", "w-3 aspect-square fill-current"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, dr) {
      insert(ur, ar, dr), append(ar, lr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$I(cr) {
  let ar, lr, ur = (
    /*stepIndex*/
    cr[22] === /*$state*/
    cr[21].current && create_if_block$h(cr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$2();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), insert(dr, ar, fr), lr = !0;
    },
    p(dr, fr) {
      /*stepIndex*/
      dr[22] === /*$state*/
      dr[21].current ? ur ? (ur.p(dr, fr), fr[0] & /*$state*/
      2097152 && transition_in(ur, 1)) : (ur = create_if_block$h(dr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(dr) {
      lr || (transition_in(ur), lr = !0);
    },
    o(dr) {
      transition_out(ur), lr = !1;
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(dr);
    }
  };
}
const cBase$6 = "space-y-4", cHeader$1 = "text-2xl font-bold", cContent = "space-y-4", cNavigation = "flex";
function instance$n(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr = noop$1, yr = () => (vr(), vr = subscribe(Sr, (Zr) => lr(21, mr = Zr)), Sr);
  cr.$$.on_destroy.push(() => vr());
  let { $$slots: _r = {}, $$scope: kr } = ar;
  const xr = compute_slots(_r);
  let { locked: Ar = !1 } = ar, { regionHeader: Er = "" } = ar, { regionContent: Cr = "" } = ar, { regionNavigation: Tr = "" } = ar, { state: Sr = getContext("state") } = ar;
  yr();
  let { dispatchParent: Lr = getContext("dispatchParent") } = ar, { stepTerm: Ir = getContext("stepTerm") } = ar, { gap: Nr = getContext("gap") } = ar, { justify: Rr = getContext("justify") } = ar, { buttonBack: Mr = getContext("buttonBack") } = ar, { buttonBackType: Br = getContext("buttonBackType") } = ar, { buttonBackLabel: Dr = getContext("buttonBackLabel") } = ar, { buttonNext: Hr = getContext("buttonNext") } = ar, { buttonNextType: Fr = getContext("buttonNextType") } = ar, { buttonNextLabel: zr = getContext("buttonNextLabel") } = ar, { buttonComplete: Ur = getContext("buttonComplete") } = ar, { buttonCompleteType: jr = getContext("buttonCompleteType") } = ar, { buttonCompleteLabel: Yr = getContext("buttonCompleteLabel") } = ar, { transitions: qr = getContext("transitions") } = ar, { transitionIn: Wr = getContext("transitionIn") } = ar, { transitionInParams: Jr = getContext("transitionInParams") } = ar, { transitionOut: Gr = getContext("transitionOut") } = ar, { transitionOutParams: Vr = getContext("transitionOutParams") } = ar;
  const Qr = mr.total;
  set_store_value(Sr, mr.total++, mr);
  async function $r() {
    await new Promise((Zr) => setTimeout(Zr)), !Ar && (set_store_value(Sr, mr.current++, mr), Lr("next", { step: Qr, state: mr }), Lr("step", { step: Qr, state: mr }));
  }
  function Xr() {
    set_store_value(Sr, mr.current--, mr), Lr("back", { step: Qr, state: mr }), Lr("step", { step: Qr, state: mr });
  }
  function si() {
    Lr("complete", { step: Qr, state: mr });
  }
  return onDestroy(() => {
    set_store_value(Sr, mr.total--, mr);
  }), cr.$$set = (Zr) => {
    lr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Zr))), "locked" in Zr && lr(0, Ar = Zr.locked), "regionHeader" in Zr && lr(27, Er = Zr.regionHeader), "regionContent" in Zr && lr(28, Cr = Zr.regionContent), "regionNavigation" in Zr && lr(29, Tr = Zr.regionNavigation), "state" in Zr && yr(lr(1, Sr = Zr.state)), "dispatchParent" in Zr && lr(30, Lr = Zr.dispatchParent), "stepTerm" in Zr && lr(2, Ir = Zr.stepTerm), "gap" in Zr && lr(31, Nr = Zr.gap), "justify" in Zr && lr(32, Rr = Zr.justify), "buttonBack" in Zr && lr(3, Mr = Zr.buttonBack), "buttonBackType" in Zr && lr(4, Br = Zr.buttonBackType), "buttonBackLabel" in Zr && lr(5, Dr = Zr.buttonBackLabel), "buttonNext" in Zr && lr(6, Hr = Zr.buttonNext), "buttonNextType" in Zr && lr(7, Fr = Zr.buttonNextType), "buttonNextLabel" in Zr && lr(8, zr = Zr.buttonNextLabel), "buttonComplete" in Zr && lr(9, Ur = Zr.buttonComplete), "buttonCompleteType" in Zr && lr(10, jr = Zr.buttonCompleteType), "buttonCompleteLabel" in Zr && lr(11, Yr = Zr.buttonCompleteLabel), "transitions" in Zr && lr(12, qr = Zr.transitions), "transitionIn" in Zr && lr(13, Wr = Zr.transitionIn), "transitionInParams" in Zr && lr(14, Jr = Zr.transitionInParams), "transitionOut" in Zr && lr(15, Gr = Zr.transitionOut), "transitionOutParams" in Zr && lr(16, Vr = Zr.transitionOutParams), "$$scope" in Zr && lr(33, kr = Zr.$$scope);
  }, cr.$$.update = () => {
    var Zr;
    lr(20, ur = `${cBase$6} ${(Zr = ar.class) != null ? Zr : ""}`), cr.$$.dirty[0] & /*regionHeader*/
    134217728 && lr(19, dr = `${cHeader$1} ${Er}`), cr.$$.dirty[0] & /*regionContent*/
    268435456 && lr(18, fr = `${cContent} ${Cr}`), cr.$$.dirty[0] & /*regionNavigation*/
    536870912 | cr.$$.dirty[1] & /*justify, gap*/
    3 && lr(17, gr = `${cNavigation} ${Rr} ${Nr} ${Tr}`);
  }, ar = exclude_internal_props(ar), [
    Ar,
    Sr,
    Ir,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    gr,
    fr,
    dr,
    ur,
    mr,
    Qr,
    $r,
    Xr,
    si,
    xr,
    Er,
    Cr,
    Tr,
    Lr,
    Nr,
    Rr,
    kr,
    _r
  ];
}
let Step$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$n,
      create_fragment$I,
      safe_not_equal,
      {
        locked: 0,
        regionHeader: 27,
        regionContent: 28,
        regionNavigation: 29,
        state: 1,
        dispatchParent: 30,
        stepTerm: 2,
        gap: 31,
        justify: 32,
        buttonBack: 3,
        buttonBackType: 4,
        buttonBackLabel: 5,
        buttonNext: 6,
        buttonNextType: 7,
        buttonNextLabel: 8,
        buttonComplete: 9,
        buttonCompleteType: 10,
        buttonCompleteLabel: 11,
        transitions: 12,
        transitionIn: 13,
        transitionInParams: 14,
        transitionOut: 15,
        transitionOutParams: 16
      },
      null,
      [-1, -1]
    );
  }
  get locked() {
    return this.$$.ctx[0];
  }
  set locked(ar) {
    this.$$set({ locked: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[27];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionContent() {
    return this.$$.ctx[28];
  }
  set regionContent(ar) {
    this.$$set({ regionContent: ar }), flush();
  }
  get regionNavigation() {
    return this.$$.ctx[29];
  }
  set regionNavigation(ar) {
    this.$$set({ regionNavigation: ar }), flush();
  }
  get state() {
    return this.$$.ctx[1];
  }
  set state(ar) {
    this.$$set({ state: ar }), flush();
  }
  get dispatchParent() {
    return this.$$.ctx[30];
  }
  set dispatchParent(ar) {
    this.$$set({ dispatchParent: ar }), flush();
  }
  get stepTerm() {
    return this.$$.ctx[2];
  }
  set stepTerm(ar) {
    this.$$set({ stepTerm: ar }), flush();
  }
  get gap() {
    return this.$$.ctx[31];
  }
  set gap(ar) {
    this.$$set({ gap: ar }), flush();
  }
  get justify() {
    return this.$$.ctx[32];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get buttonBack() {
    return this.$$.ctx[3];
  }
  set buttonBack(ar) {
    this.$$set({ buttonBack: ar }), flush();
  }
  get buttonBackType() {
    return this.$$.ctx[4];
  }
  set buttonBackType(ar) {
    this.$$set({ buttonBackType: ar }), flush();
  }
  get buttonBackLabel() {
    return this.$$.ctx[5];
  }
  set buttonBackLabel(ar) {
    this.$$set({ buttonBackLabel: ar }), flush();
  }
  get buttonNext() {
    return this.$$.ctx[6];
  }
  set buttonNext(ar) {
    this.$$set({ buttonNext: ar }), flush();
  }
  get buttonNextType() {
    return this.$$.ctx[7];
  }
  set buttonNextType(ar) {
    this.$$set({ buttonNextType: ar }), flush();
  }
  get buttonNextLabel() {
    return this.$$.ctx[8];
  }
  set buttonNextLabel(ar) {
    this.$$set({ buttonNextLabel: ar }), flush();
  }
  get buttonComplete() {
    return this.$$.ctx[9];
  }
  set buttonComplete(ar) {
    this.$$set({ buttonComplete: ar }), flush();
  }
  get buttonCompleteType() {
    return this.$$.ctx[10];
  }
  set buttonCompleteType(ar) {
    this.$$set({ buttonCompleteType: ar }), flush();
  }
  get buttonCompleteLabel() {
    return this.$$.ctx[11];
  }
  set buttonCompleteLabel(ar) {
    this.$$set({ buttonCompleteLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[12];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[13];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[14];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[15];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[16];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
};
create_custom_element(Step$1, { locked: { type: "Boolean" }, regionHeader: {}, regionContent: {}, regionNavigation: {}, state: {}, dispatchParent: {}, stepTerm: {}, gap: {}, justify: {}, buttonBack: {}, buttonBackType: {}, buttonBackLabel: {}, buttonNext: {}, buttonNextType: {}, buttonNextLabel: {}, buttonComplete: {}, buttonCompleteType: {}, buttonCompleteLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, ["header", "default", "navigation"], [], !0);
function tableA11y(cr) {
  const ar = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"], lr = (ur) => {
    if (ar.includes(ur.code))
      switch (ur.preventDefault(), ur.code) {
        case "ArrowUp":
          a11ySetActiveCell(cr, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(cr, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(cr, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(cr, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(cr, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(cr, "last");
          break;
      }
  };
  return cr.addEventListener("keydown", lr), {
    destroy() {
      cr.removeEventListener("keydown", lr);
    }
  };
}
function a11ySetActiveCell(cr, ar, lr) {
  const ur = document.activeElement;
  if (!ur || !ur.parentElement || !ur.parentElement.ariaRowIndex || !ur.ariaColIndex)
    return;
  const dr = parseInt(ur.parentElement.ariaRowIndex), fr = parseInt(ur.ariaColIndex), gr = cr.querySelector(`[aria-rowindex="${dr + lr}"]`);
  if (gr !== null) {
    const mr = gr.querySelector(`[aria-colindex="${fr + ar}"]`);
    mr !== null && mr.focus();
  }
}
function a11yGetTargetElem(cr) {
  const ar = document.activeElement;
  if (!ar || !ar.parentElement || !ar.parentElement.ariaRowIndex)
    return null;
  const lr = parseInt(ar.parentElement.ariaRowIndex);
  return cr.querySelector(`[aria-rowindex="${lr}"]`);
}
function a11yJumpToOuterColumn(cr, ar = "first") {
  const lr = a11yGetTargetElem(cr);
  if (lr === null)
    return;
  const ur = lr.children.length, dr = ar === "first" ? 1 : ur, fr = lr.querySelector(`[aria-colindex="${dr}"]`);
  fr !== null && fr.focus();
}
function get_each_context$5(cr, ar, lr) {
  const ur = cr.slice();
  return ur[19] = ar[lr], ur;
}
function get_each_context_1$2(cr, ar, lr) {
  const ur = cr.slice();
  return ur[22] = ar[lr], ur[24] = lr, ur;
}
function get_each_context_2(cr, ar, lr) {
  const ur = cr.slice();
  return ur[19] = ar[lr], ur[26] = lr, ur;
}
function get_each_context_3(cr, ar, lr) {
  const ur = cr.slice();
  return ur[27] = ar[lr], ur;
}
function create_each_block_3(cr) {
  let ar, lr = (
    /*heading*/
    cr[27] + ""
  );
  return {
    c() {
      ar = element("th"), attr(
        ar,
        "class",
        /*regionHeadCell*/
        cr[3]
      ), attr(ar, "role", "columnheader");
    },
    m(ur, dr) {
      insert(ur, ar, dr), ar.innerHTML = lr;
    },
    p(ur, dr) {
      dr & /*source*/
      1 && lr !== (lr = /*heading*/
      ur[27] + "") && (ar.innerHTML = lr), dr & /*regionHeadCell*/
      8 && attr(
        ar,
        "class",
        /*regionHeadCell*/
        ur[3]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_each_block_2(cr) {
  let ar, lr = (Number(
    /*cell*/
    cr[19]
  ) === 0 || /*cell*/
  cr[19] ? (
    /*cell*/
    cr[19]
  ) : "-") + "", ur;
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionCell*/
        cr[5]
      ), attr(ar, "role", "gridcell"), attr(
        ar,
        "aria-colindex",
        /*cellIndex*/
        cr[26] + 1
      ), attr(ar, "tabindex", ur = /*cellIndex*/
      cr[26] === 0 && /*interactive*/
      cr[1] ? 0 : -1);
    },
    m(dr, fr) {
      insert(dr, ar, fr), ar.innerHTML = lr;
    },
    p(dr, fr) {
      fr & /*source*/
      1 && lr !== (lr = (Number(
        /*cell*/
        dr[19]
      ) === 0 || /*cell*/
      dr[19] ? (
        /*cell*/
        dr[19]
      ) : "-") + "") && (ar.innerHTML = lr), fr & /*regionCell*/
      32 && attr(
        ar,
        "class",
        /*regionCell*/
        dr[5]
      ), fr & /*interactive*/
      2 && ur !== (ur = /*cellIndex*/
      dr[26] === 0 && /*interactive*/
      dr[1] ? 0 : -1) && attr(ar, "tabindex", ur);
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_each_block_1$2(cr) {
  let ar, lr, ur, dr, fr = ensure_array_like(
    /*row*/
    cr[22]
  ), gr = [];
  for (let yr = 0; yr < fr.length; yr += 1)
    gr[yr] = create_each_block_2(get_each_context_2(cr, fr, yr));
  function mr(...yr) {
    return (
      /*click_handler*/
      cr[15](
        /*rowIndex*/
        cr[24],
        ...yr
      )
    );
  }
  function vr(...yr) {
    return (
      /*keydown_handler*/
      cr[16](
        /*rowIndex*/
        cr[24],
        ...yr
      )
    );
  }
  return {
    c() {
      ar = element("tr");
      for (let yr = 0; yr < gr.length; yr += 1)
        gr[yr].c();
      lr = space(), attr(
        ar,
        "aria-rowindex",
        /*rowIndex*/
        cr[24] + 1
      );
    },
    m(yr, _r) {
      insert(yr, ar, _r);
      for (let kr = 0; kr < gr.length; kr += 1)
        gr[kr] && gr[kr].m(ar, null);
      append(ar, lr), ur || (dr = [
        listen(ar, "click", mr),
        listen(ar, "keydown", vr)
      ], ur = !0);
    },
    p(yr, _r) {
      if (cr = yr, _r & /*regionCell, interactive, Number, source*/
      35) {
        fr = ensure_array_like(
          /*row*/
          cr[22]
        );
        let kr;
        for (kr = 0; kr < fr.length; kr += 1) {
          const xr = get_each_context_2(cr, fr, kr);
          gr[kr] ? gr[kr].p(xr, _r) : (gr[kr] = create_each_block_2(xr), gr[kr].c(), gr[kr].m(ar, lr));
        }
        for (; kr < gr.length; kr += 1)
          gr[kr].d(1);
        gr.length = fr.length;
      }
    },
    d(yr) {
      yr && detach(ar), destroy_each(gr, yr), ur = !1, run_all(dr);
    }
  };
}
function create_if_block$g(cr) {
  let ar, lr, ur, dr = ensure_array_like(
    /*source*/
    cr[0].foot
  ), fr = [];
  for (let gr = 0; gr < dr.length; gr += 1)
    fr[gr] = create_each_block$5(get_each_context$5(cr, dr, gr));
  return {
    c() {
      ar = element("tfoot"), lr = element("tr");
      for (let gr = 0; gr < fr.length; gr += 1)
        fr[gr].c();
      attr(ar, "class", ur = "table-foot " + /*regionFoot*/
      cr[6]);
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, lr);
      for (let vr = 0; vr < fr.length; vr += 1)
        fr[vr] && fr[vr].m(lr, null);
    },
    p(gr, mr) {
      if (mr & /*regionFootCell, source*/
      129) {
        dr = ensure_array_like(
          /*source*/
          gr[0].foot
        );
        let vr;
        for (vr = 0; vr < dr.length; vr += 1) {
          const yr = get_each_context$5(gr, dr, vr);
          fr[vr] ? fr[vr].p(yr, mr) : (fr[vr] = create_each_block$5(yr), fr[vr].c(), fr[vr].m(lr, null));
        }
        for (; vr < fr.length; vr += 1)
          fr[vr].d(1);
        fr.length = dr.length;
      }
      mr & /*regionFoot*/
      64 && ur !== (ur = "table-foot " + /*regionFoot*/
      gr[6]) && attr(ar, "class", ur);
    },
    d(gr) {
      gr && detach(ar), destroy_each(fr, gr);
    }
  };
}
function create_each_block$5(cr) {
  let ar, lr = (
    /*cell*/
    cr[19] + ""
  );
  return {
    c() {
      ar = element("td"), attr(
        ar,
        "class",
        /*regionFootCell*/
        cr[7]
      );
    },
    m(ur, dr) {
      insert(ur, ar, dr), ar.innerHTML = lr;
    },
    p(ur, dr) {
      dr & /*source*/
      1 && lr !== (lr = /*cell*/
      ur[19] + "") && (ar.innerHTML = lr), dr & /*regionFootCell*/
      128 && attr(
        ar,
        "class",
        /*regionFootCell*/
        ur[7]
      );
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_fragment$H(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er = ensure_array_like(
    /*source*/
    cr[0].head
  ), Cr = [];
  for (let Ir = 0; Ir < Er.length; Ir += 1)
    Cr[Ir] = create_each_block_3(get_each_context_3(cr, Er, Ir));
  let Tr = ensure_array_like(
    /*source*/
    cr[0].body
  ), Sr = [];
  for (let Ir = 0; Ir < Tr.length; Ir += 1)
    Sr[Ir] = create_each_block_1$2(get_each_context_1$2(cr, Tr, Ir));
  let Lr = (
    /*source*/
    cr[0].foot && create_if_block$g(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("table"), ur = element("thead"), dr = element("tr");
      for (let Ir = 0; Ir < Cr.length; Ir += 1)
        Cr[Ir].c();
      gr = space(), mr = element("tbody");
      for (let Ir = 0; Ir < Sr.length; Ir += 1)
        Sr[Ir].c();
      yr = space(), Lr && Lr.c(), attr(ur, "class", fr = "table-head " + /*regionHead*/
      cr[2]), attr(mr, "class", vr = "table-body " + /*regionBody*/
      cr[4]), attr(
        lr,
        "class",
        /*classesTable*/
        cr[8]
      ), attr(lr, "role", _r = /*interactive*/
      cr[1] ? "grid" : "table"), toggle_class(
        lr,
        "table-interactive",
        /*interactive*/
        cr[1]
      ), attr(ar, "class", kr = "table-container " + /*classesBase*/
      cr[9]);
    },
    m(Ir, Nr) {
      insert(Ir, ar, Nr), append(ar, lr), append(lr, ur), append(ur, dr);
      for (let Rr = 0; Rr < Cr.length; Rr += 1)
        Cr[Rr] && Cr[Rr].m(dr, null);
      append(lr, gr), append(lr, mr);
      for (let Rr = 0; Rr < Sr.length; Rr += 1)
        Sr[Rr] && Sr[Rr].m(mr, null);
      append(lr, yr), Lr && Lr.m(lr, null), xr || (Ar = action_destroyer(tableA11y.call(null, lr)), xr = !0);
    },
    p(Ir, [Nr]) {
      if (Nr & /*regionHeadCell, source*/
      9) {
        Er = ensure_array_like(
          /*source*/
          Ir[0].head
        );
        let Rr;
        for (Rr = 0; Rr < Er.length; Rr += 1) {
          const Mr = get_each_context_3(Ir, Er, Rr);
          Cr[Rr] ? Cr[Rr].p(Mr, Nr) : (Cr[Rr] = create_each_block_3(Mr), Cr[Rr].c(), Cr[Rr].m(dr, null));
        }
        for (; Rr < Cr.length; Rr += 1)
          Cr[Rr].d(1);
        Cr.length = Er.length;
      }
      if (Nr & /*regionHead*/
      4 && fr !== (fr = "table-head " + /*regionHead*/
      Ir[2]) && attr(ur, "class", fr), Nr & /*onRowClick, onRowKeydown, source, regionCell, interactive, Number*/
      3107) {
        Tr = ensure_array_like(
          /*source*/
          Ir[0].body
        );
        let Rr;
        for (Rr = 0; Rr < Tr.length; Rr += 1) {
          const Mr = get_each_context_1$2(Ir, Tr, Rr);
          Sr[Rr] ? Sr[Rr].p(Mr, Nr) : (Sr[Rr] = create_each_block_1$2(Mr), Sr[Rr].c(), Sr[Rr].m(mr, null));
        }
        for (; Rr < Sr.length; Rr += 1)
          Sr[Rr].d(1);
        Sr.length = Tr.length;
      }
      Nr & /*regionBody*/
      16 && vr !== (vr = "table-body " + /*regionBody*/
      Ir[4]) && attr(mr, "class", vr), /*source*/
      Ir[0].foot ? Lr ? Lr.p(Ir, Nr) : (Lr = create_if_block$g(Ir), Lr.c(), Lr.m(lr, null)) : Lr && (Lr.d(1), Lr = null), Nr & /*classesTable*/
      256 && attr(
        lr,
        "class",
        /*classesTable*/
        Ir[8]
      ), Nr & /*interactive*/
      2 && _r !== (_r = /*interactive*/
      Ir[1] ? "grid" : "table") && attr(lr, "role", _r), Nr & /*classesTable, interactive*/
      258 && toggle_class(
        lr,
        "table-interactive",
        /*interactive*/
        Ir[1]
      ), Nr & /*classesBase*/
      512 && kr !== (kr = "table-container " + /*classesBase*/
      Ir[9]) && attr(ar, "class", kr);
    },
    i: noop$1,
    o: noop$1,
    d(Ir) {
      Ir && detach(ar), destroy_each(Cr, Ir), destroy_each(Sr, Ir), Lr && Lr.d(), xr = !1, Ar();
    }
  };
}
function instance$m(cr, ar, lr) {
  let ur, dr;
  const fr = createEventDispatcher();
  let { source: gr } = ar, { interactive: mr = !1 } = ar, { element: vr = "table" } = ar, { text: yr = "" } = ar, { color: _r = "" } = ar, { regionHead: kr = "" } = ar, { regionHeadCell: xr = "" } = ar, { regionBody: Ar = "" } = ar, { regionCell: Er = "" } = ar, { regionFoot: Cr = "" } = ar, { regionFootCell: Tr = "" } = ar;
  function Sr(Rr, Mr) {
    if (!mr)
      return;
    Rr.preventDefault(), Rr.stopPropagation();
    const Br = gr.meta ? gr.meta[Mr] : gr.body[Mr];
    fr("selected", Br);
  }
  function Lr(Rr, Mr) {
    ["Enter", "Space"].includes(Rr.code) && Sr(Rr, Mr);
  }
  const Ir = (Rr, Mr) => {
    Sr(Mr, Rr);
  }, Nr = (Rr, Mr) => {
    Lr(Mr, Rr);
  };
  return cr.$$set = (Rr) => {
    lr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Rr))), "source" in Rr && lr(0, gr = Rr.source), "interactive" in Rr && lr(1, mr = Rr.interactive), "element" in Rr && lr(12, vr = Rr.element), "text" in Rr && lr(13, yr = Rr.text), "color" in Rr && lr(14, _r = Rr.color), "regionHead" in Rr && lr(2, kr = Rr.regionHead), "regionHeadCell" in Rr && lr(3, xr = Rr.regionHeadCell), "regionBody" in Rr && lr(4, Ar = Rr.regionBody), "regionCell" in Rr && lr(5, Er = Rr.regionCell), "regionFoot" in Rr && lr(6, Cr = Rr.regionFoot), "regionFootCell" in Rr && lr(7, Tr = Rr.regionFootCell);
  }, cr.$$.update = () => {
    lr(9, ur = `${ar.class || ""}`), cr.$$.dirty & /*element, text, color*/
    28672 && lr(8, dr = `${vr} ${yr} ${_r}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    dr,
    ur,
    Sr,
    Lr,
    vr,
    yr,
    _r,
    Ir,
    Nr
  ];
}
let Table$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$m, create_fragment$H, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 12,
      text: 13,
      color: 14,
      regionHead: 2,
      regionHeadCell: 3,
      regionBody: 4,
      regionCell: 5,
      regionFoot: 6,
      regionFootCell: 7
    });
  }
  get source() {
    return this.$$.ctx[0];
  }
  set source(ar) {
    this.$$set({ source: ar }), flush();
  }
  get interactive() {
    return this.$$.ctx[1];
  }
  set interactive(ar) {
    this.$$set({ interactive: ar }), flush();
  }
  get element() {
    return this.$$.ctx[12];
  }
  set element(ar) {
    this.$$set({ element: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get regionHead() {
    return this.$$.ctx[2];
  }
  set regionHead(ar) {
    this.$$set({ regionHead: ar }), flush();
  }
  get regionHeadCell() {
    return this.$$.ctx[3];
  }
  set regionHeadCell(ar) {
    this.$$set({ regionHeadCell: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[4];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionCell() {
    return this.$$.ctx[5];
  }
  set regionCell(ar) {
    this.$$set({ regionCell: ar }), flush();
  }
  get regionFoot() {
    return this.$$.ctx[6];
  }
  set regionFoot(ar) {
    this.$$set({ regionFoot: ar }), flush();
  }
  get regionFootCell() {
    return this.$$.ctx[7];
  }
  set regionFootCell(ar) {
    this.$$set({ regionFootCell: ar }), flush();
  }
};
create_custom_element(Table$2, { source: {}, interactive: { type: "Boolean" }, element: {}, text: {}, color: {}, regionHead: {}, regionHeadCell: {}, regionBody: {}, regionCell: {}, regionFoot: {}, regionFootCell: {} }, [], [], !0);
const get_panel_slot_changes = (cr) => ({}), get_panel_slot_context = (cr) => ({});
function create_if_block$f(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[17].panel
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[16],
    get_panel_slot_context
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "tab-panel " + /*classesPanel*/
      cr[2]), attr(ar, "role", "tabpanel"), attr(
        ar,
        "aria-labelledby",
        /*panel*/
        cr[1]
      ), attr(ar, "tabindex", "0");
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), ur = !0;
    },
    p(gr, mr) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      65536) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[16],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[16],
          mr,
          get_panel_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[16]
        ),
        get_panel_slot_context
      ), (!ur || mr & /*classesPanel*/
      4 && lr !== (lr = "tab-panel " + /*classesPanel*/
      gr[2])) && attr(ar, "class", lr), (!ur || mr & /*panel*/
      2) && attr(
        ar,
        "aria-labelledby",
        /*panel*/
        gr[1]
      );
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr);
    }
  };
}
function create_fragment$G(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  const yr = (
    /*#slots*/
    cr[17].default
  ), _r = create_slot(
    yr,
    cr,
    /*$$scope*/
    cr[16],
    null
  );
  let kr = (
    /*$$slots*/
    cr[5].panel && create_if_block$f(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("div"), _r && _r.c(), dr = space(), kr && kr.c(), attr(lr, "class", ur = "tab-list " + /*classesList*/
      cr[3]), attr(lr, "role", "tablist"), attr(
        lr,
        "aria-labelledby",
        /*labelledby*/
        cr[0]
      ), attr(ar, "class", fr = "tab-group " + /*classesBase*/
      cr[4]), attr(ar, "data-testid", "tab-group");
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), append(ar, lr), _r && _r.m(lr, null), append(ar, dr), kr && kr.m(ar, null), gr = !0, mr || (vr = [
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[19]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          cr[20]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          cr[21]
        )
      ], mr = !0);
    },
    p(xr, [Ar]) {
      _r && _r.p && (!gr || Ar & /*$$scope*/
      65536) && update_slot_base(
        _r,
        yr,
        xr,
        /*$$scope*/
        xr[16],
        gr ? get_slot_changes(
          yr,
          /*$$scope*/
          xr[16],
          Ar,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          xr[16]
        ),
        null
      ), (!gr || Ar & /*classesList*/
      8 && ur !== (ur = "tab-list " + /*classesList*/
      xr[3])) && attr(lr, "class", ur), (!gr || Ar & /*labelledby*/
      1) && attr(
        lr,
        "aria-labelledby",
        /*labelledby*/
        xr[0]
      ), /*$$slots*/
      xr[5].panel ? kr ? (kr.p(xr, Ar), Ar & /*$$slots*/
      32 && transition_in(kr, 1)) : (kr = create_if_block$f(xr), kr.c(), transition_in(kr, 1), kr.m(ar, null)) : kr && (group_outros(), transition_out(kr, 1, 1, () => {
        kr = null;
      }), check_outros()), (!gr || Ar & /*classesBase*/
      16 && fr !== (fr = "tab-group " + /*classesBase*/
      xr[4])) && attr(ar, "class", fr);
    },
    i(xr) {
      gr || (transition_in(_r, xr), transition_in(kr), gr = !0);
    },
    o(xr) {
      transition_out(_r, xr), transition_out(kr), gr = !1;
    },
    d(xr) {
      xr && detach(ar), _r && _r.d(xr), kr && kr.d(), mr = !1, run_all(vr);
    }
  };
}
const cBase$5 = "space-y-4", cList$1 = "flex overflow-x-auto hide-scrollbar", cPanel = "";
function instance$l(cr, ar, lr) {
  let ur, dr, fr, { $$slots: gr = {}, $$scope: mr } = ar;
  const vr = compute_slots(gr);
  let { justify: yr = "justify-start" } = ar, { border: _r = "border-b border-surface-400-500-token" } = ar, { active: kr = "border-b-2 border-surface-900-50-token" } = ar, { hover: xr = "hover:variant-soft" } = ar, { flex: Ar = "flex-none" } = ar, { padding: Er = "px-4 py-2" } = ar, { rounded: Cr = "rounded-tl-container-token rounded-tr-container-token" } = ar, { spacing: Tr = "space-y-1" } = ar, { regionList: Sr = "" } = ar, { regionPanel: Lr = "" } = ar, { labelledby: Ir = "" } = ar, { panel: Nr = "" } = ar;
  setContext("active", kr), setContext("hover", xr), setContext("flex", Ar), setContext("padding", Er), setContext("rounded", Cr), setContext("spacing", Tr);
  function Rr(Hr) {
    bubble.call(this, cr, Hr);
  }
  function Mr(Hr) {
    bubble.call(this, cr, Hr);
  }
  function Br(Hr) {
    bubble.call(this, cr, Hr);
  }
  function Dr(Hr) {
    bubble.call(this, cr, Hr);
  }
  return cr.$$set = (Hr) => {
    lr(22, ar = assign$1(assign$1({}, ar), exclude_internal_props(Hr))), "justify" in Hr && lr(6, yr = Hr.justify), "border" in Hr && lr(7, _r = Hr.border), "active" in Hr && lr(8, kr = Hr.active), "hover" in Hr && lr(9, xr = Hr.hover), "flex" in Hr && lr(10, Ar = Hr.flex), "padding" in Hr && lr(11, Er = Hr.padding), "rounded" in Hr && lr(12, Cr = Hr.rounded), "spacing" in Hr && lr(13, Tr = Hr.spacing), "regionList" in Hr && lr(14, Sr = Hr.regionList), "regionPanel" in Hr && lr(15, Lr = Hr.regionPanel), "labelledby" in Hr && lr(0, Ir = Hr.labelledby), "panel" in Hr && lr(1, Nr = Hr.panel), "$$scope" in Hr && lr(16, mr = Hr.$$scope);
  }, cr.$$.update = () => {
    var Hr;
    lr(4, ur = `${cBase$5} ${(Hr = ar.class) != null ? Hr : ""}`), cr.$$.dirty & /*justify, border, regionList*/
    16576 && lr(3, dr = `${cList$1} ${yr} ${_r} ${Sr}`), cr.$$.dirty & /*regionPanel*/
    32768 && lr(2, fr = `${cPanel} ${Lr}`);
  }, ar = exclude_internal_props(ar), [
    Ir,
    Nr,
    fr,
    dr,
    ur,
    vr,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    mr,
    gr,
    Rr,
    Mr,
    Br,
    Dr
  ];
}
class TabGroup extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$l, create_fragment$G, safe_not_equal, {
      justify: 6,
      border: 7,
      active: 8,
      hover: 9,
      flex: 10,
      padding: 11,
      rounded: 12,
      spacing: 13,
      regionList: 14,
      regionPanel: 15,
      labelledby: 0,
      panel: 1
    });
  }
  get justify() {
    return this.$$.ctx[6];
  }
  set justify(ar) {
    this.$$set({ justify: ar }), flush();
  }
  get border() {
    return this.$$.ctx[7];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get active() {
    return this.$$.ctx[8];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[9];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[10];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[11];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[13];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[14];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionPanel() {
    return this.$$.ctx[15];
  }
  set regionPanel(ar) {
    this.$$set({ regionPanel: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get panel() {
    return this.$$.ctx[1];
  }
  set panel(ar) {
    this.$$set({ panel: ar }), flush();
  }
}
create_custom_element(TabGroup, { justify: {}, border: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {}, regionList: {}, regionPanel: {}, labelledby: {}, panel: {} }, ["default", "panel"], [], !0);
const get_lead_slot_changes$2 = (cr) => ({}), get_lead_slot_context$2 = (cr) => ({});
function create_if_block$e(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[22].lead
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[21],
    get_lead_slot_context$2
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "tab-lead");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr[0] & /*$$scope*/
      2097152) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[21],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[21],
          gr,
          get_lead_slot_changes$2
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[21]
        ),
        get_lead_slot_context$2
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_fragment$F(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr = [
    { type: "radio" },
    { name: (
      /*name*/
      cr[1]
    ) },
    { __value: (
      /*value*/
      cr[2]
    ) },
    /*prunedRestProps*/
    cr[11](),
    { tabindex: "-1" }
  ], Sr = {};
  for (let Rr = 0; Rr < Tr.length; Rr += 1)
    Sr = assign$1(Sr, Tr[Rr]);
  let Lr = (
    /*$$slots*/
    cr[12].lead && create_if_block$e(cr)
  );
  const Ir = (
    /*#slots*/
    cr[22].default
  ), Nr = create_slot(
    Ir,
    cr,
    /*$$scope*/
    cr[21],
    null
  );
  return Ar = init_binding_group(
    /*$$binding_groups*/
    cr[30][0]
  ), {
    c() {
      ar = element("label"), lr = element("div"), ur = element("div"), dr = element("input"), fr = space(), gr = element("div"), Lr && Lr.c(), mr = space(), vr = element("div"), Nr && Nr.c(), set_attributes(dr, Sr), attr(ur, "class", "h-0 w-0 overflow-hidden"), attr(vr, "class", "tab-label"), attr(gr, "class", yr = "tab-interface " + /*classesInterface*/
      cr[8]), attr(lr, "class", _r = "tab " + /*classesTab*/
      cr[7]), attr(lr, "data-testid", "tab"), attr(lr, "role", "tab"), attr(
        lr,
        "aria-controls",
        /*controls*/
        cr[4]
      ), attr(
        lr,
        "aria-selected",
        /*selected*/
        cr[5]
      ), attr(lr, "tabindex", kr = /*selected*/
      cr[5] ? 0 : -1), attr(
        ar,
        "class",
        /*classesBase*/
        cr[9]
      ), attr(
        ar,
        "title",
        /*title*/
        cr[3]
      ), Ar.p(dr);
    },
    m(Rr, Mr) {
      insert(Rr, ar, Mr), append(ar, lr), append(lr, ur), append(ur, dr), dr.autofocus && dr.focus(), cr[28](dr), dr.checked = dr.__value === /*group*/
      cr[0], append(lr, fr), append(lr, gr), Lr && Lr.m(gr, null), append(gr, mr), append(gr, vr), Nr && Nr.m(vr, null), xr = !0, Er || (Cr = [
        listen(
          dr,
          "change",
          /*input_change_handler*/
          cr[29]
        ),
        listen(
          dr,
          "click",
          /*click_handler*/
          cr[26]
        ),
        listen(
          dr,
          "change",
          /*change_handler*/
          cr[27]
        ),
        listen(
          lr,
          "keydown",
          /*onKeyDown*/
          cr[10]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[23]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[24]
        ),
        listen(
          lr,
          "keypress",
          /*keypress_handler*/
          cr[25]
        )
      ], Er = !0);
    },
    p(Rr, Mr) {
      set_attributes(dr, Sr = get_spread_update(Tr, [
        { type: "radio" },
        (!xr || Mr[0] & /*name*/
        2) && { name: (
          /*name*/
          Rr[1]
        ) },
        (!xr || Mr[0] & /*value*/
        4) && { __value: (
          /*value*/
          Rr[2]
        ) },
        /*prunedRestProps*/
        Rr[11](),
        { tabindex: "-1" }
      ])), Mr[0] & /*group*/
      1 && (dr.checked = dr.__value === /*group*/
      Rr[0]), /*$$slots*/
      Rr[12].lead ? Lr ? (Lr.p(Rr, Mr), Mr[0] & /*$$slots*/
      4096 && transition_in(Lr, 1)) : (Lr = create_if_block$e(Rr), Lr.c(), transition_in(Lr, 1), Lr.m(gr, mr)) : Lr && (group_outros(), transition_out(Lr, 1, 1, () => {
        Lr = null;
      }), check_outros()), Nr && Nr.p && (!xr || Mr[0] & /*$$scope*/
      2097152) && update_slot_base(
        Nr,
        Ir,
        Rr,
        /*$$scope*/
        Rr[21],
        xr ? get_slot_changes(
          Ir,
          /*$$scope*/
          Rr[21],
          Mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Rr[21]
        ),
        null
      ), (!xr || Mr[0] & /*classesInterface*/
      256 && yr !== (yr = "tab-interface " + /*classesInterface*/
      Rr[8])) && attr(gr, "class", yr), (!xr || Mr[0] & /*classesTab*/
      128 && _r !== (_r = "tab " + /*classesTab*/
      Rr[7])) && attr(lr, "class", _r), (!xr || Mr[0] & /*controls*/
      16) && attr(
        lr,
        "aria-controls",
        /*controls*/
        Rr[4]
      ), (!xr || Mr[0] & /*selected*/
      32) && attr(
        lr,
        "aria-selected",
        /*selected*/
        Rr[5]
      ), (!xr || Mr[0] & /*selected*/
      32 && kr !== (kr = /*selected*/
      Rr[5] ? 0 : -1)) && attr(lr, "tabindex", kr), (!xr || Mr[0] & /*classesBase*/
      512) && attr(
        ar,
        "class",
        /*classesBase*/
        Rr[9]
      ), (!xr || Mr[0] & /*title*/
      8) && attr(
        ar,
        "title",
        /*title*/
        Rr[3]
      );
    },
    i(Rr) {
      xr || (transition_in(Lr), transition_in(Nr, Rr), xr = !0);
    },
    o(Rr) {
      transition_out(Lr), transition_out(Nr, Rr), xr = !1;
    },
    d(Rr) {
      Rr && detach(ar), cr[28](null), Lr && Lr.d(), Nr && Nr.d(Rr), Ar.r(), Er = !1, run_all(Cr);
    }
  };
}
const cBase$4 = "text-center cursor-pointer transition-colors duration-100", cInterface$1 = "";
function instance$k(cr, ar, lr) {
  let ur, dr, fr, gr, mr;
  const vr = [
    "group",
    "name",
    "value",
    "title",
    "controls",
    "regionTab",
    "active",
    "hover",
    "flex",
    "padding",
    "rounded",
    "spacing"
  ];
  let yr = compute_rest_props(ar, vr), { $$slots: _r = {}, $$scope: kr } = ar;
  const xr = compute_slots(_r);
  let { group: Ar } = ar, { name: Er } = ar, { value: Cr } = ar, { title: Tr = "" } = ar, { controls: Sr = "" } = ar, { regionTab: Lr = "" } = ar, { active: Ir = getContext("active") } = ar, { hover: Nr = getContext("hover") } = ar, { flex: Rr = getContext("flex") } = ar, { padding: Mr = getContext("padding") } = ar, { rounded: Br = getContext("rounded") } = ar, { spacing: Dr = getContext("spacing") } = ar, Hr;
  function Fr(Qr) {
    if (["Enter", "Space"].includes(Qr.code))
      Qr.preventDefault(), Hr.click();
    else if (Qr.code === "ArrowRight") {
      const $r = Hr.closest(".tab-list");
      if (!$r)
        return;
      const Xr = Array.from($r.querySelectorAll(".tab")), si = Hr.closest(".tab");
      if (!si)
        return;
      const Zr = Xr.indexOf(si), li = Zr + 1 >= Xr.length ? 0 : Zr + 1, Ei = Xr[li], ki = Ei == null ? void 0 : Ei.querySelector("input");
      Ei && ki && (ki.click(), Ei.focus());
    } else if (Qr.code === "ArrowLeft") {
      const $r = Hr.closest(".tab-list");
      if (!$r)
        return;
      const Xr = Array.from($r.querySelectorAll(".tab")), si = Hr.closest(".tab");
      if (!si)
        return;
      const Zr = Xr.indexOf(si), li = Zr - 1 < 0 ? Xr.length - 1 : Zr - 1, Ei = Xr[li], ki = Ei == null ? void 0 : Ei.querySelector("input");
      Ei && ki && (ki.click(), Ei.focus());
    }
  }
  function zr() {
    return delete yr.class, yr;
  }
  const Ur = [[]];
  function jr(Qr) {
    bubble.call(this, cr, Qr);
  }
  function Yr(Qr) {
    bubble.call(this, cr, Qr);
  }
  function qr(Qr) {
    bubble.call(this, cr, Qr);
  }
  function Wr(Qr) {
    bubble.call(this, cr, Qr);
  }
  function Jr(Qr) {
    bubble.call(this, cr, Qr);
  }
  function Gr(Qr) {
    binding_callbacks[Qr ? "unshift" : "push"](() => {
      Hr = Qr, lr(6, Hr);
    });
  }
  function Vr() {
    Ar = this.__value, lr(0, Ar);
  }
  return cr.$$set = (Qr) => {
    lr(32, ar = assign$1(assign$1({}, ar), exclude_internal_props(Qr))), lr(31, yr = compute_rest_props(ar, vr)), "group" in Qr && lr(0, Ar = Qr.group), "name" in Qr && lr(1, Er = Qr.name), "value" in Qr && lr(2, Cr = Qr.value), "title" in Qr && lr(3, Tr = Qr.title), "controls" in Qr && lr(4, Sr = Qr.controls), "regionTab" in Qr && lr(13, Lr = Qr.regionTab), "active" in Qr && lr(14, Ir = Qr.active), "hover" in Qr && lr(15, Nr = Qr.hover), "flex" in Qr && lr(16, Rr = Qr.flex), "padding" in Qr && lr(17, Mr = Qr.padding), "rounded" in Qr && lr(18, Br = Qr.rounded), "spacing" in Qr && lr(19, Dr = Qr.spacing), "$$scope" in Qr && lr(21, kr = Qr.$$scope);
  }, cr.$$.update = () => {
    var Qr;
    cr.$$.dirty[0] & /*value, group*/
    5 && lr(5, ur = Cr === Ar), cr.$$.dirty[0] & /*selected, active, hover*/
    49184 && lr(20, dr = ur ? Ir : Nr), lr(9, fr = `${cBase$4} ${Rr} ${Mr} ${Br} ${dr} ${(Qr = ar.class) != null ? Qr : ""}`), cr.$$.dirty[0] & /*spacing*/
    524288 && lr(8, gr = `${cInterface$1} ${Dr}`), cr.$$.dirty[0] & /*regionTab*/
    8192 && lr(7, mr = `${Lr}`);
  }, ar = exclude_internal_props(ar), [
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    ur,
    Hr,
    mr,
    gr,
    fr,
    Fr,
    zr,
    xr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    dr,
    kr,
    _r,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    Vr,
    Ur
  ];
}
let Tab$1 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$k,
      create_fragment$F,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        controls: 4,
        regionTab: 13,
        active: 14,
        hover: 15,
        flex: 16,
        padding: 17,
        rounded: 18,
        spacing: 19
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[1];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[4];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get regionTab() {
    return this.$$.ctx[13];
  }
  set regionTab(ar) {
    this.$$set({ regionTab: ar }), flush();
  }
  get active() {
    return this.$$.ctx[14];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[15];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[16];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[17];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[18];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[19];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
};
create_custom_element(Tab$1, { group: {}, name: {}, value: {}, title: {}, controls: {}, regionTab: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
const get_lead_slot_changes$1 = (cr) => ({}), get_lead_slot_context$1 = (cr) => ({});
function create_if_block$d(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[15].lead
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[14],
    get_lead_slot_context$1
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "tab-lead");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr & /*$$scope*/
      16384) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[14],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[14],
          gr,
          get_lead_slot_changes$1
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[14]
        ),
        get_lead_slot_context$1
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_fragment$E(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr = (
    /*$$slots*/
    cr[5].lead && create_if_block$d(cr)
  );
  const xr = (
    /*#slots*/
    cr[15].default
  ), Ar = create_slot(
    xr,
    cr,
    /*$$scope*/
    cr[14],
    null
  );
  let Er = [
    {
      class: gr = "tab-anchor " + /*classesBase*/
      cr[2]
    },
    {
      href: mr = /*$$props*/
      cr[4].href
    },
    /*prunedRestProps*/
    cr[3](),
    { "aria-controls": (
      /*controls*/
      cr[0]
    ) },
    { "data-testid": "tab-anchor" }
  ], Cr = {};
  for (let Tr = 0; Tr < Er.length; Tr += 1)
    Cr = assign$1(Cr, Er[Tr]);
  return {
    c() {
      ar = element("a"), lr = element("div"), kr && kr.c(), ur = space(), dr = element("div"), Ar && Ar.c(), attr(dr, "class", "tab-label"), attr(lr, "class", fr = "tab-interface " + /*classesInterface*/
      cr[1]), set_attributes(ar, Cr);
    },
    m(Tr, Sr) {
      insert(Tr, ar, Sr), append(ar, lr), kr && kr.m(lr, null), append(lr, ur), append(lr, dr), Ar && Ar.m(dr, null), vr = !0, yr || (_r = [
        listen(
          ar,
          "click",
          /*click_handler*/
          cr[16]
        ),
        listen(
          ar,
          "keydown",
          /*keydown_handler*/
          cr[17]
        ),
        listen(
          ar,
          "keyup",
          /*keyup_handler*/
          cr[18]
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[19]
        ),
        listen(
          ar,
          "mouseover",
          /*mouseover_handler*/
          cr[20]
        ),
        listen(
          ar,
          "mouseleave",
          /*mouseleave_handler*/
          cr[21]
        ),
        listen(
          ar,
          "focus",
          /*focus_handler*/
          cr[22]
        ),
        listen(
          ar,
          "blur",
          /*blur_handler*/
          cr[23]
        )
      ], yr = !0);
    },
    p(Tr, [Sr]) {
      /*$$slots*/
      Tr[5].lead ? kr ? (kr.p(Tr, Sr), Sr & /*$$slots*/
      32 && transition_in(kr, 1)) : (kr = create_if_block$d(Tr), kr.c(), transition_in(kr, 1), kr.m(lr, ur)) : kr && (group_outros(), transition_out(kr, 1, 1, () => {
        kr = null;
      }), check_outros()), Ar && Ar.p && (!vr || Sr & /*$$scope*/
      16384) && update_slot_base(
        Ar,
        xr,
        Tr,
        /*$$scope*/
        Tr[14],
        vr ? get_slot_changes(
          xr,
          /*$$scope*/
          Tr[14],
          Sr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Tr[14]
        ),
        null
      ), (!vr || Sr & /*classesInterface*/
      2 && fr !== (fr = "tab-interface " + /*classesInterface*/
      Tr[1])) && attr(lr, "class", fr), set_attributes(ar, Cr = get_spread_update(Er, [
        (!vr || Sr & /*classesBase*/
        4 && gr !== (gr = "tab-anchor " + /*classesBase*/
        Tr[2])) && { class: gr },
        (!vr || Sr & /*$$props*/
        16 && mr !== (mr = /*$$props*/
        Tr[4].href)) && { href: mr },
        /*prunedRestProps*/
        Tr[3](),
        (!vr || Sr & /*controls*/
        1) && { "aria-controls": (
          /*controls*/
          Tr[0]
        ) },
        { "data-testid": "tab-anchor" }
      ]));
    },
    i(Tr) {
      vr || (transition_in(kr), transition_in(Ar, Tr), vr = !0);
    },
    o(Tr) {
      transition_out(kr), transition_out(Ar, Tr), vr = !1;
    },
    d(Tr) {
      Tr && detach(ar), kr && kr.d(), Ar && Ar.d(Tr), yr = !1, run_all(_r);
    }
  };
}
const cBase$3 = "text-center cursor-pointer transition-colors duration-100", cInterface = "";
function instance$j(cr, ar, lr) {
  let ur, dr, fr;
  const gr = ["selected", "controls", "active", "hover", "flex", "padding", "rounded", "spacing"];
  let mr = compute_rest_props(ar, gr), { $$slots: vr = {}, $$scope: yr } = ar;
  const _r = compute_slots(vr);
  let { selected: kr = !1 } = ar, { controls: xr = "" } = ar, { active: Ar = getContext("active") } = ar, { hover: Er = getContext("hover") } = ar, { flex: Cr = getContext("flex") } = ar, { padding: Tr = getContext("padding") } = ar, { rounded: Sr = getContext("rounded") } = ar, { spacing: Lr = getContext("spacing") } = ar;
  function Ir() {
    return delete mr.class, mr;
  }
  function Nr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Rr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Mr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Br(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Dr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Hr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function Fr(Ur) {
    bubble.call(this, cr, Ur);
  }
  function zr(Ur) {
    bubble.call(this, cr, Ur);
  }
  return cr.$$set = (Ur) => {
    lr(4, ar = assign$1(assign$1({}, ar), exclude_internal_props(Ur))), lr(24, mr = compute_rest_props(ar, gr)), "selected" in Ur && lr(6, kr = Ur.selected), "controls" in Ur && lr(0, xr = Ur.controls), "active" in Ur && lr(7, Ar = Ur.active), "hover" in Ur && lr(8, Er = Ur.hover), "flex" in Ur && lr(9, Cr = Ur.flex), "padding" in Ur && lr(10, Tr = Ur.padding), "rounded" in Ur && lr(11, Sr = Ur.rounded), "spacing" in Ur && lr(12, Lr = Ur.spacing), "$$scope" in Ur && lr(14, yr = Ur.$$scope);
  }, cr.$$.update = () => {
    var Ur;
    cr.$$.dirty & /*selected, active, hover*/
    448 && lr(13, ur = kr ? Ar : Er), lr(2, dr = `${cBase$3} ${Cr} ${Tr} ${Sr} ${ur} ${(Ur = ar.class) != null ? Ur : ""}`), cr.$$.dirty & /*spacing*/
    4096 && lr(1, fr = `${cInterface} ${Lr}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    fr,
    dr,
    Ir,
    ar,
    _r,
    kr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    ur,
    yr,
    vr,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr
  ];
}
class TabAnchor extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$j, create_fragment$E, safe_not_equal, {
      selected: 6,
      controls: 0,
      active: 7,
      hover: 8,
      flex: 9,
      padding: 10,
      rounded: 11,
      spacing: 12
    });
  }
  get selected() {
    return this.$$.ctx[6];
  }
  set selected(ar) {
    this.$$set({ selected: ar }), flush();
  }
  get controls() {
    return this.$$.ctx[0];
  }
  set controls(ar) {
    this.$$set({ controls: ar }), flush();
  }
  get active() {
    return this.$$.ctx[7];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[8];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get flex() {
    return this.$$.ctx[9];
  }
  set flex(ar) {
    this.$$set({ flex: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[10];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[11];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[12];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
}
create_custom_element(TabAnchor, { selected: { type: "Boolean" }, controls: {}, active: {}, hover: {}, flex: {}, padding: {}, rounded: {}, spacing: {} }, ["lead", "default"], [], !0);
function create_fragment$D(cr) {
  let ar, lr, ur;
  const dr = (
    /*#slots*/
    cr[22].default
  ), fr = create_slot(
    dr,
    cr,
    /*$$scope*/
    cr[21],
    null
  );
  return {
    c() {
      ar = element("div"), fr && fr.c(), attr(ar, "class", lr = "tree " + /*classesBase*/
      cr[4]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        cr[0]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        cr[2]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        cr[1]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), fr && fr.m(ar, null), cr[23](ar), ur = !0;
    },
    p(gr, [mr]) {
      fr && fr.p && (!ur || mr & /*$$scope*/
      2097152) && update_slot_base(
        fr,
        dr,
        gr,
        /*$$scope*/
        gr[21],
        ur ? get_slot_changes(
          dr,
          /*$$scope*/
          gr[21],
          mr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          gr[21]
        ),
        null
      ), (!ur || mr & /*classesBase*/
      16 && lr !== (lr = "tree " + /*classesBase*/
      gr[4])) && attr(ar, "class", lr), (!ur || mr & /*multiple*/
      1) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        gr[0]
      ), (!ur || mr & /*labelledby*/
      4) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        gr[2]
      ), (!ur || mr & /*disabled*/
      2) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        gr[1]
      );
    },
    i(gr) {
      ur || (transition_in(fr, gr), ur = !0);
    },
    o(gr) {
      transition_out(fr, gr), ur = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr), cr[23](null);
    }
  };
}
function instance$i(cr, ar, lr) {
  let ur, { $$slots: dr = {}, $$scope: fr } = ar, { selection: gr = !1 } = ar, { multiple: mr = !1 } = ar, { width: vr = "w-full" } = ar, { spacing: yr = "space-y-1" } = ar, { open: _r = !1 } = ar, { disabled: kr = !1 } = ar, { padding: xr = "py-4 px-4" } = ar, { indent: Ar = "ml-4" } = ar, { hover: Er = "hover:variant-soft" } = ar, { rounded: Cr = "rounded-container-token" } = ar, { caretOpen: Tr = "rotate-180" } = ar, { caretClosed: Sr = "" } = ar, { hyphenOpacity: Lr = "opacity-10" } = ar, { regionSummary: Ir = "" } = ar, { regionSymbol: Nr = "" } = ar, { regionChildren: Rr = "" } = ar, { labelledby: Mr = "" } = ar;
  function Br() {
    Hr.querySelectorAll("details.tree-item").forEach((Ur) => {
      if (!Ur.open) {
        const jr = Ur.querySelector("summary.tree-item-summary");
        jr && jr.click();
      }
    });
  }
  function Dr() {
    Hr.querySelectorAll("details.tree-item").forEach((Ur) => {
      if (Ur.open) {
        const jr = Ur.querySelector("summary.tree-item-summary");
        jr && jr.click();
      }
    });
  }
  setContext("open", _r), setContext("selection", gr), setContext("multiple", mr), setContext("disabled", kr), setContext("padding", xr), setContext("indent", Ar), setContext("hover", Er), setContext("rounded", Cr), setContext("caretOpen", Tr), setContext("caretClosed", Sr), setContext("hyphenOpacity", Lr), setContext("regionSummary", Ir), setContext("regionSymbol", Nr), setContext("regionChildren", Rr);
  let Hr;
  function Fr(zr) {
    binding_callbacks[zr ? "unshift" : "push"](() => {
      Hr = zr, lr(3, Hr);
    });
  }
  return cr.$$set = (zr) => {
    lr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(zr))), "selection" in zr && lr(5, gr = zr.selection), "multiple" in zr && lr(0, mr = zr.multiple), "width" in zr && lr(6, vr = zr.width), "spacing" in zr && lr(7, yr = zr.spacing), "open" in zr && lr(8, _r = zr.open), "disabled" in zr && lr(1, kr = zr.disabled), "padding" in zr && lr(9, xr = zr.padding), "indent" in zr && lr(10, Ar = zr.indent), "hover" in zr && lr(11, Er = zr.hover), "rounded" in zr && lr(12, Cr = zr.rounded), "caretOpen" in zr && lr(13, Tr = zr.caretOpen), "caretClosed" in zr && lr(14, Sr = zr.caretClosed), "hyphenOpacity" in zr && lr(15, Lr = zr.hyphenOpacity), "regionSummary" in zr && lr(16, Ir = zr.regionSummary), "regionSymbol" in zr && lr(17, Nr = zr.regionSymbol), "regionChildren" in zr && lr(18, Rr = zr.regionChildren), "labelledby" in zr && lr(2, Mr = zr.labelledby), "$$scope" in zr && lr(21, fr = zr.$$scope);
  }, cr.$$.update = () => {
    var zr;
    lr(4, ur = `${vr} ${yr} ${(zr = ar.class) != null ? zr : ""}`);
  }, ar = exclude_internal_props(ar), [
    mr,
    kr,
    Mr,
    Hr,
    ur,
    gr,
    vr,
    yr,
    _r,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Br,
    Dr,
    fr,
    dr,
    Fr
  ];
}
class TreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$i, create_fragment$D, safe_not_equal, {
      selection: 5,
      multiple: 0,
      width: 6,
      spacing: 7,
      open: 8,
      disabled: 1,
      padding: 9,
      indent: 10,
      hover: 11,
      rounded: 12,
      caretOpen: 13,
      caretClosed: 14,
      hyphenOpacity: 15,
      regionSummary: 16,
      regionSymbol: 17,
      regionChildren: 18,
      labelledby: 2,
      expandAll: 19,
      collapseAll: 20
    });
  }
  get selection() {
    return this.$$.ctx[5];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[0];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get width() {
    return this.$$.ctx[6];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[7];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[8];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[9];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[10];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[11];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[12];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[13];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[14];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[15];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[16];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[17];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[18];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[2];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get expandAll() {
    return this.$$.ctx[19];
  }
  get collapseAll() {
    return this.$$.ctx[20];
  }
}
create_custom_element(TreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, ["default"], ["expandAll", "collapseAll"], !0);
const get_children_slot_changes = (cr) => ({}), get_children_slot_context = (cr) => ({}), get_lead_slot_changes = (cr) => ({}), get_lead_slot_context = (cr) => ({});
function create_else_block_1$4(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), attr(lr, "d", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512"), attr(ar, "class", ur = "w-3 " + /*classesHyphen*/
      cr[15]);
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr);
    },
    p(dr, fr) {
      fr[0] & /*classesHyphen*/
      32768 && ur !== (ur = "w-3 " + /*classesHyphen*/
      dr[15]) && attr(ar, "class", ur);
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block_3$4(cr) {
  let ar, lr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), attr(lr, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"), attr(ar, "xmlns", "http://www.w3.org/2000/svg"), attr(ar, "viewBox", "0 0 448 512");
    },
    m(ur, dr) {
      insert(ur, ar, dr), append(ar, lr);
    },
    p: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_1$7(cr) {
  let ar;
  function lr(fr, gr) {
    return (
      /*multiple*/
      fr[7] ? create_if_block_2$5 : create_else_block$7
    );
  }
  let ur = lr(cr), dr = ur(cr);
  return {
    c() {
      dr.c(), ar = empty$2();
    },
    m(fr, gr) {
      dr.m(fr, gr), insert(fr, ar, gr);
    },
    p(fr, gr) {
      ur === (ur = lr(fr)) && dr ? dr.p(fr, gr) : (dr.d(1), dr = ur(fr), dr && (dr.c(), dr.m(ar.parentNode, ar)));
    },
    d(fr) {
      fr && detach(ar), dr.d(fr);
    }
  };
}
function create_else_block$7(cr) {
  let ar, lr = !1, ur, dr, fr;
  return ur = init_binding_group(
    /*$$binding_groups*/
    cr[44][0]
  ), {
    c() {
      ar = element("input"), attr(ar, "class", "radio tree-item-radio"), attr(ar, "type", "radio"), attr(
        ar,
        "name",
        /*name*/
        cr[4]
      ), ar.__value = /*value*/
      cr[5], set_input_value(ar, ar.__value), ur.p(ar);
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.checked = ar.__value === /*group*/
      cr[0], dr || (fr = listen(
        ar,
        "change",
        /*input_change_handler_1*/
        cr[43]
      ), dr = !0);
    },
    p(gr, mr) {
      mr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        gr[4]
      ), mr[0] & /*value*/
      32 && (ar.__value = /*value*/
      gr[5], set_input_value(ar, ar.__value), lr = !0), (lr || mr[0] & /*group*/
      1) && (ar.checked = ar.__value === /*group*/
      gr[0]);
    },
    d(gr) {
      gr && detach(ar), ur.r(), dr = !1, fr();
    }
  };
}
function create_if_block_2$5(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("input"), attr(ar, "class", "checkbox tree-item-checkbox"), attr(ar, "type", "checkbox"), attr(
        ar,
        "name",
        /*name*/
        cr[4]
      ), ar.__value = /*value*/
      cr[5], set_input_value(ar, ar.__value), /*checked*/
      (cr[1] === void 0 || /*indeterminate*/
      cr[3] === void 0) && add_render_callback(() => (
        /*input_change_handler*/
        cr[42].call(ar)
      ));
    },
    m(dr, fr) {
      insert(dr, ar, fr), ar.checked = /*checked*/
      cr[1], ar.indeterminate = /*indeterminate*/
      cr[3], lr || (ur = [
        listen(
          ar,
          "change",
          /*input_change_handler*/
          cr[42]
        ),
        listen(
          ar,
          "change",
          /*onParentChange*/
          cr[11]
        )
      ], lr = !0);
    },
    p(dr, fr) {
      fr[0] & /*name*/
      16 && attr(
        ar,
        "name",
        /*name*/
        dr[4]
      ), fr[0] & /*value*/
      32 && (ar.__value = /*value*/
      dr[5], set_input_value(ar, ar.__value)), fr[0] & /*checked*/
      2 && (ar.checked = /*checked*/
      dr[1]), fr[0] & /*indeterminate*/
      8 && (ar.indeterminate = /*indeterminate*/
      dr[3]);
    },
    d(dr) {
      dr && detach(ar), lr = !1, run_all(ur);
    }
  };
}
function create_if_block$c(cr) {
  let ar, lr;
  const ur = (
    /*#slots*/
    cr[38].lead
  ), dr = create_slot(
    ur,
    cr,
    /*$$scope*/
    cr[37],
    get_lead_slot_context
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", "tree-item-lead");
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), lr = !0;
    },
    p(fr, gr) {
      dr && dr.p && (!lr || gr[1] & /*$$scope*/
      64) && update_slot_base(
        dr,
        ur,
        fr,
        /*$$scope*/
        fr[37],
        lr ? get_slot_changes(
          ur,
          /*$$scope*/
          fr[37],
          gr,
          get_lead_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          fr[37]
        ),
        get_lead_slot_context
      );
    },
    i(fr) {
      lr || (transition_in(dr, fr), lr = !0);
    },
    o(fr) {
      transition_out(dr, fr), lr = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d(fr);
    }
  };
}
function create_fragment$C(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr;
  function Ir(Ur, jr) {
    return (
      /*$$slots*/
      Ur[21].children && !/*hideChildren*/
      Ur[10] ? create_if_block_3$4 : create_else_block_1$4
    );
  }
  let Nr = Ir(cr), Rr = Nr(cr), Mr = (
    /*selection*/
    cr[6] && /*name*/
    cr[4] && /*group*/
    cr[0] !== void 0 && create_if_block_1$7(cr)
  ), Br = (
    /*$$slots*/
    cr[21].lead && !/*hideLead*/
    cr[9] && create_if_block$c(cr)
  );
  const Dr = (
    /*#slots*/
    cr[38].default
  ), Hr = create_slot(
    Dr,
    cr,
    /*$$scope*/
    cr[37],
    null
  ), Fr = (
    /*#slots*/
    cr[38].children
  ), zr = create_slot(
    Fr,
    cr,
    /*$$scope*/
    cr[37],
    get_children_slot_context
  );
  return {
    c() {
      ar = element("details"), lr = element("summary"), ur = element("div"), Rr.c(), fr = space(), Mr && Mr.c(), gr = space(), Br && Br.c(), mr = space(), vr = element("div"), Hr && Hr.c(), xr = space(), Ar = element("div"), zr && zr.c(), attr(ur, "class", dr = "tree-summary-symbol " + /*classesSymbol*/
      cr[16]), attr(vr, "class", "tree-item-content"), attr(lr, "class", yr = "tree-item-summary " + /*classesSummary*/
      cr[17]), attr(lr, "role", "treeitem"), attr(lr, "aria-selected", _r = /*selection*/
      cr[6] ? (
        /*checked*/
        cr[1]
      ) : void 0), attr(lr, "aria-expanded", kr = /*$$slots*/
      cr[21].children ? (
        /*open*/
        cr[2]
      ) : void 0), attr(Ar, "class", Er = "tree-item-children " + /*classesChildren*/
      cr[14]), attr(Ar, "role", "group"), attr(ar, "class", Cr = "tree-item " + /*classesBase*/
      cr[18]), attr(ar, "data-testid", "tree-item"), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        cr[8]
      );
    },
    m(Ur, jr) {
      insert(Ur, ar, jr), append(ar, lr), append(lr, ur), Rr.m(ur, null), append(lr, fr), Mr && Mr.m(lr, null), append(lr, gr), Br && Br.m(lr, null), append(lr, mr), append(lr, vr), Hr && Hr.m(vr, null), append(ar, xr), append(ar, Ar), zr && zr.m(Ar, null), cr[45](Ar), cr[46](ar), ar.open = /*open*/
      cr[2], Tr = !0, Sr || (Lr = [
        listen(
          lr,
          "click",
          /*onSummaryClick*/
          cr[19]
        ),
        listen(
          lr,
          "click",
          /*click_handler*/
          cr[39]
        ),
        listen(
          lr,
          "keydown",
          /*onKeyDown*/
          cr[20]
        ),
        listen(
          lr,
          "keydown",
          /*keydown_handler*/
          cr[40]
        ),
        listen(
          lr,
          "keyup",
          /*keyup_handler*/
          cr[41]
        ),
        listen(
          ar,
          "toggle",
          /*details_toggle_handler*/
          cr[47]
        )
      ], Sr = !0);
    },
    p(Ur, jr) {
      Nr === (Nr = Ir(Ur)) && Rr ? Rr.p(Ur, jr) : (Rr.d(1), Rr = Nr(Ur), Rr && (Rr.c(), Rr.m(ur, null))), (!Tr || jr[0] & /*classesSymbol*/
      65536 && dr !== (dr = "tree-summary-symbol " + /*classesSymbol*/
      Ur[16])) && attr(ur, "class", dr), /*selection*/
      Ur[6] && /*name*/
      Ur[4] && /*group*/
      Ur[0] !== void 0 ? Mr ? Mr.p(Ur, jr) : (Mr = create_if_block_1$7(Ur), Mr.c(), Mr.m(lr, gr)) : Mr && (Mr.d(1), Mr = null), /*$$slots*/
      Ur[21].lead && !/*hideLead*/
      Ur[9] ? Br ? (Br.p(Ur, jr), jr[0] & /*$$slots, hideLead*/
      2097664 && transition_in(Br, 1)) : (Br = create_if_block$c(Ur), Br.c(), transition_in(Br, 1), Br.m(lr, mr)) : Br && (group_outros(), transition_out(Br, 1, 1, () => {
        Br = null;
      }), check_outros()), Hr && Hr.p && (!Tr || jr[1] & /*$$scope*/
      64) && update_slot_base(
        Hr,
        Dr,
        Ur,
        /*$$scope*/
        Ur[37],
        Tr ? get_slot_changes(
          Dr,
          /*$$scope*/
          Ur[37],
          jr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ur[37]
        ),
        null
      ), (!Tr || jr[0] & /*classesSummary*/
      131072 && yr !== (yr = "tree-item-summary " + /*classesSummary*/
      Ur[17])) && attr(lr, "class", yr), (!Tr || jr[0] & /*selection, checked*/
      66 && _r !== (_r = /*selection*/
      Ur[6] ? (
        /*checked*/
        Ur[1]
      ) : void 0)) && attr(lr, "aria-selected", _r), (!Tr || jr[0] & /*$$slots, open*/
      2097156 && kr !== (kr = /*$$slots*/
      Ur[21].children ? (
        /*open*/
        Ur[2]
      ) : void 0)) && attr(lr, "aria-expanded", kr), zr && zr.p && (!Tr || jr[1] & /*$$scope*/
      64) && update_slot_base(
        zr,
        Fr,
        Ur,
        /*$$scope*/
        Ur[37],
        Tr ? get_slot_changes(
          Fr,
          /*$$scope*/
          Ur[37],
          jr,
          get_children_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Ur[37]
        ),
        get_children_slot_context
      ), (!Tr || jr[0] & /*classesChildren*/
      16384 && Er !== (Er = "tree-item-children " + /*classesChildren*/
      Ur[14])) && attr(Ar, "class", Er), (!Tr || jr[0] & /*classesBase*/
      262144 && Cr !== (Cr = "tree-item " + /*classesBase*/
      Ur[18])) && attr(ar, "class", Cr), (!Tr || jr[0] & /*disabled*/
      256) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        Ur[8]
      ), jr[0] & /*open*/
      4 && (ar.open = /*open*/
      Ur[2]);
    },
    i(Ur) {
      Tr || (transition_in(Br), transition_in(Hr, Ur), transition_in(zr, Ur), Tr = !0);
    },
    o(Ur) {
      transition_out(Br), transition_out(Hr, Ur), transition_out(zr, Ur), Tr = !1;
    },
    d(Ur) {
      Ur && detach(ar), Rr.d(), Mr && Mr.d(), Br && Br.d(), Hr && Hr.d(Ur), zr && zr.d(Ur), cr[45](null), cr[46](null), Sr = !1, run_all(Lr);
    }
  };
}
const cBase$2 = "", cSummary = "list-none [&::-webkit-details-marker]:hidden flex items-center cursor-pointer", cSymbol = "fill-current w-3 text-center transition-transform duration-[200ms]", cChildren = "", cDisabled = "opacity-50 !cursor-not-allowed";
function instance$h(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r, { $$slots: kr = {}, $$scope: xr } = ar;
  const Ar = compute_slots(kr);
  let { group: Er = void 0 } = ar, { name: Cr = void 0 } = ar, { value: Tr = void 0 } = ar, { checked: Sr = !1 } = ar, { children: Lr = [] } = ar, { spacing: Ir = "space-x-4" } = ar, { open: Nr = getContext("open") } = ar, { selection: Rr = getContext("selection") } = ar, { multiple: Mr = getContext("multiple") } = ar, { disabled: Br = getContext("disabled") } = ar, { indeterminate: Dr = !1 } = ar, { padding: Hr = getContext("padding") } = ar, { indent: Fr = getContext("indent") } = ar, { hover: zr = getContext("hover") } = ar, { rounded: Ur = getContext("rounded") } = ar, { caretOpen: jr = getContext("caretOpen") } = ar, { caretClosed: Yr = getContext("caretClosed") } = ar, { hyphenOpacity: qr = getContext("hyphenOpacity") } = ar, { regionSummary: Wr = getContext("regionSummary") } = ar, { regionSymbol: Jr = getContext("regionSymbol") } = ar, { regionChildren: Gr = getContext("regionChildren") } = ar, { hideLead: Vr = !1 } = ar, { hideChildren: Qr = !1 } = ar, $r, Xr;
  function si(ui) {
    Br && ui.preventDefault();
  }
  function Zr(ui, ji) {
    Array.isArray(ui) && (lr(1, Sr = ui.indexOf(Tr) >= 0), Ti("groupChange", { checked: Sr, indeterminate: ji }), Ti("childChange"));
  }
  function li(ui, ji) {
    if (!Array.isArray(Er))
      return;
    const ai = Er.indexOf(Tr);
    ui ? ai < 0 && (Er.push(Tr), lr(0, Er)) : ai >= 0 && (Er.splice(ai, 1), lr(0, Er)), ji || hi();
  }
  function Ei(ui) {
    lr(1, Sr = ui === Tr), Ti("groupChange", { checked: Sr, indeterminate: !1 }), ui && Ti("childChange");
  }
  function ki(ui) {
    ui && Er !== Tr ? lr(0, Er = Tr) : !ui && Er === Tr && lr(0, Er = "");
  }
  function Di() {
    if (Mr) {
      if (!Array.isArray(Er))
        return;
      const ui = Lr.map((Li) => Li.value), ji = Lr[0].group, ai = Er.indexOf(Tr);
      Lr.some((Li) => Li.indeterminate) ? (lr(3, Dr = !0), ai >= 0 && (Er.splice(ai, 1), lr(0, Er))) : ui.every((Li) => Array.isArray(ji) && ji.includes(Li)) ? (lr(3, Dr = !1), ai < 0 && (Er.push(Tr), lr(0, Er))) : ui.some((Li) => Array.isArray(ji) && ji.includes(Li)) ? (lr(3, Dr = !0), ai >= 0 && (Er.splice(ai, 1), lr(0, Er))) : (lr(3, Dr = !1), ai >= 0 && (Er.splice(ai, 1), lr(0, Er)));
    } else
      Er !== Tr && Lr.some((ui) => ui.checked) ? lr(0, Er = Tr) : Er === Tr && !Lr.some((ui) => ui.checked) && lr(0, Er = "");
    Ti("childChange");
  }
  function hi() {
    if (!Mr || !Lr || Lr.length === 0 || !Array.isArray(Er))
      return;
    const ui = Er.indexOf(Tr), ji = (Li) => {
      !Li || !Array.isArray(Li.group) || (Li.indeterminate = !1, Li.group.indexOf(Li.value) < 0 && (Li.group.push(Li.value), Li.group = Li.group));
    }, ai = (Li) => {
      if (!Li || !Array.isArray(Li.group))
        return;
      Li.indeterminate = !1;
      const $i = Li.group.indexOf(Li.value);
      $i >= 0 && (Li.group.splice($i, 1), Li.group = Li.group);
    };
    Lr.forEach((Li) => {
      Li && (ui >= 0 ? ji(Li) : ai(Li), Li.onParentChange());
    });
  }
  const Ti = createEventDispatcher();
  function fi(ui) {
    var $i, Wi, io, ro, mi, di, yi, Bi, Ii;
    function ji() {
      let Fi = $r;
      for (; Fi !== null; ) {
        if (Fi.classList.contains("tree"))
          return Fi;
        Fi = Fi.parentElement;
      }
    }
    let ai, Li = null;
    switch (ui.code) {
      case "ArrowRight":
        if (!Nr)
          lr(2, Nr = !0);
        else if (Ar.children && !Qr) {
          const Fi = Xr.querySelector("details>summary");
          Fi && Fi.focus();
        }
        break;
      case "ArrowLeft":
        if (Nr)
          lr(2, Nr = !1);
        else {
          const Fi = ($i = $r.parentElement) == null ? void 0 : $i.parentElement;
          Fi && Fi.tagName === "DETAILS" && ((Wi = Fi.querySelector("summary")) == null || Wi.focus());
        }
        break;
      case "Home":
        ui.preventDefault(), ai = ji(), ai && ((io = ai == null ? void 0 : ai.querySelector("summary")) == null || io.focus());
        break;
      case "End":
        if (ui.preventDefault(), ai = ji(), ai) {
          const Fi = ai == null ? void 0 : ai.querySelectorAll("details");
          if (!Fi)
            return;
          for (let eo = Fi.length - 1; eo >= 0; eo--) {
            const Ui = Fi[eo];
            if ((mi = (ro = Ui.parentElement) == null ? void 0 : ro.classList) != null && mi.contains("tree") || ((yi = (di = Ui.parentElement) == null ? void 0 : di.parentElement) == null ? void 0 : yi.getAttribute("open")) !== null) {
              Li = Ui;
              break;
            } else if (((Ii = (Bi = Ui.parentElement) == null ? void 0 : Bi.parentElement) == null ? void 0 : Ii.tagName) !== "details") {
              Li = Ui.parentElement.parentElement;
              break;
            }
          }
          if (Li) {
            const eo = Li.querySelector("summary");
            eo && eo.focus();
          }
        }
        break;
    }
  }
  const Mi = [[]];
  function oi(ui) {
    bubble.call(this, cr, ui);
  }
  function Ri(ui) {
    bubble.call(this, cr, ui);
  }
  function qi(ui) {
    bubble.call(this, cr, ui);
  }
  function zi() {
    Sr = this.checked, Dr = this.indeterminate, lr(1, Sr), lr(3, Dr);
  }
  function to() {
    Er = this.__value, lr(0, Er);
  }
  function Hi(ui) {
    binding_callbacks[ui ? "unshift" : "push"](() => {
      Xr = ui, lr(13, Xr);
    });
  }
  function _i(ui) {
    binding_callbacks[ui ? "unshift" : "push"](() => {
      $r = ui, lr(12, $r);
    });
  }
  function Ai() {
    Nr = this.open, lr(2, Nr);
  }
  return cr.$$set = (ui) => {
    lr(54, ar = assign$1(assign$1({}, ar), exclude_internal_props(ui))), "group" in ui && lr(0, Er = ui.group), "name" in ui && lr(4, Cr = ui.name), "value" in ui && lr(5, Tr = ui.value), "checked" in ui && lr(1, Sr = ui.checked), "children" in ui && lr(22, Lr = ui.children), "spacing" in ui && lr(23, Ir = ui.spacing), "open" in ui && lr(2, Nr = ui.open), "selection" in ui && lr(6, Rr = ui.selection), "multiple" in ui && lr(7, Mr = ui.multiple), "disabled" in ui && lr(8, Br = ui.disabled), "indeterminate" in ui && lr(3, Dr = ui.indeterminate), "padding" in ui && lr(24, Hr = ui.padding), "indent" in ui && lr(25, Fr = ui.indent), "hover" in ui && lr(26, zr = ui.hover), "rounded" in ui && lr(27, Ur = ui.rounded), "caretOpen" in ui && lr(28, jr = ui.caretOpen), "caretClosed" in ui && lr(29, Yr = ui.caretClosed), "hyphenOpacity" in ui && lr(30, qr = ui.hyphenOpacity), "regionSummary" in ui && lr(31, Wr = ui.regionSummary), "regionSymbol" in ui && lr(32, Jr = ui.regionSymbol), "regionChildren" in ui && lr(33, Gr = ui.regionChildren), "hideLead" in ui && lr(9, Vr = ui.hideLead), "hideChildren" in ui && lr(10, Qr = ui.hideChildren), "$$scope" in ui && lr(37, xr = ui.$$scope);
  }, cr.$$.update = () => {
    var ui;
    cr.$$.dirty[0] & /*multiple, group, indeterminate*/
    137 && Mr && Zr(Er, Dr), cr.$$.dirty[0] & /*multiple, checked, indeterminate*/
    138 && Mr && li(Sr, Dr), cr.$$.dirty[0] & /*multiple, group*/
    129 && (Mr || Ei(Er)), cr.$$.dirty[0] & /*multiple, checked*/
    130 && (Mr || ki(Sr)), cr.$$.dirty[0] & /*multiple, group, value, children*/
    4194465 && !Mr && Er !== void 0 && Er !== Tr && Lr.forEach((ji) => {
      ji && (ji.group = "");
    }), cr.$$.dirty[0] & /*open*/
    4 && Ti("toggle", { open: Nr }), cr.$$.dirty[0] & /*children*/
    4194304 && Lr.forEach((ji) => {
      ji && ji.$on("childChange", Di);
    }), cr.$$.dirty[0] & /*open, hideChildren, caretOpen, caretClosed*/
    805307396 && lr(34, ur = Nr && Ar.children && !Qr ? jr : Yr), cr.$$.dirty[0] & /*disabled*/
    256 && lr(36, dr = Br ? cDisabled : ""), lr(18, fr = `${cBase$2} ${(ui = ar.class) != null ? ui : ""}`), cr.$$.dirty[0] & /*spacing, rounded, padding, hover*/
    226492416 | cr.$$.dirty[1] & /*classesDisabled, regionSummary*/
    33 && lr(17, gr = `${cSummary} ${dr} ${Ir} ${Ur} ${Hr} ${zr} ${Wr}`), cr.$$.dirty[1] & /*classesCaretState*/
    8 && lr(35, vr = `${ur}`), cr.$$.dirty[1] & /*classesCaret, regionSymbol*/
    18 && lr(16, mr = `${cSymbol} ${vr} ${Jr}`), cr.$$.dirty[0] & /*hyphenOpacity*/
    1073741824 && lr(15, yr = `${qr}`), cr.$$.dirty[0] & /*indent*/
    33554432 | cr.$$.dirty[1] & /*regionChildren*/
    4 && lr(14, _r = `${cChildren} ${Fr} ${Gr}`);
  }, ar = exclude_internal_props(ar), [
    Er,
    Sr,
    Nr,
    Dr,
    Cr,
    Tr,
    Rr,
    Mr,
    Br,
    Vr,
    Qr,
    hi,
    $r,
    Xr,
    _r,
    yr,
    mr,
    gr,
    fr,
    si,
    fi,
    Ar,
    Lr,
    Ir,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    ur,
    vr,
    dr,
    xr,
    kr,
    oi,
    Ri,
    qi,
    zi,
    to,
    Mi,
    Hi,
    _i,
    Ai
  ];
}
class TreeViewItem extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$h,
      create_fragment$C,
      safe_not_equal,
      {
        group: 0,
        name: 4,
        value: 5,
        checked: 1,
        children: 22,
        spacing: 23,
        open: 2,
        selection: 6,
        multiple: 7,
        disabled: 8,
        indeterminate: 3,
        padding: 24,
        indent: 25,
        hover: 26,
        rounded: 27,
        caretOpen: 28,
        caretClosed: 29,
        hyphenOpacity: 30,
        regionSummary: 31,
        regionSymbol: 32,
        regionChildren: 33,
        hideLead: 9,
        hideChildren: 10,
        onParentChange: 11
      },
      null,
      [-1, -1]
    );
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(ar) {
    this.$$set({ group: ar }), flush();
  }
  get name() {
    return this.$$.ctx[4];
  }
  set name(ar) {
    this.$$set({ name: ar }), flush();
  }
  get value() {
    return this.$$.ctx[5];
  }
  set value(ar) {
    this.$$set({ value: ar }), flush();
  }
  get checked() {
    return this.$$.ctx[1];
  }
  set checked(ar) {
    this.$$set({ checked: ar }), flush();
  }
  get children() {
    return this.$$.ctx[22];
  }
  set children(ar) {
    this.$$set({ children: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[23];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[2];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get selection() {
    return this.$$.ctx[6];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[7];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[8];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get indeterminate() {
    return this.$$.ctx[3];
  }
  set indeterminate(ar) {
    this.$$set({ indeterminate: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[24];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[25];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[26];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[27];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[28];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[29];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[30];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[31];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[32];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[33];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get hideLead() {
    return this.$$.ctx[9];
  }
  set hideLead(ar) {
    this.$$set({ hideLead: ar }), flush();
  }
  get hideChildren() {
    return this.$$.ctx[10];
  }
  set hideChildren(ar) {
    this.$$set({ hideChildren: ar }), flush();
  }
  get onParentChange() {
    return this.$$.ctx[11];
  }
}
create_custom_element(TreeViewItem, { group: {}, name: {}, value: {}, checked: { type: "Boolean" }, children: {}, spacing: {}, open: {}, selection: {}, multiple: {}, disabled: {}, indeterminate: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, hideLead: { type: "Boolean" }, hideChildren: { type: "Boolean" } }, ["lead", "default", "children"], ["onParentChange"], !0);
function get_each_context$4(cr, ar, lr) {
  const ur = cr.slice();
  return ur[31] = ar[lr], ur[32] = ar, ur[33] = lr, ur;
}
function create_if_block$b(cr) {
  let ar, lr, ur = ensure_array_like(
    /*nodes*/
    cr[0]
  ), dr = [];
  for (let gr = 0; gr < ur.length; gr += 1)
    dr[gr] = create_each_block$4(get_each_context$4(cr, ur, gr));
  const fr = (gr) => transition_out(dr[gr], 1, 1, () => {
    dr[gr] = null;
  });
  return {
    c() {
      for (let gr = 0; gr < dr.length; gr += 1)
        dr[gr].c();
      ar = empty$2();
    },
    m(gr, mr) {
      for (let vr = 0; vr < dr.length; vr += 1)
        dr[vr] && dr[vr].m(gr, mr);
      insert(gr, ar, mr), lr = !0;
    },
    p(gr, mr) {
      if (mr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, treeItems, children, group, name, toggleNode, checkNode, dispatch*/
      4095) {
        ur = ensure_array_like(
          /*nodes*/
          gr[0]
        );
        let vr;
        for (vr = 0; vr < ur.length; vr += 1) {
          const yr = get_each_context$4(gr, ur, vr);
          dr[vr] ? (dr[vr].p(yr, mr), transition_in(dr[vr], 1)) : (dr[vr] = create_each_block$4(yr), dr[vr].c(), transition_in(dr[vr], 1), dr[vr].m(ar.parentNode, ar));
        }
        for (group_outros(), vr = ur.length; vr < dr.length; vr += 1)
          fr(vr);
        check_outros();
      }
    },
    i(gr) {
      if (!lr) {
        for (let mr = 0; mr < ur.length; mr += 1)
          transition_in(dr[mr]);
        lr = !0;
      }
    },
    o(gr) {
      dr = dr.filter(Boolean);
      for (let mr = 0; mr < dr.length; mr += 1)
        transition_out(dr[mr]);
      lr = !1;
    },
    d(gr) {
      gr && detach(ar), destroy_each(dr, gr);
    }
  };
}
function create_else_block_1$3(cr) {
  let ar, lr, ur;
  const dr = [
    /*node*/
    cr[31].contentProps
  ];
  var fr = (
    /*node*/
    cr[31].content
  );
  function gr(mr, vr) {
    let yr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      yr = get_spread_update(dr, [get_spread_object(
        /*node*/
        mr[31].contentProps
      )]);
    else
      for (let _r = 0; _r < dr.length; _r += 1)
        yr = assign$1(yr, dr[_r]);
    return { props: yr };
  }
  return fr && (ar = construct_svelte_component(fr, gr(cr))), {
    c() {
      ar && create_component(ar.$$.fragment), lr = empty$2();
    },
    m(mr, vr) {
      ar && mount_component(ar, mr, vr), insert(mr, lr, vr), ur = !0;
    },
    p(mr, vr) {
      if (vr[0] & /*nodes*/
      1 && fr !== (fr = /*node*/
      mr[31].content)) {
        if (ar) {
          group_outros();
          const yr = ar;
          transition_out(yr.$$.fragment, 1, 0, () => {
            destroy_component(yr, 1);
          }), check_outros();
        }
        fr ? (ar = construct_svelte_component(fr, gr(mr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, lr.parentNode, lr)) : ar = null;
      } else if (fr) {
        const yr = vr[0] & /*nodes*/
        1 ? get_spread_update(dr, [get_spread_object(
          /*node*/
          mr[31].contentProps
        )]) : {};
        ar.$set(yr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(lr), ar && destroy_component(ar, mr);
    }
  };
}
function create_if_block_2$4(cr) {
  let ar, lr = (
    /*node*/
    cr[31].content + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$2(), ar.a = ur;
    },
    m(dr, fr) {
      ar.m(lr, dr, fr), insert(dr, ur, fr);
    },
    p(dr, fr) {
      fr[0] & /*nodes*/
      1 && lr !== (lr = /*node*/
      dr[31].content + "") && ar.p(lr);
    },
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && (detach(ur), ar.d());
    }
  };
}
function create_default_slot$1(cr) {
  let ar, lr, ur, dr;
  const fr = [create_if_block_2$4, create_else_block_1$3], gr = [];
  function mr(vr, yr) {
    return typeof /*node*/
    vr[31].content == "string" ? 0 : 1;
  }
  return ar = mr(cr), lr = gr[ar] = fr[ar](cr), {
    c() {
      lr.c(), ur = space();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), dr = !0;
    },
    p(vr, yr) {
      let _r = ar;
      ar = mr(vr), ar === _r ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[_r], 1, 1, () => {
        gr[_r] = null;
      }), check_outros(), lr = gr[ar], lr ? lr.p(vr, yr) : (lr = gr[ar] = fr[ar](vr), lr.c()), transition_in(lr, 1), lr.m(ur.parentNode, ur));
    },
    i(vr) {
      dr || (transition_in(lr), dr = !0);
    },
    o(vr) {
      transition_out(lr), dr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_else_block$6(cr) {
  let ar, lr, ur;
  const dr = [
    /*node*/
    cr[31].leadProps
  ];
  var fr = (
    /*node*/
    cr[31].lead
  );
  function gr(mr, vr) {
    let yr = {};
    if (vr !== void 0 && vr[0] & /*nodes*/
    1)
      yr = get_spread_update(dr, [get_spread_object(
        /*node*/
        mr[31].leadProps
      )]);
    else
      for (let _r = 0; _r < dr.length; _r += 1)
        yr = assign$1(yr, dr[_r]);
    return { props: yr };
  }
  return fr && (ar = construct_svelte_component(fr, gr(cr))), {
    c() {
      ar && create_component(ar.$$.fragment), lr = empty$2();
    },
    m(mr, vr) {
      ar && mount_component(ar, mr, vr), insert(mr, lr, vr), ur = !0;
    },
    p(mr, vr) {
      if (vr[0] & /*nodes*/
      1 && fr !== (fr = /*node*/
      mr[31].lead)) {
        if (ar) {
          group_outros();
          const yr = ar;
          transition_out(yr.$$.fragment, 1, 0, () => {
            destroy_component(yr, 1);
          }), check_outros();
        }
        fr ? (ar = construct_svelte_component(fr, gr(mr, vr)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, lr.parentNode, lr)) : ar = null;
      } else if (fr) {
        const yr = vr[0] & /*nodes*/
        1 ? get_spread_update(dr, [get_spread_object(
          /*node*/
          mr[31].leadProps
        )]) : {};
        ar.$set(yr);
      }
    },
    i(mr) {
      ur || (ar && transition_in(ar.$$.fragment, mr), ur = !0);
    },
    o(mr) {
      ar && transition_out(ar.$$.fragment, mr), ur = !1;
    },
    d(mr) {
      mr && detach(lr), ar && destroy_component(ar, mr);
    }
  };
}
function create_if_block_1$6(cr) {
  let ar, lr = (
    /*node*/
    cr[31].lead + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$2(), ar.a = ur;
    },
    m(dr, fr) {
      ar.m(lr, dr, fr), insert(dr, ur, fr);
    },
    p(dr, fr) {
      fr[0] & /*nodes*/
      1 && lr !== (lr = /*node*/
      dr[31].lead + "") && ar.p(lr);
    },
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && (detach(ur), ar.d());
    }
  };
}
function create_lead_slot(cr) {
  let ar, lr, ur, dr;
  const fr = [create_if_block_1$6, create_else_block$6], gr = [];
  function mr(vr, yr) {
    return typeof /*node*/
    vr[31].lead == "string" ? 0 : 1;
  }
  return ar = mr(cr), lr = gr[ar] = fr[ar](cr), {
    c() {
      lr.c(), ur = space();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), dr = !0;
    },
    p(vr, yr) {
      let _r = ar;
      ar = mr(vr), ar === _r ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[_r], 1, 1, () => {
        gr[_r] = null;
      }), check_outros(), lr = gr[ar], lr ? lr.p(vr, yr) : (lr = gr[ar] = fr[ar](vr), lr.c()), transition_in(lr, 1), lr.m(ur.parentNode, ur));
    },
    i(vr) {
      dr || (transition_in(lr), dr = !0);
    },
    o(vr) {
      transition_out(lr), dr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_children_slot(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  function yr(Cr) {
    cr[12](Cr);
  }
  function _r(Cr) {
    cr[13](Cr);
  }
  function kr(Cr) {
    cr[14](Cr);
  }
  function xr(Cr) {
    cr[15](Cr);
  }
  function Ar(Cr) {
    cr[16](
      Cr,
      /*i*/
      cr[33]
    );
  }
  let Er = { nodes: (
    /*node*/
    cr[31].children
  ) };
  return (
    /*expandedNodes*/
    cr[1] !== void 0 && (Er.expandedNodes = /*expandedNodes*/
    cr[1]), /*disabledNodes*/
    cr[2] !== void 0 && (Er.disabledNodes = /*disabledNodes*/
    cr[2]), /*checkedNodes*/
    cr[3] !== void 0 && (Er.checkedNodes = /*checkedNodes*/
    cr[3]), /*indeterminateNodes*/
    cr[4] !== void 0 && (Er.indeterminateNodes = /*indeterminateNodes*/
    cr[4]), /*children*/
    cr[8][
      /*i*/
      cr[33]
    ] !== void 0 && (Er.treeItems = /*children*/
    cr[8][
      /*i*/
      cr[33]
    ]), ar = new RecursiveTreeViewItem_1({ props: Er }), binding_callbacks.push(() => bind$1(ar, "expandedNodes", yr)), binding_callbacks.push(() => bind$1(ar, "disabledNodes", _r)), binding_callbacks.push(() => bind$1(ar, "checkedNodes", kr)), binding_callbacks.push(() => bind$1(ar, "indeterminateNodes", xr)), binding_callbacks.push(() => bind$1(ar, "treeItems", Ar)), ar.$on(
      "click",
      /*click_handler*/
      cr[17]
    ), ar.$on(
      "toggle",
      /*toggle_handler*/
      cr[18]
    ), {
      c() {
        create_component(ar.$$.fragment), mr = space();
      },
      m(Cr, Tr) {
        mount_component(ar, Cr, Tr), insert(Cr, mr, Tr), vr = !0;
      },
      p(Cr, Tr) {
        cr = Cr;
        const Sr = {};
        Tr[0] & /*nodes*/
        1 && (Sr.nodes = /*node*/
        cr[31].children), !lr && Tr[0] & /*expandedNodes*/
        2 && (lr = !0, Sr.expandedNodes = /*expandedNodes*/
        cr[1], add_flush_callback(() => lr = !1)), !ur && Tr[0] & /*disabledNodes*/
        4 && (ur = !0, Sr.disabledNodes = /*disabledNodes*/
        cr[2], add_flush_callback(() => ur = !1)), !dr && Tr[0] & /*checkedNodes*/
        8 && (dr = !0, Sr.checkedNodes = /*checkedNodes*/
        cr[3], add_flush_callback(() => dr = !1)), !fr && Tr[0] & /*indeterminateNodes*/
        16 && (fr = !0, Sr.indeterminateNodes = /*indeterminateNodes*/
        cr[4], add_flush_callback(() => fr = !1)), !gr && Tr[0] & /*children*/
        256 && (gr = !0, Sr.treeItems = /*children*/
        cr[8][
          /*i*/
          cr[33]
        ], add_flush_callback(() => gr = !1)), ar.$set(Sr);
      },
      i(Cr) {
        vr || (transition_in(ar.$$.fragment, Cr), vr = !0);
      },
      o(Cr) {
        transition_out(ar.$$.fragment, Cr), vr = !1;
      },
      d(Cr) {
        Cr && detach(mr), destroy_component(ar, Cr);
      }
    }
  );
}
function create_each_block$4(cr) {
  let ar, lr = (
    /*i*/
    cr[33]
  ), ur, dr, fr, gr, mr;
  const vr = () => (
    /*treeviewitem_binding*/
    cr[19](ar, lr)
  ), yr = () => (
    /*treeviewitem_binding*/
    cr[19](null, lr)
  );
  function _r(Ir) {
    cr[20](
      Ir,
      /*i*/
      cr[33]
    );
  }
  function kr(Ir) {
    cr[21](Ir);
  }
  function xr(Ir) {
    cr[22](Ir);
  }
  function Ar(Ir) {
    cr[23](
      Ir,
      /*node*/
      cr[31]
    );
  }
  function Er(...Ir) {
    return (
      /*toggle_handler_1*/
      cr[24](
        /*node*/
        cr[31],
        ...Ir
      )
    );
  }
  function Cr(...Ir) {
    return (
      /*groupChange_handler*/
      cr[25](
        /*node*/
        cr[31],
        ...Ir
      )
    );
  }
  function Tr() {
    return (
      /*click_handler_1*/
      cr[26](
        /*node*/
        cr[31]
      )
    );
  }
  function Sr() {
    return (
      /*toggle_handler_2*/
      cr[27](
        /*node*/
        cr[31]
      )
    );
  }
  let Lr = {
    hideLead: !/*node*/
    cr[31].lead,
    hideChildren: !/*node*/
    cr[31].children || /*node*/
    cr[31].children.length === 0,
    open: (
      /*expandedNodes*/
      cr[1].includes(
        /*node*/
        cr[31].id
      )
    ),
    disabled: (
      /*disabledNodes*/
      cr[2].includes(
        /*node*/
        cr[31].id
      )
    ),
    checked: (
      /*checkedNodes*/
      cr[3].includes(
        /*node*/
        cr[31].id
      )
    ),
    indeterminate: (
      /*indeterminateNodes*/
      cr[4].includes(
        /*node*/
        cr[31].id
      )
    ),
    $$slots: {
      children: [create_children_slot],
      lead: [create_lead_slot],
      default: [create_default_slot$1]
    },
    $$scope: { ctx: cr }
  };
  return (
    /*children*/
    cr[8][
      /*i*/
      cr[33]
    ] !== void 0 && (Lr.children = /*children*/
    cr[8][
      /*i*/
      cr[33]
    ]), /*group*/
    cr[6] !== void 0 && (Lr.group = /*group*/
    cr[6]), /*name*/
    cr[7] !== void 0 && (Lr.name = /*name*/
    cr[7]), /*node*/
    cr[31].id !== void 0 && (Lr.value = /*node*/
    cr[31].id), ar = new TreeViewItem({ props: Lr }), vr(), binding_callbacks.push(() => bind$1(ar, "children", _r)), binding_callbacks.push(() => bind$1(ar, "group", kr)), binding_callbacks.push(() => bind$1(ar, "name", xr)), binding_callbacks.push(() => bind$1(ar, "value", Ar)), ar.$on("toggle", Er), ar.$on("groupChange", Cr), ar.$on("click", Tr), ar.$on("toggle", Sr), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(Ir, Nr) {
        mount_component(ar, Ir, Nr), mr = !0;
      },
      p(Ir, Nr) {
        cr = Ir, lr !== /*i*/
        cr[33] && (yr(), lr = /*i*/
        cr[33], vr());
        const Rr = {};
        Nr[0] & /*nodes*/
        1 && (Rr.hideLead = !/*node*/
        cr[31].lead), Nr[0] & /*nodes*/
        1 && (Rr.hideChildren = !/*node*/
        cr[31].children || /*node*/
        cr[31].children.length === 0), Nr[0] & /*expandedNodes, nodes*/
        3 && (Rr.open = /*expandedNodes*/
        cr[1].includes(
          /*node*/
          cr[31].id
        )), Nr[0] & /*disabledNodes, nodes*/
        5 && (Rr.disabled = /*disabledNodes*/
        cr[2].includes(
          /*node*/
          cr[31].id
        )), Nr[0] & /*checkedNodes, nodes*/
        9 && (Rr.checked = /*checkedNodes*/
        cr[3].includes(
          /*node*/
          cr[31].id
        )), Nr[0] & /*indeterminateNodes, nodes*/
        17 && (Rr.indeterminate = /*indeterminateNodes*/
        cr[4].includes(
          /*node*/
          cr[31].id
        )), Nr[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, children*/
        287 | Nr[1] & /*$$scope*/
        8 && (Rr.$$scope = { dirty: Nr, ctx: cr }), !ur && Nr[0] & /*children*/
        256 && (ur = !0, Rr.children = /*children*/
        cr[8][
          /*i*/
          cr[33]
        ], add_flush_callback(() => ur = !1)), !dr && Nr[0] & /*group*/
        64 && (dr = !0, Rr.group = /*group*/
        cr[6], add_flush_callback(() => dr = !1)), !fr && Nr[0] & /*name*/
        128 && (fr = !0, Rr.name = /*name*/
        cr[7], add_flush_callback(() => fr = !1)), !gr && Nr[0] & /*nodes*/
        1 && (gr = !0, Rr.value = /*node*/
        cr[31].id, add_flush_callback(() => gr = !1)), ar.$set(Rr);
      },
      i(Ir) {
        mr || (transition_in(ar.$$.fragment, Ir), mr = !0);
      },
      o(Ir) {
        transition_out(ar.$$.fragment, Ir), mr = !1;
      },
      d(Ir) {
        yr(), destroy_component(ar, Ir);
      }
    }
  );
}
function create_fragment$B(cr) {
  let ar, lr, ur = (
    /*nodes*/
    cr[0] && /*nodes*/
    cr[0].length > 0 && create_if_block$b(cr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$2();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), insert(dr, ar, fr), lr = !0;
    },
    p(dr, fr) {
      /*nodes*/
      dr[0] && /*nodes*/
      dr[0].length > 0 ? ur ? (ur.p(dr, fr), fr[0] & /*nodes*/
      1 && transition_in(ur, 1)) : (ur = create_if_block$b(dr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(dr) {
      lr || (transition_in(ur), lr = !0);
    },
    o(dr) {
      transition_out(ur), lr = !1;
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(dr);
    }
  };
}
function instance$g(cr, ar, lr) {
  let { nodes: ur = [] } = ar, { expandedNodes: dr = [] } = ar, { disabledNodes: fr = [] } = ar, { checkedNodes: gr = [] } = ar, { indeterminateNodes: mr = [] } = ar, vr = getContext("selection"), yr = getContext("multiple"), _r = getContext("relational"), kr = yr ? [] : "", xr = "";
  const Ar = createEventDispatcher();
  function Er(Gr, Vr) {
    var Qr;
    (Qr = Gr.children) != null && Qr.length && (Vr ? dr.includes(Gr.id) || (dr.push(Gr.id), lr(1, dr)) : dr.includes(Gr.id) && (dr.splice(dr.indexOf(Gr.id), 1), lr(1, dr)));
  }
  function Cr(Gr, Vr, Qr) {
    Vr ? (gr.includes(Gr.id) || (gr.push(Gr.id), lr(3, gr)), !Qr && mr.includes(Gr.id) && (mr.splice(mr.indexOf(Gr.id), 1), lr(4, mr))) : (gr.includes(Gr.id) && (gr.splice(gr.indexOf(Gr.id), 1), lr(3, gr)), Qr && !mr.includes(Gr.id) ? (mr.push(Gr.id), lr(4, mr)) : !Qr && mr.includes(Gr.id) && (mr.splice(mr.indexOf(Gr.id), 1), lr(4, mr)));
  }
  vr && (yr ? (ur.forEach((Gr) => {
    Array.isArray(kr) && gr.includes(Gr.id) && !kr.includes(Gr.id) && kr.push(Gr.id);
  }), kr = kr) : ur.forEach((Gr) => {
    gr.includes(Gr.id) && kr !== Gr.id && lr(6, kr = Gr.id);
  })), onMount(async () => {
    vr && (lr(7, xr = String(Math.random())), _r || lr(5, Tr = []));
  });
  let { treeItems: Tr = [] } = ar, Sr = [];
  function Lr(Gr) {
    dr = Gr, lr(1, dr);
  }
  function Ir(Gr) {
    fr = Gr, lr(2, fr);
  }
  function Nr(Gr) {
    gr = Gr, lr(3, gr);
  }
  function Rr(Gr) {
    mr = Gr, lr(4, mr);
  }
  function Mr(Gr, Vr) {
    cr.$$.not_equal(Sr[Vr], Gr) && (Sr[Vr] = Gr, lr(8, Sr));
  }
  const Br = (Gr) => Ar("click", { id: Gr.detail.id }), Dr = (Gr) => Ar("toggle", { id: Gr.detail.id });
  function Hr(Gr, Vr) {
    binding_callbacks[Gr ? "unshift" : "push"](() => {
      Tr[Vr] = Gr, lr(5, Tr);
    });
  }
  function Fr(Gr, Vr) {
    cr.$$.not_equal(Sr[Vr], Gr) && (Sr[Vr] = Gr, lr(8, Sr));
  }
  function zr(Gr) {
    kr = Gr, lr(6, kr);
  }
  function Ur(Gr) {
    xr = Gr, lr(7, xr);
  }
  function jr(Gr, Vr) {
    cr.$$.not_equal(Vr.id, Gr) && (Vr.id = Gr, lr(0, ur));
  }
  const Yr = (Gr, Vr) => Er(Gr, Vr.detail.open), qr = (Gr, Vr) => Cr(Gr, Vr.detail.checked, Vr.detail.indeterminate), Wr = (Gr) => Ar("click", { id: Gr.id }), Jr = (Gr) => {
    Ar("toggle", { id: Gr.id });
  };
  return cr.$$set = (Gr) => {
    "nodes" in Gr && lr(0, ur = Gr.nodes), "expandedNodes" in Gr && lr(1, dr = Gr.expandedNodes), "disabledNodes" in Gr && lr(2, fr = Gr.disabledNodes), "checkedNodes" in Gr && lr(3, gr = Gr.checkedNodes), "indeterminateNodes" in Gr && lr(4, mr = Gr.indeterminateNodes), "treeItems" in Gr && lr(5, Tr = Gr.treeItems);
  }, [
    ur,
    dr,
    fr,
    gr,
    mr,
    Tr,
    kr,
    xr,
    Sr,
    Ar,
    Er,
    Cr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr
  ];
}
class RecursiveTreeViewItem_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$g,
      create_fragment$B,
      safe_not_equal,
      {
        nodes: 0,
        expandedNodes: 1,
        disabledNodes: 2,
        checkedNodes: 3,
        indeterminateNodes: 4,
        treeItems: 5
      },
      null,
      [-1, -1]
    );
  }
  get nodes() {
    return this.$$.ctx[0];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[1];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[2];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[3];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[4];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get treeItems() {
    return this.$$.ctx[5];
  }
  set treeItems(ar) {
    this.$$set({ treeItems: ar }), flush();
  }
}
create_custom_element(RecursiveTreeViewItem_1, { nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, treeItems: {} }, [], [], !0);
function create_if_block$a(cr) {
  let ar, lr, ur, dr, fr, gr;
  function mr(xr) {
    cr[26](xr);
  }
  function vr(xr) {
    cr[27](xr);
  }
  function yr(xr) {
    cr[28](xr);
  }
  function _r(xr) {
    cr[29](xr);
  }
  let kr = { nodes: (
    /*nodes*/
    cr[5]
  ) };
  return (
    /*expandedNodes*/
    cr[0] !== void 0 && (kr.expandedNodes = /*expandedNodes*/
    cr[0]), /*disabledNodes*/
    cr[1] !== void 0 && (kr.disabledNodes = /*disabledNodes*/
    cr[1]), /*checkedNodes*/
    cr[2] !== void 0 && (kr.checkedNodes = /*checkedNodes*/
    cr[2]), /*indeterminateNodes*/
    cr[3] !== void 0 && (kr.indeterminateNodes = /*indeterminateNodes*/
    cr[3]), ar = new RecursiveTreeViewItem_1({ props: kr }), binding_callbacks.push(() => bind$1(ar, "expandedNodes", mr)), binding_callbacks.push(() => bind$1(ar, "disabledNodes", vr)), binding_callbacks.push(() => bind$1(ar, "checkedNodes", yr)), binding_callbacks.push(() => bind$1(ar, "indeterminateNodes", _r)), ar.$on(
      "click",
      /*onClick*/
      cr[9]
    ), ar.$on(
      "toggle",
      /*onToggle*/
      cr[10]
    ), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(xr, Ar) {
        mount_component(ar, xr, Ar), gr = !0;
      },
      p(xr, Ar) {
        const Er = {};
        Ar[0] & /*nodes*/
        32 && (Er.nodes = /*nodes*/
        xr[5]), !lr && Ar[0] & /*expandedNodes*/
        1 && (lr = !0, Er.expandedNodes = /*expandedNodes*/
        xr[0], add_flush_callback(() => lr = !1)), !ur && Ar[0] & /*disabledNodes*/
        2 && (ur = !0, Er.disabledNodes = /*disabledNodes*/
        xr[1], add_flush_callback(() => ur = !1)), !dr && Ar[0] & /*checkedNodes*/
        4 && (dr = !0, Er.checkedNodes = /*checkedNodes*/
        xr[2], add_flush_callback(() => dr = !1)), !fr && Ar[0] & /*indeterminateNodes*/
        8 && (fr = !0, Er.indeterminateNodes = /*indeterminateNodes*/
        xr[3], add_flush_callback(() => fr = !1)), ar.$set(Er);
      },
      i(xr) {
        gr || (transition_in(ar.$$.fragment, xr), gr = !0);
      },
      o(xr) {
        transition_out(ar.$$.fragment, xr), gr = !1;
      },
      d(xr) {
        destroy_component(ar, xr);
      }
    }
  );
}
function create_fragment$A(cr) {
  let ar, lr, ur, dr = (
    /*nodes*/
    cr[5] && /*nodes*/
    cr[5].length > 0 && create_if_block$a(cr)
  );
  return {
    c() {
      ar = element("div"), dr && dr.c(), attr(ar, "class", lr = "tree " + /*classesBase*/
      cr[8]), attr(ar, "data-testid", "tree"), attr(ar, "role", "tree"), attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        cr[4]
      ), attr(
        ar,
        "aria-label",
        /*labelledby*/
        cr[7]
      ), attr(
        ar,
        "aria-disabled",
        /*disabled*/
        cr[6]
      );
    },
    m(fr, gr) {
      insert(fr, ar, gr), dr && dr.m(ar, null), ur = !0;
    },
    p(fr, gr) {
      /*nodes*/
      fr[5] && /*nodes*/
      fr[5].length > 0 ? dr ? (dr.p(fr, gr), gr[0] & /*nodes*/
      32 && transition_in(dr, 1)) : (dr = create_if_block$a(fr), dr.c(), transition_in(dr, 1), dr.m(ar, null)) : dr && (group_outros(), transition_out(dr, 1, 1, () => {
        dr = null;
      }), check_outros()), (!ur || gr[0] & /*classesBase*/
      256 && lr !== (lr = "tree " + /*classesBase*/
      fr[8])) && attr(ar, "class", lr), (!ur || gr[0] & /*multiple*/
      16) && attr(
        ar,
        "aria-multiselectable",
        /*multiple*/
        fr[4]
      ), (!ur || gr[0] & /*labelledby*/
      128) && attr(
        ar,
        "aria-label",
        /*labelledby*/
        fr[7]
      ), (!ur || gr[0] & /*disabled*/
      64) && attr(
        ar,
        "aria-disabled",
        /*disabled*/
        fr[6]
      );
    },
    i(fr) {
      ur || (transition_in(dr), ur = !0);
    },
    o(fr) {
      transition_out(dr), ur = !1;
    },
    d(fr) {
      fr && detach(ar), dr && dr.d();
    }
  };
}
function instance$f(cr, ar, lr) {
  let ur, { selection: dr = !1 } = ar, { multiple: fr = !1 } = ar, { relational: gr = !1 } = ar, { nodes: mr = [] } = ar, { expandedNodes: vr = [] } = ar, { disabledNodes: yr = [] } = ar, { checkedNodes: _r = [] } = ar, { indeterminateNodes: kr = [] } = ar, { width: xr = "w-full" } = ar, { spacing: Ar = "space-y-1" } = ar, { open: Er = !1 } = ar, { disabled: Cr = !1 } = ar, { padding: Tr = "py-4 px-4" } = ar, { indent: Sr = "ml-4" } = ar, { hover: Lr = "hover:variant-soft" } = ar, { rounded: Ir = "rounded-container-token" } = ar, { caretOpen: Nr = "rotate-180" } = ar, { caretClosed: Rr = "" } = ar, { hyphenOpacity: Mr = "opacity-10" } = ar, { regionSummary: Br = "" } = ar, { regionSymbol: Dr = "" } = ar, { regionChildren: Hr = "" } = ar, { labelledby: Fr = "" } = ar;
  setContext("open", Er), setContext("selection", dr), setContext("multiple", fr), setContext("relational", gr), setContext("disabled", Cr), setContext("padding", Tr), setContext("indent", Sr), setContext("hover", Lr), setContext("rounded", Ir), setContext("caretOpen", Nr), setContext("caretClosed", Rr), setContext("hyphenOpacity", Mr), setContext("regionSummary", Br), setContext("regionSymbol", Dr), setContext("regionChildren", Hr);
  const zr = createEventDispatcher();
  function Ur(Gr) {
    zr("click", { id: Gr.detail.id });
  }
  function jr(Gr) {
    zr("toggle", { id: Gr.detail.id });
  }
  function Yr(Gr) {
    vr = Gr, lr(0, vr);
  }
  function qr(Gr) {
    yr = Gr, lr(1, yr);
  }
  function Wr(Gr) {
    _r = Gr, lr(2, _r);
  }
  function Jr(Gr) {
    kr = Gr, lr(3, kr);
  }
  return cr.$$set = (Gr) => {
    lr(31, ar = assign$1(assign$1({}, ar), exclude_internal_props(Gr))), "selection" in Gr && lr(11, dr = Gr.selection), "multiple" in Gr && lr(4, fr = Gr.multiple), "relational" in Gr && lr(12, gr = Gr.relational), "nodes" in Gr && lr(5, mr = Gr.nodes), "expandedNodes" in Gr && lr(0, vr = Gr.expandedNodes), "disabledNodes" in Gr && lr(1, yr = Gr.disabledNodes), "checkedNodes" in Gr && lr(2, _r = Gr.checkedNodes), "indeterminateNodes" in Gr && lr(3, kr = Gr.indeterminateNodes), "width" in Gr && lr(13, xr = Gr.width), "spacing" in Gr && lr(14, Ar = Gr.spacing), "open" in Gr && lr(15, Er = Gr.open), "disabled" in Gr && lr(6, Cr = Gr.disabled), "padding" in Gr && lr(16, Tr = Gr.padding), "indent" in Gr && lr(17, Sr = Gr.indent), "hover" in Gr && lr(18, Lr = Gr.hover), "rounded" in Gr && lr(19, Ir = Gr.rounded), "caretOpen" in Gr && lr(20, Nr = Gr.caretOpen), "caretClosed" in Gr && lr(21, Rr = Gr.caretClosed), "hyphenOpacity" in Gr && lr(22, Mr = Gr.hyphenOpacity), "regionSummary" in Gr && lr(23, Br = Gr.regionSummary), "regionSymbol" in Gr && lr(24, Dr = Gr.regionSymbol), "regionChildren" in Gr && lr(25, Hr = Gr.regionChildren), "labelledby" in Gr && lr(7, Fr = Gr.labelledby);
  }, cr.$$.update = () => {
    var Gr;
    lr(8, ur = `${xr} ${Ar} ${(Gr = ar.class) != null ? Gr : ""}`);
  }, ar = exclude_internal_props(ar), [
    vr,
    yr,
    _r,
    kr,
    fr,
    mr,
    Cr,
    Fr,
    ur,
    Ur,
    jr,
    dr,
    gr,
    xr,
    Ar,
    Er,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Yr,
    qr,
    Wr,
    Jr
  ];
}
class RecursiveTreeView extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$f,
      create_fragment$A,
      safe_not_equal,
      {
        selection: 11,
        multiple: 4,
        relational: 12,
        nodes: 5,
        expandedNodes: 0,
        disabledNodes: 1,
        checkedNodes: 2,
        indeterminateNodes: 3,
        width: 13,
        spacing: 14,
        open: 15,
        disabled: 6,
        padding: 16,
        indent: 17,
        hover: 18,
        rounded: 19,
        caretOpen: 20,
        caretClosed: 21,
        hyphenOpacity: 22,
        regionSummary: 23,
        regionSymbol: 24,
        regionChildren: 25,
        labelledby: 7
      },
      null,
      [-1, -1]
    );
  }
  get selection() {
    return this.$$.ctx[11];
  }
  set selection(ar) {
    this.$$set({ selection: ar }), flush();
  }
  get multiple() {
    return this.$$.ctx[4];
  }
  set multiple(ar) {
    this.$$set({ multiple: ar }), flush();
  }
  get relational() {
    return this.$$.ctx[12];
  }
  set relational(ar) {
    this.$$set({ relational: ar }), flush();
  }
  get nodes() {
    return this.$$.ctx[5];
  }
  set nodes(ar) {
    this.$$set({ nodes: ar }), flush();
  }
  get expandedNodes() {
    return this.$$.ctx[0];
  }
  set expandedNodes(ar) {
    this.$$set({ expandedNodes: ar }), flush();
  }
  get disabledNodes() {
    return this.$$.ctx[1];
  }
  set disabledNodes(ar) {
    this.$$set({ disabledNodes: ar }), flush();
  }
  get checkedNodes() {
    return this.$$.ctx[2];
  }
  set checkedNodes(ar) {
    this.$$set({ checkedNodes: ar }), flush();
  }
  get indeterminateNodes() {
    return this.$$.ctx[3];
  }
  set indeterminateNodes(ar) {
    this.$$set({ indeterminateNodes: ar }), flush();
  }
  get width() {
    return this.$$.ctx[13];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[14];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(ar) {
    this.$$set({ open: ar }), flush();
  }
  get disabled() {
    return this.$$.ctx[6];
  }
  set disabled(ar) {
    this.$$set({ disabled: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[16];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get indent() {
    return this.$$.ctx[17];
  }
  set indent(ar) {
    this.$$set({ indent: ar }), flush();
  }
  get hover() {
    return this.$$.ctx[18];
  }
  set hover(ar) {
    this.$$set({ hover: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[19];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get caretOpen() {
    return this.$$.ctx[20];
  }
  set caretOpen(ar) {
    this.$$set({ caretOpen: ar }), flush();
  }
  get caretClosed() {
    return this.$$.ctx[21];
  }
  set caretClosed(ar) {
    this.$$set({ caretClosed: ar }), flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[22];
  }
  set hyphenOpacity(ar) {
    this.$$set({ hyphenOpacity: ar }), flush();
  }
  get regionSummary() {
    return this.$$.ctx[23];
  }
  set regionSummary(ar) {
    this.$$set({ regionSummary: ar }), flush();
  }
  get regionSymbol() {
    return this.$$.ctx[24];
  }
  set regionSymbol(ar) {
    this.$$set({ regionSymbol: ar }), flush();
  }
  get regionChildren() {
    return this.$$.ctx[25];
  }
  set regionChildren(ar) {
    this.$$set({ regionChildren: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[7];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
}
create_custom_element(RecursiveTreeView, { selection: { type: "Boolean" }, multiple: { type: "Boolean" }, relational: { type: "Boolean" }, nodes: {}, expandedNodes: {}, disabledNodes: {}, checkedNodes: {}, indeterminateNodes: {}, width: {}, spacing: {}, open: { type: "Boolean" }, disabled: { type: "Boolean" }, padding: {}, indent: {}, hover: {}, rounded: {}, caretOpen: {}, caretClosed: {}, hyphenOpacity: {}, regionSummary: {}, regionSymbol: {}, regionChildren: {}, labelledby: {} }, [], [], !0);
function create_if_block$9(cr) {
  let ar, lr, ur, dr = languageFormatter(
    /*language*/
    cr[0]
  ) + "", fr, gr, mr, vr = (/*copyState*/
  cr[7] ? (
    /*buttonCopied*/
    cr[4]
  ) : (
    /*buttonLabel*/
    cr[3]
  )) + "", yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr;
  function Ir(Mr, Br) {
    return (
      /*formatted*/
      Mr[6] ? create_if_block_1$5 : create_else_block$5
    );
  }
  let Nr = Ir(cr), Rr = Nr(cr);
  return {
    c() {
      ar = element("div"), lr = element("header"), ur = element("span"), fr = text$3(dr), gr = space(), mr = element("button"), yr = text$3(vr), xr = space(), Ar = element("pre"), Er = element("code"), Rr.c(), attr(ur, "class", "codeblock-language"), attr(mr, "class", _r = "codeblock-btn " + /*button*/
      cr[2]), attr(lr, "class", "codeblock-header " + cHeader), attr(Er, "class", Cr = "codeblock-code language-" + /*language*/
      cr[0] + " lineNumbers"), attr(Ar, "class", "codeblock-pre " + cPre), attr(ar, "class", Tr = "codeblock " + /*classesBase*/
      cr[8]), attr(ar, "data-testid", "codeblock");
    },
    m(Mr, Br) {
      insert(Mr, ar, Br), append(ar, lr), append(lr, ur), append(ur, fr), append(lr, gr), append(lr, mr), append(mr, yr), append(ar, xr), append(ar, Ar), append(Ar, Er), Rr.m(Er, null), Sr || (Lr = [
        listen(
          mr,
          "click",
          /*onCopyClick*/
          cr[9]
        ),
        action_destroyer(kr = clipboard.call(
          null,
          mr,
          /*code*/
          cr[1]
        ))
      ], Sr = !0);
    },
    p(Mr, Br) {
      Br & /*language*/
      1 && dr !== (dr = languageFormatter(
        /*language*/
        Mr[0]
      ) + "") && set_data(fr, dr), Br & /*copyState, buttonLabel, buttonCopied*/
      152 && vr !== (vr = (/*copyState*/
      Mr[7] ? (
        /*buttonCopied*/
        Mr[4]
      ) : (
        /*buttonLabel*/
        Mr[3]
      )) + "") && set_data(yr, vr), Br & /*button*/
      4 && _r !== (_r = "codeblock-btn " + /*button*/
      Mr[2]) && attr(mr, "class", _r), kr && is_function(kr.update) && Br & /*code*/
      2 && kr.update.call(
        null,
        /*code*/
        Mr[1]
      ), Nr === (Nr = Ir(Mr)) && Rr ? Rr.p(Mr, Br) : (Rr.d(1), Rr = Nr(Mr), Rr && (Rr.c(), Rr.m(Er, null))), Br & /*language*/
      1 && Cr !== (Cr = "codeblock-code language-" + /*language*/
      Mr[0] + " lineNumbers") && attr(Er, "class", Cr), Br & /*classesBase*/
      256 && Tr !== (Tr = "codeblock " + /*classesBase*/
      Mr[8]) && attr(ar, "class", Tr);
    },
    d(Mr) {
      Mr && detach(ar), Rr.d(), Sr = !1, run_all(Lr);
    }
  };
}
function create_else_block$5(cr) {
  let ar = (
    /*code*/
    cr[1].trim() + ""
  ), lr;
  return {
    c() {
      lr = text$3(ar);
    },
    m(ur, dr) {
      insert(ur, lr, dr);
    },
    p(ur, dr) {
      dr & /*code*/
      2 && ar !== (ar = /*code*/
      ur[1].trim() + "") && set_data(lr, ar);
    },
    d(ur) {
      ur && detach(lr);
    }
  };
}
function create_if_block_1$5(cr) {
  let ar, lr;
  return {
    c() {
      ar = new HtmlTag(!1), lr = empty$2(), ar.a = lr;
    },
    m(ur, dr) {
      ar.m(
        /*displayCode*/
        cr[5],
        ur,
        dr
      ), insert(ur, lr, dr);
    },
    p(ur, dr) {
      dr & /*displayCode*/
      32 && ar.p(
        /*displayCode*/
        ur[5]
      );
    },
    d(ur) {
      ur && (detach(lr), ar.d());
    }
  };
}
function create_fragment$z(cr) {
  let ar, lr = (
    /*language*/
    cr[0] && /*code*/
    cr[1] && create_if_block$9(cr)
  );
  return {
    c() {
      lr && lr.c(), ar = empty$2();
    },
    m(ur, dr) {
      lr && lr.m(ur, dr), insert(ur, ar, dr);
    },
    p(ur, [dr]) {
      /*language*/
      ur[0] && /*code*/
      ur[1] ? lr ? lr.p(ur, dr) : (lr = create_if_block$9(ur), lr.c(), lr.m(ar.parentNode, ar)) : lr && (lr.d(1), lr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), lr && lr.d(ur);
    }
  };
}
const cBase$1 = "overflow-hidden shadow", cHeader = "text-xs text-white/50 uppercase flex justify-between items-center p-2 pl-4", cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(cr) {
  return cr === "js" ? "javascript" : cr === "ts" ? "typescript" : cr === "shell" ? "terminal" : cr;
}
function instance$e(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, storeHighlightJs, (Mr) => lr(17, dr = Mr));
  const fr = createEventDispatcher();
  let { language: gr = "plaintext" } = ar, { code: mr = "" } = ar, { lineNumbers: vr = !1 } = ar, { background: yr = "bg-neutral-900/90" } = ar, { blur: _r = "" } = ar, { text: kr = "text-sm" } = ar, { color: xr = "text-white" } = ar, { rounded: Ar = "rounded-container-token" } = ar, { shadow: Er = "shadow" } = ar, { button: Cr = "btn btn-sm variant-soft !text-white" } = ar, { buttonLabel: Tr = "Copy" } = ar, { buttonCopied: Sr = "" } = ar, Lr = !1, Ir = mr, Nr = !1;
  function Rr() {
    lr(7, Nr = !0), setTimeout(
      () => {
        lr(7, Nr = !1);
      },
      2e3
    ), fr("copy");
  }
  return cr.$$set = (Mr) => {
    lr(19, ar = assign$1(assign$1({}, ar), exclude_internal_props(Mr))), "language" in Mr && lr(0, gr = Mr.language), "code" in Mr && lr(1, mr = Mr.code), "lineNumbers" in Mr && lr(10, vr = Mr.lineNumbers), "background" in Mr && lr(11, yr = Mr.background), "blur" in Mr && lr(12, _r = Mr.blur), "text" in Mr && lr(13, kr = Mr.text), "color" in Mr && lr(14, xr = Mr.color), "rounded" in Mr && lr(15, Ar = Mr.rounded), "shadow" in Mr && lr(16, Er = Mr.shadow), "button" in Mr && lr(2, Cr = Mr.button), "buttonLabel" in Mr && lr(3, Tr = Mr.buttonLabel), "buttonCopied" in Mr && lr(4, Sr = Mr.buttonCopied);
  }, cr.$$.update = () => {
    var Mr;
    cr.$$.dirty & /*$storeHighlightJs, code, language*/
    131075 && dr !== void 0 && (lr(5, Ir = dr.highlight(mr, { language: gr }).value.trim()), lr(6, Lr = !0)), cr.$$.dirty & /*lineNumbers, displayCode*/
    1056 && vr && (lr(5, Ir = Ir.replace(/^/gm, () => '<span class="line"></span>	')), lr(6, Lr = !0)), lr(8, ur = `${cBase$1} ${yr} ${_r} ${kr} ${xr} ${Ar} ${Er} ${(Mr = ar.class) != null ? Mr : ""}`);
  }, ar = exclude_internal_props(ar), [
    gr,
    mr,
    Cr,
    Tr,
    Sr,
    Ir,
    Lr,
    Nr,
    ur,
    Rr,
    vr,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Er,
    dr
  ];
}
let CodeBlock$2 = class extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$e, create_fragment$z, safe_not_equal, {
      language: 0,
      code: 1,
      lineNumbers: 10,
      background: 11,
      blur: 12,
      text: 13,
      color: 14,
      rounded: 15,
      shadow: 16,
      button: 2,
      buttonLabel: 3,
      buttonCopied: 4
    });
  }
  get language() {
    return this.$$.ctx[0];
  }
  set language(ar) {
    this.$$set({ language: ar }), flush();
  }
  get code() {
    return this.$$.ctx[1];
  }
  set code(ar) {
    this.$$set({ code: ar }), flush();
  }
  get lineNumbers() {
    return this.$$.ctx[10];
  }
  set lineNumbers(ar) {
    this.$$set({ lineNumbers: ar }), flush();
  }
  get background() {
    return this.$$.ctx[11];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[12];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get text() {
    return this.$$.ctx[13];
  }
  set text(ar) {
    this.$$set({ text: ar }), flush();
  }
  get color() {
    return this.$$.ctx[14];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[15];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[16];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get button() {
    return this.$$.ctx[2];
  }
  set button(ar) {
    this.$$set({ button: ar }), flush();
  }
  get buttonLabel() {
    return this.$$.ctx[3];
  }
  set buttonLabel(ar) {
    this.$$set({ buttonLabel: ar }), flush();
  }
  get buttonCopied() {
    return this.$$.ctx[4];
  }
  set buttonCopied(ar) {
    this.$$set({ buttonCopied: ar }), flush();
  }
};
create_custom_element(CodeBlock$2, { language: {}, code: {}, lineNumbers: { type: "Boolean" }, background: {}, blur: {}, text: {}, color: {}, rounded: {}, shadow: {}, button: {}, buttonLabel: {}, buttonCopied: {} }, [], [], !0);
function create_if_block$8(cr) {
  let ar = (
    /*$modalStore*/
    cr[13]
  ), lr, ur, dr = create_key_block(cr);
  return {
    c() {
      dr.c(), lr = empty$2();
    },
    m(fr, gr) {
      dr.m(fr, gr), insert(fr, lr, gr), ur = !0;
    },
    p(fr, gr) {
      gr[0] & /*$modalStore*/
      8192 && safe_not_equal(ar, ar = /*$modalStore*/
      fr[13]) ? (group_outros(), transition_out(dr, 1, 1, noop$1), check_outros(), dr = create_key_block(fr), dr.c(), transition_in(dr, 1), dr.m(lr.parentNode, lr)) : dr.p(fr, gr);
    },
    i(fr) {
      ur || (transition_in(dr), ur = !0);
    },
    o(fr) {
      transition_out(dr), ur = !1;
    },
    d(fr) {
      fr && detach(lr), dr.d(fr);
    }
  };
}
function create_else_block$4(cr) {
  let ar, lr, ur, dr, fr, gr;
  const mr = [create_if_block_8$1, create_else_block_1$2], vr = [];
  function yr(_r, kr) {
    var xr;
    return (
      /*currentComponent*/
      (xr = _r[15]) != null && xr.slot ? 0 : 1
    );
  }
  return lr = yr(cr), ur = vr[lr] = mr[lr](cr), {
    c() {
      var _r, kr, xr;
      ar = element("div"), ur.c(), attr(ar, "class", dr = "modal contents " + /*$modalStore*/
      ((kr = (_r = cr[13][0]) == null ? void 0 : _r.modalClasses) != null ? kr : "")), attr(ar, "data-testid", "modal-component"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", fr = /*$modalStore*/
      (xr = cr[13][0].title) != null ? xr : "");
    },
    m(_r, kr) {
      insert(_r, ar, kr), vr[lr].m(ar, null), gr = !0;
    },
    p(_r, kr) {
      var Ar, Er, Cr;
      let xr = lr;
      lr = yr(_r), lr === xr ? vr[lr].p(_r, kr) : (group_outros(), transition_out(vr[xr], 1, 1, () => {
        vr[xr] = null;
      }), check_outros(), ur = vr[lr], ur ? ur.p(_r, kr) : (ur = vr[lr] = mr[lr](_r), ur.c()), transition_in(ur, 1), ur.m(ar, null)), (!gr || kr[0] & /*$modalStore*/
      8192 && dr !== (dr = "modal contents " + /*$modalStore*/
      ((Er = (Ar = _r[13][0]) == null ? void 0 : Ar.modalClasses) != null ? Er : ""))) && attr(ar, "class", dr), (!gr || kr[0] & /*$modalStore*/
      8192 && fr !== (fr = /*$modalStore*/
      (Cr = _r[13][0].title) != null ? Cr : "")) && attr(ar, "aria-label", fr);
    },
    i(_r) {
      gr || (transition_in(ur), gr = !0);
    },
    o(_r) {
      transition_out(ur), gr = !1;
    },
    d(_r) {
      _r && detach(ar), vr[lr].d();
    }
  };
}
function create_if_block_1$4(cr) {
  var Ar, Er, Cr, Tr;
  let ar, lr, ur, dr, fr, gr, mr = (
    /*$modalStore*/
    ((Ar = cr[13][0]) == null ? void 0 : Ar.title) && create_if_block_7$1(cr)
  ), vr = (
    /*$modalStore*/
    ((Er = cr[13][0]) == null ? void 0 : Er.body) && create_if_block_6$1(cr)
  ), yr = (
    /*$modalStore*/
    ((Cr = cr[13][0]) == null ? void 0 : Cr.image) && typeof /*$modalStore*/
    ((Tr = cr[13][0]) == null ? void 0 : Tr.image) == "string" && create_if_block_5$2(cr)
  );
  function _r(Sr, Lr) {
    if (
      /*$modalStore*/
      Sr[13][0].type === "alert"
    )
      return create_if_block_2$3;
    if (
      /*$modalStore*/
      Sr[13][0].type === "confirm"
    )
      return create_if_block_3$3;
    if (
      /*$modalStore*/
      Sr[13][0].type === "prompt"
    )
      return create_if_block_4$2;
  }
  let kr = _r(cr), xr = kr && kr(cr);
  return {
    c() {
      var Sr;
      ar = element("div"), mr && mr.c(), lr = space(), vr && vr.c(), ur = space(), yr && yr.c(), dr = space(), xr && xr.c(), attr(ar, "class", fr = "modal " + /*classesModal*/
      cr[17]), attr(ar, "data-testid", "modal"), attr(ar, "role", "dialog"), attr(ar, "aria-modal", "true"), attr(ar, "aria-label", gr = /*$modalStore*/
      (Sr = cr[13][0].title) != null ? Sr : "");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), mr && mr.m(ar, null), append(ar, lr), vr && vr.m(ar, null), append(ar, ur), yr && yr.m(ar, null), append(ar, dr), xr && xr.m(ar, null);
    },
    p(Sr, Lr) {
      var Ir, Nr, Rr, Mr, Br;
      /*$modalStore*/
      (Ir = Sr[13][0]) != null && Ir.title ? mr ? mr.p(Sr, Lr) : (mr = create_if_block_7$1(Sr), mr.c(), mr.m(ar, lr)) : mr && (mr.d(1), mr = null), /*$modalStore*/
      (Nr = Sr[13][0]) != null && Nr.body ? vr ? vr.p(Sr, Lr) : (vr = create_if_block_6$1(Sr), vr.c(), vr.m(ar, ur)) : vr && (vr.d(1), vr = null), /*$modalStore*/
      (Rr = Sr[13][0]) != null && Rr.image && typeof /*$modalStore*/
      ((Mr = Sr[13][0]) == null ? void 0 : Mr.image) == "string" ? yr ? yr.p(Sr, Lr) : (yr = create_if_block_5$2(Sr), yr.c(), yr.m(ar, dr)) : yr && (yr.d(1), yr = null), kr === (kr = _r(Sr)) && xr ? xr.p(Sr, Lr) : (xr && xr.d(1), xr = kr && kr(Sr), xr && (xr.c(), xr.m(ar, null))), Lr[0] & /*classesModal*/
      131072 && fr !== (fr = "modal " + /*classesModal*/
      Sr[17]) && attr(ar, "class", fr), Lr[0] & /*$modalStore*/
      8192 && gr !== (gr = /*$modalStore*/
      (Br = Sr[13][0].title) != null ? Br : "") && attr(ar, "aria-label", gr);
    },
    i: noop$1,
    o: noop$1,
    d(Sr) {
      Sr && detach(ar), mr && mr.d(), vr && vr.d(), yr && yr.d(), xr && xr.d();
    }
  };
}
function create_else_block_1$2(cr) {
  var mr, vr;
  let ar, lr, ur;
  const dr = [
    /*currentComponent*/
    (mr = cr[15]) == null ? void 0 : mr.props,
    { parent: (
      /*parent*/
      cr[16]
    ) }
  ];
  var fr = (
    /*currentComponent*/
    (vr = cr[15]) == null ? void 0 : vr.ref
  );
  function gr(yr, _r) {
    var xr;
    let kr = {};
    if (_r !== void 0 && _r[0] & /*currentComponent, parent*/
    98304)
      kr = get_spread_update(dr, [
        _r[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (xr = yr[15]) == null ? void 0 : xr.props
        ),
        _r[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          yr[16]
        ) }
      ]);
    else
      for (let Ar = 0; Ar < dr.length; Ar += 1)
        kr = assign$1(kr, dr[Ar]);
    return { props: kr };
  }
  return fr && (ar = construct_svelte_component(fr, gr(cr))), {
    c() {
      ar && create_component(ar.$$.fragment), lr = empty$2();
    },
    m(yr, _r) {
      ar && mount_component(ar, yr, _r), insert(yr, lr, _r), ur = !0;
    },
    p(yr, _r) {
      var kr, xr;
      if (_r[0] & /*currentComponent*/
      32768 && fr !== (fr = /*currentComponent*/
      (kr = yr[15]) == null ? void 0 : kr.ref)) {
        if (ar) {
          group_outros();
          const Ar = ar;
          transition_out(Ar.$$.fragment, 1, 0, () => {
            destroy_component(Ar, 1);
          }), check_outros();
        }
        fr ? (ar = construct_svelte_component(fr, gr(yr, _r)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, lr.parentNode, lr)) : ar = null;
      } else if (fr) {
        const Ar = _r[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(dr, [
          _r[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (xr = yr[15]) == null ? void 0 : xr.props
          ),
          _r[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            yr[16]
          ) }
        ]) : {};
        ar.$set(Ar);
      }
    },
    i(yr) {
      ur || (ar && transition_in(ar.$$.fragment, yr), ur = !0);
    },
    o(yr) {
      ar && transition_out(ar.$$.fragment, yr), ur = !1;
    },
    d(yr) {
      yr && detach(lr), ar && destroy_component(ar, yr);
    }
  };
}
function create_if_block_8$1(cr) {
  var mr, vr;
  let ar, lr, ur;
  const dr = [
    /*currentComponent*/
    (mr = cr[15]) == null ? void 0 : mr.props,
    { parent: (
      /*parent*/
      cr[16]
    ) }
  ];
  var fr = (
    /*currentComponent*/
    (vr = cr[15]) == null ? void 0 : vr.ref
  );
  function gr(yr, _r) {
    var xr;
    let kr = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: yr }
    };
    if (_r !== void 0 && _r[0] & /*currentComponent, parent*/
    98304)
      kr = get_spread_update(dr, [
        _r[0] & /*currentComponent*/
        32768 && get_spread_object(
          /*currentComponent*/
          (xr = yr[15]) == null ? void 0 : xr.props
        ),
        _r[0] & /*parent*/
        65536 && { parent: (
          /*parent*/
          yr[16]
        ) }
      ]);
    else
      for (let Ar = 0; Ar < dr.length; Ar += 1)
        kr = assign$1(kr, dr[Ar]);
    return { props: kr };
  }
  return fr && (ar = construct_svelte_component(fr, gr(cr))), {
    c() {
      ar && create_component(ar.$$.fragment), lr = empty$2();
    },
    m(yr, _r) {
      ar && mount_component(ar, yr, _r), insert(yr, lr, _r), ur = !0;
    },
    p(yr, _r) {
      var kr, xr;
      if (_r[0] & /*currentComponent*/
      32768 && fr !== (fr = /*currentComponent*/
      (kr = yr[15]) == null ? void 0 : kr.ref)) {
        if (ar) {
          group_outros();
          const Ar = ar;
          transition_out(Ar.$$.fragment, 1, 0, () => {
            destroy_component(Ar, 1);
          }), check_outros();
        }
        fr ? (ar = construct_svelte_component(fr, gr(yr, _r)), create_component(ar.$$.fragment), transition_in(ar.$$.fragment, 1), mount_component(ar, lr.parentNode, lr)) : ar = null;
      } else if (fr) {
        const Ar = _r[0] & /*currentComponent, parent*/
        98304 ? get_spread_update(dr, [
          _r[0] & /*currentComponent*/
          32768 && get_spread_object(
            /*currentComponent*/
            (xr = yr[15]) == null ? void 0 : xr.props
          ),
          _r[0] & /*parent*/
          65536 && { parent: (
            /*parent*/
            yr[16]
          ) }
        ]) : {};
        _r[0] & /*currentComponent*/
        32768 | _r[1] & /*$$scope*/
        65536 && (Ar.$$scope = { dirty: _r, ctx: yr }), ar.$set(Ar);
      }
    },
    i(yr) {
      ur || (ar && transition_in(ar.$$.fragment, yr), ur = !0);
    },
    o(yr) {
      ar && transition_out(ar.$$.fragment, yr), ur = !1;
    },
    d(yr) {
      yr && detach(lr), ar && destroy_component(ar, yr);
    }
  };
}
function create_default_slot(cr) {
  var dr;
  let ar, lr = (
    /*currentComponent*/
    ((dr = cr[15]) == null ? void 0 : dr.slot) + ""
  ), ur;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$2(), ar.a = ur;
    },
    m(fr, gr) {
      ar.m(lr, fr, gr), insert(fr, ur, gr);
    },
    p(fr, gr) {
      var mr;
      gr[0] & /*currentComponent*/
      32768 && lr !== (lr = /*currentComponent*/
      ((mr = fr[15]) == null ? void 0 : mr.slot) + "") && ar.p(lr);
    },
    d(fr) {
      fr && (detach(ur), ar.d());
    }
  };
}
function create_if_block_7$1(cr) {
  let ar, lr = (
    /*$modalStore*/
    cr[13][0].title + ""
  ), ur;
  return {
    c() {
      ar = element("header"), attr(ar, "class", ur = "modal-header " + /*regionHeader*/
      cr[5]);
    },
    m(dr, fr) {
      insert(dr, ar, fr), ar.innerHTML = lr;
    },
    p(dr, fr) {
      fr[0] & /*$modalStore*/
      8192 && lr !== (lr = /*$modalStore*/
      dr[13][0].title + "") && (ar.innerHTML = lr), fr[0] & /*regionHeader*/
      32 && ur !== (ur = "modal-header " + /*regionHeader*/
      dr[5]) && attr(ar, "class", ur);
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block_6$1(cr) {
  let ar, lr = (
    /*$modalStore*/
    cr[13][0].body + ""
  ), ur;
  return {
    c() {
      ar = element("article"), attr(ar, "class", ur = "modal-body " + /*regionBody*/
      cr[6]);
    },
    m(dr, fr) {
      insert(dr, ar, fr), ar.innerHTML = lr;
    },
    p(dr, fr) {
      fr[0] & /*$modalStore*/
      8192 && lr !== (lr = /*$modalStore*/
      dr[13][0].body + "") && (ar.innerHTML = lr), fr[0] & /*regionBody*/
      64 && ur !== (ur = "modal-body " + /*regionBody*/
      dr[6]) && attr(ar, "class", ur);
    },
    d(dr) {
      dr && detach(ar);
    }
  };
}
function create_if_block_5$2(cr) {
  let ar, lr;
  return {
    c() {
      var ur;
      ar = element("img"), attr(ar, "class", "modal-image " + cModalImage), src_url_equal(ar.src, lr = /*$modalStore*/
      (ur = cr[13][0]) == null ? void 0 : ur.image) || attr(ar, "src", lr), attr(ar, "alt", "Modal");
    },
    m(ur, dr) {
      insert(ur, ar, dr);
    },
    p(ur, dr) {
      var fr;
      dr[0] & /*$modalStore*/
      8192 && !src_url_equal(ar.src, lr = /*$modalStore*/
      (fr = ur[13][0]) == null ? void 0 : fr.image) && attr(ar, "src", lr);
    },
    d(ur) {
      ur && detach(ar);
    }
  };
}
function create_if_block_4$2(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr = [
    { class: "modal-prompt-input input" },
    { name: "prompt" },
    { type: "text" },
    /*$modalStore*/
    cr[13][0].valueAttr
  ], Tr = {};
  for (let Sr = 0; Sr < Cr.length; Sr += 1)
    Tr = assign$1(Tr, Cr[Sr]);
  return {
    c() {
      ar = element("form"), lr = element("input"), ur = space(), dr = element("footer"), fr = element("button"), gr = text$3(
        /*buttonTextCancel*/
        cr[0]
      ), vr = space(), yr = element("button"), _r = text$3(
        /*buttonTextSubmit*/
        cr[2]
      ), set_attributes(lr, Tr), attr(fr, "type", "button"), attr(fr, "class", mr = "btn " + /*buttonNeutral*/
      cr[3]), attr(yr, "type", "submit"), attr(yr, "class", kr = "btn " + /*buttonPositive*/
      cr[4]), attr(dr, "class", xr = "modal-footer " + /*regionFooter*/
      cr[7]), attr(ar, "class", "space-y-4");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), lr.autofocus && lr.focus(), set_input_value(
        lr,
        /*promptValue*/
        cr[14]
      ), append(ar, ur), append(ar, dr), append(dr, fr), append(fr, gr), append(dr, vr), append(dr, yr), append(yr, _r), Ar || (Er = [
        listen(
          lr,
          "input",
          /*input_input_handler*/
          cr[41]
        ),
        listen(
          fr,
          "click",
          /*onClose*/
          cr[23]
        ),
        listen(
          ar,
          "submit",
          /*onPromptSubmit*/
          cr[25]
        )
      ], Ar = !0);
    },
    p(Sr, Lr) {
      set_attributes(lr, Tr = get_spread_update(Cr, [
        { class: "modal-prompt-input input" },
        { name: "prompt" },
        { type: "text" },
        Lr[0] & /*$modalStore*/
        8192 && /*$modalStore*/
        Sr[13][0].valueAttr
      ])), Lr[0] & /*promptValue*/
      16384 && lr.value !== /*promptValue*/
      Sr[14] && set_input_value(
        lr,
        /*promptValue*/
        Sr[14]
      ), Lr[0] & /*buttonTextCancel*/
      1 && set_data(
        gr,
        /*buttonTextCancel*/
        Sr[0]
      ), Lr[0] & /*buttonNeutral*/
      8 && mr !== (mr = "btn " + /*buttonNeutral*/
      Sr[3]) && attr(fr, "class", mr), Lr[0] & /*buttonTextSubmit*/
      4 && set_data(
        _r,
        /*buttonTextSubmit*/
        Sr[2]
      ), Lr[0] & /*buttonPositive*/
      16 && kr !== (kr = "btn " + /*buttonPositive*/
      Sr[4]) && attr(yr, "class", kr), Lr[0] & /*regionFooter*/
      128 && xr !== (xr = "modal-footer " + /*regionFooter*/
      Sr[7]) && attr(dr, "class", xr);
    },
    d(Sr) {
      Sr && detach(ar), Ar = !1, run_all(Er);
    }
  };
}
function create_if_block_3$3(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr;
  return {
    c() {
      ar = element("footer"), lr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        cr[0]
      ), fr = space(), gr = element("button"), mr = text$3(
        /*buttonTextConfirm*/
        cr[1]
      ), attr(lr, "type", "button"), attr(lr, "class", dr = "btn " + /*buttonNeutral*/
      cr[3]), attr(gr, "type", "button"), attr(gr, "class", vr = "btn " + /*buttonPositive*/
      cr[4]), attr(ar, "class", yr = "modal-footer " + /*regionFooter*/
      cr[7]);
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), append(ar, lr), append(lr, ur), append(ar, fr), append(ar, gr), append(gr, mr), _r || (kr = [
        listen(
          lr,
          "click",
          /*onClose*/
          cr[23]
        ),
        listen(
          gr,
          "click",
          /*onConfirm*/
          cr[24]
        )
      ], _r = !0);
    },
    p(xr, Ar) {
      Ar[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        xr[0]
      ), Ar[0] & /*buttonNeutral*/
      8 && dr !== (dr = "btn " + /*buttonNeutral*/
      xr[3]) && attr(lr, "class", dr), Ar[0] & /*buttonTextConfirm*/
      2 && set_data(
        mr,
        /*buttonTextConfirm*/
        xr[1]
      ), Ar[0] & /*buttonPositive*/
      16 && vr !== (vr = "btn " + /*buttonPositive*/
      xr[4]) && attr(gr, "class", vr), Ar[0] & /*regionFooter*/
      128 && yr !== (yr = "modal-footer " + /*regionFooter*/
      xr[7]) && attr(ar, "class", yr);
    },
    d(xr) {
      xr && detach(ar), _r = !1, run_all(kr);
    }
  };
}
function create_if_block_2$3(cr) {
  let ar, lr, ur, dr, fr, gr, mr;
  return {
    c() {
      ar = element("footer"), lr = element("button"), ur = text$3(
        /*buttonTextCancel*/
        cr[0]
      ), attr(lr, "type", "button"), attr(lr, "class", dr = "btn " + /*buttonNeutral*/
      cr[3]), attr(ar, "class", fr = "modal-footer " + /*regionFooter*/
      cr[7]);
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, lr), append(lr, ur), gr || (mr = listen(
        lr,
        "click",
        /*onClose*/
        cr[23]
      ), gr = !0);
    },
    p(vr, yr) {
      yr[0] & /*buttonTextCancel*/
      1 && set_data(
        ur,
        /*buttonTextCancel*/
        vr[0]
      ), yr[0] & /*buttonNeutral*/
      8 && dr !== (dr = "btn " + /*buttonNeutral*/
      vr[3]) && attr(lr, "class", dr), yr[0] & /*regionFooter*/
      128 && fr !== (fr = "modal-footer " + /*regionFooter*/
      vr[7]) && attr(ar, "class", fr);
    },
    d(vr) {
      vr && detach(ar), gr = !1, mr();
    }
  };
}
function create_key_block(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr;
  const Ar = [create_if_block_1$4, create_else_block$4], Er = [];
  function Cr(Tr, Sr) {
    return (
      /*$modalStore*/
      Tr[13][0].type !== "component" ? 0 : 1
    );
  }
  return ur = Cr(cr), dr = Er[ur] = Ar[ur](cr), {
    c() {
      ar = element("div"), lr = element("div"), dr.c(), attr(lr, "class", fr = "modal-transition " + /*classesTransitionLayer*/
      cr[18]), attr(ar, "class", vr = "modal-backdrop " + /*classesBackdrop*/
      cr[19]), attr(ar, "data-testid", "modal-backdrop");
    },
    m(Tr, Sr) {
      insert(Tr, ar, Sr), append(ar, lr), Er[ur].m(lr, null), _r = !0, kr || (xr = [
        listen(
          ar,
          "mousedown",
          /*onBackdropInteractionBegin*/
          cr[21]
        ),
        listen(
          ar,
          "mouseup",
          /*onBackdropInteractionEnd*/
          cr[22]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          cr[39],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          cr[40],
          { passive: !0 }
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], kr = !0);
    },
    p(Tr, Sr) {
      cr = Tr;
      let Lr = ur;
      ur = Cr(cr), ur === Lr ? Er[ur].p(cr, Sr) : (group_outros(), transition_out(Er[Lr], 1, 1, () => {
        Er[Lr] = null;
      }), check_outros(), dr = Er[ur], dr ? dr.p(cr, Sr) : (dr = Er[ur] = Ar[ur](cr), dr.c()), transition_in(dr, 1), dr.m(lr, null)), (!_r || Sr[0] & /*classesTransitionLayer*/
      262144 && fr !== (fr = "modal-transition " + /*classesTransitionLayer*/
      cr[18])) && attr(lr, "class", fr), (!_r || Sr[0] & /*classesBackdrop*/
      524288 && vr !== (vr = "modal-backdrop " + /*classesBackdrop*/
      cr[19])) && attr(ar, "class", vr);
    },
    i(Tr) {
      _r || (transition_in(dr), add_render_callback(() => {
        _r && (mr && mr.end(1), gr = create_in_transition(lr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            cr[9]
          ),
          params: (
            /*transitionInParams*/
            cr[10]
          ),
          enabled: (
            /*transitions*/
            cr[8]
          )
        }), gr.start());
      }), add_render_callback(() => {
        _r && (yr || (yr = create_bidirectional_transition(
          ar,
          dynamicTransition,
          {
            transition: fade,
            params: { duration: 150 },
            enabled: (
              /*transitions*/
              cr[8]
            )
          },
          !0
        )), yr.run(1));
      }), _r = !0);
    },
    o(Tr) {
      transition_out(dr), gr && gr.invalidate(), mr = create_out_transition(lr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          cr[11]
        ),
        params: (
          /*transitionOutParams*/
          cr[12]
        ),
        enabled: (
          /*transitions*/
          cr[8]
        )
      }), yr || (yr = create_bidirectional_transition(
        ar,
        dynamicTransition,
        {
          transition: fade,
          params: { duration: 150 },
          enabled: (
            /*transitions*/
            cr[8]
          )
        },
        !1
      )), yr.run(0), _r = !1;
    },
    d(Tr) {
      Tr && detach(ar), Er[ur].d(), Tr && mr && mr.end(), Tr && yr && yr.end(), kr = !1, run_all(xr);
    }
  };
}
function create_fragment$y(cr) {
  let ar, lr, ur, dr, fr = (
    /*$modalStore*/
    cr[13].length > 0 && create_if_block$8(cr)
  );
  return {
    c() {
      fr && fr.c(), ar = empty$2();
    },
    m(gr, mr) {
      fr && fr.m(gr, mr), insert(gr, ar, mr), lr = !0, ur || (dr = listen(
        window,
        "keydown",
        /*onKeyDown*/
        cr[26]
      ), ur = !0);
    },
    p(gr, mr) {
      /*$modalStore*/
      gr[13].length > 0 ? fr ? (fr.p(gr, mr), mr[0] & /*$modalStore*/
      8192 && transition_in(fr, 1)) : (fr = create_if_block$8(gr), fr.c(), transition_in(fr, 1), fr.m(ar.parentNode, ar)) : fr && (group_outros(), transition_out(fr, 1, 1, () => {
        fr = null;
      }), check_outros());
    },
    i(gr) {
      lr || (transition_in(fr), lr = !0);
    },
    o(gr) {
      transition_out(fr), lr = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr), ur = !1, dr();
    }
  };
}
const cBackdrop$1 = "fixed top-0 left-0 right-0 bottom-0 overflow-y-auto", cTransitionLayer = "w-full h-fit min-h-full p-4 overflow-y-auto flex justify-center", cModal = "block overflow-y-auto", cModalImage = "w-full h-auto";
function instance$d(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr;
  component_subscribe(cr, prefersReducedMotionStore, (oi) => lr(43, yr = oi));
  const _r = createEventDispatcher();
  let { position: kr = "items-center" } = ar, { components: xr = {} } = ar, { background: Ar = "bg-surface-100-800-token" } = ar, { width: Er = "w-modal" } = ar, { height: Cr = "h-auto" } = ar, { padding: Tr = "p-4" } = ar, { spacing: Sr = "space-y-4" } = ar, { rounded: Lr = "rounded-container-token" } = ar, { shadow: Ir = "shadow-xl" } = ar, { zIndex: Nr = "z-[999]" } = ar, { buttonNeutral: Rr = "variant-ghost-surface" } = ar, { buttonPositive: Mr = "variant-filled" } = ar, { buttonTextCancel: Br = "Cancel" } = ar, { buttonTextConfirm: Dr = "Confirm" } = ar, { buttonTextSubmit: Hr = "Submit" } = ar, { regionBackdrop: Fr = "bg-surface-backdrop-token" } = ar, { regionHeader: zr = "text-2xl font-bold" } = ar, { regionBody: Ur = "max-h-[200px] overflow-hidden" } = ar, { regionFooter: jr = "flex justify-end space-x-2" } = ar, { transitions: Yr = !yr } = ar, { transitionIn: qr = fly } = ar, { transitionInParams: Wr = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, { transitionOut: Jr = fly } = ar, { transitionOutParams: Gr = { duration: 150, opacity: 0, x: 0, y: 100 } } = ar, Vr;
  const Qr = {
    buttonTextCancel: Br,
    buttonTextConfirm: Dr,
    buttonTextSubmit: Hr
  };
  let $r, Xr = !1;
  const si = getModalStore();
  component_subscribe(cr, si, (oi) => lr(13, vr = oi)), si.subscribe((oi) => {
    oi.length && (oi[0].type === "prompt" && lr(14, Vr = oi[0].value), lr(0, Br = oi[0].buttonTextCancel || Qr.buttonTextCancel), lr(1, Dr = oi[0].buttonTextConfirm || Qr.buttonTextConfirm), lr(2, Hr = oi[0].buttonTextSubmit || Qr.buttonTextSubmit), lr(15, $r = typeof oi[0].component == "string" ? xr[oi[0].component] : oi[0].component));
  });
  function Zr(oi) {
    if (!(oi.target instanceof Element))
      return;
    const Ri = oi.target.classList;
    (Ri.contains("modal-backdrop") || Ri.contains("modal-transition")) && (Xr = !0);
  }
  function li(oi) {
    if (!(oi.target instanceof Element))
      return;
    const Ri = oi.target.classList;
    (Ri.contains("modal-backdrop") || Ri.contains("modal-transition")) && Xr && (vr[0].response && vr[0].response(void 0), si.close(), _r("backdrop", oi)), Xr = !1;
  }
  function Ei() {
    vr[0].response && vr[0].response(!1), si.close();
  }
  function ki() {
    vr[0].response && vr[0].response(!0), si.close();
  }
  function Di(oi) {
    oi.preventDefault(), vr[0].response && vr[0].response(Vr), si.close();
  }
  function hi(oi) {
    vr.length && oi.code === "Escape" && Ei();
  }
  function Ti(oi) {
    bubble.call(this, cr, oi);
  }
  function fi(oi) {
    bubble.call(this, cr, oi);
  }
  function Mi() {
    Vr = this.value, lr(14, Vr);
  }
  return cr.$$set = (oi) => {
    lr(46, ar = assign$1(assign$1({}, ar), exclude_internal_props(oi))), "position" in oi && lr(27, kr = oi.position), "components" in oi && lr(28, xr = oi.components), "background" in oi && lr(29, Ar = oi.background), "width" in oi && lr(30, Er = oi.width), "height" in oi && lr(31, Cr = oi.height), "padding" in oi && lr(32, Tr = oi.padding), "spacing" in oi && lr(33, Sr = oi.spacing), "rounded" in oi && lr(34, Lr = oi.rounded), "shadow" in oi && lr(35, Ir = oi.shadow), "zIndex" in oi && lr(36, Nr = oi.zIndex), "buttonNeutral" in oi && lr(3, Rr = oi.buttonNeutral), "buttonPositive" in oi && lr(4, Mr = oi.buttonPositive), "buttonTextCancel" in oi && lr(0, Br = oi.buttonTextCancel), "buttonTextConfirm" in oi && lr(1, Dr = oi.buttonTextConfirm), "buttonTextSubmit" in oi && lr(2, Hr = oi.buttonTextSubmit), "regionBackdrop" in oi && lr(37, Fr = oi.regionBackdrop), "regionHeader" in oi && lr(5, zr = oi.regionHeader), "regionBody" in oi && lr(6, Ur = oi.regionBody), "regionFooter" in oi && lr(7, jr = oi.regionFooter), "transitions" in oi && lr(8, Yr = oi.transitions), "transitionIn" in oi && lr(9, qr = oi.transitionIn), "transitionInParams" in oi && lr(10, Wr = oi.transitionInParams), "transitionOut" in oi && lr(11, Jr = oi.transitionOut), "transitionOutParams" in oi && lr(12, Gr = oi.transitionOutParams);
  }, cr.$$.update = () => {
    var oi, Ri, qi, zi, to, Hi, _i;
    cr.$$.dirty[0] & /*$modalStore, position*/
    134225920 && lr(38, ur = (Ri = (oi = vr[0]) == null ? void 0 : oi.position) != null ? Ri : kr), lr(19, dr = `${cBackdrop$1} ${Fr} ${Nr} ${(qi = ar.class) != null ? qi : ""} ${(to = (zi = vr[0]) == null ? void 0 : zi.backdropClasses) != null ? to : ""}`), cr.$$.dirty[1] & /*cPosition*/
    128 && lr(18, fr = `${cTransitionLayer} ${ur != null ? ur : ""}`), cr.$$.dirty[0] & /*background, width, $modalStore*/
    1610620928 | cr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow*/
    31 && lr(17, gr = `${cModal} ${Ar} ${Er} ${Cr} ${Tr} ${Sr} ${Lr} ${Ir} ${(_i = (Hi = vr[0]) == null ? void 0 : Hi.modalClasses) != null ? _i : ""}`), cr.$$.dirty[0] & /*position, background, width, buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionHeader, regionBody, regionFooter*/
    1744830719 | cr.$$.dirty[1] & /*height, padding, spacing, rounded, shadow, regionBackdrop*/
    95 && lr(16, mr = {
      position: kr,
      // ---
      background: Ar,
      width: Er,
      height: Cr,
      padding: Tr,
      spacing: Sr,
      rounded: Lr,
      shadow: Ir,
      // ---
      buttonNeutral: Rr,
      buttonPositive: Mr,
      buttonTextCancel: Br,
      buttonTextConfirm: Dr,
      buttonTextSubmit: Hr,
      // ---
      regionBackdrop: Fr,
      regionHeader: zr,
      regionBody: Ur,
      regionFooter: jr,
      // ---
      onClose: Ei
    });
  }, ar = exclude_internal_props(ar), [
    Br,
    Dr,
    Hr,
    Rr,
    Mr,
    zr,
    Ur,
    jr,
    Yr,
    qr,
    Wr,
    Jr,
    Gr,
    vr,
    Vr,
    $r,
    mr,
    gr,
    fr,
    dr,
    si,
    Zr,
    li,
    Ei,
    ki,
    Di,
    hi,
    kr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Fr,
    ur,
    Ti,
    fi,
    Mi
  ];
}
class Modal extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$d,
      create_fragment$y,
      safe_not_equal,
      {
        position: 27,
        components: 28,
        background: 29,
        width: 30,
        height: 31,
        padding: 32,
        spacing: 33,
        rounded: 34,
        shadow: 35,
        zIndex: 36,
        buttonNeutral: 3,
        buttonPositive: 4,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 37,
        regionHeader: 5,
        regionBody: 6,
        regionFooter: 7,
        transitions: 8,
        transitionIn: 9,
        transitionInParams: 10,
        transitionOut: 11,
        transitionOutParams: 12
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[27];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get components() {
    return this.$$.ctx[28];
  }
  set components(ar) {
    this.$$set({ components: ar }), flush();
  }
  get background() {
    return this.$$.ctx[29];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[30];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[31];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[32];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[33];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[34];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[35];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[36];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonNeutral() {
    return this.$$.ctx[3];
  }
  set buttonNeutral(ar) {
    this.$$set({ buttonNeutral: ar }), flush();
  }
  get buttonPositive() {
    return this.$$.ctx[4];
  }
  set buttonPositive(ar) {
    this.$$set({ buttonPositive: ar }), flush();
  }
  get buttonTextCancel() {
    return this.$$.ctx[0];
  }
  set buttonTextCancel(ar) {
    this.$$set({ buttonTextCancel: ar }), flush();
  }
  get buttonTextConfirm() {
    return this.$$.ctx[1];
  }
  set buttonTextConfirm(ar) {
    this.$$set({ buttonTextConfirm: ar }), flush();
  }
  get buttonTextSubmit() {
    return this.$$.ctx[2];
  }
  set buttonTextSubmit(ar) {
    this.$$set({ buttonTextSubmit: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[37];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionHeader() {
    return this.$$.ctx[5];
  }
  set regionHeader(ar) {
    this.$$set({ regionHeader: ar }), flush();
  }
  get regionBody() {
    return this.$$.ctx[6];
  }
  set regionBody(ar) {
    this.$$set({ regionBody: ar }), flush();
  }
  get regionFooter() {
    return this.$$.ctx[7];
  }
  set regionFooter(ar) {
    this.$$set({ regionFooter: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[8];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[9];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[10];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[11];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[12];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Modal, { position: {}, components: {}, background: {}, width: {}, height: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonNeutral: {}, buttonPositive: {}, buttonTextCancel: {}, buttonTextConfirm: {}, buttonTextSubmit: {}, regionBackdrop: {}, regionHeader: {}, regionBody: {}, regionFooter: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
const { window: window_1 } = globals;
function create_if_block$7(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr;
  const xr = (
    /*#slots*/
    cr[32].default
  ), Ar = create_slot(
    xr,
    cr,
    /*$$scope*/
    cr[31],
    null
  );
  return {
    c() {
      ar = element("div"), lr = element("div"), Ar && Ar.c(), attr(lr, "class", ur = "drawer " + /*classesDrawer*/
      cr[8]), attr(lr, "data-testid", "drawer"), attr(lr, "role", "dialog"), attr(lr, "aria-modal", "true"), attr(
        lr,
        "aria-labelledby",
        /*labelledby*/
        cr[0]
      ), attr(
        lr,
        "aria-describedby",
        /*describedby*/
        cr[1]
      ), attr(ar, "class", gr = "drawer-backdrop " + /*classesBackdrop*/
      cr[9]), attr(ar, "data-testid", "drawer-backdrop");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, lr), Ar && Ar.m(lr, null), cr[36](lr), cr[37](ar), yr = !0, _r || (kr = [
        listen(
          ar,
          "mousedown",
          /*onDrawerInteraction*/
          cr[12]
        ),
        listen(
          ar,
          "touchstart",
          /*touchstart_handler*/
          cr[33],
          { passive: !0 }
        ),
        listen(
          ar,
          "touchend",
          /*touchend_handler*/
          cr[34],
          { passive: !0 }
        ),
        listen(
          ar,
          "keypress",
          /*keypress_handler*/
          cr[35]
        ),
        action_destroyer(focusTrap.call(null, ar, !0))
      ], _r = !0);
    },
    p(Er, Cr) {
      cr = Er, Ar && Ar.p && (!yr || Cr[1] & /*$$scope*/
      1) && update_slot_base(
        Ar,
        xr,
        cr,
        /*$$scope*/
        cr[31],
        yr ? get_slot_changes(
          xr,
          /*$$scope*/
          cr[31],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          cr[31]
        ),
        null
      ), (!yr || Cr[0] & /*classesDrawer*/
      256 && ur !== (ur = "drawer " + /*classesDrawer*/
      cr[8])) && attr(lr, "class", ur), (!yr || Cr[0] & /*labelledby*/
      1) && attr(
        lr,
        "aria-labelledby",
        /*labelledby*/
        cr[0]
      ), (!yr || Cr[0] & /*describedby*/
      2) && attr(
        lr,
        "aria-describedby",
        /*describedby*/
        cr[1]
      ), (!yr || Cr[0] & /*classesBackdrop*/
      512 && gr !== (gr = "drawer-backdrop " + /*classesBackdrop*/
      cr[9])) && attr(ar, "class", gr);
    },
    i(Er) {
      yr || (transition_in(Ar, Er), Er && add_render_callback(() => {
        yr && (fr && fr.end(1), dr = create_in_transition(lr, dynamicTransition, {
          transition: fly,
          params: {
            x: (
              /*anim*/
              cr[7].x
            ),
            y: (
              /*anim*/
              cr[7].y
            ),
            duration: (
              /*duration*/
              cr[2]
            ),
            opacity: (
              /*opacityTransition*/
              cr[3] ? void 0 : 1
            )
          },
          enabled: (
            /*transitions*/
            cr[4]
          )
        }), dr.start());
      }), Er && add_render_callback(() => {
        yr && (vr && vr.end(1), mr = create_in_transition(ar, dynamicTransition, {
          transition: fade,
          params: { duration: (
            /*duration*/
            cr[2]
          ) },
          enabled: (
            /*transitions*/
            cr[4] && /*opacityTransition*/
            cr[3]
          )
        }), mr.start());
      }), yr = !0);
    },
    o(Er) {
      transition_out(Ar, Er), dr && dr.invalidate(), Er && (fr = create_out_transition(lr, dynamicTransition, {
        transition: fly,
        params: {
          x: (
            /*anim*/
            cr[7].x
          ),
          y: (
            /*anim*/
            cr[7].y
          ),
          duration: (
            /*duration*/
            cr[2]
          ),
          opacity: (
            /*opacityTransition*/
            cr[3] ? void 0 : 1
          ),
          easing: cubicIn
        },
        enabled: (
          /*transitions*/
          cr[4]
        )
      })), mr && mr.invalidate(), Er && (vr = create_out_transition(ar, dynamicTransition, {
        transition: fade,
        params: { duration: (
          /*duration*/
          cr[2]
        ) },
        enabled: (
          /*transitions*/
          cr[4] && /*opacityTransition*/
          cr[3]
        )
      })), yr = !1;
    },
    d(Er) {
      Er && detach(ar), Ar && Ar.d(Er), cr[36](null), Er && fr && fr.end(), cr[37](null), Er && vr && vr.end(), _r = !1, run_all(kr);
    }
  };
}
function create_fragment$x(cr) {
  let ar, lr, ur, dr, fr = (
    /*$drawerStore*/
    cr[10].open === !0 && create_if_block$7(cr)
  );
  return {
    c() {
      fr && fr.c(), ar = empty$2();
    },
    m(gr, mr) {
      fr && fr.m(gr, mr), insert(gr, ar, mr), lr = !0, ur || (dr = listen(
        window_1,
        "keydown",
        /*onKeydownWindow*/
        cr[13]
      ), ur = !0);
    },
    p(gr, mr) {
      /*$drawerStore*/
      gr[10].open === !0 ? fr ? (fr.p(gr, mr), mr[0] & /*$drawerStore*/
      1024 && transition_in(fr, 1)) : (fr = create_if_block$7(gr), fr.c(), transition_in(fr, 1), fr.m(ar.parentNode, ar)) : fr && (group_outros(), transition_out(fr, 1, 1, () => {
        fr = null;
      }), check_outros());
    },
    i(gr) {
      lr || (transition_in(fr), lr = !0);
    },
    o(gr) {
      transition_out(fr), lr = !1;
    },
    d(gr) {
      gr && detach(ar), fr && fr.d(gr), ur = !1, dr();
    }
  };
}
const cBackdrop = "fixed top-0 left-0 right-0 bottom-0 flex", cDrawer = "overflow-y-auto transition-transform";
function instance$c(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r;
  component_subscribe(cr, prefersReducedMotionStore, (fi) => lr(38, _r = fi));
  let { $$slots: kr = {}, $$scope: xr } = ar;
  const Ar = createEventDispatcher();
  let { position: Er = "left" } = ar, { bgDrawer: Cr = "bg-surface-100-800-token" } = ar, { border: Tr = "" } = ar, { rounded: Sr = "" } = ar, { shadow: Lr = "shadow-xl" } = ar, { width: Ir = "" } = ar, { height: Nr = "" } = ar, { bgBackdrop: Rr = "bg-surface-backdrop-token" } = ar, { blur: Mr = "" } = ar, { padding: Br = "" } = ar, { zIndex: Dr = "z-40" } = ar, { regionBackdrop: Hr = "" } = ar, { regionDrawer: Fr = "" } = ar, { labelledby: zr = "" } = ar, { describedby: Ur = "" } = ar, { duration: jr = 200 } = ar, { transitions: Yr = !_r } = ar, { opacityTransition: qr = !0 } = ar;
  const Wr = {
    top: {
      alignment: "items-start",
      width: "w-full",
      height: "h-[50%]",
      rounded: "rounded-bl-container-token rounded-br-container-token"
    },
    bottom: {
      alignment: "items-end",
      width: "w-full",
      height: " h-[50%]",
      rounded: "rounded-tl-container-token rounded-tr-container-token"
    },
    left: {
      alignment: "justify-start",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tr-container-token rounded-br-container-token"
    },
    right: {
      alignment: "justify-end",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tl-container-token rounded-bl-container-token"
    }
  };
  let Jr, Gr, Vr = { x: 0, y: 0 };
  const Qr = getDrawerStore();
  component_subscribe(cr, Qr, (fi) => lr(10, yr = fi));
  const $r = {
    position: Er,
    bgBackdrop: Rr,
    blur: Mr,
    padding: Br,
    bgDrawer: Cr,
    border: Tr,
    rounded: Sr,
    shadow: Lr,
    width: Ir,
    height: Nr,
    opacityTransition: qr,
    regionBackdrop: Hr,
    regionDrawer: Fr,
    labelledby: zr,
    describedby: Ur,
    duration: jr
  };
  function Xr(fi) {
    lr(14, Er = fi.position || $r.position), lr(21, Rr = fi.bgBackdrop || $r.bgBackdrop), lr(22, Mr = fi.blur || $r.blur), lr(23, Br = fi.padding || $r.padding), lr(15, Cr = fi.bgDrawer || $r.bgDrawer), lr(16, Tr = fi.border || $r.border), lr(17, Sr = fi.rounded || $r.rounded), lr(18, Lr = fi.shadow || $r.shadow), lr(19, Ir = fi.width || $r.width), lr(20, Nr = fi.height || $r.height), lr(24, Hr = fi.regionBackdrop || $r.regionBackdrop), lr(25, Fr = fi.regionDrawer || $r.regionDrawer), lr(0, zr = fi.labelledby || $r.labelledby), lr(1, Ur = fi.describedby || $r.describedby), lr(3, qr = fi.opacityTransition || $r.opacityTransition), lr(2, jr = fi.duration || $r.duration);
  }
  function si() {
    switch (Er) {
      case "top":
        lr(7, Vr = { x: 0, y: -window.innerWidth });
        break;
      case "bottom":
        lr(7, Vr = { x: 0, y: window.innerWidth });
        break;
      case "left":
        lr(7, Vr = { x: -window.innerHeight, y: 0 });
        break;
      case "right":
        lr(7, Vr = { x: window.innerHeight, y: 0 });
        break;
      default:
        console.error("Error: unknown position property value.");
        break;
    }
  }
  function Zr(fi) {
    fi.target === Jr ? (Qr.close(), Ar("backdrop", fi)) : Ar("drawer", fi);
  }
  function li(fi) {
    yr && fi.code === "Escape" && Qr.close();
  }
  Qr.subscribe((fi) => {
    fi.open === !0 && (Xr(fi), si());
  });
  function Ei(fi) {
    bubble.call(this, cr, fi);
  }
  function ki(fi) {
    bubble.call(this, cr, fi);
  }
  function Di(fi) {
    bubble.call(this, cr, fi);
  }
  function hi(fi) {
    binding_callbacks[fi ? "unshift" : "push"](() => {
      Gr = fi, lr(6, Gr);
    });
  }
  function Ti(fi) {
    binding_callbacks[fi ? "unshift" : "push"](() => {
      Jr = fi, lr(5, Jr);
    });
  }
  return cr.$$set = (fi) => {
    lr(44, ar = assign$1(assign$1({}, ar), exclude_internal_props(fi))), "position" in fi && lr(14, Er = fi.position), "bgDrawer" in fi && lr(15, Cr = fi.bgDrawer), "border" in fi && lr(16, Tr = fi.border), "rounded" in fi && lr(17, Sr = fi.rounded), "shadow" in fi && lr(18, Lr = fi.shadow), "width" in fi && lr(19, Ir = fi.width), "height" in fi && lr(20, Nr = fi.height), "bgBackdrop" in fi && lr(21, Rr = fi.bgBackdrop), "blur" in fi && lr(22, Mr = fi.blur), "padding" in fi && lr(23, Br = fi.padding), "zIndex" in fi && lr(26, Dr = fi.zIndex), "regionBackdrop" in fi && lr(24, Hr = fi.regionBackdrop), "regionDrawer" in fi && lr(25, Fr = fi.regionDrawer), "labelledby" in fi && lr(0, zr = fi.labelledby), "describedby" in fi && lr(1, Ur = fi.describedby), "duration" in fi && lr(2, jr = fi.duration), "transitions" in fi && lr(4, Yr = fi.transitions), "opacityTransition" in fi && lr(3, qr = fi.opacityTransition), "$$scope" in fi && lr(31, xr = fi.$$scope);
  }, cr.$$.update = () => {
    var fi;
    cr.$$.dirty[0] & /*position*/
    16384 && lr(30, ur = Wr[Er].alignment), cr.$$.dirty[0] & /*width, position*/
    540672 && lr(29, dr = Ir || Wr[Er].width), cr.$$.dirty[0] & /*height, position*/
    1064960 && lr(28, fr = Nr || Wr[Er].height), cr.$$.dirty[0] & /*rounded, position*/
    147456 && lr(27, gr = Sr || Wr[Er].rounded), lr(9, mr = `${cBackdrop} ${Rr} ${Br} ${Mr} ${ur} ${Hr} ${Dr} ${(fi = ar.class) != null ? fi : ""}`), cr.$$.dirty[0] & /*bgDrawer, border, rounded, shadow, classesWidth, classesHeight, classesRounded, regionDrawer*/
    973570048 && lr(8, vr = `${cDrawer} ${Cr} ${Tr} ${Sr} ${Lr} ${dr} ${fr} ${gr} ${Fr}`);
  }, ar = exclude_internal_props(ar), [
    zr,
    Ur,
    jr,
    qr,
    Yr,
    Jr,
    Gr,
    Vr,
    vr,
    mr,
    yr,
    Qr,
    Zr,
    li,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Hr,
    Fr,
    Dr,
    gr,
    fr,
    dr,
    ur,
    xr,
    kr,
    Ei,
    ki,
    Di,
    hi,
    Ti
  ];
}
class Drawer extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$c,
      create_fragment$x,
      safe_not_equal,
      {
        position: 14,
        bgDrawer: 15,
        border: 16,
        rounded: 17,
        shadow: 18,
        width: 19,
        height: 20,
        bgBackdrop: 21,
        blur: 22,
        padding: 23,
        zIndex: 26,
        regionBackdrop: 24,
        regionDrawer: 25,
        labelledby: 0,
        describedby: 1,
        duration: 2,
        transitions: 4,
        opacityTransition: 3
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[14];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get bgDrawer() {
    return this.$$.ctx[15];
  }
  set bgDrawer(ar) {
    this.$$set({ bgDrawer: ar }), flush();
  }
  get border() {
    return this.$$.ctx[16];
  }
  set border(ar) {
    this.$$set({ border: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[17];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[18];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get width() {
    return this.$$.ctx[19];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[20];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get bgBackdrop() {
    return this.$$.ctx[21];
  }
  set bgBackdrop(ar) {
    this.$$set({ bgBackdrop: ar }), flush();
  }
  get blur() {
    return this.$$.ctx[22];
  }
  set blur(ar) {
    this.$$set({ blur: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[26];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get regionBackdrop() {
    return this.$$.ctx[24];
  }
  set regionBackdrop(ar) {
    this.$$set({ regionBackdrop: ar }), flush();
  }
  get regionDrawer() {
    return this.$$.ctx[25];
  }
  set regionDrawer(ar) {
    this.$$set({ regionDrawer: ar }), flush();
  }
  get labelledby() {
    return this.$$.ctx[0];
  }
  set labelledby(ar) {
    this.$$set({ labelledby: ar }), flush();
  }
  get describedby() {
    return this.$$.ctx[1];
  }
  set describedby(ar) {
    this.$$set({ describedby: ar }), flush();
  }
  get duration() {
    return this.$$.ctx[2];
  }
  set duration(ar) {
    this.$$set({ duration: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get opacityTransition() {
    return this.$$.ctx[3];
  }
  set opacityTransition(ar) {
    this.$$set({ opacityTransition: ar }), flush();
  }
}
create_custom_element(Drawer, { position: {}, bgDrawer: {}, border: {}, rounded: {}, shadow: {}, width: {}, height: {}, bgBackdrop: {}, blur: {}, padding: {}, zIndex: {}, regionBackdrop: {}, regionDrawer: {}, labelledby: {}, describedby: {}, duration: {}, transitions: {}, opacityTransition: { type: "Boolean" } }, ["default"], [], !0);
function create_fragment$w(cr) {
  let ar, lr = `<script nonce="%sveltekit.nonce%">(${setInitialClassState.toString()})();<\/script>`, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er;
  return {
    c() {
      ar = new HtmlTag(!1), ur = empty$2(), dr = space(), fr = element("div"), gr = element("div"), mr = svg_element("svg"), vr = svg_element("path"), ar.a = ur, attr(vr, "d", yr = /*$modeCurrent*/
      cr[1] ? (
        /*svgPath*/
        cr[5].sun
      ) : (
        /*svgPath*/
        cr[5].moon
      )), attr(mr, "class", _r = "lightswitch-icon " + /*classesIcon*/
      cr[2]), attr(mr, "xmlns", "http://www.w3.org/2000/svg"), attr(mr, "viewBox", "0 0 512 512"), attr(gr, "class", kr = "lightswitch-thumb " + /*classesThumb*/
      cr[3]), attr(fr, "class", xr = "lightswitch-track " + /*classesTrack*/
      cr[4]), attr(fr, "role", "switch"), attr(fr, "aria-label", "Light Switch"), attr(
        fr,
        "aria-checked",
        /*$modeCurrent*/
        cr[1]
      ), attr(
        fr,
        "title",
        /*title*/
        cr[0]
      ), attr(fr, "tabindex", "0");
    },
    m(Cr, Tr) {
      ar.m(lr, document.head), append(document.head, ur), insert(Cr, dr, Tr), insert(Cr, fr, Tr), append(fr, gr), append(gr, mr), append(mr, vr), Ar || (Er = [
        listen(
          fr,
          "click",
          /*onToggleHandler*/
          cr[6]
        ),
        listen(
          fr,
          "click",
          /*click_handler*/
          cr[19]
        ),
        listen(fr, "keydown", onKeyDown),
        listen(
          fr,
          "keydown",
          /*keydown_handler*/
          cr[20]
        ),
        listen(
          fr,
          "keyup",
          /*keyup_handler*/
          cr[21]
        ),
        listen(
          fr,
          "keypress",
          /*keypress_handler*/
          cr[22]
        )
      ], Ar = !0);
    },
    p(Cr, [Tr]) {
      Tr & /*$modeCurrent*/
      2 && yr !== (yr = /*$modeCurrent*/
      Cr[1] ? (
        /*svgPath*/
        Cr[5].sun
      ) : (
        /*svgPath*/
        Cr[5].moon
      )) && attr(vr, "d", yr), Tr & /*classesIcon*/
      4 && _r !== (_r = "lightswitch-icon " + /*classesIcon*/
      Cr[2]) && attr(mr, "class", _r), Tr & /*classesThumb*/
      8 && kr !== (kr = "lightswitch-thumb " + /*classesThumb*/
      Cr[3]) && attr(gr, "class", kr), Tr & /*classesTrack*/
      16 && xr !== (xr = "lightswitch-track " + /*classesTrack*/
      Cr[4]) && attr(fr, "class", xr), Tr & /*$modeCurrent*/
      2 && attr(
        fr,
        "aria-checked",
        /*$modeCurrent*/
        Cr[1]
      ), Tr & /*title*/
      1 && attr(
        fr,
        "title",
        /*title*/
        Cr[0]
      );
    },
    i: noop$1,
    o: noop$1,
    d(Cr) {
      Cr && (ar.d(), detach(dr), detach(fr)), detach(ur), Ar = !1, run_all(Er);
    }
  };
}
const cTrack = "cursor-pointer", cThumb = "aspect-square scale-[0.8] flex justify-center items-center", cIcon = "w-[70%] aspect-square";
function onKeyDown(cr) {
  ["Enter", "Space"].includes(cr.code) && (cr.preventDefault(), cr.currentTarget.click());
}
function instance$b(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr, _r;
  component_subscribe(cr, modeCurrent, (zr) => lr(1, _r = zr));
  let { title: kr = "Toggle light or dark mode." } = ar, { bgLight: xr = "bg-surface-50" } = ar, { bgDark: Ar = "bg-surface-900" } = ar, { fillLight: Er = "fill-surface-50" } = ar, { fillDark: Cr = "fill-surface-900" } = ar, { width: Tr = "w-12" } = ar, { height: Sr = "h-6" } = ar, { ring: Lr = "ring-[1px] ring-surface-500/30" } = ar, { rounded: Ir = "rounded-token" } = ar;
  const Nr = "transition-all duration-[200ms]", Rr = {
    sun: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z",
    moon: "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
  };
  function Mr() {
    set_store_value(modeCurrent, _r = !_r, _r), setModeUserPrefers(_r), setModeCurrent(_r);
  }
  onMount(() => {
    "modeCurrent" in localStorage || setModeCurrent(getModeOsPrefers());
  });
  function Br(zr) {
    bubble.call(this, cr, zr);
  }
  function Dr(zr) {
    bubble.call(this, cr, zr);
  }
  function Hr(zr) {
    bubble.call(this, cr, zr);
  }
  function Fr(zr) {
    bubble.call(this, cr, zr);
  }
  return cr.$$set = (zr) => {
    lr(24, ar = assign$1(assign$1({}, ar), exclude_internal_props(zr))), "title" in zr && lr(0, kr = zr.title), "bgLight" in zr && lr(7, xr = zr.bgLight), "bgDark" in zr && lr(8, Ar = zr.bgDark), "fillLight" in zr && lr(9, Er = zr.fillLight), "fillDark" in zr && lr(10, Cr = zr.fillDark), "width" in zr && lr(11, Tr = zr.width), "height" in zr && lr(12, Sr = zr.height), "ring" in zr && lr(13, Lr = zr.ring), "rounded" in zr && lr(14, Ir = zr.rounded);
  }, cr.$$.update = () => {
    var zr;
    cr.$$.dirty & /*$modeCurrent, bgLight, bgDark*/
    386 && lr(18, ur = _r === !0 ? xr : Ar), cr.$$.dirty & /*$modeCurrent, bgDark, bgLight*/
    386 && lr(17, dr = _r === !0 ? Ar : xr), cr.$$.dirty & /*$modeCurrent*/
    2 && lr(16, fr = _r === !0 ? "translate-x-[100%]" : ""), cr.$$.dirty & /*$modeCurrent, fillLight, fillDark*/
    1538 && lr(15, gr = _r === !0 ? Er : Cr), lr(4, mr = `${cTrack} ${Nr} ${Tr} ${Sr} ${Lr} ${Ir} ${ur} ${(zr = ar.class) != null ? zr : ""}`), cr.$$.dirty & /*height, rounded, thumbBg, thumbPosition*/
    217088 && lr(3, vr = `${cThumb} ${Nr} ${Sr} ${Ir} ${dr} ${fr}`), cr.$$.dirty & /*iconFill*/
    32768 && lr(2, yr = `${cIcon} ${gr}`);
  }, ar = exclude_internal_props(ar), [
    kr,
    _r,
    yr,
    vr,
    mr,
    Rr,
    Mr,
    xr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    gr,
    fr,
    dr,
    ur,
    Br,
    Dr,
    Hr,
    Fr
  ];
}
class LightSwitch extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$b, create_fragment$w, safe_not_equal, {
      title: 0,
      bgLight: 7,
      bgDark: 8,
      fillLight: 9,
      fillDark: 10,
      width: 11,
      height: 12,
      ring: 13,
      rounded: 14
    });
  }
  get title() {
    return this.$$.ctx[0];
  }
  set title(ar) {
    this.$$set({ title: ar }), flush();
  }
  get bgLight() {
    return this.$$.ctx[7];
  }
  set bgLight(ar) {
    this.$$set({ bgLight: ar }), flush();
  }
  get bgDark() {
    return this.$$.ctx[8];
  }
  set bgDark(ar) {
    this.$$set({ bgDark: ar }), flush();
  }
  get fillLight() {
    return this.$$.ctx[9];
  }
  set fillLight(ar) {
    this.$$set({ fillLight: ar }), flush();
  }
  get fillDark() {
    return this.$$.ctx[10];
  }
  set fillDark(ar) {
    this.$$set({ fillDark: ar }), flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get height() {
    return this.$$.ctx[12];
  }
  set height(ar) {
    this.$$set({ height: ar }), flush();
  }
  get ring() {
    return this.$$.ctx[13];
  }
  set ring(ar) {
    this.$$set({ ring: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[14];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
}
create_custom_element(LightSwitch, { title: {}, bgLight: {}, bgDark: {}, fillLight: {}, fillDark: {}, width: {}, height: {}, ring: {}, rounded: {} }, [], [], !0);
function get_each_context$3(cr, ar, lr) {
  const ur = cr.slice();
  return ur[36] = ar[lr], ur[38] = lr, ur;
}
function create_if_block$6(cr) {
  let ar, lr, ur = [], dr = /* @__PURE__ */ new Map(), fr, gr, mr, vr = ensure_array_like(
    /*filteredToasts*/
    cr[11]
  );
  const yr = (_r) => (
    /*t*/
    _r[36]
  );
  for (let _r = 0; _r < vr.length; _r += 1) {
    let kr = get_each_context$3(cr, vr, _r), xr = yr(kr);
    dr.set(xr, ur[_r] = create_each_block$3(xr, kr));
  }
  return {
    c() {
      ar = element("div"), lr = element("div");
      for (let _r = 0; _r < ur.length; _r += 1)
        ur[_r].c();
      attr(lr, "class", fr = "snackbar " + /*classesSnackbar*/
      cr[13]), attr(ar, "class", gr = "snackbar-wrapper " + /*classesWrapper*/
      cr[14]), attr(ar, "data-testid", "snackbar-wrapper");
    },
    m(_r, kr) {
      insert(_r, ar, kr), append(ar, lr);
      for (let xr = 0; xr < ur.length; xr += 1)
        ur[xr] && ur[xr].m(lr, null);
      mr = !0;
    },
    p(_r, kr) {
      if (kr[0] & /*filteredToasts, transitionOut, animAxis, transitionOutParams, transitions, onMouseEnter, onMouseLeave, classesToast, background, buttonDismiss, toastStore, buttonDismissLabel, buttonAction, onAction*/
      499103) {
        vr = ensure_array_like(
          /*filteredToasts*/
          _r[11]
        ), group_outros();
        for (let xr = 0; xr < ur.length; xr += 1)
          ur[xr].r();
        ur = update_keyed_each(ur, kr, yr, 1, _r, vr, dr, lr, fix_and_outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        for (let xr = 0; xr < ur.length; xr += 1)
          ur[xr].a();
        check_outros();
      }
      (!mr || kr[0] & /*classesSnackbar*/
      8192 && fr !== (fr = "snackbar " + /*classesSnackbar*/
      _r[13])) && attr(lr, "class", fr), (!mr || kr[0] & /*classesWrapper*/
      16384 && gr !== (gr = "snackbar-wrapper " + /*classesWrapper*/
      _r[14])) && attr(ar, "class", gr);
    },
    i(_r) {
      if (!mr) {
        for (let kr = 0; kr < vr.length; kr += 1)
          transition_in(ur[kr]);
        mr = !0;
      }
    },
    o(_r) {
      for (let kr = 0; kr < ur.length; kr += 1)
        transition_out(ur[kr]);
      mr = !1;
    },
    d(_r) {
      _r && detach(ar);
      for (let kr = 0; kr < ur.length; kr += 1)
        ur[kr].d();
    }
  };
}
function create_if_block_1$3(cr) {
  let ar, lr, ur = (
    /*t*/
    cr[36].action && create_if_block_3$2(cr)
  ), dr = !/*t*/
  cr[36].hideDismiss && create_if_block_2$2(cr);
  return {
    c() {
      ar = element("div"), ur && ur.c(), lr = space(), dr && dr.c(), attr(ar, "class", "toast-actions " + cToastActions);
    },
    m(fr, gr) {
      insert(fr, ar, gr), ur && ur.m(ar, null), append(ar, lr), dr && dr.m(ar, null);
    },
    p(fr, gr) {
      /*t*/
      fr[36].action ? ur ? ur.p(fr, gr) : (ur = create_if_block_3$2(fr), ur.c(), ur.m(ar, lr)) : ur && (ur.d(1), ur = null), /*t*/
      fr[36].hideDismiss ? dr && (dr.d(1), dr = null) : dr ? dr.p(fr, gr) : (dr = create_if_block_2$2(fr), dr.c(), dr.m(ar, null));
    },
    d(fr) {
      fr && detach(ar), ur && ur.d(), dr && dr.d();
    }
  };
}
function create_if_block_3$2(cr) {
  let ar, lr = (
    /*t*/
    cr[36].action.label + ""
  ), ur, dr;
  function fr() {
    return (
      /*click_handler*/
      cr[30](
        /*i*/
        cr[38]
      )
    );
  }
  return {
    c() {
      ar = element("button"), attr(
        ar,
        "class",
        /*buttonAction*/
        cr[1]
      );
    },
    m(gr, mr) {
      insert(gr, ar, mr), ar.innerHTML = lr, ur || (dr = listen(ar, "click", fr), ur = !0);
    },
    p(gr, mr) {
      cr = gr, mr[0] & /*filteredToasts*/
      2048 && lr !== (lr = /*t*/
      cr[36].action.label + "") && (ar.innerHTML = lr), mr[0] & /*buttonAction*/
      2 && attr(
        ar,
        "class",
        /*buttonAction*/
        cr[1]
      );
    },
    d(gr) {
      gr && detach(ar), ur = !1, dr();
    }
  };
}
function create_if_block_2$2(cr) {
  let ar, lr, ur, dr;
  function fr() {
    return (
      /*click_handler_1*/
      cr[31](
        /*t*/
        cr[36]
      )
    );
  }
  return {
    c() {
      ar = element("button"), lr = text$3(
        /*buttonDismissLabel*/
        cr[3]
      ), attr(
        ar,
        "class",
        /*buttonDismiss*/
        cr[2]
      ), attr(ar, "aria-label", "Dismiss toast");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, lr), ur || (dr = listen(ar, "click", fr), ur = !0);
    },
    p(gr, mr) {
      cr = gr, mr[0] & /*buttonDismissLabel*/
      8 && set_data(
        lr,
        /*buttonDismissLabel*/
        cr[3]
      ), mr[0] & /*buttonDismiss*/
      4 && attr(
        ar,
        "class",
        /*buttonDismiss*/
        cr[2]
      );
    },
    d(gr) {
      gr && detach(ar), ur = !1, dr();
    }
  };
}
function create_each_block$3(cr, ar) {
  let lr, ur, dr, fr = (
    /*t*/
    ar[36].message + ""
  ), gr, mr, vr, yr, _r, kr, xr, Ar = noop$1, Er, Cr, Tr, Sr = (
    /*t*/
    (ar[36].action || !/*t*/
    ar[36].hideDismiss) && create_if_block_1$3(ar)
  );
  function Lr() {
    return (
      /*mouseenter_handler*/
      ar[32](
        /*i*/
        ar[38]
      )
    );
  }
  function Ir() {
    return (
      /*mouseleave_handler*/
      ar[33](
        /*i*/
        ar[38]
      )
    );
  }
  return {
    key: cr,
    first: null,
    c() {
      var Nr, Rr;
      lr = element("div"), ur = element("div"), dr = element("div"), gr = space(), Sr && Sr.c(), vr = space(), attr(dr, "class", "text-base"), attr(ur, "class", mr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((Nr = ar[36].background) != null ? Nr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      ((Rr = ar[36].classes) != null ? Rr : "")), attr(ur, "data-testid", "toast"), attr(lr, "role", yr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog"), attr(lr, "aria-live", "polite"), this.first = lr;
    },
    m(Nr, Rr) {
      insert(Nr, lr, Rr), append(lr, ur), append(ur, dr), dr.innerHTML = fr, append(ur, gr), Sr && Sr.m(ur, null), append(lr, vr), Er = !0, Cr || (Tr = [
        listen(lr, "mouseenter", Lr),
        listen(lr, "mouseleave", Ir)
      ], Cr = !0);
    },
    p(Nr, Rr) {
      var Mr, Br;
      ar = Nr, (!Er || Rr[0] & /*filteredToasts*/
      2048) && fr !== (fr = /*t*/
      ar[36].message + "") && (dr.innerHTML = fr), /*t*/
      ar[36].action || !/*t*/
      ar[36].hideDismiss ? Sr ? Sr.p(ar, Rr) : (Sr = create_if_block_1$3(ar), Sr.c(), Sr.m(ur, null)) : Sr && (Sr.d(1), Sr = null), (!Er || Rr[0] & /*classesToast, filteredToasts, background*/
      6145 && mr !== (mr = "toast " + /*classesToast*/
      ar[12] + " " + /*t*/
      ((Mr = ar[36].background) != null ? Mr : (
        /*background*/
        ar[0]
      )) + " " + /*t*/
      ((Br = ar[36].classes) != null ? Br : ""))) && attr(ur, "class", mr), (!Er || Rr[0] & /*filteredToasts*/
      2048 && yr !== (yr = /*t*/
      ar[36].hideDismiss ? "alert" : "alertdialog")) && attr(lr, "role", yr);
    },
    r() {
      xr = lr.getBoundingClientRect();
    },
    f() {
      fix_position(lr), Ar(), add_transform(lr, xr);
    },
    a() {
      Ar(), Ar = create_animation(lr, xr, flip, {
        duration: (
          /*transitions*/
          ar[4] ? 250 : 0
        )
      });
    },
    i(Nr) {
      Er || (add_render_callback(() => {
        Er && (kr && kr.end(1), _r = create_in_transition(lr, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ar[5]
          ),
          params: {
            x: (
              /*animAxis*/
              ar[10].x
            ),
            y: (
              /*animAxis*/
              ar[10].y
            ),
            .../*transitionInParams*/
            ar[6]
          },
          enabled: (
            /*transitions*/
            ar[4]
          )
        }), _r.start());
      }), Er = !0);
    },
    o(Nr) {
      _r && _r.invalidate(), kr = create_out_transition(lr, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ar[7]
        ),
        params: {
          x: (
            /*animAxis*/
            ar[10].x
          ),
          y: (
            /*animAxis*/
            ar[10].y
          ),
          .../*transitionOutParams*/
          ar[8]
        },
        enabled: (
          /*transitions*/
          ar[4]
        )
      }), Er = !1;
    },
    d(Nr) {
      Nr && detach(lr), Sr && Sr.d(), Nr && kr && kr.end(), Cr = !1, run_all(Tr);
    }
  };
}
function create_fragment$v(cr) {
  let ar, lr, ur = (
    /*$toastStore*/
    cr[9].length && create_if_block$6(cr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$2();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), insert(dr, ar, fr), lr = !0;
    },
    p(dr, fr) {
      /*$toastStore*/
      dr[9].length ? ur ? (ur.p(dr, fr), fr[0] & /*$toastStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$6(dr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(dr) {
      lr || (transition_in(ur), lr = !0);
    },
    o(dr) {
      transition_out(ur), lr = !1;
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(dr);
    }
  };
}
const cWrapper = "flex fixed top-0 left-0 right-0 bottom-0 pointer-events-none", cSnackbar = "flex flex-col gap-y-2", cToast = "flex justify-between items-center pointer-events-auto", cToastActions = "flex items-center space-x-2";
function instance$a(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr;
  component_subscribe(cr, prefersReducedMotionStore, (Xr) => lr(34, vr = Xr));
  const yr = getToastStore();
  component_subscribe(cr, yr, (Xr) => lr(9, mr = Xr));
  let { position: _r = "b" } = ar, { max: kr = 3 } = ar, { background: xr = "variant-filled-secondary" } = ar, { width: Ar = "max-w-[640px]" } = ar, { color: Er = "" } = ar, { padding: Cr = "p-4" } = ar, { spacing: Tr = "space-x-4" } = ar, { rounded: Sr = "rounded-container-token" } = ar, { shadow: Lr = "shadow-lg" } = ar, { zIndex: Ir = "z-[888]" } = ar, { buttonAction: Nr = "btn variant-filled" } = ar, { buttonDismiss: Rr = "btn-icon btn-icon-sm variant-filled" } = ar, { buttonDismissLabel: Mr = "" } = ar, { transitions: Br = !vr } = ar, { transitionIn: Dr = fly } = ar, { transitionInParams: Hr = { duration: 250 } } = ar, { transitionOut: Fr = fly } = ar, { transitionOutParams: zr = { duration: 250 } } = ar, Ur, jr, Yr = { x: 0, y: 0 };
  switch (_r) {
    case "t":
      Ur = "justify-center items-start", jr = "items-center", Yr = { x: 0, y: -100 };
      break;
    case "b":
      Ur = "justify-center items-end", jr = "items-center", Yr = { x: 0, y: 100 };
      break;
    case "l":
      Ur = "justify-start items-center", jr = "items-start", Yr = { x: -100, y: 0 };
      break;
    case "r":
      Ur = "justify-end items-center", jr = "items-end", Yr = { x: 100, y: 0 };
      break;
    case "tl":
      Ur = "justify-start items-start", jr = "items-start", Yr = { x: -100, y: 0 };
      break;
    case "tr":
      Ur = "justify-end items-start", jr = "items-end", Yr = { x: 100, y: 0 };
      break;
    case "bl":
      Ur = "justify-start items-end", jr = "items-start", Yr = { x: -100, y: 0 };
      break;
    case "br":
      Ur = "justify-end items-end", jr = "items-end", Yr = { x: 100, y: 0 };
      break;
  }
  function qr(Xr) {
    var si, Zr;
    (Zr = (si = mr[Xr]) == null ? void 0 : si.action) == null || Zr.response(), yr.close(mr[Xr].id);
  }
  function Wr(Xr) {
    var si;
    (si = mr[Xr]) != null && si.hoverable && (yr.freeze(Xr), lr(13, dr += " scale-[105%]"));
  }
  function Jr(Xr) {
    var si;
    (si = mr[Xr]) != null && si.hoverable && (yr.unfreeze(Xr), lr(13, dr = dr.replace(" scale-[105%]", "")));
  }
  const Gr = (Xr) => qr(Xr), Vr = (Xr) => yr.close(Xr.id), Qr = (Xr) => Wr(Xr), $r = (Xr) => Jr(Xr);
  return cr.$$set = (Xr) => {
    lr(35, ar = assign$1(assign$1({}, ar), exclude_internal_props(Xr))), "position" in Xr && lr(19, _r = Xr.position), "max" in Xr && lr(20, kr = Xr.max), "background" in Xr && lr(0, xr = Xr.background), "width" in Xr && lr(21, Ar = Xr.width), "color" in Xr && lr(22, Er = Xr.color), "padding" in Xr && lr(23, Cr = Xr.padding), "spacing" in Xr && lr(24, Tr = Xr.spacing), "rounded" in Xr && lr(25, Sr = Xr.rounded), "shadow" in Xr && lr(26, Lr = Xr.shadow), "zIndex" in Xr && lr(27, Ir = Xr.zIndex), "buttonAction" in Xr && lr(1, Nr = Xr.buttonAction), "buttonDismiss" in Xr && lr(2, Rr = Xr.buttonDismiss), "buttonDismissLabel" in Xr && lr(3, Mr = Xr.buttonDismissLabel), "transitions" in Xr && lr(4, Br = Xr.transitions), "transitionIn" in Xr && lr(5, Dr = Xr.transitionIn), "transitionInParams" in Xr && lr(6, Hr = Xr.transitionInParams), "transitionOut" in Xr && lr(7, Fr = Xr.transitionOut), "transitionOutParams" in Xr && lr(8, zr = Xr.transitionOutParams);
  }, cr.$$.update = () => {
    lr(14, ur = `${cWrapper} ${Ur} ${Ir} ${ar.class || ""}`), cr.$$.dirty[0] & /*cAlign, padding*/
    545259520 && lr(13, dr = `${cSnackbar} ${jr} ${Cr}`), cr.$$.dirty[0] & /*width, color, padding, spacing, rounded, shadow*/
    132120576 && lr(12, fr = `${cToast} ${Ar} ${Er} ${Cr} ${Tr} ${Sr} ${Lr}`), cr.$$.dirty[0] & /*$toastStore, max*/
    1049088 && lr(11, gr = Array.from(mr).slice(0, kr));
  }, ar = exclude_internal_props(ar), [
    xr,
    Nr,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    mr,
    Yr,
    gr,
    fr,
    dr,
    ur,
    yr,
    qr,
    Wr,
    Jr,
    _r,
    kr,
    Ar,
    Er,
    Cr,
    Tr,
    Sr,
    Lr,
    Ir,
    Ur,
    jr,
    Gr,
    Vr,
    Qr,
    $r
  ];
}
class Toast extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$a,
      create_fragment$v,
      safe_not_equal,
      {
        position: 19,
        max: 20,
        background: 0,
        width: 21,
        color: 22,
        padding: 23,
        spacing: 24,
        rounded: 25,
        shadow: 26,
        zIndex: 27,
        buttonAction: 1,
        buttonDismiss: 2,
        buttonDismissLabel: 3,
        transitions: 4,
        transitionIn: 5,
        transitionInParams: 6,
        transitionOut: 7,
        transitionOutParams: 8
      },
      null,
      [-1, -1]
    );
  }
  get position() {
    return this.$$.ctx[19];
  }
  set position(ar) {
    this.$$set({ position: ar }), flush();
  }
  get max() {
    return this.$$.ctx[20];
  }
  set max(ar) {
    this.$$set({ max: ar }), flush();
  }
  get background() {
    return this.$$.ctx[0];
  }
  set background(ar) {
    this.$$set({ background: ar }), flush();
  }
  get width() {
    return this.$$.ctx[21];
  }
  set width(ar) {
    this.$$set({ width: ar }), flush();
  }
  get color() {
    return this.$$.ctx[22];
  }
  set color(ar) {
    this.$$set({ color: ar }), flush();
  }
  get padding() {
    return this.$$.ctx[23];
  }
  set padding(ar) {
    this.$$set({ padding: ar }), flush();
  }
  get spacing() {
    return this.$$.ctx[24];
  }
  set spacing(ar) {
    this.$$set({ spacing: ar }), flush();
  }
  get rounded() {
    return this.$$.ctx[25];
  }
  set rounded(ar) {
    this.$$set({ rounded: ar }), flush();
  }
  get shadow() {
    return this.$$.ctx[26];
  }
  set shadow(ar) {
    this.$$set({ shadow: ar }), flush();
  }
  get zIndex() {
    return this.$$.ctx[27];
  }
  set zIndex(ar) {
    this.$$set({ zIndex: ar }), flush();
  }
  get buttonAction() {
    return this.$$.ctx[1];
  }
  set buttonAction(ar) {
    this.$$set({ buttonAction: ar }), flush();
  }
  get buttonDismiss() {
    return this.$$.ctx[2];
  }
  set buttonDismiss(ar) {
    this.$$set({ buttonDismiss: ar }), flush();
  }
  get buttonDismissLabel() {
    return this.$$.ctx[3];
  }
  set buttonDismissLabel(ar) {
    this.$$set({ buttonDismissLabel: ar }), flush();
  }
  get transitions() {
    return this.$$.ctx[4];
  }
  set transitions(ar) {
    this.$$set({ transitions: ar }), flush();
  }
  get transitionIn() {
    return this.$$.ctx[5];
  }
  set transitionIn(ar) {
    this.$$set({ transitionIn: ar }), flush();
  }
  get transitionInParams() {
    return this.$$.ctx[6];
  }
  set transitionInParams(ar) {
    this.$$set({ transitionInParams: ar }), flush();
  }
  get transitionOut() {
    return this.$$.ctx[7];
  }
  set transitionOut(ar) {
    this.$$set({ transitionOut: ar }), flush();
  }
  get transitionOutParams() {
    return this.$$.ctx[8];
  }
  set transitionOutParams(ar) {
    this.$$set({ transitionOutParams: ar }), flush();
  }
}
create_custom_element(Toast, { position: {}, max: {}, background: {}, width: {}, color: {}, padding: {}, spacing: {}, rounded: {}, shadow: {}, zIndex: {}, buttonAction: {}, buttonDismiss: {}, buttonDismissLabel: {}, transitions: {}, transitionIn: {}, transitionInParams: {}, transitionOut: {}, transitionOutParams: {} }, [], [], !0);
function get_each_context$2(cr, ar, lr) {
  const ur = cr.slice();
  return ur[19] = ar[lr], ur;
}
function create_if_block$5(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr;
  const yr = (
    /*#slots*/
    cr[16].default
  ), _r = create_slot(
    yr,
    cr,
    /*$$scope*/
    cr[15],
    null
  ), kr = _r || fallback_block();
  let xr = ensure_array_like(
    /*$tocStore*/
    cr[9]
  ), Ar = [];
  for (let Er = 0; Er < xr.length; Er += 1)
    Ar[Er] = create_each_block$2(get_each_context$2(cr, xr, Er));
  return {
    c() {
      ar = element("nav"), lr = element("div"), kr && kr.c(), ur = space(), dr = element("ul");
      for (let Er = 0; Er < Ar.length; Er += 1)
        Ar[Er].c();
      attr(
        lr,
        "class",
        /*regionLead*/
        cr[3]
      ), attr(dr, "class", fr = "toc-list " + /*classesList*/
      cr[6]), attr(ar, "class", gr = "toc " + /*classesBase*/
      cr[7]), attr(ar, "data-testid", "toc");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, lr), kr && kr.m(lr, null), append(ar, ur), append(ar, dr);
      for (let Tr = 0; Tr < Ar.length; Tr += 1)
        Ar[Tr] && Ar[Tr].m(dr, null);
      vr = !0;
    },
    p(Er, Cr) {
      if (_r && _r.p && (!vr || Cr & /*$$scope*/
      32768) && update_slot_base(
        _r,
        yr,
        Er,
        /*$$scope*/
        Er[15],
        vr ? get_slot_changes(
          yr,
          /*$$scope*/
          Er[15],
          Cr,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          Er[15]
        ),
        null
      ), (!vr || Cr & /*regionLead*/
      8) && attr(
        lr,
        "class",
        /*regionLead*/
        Er[3]
      ), Cr & /*classesListItem, indentStyles, $tocStore, classesAnchor, reactiveActiveId, active, inactive*/
      823) {
        xr = ensure_array_like(
          /*$tocStore*/
          Er[9]
        );
        let Tr;
        for (Tr = 0; Tr < xr.length; Tr += 1) {
          const Sr = get_each_context$2(Er, xr, Tr);
          Ar[Tr] ? Ar[Tr].p(Sr, Cr) : (Ar[Tr] = create_each_block$2(Sr), Ar[Tr].c(), Ar[Tr].m(dr, null));
        }
        for (; Tr < Ar.length; Tr += 1)
          Ar[Tr].d(1);
        Ar.length = xr.length;
      }
      (!vr || Cr & /*classesList*/
      64 && fr !== (fr = "toc-list " + /*classesList*/
      Er[6])) && attr(dr, "class", fr), (!vr || Cr & /*classesBase*/
      128 && gr !== (gr = "toc " + /*classesBase*/
      Er[7])) && attr(ar, "class", gr);
    },
    i(Er) {
      vr || (transition_in(kr, Er), Er && add_render_callback(() => {
        vr && (mr || (mr = create_bidirectional_transition(ar, fade, { duration: 100 }, !0)), mr.run(1));
      }), vr = !0);
    },
    o(Er) {
      transition_out(kr, Er), Er && (mr || (mr = create_bidirectional_transition(ar, fade, { duration: 100 }, !1)), mr.run(0)), vr = !1;
    },
    d(Er) {
      Er && detach(ar), kr && kr.d(Er), destroy_each(Ar, Er), Er && mr && mr.end();
    }
  };
}
function fallback_block(cr) {
  let ar;
  return {
    c() {
      ar = text$3("Table of Contents");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_each_block$2(cr) {
  let ar, lr, ur = (
    /*tocHeading*/
    cr[19].text + ""
  ), dr, fr, gr, mr, vr, yr, _r;
  function kr() {
    return (
      /*click_handler*/
      cr[17](
        /*tocHeading*/
        cr[19]
      )
    );
  }
  return {
    c() {
      ar = element("li"), lr = element("a"), dr = text$3(ur), mr = space(), attr(lr, "href", fr = "#" + /*tocHeading*/
      cr[19].id), attr(lr, "class", gr = "toc-anchor " + /*classesAnchor*/
      cr[4] + " " + /*tocHeading*/
      (cr[19].id === /*reactiveActiveId*/
      cr[8] ? (
        /*active*/
        cr[1]
      ) : (
        /*inactive*/
        cr[0]
      ))), attr(ar, "class", vr = "toc-list-item " + /*classesListItem*/
      cr[5] + " " + /*indentStyles*/
      cr[2][
        /*tocHeading*/
        cr[19].element
      ]);
    },
    m(xr, Ar) {
      insert(xr, ar, Ar), append(ar, lr), append(lr, dr), append(ar, mr), yr || (_r = listen(lr, "click", kr), yr = !0);
    },
    p(xr, Ar) {
      cr = xr, Ar & /*$tocStore*/
      512 && ur !== (ur = /*tocHeading*/
      cr[19].text + "") && set_data(dr, ur), Ar & /*$tocStore*/
      512 && fr !== (fr = "#" + /*tocHeading*/
      cr[19].id) && attr(lr, "href", fr), Ar & /*classesAnchor, $tocStore, reactiveActiveId, active, inactive*/
      787 && gr !== (gr = "toc-anchor " + /*classesAnchor*/
      cr[4] + " " + /*tocHeading*/
      (cr[19].id === /*reactiveActiveId*/
      cr[8] ? (
        /*active*/
        cr[1]
      ) : (
        /*inactive*/
        cr[0]
      ))) && attr(lr, "class", gr), Ar & /*classesListItem, indentStyles, $tocStore*/
      548 && vr !== (vr = "toc-list-item " + /*classesListItem*/
      cr[5] + " " + /*indentStyles*/
      cr[2][
        /*tocHeading*/
        cr[19].element
      ]) && attr(ar, "class", vr);
    },
    d(xr) {
      xr && detach(ar), yr = !1, _r();
    }
  };
}
function create_fragment$u(cr) {
  let ar, lr, ur = (
    /*$tocStore*/
    cr[9].length && create_if_block$5(cr)
  );
  return {
    c() {
      ur && ur.c(), ar = empty$2();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), insert(dr, ar, fr), lr = !0;
    },
    p(dr, [fr]) {
      /*$tocStore*/
      dr[9].length ? ur ? (ur.p(dr, fr), fr & /*$tocStore*/
      512 && transition_in(ur, 1)) : (ur = create_if_block$5(dr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar)) : ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros());
    },
    i(dr) {
      lr || (transition_in(ur), lr = !0);
    },
    o(dr) {
      transition_out(ur), lr = !1;
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(dr);
    }
  };
}
const cBase = "space-y-4", cList = "space-y-2", cListItem = "block", cAnchor = "";
function instance$9(cr, ar, lr) {
  let ur, dr, fr, gr, mr, vr, yr;
  component_subscribe(cr, tocActiveId, (Rr) => lr(14, vr = Rr)), component_subscribe(cr, tocStore, (Rr) => lr(9, yr = Rr));
  let { $$slots: _r = {}, $$scope: kr } = ar, { inactive: xr = "opacity-60 hover:opacity-100" } = ar, { active: Ar = "text-primary-500" } = ar, { activeId: Er = "" } = ar, { indentStyles: Cr = {
    h2: "",
    h3: "ml-4",
    h4: "ml-8",
    h5: "ml-12",
    h6: "ml-16"
  } } = ar, { regionLead: Tr = "font-bold" } = ar, { regionList: Sr = "" } = ar, { regionListItem: Lr = "" } = ar, { regionAnchor: Ir = "" } = ar;
  const Nr = (Rr) => {
    lr(8, ur = Rr.id);
  };
  return cr.$$set = (Rr) => {
    lr(18, ar = assign$1(assign$1({}, ar), exclude_internal_props(Rr))), "inactive" in Rr && lr(0, xr = Rr.inactive), "active" in Rr && lr(1, Ar = Rr.active), "activeId" in Rr && lr(10, Er = Rr.activeId), "indentStyles" in Rr && lr(2, Cr = Rr.indentStyles), "regionLead" in Rr && lr(3, Tr = Rr.regionLead), "regionList" in Rr && lr(11, Sr = Rr.regionList), "regionListItem" in Rr && lr(12, Lr = Rr.regionListItem), "regionAnchor" in Rr && lr(13, Ir = Rr.regionAnchor), "$$scope" in Rr && lr(15, kr = Rr.$$scope);
  }, cr.$$.update = () => {
    var Rr;
    cr.$$.dirty & /*$tocActiveId, activeId*/
    17408 && lr(8, ur = vr || Er.replace("#", "")), lr(7, dr = `${cBase} ${(Rr = ar.class) != null ? Rr : ""}`), cr.$$.dirty & /*regionList*/
    2048 && lr(6, fr = `${cList} ${Sr}`), cr.$$.dirty & /*regionListItem*/
    4096 && lr(5, gr = `${cListItem} ${Lr}`), cr.$$.dirty & /*regionAnchor*/
    8192 && lr(4, mr = `${cAnchor} ${Ir}`);
  }, ar = exclude_internal_props(ar), [
    xr,
    Ar,
    Cr,
    Tr,
    mr,
    gr,
    fr,
    dr,
    ur,
    yr,
    Er,
    Sr,
    Lr,
    Ir,
    vr,
    kr,
    _r,
    Nr
  ];
}
class TableOfContents extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$9, create_fragment$u, safe_not_equal, {
      inactive: 0,
      active: 1,
      activeId: 10,
      indentStyles: 2,
      regionLead: 3,
      regionList: 11,
      regionListItem: 12,
      regionAnchor: 13
    });
  }
  get inactive() {
    return this.$$.ctx[0];
  }
  set inactive(ar) {
    this.$$set({ inactive: ar }), flush();
  }
  get active() {
    return this.$$.ctx[1];
  }
  set active(ar) {
    this.$$set({ active: ar }), flush();
  }
  get activeId() {
    return this.$$.ctx[10];
  }
  set activeId(ar) {
    this.$$set({ activeId: ar }), flush();
  }
  get indentStyles() {
    return this.$$.ctx[2];
  }
  set indentStyles(ar) {
    this.$$set({ indentStyles: ar }), flush();
  }
  get regionLead() {
    return this.$$.ctx[3];
  }
  set regionLead(ar) {
    this.$$set({ regionLead: ar }), flush();
  }
  get regionList() {
    return this.$$.ctx[11];
  }
  set regionList(ar) {
    this.$$set({ regionList: ar }), flush();
  }
  get regionListItem() {
    return this.$$.ctx[12];
  }
  set regionListItem(ar) {
    this.$$set({ regionListItem: ar }), flush();
  }
  get regionAnchor() {
    return this.$$.ctx[13];
  }
  set regionAnchor(ar) {
    this.$$set({ regionAnchor: ar }), flush();
  }
}
create_custom_element(TableOfContents, { inactive: {}, active: {}, activeId: {}, indentStyles: {}, regionLead: {}, regionList: {}, regionListItem: {}, regionAnchor: {} }, ["default"], [], !0);
function create_fragment$t(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "values", `0.8 0.6 -0.4 0.1 0,
					0 1.2 0.05 0 0,
					0 -1 3 0.02 0,
					0 0 0 50 0`), attr(ur, "result", "final"), attr(ur, "in", "SourceGraphic"), attr(lr, "id", "Apollo"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-apollo"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Apollo extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$t, safe_not_equal, {});
  }
}
create_custom_element(Apollo, {}, [], [], !0);
function create_fragment$s(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.000 0.000 0.000 0.000 0.000 
                    0.000 1.000 0.000 0.000 0.05 
                    0.000 0.000 1.000 0.000 0.400 
                    0.000 0.000 0.000 1.000 0.000`), attr(lr, "id", "BlueNight"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-bluenight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class BlueNight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$s, safe_not_equal, {});
  }
}
create_custom_element(BlueNight, {}, [], [], !0);
function create_fragment$r(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), dr = svg_element("feComponentTransfer"), fr = svg_element("feFuncR"), gr = svg_element("feFuncG"), mr = svg_element("feFuncB"), vr = svg_element("feFuncA"), yr = svg_element("feBlend"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            .16 .185 .129 0 0
            0 0 0 0.33 0`), attr(fr, "type", "table"), attr(fr, "tableValues", "0.03 0.9"), attr(gr, "type", "table"), attr(gr, "tableValues", "0.57 1"), attr(mr, "type", "table"), attr(mr, "tableValues", "0.49 0.53"), attr(vr, "type", "table"), attr(vr, "tableValues", "0 1"), attr(dr, "in", "colormatrix"), attr(dr, "result", "componentTransfer"), attr(yr, "mode", "normal"), attr(yr, "in", "componentTransfer"), attr(yr, "in2", "SourceGraphic"), attr(yr, "result", "blend"), attr(lr, "id", "Emerald"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-emerald"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(_r, kr) {
      insert(_r, ar, kr), append(ar, lr), append(lr, ur), append(lr, dr), append(dr, fr), append(dr, gr), append(dr, mr), append(dr, vr), append(lr, yr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(_r) {
      _r && detach(ar);
    }
  };
}
class Emerald extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$r, safe_not_equal, {});
  }
}
create_custom_element(Emerald, {}, [], [], !0);
function create_fragment$q(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `0.5 -0.4 0.3332 0 0
					0 0.4 0.3 0 0
					0 0 0.5 0 0
					0 0 0 500 -20`), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(lr, "id", "GreenFall"), attr(lr, "x", "-20%"), attr(lr, "y", "-20%"), attr(lr, "width", "140%"), attr(lr, "height", "140%"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-greenfall"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class GreenFall extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$q, safe_not_equal, {});
  }
}
create_custom_element(GreenFall, {}, [], [], !0);
function create_fragment$p(cr) {
  let ar, lr, ur, dr, fr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), dr = svg_element("feBlend"), fr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix1"), attr(dr, "mode", "lighten"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "colormatrix1"), attr(dr, "in2", "colormatrix1"), attr(dr, "result", "blend"), attr(fr, "mode", "multiply"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "colormatrix1"), attr(fr, "in2", "diffuseLighting"), attr(fr, "result", "blend1"), attr(lr, "id", "Noir"), attr(lr, "x", "-20%"), attr(lr, "y", "-20%"), attr(lr, "width", "140%"), attr(lr, "height", "140%"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noir"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, lr), append(lr, ur), append(lr, dr), append(lr, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar);
    }
  };
}
class Noir extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$p, safe_not_equal, {});
  }
}
create_custom_element(Noir, {}, [], [], !0);
function create_fragment$o(cr) {
  let ar, lr, ur, dr, fr, gr, mr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), dr = svg_element("feBlend"), fr = svg_element("feBlend"), gr = svg_element("feColorMatrix"), mr = svg_element("feBlend"), attr(ur, "type", "saturate"), attr(ur, "values", "0"), attr(ur, "x", "0%"), attr(ur, "y", "0%"), attr(ur, "width", "100%"), attr(ur, "height", "100%"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix2"), attr(dr, "mode", "saturation"), attr(dr, "x", "0%"), attr(dr, "y", "0%"), attr(dr, "width", "100%"), attr(dr, "height", "100%"), attr(dr, "in", "SourceGraphic"), attr(dr, "in2", "colormatrix2"), attr(dr, "result", "blend2"), attr(fr, "mode", "screen"), attr(fr, "x", "0%"), attr(fr, "y", "0%"), attr(fr, "width", "100%"), attr(fr, "height", "100%"), attr(fr, "in", "colormatrix2"), attr(fr, "in2", "blend2"), attr(fr, "result", "blend3"), attr(gr, "type", "luminanceToAlpha"), attr(gr, "x", "0%"), attr(gr, "y", "0%"), attr(gr, "width", "100%"), attr(gr, "height", "100%"), attr(gr, "in", "blend3"), attr(gr, "result", "colormatrix3"), attr(mr, "mode", "exclusion"), attr(mr, "x", "0%"), attr(mr, "y", "0%"), attr(mr, "width", "100%"), attr(mr, "height", "100%"), attr(mr, "in", "blend3"), attr(mr, "in2", "colormatrix3"), attr(mr, "result", "blend5"), attr(lr, "id", "NoirLight"), attr(lr, "x", "-20%"), attr(lr, "y", "-20%"), attr(lr, "width", "140%"), attr(lr, "height", "140%"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "linearRGB"), attr(ar, "id", "svg-filter-noirlight"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, lr), append(lr, ur), append(lr, dr), append(lr, fr), append(lr, gr), append(lr, mr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(vr) {
      vr && detach(ar);
    }
  };
}
class NoirLight extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$o, safe_not_equal, {});
  }
}
create_custom_element(NoirLight, {}, [], [], !0);
function create_fragment$n(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "in", "SourceGraphic"), attr(ur, "result", "colormatrix"), attr(ur, "values", `0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 
					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 
					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  
					0 0 0 1 0`), attr(lr, "id", "Rustic"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-rustic"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Rustic extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$n, safe_not_equal, {});
  }
}
create_custom_element(Rustic, {}, [], [], !0);
function create_fragment$m(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.300 0.200 0.000 0.000 0.000 
					0.300 0.600 0.200 0.000 0.000 
					0.200 1.000 0.200 0.000 0.000 
					0.000 0.000 0.000 1.000 0.000`), attr(lr, "id", "Summer84"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-summer84"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Summer84 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$m, safe_not_equal, {});
  }
}
create_custom_element(Summer84, {}, [], [], !0);
function create_fragment$l(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("filter"), ur = svg_element("feColorMatrix"), attr(ur, "type", "matrix"), attr(ur, "values", `1.70 -0.20 0.00 0.00 0.00 
                    0.10 0.800 0.30 0.00 0.00 
                    0.20 0.300 0.50 0.00 0.00 
                    0.00 0.00 0.00 1.00 0.00`), attr(lr, "id", "XPro"), attr(lr, "filterUnits", "objectBoundingBox"), attr(lr, "primitiveUnits", "userSpaceOnUse"), attr(lr, "color-interpolation-filters", "sRGB"), attr(ar, "id", "svg-filter-xpro"), attr(ar, "class", "filter absolute -left-full w-0 h-0");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class XPro extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$l, safe_not_equal, {});
  }
}
create_custom_element(XPro, {}, [], [], !0);
const ndkUser = writable(null), isNip05Valid = writable({
  isNip05Valid: null,
  Nip05address: void 0,
  UserNpub: void 0,
  Vanity: void 0,
  UserIdentifier: void 0
}), activeProfile = writable(null);
activeProfile.subscribe((cr) => {
  cr && activeProfile.set(cr);
});
const localStore = localStorageStore("localStore", {
  lastUserLogged: void 0,
  pk: void 0
});
function create_fragment$k(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), ur = svg_element("path"), attr(lr, "fill-rule", "evenodd"), attr(lr, "clip-rule", "evenodd"), attr(lr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(lr, "fill", "#4DA84D"), attr(ur, "d", "M12 16.2553L14.8661 19L19 12"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class Positive extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$k, safe_not_equal, {});
  }
}
create_custom_element(Positive, {}, [], [], !0);
function create_fragment$j(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), ur = svg_element("path"), dr = svg_element("path"), attr(lr, "fill-rule", "evenodd"), attr(lr, "clip-rule", "evenodd"), attr(lr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(lr, "fill", "#42BDD8"), attr(ur, "d", "M12.8661 17H18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.5"), attr(ur, "stroke-linecap", "round"), attr(ur, "stroke-linejoin", "round"), attr(dr, "d", "M12.8661 13H18.5"), attr(dr, "stroke", "white"), attr(dr, "stroke-width", "1.5"), attr(dr, "stroke-linecap", "round"), attr(dr, "stroke-linejoin", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, gr) {
      insert(fr, ar, gr), append(ar, lr), append(ar, ur), append(ar, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Neutral extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$j, safe_not_equal, {});
  }
}
create_custom_element(Neutral, {}, [], [], !0);
function create_fragment$i(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), ur = svg_element("path"), dr = svg_element("path"), attr(lr, "fill-rule", "evenodd"), attr(lr, "clip-rule", "evenodd"), attr(lr, "d", "M24 9.77734C24 8.86867 23.3874 8.0742 22.5087 7.8431L16.0087 6.13376C15.6752 6.04607 15.3248 6.04607 14.9913 6.13376L8.49134 7.8431C7.61255 8.0742 7 8.86867 7 9.77734V16V16C7.00002 20.8032 10.7627 24.7276 15.5013 24.9864C20.2387 24.7263 24 20.8025 24 16.0001V16V9.77734Z"), attr(lr, "fill", "#ED1B24"), attr(ur, "d", "M12 11.5L19 18.5"), attr(ur, "stroke", "white"), attr(ur, "stroke-width", "1.3125"), attr(ur, "stroke-linecap", "round"), attr(dr, "d", "M19 11.5L12 18.5"), attr(dr, "stroke", "white"), attr(dr, "stroke-width", "1.3125"), attr(dr, "stroke-linecap", "round"), attr(ar, "width", "30"), attr(ar, "height", "30"), attr(ar, "viewBox", "0 0 30 30"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, gr) {
      insert(fr, ar, gr), append(ar, lr), append(ar, ur), append(ar, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class Negative extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$i, safe_not_equal, {});
  }
}
create_custom_element(Negative, {}, [], [], !0);
const profileImageUrl = "https://api.dicebear.com/5.x/identicon/svg?seed=", kindNotes = 1, kindOpinion = 30023, kindDelete = 5, kindReaction = 7, uploadUrl = "https://void.cat", DEFAULT_RELAY_URLS = {
  read: ["wss://nos.lol"],
  write: ["wss://nos.lol"]
}, opinionHeaderSeparator = `
<!--HEADER END-->
`, opinionFooterSeparator = `
<!--FOOTER START-->



`, opinionHeaderRegex = new RegExp(`^[\\s\\S]*${opinionHeaderSeparator}`), opinionFooterRegex = new RegExp(`${opinionFooterSeparator}[\\s\\S]*$`);
function number$6(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool$5(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes$6(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$6(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$6(cr.outputLen), number$6(cr.blockLen);
}
function exists$6(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$6(cr, ar) {
  bytes$6(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert$6 = {
  number: number$6,
  bool: bool$5,
  bytes: bytes$6,
  hash: hash$6,
  exists: exists$6,
  output: output$6
}, crypto$6 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$8 = (cr) => cr instanceof Uint8Array, createView$5 = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr$5 = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE$6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$6)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function utf8ToBytes$8(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$6(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$8(cr)), !u8a$8(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes$7(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$8(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
let Hash$5 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$5(cr) {
  const ar = (ur) => cr().update(toBytes$6(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes$5(cr = 32) {
  if (crypto$6 && typeof crypto$6.getRandomValues == "function")
    return crypto$6.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$5(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
let SHA2$5 = class extends Hash$5 {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$5(this.buffer);
  }
  update(ar) {
    assert$6.exists(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes$6(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView$5(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.output(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64$5(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView$5(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
};
const Chi$6 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj$5 = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K$5 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$5 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$5 = new Uint32Array(64);
let SHA256$5 = class extends SHA2$5 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$5[0] | 0, this.B = IV$5[1] | 0, this.C = IV$5[2] | 0, this.D = IV$5[3] | 0, this.E = IV$5[4] | 0, this.F = IV$5[5] | 0, this.G = IV$5[6] | 0, this.H = IV$5[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W$5[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W$5[kr - 15], Ar = SHA256_W$5[kr - 2], Er = rotr$5(xr, 7) ^ rotr$5(xr, 18) ^ xr >>> 3, Cr = rotr$5(Ar, 17) ^ rotr$5(Ar, 19) ^ Ar >>> 10;
      SHA256_W$5[kr] = Cr + SHA256_W$5[kr - 7] + Er + SHA256_W$5[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr$5(mr, 6) ^ rotr$5(mr, 11) ^ rotr$5(mr, 25), Ar = _r + xr + Chi$6(mr, vr, yr) + SHA256_K$5[kr] + SHA256_W$5[kr] | 0, Cr = (rotr$5(ur, 2) ^ rotr$5(ur, 13) ^ rotr$5(ur, 22)) + Maj$5(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W$5.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$3 = class extends SHA256$5 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$5 = wrapConstructor$5(() => new SHA256$5());
wrapConstructor$5(() => new SHA224$3());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$9 = BigInt(0), _1n$9 = BigInt(1), _2n$5 = BigInt(2), u8a$7 = (cr) => cr instanceof Uint8Array, hexes$5 = Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$5(cr) {
  if (!u8a$7(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes$5[cr[lr]];
  return ar;
}
function numberToHexUnpadded$1(cr) {
  const ar = cr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber$1(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  return BigInt(cr === "" ? "0" : `0x${cr}`);
}
function hexToBytes$6(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function bytesToNumberBE$1(cr) {
  return hexToNumber$1(bytesToHex$5(cr));
}
function bytesToNumberLE$1(cr) {
  if (!u8a$7(cr))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$5(Uint8Array.from(cr).reverse()));
}
function numberToBytesBE$1(cr, ar) {
  return hexToBytes$6(cr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE$1(cr, ar) {
  return numberToBytesBE$1(cr, ar).reverse();
}
function numberToVarBytesBE$1(cr) {
  return hexToBytes$6(numberToHexUnpadded$1(cr));
}
function ensureBytes$2(cr, ar, lr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$6(ar);
    } catch (fr) {
      throw new Error(`${cr} must be valid hex string, got "${ar}". Cause: ${fr}`);
    }
  else if (u8a$7(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${cr} must be hex string or Uint8Array`);
  const dr = ur.length;
  if (typeof lr == "number" && dr !== lr)
    throw new Error(`${cr} expected ${lr} bytes, got ${dr}`);
  return ur;
}
function concatBytes$6(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$7(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
function equalBytes$2(cr, ar) {
  if (cr.length !== ar.length)
    return !1;
  for (let lr = 0; lr < cr.length; lr++)
    if (cr[lr] !== ar[lr])
      return !1;
  return !0;
}
function utf8ToBytes$7(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function bitLen$1(cr) {
  let ar;
  for (ar = 0; cr > _0n$9; cr >>= _1n$9, ar += 1)
    ;
  return ar;
}
function bitGet$1(cr, ar) {
  return cr >> BigInt(ar) & _1n$9;
}
const bitSet$1 = (cr, ar, lr) => cr | (lr ? _1n$9 : _0n$9) << BigInt(ar), bitMask$1 = (cr) => (_2n$5 << BigInt(cr - 1)) - _1n$9, u8n$1 = (cr) => new Uint8Array(cr), u8fr$1 = (cr) => Uint8Array.from(cr);
function createHmacDrbg$1(cr, ar, lr) {
  if (typeof cr != "number" || cr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof lr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n$1(cr), dr = u8n$1(cr), fr = 0;
  const gr = () => {
    ur.fill(1), dr.fill(0), fr = 0;
  }, mr = (...kr) => lr(dr, ur, ...kr), vr = (kr = u8n$1()) => {
    dr = mr(u8fr$1([0]), kr), ur = mr(), kr.length !== 0 && (dr = mr(u8fr$1([1]), kr), ur = mr());
  }, yr = () => {
    if (fr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let kr = 0;
    const xr = [];
    for (; kr < ar; ) {
      ur = mr();
      const Ar = ur.slice();
      xr.push(Ar), kr += ur.length;
    }
    return concatBytes$6(...xr);
  };
  return (kr, xr) => {
    gr(), vr(kr);
    let Ar;
    for (; !(Ar = xr(yr())); )
      vr();
    return gr(), Ar;
  };
}
const validatorFns$1 = {
  bigint: (cr) => typeof cr == "bigint",
  function: (cr) => typeof cr == "function",
  boolean: (cr) => typeof cr == "boolean",
  string: (cr) => typeof cr == "string",
  isSafeInteger: (cr) => Number.isSafeInteger(cr),
  array: (cr) => Array.isArray(cr),
  field: (cr, ar) => ar.Fp.isValid(cr),
  hash: (cr) => typeof cr == "function" && Number.isSafeInteger(cr.outputLen)
};
function validateObject$1(cr, ar, lr = {}) {
  const ur = (dr, fr, gr) => {
    const mr = validatorFns$1[fr];
    if (typeof mr != "function")
      throw new Error(`Invalid validator "${fr}", expected function`);
    const vr = cr[dr];
    if (!(gr && vr === void 0) && !mr(vr, cr))
      throw new Error(`Invalid param ${String(dr)}=${vr} (${typeof vr}), expected ${fr}`);
  };
  for (const [dr, fr] of Object.entries(ar))
    ur(dr, fr, !1);
  for (const [dr, fr] of Object.entries(lr))
    ur(dr, fr, !0);
  return cr;
}
const ut$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$5,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$6,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$2,
  equalBytes: equalBytes$2,
  hexToBytes: hexToBytes$6,
  hexToNumber: hexToNumber$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$7,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = BigInt(0), _1n$8 = BigInt(1), _2n$4 = BigInt(2), _3n$3 = BigInt(3), _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(cr, ar) {
  const lr = cr % ar;
  return lr >= _0n$8 ? lr : ar + lr;
}
function pow$1(cr, ar, lr) {
  if (lr <= _0n$8 || ar < _0n$8)
    throw new Error("Expected power/modulo > 0");
  if (lr === _1n$8)
    return _0n$8;
  let ur = _1n$8;
  for (; ar > _0n$8; )
    ar & _1n$8 && (ur = ur * cr % lr), cr = cr * cr % lr, ar >>= _1n$8;
  return ur;
}
function pow2$1(cr, ar, lr) {
  let ur = cr;
  for (; ar-- > _0n$8; )
    ur *= ur, ur %= lr;
  return ur;
}
function invert$1(cr, ar) {
  if (cr === _0n$8 || ar <= _0n$8)
    throw new Error(`invert: expected positive integers, got n=${cr} mod=${ar}`);
  let lr = mod$1(cr, ar), ur = ar, dr = _0n$8, fr = _1n$8;
  for (; lr !== _0n$8; ) {
    const mr = ur / lr, vr = ur % lr, yr = dr - fr * mr;
    ur = lr, lr = vr, dr = fr, fr = yr;
  }
  if (ur !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(dr, ar);
}
function tonelliShanks$1(cr) {
  const ar = (cr - _1n$8) / _2n$4;
  let lr, ur, dr;
  for (lr = cr - _1n$8, ur = 0; lr % _2n$4 === _0n$8; lr /= _2n$4, ur++)
    ;
  for (dr = _2n$4; dr < cr && pow$1(dr, ar, cr) !== cr - _1n$8; dr++)
    ;
  if (ur === 1) {
    const gr = (cr + _1n$8) / _4n$1;
    return function(vr, yr) {
      const _r = vr.pow(yr, gr);
      if (!vr.eql(vr.sqr(_r), yr))
        throw new Error("Cannot find square root");
      return _r;
    };
  }
  const fr = (lr + _1n$8) / _2n$4;
  return function(mr, vr) {
    if (mr.pow(vr, ar) === mr.neg(mr.ONE))
      throw new Error("Cannot find square root");
    let yr = ur, _r = mr.pow(mr.mul(mr.ONE, dr), lr), kr = mr.pow(vr, fr), xr = mr.pow(vr, lr);
    for (; !mr.eql(xr, mr.ONE); ) {
      if (mr.eql(xr, mr.ZERO))
        return mr.ZERO;
      let Ar = 1;
      for (let Cr = mr.sqr(xr); Ar < yr && !mr.eql(Cr, mr.ONE); Ar++)
        Cr = mr.sqr(Cr);
      const Er = mr.pow(_r, _1n$8 << BigInt(yr - Ar - 1));
      _r = mr.sqr(Er), kr = mr.mul(kr, Er), xr = mr.mul(xr, _r), yr = Ar;
    }
    return kr;
  };
}
function FpSqrt$1(cr) {
  if (cr % _4n$1 === _3n$3) {
    const ar = (cr + _1n$8) / _4n$1;
    return function(ur, dr) {
      const fr = ur.pow(dr, ar);
      if (!ur.eql(ur.sqr(fr), dr))
        throw new Error("Cannot find square root");
      return fr;
    };
  }
  if (cr % _8n$1 === _5n$1) {
    const ar = (cr - _5n$1) / _8n$1;
    return function(ur, dr) {
      const fr = ur.mul(dr, _2n$4), gr = ur.pow(fr, ar), mr = ur.mul(dr, gr), vr = ur.mul(ur.mul(mr, _2n$4), gr), yr = ur.mul(mr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(yr), dr))
        throw new Error("Cannot find square root");
      return yr;
    };
  }
  return tonelliShanks$1(cr);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(cr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, lr = FIELD_FIELDS$1.reduce((ur, dr) => (ur[dr] = "function", ur), ar);
  return validateObject$1(cr, lr);
}
function FpPow$1(cr, ar, lr) {
  if (lr < _0n$8)
    throw new Error("Expected power > 0");
  if (lr === _0n$8)
    return cr.ONE;
  if (lr === _1n$8)
    return ar;
  let ur = cr.ONE, dr = ar;
  for (; lr > _0n$8; )
    lr & _1n$8 && (ur = cr.mul(ur, dr)), dr = cr.sqr(dr), lr >>= _1n$8;
  return ur;
}
function FpInvertBatch$1(cr, ar) {
  const lr = new Array(ar.length), ur = ar.reduce((fr, gr, mr) => cr.is0(gr) ? fr : (lr[mr] = fr, cr.mul(fr, gr)), cr.ONE), dr = cr.inv(ur);
  return ar.reduceRight((fr, gr, mr) => cr.is0(gr) ? fr : (lr[mr] = cr.mul(fr, lr[mr]), cr.mul(fr, gr)), dr), lr;
}
function nLength$1(cr, ar) {
  const lr = ar !== void 0 ? ar : cr.toString(2).length, ur = Math.ceil(lr / 8);
  return { nBitLength: lr, nByteLength: ur };
}
function Field$1(cr, ar, lr = !1, ur = {}) {
  if (cr <= _0n$8)
    throw new Error(`Expected Fp ORDER > 0, got ${cr}`);
  const { nBitLength: dr, nByteLength: fr } = nLength$1(cr, ar);
  if (fr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const gr = FpSqrt$1(cr), mr = Object.freeze({
    ORDER: cr,
    BITS: dr,
    BYTES: fr,
    MASK: bitMask$1(dr),
    ZERO: _0n$8,
    ONE: _1n$8,
    create: (vr) => mod$1(vr, cr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$8 <= vr && vr < cr;
    },
    is0: (vr) => vr === _0n$8,
    isOdd: (vr) => (vr & _1n$8) === _1n$8,
    neg: (vr) => mod$1(-vr, cr),
    eql: (vr, yr) => vr === yr,
    sqr: (vr) => mod$1(vr * vr, cr),
    add: (vr, yr) => mod$1(vr + yr, cr),
    sub: (vr, yr) => mod$1(vr - yr, cr),
    mul: (vr, yr) => mod$1(vr * yr, cr),
    pow: (vr, yr) => FpPow$1(mr, vr, yr),
    div: (vr, yr) => mod$1(vr * invert$1(yr, cr), cr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, yr) => vr + yr,
    subN: (vr, yr) => vr - yr,
    mulN: (vr, yr) => vr * yr,
    inv: (vr) => invert$1(vr, cr),
    sqrt: ur.sqrt || ((vr) => gr(mr, vr)),
    invertBatch: (vr) => FpInvertBatch$1(mr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, yr, _r) => _r ? yr : vr,
    toBytes: (vr) => lr ? numberToBytesLE$1(vr, fr) : numberToBytesBE$1(vr, fr),
    fromBytes: (vr) => {
      if (vr.length !== fr)
        throw new Error(`Fp.fromBytes: expected ${fr}, got ${vr.length}`);
      return lr ? bytesToNumberLE$1(vr) : bytesToNumberBE$1(vr);
    }
  });
  return Object.freeze(mr);
}
function hashToPrivateScalar(cr, ar, lr = !1) {
  cr = ensureBytes$2("privateHash", cr);
  const ur = cr.length, dr = nLength$1(ar).nByteLength + 8;
  if (dr < 24 || ur < dr || ur > 1024)
    throw new Error(`hashToPrivateScalar: expected ${dr}-1024 bytes of input, got ${ur}`);
  const fr = lr ? bytesToNumberLE$1(cr) : bytesToNumberBE$1(cr);
  return mod$1(fr, ar - _1n$8) + _1n$8;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$7 = BigInt(1);
function wNAF$1(cr, ar) {
  const lr = (dr, fr) => {
    const gr = fr.negate();
    return dr ? gr : fr;
  }, ur = (dr) => {
    const fr = Math.ceil(ar / dr) + 1, gr = 2 ** (dr - 1);
    return { windows: fr, windowSize: gr };
  };
  return {
    constTimeNegate: lr,
    // non-const time multiplication ladder
    unsafeLadder(dr, fr) {
      let gr = cr.ZERO, mr = dr;
      for (; fr > _0n$7; )
        fr & _1n$7 && (gr = gr.add(mr)), mr = mr.double(), fr >>= _1n$7;
      return gr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(dr, fr) {
      const { windows: gr, windowSize: mr } = ur(fr), vr = [];
      let yr = dr, _r = yr;
      for (let kr = 0; kr < gr; kr++) {
        _r = yr, vr.push(_r);
        for (let xr = 1; xr < mr; xr++)
          _r = _r.add(yr), vr.push(_r);
        yr = _r.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(dr, fr, gr) {
      const { windows: mr, windowSize: vr } = ur(dr);
      let yr = cr.ZERO, _r = cr.BASE;
      const kr = BigInt(2 ** dr - 1), xr = 2 ** dr, Ar = BigInt(dr);
      for (let Er = 0; Er < mr; Er++) {
        const Cr = Er * vr;
        let Tr = Number(gr & kr);
        gr >>= Ar, Tr > vr && (Tr -= xr, gr += _1n$7);
        const Sr = Cr, Lr = Cr + Math.abs(Tr) - 1, Ir = Er % 2 !== 0, Nr = Tr < 0;
        Tr === 0 ? _r = _r.add(lr(Ir, fr[Sr])) : yr = yr.add(lr(Nr, fr[Lr]));
      }
      return { p: yr, f: _r };
    },
    wNAFCached(dr, fr, gr, mr) {
      const vr = dr._WINDOW_SIZE || 1;
      let yr = fr.get(dr);
      return yr || (yr = this.precomputeWindow(dr, vr), vr !== 1 && fr.set(dr, mr(yr))), this.wNAF(vr, yr, gr);
    }
  };
}
function validateBasic$1(cr) {
  return validateField$1(cr.Fp), validateObject$1(cr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength$1(cr.n, cr.nBitLength),
    ...cr,
    p: cr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(cr) {
  const ar = validateBasic$1(cr);
  validateObject$1(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: lr, Fp: ur, a: dr } = ar;
  if (lr) {
    if (!ur.eql(dr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof lr != "object" || typeof lr.beta != "bigint" || typeof lr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$2, DER$1 = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(cr) {
    const { Err: ar } = DER$1;
    if (cr.length < 2 || cr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const lr = cr[1], ur = cr.subarray(2, lr + 2);
    if (!lr || ur.length !== lr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(ur), l: cr.subarray(lr + 2) };
  },
  toSig(cr) {
    const { Err: ar } = DER$1, lr = typeof cr == "string" ? h2b$1(cr) : cr;
    if (!(lr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = lr.length;
    if (ur < 2 || lr[0] != 48)
      throw new ar("Invalid signature tag");
    if (lr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: dr, l: fr } = DER$1._parseInt(lr.subarray(2)), { d: gr, l: mr } = DER$1._parseInt(fr);
    if (mr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: dr, s: gr };
  },
  hexFromSig(cr) {
    const ar = (yr) => Number.parseInt(yr[0], 16) & 8 ? "00" + yr : yr, lr = (yr) => {
      const _r = yr.toString(16);
      return _r.length & 1 ? `0${_r}` : _r;
    }, ur = ar(lr(cr.s)), dr = ar(lr(cr.r)), fr = ur.length / 2, gr = dr.length / 2, mr = lr(fr), vr = lr(gr);
    return `30${lr(gr + fr + 4)}02${vr}${dr}02${mr}${ur}`;
  }
}, _0n$6 = BigInt(0), _1n$6 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(cr) {
  const ar = validatePointOpts$1(cr), { Fp: lr } = ar, ur = ar.toBytes || ((Er, Cr, Tr) => {
    const Sr = Cr.toAffine();
    return concatBytes$6(Uint8Array.from([4]), lr.toBytes(Sr.x), lr.toBytes(Sr.y));
  }), dr = ar.fromBytes || ((Er) => {
    const Cr = Er.subarray(1), Tr = lr.fromBytes(Cr.subarray(0, lr.BYTES)), Sr = lr.fromBytes(Cr.subarray(lr.BYTES, 2 * lr.BYTES));
    return { x: Tr, y: Sr };
  });
  function fr(Er) {
    const { a: Cr, b: Tr } = ar, Sr = lr.sqr(Er), Lr = lr.mul(Sr, Er);
    return lr.add(lr.add(Lr, lr.mul(Er, Cr)), Tr);
  }
  if (!lr.eql(lr.sqr(ar.Gy), fr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function gr(Er) {
    return typeof Er == "bigint" && _0n$6 < Er && Er < ar.n;
  }
  function mr(Er) {
    if (!gr(Er))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(Er) {
    const { allowedPrivateKeyLengths: Cr, nByteLength: Tr, wrapPrivateKey: Sr, n: Lr } = ar;
    if (Cr && typeof Er != "bigint") {
      if (Er instanceof Uint8Array && (Er = bytesToHex$5(Er)), typeof Er != "string" || !Cr.includes(Er.length))
        throw new Error("Invalid key");
      Er = Er.padStart(Tr * 2, "0");
    }
    let Ir;
    try {
      Ir = typeof Er == "bigint" ? Er : bytesToNumberBE$1(ensureBytes$2("private key", Er, Tr));
    } catch (Nr) {
      throw new Error(`private key must be ${Tr} bytes, hex or bigint, not ${typeof Er}`);
    }
    return Sr && (Ir = mod$1(Ir, Lr)), mr(Ir), Ir;
  }
  const yr = /* @__PURE__ */ new Map();
  function _r(Er) {
    if (!(Er instanceof kr))
      throw new Error("ProjectivePoint expected");
  }
  class kr {
    constructor(Cr, Tr, Sr) {
      if (this.px = Cr, this.py = Tr, this.pz = Sr, Cr == null || !lr.isValid(Cr))
        throw new Error("x required");
      if (Tr == null || !lr.isValid(Tr))
        throw new Error("y required");
      if (Sr == null || !lr.isValid(Sr))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Cr) {
      const { x: Tr, y: Sr } = Cr || {};
      if (!Cr || !lr.isValid(Tr) || !lr.isValid(Sr))
        throw new Error("invalid affine point");
      if (Cr instanceof kr)
        throw new Error("projective point not allowed");
      const Lr = (Ir) => lr.eql(Ir, lr.ZERO);
      return Lr(Tr) && Lr(Sr) ? kr.ZERO : new kr(Tr, Sr, lr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Cr) {
      const Tr = lr.invertBatch(Cr.map((Sr) => Sr.pz));
      return Cr.map((Sr, Lr) => Sr.toAffine(Tr[Lr])).map(kr.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Cr) {
      const Tr = kr.fromAffine(dr(ensureBytes$2("pointHex", Cr)));
      return Tr.assertValidity(), Tr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Cr) {
      return kr.BASE.multiply(vr(Cr));
    }
    // "Private method", don't use it directly
    _setWindowSize(Cr) {
      this._WINDOW_SIZE = Cr, yr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Cr, y: Tr } = this.toAffine();
      if (!lr.isValid(Cr) || !lr.isValid(Tr))
        throw new Error("bad point: x or y not FE");
      const Sr = lr.sqr(Tr), Lr = fr(Cr);
      if (!lr.eql(Sr, Lr))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Cr } = this.toAffine();
      if (lr.isOdd)
        return !lr.isOdd(Cr);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Cr) {
      _r(Cr);
      const { px: Tr, py: Sr, pz: Lr } = this, { px: Ir, py: Nr, pz: Rr } = Cr, Mr = lr.eql(lr.mul(Tr, Rr), lr.mul(Ir, Lr)), Br = lr.eql(lr.mul(Sr, Rr), lr.mul(Nr, Lr));
      return Mr && Br;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new kr(this.px, lr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Cr, b: Tr } = ar, Sr = lr.mul(Tr, _3n$2), { px: Lr, py: Ir, pz: Nr } = this;
      let Rr = lr.ZERO, Mr = lr.ZERO, Br = lr.ZERO, Dr = lr.mul(Lr, Lr), Hr = lr.mul(Ir, Ir), Fr = lr.mul(Nr, Nr), zr = lr.mul(Lr, Ir);
      return zr = lr.add(zr, zr), Br = lr.mul(Lr, Nr), Br = lr.add(Br, Br), Rr = lr.mul(Cr, Br), Mr = lr.mul(Sr, Fr), Mr = lr.add(Rr, Mr), Rr = lr.sub(Hr, Mr), Mr = lr.add(Hr, Mr), Mr = lr.mul(Rr, Mr), Rr = lr.mul(zr, Rr), Br = lr.mul(Sr, Br), Fr = lr.mul(Cr, Fr), zr = lr.sub(Dr, Fr), zr = lr.mul(Cr, zr), zr = lr.add(zr, Br), Br = lr.add(Dr, Dr), Dr = lr.add(Br, Dr), Dr = lr.add(Dr, Fr), Dr = lr.mul(Dr, zr), Mr = lr.add(Mr, Dr), Fr = lr.mul(Ir, Nr), Fr = lr.add(Fr, Fr), Dr = lr.mul(Fr, zr), Rr = lr.sub(Rr, Dr), Br = lr.mul(Fr, Hr), Br = lr.add(Br, Br), Br = lr.add(Br, Br), new kr(Rr, Mr, Br);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Cr) {
      _r(Cr);
      const { px: Tr, py: Sr, pz: Lr } = this, { px: Ir, py: Nr, pz: Rr } = Cr;
      let Mr = lr.ZERO, Br = lr.ZERO, Dr = lr.ZERO;
      const Hr = ar.a, Fr = lr.mul(ar.b, _3n$2);
      let zr = lr.mul(Tr, Ir), Ur = lr.mul(Sr, Nr), jr = lr.mul(Lr, Rr), Yr = lr.add(Tr, Sr), qr = lr.add(Ir, Nr);
      Yr = lr.mul(Yr, qr), qr = lr.add(zr, Ur), Yr = lr.sub(Yr, qr), qr = lr.add(Tr, Lr);
      let Wr = lr.add(Ir, Rr);
      return qr = lr.mul(qr, Wr), Wr = lr.add(zr, jr), qr = lr.sub(qr, Wr), Wr = lr.add(Sr, Lr), Mr = lr.add(Nr, Rr), Wr = lr.mul(Wr, Mr), Mr = lr.add(Ur, jr), Wr = lr.sub(Wr, Mr), Dr = lr.mul(Hr, qr), Mr = lr.mul(Fr, jr), Dr = lr.add(Mr, Dr), Mr = lr.sub(Ur, Dr), Dr = lr.add(Ur, Dr), Br = lr.mul(Mr, Dr), Ur = lr.add(zr, zr), Ur = lr.add(Ur, zr), jr = lr.mul(Hr, jr), qr = lr.mul(Fr, qr), Ur = lr.add(Ur, jr), jr = lr.sub(zr, jr), jr = lr.mul(Hr, jr), qr = lr.add(qr, jr), zr = lr.mul(Ur, qr), Br = lr.add(Br, zr), zr = lr.mul(Wr, qr), Mr = lr.mul(Yr, Mr), Mr = lr.sub(Mr, zr), zr = lr.mul(Yr, Ur), Dr = lr.mul(Wr, Dr), Dr = lr.add(Dr, zr), new kr(Mr, Br, Dr);
    }
    subtract(Cr) {
      return this.add(Cr.negate());
    }
    is0() {
      return this.equals(kr.ZERO);
    }
    wNAF(Cr) {
      return Ar.wNAFCached(this, yr, Cr, (Tr) => {
        const Sr = lr.invertBatch(Tr.map((Lr) => Lr.pz));
        return Tr.map((Lr, Ir) => Lr.toAffine(Sr[Ir])).map(kr.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Cr) {
      const Tr = kr.ZERO;
      if (Cr === _0n$6)
        return Tr;
      if (mr(Cr), Cr === _1n$6)
        return this;
      const { endo: Sr } = ar;
      if (!Sr)
        return Ar.unsafeLadder(this, Cr);
      let { k1neg: Lr, k1: Ir, k2neg: Nr, k2: Rr } = Sr.splitScalar(Cr), Mr = Tr, Br = Tr, Dr = this;
      for (; Ir > _0n$6 || Rr > _0n$6; )
        Ir & _1n$6 && (Mr = Mr.add(Dr)), Rr & _1n$6 && (Br = Br.add(Dr)), Dr = Dr.double(), Ir >>= _1n$6, Rr >>= _1n$6;
      return Lr && (Mr = Mr.negate()), Nr && (Br = Br.negate()), Br = new kr(lr.mul(Br.px, Sr.beta), Br.py, Br.pz), Mr.add(Br);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Cr) {
      mr(Cr);
      let Tr = Cr, Sr, Lr;
      const { endo: Ir } = ar;
      if (Ir) {
        const { k1neg: Nr, k1: Rr, k2neg: Mr, k2: Br } = Ir.splitScalar(Tr);
        let { p: Dr, f: Hr } = this.wNAF(Rr), { p: Fr, f: zr } = this.wNAF(Br);
        Dr = Ar.constTimeNegate(Nr, Dr), Fr = Ar.constTimeNegate(Mr, Fr), Fr = new kr(lr.mul(Fr.px, Ir.beta), Fr.py, Fr.pz), Sr = Dr.add(Fr), Lr = Hr.add(zr);
      } else {
        const { p: Nr, f: Rr } = this.wNAF(Tr);
        Sr = Nr, Lr = Rr;
      }
      return kr.normalizeZ([Sr, Lr])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Cr, Tr, Sr) {
      const Lr = kr.BASE, Ir = (Rr, Mr) => Mr === _0n$6 || Mr === _1n$6 || !Rr.equals(Lr) ? Rr.multiplyUnsafe(Mr) : Rr.multiply(Mr), Nr = Ir(this, Tr).add(Ir(Cr, Sr));
      return Nr.is0() ? void 0 : Nr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(Cr) {
      const { px: Tr, py: Sr, pz: Lr } = this, Ir = this.is0();
      Cr == null && (Cr = Ir ? lr.ONE : lr.inv(Lr));
      const Nr = lr.mul(Tr, Cr), Rr = lr.mul(Sr, Cr), Mr = lr.mul(Lr, Cr);
      if (Ir)
        return { x: lr.ZERO, y: lr.ZERO };
      if (!lr.eql(Mr, lr.ONE))
        throw new Error("invZ was invalid");
      return { x: Nr, y: Rr };
    }
    isTorsionFree() {
      const { h: Cr, isTorsionFree: Tr } = ar;
      if (Cr === _1n$6)
        return !0;
      if (Tr)
        return Tr(kr, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Cr, clearCofactor: Tr } = ar;
      return Cr === _1n$6 ? this : Tr ? Tr(kr, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Cr = !0) {
      return this.assertValidity(), ur(kr, this, Cr);
    }
    toHex(Cr = !0) {
      return bytesToHex$5(this.toRawBytes(Cr));
    }
  }
  kr.BASE = new kr(ar.Gx, ar.Gy, lr.ONE), kr.ZERO = new kr(lr.ZERO, lr.ONE, lr.ZERO);
  const xr = ar.nBitLength, Ar = wNAF$1(kr, ar.endo ? Math.ceil(xr / 2) : xr);
  return {
    CURVE: ar,
    ProjectivePoint: kr,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: fr,
    isWithinCurveOrder: gr
  };
}
function validateOpts$1(cr) {
  const ar = validateBasic$1(cr);
  return validateObject$1(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass$1(cr) {
  const ar = validateOpts$1(cr), { Fp: lr, n: ur } = ar, dr = lr.BYTES + 1, fr = 2 * lr.BYTES + 1;
  function gr(qr) {
    return _0n$6 < qr && qr < lr.ORDER;
  }
  function mr(qr) {
    return mod$1(qr, ur);
  }
  function vr(qr) {
    return invert$1(qr, ur);
  }
  const { ProjectivePoint: yr, normPrivateKeyToScalar: _r, weierstrassEquation: kr, isWithinCurveOrder: xr } = weierstrassPoints$1({
    ...ar,
    toBytes(qr, Wr, Jr) {
      const Gr = Wr.toAffine(), Vr = lr.toBytes(Gr.x), Qr = concatBytes$6;
      return Jr ? Qr(Uint8Array.from([Wr.hasEvenY() ? 2 : 3]), Vr) : Qr(Uint8Array.from([4]), Vr, lr.toBytes(Gr.y));
    },
    fromBytes(qr) {
      const Wr = qr.length, Jr = qr[0], Gr = qr.subarray(1);
      if (Wr === dr && (Jr === 2 || Jr === 3)) {
        const Vr = bytesToNumberBE$1(Gr);
        if (!gr(Vr))
          throw new Error("Point is not on curve");
        const Qr = kr(Vr);
        let $r = lr.sqrt(Qr);
        const Xr = ($r & _1n$6) === _1n$6;
        return (Jr & 1) === 1 !== Xr && ($r = lr.neg($r)), { x: Vr, y: $r };
      } else if (Wr === fr && Jr === 4) {
        const Vr = lr.fromBytes(Gr.subarray(0, lr.BYTES)), Qr = lr.fromBytes(Gr.subarray(lr.BYTES, 2 * lr.BYTES));
        return { x: Vr, y: Qr };
      } else
        throw new Error(`Point of length ${Wr} was invalid. Expected ${dr} compressed bytes or ${fr} uncompressed bytes`);
    }
  }), Ar = (qr) => bytesToHex$5(numberToBytesBE$1(qr, ar.nByteLength));
  function Er(qr) {
    const Wr = ur >> _1n$6;
    return qr > Wr;
  }
  function Cr(qr) {
    return Er(qr) ? mr(-qr) : qr;
  }
  const Tr = (qr, Wr, Jr) => bytesToNumberBE$1(qr.slice(Wr, Jr));
  class Sr {
    constructor(Wr, Jr, Gr) {
      this.r = Wr, this.s = Jr, this.recovery = Gr, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Wr) {
      const Jr = ar.nByteLength;
      return Wr = ensureBytes$2("compactSignature", Wr, Jr * 2), new Sr(Tr(Wr, 0, Jr), Tr(Wr, Jr, 2 * Jr));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Wr) {
      const { r: Jr, s: Gr } = DER$1.toSig(ensureBytes$2("DER", Wr));
      return new Sr(Jr, Gr);
    }
    assertValidity() {
      if (!xr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!xr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Wr) {
      return new Sr(this.r, this.s, Wr);
    }
    recoverPublicKey(Wr) {
      const { r: Jr, s: Gr, recovery: Vr } = this, Qr = Br(ensureBytes$2("msgHash", Wr));
      if (Vr == null || ![0, 1, 2, 3].includes(Vr))
        throw new Error("recovery id invalid");
      const $r = Vr === 2 || Vr === 3 ? Jr + ar.n : Jr;
      if ($r >= lr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Xr = Vr & 1 ? "03" : "02", si = yr.fromHex(Xr + Ar($r)), Zr = vr($r), li = mr(-Qr * Zr), Ei = mr(Gr * Zr), ki = yr.BASE.multiplyAndAddUnsafe(si, li, Ei);
      if (!ki)
        throw new Error("point at infinify");
      return ki.assertValidity(), ki;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return Er(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Sr(this.r, mr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$6(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$6(this.toCompactHex());
    }
    toCompactHex() {
      return Ar(this.r) + Ar(this.s);
    }
  }
  const Lr = {
    isValidPrivateKey(qr) {
      try {
        return _r(qr), !0;
      } catch (Wr) {
        return !1;
      }
    },
    normPrivateKeyToScalar: _r,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const qr = ar.randomBytes(lr.BYTES + 8), Wr = hashToPrivateScalar(qr, ur);
      return numberToBytesBE$1(Wr, ar.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(qr = 8, Wr = yr.BASE) {
      return Wr._setWindowSize(qr), Wr.multiply(BigInt(3)), Wr;
    }
  };
  function Ir(qr, Wr = !0) {
    return yr.fromPrivateKey(qr).toRawBytes(Wr);
  }
  function Nr(qr) {
    const Wr = qr instanceof Uint8Array, Jr = typeof qr == "string", Gr = (Wr || Jr) && qr.length;
    return Wr ? Gr === dr || Gr === fr : Jr ? Gr === 2 * dr || Gr === 2 * fr : qr instanceof yr;
  }
  function Rr(qr, Wr, Jr = !0) {
    if (Nr(qr))
      throw new Error("first arg must be private key");
    if (!Nr(Wr))
      throw new Error("second arg must be public key");
    return yr.fromHex(Wr).multiply(_r(qr)).toRawBytes(Jr);
  }
  const Mr = ar.bits2int || function(qr) {
    const Wr = bytesToNumberBE$1(qr), Jr = qr.length * 8 - ar.nBitLength;
    return Jr > 0 ? Wr >> BigInt(Jr) : Wr;
  }, Br = ar.bits2int_modN || function(qr) {
    return mr(Mr(qr));
  }, Dr = bitMask$1(ar.nBitLength);
  function Hr(qr) {
    if (typeof qr != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$6 <= qr && qr < Dr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE$1(qr, ar.nByteLength);
  }
  function Fr(qr, Wr, Jr = zr) {
    if (["recovered", "canonical"].some((hi) => hi in Jr))
      throw new Error("sign() legacy options not supported");
    const { hash: Gr, randomBytes: Vr } = ar;
    let { lowS: Qr, prehash: $r, extraEntropy: Xr } = Jr;
    Qr == null && (Qr = !0), qr = ensureBytes$2("msgHash", qr), $r && (qr = ensureBytes$2("prehashed msgHash", Gr(qr)));
    const si = Br(qr), Zr = _r(Wr), li = [Hr(Zr), Hr(si)];
    if (Xr != null) {
      const hi = Xr === !0 ? Vr(lr.BYTES) : Xr;
      li.push(ensureBytes$2("extraEntropy", hi, lr.BYTES));
    }
    const Ei = concatBytes$6(...li), ki = si;
    function Di(hi) {
      const Ti = Mr(hi);
      if (!xr(Ti))
        return;
      const fi = vr(Ti), Mi = yr.BASE.multiply(Ti).toAffine(), oi = mr(Mi.x);
      if (oi === _0n$6)
        return;
      const Ri = mr(fi * mr(ki + oi * Zr));
      if (Ri === _0n$6)
        return;
      let qi = (Mi.x === oi ? 0 : 2) | Number(Mi.y & _1n$6), zi = Ri;
      return Qr && Er(Ri) && (zi = Cr(Ri), qi ^= 1), new Sr(oi, zi, qi);
    }
    return { seed: Ei, k2sig: Di };
  }
  const zr = { lowS: ar.lowS, prehash: !1 }, Ur = { lowS: ar.lowS, prehash: !1 };
  function jr(qr, Wr, Jr = zr) {
    const { seed: Gr, k2sig: Vr } = Fr(qr, Wr, Jr), Qr = ar;
    return createHmacDrbg$1(Qr.hash.outputLen, Qr.nByteLength, Qr.hmac)(Gr, Vr);
  }
  yr.BASE._setWindowSize(8);
  function Yr(qr, Wr, Jr, Gr = Ur) {
    var Mi;
    const Vr = qr;
    if (Wr = ensureBytes$2("msgHash", Wr), Jr = ensureBytes$2("publicKey", Jr), "strict" in Gr)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Qr, prehash: $r } = Gr;
    let Xr, si;
    try {
      if (typeof Vr == "string" || Vr instanceof Uint8Array)
        try {
          Xr = Sr.fromDER(Vr);
        } catch (oi) {
          if (!(oi instanceof DER$1.Err))
            throw oi;
          Xr = Sr.fromCompact(Vr);
        }
      else if (typeof Vr == "object" && typeof Vr.r == "bigint" && typeof Vr.s == "bigint") {
        const { r: oi, s: Ri } = Vr;
        Xr = new Sr(oi, Ri);
      } else
        throw new Error("PARSE");
      si = yr.fromHex(Jr);
    } catch (oi) {
      if (oi.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Qr && Xr.hasHighS())
      return !1;
    $r && (Wr = ar.hash(Wr));
    const { r: Zr, s: li } = Xr, Ei = Br(Wr), ki = vr(li), Di = mr(Ei * ki), hi = mr(Zr * ki), Ti = (Mi = yr.BASE.multiplyAndAddUnsafe(si, Di, hi)) == null ? void 0 : Mi.toAffine();
    return Ti ? mr(Ti.x) === Zr : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Ir,
    getSharedSecret: Rr,
    sign: jr,
    verify: Yr,
    ProjectivePoint: yr,
    Signature: Sr,
    utils: Lr
  };
}
let HMAC$5 = class extends Hash$5 {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, assert$6.hash(ar);
    const ur = toBytes$6(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return assert$6.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$6.exists(this), assert$6.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$5 = (cr, ar, lr) => new HMAC$5(cr, ar).update(lr).digest();
hmac$5.create = (cr, ar) => new HMAC$5(cr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(cr) {
  return {
    hash: cr,
    hmac: (ar, ...lr) => hmac$5(cr, ar, concatBytes$7(...lr)),
    randomBytes: randomBytes$5
  };
}
function createCurve$1(cr, ar) {
  const lr = (ur) => weierstrass$1({ ...cr, ...getHash$1(ur) });
  return Object.freeze({ ...lr(ar), create: lr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$5 = BigInt(1), _2n$3 = BigInt(2), divNearest$1 = (cr, ar) => (cr + ar / _2n$3) / ar;
function sqrtMod$1(cr) {
  const ar = secp256k1P$1, lr = BigInt(3), ur = BigInt(6), dr = BigInt(11), fr = BigInt(22), gr = BigInt(23), mr = BigInt(44), vr = BigInt(88), yr = cr * cr * cr % ar, _r = yr * yr * cr % ar, kr = pow2$1(_r, lr, ar) * _r % ar, xr = pow2$1(kr, lr, ar) * _r % ar, Ar = pow2$1(xr, _2n$3, ar) * yr % ar, Er = pow2$1(Ar, dr, ar) * Ar % ar, Cr = pow2$1(Er, fr, ar) * Er % ar, Tr = pow2$1(Cr, mr, ar) * Cr % ar, Sr = pow2$1(Tr, vr, ar) * Tr % ar, Lr = pow2$1(Sr, mr, ar) * Cr % ar, Ir = pow2$1(Lr, lr, ar) * _r % ar, Nr = pow2$1(Ir, gr, ar) * Er % ar, Rr = pow2$1(Nr, ur, ar) * yr % ar, Mr = pow2$1(Rr, _2n$3, ar);
  if (!Fp$1.eql(Fp$1.sqr(Mr), cr))
    throw new Error("Cannot find square root");
  return Mr;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 }), secp256k1$1 = createCurve$1({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (cr) => {
      const ar = secp256k1N$1, lr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n$5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), dr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), fr = lr, gr = BigInt("0x100000000000000000000000000000000"), mr = divNearest$1(fr * cr, ar), vr = divNearest$1(-ur * cr, ar);
      let yr = mod$1(cr - mr * lr - vr * dr, ar), _r = mod$1(-mr * ur - vr * fr, ar);
      const kr = yr > gr, xr = _r > gr;
      if (kr && (yr = ar - yr), xr && (_r = ar - _r), yr > gr || _r > gr)
        throw new Error("splitScalar: Endomorphism failed, k=" + cr);
      return { k1neg: kr, k1: yr, k2neg: xr, k2: _r };
    }
  }
}, sha256$5), _0n$5 = BigInt(0), fe$2 = (cr) => typeof cr == "bigint" && _0n$5 < cr && cr < secp256k1P$1, ge$3 = (cr) => typeof cr == "bigint" && _0n$5 < cr && cr < secp256k1N$1, TAGGED_HASH_PREFIXES$1 = {};
function taggedHash$1(cr, ...ar) {
  let lr = TAGGED_HASH_PREFIXES$1[cr];
  if (lr === void 0) {
    const ur = sha256$5(Uint8Array.from(cr, (dr) => dr.charCodeAt(0)));
    lr = concatBytes$6(ur, ur), TAGGED_HASH_PREFIXES$1[cr] = lr;
  }
  return sha256$5(concatBytes$6(lr, ...ar));
}
const pointToBytes$1 = (cr) => cr.toRawBytes(!0).slice(1), numTo32b$1 = (cr) => numberToBytesBE$1(cr, 32), modP$1 = (cr) => mod$1(cr, secp256k1P$1), modN$1 = (cr) => mod$1(cr, secp256k1N$1), Point$2 = secp256k1$1.ProjectivePoint, GmulAdd$1 = (cr, ar, lr) => Point$2.BASE.multiplyAndAddUnsafe(cr, ar, lr);
function schnorrGetExtPubKey$1(cr) {
  let ar = secp256k1$1.utils.normPrivateKeyToScalar(cr), lr = Point$2.fromPrivateKey(ar);
  return { scalar: lr.hasEvenY() ? ar : modN$1(-ar), bytes: pointToBytes$1(lr) };
}
function lift_x$1(cr) {
  if (!fe$2(cr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP$1(cr * cr), lr = modP$1(ar * cr + BigInt(7));
  let ur = sqrtMod$1(lr);
  ur % _2n$3 !== _0n$5 && (ur = modP$1(-ur));
  const dr = new Point$2(cr, ur, _1n$5);
  return dr.assertValidity(), dr;
}
function challenge$1(...cr) {
  return modN$1(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge", ...cr)));
}
function schnorrGetPublicKey$1(cr) {
  return schnorrGetExtPubKey$1(cr).bytes;
}
function schnorrSign$1(cr, ar, lr = randomBytes$5(32)) {
  const ur = ensureBytes$2("message", cr), { bytes: dr, scalar: fr } = schnorrGetExtPubKey$1(ar), gr = ensureBytes$2("auxRand", lr, 32), mr = numTo32b$1(fr ^ bytesToNumberBE$1(taggedHash$1("BIP0340/aux", gr))), vr = taggedHash$1("BIP0340/nonce", mr, dr, ur), yr = modN$1(bytesToNumberBE$1(vr));
  if (yr === _0n$5)
    throw new Error("sign failed: k is zero");
  const { bytes: _r, scalar: kr } = schnorrGetExtPubKey$1(yr), xr = challenge$1(_r, dr, ur), Ar = new Uint8Array(64);
  if (Ar.set(_r, 0), Ar.set(numTo32b$1(modN$1(kr + xr * fr)), 32), !schnorrVerify$1(Ar, ur, dr))
    throw new Error("sign: Invalid signature produced");
  return Ar;
}
function schnorrVerify$1(cr, ar, lr) {
  const ur = ensureBytes$2("signature", cr, 64), dr = ensureBytes$2("message", ar), fr = ensureBytes$2("publicKey", lr, 32);
  try {
    const gr = lift_x$1(bytesToNumberBE$1(fr)), mr = bytesToNumberBE$1(ur.subarray(0, 32));
    if (!fe$2(mr))
      return !1;
    const vr = bytesToNumberBE$1(ur.subarray(32, 64));
    if (!ge$3(vr))
      return !1;
    const yr = challenge$1(numTo32b$1(mr), pointToBytes$1(gr), dr), _r = GmulAdd$1(gr, vr, modN$1(-yr));
    return !(!_r || !_r.hasEvenY() || _r.toAffine().x !== mr);
  } catch (gr) {
    return !1;
  }
}
const schnorr$1 = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey$1,
  sign: schnorrSign$1,
  verify: schnorrVerify$1,
  utils: {
    randomPrivateKey: secp256k1$1.utils.randomPrivateKey,
    lift_x: lift_x$1,
    pointToBytes: pointToBytes$1,
    numberToBytesBE: numberToBytesBE$1,
    bytesToNumberBE: bytesToNumberBE$1,
    taggedHash: taggedHash$1,
    mod: mod$1
  }
}))(), crypto$5 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$6 = (cr) => cr instanceof Uint8Array, createView$4 = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr$4 = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE$5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$5)
  throw new Error("Non little-endian hardware is not supported");
const hexes$4 = Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$4(cr) {
  if (!u8a$6(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes$4[cr[lr]];
  return ar;
}
function hexToBytes$5(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function utf8ToBytes$6(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$5(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$6(cr)), !u8a$6(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes$5(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$6(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
let Hash$4 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$4(cr) {
  const ar = (ur) => cr().update(toBytes$5(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes$4(cr = 32) {
  if (crypto$5 && typeof crypto$5.getRandomValues == "function")
    return crypto$5.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$5(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool$4(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes$5(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$5(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$5(cr.outputLen), number$5(cr.blockLen);
}
function exists$5(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$5(cr, ar) {
  bytes$5(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert$5 = {
  number: number$5,
  bool: bool$4,
  bytes: bytes$5,
  hash: hash$5,
  exists: exists$5,
  output: output$5
};
function setBigUint64$4(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
let SHA2$4 = class extends Hash$4 {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$4(this.buffer);
  }
  update(ar) {
    assert$5.exists(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes$5(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView$4(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.output(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64$4(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView$4(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
};
const Chi$5 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj$4 = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K$4 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$4 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$4 = new Uint32Array(64);
let SHA256$4 = class extends SHA2$4 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$4[0] | 0, this.B = IV$4[1] | 0, this.C = IV$4[2] | 0, this.D = IV$4[3] | 0, this.E = IV$4[4] | 0, this.F = IV$4[5] | 0, this.G = IV$4[6] | 0, this.H = IV$4[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W$4[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W$4[kr - 15], Ar = SHA256_W$4[kr - 2], Er = rotr$4(xr, 7) ^ rotr$4(xr, 18) ^ xr >>> 3, Cr = rotr$4(Ar, 17) ^ rotr$4(Ar, 19) ^ Ar >>> 10;
      SHA256_W$4[kr] = Cr + SHA256_W$4[kr - 7] + Er + SHA256_W$4[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr$4(mr, 6) ^ rotr$4(mr, 11) ^ rotr$4(mr, 25), Ar = _r + xr + Chi$5(mr, vr, yr) + SHA256_K$4[kr] + SHA256_W$4[kr] | 0, Cr = (rotr$4(ur, 2) ^ rotr$4(ur, 13) ^ rotr$4(ur, 22)) + Maj$4(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W$4.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$2 = class extends SHA256$4 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$4 = wrapConstructor$4(() => new SHA256$4());
wrapConstructor$4(() => new SHA224$2());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$2(cr) {
  if (!Number.isSafeInteger(cr))
    throw new Error(`Wrong integer: ${cr}`);
}
function chain$3(...cr) {
  const ar = (dr, fr) => (gr) => dr(fr(gr)), lr = Array.from(cr).reverse().reduce((dr, fr) => dr ? ar(dr, fr.encode) : fr.encode, void 0), ur = cr.reduce((dr, fr) => dr ? ar(dr, fr.decode) : fr.decode, void 0);
  return { encode: lr, decode: ur };
}
function alphabet$3(cr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((lr) => {
        if (assertNumber$2(lr), lr < 0 || lr >= cr.length)
          throw new Error(`Digit index outside alphabet: ${lr} (alphabet: ${cr.length})`);
        return cr[lr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((lr) => {
        if (typeof lr != "string")
          throw new Error(`alphabet.decode: not string element=${lr}`);
        const ur = cr.indexOf(lr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${lr}". Allowed: ${cr}`);
        return ur;
      });
    }
  };
}
function join$4(cr = "") {
  if (typeof cr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let lr of ar)
        if (typeof lr != "string")
          throw new Error(`join.encode: non-string input=${lr}`);
      return ar.join(cr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(cr);
    }
  };
}
function padding$3(cr, ar = "=") {
  if (assertNumber$2(cr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of lr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; lr.length * cr % 8; )
        lr.push(ar);
      return lr;
    },
    decode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let dr of lr)
        if (typeof dr != "string")
          throw new Error(`padding.decode: non-string input=${dr}`);
      let ur = lr.length;
      if (ur * cr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && lr[ur - 1] === ar; ur--)
        if (!((ur - 1) * cr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return lr.slice(0, ur);
    }
  };
}
function normalize$4(cr) {
  if (typeof cr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => cr(ar) };
}
function convertRadix$3(cr, ar, lr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (lr < 2)
    throw new Error(`convertRadix: wrong to=${lr}, base cannot be less than 2`);
  if (!Array.isArray(cr))
    throw new Error("convertRadix: data should be array");
  if (!cr.length)
    return [];
  let ur = 0;
  const dr = [], fr = Array.from(cr);
  for (fr.forEach((gr) => {
    if (assertNumber$2(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < fr.length; vr++) {
      const yr = fr[vr], _r = ar * gr + yr;
      if (!Number.isSafeInteger(_r) || ar * gr / ar !== gr || _r - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = _r % lr, fr[vr] = Math.floor(_r / lr), !Number.isSafeInteger(fr[vr]) || fr[vr] * lr + gr !== _r)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        fr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (dr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < cr.length - 1 && cr[gr] === 0; gr++)
    dr.push(0);
  return dr.reverse();
}
const gcd$3 = (cr, ar) => ar ? gcd$3(ar, cr % ar) : cr, radix2carry$3 = (cr, ar) => cr + (ar - gcd$3(cr, ar));
function convertRadix2$3(cr, ar, lr, ur) {
  if (!Array.isArray(cr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (lr <= 0 || lr > 32)
    throw new Error(`convertRadix2: wrong to=${lr}`);
  if (radix2carry$3(ar, lr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${lr} carryBits=${radix2carry$3(ar, lr)}`);
  let dr = 0, fr = 0;
  const gr = 2 ** lr - 1, mr = [];
  for (const vr of cr) {
    if (assertNumber$2(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (dr = dr << ar | vr, fr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${fr} from=${ar}`);
    for (fr += ar; fr >= lr; fr -= lr)
      mr.push((dr >> fr - lr & gr) >>> 0);
    dr &= 2 ** fr - 1;
  }
  if (dr = dr << lr - fr & gr, !ur && fr >= ar)
    throw new Error("Excess padding");
  if (!ur && dr)
    throw new Error(`Non-zero padding: ${dr}`);
  return ur && fr > 0 && mr.push(dr >>> 0), mr;
}
function radix$3(cr) {
  return assertNumber$2(cr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$3(Array.from(ar), 2 ** 8, cr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$3(ar, cr, 2 ** 8));
    }
  };
}
function radix2$3(cr, ar = !1) {
  if (assertNumber$2(cr), cr <= 0 || cr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$3(8, cr) > 32 || radix2carry$3(cr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (lr) => {
      if (!(lr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$3(Array.from(lr), 8, cr, !ar);
    },
    decode: (lr) => {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$3(lr, cr, 8, ar));
    }
  };
}
function unsafeWrapper$2(cr) {
  if (typeof cr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return cr.apply(null, ar);
    } catch (lr) {
    }
  };
}
const base16$2 = chain$3(radix2$3(4), alphabet$3("0123456789ABCDEF"), join$4("")), base32$2 = chain$3(radix2$3(5), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$3(5), join$4(""));
chain$3(radix2$3(5), alphabet$3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$4(""), normalize$4((cr) => cr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$3(6), join$4("")), base64url$2 = chain$3(radix2$3(6), alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$3(6), join$4("")), genBase58$3 = (cr) => chain$3(radix$3(58), alphabet$3(cr), join$4("")), base58$3 = genBase58$3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$2 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$2 = {
  encode(cr) {
    let ar = "";
    for (let lr = 0; lr < cr.length; lr += 8) {
      const ur = cr.subarray(lr, lr + 8);
      ar += base58$3.encode(ur).padStart(XMR_BLOCK_LEN$2[ur.length], "1");
    }
    return ar;
  },
  decode(cr) {
    let ar = [];
    for (let lr = 0; lr < cr.length; lr += 11) {
      const ur = cr.slice(lr, lr + 11), dr = XMR_BLOCK_LEN$2.indexOf(ur.length), fr = base58$3.decode(ur);
      for (let gr = 0; gr < fr.length - dr; gr++)
        if (fr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(fr.slice(fr.length - dr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$2 = chain$3(alphabet$3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$4("")), POLYMOD_GENERATORS$2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$2(cr) {
  const ar = cr >> 25;
  let lr = (cr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$2.length; ur++)
    (ar >> ur & 1) === 1 && (lr ^= POLYMOD_GENERATORS$2[ur]);
  return lr;
}
function bechChecksum$2(cr, ar, lr = 1) {
  const ur = cr.length;
  let dr = 1;
  for (let fr = 0; fr < ur; fr++) {
    const gr = cr.charCodeAt(fr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${cr})`);
    dr = bech32Polymod$2(dr) ^ gr >> 5;
  }
  dr = bech32Polymod$2(dr);
  for (let fr = 0; fr < ur; fr++)
    dr = bech32Polymod$2(dr) ^ cr.charCodeAt(fr) & 31;
  for (let fr of ar)
    dr = bech32Polymod$2(dr) ^ fr;
  for (let fr = 0; fr < 6; fr++)
    dr = bech32Polymod$2(dr);
  return dr ^= lr, BECH_ALPHABET$2.encode(convertRadix2$3([dr % 2 ** 30], 30, 5, !1));
}
function genBech32$2(cr) {
  const ar = cr === "bech32" ? 1 : 734539939, lr = radix2$3(5), ur = lr.decode, dr = lr.encode, fr = unsafeWrapper$2(ur);
  function gr(_r, kr, xr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof _r}`);
    if (!Array.isArray(kr) || kr.length && typeof kr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof kr}`);
    const Ar = _r.length + 7 + kr.length;
    if (xr !== !1 && Ar > xr)
      throw new TypeError(`Length ${Ar} exceeds limit ${xr}`);
    return _r = _r.toLowerCase(), `${_r}1${BECH_ALPHABET$2.encode(kr)}${bechChecksum$2(_r, kr, ar)}`;
  }
  function mr(_r, kr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof _r}`);
    if (_r.length < 8 || kr !== !1 && _r.length > kr)
      throw new TypeError(`Wrong string length: ${_r.length} (${_r}). Expected (8..${kr})`);
    const xr = _r.toLowerCase();
    if (_r !== xr && _r !== _r.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    _r = xr;
    const Ar = _r.lastIndexOf("1");
    if (Ar === 0 || Ar === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = _r.slice(0, Ar), Cr = _r.slice(Ar + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET$2.decode(Cr).slice(0, -6), Sr = bechChecksum$2(Er, Tr, ar);
    if (!Cr.endsWith(Sr))
      throw new Error(`Invalid checksum in ${_r}: expected "${Sr}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper$2(mr);
  function yr(_r) {
    const { prefix: kr, words: xr } = mr(_r, !1);
    return { prefix: kr, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: fr, toWords: dr };
}
const bech32$3 = genBech32$2("bech32");
genBech32$2("bech32m");
const utf8$2 = {
  encode: (cr) => new TextDecoder().decode(cr),
  decode: (cr) => new TextEncoder().encode(cr)
}, hex$2 = chain$3(radix2$3(4), alphabet$3("0123456789abcdef"), join$4(""), normalize$4((cr) => {
  if (typeof cr != "string" || cr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof cr} with length ${cr.length}`);
  return cr.toLowerCase();
})), CODERS$2 = {
  utf8: utf8$2,
  hex: hex$2,
  base16: base16$2,
  base32: base32$2,
  base64: base64$2,
  base64url: base64url$2,
  base58: base58$3,
  base58xmr: base58xmr$2
};
`${Object.keys(CODERS$2).join(", ")}`;
const wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split(`
`);
function number$4(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool$3(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes$4(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$4(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$4(cr.outputLen), number$4(cr.blockLen);
}
function exists$4(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$4(cr, ar) {
  bytes$4(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert$3 = { number: number$4, bool: bool$3, bytes: bytes$4, hash: hash$4, exists: exists$4, output: output$4 }, assert$4 = assert$3, crypto$4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$5 = (cr) => cr instanceof Uint8Array, createView$3 = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr$3 = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE$4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$4)
  throw new Error("Non little-endian hardware is not supported");
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$3(cr) {
  if (!u8a$5(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes$3[cr[lr]];
  return ar;
}
function hexToBytes$4(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function utf8ToBytes$5(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$4(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$5(cr)), !u8a$5(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes$4(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$5(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
let Hash$3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts$1(cr, ar) {
  if (ar !== void 0 && toStr.call(ar) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(cr, ar);
}
function wrapConstructor$3(cr) {
  const ar = (ur) => cr().update(toBytes$4(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes$3(cr = 32) {
  if (crypto$4 && typeof crypto$4.getRandomValues == "function")
    return crypto$4.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$4 = class extends Hash$3 {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, hash$4(ar);
    const ur = toBytes$4(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return exists$4(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$4(this), bytes$4(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$4 = (cr, ar, lr) => new HMAC$4(cr, ar).update(lr).digest();
hmac$4.create = (cr, ar) => new HMAC$4(cr, ar);
function pbkdf2Init(cr, ar, lr, ur) {
  hash$4(cr);
  const dr = checkOpts$1({ dkLen: 32, asyncTick: 10 }, ur), { c: fr, dkLen: gr, asyncTick: mr } = dr;
  if (number$4(fr), number$4(gr), number$4(mr), fr < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const vr = toBytes$4(ar), yr = toBytes$4(lr), _r = new Uint8Array(gr), kr = hmac$4.create(cr, vr), xr = kr._cloneInto().update(yr);
  return { c: fr, dkLen: gr, asyncTick: mr, DK: _r, PRF: kr, PRFSalt: xr };
}
function pbkdf2Output(cr, ar, lr, ur, dr) {
  return cr.destroy(), ar.destroy(), ur && ur.destroy(), dr.fill(0), lr;
}
function pbkdf2(cr, ar, lr, ur) {
  const { c: dr, dkLen: fr, DK: gr, PRF: mr, PRFSalt: vr } = pbkdf2Init(cr, ar, lr, ur);
  let yr;
  const _r = new Uint8Array(4), kr = createView$3(_r), xr = new Uint8Array(mr.outputLen);
  for (let Ar = 1, Er = 0; Er < fr; Ar++, Er += mr.outputLen) {
    const Cr = gr.subarray(Er, Er + mr.outputLen);
    kr.setInt32(0, Ar, !1), (yr = vr._cloneInto(yr)).update(_r).digestInto(xr), Cr.set(xr.subarray(0, Cr.length));
    for (let Tr = 1; Tr < dr; Tr++) {
      mr._cloneInto(yr).update(xr).digestInto(xr);
      for (let Sr = 0; Sr < Cr.length; Sr++)
        Cr[Sr] ^= xr[Sr];
    }
  }
  return pbkdf2Output(mr, vr, gr, yr, xr);
}
function setBigUint64$3(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
let SHA2$3 = class extends Hash$3 {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$3(this.buffer);
  }
  update(ar) {
    exists$4(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes$4(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView$3(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$4(this), output$4(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64$3(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView$3(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
};
const Chi$4 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj$3 = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K$3 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$3 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$3 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$3 = class extends SHA2$3 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$3[0] | 0, this.B = IV$3[1] | 0, this.C = IV$3[2] | 0, this.D = IV$3[3] | 0, this.E = IV$3[4] | 0, this.F = IV$3[5] | 0, this.G = IV$3[6] | 0, this.H = IV$3[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W$3[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W$3[kr - 15], Ar = SHA256_W$3[kr - 2], Er = rotr$3(xr, 7) ^ rotr$3(xr, 18) ^ xr >>> 3, Cr = rotr$3(Ar, 17) ^ rotr$3(Ar, 19) ^ Ar >>> 10;
      SHA256_W$3[kr] = Cr + SHA256_W$3[kr - 7] + Er + SHA256_W$3[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr$3(mr, 6) ^ rotr$3(mr, 11) ^ rotr$3(mr, 25), Ar = _r + xr + Chi$4(mr, vr, yr) + SHA256_K$3[kr] + SHA256_W$3[kr] | 0, Cr = (rotr$3(ur, 2) ^ rotr$3(ur, 13) ^ rotr$3(ur, 22)) + Maj$3(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W$3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$3(() => new SHA256$3()), U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(cr, ar = !1) {
  return ar ? { h: Number(cr & U32_MASK64), l: Number(cr >> _32n & U32_MASK64) } : { h: Number(cr >> _32n & U32_MASK64) | 0, l: Number(cr & U32_MASK64) | 0 };
}
function split$1(cr, ar = !1) {
  let lr = new Uint32Array(cr.length), ur = new Uint32Array(cr.length);
  for (let dr = 0; dr < cr.length; dr++) {
    const { h: fr, l: gr } = fromBig(cr[dr], ar);
    [lr[dr], ur[dr]] = [fr, gr];
  }
  return [lr, ur];
}
const toBig = (cr, ar) => BigInt(cr >>> 0) << _32n | BigInt(ar >>> 0), shrSH = (cr, ar, lr) => cr >>> lr, shrSL = (cr, ar, lr) => cr << 32 - lr | ar >>> lr, rotrSH = (cr, ar, lr) => cr >>> lr | ar << 32 - lr, rotrSL = (cr, ar, lr) => cr << 32 - lr | ar >>> lr, rotrBH = (cr, ar, lr) => cr << 64 - lr | ar >>> lr - 32, rotrBL = (cr, ar, lr) => cr >>> lr - 32 | ar << 64 - lr, rotr32H = (cr, ar) => ar, rotr32L = (cr, ar) => cr, rotlSH = (cr, ar, lr) => cr << lr | ar >>> 32 - lr, rotlSL = (cr, ar, lr) => ar << lr | cr >>> 32 - lr, rotlBH = (cr, ar, lr) => ar << lr - 32 | cr >>> 64 - lr, rotlBL = (cr, ar, lr) => cr << lr - 32 | ar >>> 64 - lr;
function add(cr, ar, lr, ur) {
  const dr = (ar >>> 0) + (ur >>> 0);
  return { h: cr + lr + (dr / 2 ** 32 | 0) | 0, l: dr | 0 };
}
const add3L = (cr, ar, lr) => (cr >>> 0) + (ar >>> 0) + (lr >>> 0), add3H = (cr, ar, lr, ur) => ar + lr + ur + (cr / 2 ** 32 | 0) | 0, add4L = (cr, ar, lr, ur) => (cr >>> 0) + (ar >>> 0) + (lr >>> 0) + (ur >>> 0), add4H = (cr, ar, lr, ur, dr) => ar + lr + ur + dr + (cr / 2 ** 32 | 0) | 0, add5L = (cr, ar, lr, ur, dr) => (cr >>> 0) + (ar >>> 0) + (lr >>> 0) + (ur >>> 0) + (dr >>> 0), add5H = (cr, ar, lr, ur, dr, fr) => ar + lr + ur + dr + fr + (cr / 2 ** 32 | 0) | 0, u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, u64$1 = u64, [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((cr) => BigInt(cr))))(), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2$3 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: ar, Al: lr, Bh: ur, Bl: dr, Ch: fr, Cl: gr, Dh: mr, Dl: vr, Eh: yr, El: _r, Fh: kr, Fl: xr, Gh: Ar, Gl: Er, Hh: Cr, Hl: Tr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr) {
    this.Ah = ar | 0, this.Al = lr | 0, this.Bh = ur | 0, this.Bl = dr | 0, this.Ch = fr | 0, this.Cl = gr | 0, this.Dh = mr | 0, this.Dl = vr | 0, this.Eh = yr | 0, this.El = _r | 0, this.Fh = kr | 0, this.Fl = xr | 0, this.Gh = Ar | 0, this.Gl = Er | 0, this.Hh = Cr | 0, this.Hl = Tr | 0;
  }
  process(ar, lr) {
    for (let Ir = 0; Ir < 16; Ir++, lr += 4)
      SHA512_W_H[Ir] = ar.getUint32(lr), SHA512_W_L[Ir] = ar.getUint32(lr += 4);
    for (let Ir = 16; Ir < 80; Ir++) {
      const Nr = SHA512_W_H[Ir - 15] | 0, Rr = SHA512_W_L[Ir - 15] | 0, Mr = u64$1.rotrSH(Nr, Rr, 1) ^ u64$1.rotrSH(Nr, Rr, 8) ^ u64$1.shrSH(Nr, Rr, 7), Br = u64$1.rotrSL(Nr, Rr, 1) ^ u64$1.rotrSL(Nr, Rr, 8) ^ u64$1.shrSL(Nr, Rr, 7), Dr = SHA512_W_H[Ir - 2] | 0, Hr = SHA512_W_L[Ir - 2] | 0, Fr = u64$1.rotrSH(Dr, Hr, 19) ^ u64$1.rotrBH(Dr, Hr, 61) ^ u64$1.shrSH(Dr, Hr, 6), zr = u64$1.rotrSL(Dr, Hr, 19) ^ u64$1.rotrBL(Dr, Hr, 61) ^ u64$1.shrSL(Dr, Hr, 6), Ur = u64$1.add4L(Br, zr, SHA512_W_L[Ir - 7], SHA512_W_L[Ir - 16]), jr = u64$1.add4H(Ur, Mr, Fr, SHA512_W_H[Ir - 7], SHA512_W_H[Ir - 16]);
      SHA512_W_H[Ir] = jr | 0, SHA512_W_L[Ir] = Ur | 0;
    }
    let { Ah: ur, Al: dr, Bh: fr, Bl: gr, Ch: mr, Cl: vr, Dh: yr, Dl: _r, Eh: kr, El: xr, Fh: Ar, Fl: Er, Gh: Cr, Gl: Tr, Hh: Sr, Hl: Lr } = this;
    for (let Ir = 0; Ir < 80; Ir++) {
      const Nr = u64$1.rotrSH(kr, xr, 14) ^ u64$1.rotrSH(kr, xr, 18) ^ u64$1.rotrBH(kr, xr, 41), Rr = u64$1.rotrSL(kr, xr, 14) ^ u64$1.rotrSL(kr, xr, 18) ^ u64$1.rotrBL(kr, xr, 41), Mr = kr & Ar ^ ~kr & Cr, Br = xr & Er ^ ~xr & Tr, Dr = u64$1.add5L(Lr, Rr, Br, SHA512_Kl[Ir], SHA512_W_L[Ir]), Hr = u64$1.add5H(Dr, Sr, Nr, Mr, SHA512_Kh[Ir], SHA512_W_H[Ir]), Fr = Dr | 0, zr = u64$1.rotrSH(ur, dr, 28) ^ u64$1.rotrBH(ur, dr, 34) ^ u64$1.rotrBH(ur, dr, 39), Ur = u64$1.rotrSL(ur, dr, 28) ^ u64$1.rotrBL(ur, dr, 34) ^ u64$1.rotrBL(ur, dr, 39), jr = ur & fr ^ ur & mr ^ fr & mr, Yr = dr & gr ^ dr & vr ^ gr & vr;
      Sr = Cr | 0, Lr = Tr | 0, Cr = Ar | 0, Tr = Er | 0, Ar = kr | 0, Er = xr | 0, { h: kr, l: xr } = u64$1.add(yr | 0, _r | 0, Hr | 0, Fr | 0), yr = mr | 0, _r = vr | 0, mr = fr | 0, vr = gr | 0, fr = ur | 0, gr = dr | 0;
      const qr = u64$1.add3L(Fr, Ur, Yr);
      ur = u64$1.add3H(qr, Hr, zr, jr), dr = qr | 0;
    }
    ({ h: ur, l: dr } = u64$1.add(this.Ah | 0, this.Al | 0, ur | 0, dr | 0)), { h: fr, l: gr } = u64$1.add(this.Bh | 0, this.Bl | 0, fr | 0, gr | 0), { h: mr, l: vr } = u64$1.add(this.Ch | 0, this.Cl | 0, mr | 0, vr | 0), { h: yr, l: _r } = u64$1.add(this.Dh | 0, this.Dl | 0, yr | 0, _r | 0), { h: kr, l: xr } = u64$1.add(this.Eh | 0, this.El | 0, kr | 0, xr | 0), { h: Ar, l: Er } = u64$1.add(this.Fh | 0, this.Fl | 0, Ar | 0, Er | 0), { h: Cr, l: Tr } = u64$1.add(this.Gh | 0, this.Gl | 0, Cr | 0, Tr | 0), { h: Sr, l: Lr } = u64$1.add(this.Hh | 0, this.Hl | 0, Sr | 0, Lr | 0), this.set(ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor$3(() => new SHA512());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function chain$2(...cr) {
  const ar = (dr, fr) => (gr) => dr(fr(gr)), lr = Array.from(cr).reverse().reduce((dr, fr) => dr ? ar(dr, fr.encode) : fr.encode, void 0), ur = cr.reduce((dr, fr) => dr ? ar(dr, fr.decode) : fr.decode, void 0);
  return { encode: lr, decode: ur };
}
// @__NO_SIDE_EFFECTS__
function alphabet$2(cr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((lr) => {
        if (lr < 0 || lr >= cr.length)
          throw new Error(`Digit index outside alphabet: ${lr} (alphabet: ${cr.length})`);
        return cr[lr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((lr) => {
        if (typeof lr != "string")
          throw new Error(`alphabet.decode: not string element=${lr}`);
        const ur = cr.indexOf(lr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${lr}". Allowed: ${cr}`);
        return ur;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join$3(cr = "") {
  if (typeof cr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let lr of ar)
        if (typeof lr != "string")
          throw new Error(`join.encode: non-string input=${lr}`);
      return ar.join(cr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(cr);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding$2(cr, ar = "=") {
  if (typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of lr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; lr.length * cr % 8; )
        lr.push(ar);
      return lr;
    },
    decode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let dr of lr)
        if (typeof dr != "string")
          throw new Error(`padding.decode: non-string input=${dr}`);
      let ur = lr.length;
      if (ur * cr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && lr[ur - 1] === ar; ur--)
        if (!((ur - 1) * cr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return lr.slice(0, ur);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix$2(cr, ar, lr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (lr < 2)
    throw new Error(`convertRadix: wrong to=${lr}, base cannot be less than 2`);
  if (!Array.isArray(cr))
    throw new Error("convertRadix: data should be array");
  if (!cr.length)
    return [];
  let ur = 0;
  const dr = [], fr = Array.from(cr);
  for (fr.forEach((gr) => {
    if (gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < fr.length; vr++) {
      const yr = fr[vr], _r = ar * gr + yr;
      if (!Number.isSafeInteger(_r) || ar * gr / ar !== gr || _r - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      gr = _r % lr;
      const kr = Math.floor(_r / lr);
      if (fr[vr] = kr, !Number.isSafeInteger(kr) || kr * lr + gr !== _r)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        kr ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (dr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < cr.length - 1 && cr[gr] === 0; gr++)
    dr.push(0);
  return dr.reverse();
}
const gcd$2 = /* @__NO_SIDE_EFFECTS__ */ (cr, ar) => ar ? /* @__PURE__ */ gcd$2(ar, cr % ar) : cr, radix2carry$2 = /* @__NO_SIDE_EFFECTS__ */ (cr, ar) => cr + (ar - /* @__PURE__ */ gcd$2(cr, ar));
// @__NO_SIDE_EFFECTS__
function convertRadix2$2(cr, ar, lr, ur) {
  if (!Array.isArray(cr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (lr <= 0 || lr > 32)
    throw new Error(`convertRadix2: wrong to=${lr}`);
  if (/* @__PURE__ */ radix2carry$2(ar, lr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${lr} carryBits=${/* @__PURE__ */ radix2carry$2(ar, lr)}`);
  let dr = 0, fr = 0;
  const gr = 2 ** lr - 1, mr = [];
  for (const vr of cr) {
    if (vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (dr = dr << ar | vr, fr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${fr} from=${ar}`);
    for (fr += ar; fr >= lr; fr -= lr)
      mr.push((dr >> fr - lr & gr) >>> 0);
    dr &= 2 ** fr - 1;
  }
  if (dr = dr << lr - fr & gr, !ur && fr >= ar)
    throw new Error("Excess padding");
  if (!ur && dr)
    throw new Error(`Non-zero padding: ${dr}`);
  return ur && fr > 0 && mr.push(dr >>> 0), mr;
}
// @__NO_SIDE_EFFECTS__
function radix$2(cr) {
  return {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix$2(Array.from(ar), 2 ** 8, cr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix$2(ar, cr, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function radix2$2(cr, ar = !1) {
  if (cr <= 0 || cr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry$2(8, cr) > 32 || /* @__PURE__ */ radix2carry$2(cr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (lr) => {
      if (!(lr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix2$2(Array.from(lr), 8, cr, !ar);
    },
    decode: (lr) => {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ convertRadix2$2(lr, cr, 8, ar));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function checksum(cr, ar) {
  if (typeof ar != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(lr) {
      if (!(lr instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const ur = ar(lr).slice(0, cr), dr = new Uint8Array(lr.length + cr);
      return dr.set(lr), dr.set(ur, lr.length), dr;
    },
    decode(lr) {
      if (!(lr instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const ur = lr.slice(0, -cr), dr = ar(ur).slice(0, cr), fr = lr.slice(-cr);
      for (let gr = 0; gr < cr; gr++)
        if (dr[gr] !== fr[gr])
          throw new Error("Invalid checksum");
      return ur;
    }
  };
}
const utils$4 = { alphabet: alphabet$2, chain: chain$2, checksum, radix: radix$2, radix2: radix2$2, join: join$3, padding: padding$2 }, genBase58$2 = (cr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ radix$2(58), /* @__PURE__ */ alphabet$2(cr), /* @__PURE__ */ join$3("")), base58$2 = /* @__PURE__ */ genBase58$2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), base58check$1 = (cr) => /* @__PURE__ */ chain$2(/* @__PURE__ */ checksum(4, (ar) => cr(cr(ar))), base58$2), isJapanese = (cr) => cr[0] === "";
function nfkd(cr) {
  if (typeof cr != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof cr}`);
  return cr.normalize("NFKD");
}
function normalize$3(cr) {
  const ar = nfkd(cr), lr = ar.split(" ");
  if (![12, 15, 18, 21, 24].includes(lr.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: ar, words: lr };
}
function assertEntropy(cr) {
  assert$4.bytes(cr, 16, 20, 24, 28, 32);
}
function generateMnemonic(cr, ar = 128) {
  if (assert$4.number(ar), ar % 32 !== 0 || ar > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes$3(ar / 8), cr);
}
const calcChecksum = (cr) => {
  const ar = 8 - cr.length / 4;
  return new Uint8Array([sha256$3(cr)[0] >> ar << ar]);
};
function getCoder(cr) {
  if (!Array.isArray(cr) || cr.length !== 2048 || typeof cr[0] != "string")
    throw new Error("Worlist: expected array of 2048 strings");
  return cr.forEach((ar) => {
    if (typeof ar != "string")
      throw new Error(`Wordlist: non-string element: ${ar}`);
  }), utils$4.chain(utils$4.checksum(1, calcChecksum), utils$4.radix2(11, !0), utils$4.alphabet(cr));
}
function mnemonicToEntropy(cr, ar) {
  const { words: lr } = normalize$3(cr), ur = getCoder(ar).decode(lr);
  return assertEntropy(ur), ur;
}
function entropyToMnemonic(cr, ar) {
  return assertEntropy(cr), getCoder(ar).encode(cr).join(isJapanese(ar) ? "" : " ");
}
function validateMnemonic(cr, ar) {
  try {
    mnemonicToEntropy(cr, ar);
  } catch (lr) {
    return !1;
  }
  return !0;
}
const salt = (cr) => nfkd(`mnemonic${cr}`);
function mnemonicToSeedSync(cr, ar = "") {
  return pbkdf2(sha512, normalize$3(cr).nfkd, salt(ar), { c: 2048, dkLen: 64 });
}
const Rho$1 = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (cr, ar) => ar), Pi$1 = /* @__PURE__ */ Id.map((cr) => (9 * cr + 5) % 16);
let idxL = [Id], idxR = [Pi$1];
for (let cr = 0; cr < 4; cr++)
  for (let ar of [idxL, idxR])
    ar.push(ar[cr].map((lr) => Rho$1[lr]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((cr) => new Uint8Array(cr)), shiftsL = /* @__PURE__ */ idxL.map((cr, ar) => cr.map((lr) => shifts[ar][lr])), shiftsR = /* @__PURE__ */ idxR.map((cr, ar) => cr.map((lr) => shifts[ar][lr])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]), rotl$1 = (cr, ar) => cr << ar | cr >>> 32 - ar;
function f$1(cr, ar, lr, ur) {
  return cr === 0 ? ar ^ lr ^ ur : cr === 1 ? ar & lr | ~ar & ur : cr === 2 ? (ar | ~lr) ^ ur : cr === 3 ? ar & ur | lr & ~ur : ar ^ (lr | ~ur);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2$3 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: ar, h1: lr, h2: ur, h3: dr, h4: fr } = this;
    return [ar, lr, ur, dr, fr];
  }
  set(ar, lr, ur, dr, fr) {
    this.h0 = ar | 0, this.h1 = lr | 0, this.h2 = ur | 0, this.h3 = dr | 0, this.h4 = fr | 0;
  }
  process(ar, lr) {
    for (let Ar = 0; Ar < 16; Ar++, lr += 4)
      BUF[Ar] = ar.getUint32(lr, !0);
    let ur = this.h0 | 0, dr = ur, fr = this.h1 | 0, gr = fr, mr = this.h2 | 0, vr = mr, yr = this.h3 | 0, _r = yr, kr = this.h4 | 0, xr = kr;
    for (let Ar = 0; Ar < 5; Ar++) {
      const Er = 4 - Ar, Cr = Kl[Ar], Tr = Kr[Ar], Sr = idxL[Ar], Lr = idxR[Ar], Ir = shiftsL[Ar], Nr = shiftsR[Ar];
      for (let Rr = 0; Rr < 16; Rr++) {
        const Mr = rotl$1(ur + f$1(Ar, fr, mr, yr) + BUF[Sr[Rr]] + Cr, Ir[Rr]) + kr | 0;
        ur = kr, kr = yr, yr = rotl$1(mr, 10) | 0, mr = fr, fr = Mr;
      }
      for (let Rr = 0; Rr < 16; Rr++) {
        const Mr = rotl$1(dr + f$1(Er, gr, vr, _r) + BUF[Lr[Rr]] + Tr, Nr[Rr]) + xr | 0;
        dr = xr, xr = _r, _r = rotl$1(vr, 10) | 0, vr = gr, gr = Mr;
      }
    }
    this.set(this.h1 + mr + _r | 0, this.h2 + yr + xr | 0, this.h3 + kr + dr | 0, this.h4 + ur + gr | 0, this.h0 + fr + vr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160 = /* @__PURE__ */ wrapConstructor$3(() => new RIPEMD160()), Point$1 = secp256k1$1.ProjectivePoint, base58check = base58check$1(sha256$3);
function bytesToNumber(cr) {
  return BigInt(`0x${bytesToHex$3(cr)}`);
}
function numberToBytes(cr) {
  return hexToBytes$4(cr.toString(16).padStart(64, "0"));
}
const MASTER_SECRET = utf8ToBytes$5("Bitcoin seed"), BITCOIN_VERSIONS = { private: 76066276, public: 76067358 }, HARDENED_OFFSET = 2147483648, hash160 = (cr) => ripemd160(sha256$3(cr)), fromU32 = (cr) => createView$3(cr).getUint32(0, !1), toU32 = (cr) => {
  if (!Number.isSafeInteger(cr) || cr < 0 || cr > 2 ** 32 - 1)
    throw new Error(`Invalid number=${cr}. Should be from 0 to 2 ** 32 - 1`);
  const ar = new Uint8Array(4);
  return createView$3(ar).setUint32(0, cr, !1), ar;
};
class HDKey {
  get fingerprint() {
    if (!this.pubHash)
      throw new Error("No publicKey set!");
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const ar = this.privateKey;
    if (!ar)
      throw new Error("No private key");
    return base58check.encode(this.serialize(this.versions.private, concatBytes$4(new Uint8Array([0]), ar)));
  }
  get publicExtendedKey() {
    if (!this.pubKey)
      throw new Error("No public key");
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(ar, lr = BITCOIN_VERSIONS) {
    if (bytes$4(ar), 8 * ar.length < 128 || 8 * ar.length > 512)
      throw new Error(`HDKey: wrong seed length=${ar.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const ur = hmac$4(sha512, MASTER_SECRET, ar);
    return new HDKey({
      versions: lr,
      chainCode: ur.slice(32),
      privateKey: ur.slice(0, 32)
    });
  }
  static fromExtendedKey(ar, lr = BITCOIN_VERSIONS) {
    const ur = base58check.decode(ar), dr = createView$3(ur), fr = dr.getUint32(0, !1), gr = {
      versions: lr,
      depth: ur[4],
      parentFingerprint: dr.getUint32(5, !1),
      index: dr.getUint32(9, !1),
      chainCode: ur.slice(13, 45)
    }, mr = ur.slice(45), vr = mr[0] === 0;
    if (fr !== lr[vr ? "private" : "public"])
      throw new Error("Version mismatch");
    return vr ? new HDKey({ ...gr, privateKey: mr.slice(1) }) : new HDKey({ ...gr, publicKey: mr });
  }
  static fromJSON(ar) {
    return HDKey.fromExtendedKey(ar.xpriv);
  }
  constructor(ar) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !ar || typeof ar != "object")
      throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = ar.versions || BITCOIN_VERSIONS, this.depth = ar.depth || 0, this.chainCode = ar.chainCode, this.index = ar.index || 0, this.parentFingerprint = ar.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))
      throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (ar.publicKey && ar.privateKey)
      throw new Error("HDKey: publicKey and privateKey at same time.");
    if (ar.privateKey) {
      if (!secp256k1$1.utils.isValidPrivateKey(ar.privateKey))
        throw new Error("Invalid private key");
      this.privKey = typeof ar.privateKey == "bigint" ? ar.privateKey : bytesToNumber(ar.privateKey), this.privKeyBytes = numberToBytes(this.privKey), this.pubKey = secp256k1$1.getPublicKey(ar.privateKey, !0);
    } else if (ar.publicKey)
      this.pubKey = Point$1.fromHex(ar.publicKey).toRawBytes(!0);
    else
      throw new Error("HDKey: no public or private key provided");
    this.pubHash = hash160(this.pubKey);
  }
  derive(ar) {
    if (!/^[mM]'?/.test(ar))
      throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(ar))
      return this;
    const lr = ar.replace(/^[mM]'?\//, "").split("/");
    let ur = this;
    for (const dr of lr) {
      const fr = /^(\d+)('?)$/.exec(dr);
      if (!fr || fr.length !== 3)
        throw new Error(`Invalid child index: ${dr}`);
      let gr = +fr[1];
      if (!Number.isSafeInteger(gr) || gr >= HARDENED_OFFSET)
        throw new Error("Invalid index");
      fr[2] === "'" && (gr += HARDENED_OFFSET), ur = ur.deriveChild(gr);
    }
    return ur;
  }
  deriveChild(ar) {
    if (!this.pubKey || !this.chainCode)
      throw new Error("No publicKey or chainCode set");
    let lr = toU32(ar);
    if (ar >= HARDENED_OFFSET) {
      const mr = this.privateKey;
      if (!mr)
        throw new Error("Could not derive hardened child key");
      lr = concatBytes$4(new Uint8Array([0]), mr, lr);
    } else
      lr = concatBytes$4(this.pubKey, lr);
    const ur = hmac$4(sha512, this.chainCode, lr), dr = bytesToNumber(ur.slice(0, 32)), fr = ur.slice(32);
    if (!secp256k1$1.utils.isValidPrivateKey(dr))
      throw new Error("Tweak bigger than curve order");
    const gr = {
      versions: this.versions,
      chainCode: fr,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: ar
    };
    try {
      if (this.privateKey) {
        const mr = mod$1(this.privKey + dr, secp256k1$1.CURVE.n);
        if (!secp256k1$1.utils.isValidPrivateKey(mr))
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        gr.privateKey = mr;
      } else {
        const mr = Point$1.fromHex(this.pubKey).add(Point$1.fromPrivateKey(dr));
        if (mr.equals(Point$1.ZERO))
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        gr.publicKey = mr.toRawBytes(!0);
      }
      return new HDKey(gr);
    } catch (mr) {
      return this.deriveChild(ar + 1);
    }
  }
  sign(ar) {
    if (!this.privateKey)
      throw new Error("No privateKey set!");
    return bytes$4(ar, 32), secp256k1$1.sign(ar, this.privKey).toCompactRawBytes();
  }
  verify(ar, lr) {
    if (bytes$4(ar, 32), bytes$4(lr, 64), !this.publicKey)
      throw new Error("No publicKey set!");
    let ur;
    try {
      ur = secp256k1$1.Signature.fromCompact(lr);
    } catch (dr) {
      return !1;
    }
    return secp256k1$1.verify(ur, ar, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(ar, lr) {
    if (!this.chainCode)
      throw new Error("No chainCode set");
    return bytes$4(lr, 33), concatBytes$4(toU32(ar), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, lr);
  }
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
const u8a$4 = (cr) => cr instanceof Uint8Array, u32 = (cr) => new Uint32Array(cr.buffer, cr.byteOffset, Math.floor(cr.byteLength / 4)), isLE$3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$3)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$4(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$3(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$4(cr)), !u8a$4(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
const isPlainObject = (cr) => Object.prototype.toString.call(cr) === "[object Object]" && cr.constructor === Object;
function checkOpts(cr, ar) {
  if (ar !== void 0 && (typeof ar != "object" || !isPlainObject(ar)))
    throw new Error("options must be object or undefined");
  return Object.assign(cr, ar);
}
function ensureBytes$1(cr, ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof ar == "number" && cr.length !== ar)
    throw new Error(`Uint8Array length ${ar} expected`);
}
function equalBytes$1(cr, ar) {
  if (cr.length !== ar.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let lr = !0;
  for (let ur = 0; ur < cr.length; ur++)
    lr && (lr = cr[ur] === ar[ur]);
  return lr;
}
function number$3(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool$2(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes$3(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$3(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("hash must be wrapped by utils.wrapConstructor");
  number$3(cr.outputLen), number$3(cr.blockLen);
}
function exists$3(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$3(cr, ar) {
  bytes$3(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert$2 = { number: number$3, bool: bool$2, bytes: bytes$3, hash: hash$3, exists: exists$3, output: output$3 }, u8to16 = (cr, ar) => cr[ar++] & 255 | (cr[ar++] & 255) << 8;
class Poly1305 {
  constructor(ar) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, ar = toBytes$3(ar), ensureBytes$1(ar, 32);
    const lr = u8to16(ar, 0), ur = u8to16(ar, 2), dr = u8to16(ar, 4), fr = u8to16(ar, 6), gr = u8to16(ar, 8), mr = u8to16(ar, 10), vr = u8to16(ar, 12), yr = u8to16(ar, 14);
    this.r[0] = lr & 8191, this.r[1] = (lr >>> 13 | ur << 3) & 8191, this.r[2] = (ur >>> 10 | dr << 6) & 7939, this.r[3] = (dr >>> 7 | fr << 9) & 8191, this.r[4] = (fr >>> 4 | gr << 12) & 255, this.r[5] = gr >>> 1 & 8190, this.r[6] = (gr >>> 14 | mr << 2) & 8191, this.r[7] = (mr >>> 11 | vr << 5) & 8065, this.r[8] = (vr >>> 8 | yr << 8) & 8191, this.r[9] = yr >>> 5 & 127;
    for (let _r = 0; _r < 8; _r++)
      this.pad[_r] = u8to16(ar, 16 + 2 * _r);
  }
  process(ar, lr, ur = !1) {
    const dr = ur ? 0 : 2048, { h: fr, r: gr } = this, mr = gr[0], vr = gr[1], yr = gr[2], _r = gr[3], kr = gr[4], xr = gr[5], Ar = gr[6], Er = gr[7], Cr = gr[8], Tr = gr[9], Sr = u8to16(ar, lr + 0), Lr = u8to16(ar, lr + 2), Ir = u8to16(ar, lr + 4), Nr = u8to16(ar, lr + 6), Rr = u8to16(ar, lr + 8), Mr = u8to16(ar, lr + 10), Br = u8to16(ar, lr + 12), Dr = u8to16(ar, lr + 14);
    let Hr = fr[0] + (Sr & 8191), Fr = fr[1] + ((Sr >>> 13 | Lr << 3) & 8191), zr = fr[2] + ((Lr >>> 10 | Ir << 6) & 8191), Ur = fr[3] + ((Ir >>> 7 | Nr << 9) & 8191), jr = fr[4] + ((Nr >>> 4 | Rr << 12) & 8191), Yr = fr[5] + (Rr >>> 1 & 8191), qr = fr[6] + ((Rr >>> 14 | Mr << 2) & 8191), Wr = fr[7] + ((Mr >>> 11 | Br << 5) & 8191), Jr = fr[8] + ((Br >>> 8 | Dr << 8) & 8191), Gr = fr[9] + (Dr >>> 5 | dr), Vr = 0, Qr = Vr + Hr * mr + Fr * (5 * Tr) + zr * (5 * Cr) + Ur * (5 * Er) + jr * (5 * Ar);
    Vr = Qr >>> 13, Qr &= 8191, Qr += Yr * (5 * xr) + qr * (5 * kr) + Wr * (5 * _r) + Jr * (5 * yr) + Gr * (5 * vr), Vr += Qr >>> 13, Qr &= 8191;
    let $r = Vr + Hr * vr + Fr * mr + zr * (5 * Tr) + Ur * (5 * Cr) + jr * (5 * Er);
    Vr = $r >>> 13, $r &= 8191, $r += Yr * (5 * Ar) + qr * (5 * xr) + Wr * (5 * kr) + Jr * (5 * _r) + Gr * (5 * yr), Vr += $r >>> 13, $r &= 8191;
    let Xr = Vr + Hr * yr + Fr * vr + zr * mr + Ur * (5 * Tr) + jr * (5 * Cr);
    Vr = Xr >>> 13, Xr &= 8191, Xr += Yr * (5 * Er) + qr * (5 * Ar) + Wr * (5 * xr) + Jr * (5 * kr) + Gr * (5 * _r), Vr += Xr >>> 13, Xr &= 8191;
    let si = Vr + Hr * _r + Fr * yr + zr * vr + Ur * mr + jr * (5 * Tr);
    Vr = si >>> 13, si &= 8191, si += Yr * (5 * Cr) + qr * (5 * Er) + Wr * (5 * Ar) + Jr * (5 * xr) + Gr * (5 * kr), Vr += si >>> 13, si &= 8191;
    let Zr = Vr + Hr * kr + Fr * _r + zr * yr + Ur * vr + jr * mr;
    Vr = Zr >>> 13, Zr &= 8191, Zr += Yr * (5 * Tr) + qr * (5 * Cr) + Wr * (5 * Er) + Jr * (5 * Ar) + Gr * (5 * xr), Vr += Zr >>> 13, Zr &= 8191;
    let li = Vr + Hr * xr + Fr * kr + zr * _r + Ur * yr + jr * vr;
    Vr = li >>> 13, li &= 8191, li += Yr * mr + qr * (5 * Tr) + Wr * (5 * Cr) + Jr * (5 * Er) + Gr * (5 * Ar), Vr += li >>> 13, li &= 8191;
    let Ei = Vr + Hr * Ar + Fr * xr + zr * kr + Ur * _r + jr * yr;
    Vr = Ei >>> 13, Ei &= 8191, Ei += Yr * vr + qr * mr + Wr * (5 * Tr) + Jr * (5 * Cr) + Gr * (5 * Er), Vr += Ei >>> 13, Ei &= 8191;
    let ki = Vr + Hr * Er + Fr * Ar + zr * xr + Ur * kr + jr * _r;
    Vr = ki >>> 13, ki &= 8191, ki += Yr * yr + qr * vr + Wr * mr + Jr * (5 * Tr) + Gr * (5 * Cr), Vr += ki >>> 13, ki &= 8191;
    let Di = Vr + Hr * Cr + Fr * Er + zr * Ar + Ur * xr + jr * kr;
    Vr = Di >>> 13, Di &= 8191, Di += Yr * _r + qr * yr + Wr * vr + Jr * mr + Gr * (5 * Tr), Vr += Di >>> 13, Di &= 8191;
    let hi = Vr + Hr * Tr + Fr * Cr + zr * Er + Ur * Ar + jr * xr;
    Vr = hi >>> 13, hi &= 8191, hi += Yr * kr + qr * _r + Wr * yr + Jr * vr + Gr * mr, Vr += hi >>> 13, hi &= 8191, Vr = (Vr << 2) + Vr | 0, Vr = Vr + Qr | 0, Qr = Vr & 8191, Vr = Vr >>> 13, $r += Vr, fr[0] = Qr, fr[1] = $r, fr[2] = Xr, fr[3] = si, fr[4] = Zr, fr[5] = li, fr[6] = Ei, fr[7] = ki, fr[8] = Di, fr[9] = hi;
  }
  finalize() {
    const { h: ar, pad: lr } = this, ur = new Uint16Array(10);
    let dr = ar[1] >>> 13;
    ar[1] &= 8191;
    for (let mr = 2; mr < 10; mr++)
      ar[mr] += dr, dr = ar[mr] >>> 13, ar[mr] &= 8191;
    ar[0] += dr * 5, dr = ar[0] >>> 13, ar[0] &= 8191, ar[1] += dr, dr = ar[1] >>> 13, ar[1] &= 8191, ar[2] += dr, ur[0] = ar[0] + 5, dr = ur[0] >>> 13, ur[0] &= 8191;
    for (let mr = 1; mr < 10; mr++)
      ur[mr] = ar[mr] + dr, dr = ur[mr] >>> 13, ur[mr] &= 8191;
    ur[9] -= 8192;
    let fr = (dr ^ 1) - 1;
    for (let mr = 0; mr < 10; mr++)
      ur[mr] &= fr;
    fr = ~fr;
    for (let mr = 0; mr < 10; mr++)
      ar[mr] = ar[mr] & fr | ur[mr];
    ar[0] = (ar[0] | ar[1] << 13) & 65535, ar[1] = (ar[1] >>> 3 | ar[2] << 10) & 65535, ar[2] = (ar[2] >>> 6 | ar[3] << 7) & 65535, ar[3] = (ar[3] >>> 9 | ar[4] << 4) & 65535, ar[4] = (ar[4] >>> 12 | ar[5] << 1 | ar[6] << 14) & 65535, ar[5] = (ar[6] >>> 2 | ar[7] << 11) & 65535, ar[6] = (ar[7] >>> 5 | ar[8] << 8) & 65535, ar[7] = (ar[8] >>> 8 | ar[9] << 5) & 65535;
    let gr = ar[0] + lr[0];
    ar[0] = gr & 65535;
    for (let mr = 1; mr < 8; mr++)
      gr = (ar[mr] + lr[mr] | 0) + (gr >>> 16) | 0, ar[mr] = gr & 65535;
  }
  update(ar) {
    assert$2.exists(this);
    const { buffer: lr, blockLen: ur } = this;
    ar = toBytes$3(ar);
    const dr = ar.length;
    for (let fr = 0; fr < dr; ) {
      const gr = Math.min(ur - this.pos, dr - fr);
      if (gr === ur) {
        for (; ur <= dr - fr; fr += ur)
          this.process(ar, fr);
        continue;
      }
      lr.set(ar.subarray(fr, fr + gr), this.pos), this.pos += gr, fr += gr, this.pos === ur && (this.process(lr, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    this.h.fill(0), this.r.fill(0), this.buffer.fill(0), this.pad.fill(0);
  }
  digestInto(ar) {
    assert$2.exists(this), assert$2.output(ar, this), this.finished = !0;
    const { buffer: lr, h: ur } = this;
    let { pos: dr } = this;
    if (dr) {
      for (lr[dr++] = 1; dr < 16; dr++)
        lr[dr] = 0;
      this.process(lr, 0, !0);
    }
    this.finalize();
    let fr = 0;
    for (let gr = 0; gr < 8; gr++)
      ar[fr++] = ur[gr] >>> 0, ar[fr++] = ur[gr] >>> 8;
    return ar;
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
}
function wrapConstructorWithKey(cr) {
  const ar = (ur, dr) => cr(dr).update(toBytes$3(ur)).digest(), lr = cr(new Uint8Array(32));
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = (ur) => cr(ur), ar;
}
wrapConstructorWithKey((cr) => new Poly1305(cr));
const sigma16 = utf8ToBytes$4("expand 16-byte k"), sigma32 = utf8ToBytes$4("expand 32-byte k"), sigma16_32 = u32(sigma16), sigma32_32 = u32(sigma32), isAligned32 = (cr) => !(cr.byteOffset % 4), salsaBasic = (cr) => {
  const { core: ar, rounds: lr, counterRight: ur, counterLen: dr, allow128bitKeys: fr, extendNonceFn: gr, blockLen: mr } = checkOpts({ rounds: 20, counterRight: !1, counterLen: 8, allow128bitKeys: !0, blockLen: 64 }, cr);
  assert$2.number(dr), assert$2.number(lr), assert$2.number(mr), assert$2.bool(ur), assert$2.bool(fr);
  const vr = mr / 4;
  if (mr % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen must be aligned to 4 bytes");
  return (yr, _r, kr, xr, Ar = 0) => {
    if (assert$2.bytes(yr), assert$2.bytes(_r), assert$2.bytes(kr), xr || (xr = new Uint8Array(kr.length)), assert$2.bytes(xr), assert$2.number(Ar), Ar < 0 || Ar >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (xr.length < kr.length)
      throw new Error(`Salsa/ChaCha: output (${xr.length}) is shorter than data (${kr.length})`);
    const Er = [];
    let Cr, Tr;
    if (yr.length === 32)
      Cr = yr, Tr = sigma32_32;
    else if (yr.length === 16 && fr)
      Cr = new Uint8Array(32), Cr.set(yr), Cr.set(yr, 16), Tr = sigma16_32, Er.push(Cr);
    else
      throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${yr.length}`);
    if (gr) {
      if (_r.length <= 16)
        throw new Error("Salsa/ChaCha: extended nonce must be bigger than 16 bytes");
      Cr = gr(Tr, Cr, _r.subarray(0, 16), new Uint8Array(32)), Er.push(Cr), _r = _r.subarray(16);
    }
    const Sr = 16 - dr;
    if (_r.length !== Sr)
      throw new Error(`Salsa/ChaCha: nonce must be ${Sr} or 16 bytes`);
    if (Sr !== 12) {
      const Hr = new Uint8Array(12);
      Hr.set(_r, ur ? 0 : 12 - _r.length), Er.push(_r = Hr);
    }
    const Lr = new Uint8Array(mr), Ir = u32(Lr), Nr = u32(Cr), Rr = u32(_r), Mr = isAligned32(kr) && u32(kr), Br = isAligned32(xr) && u32(xr);
    Er.push(Ir);
    const Dr = kr.length;
    for (let Hr = 0, Fr = Ar; Hr < Dr; Fr++) {
      if (ar(Tr, Nr, Rr, Ir, Fr, lr), Fr >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const zr = Math.min(mr, Dr - Hr);
      if (zr === mr && Br && Mr) {
        const Ur = Hr / 4;
        if (Hr % 4 !== 0)
          throw new Error("Salsa/ChaCha: invalid block position");
        for (let jr = 0; jr < vr; jr++)
          Br[Ur + jr] = Mr[Ur + jr] ^ Ir[jr];
        Hr += mr;
        continue;
      }
      for (let Ur = 0; Ur < zr; Ur++)
        xr[Hr + Ur] = kr[Hr + Ur] ^ Lr[Ur];
      Hr += zr;
    }
    for (let Hr = 0; Hr < Er.length; Hr++)
      Er[Hr].fill(0);
    return xr;
  };
}, rotl = (cr, ar) => cr << ar | cr >>> 32 - ar;
function chachaCore(cr, ar, lr, ur, dr, fr = 20) {
  let gr = cr[0], mr = cr[1], vr = cr[2], yr = cr[3], _r = ar[0], kr = ar[1], xr = ar[2], Ar = ar[3], Er = ar[4], Cr = ar[5], Tr = ar[6], Sr = ar[7], Lr = dr, Ir = lr[0], Nr = lr[1], Rr = lr[2], Mr = gr, Br = mr, Dr = vr, Hr = yr, Fr = _r, zr = kr, Ur = xr, jr = Ar, Yr = Er, qr = Cr, Wr = Tr, Jr = Sr, Gr = Lr, Vr = Ir, Qr = Nr, $r = Rr;
  for (let si = 0; si < fr; si += 2)
    Mr = Mr + Fr | 0, Gr = rotl(Gr ^ Mr, 16), Yr = Yr + Gr | 0, Fr = rotl(Fr ^ Yr, 12), Mr = Mr + Fr | 0, Gr = rotl(Gr ^ Mr, 8), Yr = Yr + Gr | 0, Fr = rotl(Fr ^ Yr, 7), Br = Br + zr | 0, Vr = rotl(Vr ^ Br, 16), qr = qr + Vr | 0, zr = rotl(zr ^ qr, 12), Br = Br + zr | 0, Vr = rotl(Vr ^ Br, 8), qr = qr + Vr | 0, zr = rotl(zr ^ qr, 7), Dr = Dr + Ur | 0, Qr = rotl(Qr ^ Dr, 16), Wr = Wr + Qr | 0, Ur = rotl(Ur ^ Wr, 12), Dr = Dr + Ur | 0, Qr = rotl(Qr ^ Dr, 8), Wr = Wr + Qr | 0, Ur = rotl(Ur ^ Wr, 7), Hr = Hr + jr | 0, $r = rotl($r ^ Hr, 16), Jr = Jr + $r | 0, jr = rotl(jr ^ Jr, 12), Hr = Hr + jr | 0, $r = rotl($r ^ Hr, 8), Jr = Jr + $r | 0, jr = rotl(jr ^ Jr, 7), Mr = Mr + zr | 0, $r = rotl($r ^ Mr, 16), Wr = Wr + $r | 0, zr = rotl(zr ^ Wr, 12), Mr = Mr + zr | 0, $r = rotl($r ^ Mr, 8), Wr = Wr + $r | 0, zr = rotl(zr ^ Wr, 7), Br = Br + Ur | 0, Gr = rotl(Gr ^ Br, 16), Jr = Jr + Gr | 0, Ur = rotl(Ur ^ Jr, 12), Br = Br + Ur | 0, Gr = rotl(Gr ^ Br, 8), Jr = Jr + Gr | 0, Ur = rotl(Ur ^ Jr, 7), Dr = Dr + jr | 0, Vr = rotl(Vr ^ Dr, 16), Yr = Yr + Vr | 0, jr = rotl(jr ^ Yr, 12), Dr = Dr + jr | 0, Vr = rotl(Vr ^ Dr, 8), Yr = Yr + Vr | 0, jr = rotl(jr ^ Yr, 7), Hr = Hr + Fr | 0, Qr = rotl(Qr ^ Hr, 16), qr = qr + Qr | 0, Fr = rotl(Fr ^ qr, 12), Hr = Hr + Fr | 0, Qr = rotl(Qr ^ Hr, 8), qr = qr + Qr | 0, Fr = rotl(Fr ^ qr, 7);
  let Xr = 0;
  ur[Xr++] = gr + Mr | 0, ur[Xr++] = mr + Br | 0, ur[Xr++] = vr + Dr | 0, ur[Xr++] = yr + Hr | 0, ur[Xr++] = _r + Fr | 0, ur[Xr++] = kr + zr | 0, ur[Xr++] = xr + Ur | 0, ur[Xr++] = Ar + jr | 0, ur[Xr++] = Er + Yr | 0, ur[Xr++] = Cr + qr | 0, ur[Xr++] = Tr + Wr | 0, ur[Xr++] = Sr + Jr | 0, ur[Xr++] = Lr + Gr | 0, ur[Xr++] = Ir + Vr | 0, ur[Xr++] = Nr + Qr | 0, ur[Xr++] = Rr + $r | 0;
}
const chacha20 = /* @__PURE__ */ salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  allow128bitKeys: !1
});
let HMAC$3 = class extends Hash$4 {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, assert$5.hash(ar);
    const ur = toBytes$5(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return assert$5.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$5.exists(this), assert$5.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$3 = (cr, ar, lr) => new HMAC$3(cr, ar).update(lr).digest();
hmac$3.create = (cr, ar) => new HMAC$3(cr, ar);
function extract$2(cr, ar, lr) {
  return assert$5.hash(cr), lr === void 0 && (lr = new Uint8Array(cr.outputLen)), hmac$3(cr, toBytes$5(lr), toBytes$5(ar));
}
const HKDF_COUNTER$2 = new Uint8Array([0]), EMPTY_BUFFER$2 = new Uint8Array();
function expand$2(cr, ar, lr, ur = 32) {
  if (assert$5.hash(cr), assert$5.number(ur), ur > 255 * cr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const dr = Math.ceil(ur / cr.outputLen);
  lr === void 0 && (lr = EMPTY_BUFFER$2);
  const fr = new Uint8Array(dr * cr.outputLen), gr = hmac$3.create(cr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < dr; yr++)
    HKDF_COUNTER$2[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER$2 : vr).update(lr).update(HKDF_COUNTER$2).digestInto(vr), fr.set(vr, cr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER$2.fill(0), fr.slice(0, ur);
}
const hkdf$1 = (cr, ar, lr, ur, dr) => expand$2(cr, extract$2(cr, ar, lr), ur, dr);
var __defProp$2 = Object.defineProperty, __export$2 = (cr, ar) => {
  for (var lr in ar)
    __defProp$2(cr, lr, { get: ar[lr], enumerable: !0 });
};
function generatePrivateKey() {
  return bytesToHex$4(schnorr$1.utils.randomPrivateKey());
}
function getPublicKey$1(cr) {
  return bytesToHex$4(schnorr$1.getPublicKey(cr));
}
var utils_exports$2 = {};
__export$2(utils_exports$2, {
  MessageNode: () => MessageNode$1,
  MessageQueue: () => MessageQueue$1,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$2,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$2,
  normalizeURL: () => normalizeURL$2,
  utf8Decoder: () => utf8Decoder$2,
  utf8Encoder: () => utf8Encoder$2
});
var utf8Decoder$2 = new TextDecoder("utf-8"), utf8Encoder$2 = new TextEncoder();
function normalizeURL$2(cr) {
  let ar = new URL(cr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$2(cr, ar) {
  var gr;
  let lr = 0, ur = cr.length - 1, dr, fr = lr;
  if (ur < 0)
    fr = 0;
  else if (ar.created_at < cr[ur].created_at)
    fr = ur + 1;
  else if (ar.created_at >= cr[lr].created_at)
    fr = lr;
  else
    for (; ; ) {
      if (ur <= lr + 1) {
        fr = ur;
        break;
      }
      if (dr = Math.floor(lr + (ur - lr) / 2), cr[dr].created_at > ar.created_at)
        lr = dr;
      else if (cr[dr].created_at < ar.created_at)
        ur = dr;
      else {
        fr = dr;
        break;
      }
    }
  return ((gr = cr[fr]) == null ? void 0 : gr.id) !== ar.id ? [...cr.slice(0, fr), ar, ...cr.slice(fr)] : cr;
}
function insertEventIntoAscendingList$2(cr, ar) {
  var gr;
  let lr = 0, ur = cr.length - 1, dr, fr = lr;
  if (ur < 0)
    fr = 0;
  else if (ar.created_at > cr[ur].created_at)
    fr = ur + 1;
  else if (ar.created_at <= cr[lr].created_at)
    fr = lr;
  else
    for (; ; ) {
      if (ur <= lr + 1) {
        fr = ur;
        break;
      }
      if (dr = Math.floor(lr + (ur - lr) / 2), cr[dr].created_at < ar.created_at)
        lr = dr;
      else if (cr[dr].created_at > ar.created_at)
        ur = dr;
      else {
        fr = dr;
        break;
      }
    }
  return ((gr = cr[fr]) == null ? void 0 : gr.id) !== ar.id ? [...cr.slice(0, fr), ar, ...cr.slice(fr)] : cr;
}
var MessageNode$1 = class {
  constructor(ar) {
    ti(this, "_value");
    ti(this, "_next");
    this._value = ar, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(ar) {
    this._value = ar;
  }
  get next() {
    return this._next;
  }
  set next(ar) {
    this._next = ar;
  }
}, MessageQueue$1 = class {
  constructor() {
    ti(this, "_first");
    ti(this, "_last");
    ti(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(ar) {
    this._first = ar;
  }
  get last() {
    return this._last;
  }
  set last(ar) {
    this._last = ar;
  }
  get size() {
    return this._size;
  }
  set size(ar) {
    this._size = ar;
  }
  enqueue(ar) {
    const lr = new MessageNode$1(ar);
    return this._size === 0 || !this._last ? (this._first = lr, this._last = lr) : (this._last.next = lr, this._last = lr), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let ar = this._first;
    return this._first = ar.next, ar.next = null, this._size--, ar.value;
  }
}, verifiedSymbol$2 = Symbol("verified");
function getBlankEvent$1(cr = 255) {
  return {
    kind: cr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent$1(cr, ar) {
  const lr = cr;
  return lr.pubkey = getPublicKey$1(ar), lr.id = getEventHash$2(lr), lr.sig = getSignature$1(lr, ar), lr[verifiedSymbol$2] = !0, lr;
}
function serializeEvent$2(cr) {
  if (!validateEvent$2(cr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, cr.pubkey, cr.created_at, cr.kind, cr.tags, cr.content]);
}
function getEventHash$2(cr) {
  let ar = sha256$4(utf8Encoder$2.encode(serializeEvent$2(cr)));
  return bytesToHex$4(ar);
}
var isRecord$2 = (cr) => cr instanceof Object;
function validateEvent$2(cr) {
  if (!isRecord$2(cr) || typeof cr.kind != "number" || typeof cr.content != "string" || typeof cr.created_at != "number" || typeof cr.pubkey != "string" || !cr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(cr.tags))
    return !1;
  for (let ar = 0; ar < cr.tags.length; ar++) {
    let lr = cr.tags[ar];
    if (!Array.isArray(lr))
      return !1;
    for (let ur = 0; ur < lr.length; ur++)
      if (typeof lr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature$1(cr) {
  if (typeof cr[verifiedSymbol$2] == "boolean")
    return cr[verifiedSymbol$2];
  const ar = getEventHash$2(cr);
  if (ar !== cr.id)
    return cr[verifiedSymbol$2] = !1;
  try {
    return cr[verifiedSymbol$2] = schnorr$1.verify(cr.sig, ar, cr.pubkey);
  } catch (lr) {
    return cr[verifiedSymbol$2] = !1;
  }
}
function getSignature$1(cr, ar) {
  return bytesToHex$4(schnorr$1.sign(getEventHash$2(cr), ar));
}
function matchFilter$1(cr, ar) {
  if (cr.ids && cr.ids.indexOf(ar.id) === -1 && !cr.ids.some((lr) => ar.id.startsWith(lr)) || cr.kinds && cr.kinds.indexOf(ar.kind) === -1 || cr.authors && cr.authors.indexOf(ar.pubkey) === -1 && !cr.authors.some((lr) => ar.pubkey.startsWith(lr)))
    return !1;
  for (let lr in cr)
    if (lr[0] === "#") {
      let ur = lr.slice(1), dr = cr[`#${ur}`];
      if (dr && !ar.tags.find(([fr, gr]) => fr === lr.slice(1) && dr.indexOf(gr) !== -1))
        return !1;
    }
  return !(cr.since && ar.created_at < cr.since || cr.until && ar.created_at > cr.until);
}
function matchFilters(cr, ar) {
  for (let lr = 0; lr < cr.length; lr++)
    if (matchFilter$1(cr[lr], ar))
      return !0;
  return !1;
}
var fakejson_exports$2 = {};
__export$2(fakejson_exports$2, {
  getHex64: () => getHex64$2,
  getInt: () => getInt$2,
  getSubscriptionId: () => getSubscriptionId$2,
  matchEventId: () => matchEventId$2,
  matchEventKind: () => matchEventKind$2,
  matchEventPubkey: () => matchEventPubkey$2
});
function getHex64$2(cr, ar) {
  let lr = ar.length + 3, ur = cr.indexOf(`"${ar}":`) + lr, dr = cr.slice(ur).indexOf('"') + ur + 1;
  return cr.slice(dr, dr + 64);
}
function getInt$2(cr, ar) {
  let lr = ar.length, ur = cr.indexOf(`"${ar}":`) + lr + 3, dr = cr.slice(ur), fr = Math.min(dr.indexOf(","), dr.indexOf("}"));
  return parseInt(dr.slice(0, fr), 10);
}
function getSubscriptionId$2(cr) {
  let ar = cr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let lr = cr.slice(ar + 7 + 1).indexOf('"');
  if (lr === -1)
    return null;
  let ur = ar + 7 + 1 + lr, dr = cr.slice(ur + 1, 80).indexOf('"');
  if (dr === -1)
    return null;
  let fr = ur + 1 + dr;
  return cr.slice(ur + 1, fr);
}
function matchEventId$2(cr, ar) {
  return ar === getHex64$2(cr, "id");
}
function matchEventPubkey$2(cr, ar) {
  return ar === getHex64$2(cr, "pubkey");
}
function matchEventKind$2(cr, ar) {
  return ar === getInt$2(cr, "kind");
}
var newListeners = () => ({
  connect: [],
  disconnect: [],
  error: [],
  notice: [],
  auth: []
});
function relayInit(cr, ar = {}) {
  let { listTimeout: lr = 3e3, getTimeout: ur = 3e3, countTimeout: dr = 3e3 } = ar;
  var fr, gr = {}, mr = newListeners(), vr = {}, yr = {}, _r;
  async function kr() {
    return _r || (_r = new Promise((Sr, Lr) => {
      try {
        fr = new WebSocket(cr);
      } catch (Mr) {
        Lr(Mr);
      }
      fr.onopen = () => {
        mr.connect.forEach((Mr) => Mr()), Sr();
      }, fr.onerror = () => {
        _r = void 0, mr.error.forEach((Mr) => Mr()), Lr();
      }, fr.onclose = async () => {
        _r = void 0, mr.disconnect.forEach((Mr) => Mr());
      };
      let Ir = new MessageQueue$1(), Nr;
      fr.onmessage = (Mr) => {
        Ir.enqueue(Mr.data), Nr || (Nr = setInterval(Rr, 0));
      };
      function Rr() {
        var Dr, Hr, Fr;
        if (Ir.size === 0) {
          clearInterval(Nr), Nr = null;
          return;
        }
        var Mr = Ir.dequeue();
        if (!Mr)
          return;
        let Br = getSubscriptionId$2(Mr);
        if (Br) {
          let zr = gr[Br];
          if (zr && zr.alreadyHaveEvent && zr.alreadyHaveEvent(getHex64$2(Mr, "id"), cr))
            return;
        }
        try {
          let zr = JSON.parse(Mr);
          switch (zr[0]) {
            case "EVENT": {
              let qr = zr[1], Wr = zr[2];
              validateEvent$2(Wr) && gr[qr] && (gr[qr].skipVerification || verifySignature$1(Wr)) && matchFilters(gr[qr].filters, Wr) && (gr[qr], (((Dr = vr[qr]) == null ? void 0 : Dr.event) || []).forEach((Jr) => Jr(Wr)));
              return;
            }
            case "COUNT":
              let Ur = zr[1], jr = zr[2];
              gr[Ur] && (((Hr = vr[Ur]) == null ? void 0 : Hr.count) || []).forEach((qr) => qr(jr));
              return;
            case "EOSE": {
              let qr = zr[1];
              qr in vr && (vr[qr].eose.forEach((Wr) => Wr()), vr[qr].eose = []);
              return;
            }
            case "OK": {
              let qr = zr[1], Wr = zr[2], Jr = zr[3] || "";
              if (qr in yr) {
                let { resolve: Gr, reject: Vr } = yr[qr];
                Wr ? Gr(null) : Vr(new Error(Jr));
              }
              return;
            }
            case "NOTICE":
              let Yr = zr[1];
              mr.notice.forEach((qr) => qr(Yr));
              return;
            case "AUTH": {
              let qr = zr[1];
              (Fr = mr.auth) == null || Fr.forEach((Wr) => Wr(qr));
              return;
            }
          }
        } catch (zr) {
          return;
        }
      }
    }), _r);
  }
  function xr() {
    return (fr == null ? void 0 : fr.readyState) === 1;
  }
  async function Ar() {
    xr() || await kr();
  }
  async function Er(Sr) {
    let Lr = JSON.stringify(Sr);
    if (!(!xr() && (await new Promise((Ir) => setTimeout(Ir, 1e3)), !xr())))
      try {
        fr.send(Lr);
      } catch (Ir) {
        console.log(Ir);
      }
  }
  const Cr = (Sr, {
    verb: Lr = "REQ",
    skipVerification: Ir = !1,
    alreadyHaveEvent: Nr = null,
    id: Rr = Math.random().toString().slice(2)
  } = {}) => {
    let Mr = Rr;
    gr[Mr] = {
      id: Mr,
      filters: Sr,
      skipVerification: Ir,
      alreadyHaveEvent: Nr
    }, Er([Lr, Mr, ...Sr]);
    let Br = {
      sub: (Dr, Hr = {}) => Cr(Dr || Sr, {
        skipVerification: Hr.skipVerification || Ir,
        alreadyHaveEvent: Hr.alreadyHaveEvent || Nr,
        id: Mr
      }),
      unsub: () => {
        delete gr[Mr], delete vr[Mr], Er(["CLOSE", Mr]);
      },
      on: (Dr, Hr) => {
        vr[Mr] = vr[Mr] || {
          event: [],
          count: [],
          eose: []
        }, vr[Mr][Dr].push(Hr);
      },
      off: (Dr, Hr) => {
        let Fr = vr[Mr], zr = Fr[Dr].indexOf(Hr);
        zr >= 0 && Fr[Dr].splice(zr, 1);
      },
      get events() {
        return eventsGenerator(Br);
      }
    };
    return Br;
  };
  function Tr(Sr, Lr) {
    return new Promise((Ir, Nr) => {
      if (!Sr.id) {
        Nr(new Error(`event ${Sr} has no id`));
        return;
      }
      let Rr = Sr.id;
      Er([Lr, Sr]), yr[Rr] = { resolve: Ir, reject: Nr };
    });
  }
  return {
    url: cr,
    sub: Cr,
    on: (Sr, Lr) => {
      mr[Sr].push(Lr), Sr === "connect" && (fr == null ? void 0 : fr.readyState) === 1 && Lr();
    },
    off: (Sr, Lr) => {
      let Ir = mr[Sr].indexOf(Lr);
      Ir !== -1 && mr[Sr].splice(Ir, 1);
    },
    list: (Sr, Lr) => new Promise((Ir) => {
      let Nr = Cr(Sr, Lr), Rr = [], Mr = setTimeout(() => {
        Nr.unsub(), Ir(Rr);
      }, lr);
      Nr.on("eose", () => {
        Nr.unsub(), clearTimeout(Mr), Ir(Rr);
      }), Nr.on("event", (Br) => {
        Rr.push(Br);
      });
    }),
    get: (Sr, Lr) => new Promise((Ir) => {
      let Nr = Cr([Sr], Lr), Rr = setTimeout(() => {
        Nr.unsub(), Ir(null);
      }, ur);
      Nr.on("event", (Mr) => {
        Nr.unsub(), clearTimeout(Rr), Ir(Mr);
      });
    }),
    count: (Sr) => new Promise((Lr) => {
      let Ir = Cr(Sr, { ...Cr, verb: "COUNT" }), Nr = setTimeout(() => {
        Ir.unsub(), Lr(null);
      }, dr);
      Ir.on("count", (Rr) => {
        Ir.unsub(), clearTimeout(Nr), Lr(Rr);
      });
    }),
    async publish(Sr) {
      await Tr(Sr, "EVENT");
    },
    async auth(Sr) {
      await Tr(Sr, "AUTH");
    },
    connect: Ar,
    close() {
      mr = newListeners(), vr = {}, yr = {}, (fr == null ? void 0 : fr.readyState) === WebSocket.OPEN && fr.close();
    },
    get status() {
      var Sr;
      return (Sr = fr == null ? void 0 : fr.readyState) != null ? Sr : 3;
    }
  };
}
async function* eventsGenerator(cr) {
  let ar;
  const lr = [], ur = (dr) => {
    ar ? (ar(dr), ar = void 0) : lr.push(dr);
  };
  cr.on("event", ur);
  try {
    for (; ; )
      lr.length > 0 ? yield lr.shift() : yield await new Promise((fr) => {
        ar = fr;
      });
  } finally {
    cr.off("event", ur);
  }
}
var nip19_exports$2 = {};
__export$2(nip19_exports$2, {
  BECH32_REGEX: () => BECH32_REGEX$2,
  decode: () => decode$3,
  naddrEncode: () => naddrEncode$2,
  neventEncode: () => neventEncode$2,
  noteEncode: () => noteEncode$2,
  nprofileEncode: () => nprofileEncode$2,
  npubEncode: () => npubEncode$2,
  nrelayEncode: () => nrelayEncode$2,
  nsecEncode: () => nsecEncode$2
});
var Bech32MaxSize$2 = 5e3, BECH32_REGEX$2 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$2(cr) {
  const ar = new Uint8Array(4);
  return ar[0] = cr >> 24 & 255, ar[1] = cr >> 16 & 255, ar[2] = cr >> 8 & 255, ar[3] = cr & 255, ar;
}
function decode$3(cr) {
  var dr, fr, gr, mr, vr, yr, _r, kr;
  let { prefix: ar, words: lr } = bech32$3.decode(cr, Bech32MaxSize$2), ur = new Uint8Array(bech32$3.fromWords(lr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV$2(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$4(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$2.decode(Ar)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV$2(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$4(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$2.decode(Ar)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex$4(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex$4(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV$2(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_r = xr[3]) != null && _r[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$2.decode(xr[0][0]),
          pubkey: bytesToHex$4(xr[2][0]),
          kind: parseInt(bytesToHex$4(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$2.decode(Ar)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV$2(ur);
      if (!((kr = xr[0]) != null && kr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$2.decode(xr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$4(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$2(cr) {
  let ar = {}, lr = cr;
  for (; lr.length > 0; ) {
    let ur = lr[0], dr = lr[1];
    if (!dr)
      throw new Error(`malformed TLV ${ur}`);
    let fr = lr.slice(2, 2 + dr);
    if (lr = lr.slice(2 + dr), fr.length < dr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(fr);
  }
  return ar;
}
function nsecEncode$2(cr) {
  return encodeBytes$2("nsec", cr);
}
function npubEncode$2(cr) {
  return encodeBytes$2("npub", cr);
}
function noteEncode$2(cr) {
  return encodeBytes$2("note", cr);
}
function encodeBech32$2(cr, ar) {
  let lr = bech32$3.toWords(ar);
  return bech32$3.encode(cr, lr, Bech32MaxSize$2);
}
function encodeBytes$2(cr, ar) {
  let lr = hexToBytes$5(ar);
  return encodeBech32$2(cr, lr);
}
function nprofileEncode$2(cr) {
  let ar = encodeTLV$2({
    0: [hexToBytes$5(cr.pubkey)],
    1: (cr.relays || []).map((lr) => utf8Encoder$2.encode(lr))
  });
  return encodeBech32$2("nprofile", ar);
}
function neventEncode$2(cr) {
  let ar;
  cr.kind != null && (ar = integerToUint8Array$2(cr.kind));
  let lr = encodeTLV$2({
    0: [hexToBytes$5(cr.id)],
    1: (cr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: cr.author ? [hexToBytes$5(cr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$2("nevent", lr);
}
function naddrEncode$2(cr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, cr.kind, !1);
  let lr = encodeTLV$2({
    0: [utf8Encoder$2.encode(cr.identifier)],
    1: (cr.relays || []).map((ur) => utf8Encoder$2.encode(ur)),
    2: [hexToBytes$5(cr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$2("naddr", lr);
}
function nrelayEncode$2(cr) {
  let ar = encodeTLV$2({
    0: [utf8Encoder$2.encode(cr)]
  });
  return encodeBech32$2("nrelay", ar);
}
function encodeTLV$2(cr) {
  let ar = [];
  return Object.entries(cr).forEach(([lr, ur]) => {
    ur.forEach((dr) => {
      let fr = new Uint8Array(dr.length + 2);
      fr.set([parseInt(lr)], 0), fr.set([dr.length], 1), fr.set(dr, 2), ar.push(fr);
    });
  }), concatBytes$5(...ar);
}
var nip04_exports$2 = {};
__export$2(nip04_exports$2, {
  decrypt: () => decrypt$3,
  encrypt: () => encrypt$3
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$3(cr, ar, lr) {
  const ur = secp256k1$1.getSharedSecret(cr, "02" + ar), dr = getNormalizedX$2(ur);
  let fr = Uint8Array.from(randomBytes$4(16)), gr = utf8Encoder$2.encode(lr), mr = await crypto.subtle.importKey("raw", dr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: fr }, mr, gr), yr = base64$2.encode(new Uint8Array(vr)), _r = base64$2.encode(new Uint8Array(fr.buffer));
  return `${yr}?iv=${_r}`;
}
async function decrypt$3(cr, ar, lr) {
  let [ur, dr] = lr.split("?iv="), fr = secp256k1$1.getSharedSecret(cr, "02" + ar), gr = getNormalizedX$2(fr), mr = await crypto.subtle.importKey("raw", gr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$2.decode(ur), yr = base64$2.decode(dr), _r = await crypto.subtle.decrypt({ name: "AES-CBC", iv: yr }, mr, vr);
  return utf8Decoder$2.decode(_r);
}
function getNormalizedX$2(cr) {
  return cr.slice(1, 33);
}
var nip05_exports$2 = {};
__export$2(nip05_exports$2, {
  NIP05_REGEX: () => NIP05_REGEX$2,
  queryProfile: () => queryProfile$2,
  searchDomain: () => searchDomain$2,
  useFetchImplementation: () => useFetchImplementation$2
});
var NIP05_REGEX$2 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$2;
try {
  _fetch$2 = fetch;
} catch (cr) {
}
function useFetchImplementation$2(cr) {
  _fetch$2 = cr;
}
async function searchDomain$2(cr, ar = "") {
  try {
    return (await (await _fetch$2(`https://${cr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (lr) {
    return {};
  }
}
async function queryProfile$2(cr) {
  const ar = cr.match(NIP05_REGEX$2);
  if (!ar)
    return null;
  const [lr, ur = "_", dr] = ar;
  try {
    const fr = await _fetch$2(`https://${dr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result$2(await fr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (fr) {
    return null;
  }
}
function parseNIP05Result$2(cr) {
  const ar = {
    names: {}
  };
  for (const [lr, ur] of Object.entries(cr.names))
    typeof lr == "string" && typeof ur == "string" && (ar.names[lr] = ur);
  if (cr.relays) {
    ar.relays = {};
    for (const [lr, ur] of Object.entries(cr.relays))
      typeof lr == "string" && Array.isArray(ur) && (ar.relays[lr] = ur.filter((dr) => typeof dr == "string"));
  }
  return ar;
}
var nip06_exports$1 = {};
__export$2(nip06_exports$1, {
  generateSeedWords: () => generateSeedWords$1,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords$1,
  validateWords: () => validateWords$1
});
function privateKeyFromSeedWords$1(cr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(cr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$4(ur);
}
function generateSeedWords$1() {
  return generateMnemonic(wordlist);
}
function validateWords$1(cr) {
  return validateMnemonic(cr, wordlist);
}
var nip10_exports$2 = {};
__export$2(nip10_exports$2, {
  parse: () => parse$2
});
function parse$2(cr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, lr = [];
  for (const ur of cr.tags)
    ur[0] === "e" && ur[1] && lr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = lr[ur], [fr, gr, mr, vr] = dr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, _r = ur === 0, kr = ur === lr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (_r) {
      ar.root = yr;
      continue;
    }
    if (kr) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip13_exports$2 = {};
__export$2(nip13_exports$2, {
  getPow: () => getPow$2,
  minePow: () => minePow$2
});
function getPow$2(cr) {
  let ar = 0;
  for (let lr = 0; lr < cr.length; lr++) {
    const ur = parseInt(cr[lr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$2(cr, ar) {
  let lr = 0;
  const ur = cr, dr = ["nonce", lr.toString(), ar.toString()];
  for (ur.tags.push(dr); ; ) {
    const fr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (fr !== ur.created_at && (lr = 0, ur.created_at = fr), dr[1] = (++lr).toString(), ur.id = getEventHash$2(ur), getPow$2(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$2 = {};
__export$2(nip18_exports$2, {
  finishRepostEvent: () => finishRepostEvent$2,
  getRepostedEvent: () => getRepostedEvent$2,
  getRepostedEventPointer: () => getRepostedEventPointer$2
});
function finishRepostEvent$2(cr, ar, lr, ur) {
  var dr;
  return finishEvent$1(
    {
      kind: 6,
      tags: [...(dr = cr.tags) != null ? dr : [], ["e", ar.id, lr], ["p", ar.pubkey]],
      content: cr.content === "" ? "" : JSON.stringify(ar),
      created_at: cr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$2(cr) {
  if (cr.kind !== 6)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], lr == null ? void 0 : lr[2]].filter((ur) => typeof ur == "string"),
      author: lr == null ? void 0 : lr[1]
    };
}
function getRepostedEvent$2(cr, { skipVerification: ar } = {}) {
  const lr = getRepostedEventPointer$2(cr);
  if (lr === void 0 || cr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(cr.content);
  } catch (dr) {
    return;
  }
  if (ur.id === lr.id && !(!ar && !verifySignature$1(ur)))
    return ur;
}
var nip21_exports$2 = {};
__export$2(nip21_exports$2, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$2,
  parse: () => parse2$2,
  test: () => test$2
});
var NOSTR_URI_REGEX$2 = new RegExp(`nostr:(${BECH32_REGEX$2.source})`);
function test$2(cr) {
  return typeof cr == "string" && new RegExp(`^${NOSTR_URI_REGEX$2.source}$`).test(cr);
}
function parse2$2(cr) {
  const ar = cr.match(new RegExp(`^${NOSTR_URI_REGEX$2.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${cr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$3(ar[1])
  };
}
var nip25_exports$2 = {};
__export$2(nip25_exports$2, {
  finishReactionEvent: () => finishReactionEvent$2,
  getReactedEventPointer: () => getReactedEventPointer$2
});
function finishReactionEvent$2(cr, ar, lr) {
  var dr, fr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finishEvent$1(
    {
      ...cr,
      kind: 7,
      tags: [...(dr = cr.tags) != null ? dr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (fr = cr.content) != null ? fr : "+"
    },
    lr
  );
}
function getReactedEventPointer$2(cr) {
  if (cr.kind !== 7)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (!(ar === void 0 || lr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], lr[2]].filter((ur) => ur !== void 0),
      author: lr[1]
    };
}
var nip26_exports$1 = {};
__export$2(nip26_exports$1, {
  createDelegation: () => createDelegation$1,
  getDelegator: () => getDelegator$1
});
function createDelegation$1(cr, ar) {
  let lr = [];
  (ar.kind || -1) >= 0 && lr.push(`kind=${ar.kind}`), ar.until && lr.push(`created_at<${ar.until}`), ar.since && lr.push(`created_at>${ar.since}`);
  let ur = lr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let dr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), fr = bytesToHex$4(schnorr$1.sign(dr, cr));
  return {
    from: getPublicKey$1(cr),
    to: ar.pubkey,
    cond: ur,
    sig: fr
  };
}
function getDelegator$1(cr) {
  let ar = cr.tags.find((mr) => mr[0] === "delegation" && mr.length >= 4);
  if (!ar)
    return null;
  let lr = ar[1], ur = ar[2], dr = ar[3], fr = ur.split("&");
  for (let mr = 0; mr < fr.length; mr++) {
    let [vr, yr, _r] = fr[mr].split(/\b/);
    if (!(vr === "kind" && yr === "=" && cr.kind === parseInt(_r))) {
      if (vr === "created_at" && yr === "<" && cr.created_at < parseInt(_r))
        continue;
      if (vr === "created_at" && yr === ">" && cr.created_at > parseInt(_r))
        continue;
      return null;
    }
  }
  let gr = sha256$4(utf8Encoder$2.encode(`nostr:delegation:${cr.pubkey}:${ur}`));
  return schnorr$1.verify(dr, gr, lr) ? lr : null;
}
var nip27_exports$2 = {};
__export$2(nip27_exports$2, {
  matchAll: () => matchAll$2,
  regex: () => regex$2,
  replaceAll: () => replaceAll$2
});
var regex$2 = () => new RegExp(`\\b${NOSTR_URI_REGEX$2.source}\\b`, "g");
function* matchAll$2(cr) {
  const ar = cr.matchAll(regex$2());
  for (const lr of ar)
    try {
      const [ur, dr] = lr;
      yield {
        uri: ur,
        value: dr,
        decoded: decode$3(dr),
        start: lr.index,
        end: lr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$2(cr, ar) {
  return cr.replaceAll(regex$2(), (lr, ur) => ar({
    uri: lr,
    value: ur,
    decoded: decode$3(ur)
  }));
}
var nip28_exports$2 = {};
__export$2(nip28_exports$2, {
  channelCreateEvent: () => channelCreateEvent$2,
  channelHideMessageEvent: () => channelHideMessageEvent$2,
  channelMessageEvent: () => channelMessageEvent$2,
  channelMetadataEvent: () => channelMetadataEvent$2,
  channelMuteUserEvent: () => channelMuteUserEvent$2
});
var channelCreateEvent$2 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 40,
      tags: [...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMetadataEvent$2 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 41,
      tags: [["e", cr.channel_create_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMessageEvent$2 = (cr, ar) => {
  var ur;
  const lr = [["e", cr.channel_create_event_id, cr.relay_url, "root"]];
  return cr.reply_to_channel_message_event_id && lr.push(["e", cr.reply_to_channel_message_event_id, cr.relay_url, "reply"]), finishEvent$1(
    {
      kind: 42,
      tags: [...lr, ...(ur = cr.tags) != null ? ur : []],
      content: cr.content,
      created_at: cr.created_at
    },
    ar
  );
}, channelHideMessageEvent$2 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 43,
      tags: [["e", cr.channel_message_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMuteUserEvent$2 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent$1(
    {
      kind: 44,
      tags: [["p", cr.pubkey_to_mute], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, nip39_exports$2 = {};
__export$2(nip39_exports$2, {
  useFetchImplementation: () => useFetchImplementation2$2,
  validateGithub: () => validateGithub$2
});
var _fetch2$2;
try {
  _fetch2$2 = fetch;
} catch (cr) {
}
function useFetchImplementation2$2(cr) {
  _fetch2$2 = cr;
}
async function validateGithub$2(cr, ar, lr) {
  try {
    return await (await _fetch2$2(`https://gist.github.com/${ar}/${lr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${cr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$2 = {};
__export$2(nip42_exports$2, {
  authenticate: () => authenticate$1
});
var authenticate$1 = async ({
  challenge: cr,
  relay: ar,
  sign: lr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", cr]
    ],
    content: ""
  };
  return ar.auth(await lr(ur));
}, nip44_exports$2 = {};
__export$2(nip44_exports$2, {
  decrypt: () => decrypt2$2,
  encrypt: () => encrypt2$2,
  utils: () => utils$3
});
var utils$3 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(cr, ar) {
      return secp256k1$1.getSharedSecret(cr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(cr, ar) {
      const lr = hkdf$1(sha256$4, cr, ar, "nip44-v2", 76);
      return {
        encryption: lr.subarray(0, 32),
        nonce: lr.subarray(32, 44),
        auth: lr.subarray(44, 76)
      };
    },
    calcPadding(cr) {
      if (!Number.isSafeInteger(cr) || cr < 0)
        throw new Error("expected positive integer");
      if (cr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(cr - 1)) + 1, lr = ar <= 256 ? 32 : ar / 8;
      return lr * (Math.floor((cr - 1) / lr) + 1);
    },
    pad(cr) {
      const ar = utf8Encoder$2.encode(cr), lr = ar.length;
      if (lr < 1 || lr >= utils$3.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$3.v2.calcPadding(lr), dr = new Uint8Array(ur - lr), fr = new Uint8Array(2);
      return new DataView(fr.buffer).setUint16(0, lr), concatBytes$5(fr, ar, dr);
    },
    unpad(cr) {
      const ar = new DataView(cr.buffer).getUint16(0), lr = cr.subarray(2, 2 + ar);
      if (ar === 0 || lr.length !== ar || cr.length !== 2 + utils$3.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$2.decode(lr);
    }
  }
};
function encrypt2$2(cr, ar, lr = {}) {
  var yr, _r;
  const ur = (yr = lr.version) != null ? yr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const dr = (_r = lr.salt) != null ? _r : randomBytes$4(32);
  ensureBytes$1(dr, 32);
  const fr = utils$3.v2.getMessageKeys(cr, dr), gr = utils$3.v2.pad(ar), mr = chacha20(fr.encryption, fr.nonce, gr), vr = hmac$3(sha256$4, fr.auth, mr);
  return base64$2.encode(concatBytes$5(new Uint8Array([ur]), dr, mr, vr));
}
function decrypt2$2(cr, ar) {
  const lr = utils$3.v2;
  ensureBytes$1(cr, 32);
  const ur = ar.length;
  if (ur < lr.minCiphertextSize || ur >= lr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let dr;
  try {
    dr = base64$2.decode(ar);
  } catch (xr) {
    throw new Error("invalid base64: " + xr.message);
  }
  const fr = dr.subarray(0, 1)[0];
  if (fr !== 2)
    throw new Error("unknown encryption version " + fr);
  const gr = dr.subarray(1, 33), mr = dr.subarray(33, -32), vr = dr.subarray(-32), yr = lr.getMessageKeys(cr, gr), _r = hmac$3(sha256$4, yr.auth, mr);
  if (!equalBytes$1(_r, vr))
    throw new Error("invalid MAC");
  const kr = chacha20(yr.encryption, yr.nonce, mr);
  return lr.unpad(kr);
}
var nip47_exports$2 = {};
__export$2(nip47_exports$2, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$2,
  parseConnectionString: () => parseConnectionString$2
});
function parseConnectionString$2(cr) {
  const { pathname: ar, searchParams: lr } = new URL(cr), ur = ar, dr = lr.get("relay"), fr = lr.get("secret");
  if (!ur || !dr || !fr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: dr, secret: fr };
}
async function makeNwcRequestEvent$2({
  pubkey: cr,
  secret: ar,
  invoice: lr
}) {
  const dr = await encrypt$3(ar, cr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: lr
    }
  })), fr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [["p", cr]]
  };
  return finishEvent$1(fr, ar);
}
var nip57_exports$2 = {};
__export$2(nip57_exports$2, {
  getZapEndpoint: () => getZapEndpoint$2,
  makeZapReceipt: () => makeZapReceipt$2,
  makeZapRequest: () => makeZapRequest$2,
  useFetchImplementation: () => useFetchImplementation3$2,
  validateZapRequest: () => validateZapRequest$2
});
var _fetch3$2;
try {
  _fetch3$2 = fetch;
} catch (cr) {
}
function useFetchImplementation3$2(cr) {
  _fetch3$2 = cr;
}
async function getZapEndpoint$2(cr) {
  try {
    let ar = "", { lud06: lr, lud16: ur } = JSON.parse(cr.content);
    if (lr) {
      let { words: gr } = bech32$3.decode(lr, 1e3), mr = bech32$3.fromWords(gr);
      ar = utf8Decoder$2.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = `https://${mr}/.well-known/lnurlp/${gr}`;
    } else
      return null;
    let fr = await (await _fetch3$2(ar)).json();
    if (fr.allowsNostr && fr.nostrPubkey)
      return fr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$2({
  profile: cr,
  event: ar,
  amount: lr,
  relays: ur,
  comment: dr = ""
}) {
  if (!lr)
    throw new Error("amount not given");
  if (!cr)
    throw new Error("profile not given");
  let fr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [
      ["p", cr],
      ["amount", lr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && fr.tags.push(["e", ar]), fr;
}
function validateZapRequest$2(cr) {
  let ar;
  try {
    ar = JSON.parse(cr);
  } catch (fr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$2(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature$1(ar))
    return "Invalid signature on zap request.";
  let lr = ar.tags.find(([fr, gr]) => fr === "p" && gr);
  if (!lr)
    return "Zap request doesn't have a 'p' tag.";
  if (!lr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([fr, gr]) => fr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([fr, gr]) => fr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$2({
  zapRequest: cr,
  preimage: ar,
  bolt11: lr,
  paidAt: ur
}) {
  let fr = JSON.parse(cr).tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...fr, ["bolt11", lr], ["description", cr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports$2 = {};
__export$2(nip98_exports$2, {
  getToken: () => getToken$2,
  unpackEventFromToken: () => unpackEventFromToken$2,
  validateEvent: () => validateEvent2$2,
  validateToken: () => validateToken$2
});
var _authorizationScheme$2 = "Nostr ";
async function getToken$2(cr, ar, lr, ur = !1) {
  if (!cr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const dr = getBlankEvent$1(
    27235
    /* HttpAuth */
  );
  dr.tags = [
    ["u", cr],
    ["method", ar]
  ], dr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const fr = await lr(dr);
  return (ur ? _authorizationScheme$2 : "") + base64$2.encode(utf8Encoder$2.encode(JSON.stringify(fr)));
}
async function validateToken$2(cr, ar, lr) {
  const ur = await unpackEventFromToken$2(cr).catch((fr) => {
    throw fr;
  });
  return await validateEvent2$2(ur, ar, lr).catch((fr) => {
    throw fr;
  });
}
async function unpackEventFromToken$2(cr) {
  if (!cr)
    throw new Error("Missing token");
  cr = cr.replace(_authorizationScheme$2, "");
  const ar = utf8Decoder$2.decode(base64$2.decode(cr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$2(cr, ar, lr) {
  if (!cr)
    throw new Error("Invalid nostr event");
  if (!verifySignature$1(cr))
    throw new Error("Invalid nostr event, signature invalid");
  if (cr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!cr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - cr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = cr.tags.find((fr) => fr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const dr = cr.tags.find((fr) => fr[0] === "method");
  if ((dr == null ? void 0 : dr.length) !== 1 && (dr == null ? void 0 : dr[1].toLowerCase()) !== lr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
var commonjsGlobal$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function getDefaultExportFromCjs(cr) {
  return cr && cr.__esModule && Object.prototype.hasOwnProperty.call(cr, "default") ? cr.default : cr;
}
function getAugmentedNamespace(cr) {
  if (cr.__esModule)
    return cr;
  var ar = cr.default;
  if (typeof ar == "function") {
    var lr = function ur() {
      return this instanceof ur ? Reflect.construct(ar, arguments, this.constructor) : ar.apply(this, arguments);
    };
    lr.prototype = ar.prototype;
  } else
    lr = {};
  return Object.defineProperty(lr, "__esModule", { value: !0 }), Object.keys(cr).forEach(function(ur) {
    var dr = Object.getOwnPropertyDescriptor(cr, ur);
    Object.defineProperty(lr, ur, dr.get ? dr : {
      enumerable: !0,
      get: function() {
        return cr[ur];
      }
    });
  }), lr;
}
var lib$2 = {}, types = {};
Object.defineProperty(types, "__esModule", { value: !0 });
var ee$2 = {}, taskCollection$1 = {}, taskCollection = {}, bakeCollection = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.bakeCollectionVariadic = exports.bakeCollectionAwait = exports.bakeCollection = exports.BAKED_EMPTY_FUNC = void 0, exports.BAKED_EMPTY_FUNC = function() {
  };
  var FORLOOP_FALLBACK = 1500;
  function generateArgsDefCode(cr) {
    var ar = "";
    if (cr === 0)
      return ar;
    for (var lr = 0; lr < cr - 1; ++lr)
      ar += "arg" + String(lr) + ", ";
    return ar += "arg" + String(cr - 1), ar;
  }
  function generateBodyPartsCode(cr, ar) {
    for (var lr = "", ur = "", dr = 0; dr < ar; ++dr)
      lr += "var f".concat(dr, " = collection[").concat(dr, `];
`), ur += "f".concat(dr, "(").concat(cr, `)
`);
    return { funcDefCode: lr, funcCallCode: ur };
  }
  function generateBodyPartsVariadicCode(cr) {
    for (var ar = "", lr = "", ur = 0; ur < cr; ++ur)
      ar += "var f".concat(ur, " = collection[").concat(ur, `];
`), lr += "f".concat(ur, `.apply(undefined, arguments)
`);
    return { funcDefCode: ar, funcCallCode: lr };
  }
  function bakeCollection(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                `).concat(funcCallCode, `
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      collection.length % 10 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                        collection[i+4](`).concat(argsDefCode, `);
                        collection[i+5](`).concat(argsDefCode, `);
                        collection[i+6](`).concat(argsDefCode, `);
                        collection[i+7](`).concat(argsDefCode, `);
                        collection[i+8](`).concat(argsDefCode, `);
                        collection[i+9](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 4 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                        collection[i+3](`).concat(argsDefCode, `);
                    }
                });
            })`) : collection.length % 3 === 0 ? funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode, `);
                        collection[i+1](`).concat(argsDefCode, `);
                        collection[i+2](`).concat(argsDefCode, `);
                    }
                });
            })`) : funcFactoryCode = `(function(collection) {
                return (function(`.concat(argsDefCode, `) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode, `);
                    }
                });
            })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollection = bakeCollection;
  function bakeCollectionAwait(collection, fixedArgsNum) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var argsDefCode = generateArgsDefCode(fixedArgsNum), _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function(`).concat(argsDefCode, `) {
                return Promise.all([ `).concat(funcCallCode, ` ]);
            });
        })`);
    } else {
      var argsDefCode = generateArgsDefCode(fixedArgsNum);
      funcFactoryCode = `(function(collection) {
            return (function(`.concat(argsDefCode, `) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode, `);
                }
                return Promise.all(promises);
            });
        })`);
    }
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionAwait = bakeCollectionAwait;
  function bakeCollectionVariadic(collection) {
    if (collection.length === 0)
      return exports.BAKED_EMPTY_FUNC;
    if (collection.length === 1)
      return collection[0];
    var funcFactoryCode;
    if (collection.length < FORLOOP_FALLBACK) {
      var _a = generateBodyPartsVariadicCode(collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;
      funcFactoryCode = `(function(collection) {
            `.concat(funcDefCode, `
            collection = undefined;
            return (function() {
                `).concat(funcCallCode, `
            });
        })`);
    } else
      funcFactoryCode = `(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;
    {
      var funcFactory = eval(funcFactoryCode);
      return funcFactory(collection);
    }
  }
  exports.bakeCollectionVariadic = bakeCollectionVariadic;
})(bakeCollection);
var __spreadArray$3 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(cr, ar, lr) {
  if (lr || arguments.length === 2)
    for (var ur = 0, dr = ar.length, fr; ur < dr; ur++)
      (fr || !(ur in ar)) && (fr || (fr = Array.prototype.slice.call(ar, 0, ur)), fr[ur] = ar[ur]);
  return cr.concat(fr || Array.prototype.slice.call(ar));
};
Object.defineProperty(taskCollection, "__esModule", { value: !0 });
taskCollection.TaskCollection = taskCollection._fast_remove_single = void 0;
var bake_collection_1 = bakeCollection;
function push_norebuild(cr, ar) {
  var lr = this.length;
  if (lr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(cr), this.length++;
  else if (ar) {
    if (lr === 1) {
      var dr = Array(1 + arguments.length);
      dr.push(dr), dr.push.apply(dr, arguments), this._tasks = dr;
    } else {
      var dr = Array(arguments.length);
      dr.push.apply(dr, arguments), this._tasks = dr;
    }
    this.length += arguments.length;
  } else
    lr === 1 ? this._tasks = [this._tasks, cr] : this._tasks = cr, this.length++;
}
function push_rebuild(cr, ar) {
  var lr = this.length;
  if (lr > 1)
    if (ar) {
      var ur;
      (ur = this._tasks).push.apply(ur, arguments), this.length += arguments.length;
    } else
      this._tasks.push(cr), this.length++;
  else if (ar) {
    if (lr === 1) {
      var dr = Array(1 + arguments.length);
      dr.push(dr), dr.push.apply(dr, arguments), this._tasks = dr;
    } else {
      var dr = Array(arguments.length);
      dr.push.apply(dr, arguments), this._tasks = dr;
    }
    this.length += arguments.length;
  } else
    lr === 1 ? this._tasks = [this._tasks, cr] : this._tasks = cr, this.length++;
  this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function _fast_remove_single(cr, ar) {
  ar !== -1 && (ar === 0 ? cr.shift() : ar === cr.length - 1 ? cr.length = cr.length - 1 : cr.splice(ar, 1));
}
taskCollection._fast_remove_single = _fast_remove_single;
function removeLast_norebuild(cr) {
  this.length !== 0 && (this.length === 1 ? this._tasks === cr && (this.length = 0) : (_fast_remove_single(this._tasks, this._tasks.lastIndexOf(cr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length));
}
function removeLast_rebuild(cr) {
  if (this.length !== 0) {
    if (this.length === 1)
      if (this._tasks === cr && (this.length = 0), this.firstEmitBuildStrategy) {
        this.call = bake_collection_1.BAKED_EMPTY_FUNC;
        return;
      } else {
        this.rebuild();
        return;
      }
    else
      _fast_remove_single(this._tasks, this._tasks.lastIndexOf(cr)), this._tasks.length === 1 ? (this._tasks = this._tasks[0], this.length = 1) : this.length = this._tasks.length;
    this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
  }
}
function insert_norebuild(cr) {
  for (var ar, lr = [], ur = 1; ur < arguments.length; ur++)
    lr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = lr, this.length = 1) : this.length === 1 ? (lr.unshift(this._tasks), this._tasks = lr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([cr, 0], lr, !1)), this.length = this._tasks.length);
}
function insert_rebuild(cr) {
  for (var ar, lr = [], ur = 1; ur < arguments.length; ur++)
    lr[ur - 1] = arguments[ur];
  this.length === 0 ? (this._tasks = lr, this.length = 1) : this.length === 1 ? (lr.unshift(this._tasks), this._tasks = lr, this.length = this._tasks.length) : ((ar = this._tasks).splice.apply(ar, __spreadArray$3([cr, 0], lr, !1)), this.length = this._tasks.length), this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild();
}
function rebuild_noawait() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollection)(this._tasks, this.argsNum);
}
function rebuild_await() {
  this.length === 0 ? this.call = bake_collection_1.BAKED_EMPTY_FUNC : this.length === 1 ? this.call = this._tasks : this.call = (0, bake_collection_1.bakeCollectionAwait)(this._tasks, this.argsNum);
}
function rebuild_on_first_call() {
  this.rebuild(), this.call.apply(void 0, arguments);
}
var TaskCollection = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      lr === void 0 && (lr = !0), ur === void 0 && (ur = null), dr === void 0 && (dr = !1), this.awaitTasks = dr, this.call = bake_collection_1.BAKED_EMPTY_FUNC, this.argsNum = ar, this.firstEmitBuildStrategy = !0, dr ? this.rebuild = rebuild_await.bind(this) : this.rebuild = rebuild_noawait.bind(this), this.setAutoRebuild(lr), ur ? typeof ur == "function" ? (this._tasks = ur, this.length = 1) : (this._tasks = ur, this.length = ur.length) : (this._tasks = null, this.length = 0), lr && this.rebuild();
    }
    return cr;
  }()
);
taskCollection.TaskCollection = TaskCollection;
function fastClear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function clear() {
  this._tasks = null, this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC;
}
function growArgsNum(cr) {
  this.argsNum < cr && (this.argsNum = cr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
function setAutoRebuild(cr) {
  cr ? (this.push = push_rebuild.bind(this), this.insert = insert_rebuild.bind(this), this.removeLast = removeLast_rebuild.bind(this)) : (this.push = push_norebuild.bind(this), this.insert = insert_norebuild.bind(this), this.removeLast = removeLast_norebuild.bind(this));
}
function tasksAsArray() {
  return this.length === 0 ? [] : this.length === 1 ? [this._tasks] : this._tasks;
}
function setTasks(cr) {
  cr.length === 0 ? (this.length = 0, this.call = bake_collection_1.BAKED_EMPTY_FUNC) : cr.length === 1 ? (this.length = 1, this.call = cr[0], this._tasks = cr[0]) : (this.length = cr.length, this._tasks = cr, this.firstEmitBuildStrategy ? this.call = rebuild_on_first_call : this.rebuild());
}
TaskCollection.prototype.fastClear = fastClear;
TaskCollection.prototype.clear = clear;
TaskCollection.prototype.growArgsNum = growArgsNum;
TaskCollection.prototype.setAutoRebuild = setAutoRebuild;
TaskCollection.prototype.tasksAsArray = tasksAsArray;
TaskCollection.prototype.setTasks = setTasks;
(function(cr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr);
    var mr = Object.getOwnPropertyDescriptor(dr, fr);
    (!mr || ("get" in mr ? !dr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return dr[fr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr), ur[gr] = dr[fr];
  }), lr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, dr) {
    for (var fr in ur)
      fr !== "default" && !Object.prototype.hasOwnProperty.call(dr, fr) && ar(dr, ur, fr);
  };
  Object.defineProperty(cr, "__esModule", { value: !0 }), lr(taskCollection, cr);
})(taskCollection$1);
var utils$2 = {};
Object.defineProperty(utils$2, "__esModule", { value: !0 });
utils$2.nullObj = void 0;
function nullObj() {
  var cr = {};
  return cr.__proto__ = null, cr.prototype = null, cr;
}
utils$2.nullObj = nullObj;
var __spreadArray$2 = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(cr, ar, lr) {
  if (lr || arguments.length === 2)
    for (var ur = 0, dr = ar.length, fr; ur < dr; ur++)
      (fr || !(ur in ar)) && (fr || (fr = Array.prototype.slice.call(ar, 0, ur)), fr[ur] = ar[ur]);
  return cr.concat(fr || Array.prototype.slice.call(ar));
};
Object.defineProperty(ee$2, "__esModule", { value: !0 });
ee$2.EventEmitter = void 0;
var task_collection_1 = taskCollection$1, utils_1$1 = utils$2;
function emit(cr, ar, lr, ur, dr, fr) {
  var gr = this.events[cr];
  return gr ? gr.length === 0 ? !1 : (gr.argsNum < 6 ? gr.call(ar, lr, ur, dr, fr) : gr.call.apply(void 0, arguments), !0) : !1;
}
function emitHasOnce(cr, ar, lr, ur, dr, fr) {
  var gr = this.events[cr];
  if (gr) {
    if (gr.length === 0)
      return !1;
    gr.argsNum < 6 ? gr.call(ar, lr, ur, dr, fr) : gr.call.apply(void 0, arguments);
  }
  var mr = this.onceEvents[cr];
  if (mr) {
    if (typeof mr == "function")
      this.onceEvents[cr] = void 0, arguments.length < 6 ? mr(ar, lr, ur, dr, fr) : mr.apply(void 0, arguments);
    else {
      var vr = mr;
      if (this.onceEvents[cr] = void 0, arguments.length < 6)
        for (var yr = 0; yr < vr.length; ++yr)
          vr[yr](ar, lr, ur, dr, fr);
      else
        for (var yr = 0; yr < vr.length; ++yr)
          vr[yr].apply(void 0, arguments);
    }
    return !0;
  }
  return !!gr;
}
var EventEmitter$1 = (
  /** @class */
  function() {
    function cr() {
      this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set(), this.maxListeners = 1 / 0;
    }
    return Object.defineProperty(cr.prototype, "_eventsCount", {
      get: function() {
        return this.eventNames().length;
      },
      enumerable: !1,
      configurable: !0
    }), cr;
  }()
);
ee$2.EventEmitter = EventEmitter$1;
function once(cr, ar) {
  switch (this.emit === emit && (this.emit = emitHasOnce), typeof this.onceEvents[cr]) {
    case "undefined":
      this.onceEvents[cr] = ar, typeof cr == "symbol" && this._symbolKeys.add(cr);
      break;
    case "function":
      this.onceEvents[cr] = [this.onceEvents[cr], ar];
      break;
    case "object":
      this.onceEvents[cr].push(ar);
  }
  return this;
}
function addListener(cr, ar, lr) {
  if (lr === void 0 && (lr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[cr];
  return ur ? (ur.push(ar), ur.growArgsNum(lr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(cr), '" event!'))) : (this.events[cr] = new task_collection_1.TaskCollection(lr, !0, ar, !1), typeof cr == "symbol" && this._symbolKeys.add(cr)), this;
}
function removeListener(cr, ar) {
  var lr = this.events[cr];
  lr && lr.removeLast(ar);
  var ur = this.onceEvents[cr];
  return ur && (typeof ur == "function" ? this.onceEvents[cr] = void 0 : typeof ur == "object" && (ur.length === 1 && ur[0] === ar ? this.onceEvents[cr] = void 0 : (0, task_collection_1._fast_remove_single)(ur, ur.lastIndexOf(ar)))), this;
}
function hasListeners(cr) {
  return this.events[cr] && !!this.events[cr].length;
}
function prependListener(cr, ar, lr) {
  if (lr === void 0 && (lr = ar.length), typeof ar != "function")
    throw new TypeError("The listener must be a function");
  var ur = this.events[cr];
  return !ur || !(ur instanceof task_collection_1.TaskCollection) ? (ur = this.events[cr] = new task_collection_1.TaskCollection(lr, !0, ar, !1), typeof cr == "symbol" && this._symbolKeys.add(cr)) : (ur.insert(0, ar), ur.growArgsNum(lr), this.maxListeners !== 1 / 0 && this.maxListeners <= ur.length && console.warn('Maximum event listeners for "'.concat(String(cr), '" event!'))), this;
}
function prependOnceListener(cr, ar) {
  this.emit === emit && (this.emit = emitHasOnce);
  var lr = this.onceEvents[cr];
  if (!lr || typeof lr != "object")
    lr = this.onceEvents[cr] = [ar], typeof cr == "symbol" && this._symbolKeys.add(cr);
  else
    throw new Error("FIXME");
  return this;
}
function removeAllListeners(cr) {
  return cr === void 0 ? (this.events = (0, utils_1$1.nullObj)(), this.onceEvents = (0, utils_1$1.nullObj)(), this._symbolKeys = /* @__PURE__ */ new Set()) : (this.events[cr] = void 0, this.onceEvents[cr] = void 0, typeof cr == "symbol" && this._symbolKeys.delete(cr)), this;
}
function setMaxListeners(cr) {
  return this.maxListeners = cr, this;
}
function getMaxListeners() {
  return this.maxListeners;
}
function listeners(cr) {
  return this.emit === emit ? this.events[cr] ? this.events[cr].tasksAsArray().slice() : [] : this.events[cr] && this.onceEvents[cr] ? __spreadArray$2(__spreadArray$2([], this.events[cr].tasksAsArray(), !0), typeof this.onceEvents[cr] == "function" ? [this.onceEvents[cr]] : this.onceEvents[cr], !0) : this.events[cr] ? this.events[cr].tasksAsArray() : this.onceEvents[cr] ? typeof this.onceEvents[cr] == "function" ? [this.onceEvents[cr]] : this.onceEvents[cr] : [];
}
function eventNames() {
  var cr = this;
  if (this.emit === emit) {
    var ar = Object.keys(this.events);
    return __spreadArray$2(__spreadArray$2([], ar, !0), Array.from(this._symbolKeys), !0).filter(function(ur) {
      return ur in cr.events && cr.events[ur] && cr.events[ur].length;
    });
  } else {
    var ar = Object.keys(this.events).filter(function(dr) {
      return cr.events[dr] && cr.events[dr].length;
    }), lr = Object.keys(this.onceEvents).filter(function(dr) {
      return cr.onceEvents[dr] && cr.onceEvents[dr].length;
    });
    return __spreadArray$2(__spreadArray$2(__spreadArray$2([], ar, !0), lr, !0), Array.from(this._symbolKeys).filter(function(dr) {
      return dr in cr.events && cr.events[dr] && cr.events[dr].length || dr in cr.onceEvents && cr.onceEvents[dr] && cr.onceEvents[dr].length;
    }), !0);
  }
}
function listenerCount(cr) {
  return this.emit === emit ? this.events[cr] && this.events[cr].length || 0 : (this.events[cr] && this.events[cr].length || 0) + (this.onceEvents[cr] && this.onceEvents[cr].length || 0);
}
EventEmitter$1.prototype.emit = emit;
EventEmitter$1.prototype.on = addListener;
EventEmitter$1.prototype.once = once;
EventEmitter$1.prototype.addListener = addListener;
EventEmitter$1.prototype.removeListener = removeListener;
EventEmitter$1.prototype.hasListeners = hasListeners;
EventEmitter$1.prototype.prependListener = prependListener;
EventEmitter$1.prototype.prependOnceListener = prependOnceListener;
EventEmitter$1.prototype.off = removeListener;
EventEmitter$1.prototype.removeAllListeners = removeAllListeners;
EventEmitter$1.prototype.setMaxListeners = setMaxListeners;
EventEmitter$1.prototype.getMaxListeners = getMaxListeners;
EventEmitter$1.prototype.listeners = listeners;
EventEmitter$1.prototype.eventNames = eventNames;
EventEmitter$1.prototype.listenerCount = listenerCount;
(function(cr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr);
    var mr = Object.getOwnPropertyDescriptor(dr, fr);
    (!mr || ("get" in mr ? !dr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return dr[fr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr), ur[gr] = dr[fr];
  }), lr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, dr) {
    for (var fr in ur)
      fr !== "default" && !Object.prototype.hasOwnProperty.call(dr, fr) && ar(dr, ur, fr);
  };
  Object.defineProperty(cr, "__esModule", { value: !0 }), lr(types, cr), lr(ee$2, cr);
})(lib$2);
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var cr = 1e3, ar = cr * 60, lr = ar * 60, ur = lr * 24, dr = ur * 7, fr = ur * 365.25;
  ms = function(_r, kr) {
    kr = kr || {};
    var xr = typeof _r;
    if (xr === "string" && _r.length > 0)
      return gr(_r);
    if (xr === "number" && isFinite(_r))
      return kr.long ? vr(_r) : mr(_r);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(_r)
    );
  };
  function gr(_r) {
    if (_r = String(_r), !(_r.length > 100)) {
      var kr = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        _r
      );
      if (kr) {
        var xr = parseFloat(kr[1]), Ar = (kr[2] || "ms").toLowerCase();
        switch (Ar) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return xr * fr;
          case "weeks":
          case "week":
          case "w":
            return xr * dr;
          case "days":
          case "day":
          case "d":
            return xr * ur;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return xr * lr;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return xr * ar;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return xr * cr;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return xr;
          default:
            return;
        }
      }
    }
  }
  function mr(_r) {
    var kr = Math.abs(_r);
    return kr >= ur ? Math.round(_r / ur) + "d" : kr >= lr ? Math.round(_r / lr) + "h" : kr >= ar ? Math.round(_r / ar) + "m" : kr >= cr ? Math.round(_r / cr) + "s" : _r + "ms";
  }
  function vr(_r) {
    var kr = Math.abs(_r);
    return kr >= ur ? yr(_r, kr, ur, "day") : kr >= lr ? yr(_r, kr, lr, "hour") : kr >= ar ? yr(_r, kr, ar, "minute") : kr >= cr ? yr(_r, kr, cr, "second") : _r + " ms";
  }
  function yr(_r, kr, xr, Ar) {
    var Er = kr >= xr * 1.5;
    return Math.round(_r / xr) + " " + Ar + (Er ? "s" : "");
  }
  return ms;
}
function setup(cr) {
  lr.debug = lr, lr.default = lr, lr.coerce = vr, lr.disable = fr, lr.enable = dr, lr.enabled = gr, lr.humanize = requireMs(), lr.destroy = yr, Object.keys(cr).forEach((_r) => {
    lr[_r] = cr[_r];
  }), lr.names = [], lr.skips = [], lr.formatters = {};
  function ar(_r) {
    let kr = 0;
    for (let xr = 0; xr < _r.length; xr++)
      kr = (kr << 5) - kr + _r.charCodeAt(xr), kr |= 0;
    return lr.colors[Math.abs(kr) % lr.colors.length];
  }
  lr.selectColor = ar;
  function lr(_r) {
    let kr, xr = null, Ar, Er;
    function Cr(...Tr) {
      if (!Cr.enabled)
        return;
      const Sr = Cr, Lr = Number(/* @__PURE__ */ new Date()), Ir = Lr - (kr || Lr);
      Sr.diff = Ir, Sr.prev = kr, Sr.curr = Lr, kr = Lr, Tr[0] = lr.coerce(Tr[0]), typeof Tr[0] != "string" && Tr.unshift("%O");
      let Nr = 0;
      Tr[0] = Tr[0].replace(/%([a-zA-Z%])/g, (Mr, Br) => {
        if (Mr === "%%")
          return "%";
        Nr++;
        const Dr = lr.formatters[Br];
        if (typeof Dr == "function") {
          const Hr = Tr[Nr];
          Mr = Dr.call(Sr, Hr), Tr.splice(Nr, 1), Nr--;
        }
        return Mr;
      }), lr.formatArgs.call(Sr, Tr), (Sr.log || lr.log).apply(Sr, Tr);
    }
    return Cr.namespace = _r, Cr.useColors = lr.useColors(), Cr.color = lr.selectColor(_r), Cr.extend = ur, Cr.destroy = lr.destroy, Object.defineProperty(Cr, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => xr !== null ? xr : (Ar !== lr.namespaces && (Ar = lr.namespaces, Er = lr.enabled(_r)), Er),
      set: (Tr) => {
        xr = Tr;
      }
    }), typeof lr.init == "function" && lr.init(Cr), Cr;
  }
  function ur(_r, kr) {
    const xr = lr(this.namespace + (typeof kr == "undefined" ? ":" : kr) + _r);
    return xr.log = this.log, xr;
  }
  function dr(_r) {
    lr.save(_r), lr.namespaces = _r, lr.names = [], lr.skips = [];
    let kr;
    const xr = (typeof _r == "string" ? _r : "").split(/[\s,]+/), Ar = xr.length;
    for (kr = 0; kr < Ar; kr++)
      xr[kr] && (_r = xr[kr].replace(/\*/g, ".*?"), _r[0] === "-" ? lr.skips.push(new RegExp("^" + _r.slice(1) + "$")) : lr.names.push(new RegExp("^" + _r + "$")));
  }
  function fr() {
    const _r = [
      ...lr.names.map(mr),
      ...lr.skips.map(mr).map((kr) => "-" + kr)
    ].join(",");
    return lr.enable(""), _r;
  }
  function gr(_r) {
    if (_r[_r.length - 1] === "*")
      return !0;
    let kr, xr;
    for (kr = 0, xr = lr.skips.length; kr < xr; kr++)
      if (lr.skips[kr].test(_r))
        return !1;
    for (kr = 0, xr = lr.names.length; kr < xr; kr++)
      if (lr.names[kr].test(_r))
        return !0;
    return !1;
  }
  function mr(_r) {
    return _r.toString().substring(2, _r.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function vr(_r) {
    return _r instanceof Error ? _r.stack || _r.message : _r;
  }
  function yr() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return lr.enable(lr.load()), lr;
}
var common = setup;
(function(cr, ar) {
  ar.formatArgs = ur, ar.save = dr, ar.load = fr, ar.useColors = lr, ar.storage = gr(), ar.destroy = (() => {
    let vr = !1;
    return () => {
      vr || (vr = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), ar.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function lr() {
    return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function ur(vr) {
    if (vr[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + vr[0] + (this.useColors ? "%c " : " ") + "+" + cr.exports.humanize(this.diff), !this.useColors)
      return;
    const yr = "color: " + this.color;
    vr.splice(1, 0, yr, "color: inherit");
    let _r = 0, kr = 0;
    vr[0].replace(/%[a-zA-Z%]/g, (xr) => {
      xr !== "%%" && (_r++, xr === "%c" && (kr = _r));
    }), vr.splice(kr, 0, yr);
  }
  ar.log = console.debug || console.log || (() => {
  });
  function dr(vr) {
    try {
      vr ? ar.storage.setItem("debug", vr) : ar.storage.removeItem("debug");
    } catch (yr) {
    }
  }
  function fr() {
    let vr;
    try {
      vr = ar.storage.getItem("debug");
    } catch (yr) {
    }
    return !vr && typeof process != "undefined" && "env" in process && (vr = process.env.DEBUG), vr;
  }
  function gr() {
    try {
      return localStorage;
    } catch (vr) {
    }
  }
  cr.exports = common(ar);
  const { formatters: mr } = cr.exports;
  mr.j = function(vr) {
    try {
      return JSON.stringify(vr);
    } catch (yr) {
      return "[UnexpectedJSONParseError]: " + yr.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const _debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var dist$2 = {}, LRUCache$1 = {}, LRUCacheNode$1 = {};
Object.defineProperty(LRUCacheNode$1, "__esModule", { value: !0 });
LRUCacheNode$1.LRUCacheNode = void 0;
class LRUCacheNode {
  constructor(ar, lr, ur) {
    const { entryExpirationTimeInMS: dr = null, next: fr = null, prev: gr = null, onEntryEvicted: mr, onEntryMarkedAsMostRecentlyUsed: vr, clone: yr, cloneFn: _r } = ur != null ? ur : {};
    if (typeof dr == "number" && (dr <= 0 || Number.isNaN(dr)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.clone = yr != null ? yr : !1, this.cloneFn = _r != null ? _r : this.defaultClone, this.key = ar, this.internalValue = this.clone ? this.cloneFn(lr) : lr, this.created = Date.now(), this.entryExpirationTimeInMS = dr, this.next = fr, this.prev = gr, this.onEntryEvicted = mr, this.onEntryMarkedAsMostRecentlyUsed = vr;
  }
  get value() {
    return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;
  }
  get isExpired() {
    return typeof this.entryExpirationTimeInMS == "number" && Date.now() - this.created > this.entryExpirationTimeInMS;
  }
  invokeOnEvicted() {
    if (this.onEntryEvicted) {
      const { key: ar, value: lr, isExpired: ur } = this;
      this.onEntryEvicted({ key: ar, value: lr, isExpired: ur });
    }
  }
  invokeOnEntryMarkedAsMostRecentlyUsed() {
    if (this.onEntryMarkedAsMostRecentlyUsed) {
      const { key: ar, value: lr } = this;
      this.onEntryMarkedAsMostRecentlyUsed({ key: ar, value: lr });
    }
  }
  defaultClone(ar) {
    return typeof ar == "boolean" || typeof ar == "string" || typeof ar == "number" ? ar : JSON.parse(JSON.stringify(ar));
  }
}
LRUCacheNode$1.LRUCacheNode = LRUCacheNode;
Object.defineProperty(LRUCache$1, "__esModule", { value: !0 });
LRUCache$1.LRUCache = void 0;
const LRUCacheNode_1 = LRUCacheNode$1;
class LRUCache {
  /**
   * Creates a new instance of the LRUCache.
   *
   * @param options Additional configuration options for the LRUCache.
   *
   * @example
   * ```typescript
   * // No options.
   * const cache = new LRUCache();
   *
   * // With options.
   * const cache = new LRUCache({
   *  entryExpirationTimeInMS: 10000
   * });
   * ```
   */
  constructor(ar) {
    this.lookupTable = /* @__PURE__ */ new Map(), this.head = null, this.tail = null;
    const { maxSize: lr = 25, entryExpirationTimeInMS: ur = null, onEntryEvicted: dr, onEntryMarkedAsMostRecentlyUsed: fr, cloneFn: gr, clone: mr } = ar != null ? ar : {};
    if (Number.isNaN(lr) || lr <= 0)
      throw new Error("maxSize must be greater than 0.");
    if (typeof ur == "number" && (ur <= 0 || Number.isNaN(ur)))
      throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");
    this.maxSizeInternal = lr, this.entryExpirationTimeInMS = ur, this.onEntryEvicted = dr, this.onEntryMarkedAsMostRecentlyUsed = fr, this.clone = mr, this.cloneFn = gr;
  }
  /**
   * Returns the number of entries in the LRUCache object.
   * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.
   *
   * @returns The number of entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * cache.set('testKey', 'testValue');
   *
   * const size = cache.size;
   *
   * // Will log 1
   * console.log(size);
   * ```
   */
  get size() {
    return this.cleanCache(), this.lookupTable.size;
  }
  /**
   * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.
   *
   * @returns The number of entries that can still be added without evicting existing entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const remainingSize = cache.remainingSize;
   *
   * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.
   * console.log(remainingSize);
   * ```
   */
  get remainingSize() {
    return this.maxSizeInternal - this.size;
  }
  /**
   * Returns the most recently used (newest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the newest node is expired, it will be removed.
   *
   * @returns The most recently used (newest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const newest = cache.newest;
   *
   * // Will log testValue
   * console.log(newest.value);
   *
   * // Will log testKey
   * console.log(newest.key);
   * ```
   */
  get newest() {
    return this.head ? this.head.isExpired ? (this.removeNodeFromListAndLookupTable(this.head), this.newest) : this.mapNodeToEntry(this.head) : null;
  }
  /**
   * Returns the least recently used (oldest) entry in the cache.
   * This will not mark the entry as recently used.
   * If the oldest node is expired, it will be removed.
   *
   * @returns The least recently used (oldest) entry in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * const oldest = cache.oldest;
   *
   * // Will log testValue
   * console.log(oldest.value);
   *
   * // Will log testKey
   * console.log(oldest.key);
   * ```
   */
  get oldest() {
    return this.tail ? this.tail.isExpired ? (this.removeNodeFromListAndLookupTable(this.tail), this.oldest) : this.mapNodeToEntry(this.tail) : null;
  }
  /**
   * Gets or sets the maxSize of the cache.
   * This will evict the least recently used entries if needed to reach new maxSize.
   *
   * @param value The new value for maxSize. Must be greater than 0.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache({ maxSize: 10 });
   *
   * cache.set('testKey', 'testValue');
   *
   * // Will be 10
   * const maxSize = cache.maxSize;
   *
   * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.
   * cache.maxSize = 5;
   * ```
   */
  get maxSize() {
    return this.maxSizeInternal;
  }
  set maxSize(ar) {
    if (Number.isNaN(ar) || ar <= 0)
      throw new Error("maxSize must be greater than 0.");
    this.maxSizeInternal = ar, this.enforceSizeLimit();
  }
  /**
   * Sets the value for the key in the LRUCache object. Returns the LRUCache object.
   * This marks the newly added entry as the most recently used entry.
   * If adding the new entry makes the cache size go above maxSize,
   * this will evict the least recently used entries until size is equal to maxSize.
   *
   * @param key The key of the entry.
   * @param value The value to set for the key.
   * @param entryOptions Additional configuration options for the cache entry.
   *
   * @returns The LRUCache instance.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Set the key key2 to value value2. Pass in optional options.
   * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });
   * ```
   */
  set(ar, lr, ur) {
    const dr = this.lookupTable.get(ar);
    dr && this.removeNodeFromListAndLookupTable(dr);
    const fr = new LRUCacheNode_1.LRUCacheNode(ar, lr, {
      entryExpirationTimeInMS: this.entryExpirationTimeInMS,
      onEntryEvicted: this.onEntryEvicted,
      onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,
      clone: this.clone,
      cloneFn: this.cloneFn,
      ...ur
    });
    return this.setNodeAsHead(fr), this.lookupTable.set(ar, fr), this.enforceSizeLimit(), this;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'. Entry will now be most recently used.
   * const item1 = cache.get('testKey');
   *
   * // Will be null
   * const item2 = cache.get('keyNotInCache');
   * ```
   */
  get(ar) {
    const lr = this.lookupTable.get(ar);
    return lr ? lr.isExpired ? (this.removeNodeFromListAndLookupTable(lr), null) : (this.setNodeAsHead(lr), lr.value) : null;
  }
  /**
   * Returns the value associated to the key, or null if there is none or if the entry is expired.
   * If an entry is returned, this will not mark the entry as most recently accessed.
   * Useful if a value is needed but the order of the cache should not be changed.
   *
   * @param key The key of the entry to get.
   *
   * @returns The cached value or null.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be 'testValue'
   * const item1 = cache.peek('testKey');
   *
   * // Will be null
   * const item2 = cache.peek('keyNotInCache');
   * ```
   */
  peek(ar) {
    const lr = this.lookupTable.get(ar);
    return lr ? lr.isExpired ? (this.removeNodeFromListAndLookupTable(lr), null) : lr.value : null;
  }
  /**
   * Deletes the entry for the passed in key.
   *
   * @param key The key of the entry to delete
   *
   * @returns True if an element in the LRUCache object existed and has been removed,
   * or false if the element does not exist.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.delete('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.delete('keyNotInCache');
   * ```
   */
  delete(ar) {
    const lr = this.lookupTable.get(ar);
    return lr ? this.removeNodeFromListAndLookupTable(lr) : !1;
  }
  /**
   * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.
   * This does not mark the entry as recently used.
   * If the cache has a key but the entry is expired, it will be removed and false will be returned.
   *
   * @param key The key of the entry to check if exists
   *
   * @returns true if the cache contains the supplied key. False if not.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Will be true
   * const wasDeleted = cache.has('testKey');
   *
   * // Will be false
   * const wasDeleted2 = cache.has('keyNotInCache');
   * ```
   */
  has(ar) {
    const lr = this.lookupTable.get(ar);
    return lr ? lr.isExpired ? (this.removeNodeFromListAndLookupTable(lr), !1) : !0 : !1;
  }
  /**
   * Removes all entries in the cache.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // Clear cache.
   * cache.clear();
   * ```
   */
  clear() {
    this.head = null, this.tail = null, this.lookupTable.clear();
  }
  /**
   * Searches the cache for an entry matching the passed in condition.
   * Expired entries will be skipped (and removed).
   * If multiply entries in the cache match the condition, the most recently used entry will be returned.
   * If an entry is returned, this marks the returned entry as the most recently used entry.
   *
   * @param condition The condition to apply to each entry in the
   *
   * @returns The first cache entry to match the condition. Null if none match.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * // item will be { key: 'testKey', value: 'testValue }
   * const item = cache.find(entry => {
   *   const { key, value } = entry;
   *
   *   if (key === 'testKey' || value === 'something') {
   *     return true;
   *   }
   *
   *   return false;
   * });
   *
   * // item2 will be null
   * const item2 = cache.find(entry => entry.key === 'notInCache');
   * ```
   */
  find(ar) {
    let lr = this.head;
    for (; lr; ) {
      if (lr.isExpired) {
        const dr = lr.next;
        this.removeNodeFromListAndLookupTable(lr), lr = dr;
        continue;
      }
      const ur = this.mapNodeToEntry(lr);
      if (ar(ur))
        return this.setNodeAsHead(lr), ur;
      lr = lr.next;
    }
    return null;
  }
  /**
   * Iterates over and applies the callback function to each entry in the cache.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as recently used.
   *
   * @param callback the callback function to apply to the entry
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * cache.forEach((key, value, index) => {
   *   // do something with key, value, and/or index
   * });
   * ```
   */
  forEach(ar) {
    let lr = this.head, ur = 0;
    for (; lr; ) {
      if (lr.isExpired) {
        const dr = lr.next;
        this.removeNodeFromListAndLookupTable(lr), lr = dr;
        continue;
      }
      ar(lr.value, lr.key, ur), lr = lr.next, ur++;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache values.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache values.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const value of cache.values()) {
   *   // do something with the value
   * }
   * ```
   */
  *values() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const lr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = lr;
        continue;
      }
      yield ar.value, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache keys.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const key of cache.keys()) {
   *   // do something with the key
   * }
   * ```
   */
  *keys() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const lr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = lr;
        continue;
      }
      yield ar.key, ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache.entries()) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *entries() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const lr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = lr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  /**
   * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.
   * Iterates in order from most recently accessed entry to least recently.
   * Expired entries will be skipped (and removed).
   * No entry will be marked as accessed.
   *
   * @returns A Generator for the cache entries.
   *
   * @example
   * ```typescript
   * const cache = new LRUCache();
   *
   * // Set the key testKey to value testValue
   * cache.set('testKey', 'testValue');
   *
   * for (const entry of cache) {
   *   const { key, value } = entry;
   *   // do something with the entry
   * }
   * ```
   */
  *[Symbol.iterator]() {
    let ar = this.head;
    for (; ar; ) {
      if (ar.isExpired) {
        const lr = ar.next;
        this.removeNodeFromListAndLookupTable(ar), ar = lr;
        continue;
      }
      yield this.mapNodeToEntry(ar), ar = ar.next;
    }
  }
  enforceSizeLimit() {
    let ar = this.tail;
    for (; ar !== null && this.size > this.maxSizeInternal; ) {
      const lr = ar.prev;
      this.removeNodeFromListAndLookupTable(ar), ar = lr;
    }
  }
  mapNodeToEntry({ key: ar, value: lr }) {
    return {
      key: ar,
      value: lr
    };
  }
  setNodeAsHead(ar) {
    this.removeNodeFromList(ar), this.head ? (ar.next = this.head, this.head.prev = ar, this.head = ar) : (this.head = ar, this.tail = ar), ar.invokeOnEntryMarkedAsMostRecentlyUsed();
  }
  removeNodeFromList(ar) {
    ar.prev !== null && (ar.prev.next = ar.next), ar.next !== null && (ar.next.prev = ar.prev), this.head === ar && (this.head = ar.next), this.tail === ar && (this.tail = ar.prev), ar.next = null, ar.prev = null;
  }
  removeNodeFromListAndLookupTable(ar) {
    return ar.invokeOnEvicted(), this.removeNodeFromList(ar), this.lookupTable.delete(ar.key);
  }
  cleanCache() {
    if (!this.entryExpirationTimeInMS)
      return;
    const ar = [];
    for (const lr of this.lookupTable.values())
      lr.isExpired && ar.push(lr);
    ar.forEach((lr) => this.removeNodeFromListAndLookupTable(lr));
  }
}
LRUCache$1.LRUCache = LRUCache;
(function(cr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr);
    var mr = Object.getOwnPropertyDescriptor(dr, fr);
    (!mr || ("get" in mr ? !dr.__esModule : mr.writable || mr.configurable)) && (mr = { enumerable: !0, get: function() {
      return dr[fr];
    } }), Object.defineProperty(ur, gr, mr);
  } : function(ur, dr, fr, gr) {
    gr === void 0 && (gr = fr), ur[gr] = dr[fr];
  }), lr = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(ur, dr) {
    for (var fr in ur)
      fr !== "default" && !Object.prototype.hasOwnProperty.call(dr, fr) && ar(dr, ur, fr);
  };
  Object.defineProperty(cr, "__esModule", { value: !0 }), lr(LRUCache$1, cr);
})(dist$2);
var lib$1 = {};
(function(cr) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(cr, "__esModule", { value: !0 }), cr.bytes = cr.stringToBytes = cr.str = cr.bytesToString = cr.hex = cr.utf8 = cr.bech32m = cr.bech32 = cr.base58check = cr.base58xmr = cr.base58xrp = cr.base58flickr = cr.base58 = cr.base64url = cr.base64 = cr.base32crockford = cr.base32hex = cr.base32 = cr.base16 = cr.utils = cr.assertNumber = void 0;
  function ar(zr) {
    if (!Number.isSafeInteger(zr))
      throw new Error(`Wrong integer: ${zr}`);
  }
  cr.assertNumber = ar;
  function lr(...zr) {
    const Ur = (qr, Wr) => (Jr) => qr(Wr(Jr)), jr = Array.from(zr).reverse().reduce((qr, Wr) => qr ? Ur(qr, Wr.encode) : Wr.encode, void 0), Yr = zr.reduce((qr, Wr) => qr ? Ur(qr, Wr.decode) : Wr.decode, void 0);
    return { encode: jr, decode: Yr };
  }
  function ur(zr) {
    return {
      encode: (Ur) => {
        if (!Array.isArray(Ur) || Ur.length && typeof Ur[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return Ur.map((jr) => {
          if (ar(jr), jr < 0 || jr >= zr.length)
            throw new Error(`Digit index outside alphabet: ${jr} (alphabet: ${zr.length})`);
          return zr[jr];
        });
      },
      decode: (Ur) => {
        if (!Array.isArray(Ur) || Ur.length && typeof Ur[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return Ur.map((jr) => {
          if (typeof jr != "string")
            throw new Error(`alphabet.decode: not string element=${jr}`);
          const Yr = zr.indexOf(jr);
          if (Yr === -1)
            throw new Error(`Unknown letter: "${jr}". Allowed: ${zr}`);
          return Yr;
        });
      }
    };
  }
  function dr(zr = "") {
    if (typeof zr != "string")
      throw new Error("join separator should be string");
    return {
      encode: (Ur) => {
        if (!Array.isArray(Ur) || Ur.length && typeof Ur[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let jr of Ur)
          if (typeof jr != "string")
            throw new Error(`join.encode: non-string input=${jr}`);
        return Ur.join(zr);
      },
      decode: (Ur) => {
        if (typeof Ur != "string")
          throw new Error("join.decode input should be string");
        return Ur.split(zr);
      }
    };
  }
  function fr(zr, Ur = "=") {
    if (ar(zr), typeof Ur != "string")
      throw new Error("padding chr should be string");
    return {
      encode(jr) {
        if (!Array.isArray(jr) || jr.length && typeof jr[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let Yr of jr)
          if (typeof Yr != "string")
            throw new Error(`padding.encode: non-string input=${Yr}`);
        for (; jr.length * zr % 8; )
          jr.push(Ur);
        return jr;
      },
      decode(jr) {
        if (!Array.isArray(jr) || jr.length && typeof jr[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let qr of jr)
          if (typeof qr != "string")
            throw new Error(`padding.decode: non-string input=${qr}`);
        let Yr = jr.length;
        if (Yr * zr % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; Yr > 0 && jr[Yr - 1] === Ur; Yr--)
          if (!((Yr - 1) * zr % 8))
            throw new Error("Invalid padding: string has too much padding");
        return jr.slice(0, Yr);
      }
    };
  }
  function gr(zr) {
    if (typeof zr != "function")
      throw new Error("normalize fn should be function");
    return { encode: (Ur) => Ur, decode: (Ur) => zr(Ur) };
  }
  function mr(zr, Ur, jr) {
    if (Ur < 2)
      throw new Error(`convertRadix: wrong from=${Ur}, base cannot be less than 2`);
    if (jr < 2)
      throw new Error(`convertRadix: wrong to=${jr}, base cannot be less than 2`);
    if (!Array.isArray(zr))
      throw new Error("convertRadix: data should be array");
    if (!zr.length)
      return [];
    let Yr = 0;
    const qr = [], Wr = Array.from(zr);
    for (Wr.forEach((Jr) => {
      if (ar(Jr), Jr < 0 || Jr >= Ur)
        throw new Error(`Wrong integer: ${Jr}`);
    }); ; ) {
      let Jr = 0, Gr = !0;
      for (let Vr = Yr; Vr < Wr.length; Vr++) {
        const Qr = Wr[Vr], $r = Ur * Jr + Qr;
        if (!Number.isSafeInteger($r) || Ur * Jr / Ur !== Jr || $r - Qr !== Ur * Jr)
          throw new Error("convertRadix: carry overflow");
        if (Jr = $r % jr, Wr[Vr] = Math.floor($r / jr), !Number.isSafeInteger(Wr[Vr]) || Wr[Vr] * jr + Jr !== $r)
          throw new Error("convertRadix: carry overflow");
        if (Gr)
          Wr[Vr] ? Gr = !1 : Yr = Vr;
        else
          continue;
      }
      if (qr.push(Jr), Gr)
        break;
    }
    for (let Jr = 0; Jr < zr.length - 1 && zr[Jr] === 0; Jr++)
      qr.push(0);
    return qr.reverse();
  }
  const vr = (zr, Ur) => Ur ? vr(Ur, zr % Ur) : zr, yr = (zr, Ur) => zr + (Ur - vr(zr, Ur));
  function _r(zr, Ur, jr, Yr) {
    if (!Array.isArray(zr))
      throw new Error("convertRadix2: data should be array");
    if (Ur <= 0 || Ur > 32)
      throw new Error(`convertRadix2: wrong from=${Ur}`);
    if (jr <= 0 || jr > 32)
      throw new Error(`convertRadix2: wrong to=${jr}`);
    if (yr(Ur, jr) > 32)
      throw new Error(`convertRadix2: carry overflow from=${Ur} to=${jr} carryBits=${yr(Ur, jr)}`);
    let qr = 0, Wr = 0;
    const Jr = 2 ** jr - 1, Gr = [];
    for (const Vr of zr) {
      if (ar(Vr), Vr >= 2 ** Ur)
        throw new Error(`convertRadix2: invalid data word=${Vr} from=${Ur}`);
      if (qr = qr << Ur | Vr, Wr + Ur > 32)
        throw new Error(`convertRadix2: carry overflow pos=${Wr} from=${Ur}`);
      for (Wr += Ur; Wr >= jr; Wr -= jr)
        Gr.push((qr >> Wr - jr & Jr) >>> 0);
      qr &= 2 ** Wr - 1;
    }
    if (qr = qr << jr - Wr & Jr, !Yr && Wr >= Ur)
      throw new Error("Excess padding");
    if (!Yr && qr)
      throw new Error(`Non-zero padding: ${qr}`);
    return Yr && Wr > 0 && Gr.push(qr >>> 0), Gr;
  }
  function kr(zr) {
    return ar(zr), {
      encode: (Ur) => {
        if (!(Ur instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return mr(Array.from(Ur), 2 ** 8, zr);
      },
      decode: (Ur) => {
        if (!Array.isArray(Ur) || Ur.length && typeof Ur[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(mr(Ur, zr, 2 ** 8));
      }
    };
  }
  function xr(zr, Ur = !1) {
    if (ar(zr), zr <= 0 || zr > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (yr(8, zr) > 32 || yr(zr, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (jr) => {
        if (!(jr instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return _r(Array.from(jr), 8, zr, !Ur);
      },
      decode: (jr) => {
        if (!Array.isArray(jr) || jr.length && typeof jr[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(_r(jr, zr, 8, Ur));
      }
    };
  }
  function Ar(zr) {
    if (typeof zr != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...Ur) {
      try {
        return zr.apply(null, Ur);
      } catch (jr) {
      }
    };
  }
  function Er(zr, Ur) {
    if (ar(zr), typeof Ur != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(jr) {
        if (!(jr instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const Yr = Ur(jr).slice(0, zr), qr = new Uint8Array(jr.length + zr);
        return qr.set(jr), qr.set(Yr, jr.length), qr;
      },
      decode(jr) {
        if (!(jr instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const Yr = jr.slice(0, -zr), qr = Ur(Yr).slice(0, zr), Wr = jr.slice(-zr);
        for (let Jr = 0; Jr < zr; Jr++)
          if (qr[Jr] !== Wr[Jr])
            throw new Error("Invalid checksum");
        return Yr;
      }
    };
  }
  cr.utils = { alphabet: ur, chain: lr, checksum: Er, radix: kr, radix2: xr, join: dr, padding: fr }, cr.base16 = lr(xr(4), ur("0123456789ABCDEF"), dr("")), cr.base32 = lr(xr(5), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), fr(5), dr("")), cr.base32hex = lr(xr(5), ur("0123456789ABCDEFGHIJKLMNOPQRSTUV"), fr(5), dr("")), cr.base32crockford = lr(xr(5), ur("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), dr(""), gr((zr) => zr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), cr.base64 = lr(xr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), fr(6), dr("")), cr.base64url = lr(xr(6), ur("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), fr(6), dr(""));
  const Cr = (zr) => lr(kr(58), ur(zr), dr(""));
  cr.base58 = Cr("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), cr.base58flickr = Cr("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), cr.base58xrp = Cr("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const Tr = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  cr.base58xmr = {
    encode(zr) {
      let Ur = "";
      for (let jr = 0; jr < zr.length; jr += 8) {
        const Yr = zr.subarray(jr, jr + 8);
        Ur += cr.base58.encode(Yr).padStart(Tr[Yr.length], "1");
      }
      return Ur;
    },
    decode(zr) {
      let Ur = [];
      for (let jr = 0; jr < zr.length; jr += 11) {
        const Yr = zr.slice(jr, jr + 11), qr = Tr.indexOf(Yr.length), Wr = cr.base58.decode(Yr);
        for (let Jr = 0; Jr < Wr.length - qr; Jr++)
          if (Wr[Jr] !== 0)
            throw new Error("base58xmr: wrong padding");
        Ur = Ur.concat(Array.from(Wr.slice(Wr.length - qr)));
      }
      return Uint8Array.from(Ur);
    }
  };
  const Sr = (zr) => lr(Er(4, (Ur) => zr(zr(Ur))), cr.base58);
  cr.base58check = Sr;
  const Lr = lr(ur("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), dr("")), Ir = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function Nr(zr) {
    const Ur = zr >> 25;
    let jr = (zr & 33554431) << 5;
    for (let Yr = 0; Yr < Ir.length; Yr++)
      (Ur >> Yr & 1) === 1 && (jr ^= Ir[Yr]);
    return jr;
  }
  function Rr(zr, Ur, jr = 1) {
    const Yr = zr.length;
    let qr = 1;
    for (let Wr = 0; Wr < Yr; Wr++) {
      const Jr = zr.charCodeAt(Wr);
      if (Jr < 33 || Jr > 126)
        throw new Error(`Invalid prefix (${zr})`);
      qr = Nr(qr) ^ Jr >> 5;
    }
    qr = Nr(qr);
    for (let Wr = 0; Wr < Yr; Wr++)
      qr = Nr(qr) ^ zr.charCodeAt(Wr) & 31;
    for (let Wr of Ur)
      qr = Nr(qr) ^ Wr;
    for (let Wr = 0; Wr < 6; Wr++)
      qr = Nr(qr);
    return qr ^= jr, Lr.encode(_r([qr % 2 ** 30], 30, 5, !1));
  }
  function Mr(zr) {
    const Ur = zr === "bech32" ? 1 : 734539939, jr = xr(5), Yr = jr.decode, qr = jr.encode, Wr = Ar(Yr);
    function Jr($r, Xr, si = 90) {
      if (typeof $r != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof $r}`);
      if (!Array.isArray(Xr) || Xr.length && typeof Xr[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof Xr}`);
      const Zr = $r.length + 7 + Xr.length;
      if (si !== !1 && Zr > si)
        throw new TypeError(`Length ${Zr} exceeds limit ${si}`);
      return $r = $r.toLowerCase(), `${$r}1${Lr.encode(Xr)}${Rr($r, Xr, Ur)}`;
    }
    function Gr($r, Xr = 90) {
      if (typeof $r != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof $r}`);
      if ($r.length < 8 || Xr !== !1 && $r.length > Xr)
        throw new TypeError(`Wrong string length: ${$r.length} (${$r}). Expected (8..${Xr})`);
      const si = $r.toLowerCase();
      if ($r !== si && $r !== $r.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      $r = si;
      const Zr = $r.lastIndexOf("1");
      if (Zr === 0 || Zr === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const li = $r.slice(0, Zr), Ei = $r.slice(Zr + 1);
      if (Ei.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const ki = Lr.decode(Ei).slice(0, -6), Di = Rr(li, ki, Ur);
      if (!Ei.endsWith(Di))
        throw new Error(`Invalid checksum in ${$r}: expected "${Di}"`);
      return { prefix: li, words: ki };
    }
    const Vr = Ar(Gr);
    function Qr($r) {
      const { prefix: Xr, words: si } = Gr($r, !1);
      return { prefix: Xr, words: si, bytes: Yr(si) };
    }
    return { encode: Jr, decode: Gr, decodeToBytes: Qr, decodeUnsafe: Vr, fromWords: Yr, fromWordsUnsafe: Wr, toWords: qr };
  }
  cr.bech32 = Mr("bech32"), cr.bech32m = Mr("bech32m"), cr.utf8 = {
    encode: (zr) => new TextDecoder().decode(zr),
    decode: (zr) => new TextEncoder().encode(zr)
  }, cr.hex = lr(xr(4), ur("0123456789abcdef"), dr(""), gr((zr) => {
    if (typeof zr != "string" || zr.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof zr} with length ${zr.length}`);
    return zr.toLowerCase();
  }));
  const Br = {
    utf8: cr.utf8,
    hex: cr.hex,
    base16: cr.base16,
    base32: cr.base32,
    base64: cr.base64,
    base64url: cr.base64url,
    base58: cr.base58,
    base58xmr: cr.base58xmr
  }, Dr = `Invalid encoding type. Available types: ${Object.keys(Br).join(", ")}`, Hr = (zr, Ur) => {
    if (typeof zr != "string" || !Br.hasOwnProperty(zr))
      throw new TypeError(Dr);
    if (!(Ur instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return Br[zr].encode(Ur);
  };
  cr.bytesToString = Hr, cr.str = cr.bytesToString;
  const Fr = (zr, Ur) => {
    if (!Br.hasOwnProperty(zr))
      throw new TypeError(Dr);
    if (typeof Ur != "string")
      throw new TypeError("stringToBytes() expects string");
    return Br[zr].decode(Ur);
  };
  cr.stringToBytes = Fr, cr.bytes = cr.stringToBytes;
})(lib$1);
BigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);
BigInt("2100000000000000000");
BigInt(1e11);
const TAGCODES = {
  payment_hash: 1,
  payment_secret: 16,
  description: 13,
  payee: 19,
  description_hash: 23,
  // commit to longer descriptions (used by lnurl-pay)
  expiry: 6,
  // default: 3600 (1 hour)
  min_final_cltv_expiry: 24,
  // default: 9
  fallback_address: 9,
  route_hint: 3,
  // for extra routing info (private etc.)
  feature_bits: 5,
  metadata: 27
};
for (let cr = 0, ar = Object.keys(TAGCODES); cr < ar.length; cr++)
  ar[cr], TAGCODES[ar[cr]].toString();
var NDKRelayConnectivity = class {
  constructor(cr) {
    ti(this, "ndkRelay");
    ti(this, "_status");
    ti(this, "relay");
    ti(this, "connectedAt");
    ti(this, "_connectionStats", {
      attempts: 0,
      success: 0,
      durations: []
    });
    ti(this, "debug");
    /**
     * Utility functions to update the connection stats.
     */
    ti(this, "updateConnectionStats", {
      connected: () => {
        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();
      },
      disconnected: () => {
        this._connectionStats.connectedAt && (this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;
      },
      attempt: () => {
        this._connectionStats.attempts++;
      }
    });
    this.ndkRelay = cr, this._status = 3, this.relay = relayInit(this.ndkRelay.url), this.debug = this.ndkRelay.debug.extend("connectivity"), this.relay.on("notice", (ar) => this.handleNotice(ar));
  }
  async connect() {
    const cr = () => {
      this.updateConnectionStats.connected(), this._status = 1, this.ndkRelay.emit("connect");
    }, ar = () => {
      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.ndkRelay.emit("disconnect");
    };
    try {
      this.updateConnectionStats.attempt(), this._status = 0, this.relay.off("connect", cr), this.relay.off("disconnect", ar), this.relay.on("connect", cr), this.relay.on("disconnect", ar), await this.relay.connect();
    } catch (lr) {
      throw this.debug("Failed to connect", lr), this._status = 3, lr;
    }
  }
  disconnect() {
    this._status = 2, this.relay.close();
  }
  get status() {
    return this._status;
  }
  isAvailable() {
    return this._status === 1;
  }
  /**
   * Evaluates the connection stats to determine if the relay is flapping.
   */
  isFlapping() {
    const cr = this._connectionStats.durations;
    if (cr.length % 3 !== 0)
      return !1;
    const lr = cr.reduce((gr, mr) => gr + mr, 0) / cr.length, ur = cr.map((gr) => Math.pow(gr - lr, 2)).reduce((gr, mr) => gr + mr, 0) / cr.length;
    return Math.sqrt(ur) < 1e3;
  }
  async handleNotice(cr) {
    (cr.includes("oo many") || cr.includes("aximum")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, "Relay complaining?", cr)), this.ndkRelay.emit("notice", this, cr);
  }
  /**
   * Called when the relay is unexpectedly disconnected.
   */
  handleReconnection(cr = 0) {
    if (this.isFlapping()) {
      this.ndkRelay.emit("flapping", this, this._connectionStats), this._status = 5;
      return;
    }
    const ar = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 0;
    setTimeout(() => {
      this._status = 4, this.connect().then(() => {
        this.debug("Reconnected");
      }).catch((lr) => {
        this.debug("Reconnect failed", lr), cr < 5 ? setTimeout(() => {
          this.handleReconnection(cr + 1);
        }, 6e4) : this.debug("Reconnect failed after 5 attempts");
      });
    }, ar);
  }
  /**
   * Returns the connection stats.
   */
  get connectionStats() {
    return this._connectionStats;
  }
}, NDKRelayPublisher = class {
  constructor(cr) {
    ti(this, "ndkRelay");
    this.ndkRelay = cr;
  }
  /**
   * Published an event to the relay; if the relay is not connected, it will
   * wait for the relay to connect before publishing the event.
   *
   * If the relay does not connect within the timeout, the publish operation
   * will fail.
   * @param event  The event to publish
   * @param timeoutMs  The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(cr, ar = 2500) {
    const lr = () => new Promise((mr, vr) => {
      try {
        this.publishEvent(cr, ar).then((yr) => mr(yr)).catch((yr) => vr(yr));
      } catch (yr) {
        vr(yr);
      }
    }), ur = new Promise((mr, vr) => {
      setTimeout(() => vr(new Error("Timeout")), ar);
    }), dr = () => {
      lr().then((mr) => fr(mr)).catch((mr) => gr(mr));
    };
    let fr, gr;
    return this.ndkRelay.status === 1 ? Promise.race([lr(), ur]) : Promise.race([
      new Promise((mr, vr) => {
        fr = mr, gr = vr, this.ndkRelay.once("connect", dr);
      }),
      ur
    ]).finally(() => {
      this.ndkRelay.removeListener("connect", dr);
    });
  }
  async publishEvent(cr, ar) {
    const lr = await cr.toNostrEvent(), ur = this.ndkRelay.connectivity.relay.publish(lr);
    let dr;
    const fr = new Promise((mr, vr) => {
      ur.then(() => {
        clearTimeout(dr), this.ndkRelay.emit("published", cr), mr(!0);
      }).catch((yr) => {
        clearTimeout(dr), this.ndkRelay.debug("Publish failed", yr, cr.id), this.ndkRelay.emit("publish:failed", cr, yr), vr(yr);
      });
    });
    if (!ar || cr.isEphemeral())
      return fr;
    const gr = new Promise((mr, vr) => {
      dr = setTimeout(() => {
        this.ndkRelay.debug("Publish timed out", cr.rawEvent()), this.ndkRelay.emit("publish:failed", cr, "Timeout"), vr(new Error("Publish operation timed out"));
      }, ar);
    });
    return Promise.race([fr, gr]);
  }
};
function calculateGroupableId(cr) {
  const ar = [];
  for (const lr of cr) {
    if (lr.since || lr.until)
      return null;
    const dr = Object.keys(lr || {}).sort().join("-");
    ar.push(dr);
  }
  return ar.join("|");
}
function mergeFilters(cr) {
  const ar = {};
  return cr.forEach((lr) => {
    Object.entries(lr).forEach(([ur, dr]) => {
      Array.isArray(dr) ? ar[ur] === void 0 ? ar[ur] = [...dr] : ar[ur] = Array.from(/* @__PURE__ */ new Set([...ar[ur], ...dr])) : ar[ur] = dr;
    });
  }), ar;
}
var MAX_SUBID_LENGTH = 20;
function queryFullyFilled(cr) {
  return !!(filterIncludesIds(cr.filter) && resultHasAllRequestedIds(cr));
}
function compareFilter(cr, ar) {
  if (Object.keys(cr).length !== Object.keys(ar).length)
    return !1;
  for (const [lr, ur] of Object.entries(cr)) {
    const dr = ar[lr];
    if (!dr)
      return !1;
    if (Array.isArray(ur) && Array.isArray(dr)) {
      const fr = ur;
      for (const gr of dr) {
        const mr = gr;
        if (!fr.includes(mr))
          return !1;
      }
    } else if (dr !== ur)
      return !1;
  }
  return !0;
}
function filterIncludesIds(cr) {
  return !!cr.ids;
}
function resultHasAllRequestedIds(cr) {
  const ar = cr.filter.ids;
  return !!ar && ar.length === cr.eventFirstSeen.size;
}
function generateSubId(cr, ar) {
  var mr;
  const lr = cr.map((vr) => vr.subId).filter(Boolean), ur = [], dr = /* @__PURE__ */ new Set(), fr = /* @__PURE__ */ new Set();
  if (lr.length > 0)
    ur.push(Array.from(new Set(lr)).join(","));
  else {
    for (const vr of ar)
      for (const yr of Object.keys(vr))
        yr === "kinds" ? (mr = vr.kinds) == null || mr.forEach((_r) => fr.add(_r)) : dr.add(yr);
    fr.size > 0 && ur.push("kinds:" + Array.from(fr).join(",")), dr.size > 0 && ur.push(Array.from(dr).join(","));
  }
  let gr = ur.join("-");
  return gr.length > MAX_SUBID_LENGTH && (gr = gr.substring(0, MAX_SUBID_LENGTH)), lr.length !== 1 && (gr += "-" + Math.floor(Math.random() * 999).toString()), gr;
}
function filterFromId(cr) {
  let ar;
  if (cr.match(NIP33_A_REGEX)) {
    const [lr, ur, dr] = cr.split(":"), fr = {
      authors: [ur],
      kinds: [parseInt(lr)]
    };
    return dr && (fr["#d"] = [dr]), fr;
  }
  try {
    switch (ar = nip19_exports$2.decode(cr), ar.type) {
      case "nevent":
        return { ids: [ar.data.id] };
      case "note":
        return { ids: [ar.data] };
      case "naddr":
        return {
          authors: [ar.data.pubkey],
          "#d": [ar.data.identifier],
          kinds: [ar.data.kind]
        };
    }
  } catch (lr) {
  }
  return { ids: [cr] };
}
function isNip33AValue(cr) {
  return cr.match(NIP33_A_REGEX) !== null;
}
var NIP33_A_REGEX = /^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/;
function relaysFromBech32(cr) {
  try {
    const ar = nip19_exports$2.decode(cr);
    if (["naddr", "nevent"].includes(ar == null ? void 0 : ar.type)) {
      const lr = ar.data;
      if (lr != null && lr.relays)
        return lr.relays.map((ur) => new NDKRelay(ur));
    }
  } catch (ar) {
  }
  return [];
}
var NDKGroupedSubscriptions = class extends lib$2.EventEmitter {
  constructor(ar, lr) {
    super();
    ti(this, "subscriptions");
    ti(this, "req");
    ti(this, "debug");
    this.subscriptions = ar, this.debug = lr || this.subscriptions[0].subscription.debug.extend("grouped");
    for (const ur of ar)
      this.handleSubscriptionClosure(ur);
  }
  /**
   * Adds a subscription to this group.
   * @param subscription
   */
  addSubscription(ar) {
    this.subscriptions.push(ar), this.handleSubscriptionClosure(ar);
  }
  eventReceived(ar) {
    for (const lr of this.subscriptions)
      lr.eventReceived(ar);
  }
  eoseReceived(ar) {
    Array.from(this.subscriptions).forEach(async (ur) => {
      ur.subscription.eoseReceived(ar);
    });
  }
  handleSubscriptionClosure(ar) {
    ar.subscription.on("close", () => {
      const lr = this.subscriptions.findIndex(
        (ur) => ur.subscription === ar.subscription
      );
      this.subscriptions.splice(lr, 1), this.subscriptions.length <= 0 && this.emit("close");
    });
  }
  /**
   * Maps each subscription through a transformation function.
   * @param fn - The transformation function.
   * @returns A new array with each subscription transformed by fn.
   */
  map(ar) {
    return this.subscriptions.map(ar);
  }
  [Symbol.iterator]() {
    let ar = 0;
    const lr = this.subscriptions;
    return {
      next() {
        return ar < lr.length ? { value: lr[ar++], done: !1 } : { value: null, done: !0 };
      }
    };
  }
}, NDKSubscriptionFilters = class {
  constructor(cr, ar, lr) {
    ti(this, "subscription");
    ti(this, "filters", []);
    ti(this, "ndkRelay");
    this.subscription = cr, this.filters = ar, this.ndkRelay = lr;
  }
  eventReceived(cr) {
    this.eventMatchesLocalFilter(cr) && this.subscription.eventReceived(cr, this.ndkRelay, !1);
  }
  eventMatchesLocalFilter(cr) {
    const ar = cr.rawEvent();
    return this.filters.some((lr) => matchFilter$1(lr, ar));
  }
};
function findMatchingActiveSubscriptions(cr, ar) {
  if (cr.length !== ar.length)
    return !1;
  for (let lr = 0; lr < cr.length && compareFilter(cr[lr], ar[lr]); lr++)
    return cr[lr];
}
var NDKRelaySubscriptions = class {
  constructor(cr) {
    ti(this, "ndkRelay");
    ti(this, "delayedItems", /* @__PURE__ */ new Map());
    ti(this, "delayedTimers", /* @__PURE__ */ new Map());
    /**
     * Active subscriptions this relay is connected to
     */
    ti(this, "activeSubscriptions", /* @__PURE__ */ new Map());
    ti(this, "activeSubscriptionsByGroupId", /* @__PURE__ */ new Map());
    ti(this, "debug");
    ti(this, "groupingDebug");
    ti(this, "conn");
    this.ndkRelay = cr, this.conn = cr.connectivity, this.debug = cr.debug.extend("subscriptions"), this.groupingDebug = cr.debug.extend("grouping");
  }
  /**
   * Creates or queues a subscription to the relay.
   */
  subscribe(cr, ar) {
    const lr = calculateGroupableId(ar), ur = new NDKSubscriptionFilters(
      cr,
      ar,
      this.ndkRelay
    );
    if (!lr || !cr.isGroupable()) {
      this.groupingDebug("No groupable ID for filters", ar), this.executeSubscriptions(
        lr,
        // hacky
        new NDKGroupedSubscriptions([ur]),
        ar
      );
      return;
    }
    const dr = this.activeSubscriptionsByGroupId.get(lr);
    if (dr && findMatchingActiveSubscriptions(
      dr.filters,
      ar
    )) {
      const vr = this.activeSubscriptions.get(dr.sub);
      vr == null || vr.addSubscription(
        new NDKSubscriptionFilters(cr, ar, this.ndkRelay)
      );
      return;
    }
    let fr = this.delayedItems.get(lr);
    fr ? fr.addSubscription(ur) : (fr = new NDKGroupedSubscriptions([ur]), this.delayedItems.set(lr, fr), fr.once("close", () => {
      this.delayedItems.get(lr) && this.delayedItems.delete(lr);
    }));
    const gr = setTimeout(() => {
      this.executeGroup(lr, cr);
    }, cr.opts.groupableDelay);
    this.delayedTimers.has(lr) ? this.delayedTimers.get(lr).push(gr) : this.delayedTimers.set(lr, [gr]);
  }
  /**
   * Executes a delayed subscription via its groupable ID.
   * @param groupableId
   */
  executeGroup(cr, ar) {
    const lr = this.delayedItems.get(cr);
    this.delayedItems.delete(cr);
    const ur = this.delayedTimers.get(cr);
    if (this.delayedTimers.delete(cr), ur)
      for (const dr of ur)
        clearTimeout(dr);
    if (lr) {
      const dr = lr.subscriptions[0].filters.length, fr = [];
      for (let gr = 0; gr < dr; gr++) {
        const mr = lr.map((vr) => vr.filters[gr]);
        fr.push(mergeFilters(mr));
      }
      this.executeSubscriptions(cr, lr, fr);
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * If the relay is not connected, subscriptions will be queued
   * until the relay connects.
   *
   * @param groupableId
   * @param subscriptionFilters
   * @param mergedFilters
   */
  executeSubscriptions(cr, ar, lr) {
    if (this.conn.isAvailable())
      this.executeSubscriptionsConnected(cr, ar, lr);
    else {
      const ur = () => {
        this.debug("new relay coming online for active subscription", {
          relay: this.ndkRelay.url,
          mergeFilters
        }), this.executeSubscriptionsConnected(
          cr,
          ar,
          lr
        );
      };
      this.ndkRelay.once("connect", ur), ar.once("close", () => {
        this.ndkRelay.removeListener("connect", ur);
      });
    }
  }
  /**
   * Executes one or more subscriptions.
   *
   * When there are more than one subscription, results
   * will be sent to the right subscription
   *
   * @param subscriptions
   * @param filters The filters as they should be sent to the relay
   */
  executeSubscriptionsConnected(cr, ar, lr) {
    const ur = [];
    for (const { subscription: gr } of ar)
      ur.push(gr);
    const dr = generateSubId(ur, lr);
    ar.req = lr;
    const fr = this.conn.relay.sub(lr, { id: dr });
    return this.activeSubscriptions.set(fr, ar), cr && this.activeSubscriptionsByGroupId.set(cr, { filters: lr, sub: fr }), fr.on("event", (gr) => {
      const mr = new NDKEvent(void 0, gr);
      mr.relay = this.ndkRelay;
      const vr = this.activeSubscriptions.get(fr);
      vr == null || vr.eventReceived(mr);
    }), fr.on("eose", () => {
      const gr = this.activeSubscriptions.get(fr);
      gr == null || gr.eoseReceived(this.ndkRelay);
    }), ar.once("close", () => {
      fr.unsub(), this.activeSubscriptions.delete(fr), cr && this.activeSubscriptionsByGroupId.delete(cr);
    }), fr;
  }
  executedFilters() {
    const cr = /* @__PURE__ */ new Map();
    for (const [, ar] of this.activeSubscriptions)
      cr.set(
        ar.req,
        ar.map((lr) => lr.subscription)
      );
    return cr;
  }
}, NDKRelay = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    ti(this, "url");
    ti(this, "scores");
    ti(this, "connectivity");
    ti(this, "subs");
    ti(this, "publisher");
    ti(this, "complaining", !1);
    ti(this, "debug");
    this.url = ar, this.scores = /* @__PURE__ */ new Map(), this.debug = _debug(`ndk:relay:${ar}`), this.connectivity = new NDKRelayConnectivity(this), this.subs = new NDKRelaySubscriptions(this), this.publisher = new NDKRelayPublisher(this);
  }
  get status() {
    return this.connectivity.status;
  }
  get connectionStats() {
    return this.connectivity.connectionStats;
  }
  /**
   * Connects to the relay.
   */
  async connect() {
    return this.connectivity.connect();
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    this.connectivity.disconnect();
  }
  /**
   * Queues or executes the subscription of a specific set of filters
   * within this relay.
   *
   * @param subscription NDKSubscription this filters belong to.
   * @param filters Filters to execute
   */
  subscribe(ar, lr) {
    this.subs.subscribe(ar, lr);
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(ar, lr = 2500) {
    return this.publisher.publish(ar, lr);
  }
  /**
   * Called when this relay has responded with an event but
   * wasn't the fastest one.
   * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  scoreSlowerEvent(ar) {
  }
  /** @deprecated Use referenceTags instead. */
  tagReference(ar) {
    const lr = ["r", this.url];
    return ar && lr.push(ar), lr;
  }
  referenceTags() {
    return [["r", this.url]];
  }
  activeSubscriptions() {
    return this.subs.executedFilters();
  }
}, NDKRelaySet = class {
  constructor(cr, ar) {
    ti(this, "relays");
    ti(this, "debug");
    ti(this, "ndk");
    this.relays = cr, this.ndk = ar, this.debug = ar.debug.extend("relayset");
  }
  /**
   * Adds a relay to this set.
   */
  addRelay(cr) {
    this.relays.add(cr);
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * If no connection to the relay is found in the pool it will temporarily
   * connect to it.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @returns NDKRelaySet
   */
  static fromRelayUrls(cr, ar) {
    const lr = /* @__PURE__ */ new Set();
    for (const ur of cr) {
      const dr = ar.pool.relays.get(ur);
      if (dr)
        lr.add(dr);
      else {
        const fr = new NDKRelay(ur);
        ar.pool.useTemporaryRelay(fr), lr.add(fr);
      }
    }
    return new NDKRelaySet(new Set(lr), ar);
  }
  /**
   * Publish an event to all relays in this set. Returns the number of relays that have received the event.
   * @param event
   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
   * @returns A set where the event was successfully published to
   */
  async publish(cr, ar) {
    const lr = /* @__PURE__ */ new Set(), ur = cr.isEphemeral(), dr = Array.from(this.relays).map((fr) => new Promise((gr) => {
      fr.publish(cr, ar).then(() => {
        lr.add(fr), gr();
      }).catch((mr) => {
        ur || this.debug("error publishing to relay", {
          relay: fr.url,
          err: mr
        }), gr();
      });
    }));
    if (await Promise.all(dr), lr.size === 0 && !ur)
      throw new Error("No relay was able to receive the event");
    return lr;
  }
  size() {
    return this.relays.size;
  }
};
function calculateRelaySetFromEvent(cr, ar) {
  var ur;
  const lr = /* @__PURE__ */ new Set();
  return (ur = cr.pool) == null || ur.relays.forEach((dr) => lr.add(dr)), new NDKRelaySet(lr, cr);
}
function getWriteRelaysFor(cr, ar) {
  var lr;
  if (cr.outboxTracker)
    return (lr = cr.outboxTracker.data.get(ar)) == null ? void 0 : lr.writeRelays;
}
function calculateRelaySetsFromFilter(cr, ar) {
  var dr, fr;
  const lr = /* @__PURE__ */ new Map(), ur = /* @__PURE__ */ new Set();
  if (ar.forEach((gr) => {
    gr.authors && gr.authors.forEach((mr) => ur.add(mr));
  }), ur.size > 0) {
    const gr = /* @__PURE__ */ new Map();
    for (const mr of ur) {
      const vr = getWriteRelaysFor(cr, mr);
      vr && vr.size > 0 ? (cr.debug(`Adding ${vr.size} relays for ${mr}`), vr.forEach((yr) => {
        const _r = gr.get(yr) || [];
        _r.push(mr), gr.set(yr, _r);
      })) : (dr = cr.explicitRelayUrls) == null || dr.forEach((yr) => {
        const _r = gr.get(yr) || [];
        _r.push(mr), gr.set(yr, _r);
      });
    }
    for (const mr of gr.keys())
      lr.set(mr, []);
    for (const mr of ar)
      if (mr.authors)
        for (const [vr, yr] of gr.entries())
          lr.set(vr, [...lr.get(vr), { ...mr, authors: yr }]);
      else
        for (const vr of gr.keys())
          lr.set(vr, [...lr.get(vr), mr]);
  } else
    (fr = cr.explicitRelayUrls) == null || fr.forEach((gr) => {
      lr.set(gr, ar);
    });
  return lr;
}
function calculateRelaySetsFromFilters(cr, ar) {
  return calculateRelaySetsFromFilter(cr, ar);
}
var DEFAULT_RELAYS = [
  "wss://nos.lol",
  "wss://relay.nostr.band",
  "wss://relay.f7z.io",
  "wss://relay.damus.io",
  "wss://nostr.mom",
  "wss://no.str.cr"
], Zap$1 = class extends lib$2.EventEmitter {
  constructor(lr) {
    var ur;
    super();
    ti(this, "ndk");
    ti(this, "zappedEvent");
    ti(this, "zappedUser");
    this.ndk = lr.ndk, this.zappedEvent = lr.zappedEvent, this.zappedUser = lr.zappedUser || this.ndk.getUser({ hexpubkey: (ur = this.zappedEvent) == null ? void 0 : ur.pubkey });
  }
  async getZapEndpoint() {
    let lr, ur, dr, fr;
    if (this.zappedUser && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), lr = (this.zappedUser.profile || {}).lud06, ur = (this.zappedUser.profile || {}).lud16), ur && !ur.startsWith("LNURL")) {
      const [vr, yr] = ur.split("@");
      dr = `https://${yr}/.well-known/lnurlp/${vr}`;
    } else if (lr) {
      const { words: vr } = bech32$3.decode(lr, 1e3), yr = bech32$3.fromWords(vr);
      dr = new TextDecoder("utf-8").decode(yr);
    }
    if (!dr)
      throw new Error("No zap endpoint found");
    const mr = await (await fetch(dr)).json();
    return mr != null && mr.allowsNostr && (mr != null && mr.nostrPubkey || mr != null && mr.nostrPubKey) && (fr = mr.callback), fr;
  }
  /**
   * Generates a kind:9734 zap request and returns the payment request
   * @param amount amount to zap in millisatoshis
   * @param comment optional comment to include in the zap request
   * @param extraTags optional extra tags to include in the zap request
   * @param relays optional relays to ask zapper to publish the zap to
   * @returns the payment request
   */
  async createZapRequest(lr, ur, dr, fr, gr) {
    const mr = await this.generateZapRequest(lr, ur, dr, fr);
    if (!mr)
      return null;
    const { event: vr, zapEndpoint: yr } = mr;
    if (!vr)
      throw new Error("No zap request event found");
    return await vr.sign(gr), await this.getInvoice(vr, lr, yr);
  }
  async getInvoice(lr, ur, dr) {
    return (await (await fetch(
      `${dr}?` + new URLSearchParams({
        amount: ur.toString(),
        nostr: JSON.stringify(lr.rawEvent())
      })
    )).json()).pr;
  }
  async generateZapRequest(lr, ur, dr, fr, gr) {
    const mr = await this.getZapEndpoint();
    if (!mr)
      throw new Error("No zap endpoint found");
    if (!this.zappedEvent && !this.zappedUser)
      throw new Error("No zapped event or user found");
    const vr = nip57_exports$2.makeZapRequest({
      profile: this.zappedUser.pubkey,
      // set the event to null since nostr-tools doesn't support nip-33 zaps
      event: null,
      amount: lr,
      comment: ur || "",
      relays: fr != null ? fr : this.relays()
    });
    if (this.zappedEvent) {
      const _r = this.zappedEvent.referenceTags();
      vr.tags.push(..._r);
    }
    vr.tags.push(["lnurl", mr]);
    const yr = new NDKEvent(this.ndk, vr);
    return dr && (yr.tags = yr.tags.concat(dr)), { event: yr, zapEndpoint: mr };
  }
  /**
   * @returns the relays to use for the zap request
   */
  relays() {
    var ur, dr;
    let lr = [];
    return (dr = (ur = this.ndk) == null ? void 0 : ur.pool) != null && dr.relays && (lr = this.ndk.pool.urls()), lr.length || (lr = DEFAULT_RELAYS), lr;
  }
};
function mergeTags(cr, ar) {
  const lr = /* @__PURE__ */ new Map(), ur = (gr) => gr.join(","), dr = (gr, mr) => gr.every((vr, yr) => vr === mr[yr]), fr = (gr) => {
    for (let [mr, vr] of lr)
      if (dr(vr, gr) || dr(gr, vr)) {
        gr.length >= vr.length && lr.set(mr, gr);
        return;
      }
    lr.set(ur(gr), gr);
  };
  return cr.concat(ar).forEach(fr), Array.from(lr.values());
}
async function generateContentTags(cr, ar = []) {
  const lr = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g, ur = /#(\w+)/g;
  let dr = [];
  const fr = (gr) => {
    ar.find((mr) => mr[0] === gr[0] && mr[1] === gr[1]) || ar.push(gr);
  };
  return cr = cr.replace(lr, (gr) => {
    try {
      const mr = gr.split(/(@|nostr:)/)[2], { type: vr, data: yr } = nip19_exports$2.decode(mr);
      let _r;
      switch (vr) {
        case "npub":
          _r = ["p", yr];
          break;
        case "nprofile":
          _r = ["p", yr.pubkey];
          break;
        case "note":
          dr.push(
            new Promise(async (kr) => {
              fr([
                "e",
                yr,
                await maybeGetEventRelayUrl(mr),
                "mention"
              ]), kr();
            })
          );
          break;
        case "nevent":
          dr.push(
            new Promise(async (kr) => {
              let { id: xr, relays: Ar, author: Er } = yr;
              (!Ar || Ar.length === 0) && (Ar = [await maybeGetEventRelayUrl(mr)]), fr(["e", xr, Ar[0], "mention"]), Er && fr(["p", Er]), kr();
            })
          );
          break;
        case "naddr":
          dr.push(
            new Promise(async (kr) => {
              var Er;
              const xr = [yr.kind, yr.pubkey, yr.identifier].join(":");
              let Ar = (Er = yr.relays) != null ? Er : [];
              Ar.length === 0 && (Ar = [await maybeGetEventRelayUrl(mr)]), fr(["a", xr, Ar[0], "mention"]), fr(["p", yr.pubkey]), kr();
            })
          );
          break;
        default:
          return gr;
      }
      return _r && fr(_r), `nostr:${mr}`;
    } catch (mr) {
      return gr;
    }
  }), await Promise.all(dr), cr = cr.replace(ur, (gr, mr) => {
    const vr = ["t", mr];
    return ar.find((yr) => yr[0] === vr[0] && yr[1] === vr[1]) || ar.push(vr), gr;
  }), { content: cr, tags: ar };
}
async function maybeGetEventRelayUrl(cr) {
  return "";
}
function isReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 1e4 && this.kind < 2e4;
}
function isEphemeral() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 2e4 && this.kind < 3e4;
}
function isParamReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}
var NDKKind = /* @__PURE__ */ ((cr) => (cr[cr.Metadata = 0] = "Metadata", cr[cr.Text = 1] = "Text", cr[cr.RecommendRelay = 2] = "RecommendRelay", cr[cr.Contacts = 3] = "Contacts", cr[cr.EncryptedDirectMessage = 4] = "EncryptedDirectMessage", cr[cr.EventDeletion = 5] = "EventDeletion", cr[cr.Repost = 6] = "Repost", cr[cr.Reaction = 7] = "Reaction", cr[cr.BadgeAward = 8] = "BadgeAward", cr[cr.GroupChat = 9] = "GroupChat", cr[cr.GroupNote = 11] = "GroupNote", cr[cr.GenericRepost = 16] = "GenericRepost", cr[cr.ChannelCreation = 40] = "ChannelCreation", cr[cr.ChannelMetadata = 41] = "ChannelMetadata", cr[cr.ChannelMessage = 42] = "ChannelMessage", cr[cr.ChannelHideMessage = 43] = "ChannelHideMessage", cr[cr.ChannelMuteUser = 44] = "ChannelMuteUser", cr[cr.Report = 1984] = "Report", cr[cr.Label = 1985] = "Label", cr[cr.DVMReqTextExtraction = 5e3] = "DVMReqTextExtraction", cr[cr.DVMReqTextSummarization = 5001] = "DVMReqTextSummarization", cr[cr.DVMReqTextTranslation = 5002] = "DVMReqTextTranslation", cr[cr.DVMReqTextGeneration = 5050] = "DVMReqTextGeneration", cr[cr.DVMReqImageGeneration = 5100] = "DVMReqImageGeneration", cr[cr.DVMReqDiscoveryNostrContent = 5300] = "DVMReqDiscoveryNostrContent", cr[cr.DVMReqDiscoveryNostrPeople = 5301] = "DVMReqDiscoveryNostrPeople", cr[cr.DVMReqTimestamping = 5900] = "DVMReqTimestamping", cr[cr.DVMJobFeedback = 7e3] = "DVMJobFeedback", cr[cr.MuteList = 1e4] = "MuteList", cr[cr.PinList = 10001] = "PinList", cr[cr.RelayList = 10002] = "RelayList", cr[cr.BookmarkList = 10003] = "BookmarkList", cr[cr.CommunityList = 10004] = "CommunityList", cr[cr.PublicChatList = 10005] = "PublicChatList", cr[cr.BlockRelayList = 10006] = "BlockRelayList", cr[cr.SearchRelayList = 10007] = "SearchRelayList", cr[cr.InterestList = 10015] = "InterestList", cr[cr.EmojiList = 10030] = "EmojiList", cr[cr.FollowSet = 3e4] = "FollowSet", cr[
  cr.CategorizedPeopleList = 3e4
  /* FollowSet */
] = "CategorizedPeopleList", cr[cr.CategorizedBookmarkList = 30001] = "CategorizedBookmarkList", cr[cr.RelaySet = 30002] = "RelaySet", cr[
  cr.CategorizedRelayList = 30002
  /* RelaySet */
] = "CategorizedRelayList", cr[cr.BookmarkSet = 30003] = "BookmarkSet", cr[cr.CurationSet = 30004] = "CurationSet", cr[cr.InterestSet = 30015] = "InterestSet", cr[
  cr.InterestsList = 30015
  /* InterestSet */
] = "InterestsList", cr[cr.EmojiSet = 30030] = "EmojiSet", cr[cr.HighlightSet = 39802] = "HighlightSet", cr[
  cr.CategorizedHighlightList = 39802
  /* HighlightSet */
] = "CategorizedHighlightList", cr[cr.ZapRequest = 9734] = "ZapRequest", cr[cr.Zap = 9735] = "Zap", cr[cr.Highlight = 9802] = "Highlight", cr[cr.ClientAuth = 22242] = "ClientAuth", cr[cr.NostrConnect = 24133] = "NostrConnect", cr[cr.ProfileBadge = 30008] = "ProfileBadge", cr[cr.BadgeDefinition = 30009] = "BadgeDefinition", cr[cr.MarketStall = 30017] = "MarketStall", cr[cr.MarketProduct = 30018] = "MarketProduct", cr[cr.Article = 30023] = "Article", cr[cr.AppSpecificData = 30078] = "AppSpecificData", cr[cr.Classified = 30402] = "Classified", cr[cr.AppRecommendation = 31989] = "AppRecommendation", cr[cr.AppHandler = 31990] = "AppHandler", cr))(NDKKind || {});
async function encrypt$2(cr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  if (ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), !cr) {
    const lr = this.getMatchingTags("p");
    if (lr.length !== 1)
      throw new Error(
        "No recipient could be determined and no explicit recipient was provided"
      );
    cr = this.ndk.getUser({ hexpubkey: lr[0][1] });
  }
  this.content = await (ar == null ? void 0 : ar.encrypt(cr, this.content));
}
async function decrypt$2(cr, ar) {
  if (!this.ndk)
    throw new Error("No NDK instance found!");
  ar || (await this.ndk.assertSigner(), ar = this.ndk.signer), cr || (cr = this.author), this.content = await (ar == null ? void 0 : ar.decrypt(cr, this.content));
}
function encode$2() {
  return this.isParamReplaceable() ? nip19_exports$2.naddrEncode({
    kind: this.kind,
    pubkey: this.pubkey,
    identifier: this.replaceableDTag(),
    relays: this.relay ? [this.relay.url] : []
  }) : this.relay ? nip19_exports$2.neventEncode({
    id: this.tagId(),
    relays: [this.relay.url],
    author: this.pubkey
  }) : nip19_exports$2.noteEncode(this.tagId());
}
async function repost(cr = !0, ar) {
  if (!ar && cr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner(), ar = this.ndk.signer;
  }
  const lr = new NDKEvent(this.ndk, {
    kind: getKind(this),
    content: ""
  });
  return lr.tag(this), lr.kind === 16 && lr.tags.push(["k", `${this.kind}`]), ar && await lr.sign(ar), cr && await lr.publish(), lr;
}
function getKind(cr) {
  return cr.kind === 1 ? 6 : 16;
}
var NDKEvent = class extends lib$2.EventEmitter {
  constructor(ar, lr) {
    super();
    ti(this, "ndk");
    ti(this, "created_at");
    ti(this, "content", "");
    ti(this, "tags", []);
    ti(this, "kind");
    ti(this, "id", "");
    ti(this, "sig");
    ti(this, "pubkey", "");
    ti(this, "_author");
    /**
     * The relay that this event was first received from.
     */
    ti(this, "relay");
    ti(this, "isReplaceable", isReplaceable.bind(this));
    ti(this, "isEphemeral", isEphemeral.bind(this));
    ti(this, "isParamReplaceable", isParamReplaceable.bind(this));
    /**
     * Encodes a bech32 id.
     *
     * @returns {string} - Encoded naddr, note or nevent.
     */
    ti(this, "encode", encode$2.bind(this));
    ti(this, "encrypt", encrypt$2.bind(this));
    ti(this, "decrypt", decrypt$2.bind(this));
    /**
     * NIP-18 reposting event.
     *
     * @param publish Whether to publish the reposted event automatically
     * @param signer The signer to use for signing the reposted event
     * @returns The reposted event
     *
     * @function
     */
    ti(this, "repost", repost.bind(this));
    this.ndk = ar, this.created_at = lr == null ? void 0 : lr.created_at, this.content = (lr == null ? void 0 : lr.content) || "", this.tags = (lr == null ? void 0 : lr.tags) || [], this.id = (lr == null ? void 0 : lr.id) || "", this.sig = lr == null ? void 0 : lr.sig, this.pubkey = (lr == null ? void 0 : lr.pubkey) || "", this.kind = lr == null ? void 0 : lr.kind;
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(ar) {
    this.pubkey = ar.hexpubkey, this._author = void 0;
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    if (this._author)
      return this._author;
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = this.ndk.getUser({ hexpubkey: this.pubkey });
    return this._author = ar, ar;
  }
  tag(ar, lr) {
    const ur = (ar == null ? void 0 : ar.pubkey) === this.pubkey, dr = ar.referenceTags(lr, ur);
    if (this.tags = mergeTags(this.tags, dr), ar instanceof NDKEvent)
      for (const fr of ar.getMatchingTags("p"))
        fr[1] !== this.pubkey && (this.tags.find((gr) => gr[0] === "p" && gr[1] === fr[1]) || this.tags.push(["p", fr[1]]));
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(ar) {
    var fr, gr;
    if (!ar && this.pubkey === "") {
      const mr = await ((gr = (fr = this.ndk) == null ? void 0 : fr.signer) == null ? void 0 : gr.user());
      this.pubkey = (mr == null ? void 0 : mr.hexpubkey) || "";
    }
    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));
    const lr = this.rawEvent(), { content: ur, tags: dr } = await this.generateTags();
    lr.content = ur || "", lr.tags = dr;
    try {
      this.id = getEventHash$2(lr);
    } catch (mr) {
    }
    return this.id && (lr.id = this.id), this.sig && (lr.sig = this.sig), lr;
  }
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(ar) {
    return this.tags.filter((lr) => lr[0] === ar);
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(ar) {
    const lr = this.getMatchingTags(ar);
    if (lr.length !== 0)
      return lr[0][1];
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name to search for and remove
   * @returns {void}
   */
  removeTag(ar) {
    this.tags = this.tags.filter((lr) => lr[0] !== ar);
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(ar) {
    var ur;
    ar ? this.author = await ar.user() : ((ur = this.ndk) == null || ur.assertSigner(), ar = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));
    const lr = await this.toNostrEvent();
    return this.sig = await ar.sign(lr), this.sig;
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(ar, lr) {
    if (this.sig || await this.sign(), !this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    return ar || (ar = this.ndk.devWriteRelaySet || calculateRelaySetFromEvent(this.ndk)), ar.publish(this, lr);
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  async generateTags() {
    var dr, fr, gr;
    let ar = [];
    const lr = await generateContentTags(this.content, this.tags), ur = lr.content;
    if (ar = lr.tags, this.kind && this.isParamReplaceable() && !this.getMatchingTags("d")[0]) {
      const vr = this.tagValue("title");
      let _r = [...Array(vr ? 6 : 16)].map(() => Math.random().toString(36)[2]).join("");
      vr && vr.length > 0 && (_r = vr.replace(/[^a-z0-9]+/gi, "-").replace(/^-|-$/g, "") + "-" + _r), ar.push(["d", _r]);
    }
    if (((dr = this.ndk) != null && dr.clientName || (fr = this.ndk) != null && fr.clientNip89) && !this.tagValue("client")) {
      const mr = ["client", (gr = this.ndk.clientName) != null ? gr : ""];
      this.ndk.clientNip89 && mr.push(this.ndk.clientNip89), ar.push(mr);
    }
    return { content: ur || "", tags: ar };
  }
  muted() {
    var dr, fr;
    const ar = (dr = this.ndk) == null ? void 0 : dr.mutedIds.get(this.pubkey);
    if (ar && ar === "p")
      return "author";
    const lr = this.tagReference(), ur = (fr = this.ndk) == null ? void 0 : fr.mutedIds.get(lr[1]);
    return ur && ur === lr[0] ? "event" : null;
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const ar = this.getMatchingTags("d")[0];
      return ar ? ar[1] : "";
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Provides a deduplication key for the event.
   *
   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
   * For all other kinds this will be the event id
   */
  deduplicationKey() {
    return this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4 ? `${this.kind}:${this.pubkey}` : this.tagId();
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    return this.isParamReplaceable() ? this.tagAddress() : this.id;
  }
  /**
   * Returns the "reference" value ("<kind>:<author-pubkey>:<d-tag>") for this replaceable event.
   * @returns {string} The id
   */
  tagAddress() {
    if (!this.isParamReplaceable())
      throw new Error("This must only be called on replaceable events");
    const ar = this.replaceableDTag();
    return `${this.kind}:${this.pubkey}:${ar}`;
  }
  /**
   * Get the tag that can be used to reference this event from another event.
   *
   * Consider using referenceTags() instead (unless you have a good reason to use this)
   *
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference(ar) {
    let lr;
    return this.isParamReplaceable() ? lr = ["a", this.tagAddress()] : lr = ["e", this.tagId()], this.relay ? lr.push(this.relay.url) : lr.push(""), ar && lr.push(ar), lr;
  }
  /**
   * Get the tags that can be used to reference this event from another event
   * @param marker The marker to use in the tag
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.referenceTags(); // [["e", "parent-id"]]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  referenceTags(ar, lr) {
    var dr;
    let ur = [];
    return this.isParamReplaceable() ? ur = [
      ["a", this.tagAddress()],
      ["e", this.id]
    ] : ur = [["e", this.id]], (dr = this.relay) != null && dr.url ? ur = ur.map((fr) => {
      var gr;
      return fr.push((gr = this.relay) == null ? void 0 : gr.url), fr;
    }) : ar && (ur = ur.map((fr) => (fr.push(""), fr))), ar && ur.forEach((fr) => fr.push(ar)), lr || ur.push(...this.author.referenceTags()), ur;
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    return this.isParamReplaceable() ? { "#a": [this.tagId()] } : { "#e": [this.tagId()] };
  }
  /**
   * Create a zap request for an existing event
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param recipient The zap recipient (optional for events)
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(ar, lr, ur, dr, fr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    fr || this.ndk.assertSigner();
    const gr = new Zap$1({
      ndk: this.ndk,
      zappedEvent: this,
      zappedUser: dr
    }), mr = Array.from(this.ndk.pool.relays.keys());
    return await gr.createZapRequest(
      ar,
      lr,
      ur,
      mr,
      fr
    );
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @returns The deletion event
   */
  async delete(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const lr = new NDKEvent(this.ndk, {
      kind: 5,
      content: ar || ""
    });
    return lr.tag(this), await lr.publish(), lr;
  }
  /**
   * React to an existing event
   *
   * @param content The content of the reaction
   */
  async react(ar) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const lr = new NDKEvent(this.ndk, {
      kind: 7,
      content: ar
    });
    return lr.tag(this), await lr.publish(), lr;
  }
}, READ_MARKER = "read", WRITE_MARKER = "write", NDKRelayList = class extends NDKEvent {
  constructor(cr, ar) {
    var lr;
    super(cr, ar), (lr = this.kind) != null || (this.kind = 10002);
  }
  static from(cr) {
    return new NDKRelayList(cr.ndk, cr.rawEvent());
  }
  get readRelayUrls() {
    return this.getMatchingTags("r").filter((cr) => !cr[2] || cr[2] && cr[2] === READ_MARKER).map((cr) => cr[1]);
  }
  set readRelayUrls(cr) {
    for (const ar of cr)
      this.tags.push(["r", ar, READ_MARKER]);
  }
  get writeRelayUrls() {
    return this.getMatchingTags("r").filter((cr) => !cr[2] || cr[2] && cr[2] === WRITE_MARKER).map((cr) => cr[1]);
  }
  set writeRelayUrls(cr) {
    for (const ar of cr)
      this.tags.push(["r", ar, WRITE_MARKER]);
  }
  get bothRelayUrls() {
    return this.getMatchingTags("r").filter((cr) => !cr[2]).map((cr) => cr[1]);
  }
  set bothRelayUrls(cr) {
    for (const ar of cr)
      this.tags.push(["r", ar]);
  }
  get relays() {
    return this.getMatchingTags("r").map((cr) => cr[1]);
  }
}, defaultOpts = {
  closeOnEose: !1,
  cacheUsage: "CACHE_FIRST",
  groupable: !0,
  groupableDelay: 100
}, NDKSubscription = class extends lib$2.EventEmitter {
  constructor(ar, lr, ur, dr, fr) {
    var gr;
    super();
    ti(this, "subId");
    ti(this, "filters");
    ti(this, "opts");
    ti(this, "pool");
    /**
     * Tracks the filters as they are executed on each relay
     */
    ti(this, "relayFilters");
    ti(this, "relaySet");
    ti(this, "ndk");
    ti(this, "debug");
    ti(this, "eoseDebug");
    /**
     * Events that have been seen by the subscription, with the time they were first seen.
     */
    ti(this, "eventFirstSeen", /* @__PURE__ */ new Map());
    /**
     * Relays that have sent an EOSE.
     */
    ti(this, "eosesSeen", /* @__PURE__ */ new Set());
    /**
     * Events that have been seen by the subscription per relay.
     */
    ti(this, "eventsPerRelay", /* @__PURE__ */ new Map());
    /**
     * The time the last event was received by the subscription.
     * This is used to calculate when EOSE should be emitted.
     */
    ti(this, "lastEventReceivedAt");
    ti(this, "internalId");
    // EOSE handling
    ti(this, "eoseTimeout");
    if (this.ndk = ar, this.pool = (ur == null ? void 0 : ur.pool) || ar.pool, this.opts = { ...defaultOpts, ...ur || {} }, this.filters = lr instanceof Array ? lr : [lr], this.subId = fr || (ur == null ? void 0 : ur.subId), this.internalId = Math.random().toString(36).substring(7), this.relaySet = dr, this.debug = ar.debug.extend(`subscription[${(gr = ur == null ? void 0 : ur.subId) != null ? gr : this.internalId}]`), this.eoseDebug = this.debug.extend("eose"), this.opts.closeOnEose || this.debug(
      "Creating a permanent subscription",
      this.opts,
      JSON.stringify(this.filters)
    ), this.opts.cacheUsage === "ONLY_CACHE" && !this.opts.closeOnEose)
      throw new Error("Cannot use cache-only options with a persistent subscription");
  }
  /**
   * Provides access to the first filter of the subscription for
   * backwards compatibility.
   */
  get filter() {
    return this.filters[0];
  }
  isGroupable() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.groupable) || !1;
  }
  shouldQueryCache() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_RELAY";
  }
  shouldQueryRelays() {
    var ar;
    return ((ar = this.opts) == null ? void 0 : ar.cacheUsage) !== "ONLY_CACHE";
  }
  shouldWaitForCache() {
    var ar;
    return (
      // Must want to close on EOSE; subscriptions
      // that want to receive further updates must
      // always hit the relay
      this.opts.closeOnEose && // Cache adapter must claim to be fast
      !!((ar = this.ndk.cacheAdapter) != null && ar.locking) && // If explicitly told to run in parallel, then
      // we should not wait for the cache
      this.opts.cacheUsage !== "PARALLEL"
    );
  }
  /**
   * Start the subscription. This is the main method that should be called
   * after creating a subscription.
   */
  async start() {
    let ar;
    if (this.shouldQueryCache() && (ar = this.startWithCache(), this.shouldWaitForCache() && (await ar, queryFullyFilled(this)))) {
      this.emit("eose", this);
      return;
    }
    this.shouldQueryRelays() ? this.startWithRelays() : this.emit("eose", this);
  }
  stop() {
    this.emit("close", this), this.removeAllListeners();
  }
  /**
   * @returns Whether the subscription has an authors filter.
   */
  hasAuthorsFilter() {
    return this.filters.some((ar) => {
      var lr;
      return (lr = ar.authors) == null ? void 0 : lr.length;
    });
  }
  async startWithCache() {
    var ar;
    if ((ar = this.ndk.cacheAdapter) != null && ar.query) {
      const lr = this.ndk.cacheAdapter.query(this);
      this.ndk.cacheAdapter.locking && await lr;
    }
  }
  /**
   * Send REQ to relays
   */
  startWithRelays() {
    if (!this.relaySet)
      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters);
    else {
      this.relayFilters = /* @__PURE__ */ new Map();
      for (const ar of this.relaySet.relays)
        this.relayFilters.set(ar.url, this.filters);
    }
    for (const [ar, lr] of this.relayFilters)
      this.pool.getRelay(ar).subscribe(this, lr);
  }
  // EVENT handling
  /**
   * Called when an event is received from a relay or the cache
   * @param event
   * @param relay
   * @param fromCache Whether the event was received from the cache
   */
  eventReceived(ar, lr, ur = !1) {
    if (lr && (ar.relay = lr), lr || (lr = ar.relay), !ur && lr) {
      let dr = this.eventsPerRelay.get(lr);
      if (dr || (dr = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(lr, dr)), dr.add(ar.id), this.eventFirstSeen.has(ar.id)) {
        const gr = Date.now() - (this.eventFirstSeen.get(ar.id) || 0);
        lr.scoreSlowerEvent(gr), this.emit("event:dup", ar, lr, gr, this);
        return;
      }
      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(ar, this.filters[0], lr), this.eventFirstSeen.set(ar.id, Date.now());
    } else
      this.eventFirstSeen.set(ar.id, 0);
    ar.ndk || (ar.ndk = this.ndk), this.emit("event", ar, lr, this), this.lastEventReceivedAt = Date.now();
  }
  eoseReceived(ar) {
    var fr, gr, mr;
    this.eosesSeen.add(ar), this.eoseDebug(`received from ${ar.url}`);
    let lr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;
    const ur = this.eosesSeen.size === ((fr = this.relayFilters) == null ? void 0 : fr.size);
    if (queryFullyFilled(this))
      this.emit("eose"), this.eoseDebug("Query fully filled"), (gr = this.opts) != null && gr.closeOnEose && this.stop();
    else if (ur)
      this.emit("eose"), this.eoseDebug("All EOSEs seen"), (mr = this.opts) != null && mr.closeOnEose && this.stop();
    else {
      let vr = 1e3;
      const yr = this.eosesSeen.size / this.relayFilters.size;
      if (this.eosesSeen.size >= 2 && yr >= 0.5) {
        vr = vr * (1 - yr), this.eoseTimeout && clearTimeout(this.eoseTimeout);
        const _r = () => {
          var kr;
          lr = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0, lr !== void 0 && lr < 20 ? this.eoseTimeout = setTimeout(_r, vr) : (this.emit("eose"), (kr = this.opts) != null && kr.closeOnEose && this.stop());
        };
        this.eoseTimeout = setTimeout(_r, vr);
      }
    }
  }
};
async function follows(cr, ar, lr = 3) {
  if (!this.ndk)
    throw new Error("NDK not set");
  const ur = Array.from(
    await this.ndk.fetchEvents(
      {
        kinds: [lr],
        authors: [this.pubkey]
      },
      cr || { groupable: !1 }
    )
  )[0];
  if (ur) {
    const dr = /* @__PURE__ */ new Set();
    return ur.tags.forEach((fr) => {
      var gr, mr;
      if (fr[0] === "p")
        try {
          dr.add(fr[1]), ar && ((mr = (gr = this.ndk) == null ? void 0 : gr.outboxTracker) == null || mr.trackUsers([fr[1]]));
        } catch (vr) {
        }
    }), [...dr].reduce((fr, gr) => {
      const mr = new NDKUser({ pubkey: gr });
      return mr.ndk = this.ndk, fr.add(mr), fr;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}
function profileFromEvent(cr) {
  const ar = {}, lr = JSON.parse(cr.content);
  return Object.keys(lr).forEach((ur) => {
    switch (ur) {
      case "name":
        ar.name = lr.name;
        break;
      case "display_name":
        ar.displayName = lr.display_name;
        break;
      case "image":
      case "picture":
        ar.image = lr.image || lr.picture;
        break;
      case "banner":
        ar.banner = lr.banner;
        break;
      case "bio":
        ar.bio = lr.bio;
        break;
      case "nip05":
        ar.nip05 = lr.nip05;
        break;
      case "lud06":
        ar.lud06 = lr.lud06;
        break;
      case "lud16":
        ar.lud16 = lr.lud16;
        break;
      case "about":
        ar.about = lr.about;
        break;
      case "zapService":
        ar.zapService = lr.zapService;
        break;
      case "website":
        ar.website = lr.website;
        break;
      default:
        ar[ur] = lr[ur];
        break;
    }
  }), ar;
}
function serializeProfile(cr) {
  const ar = {};
  for (const [lr, ur] of Object.entries(cr))
    switch (lr) {
      case "username":
      case "name":
        ar.name = ur;
        break;
      case "displayName":
        ar.display_name = ur;
        break;
      case "image":
      case "picture":
        ar.picture = ur;
        break;
      case "bio":
      case "about":
        ar.about = ur;
        break;
      default:
        ar[lr] = ur;
        break;
    }
  return JSON.stringify(ar);
}
var NDKList = class extends NDKEvent {
  constructor(ar, lr) {
    var ur;
    super(ar, lr);
    ti(this, "_encryptedTags");
    /**
     * Stores the number of bytes the content was before decryption
     * to expire the cache when the content changes.
     */
    ti(this, "encryptedTagsLength");
    (ur = this.kind) != null || (this.kind = 30001);
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ar) {
    return new NDKList(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns the title of the list. Falls back on fetching the name tag value.
   */
  get title() {
    const ar = this.tagValue("title") || this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the title of the list.
   */
  set title(ar) {
    if (this.removeTag("title"), this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Title cannot be empty");
  }
  /**
   * Returns the name of the list.
   * @deprecated Please use "title" instead.
   */
  get name() {
    const ar = this.tagValue("name");
    return this.kind === 3 && !ar ? "Contacts" : this.kind === 1e4 && !ar ? "Mute" : this.kind === 10001 && !ar ? "Pinned Notes" : this.kind === 10002 && !ar ? "Relay Metadata" : this.kind === 10003 && !ar ? "Bookmarks" : this.kind === 10004 && !ar ? "Communities" : this.kind === 10005 && !ar ? "Public Chats" : this.kind === 10006 && !ar ? "Blocked Relays" : this.kind === 10007 && !ar ? "Search Relays" : this.kind === 10015 && !ar ? "Interests" : this.kind === 10030 && !ar ? "Emojis" : ar != null ? ar : this.tagValue("d");
  }
  /**
   * Sets the name of the list.
   * @deprecated Please use "title" instead. This method will use the `title` tag instead.
   */
  set name(ar) {
    if (this.removeTag("name"), ar)
      this.tags.push(["title", ar]);
    else
      throw new Error("Name cannot be empty");
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(ar) {
    ar ? this.tags.push(["description", ar]) : this.removeTag("description");
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(ar = !0) {
    if (ar && this.isEncryptedTagsCacheValid())
      return this._encryptedTags;
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    const lr = await this.ndk.signer.user();
    try {
      if (this.content.length > 0)
        try {
          const ur = await this.ndk.signer.decrypt(lr, this.content), dr = JSON.parse(ur);
          return dr && dr[0] ? (this.encryptedTagsLength = this.content.length, this._encryptedTags = dr) : (this.encryptedTagsLength = this.content.length, this._encryptedTags = []);
        } catch (ur) {
          console.log(`error decrypting ${this.content}`);
        }
    } catch (ur) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(ar) {
    return !0;
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((ar) => ![
      "d",
      "L",
      "l",
      "title",
      "name",
      "description",
      "summary",
      "image",
      "thumb",
      "alt",
      "expiration",
      "subject"
    ].includes(ar[0]));
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   */
  async addItem(ar, lr = void 0, ur = !1) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    let dr;
    if (ar instanceof NDKEvent)
      dr = ar.referenceTags();
    else if (ar instanceof NDKUser)
      dr = ar.referenceTags();
    else if (ar instanceof NDKRelay)
      dr = ar.referenceTags();
    else if (Array.isArray(ar))
      dr = [ar];
    else
      throw new Error("Invalid object type");
    if (lr && dr[0].push(lr), ur) {
      const fr = await this.ndk.signer.user(), gr = await this.encryptedTags();
      gr.push(...dr), this._encryptedTags = gr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(gr), await this.encrypt(fr);
    } else
      this.tags.push(...dr);
    this.created_at = Math.floor(Date.now() / 1e3), this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(ar, lr) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    if (lr) {
      const ur = await this.ndk.signer.user(), dr = await this.encryptedTags();
      dr.splice(ar, 1), this._encryptedTags = dr, this.encryptedTagsLength = this.content.length, this.content = JSON.stringify(dr), await this.encrypt(ur);
    } else
      this.tags.splice(ar, 1);
    return this.created_at = Math.floor(Date.now() / 1e3), this.emit("change"), this;
  }
}, lists_default = NDKList;
async function pin(cr, ar, lr) {
  if (!this.ndk)
    throw new Error("No NDK instance found");
  if (this.ndk.assertSigner(), !ar) {
    const dr = await this.ndk.fetchEvents(
      { kinds: [10001], authors: [this.pubkey] },
      {
        cacheUsage: "ONLY_RELAY"
        /* ONLY_RELAY */
      }
    );
    dr.size > 0 ? ar = lists_default.from(Array.from(dr)[0]) : ar = new NDKEvent(this.ndk, {
      kind: 10001
    });
  }
  return ar.tag(cr), lr && await ar.publish(), ar;
}
var NDKUser = class {
  constructor(cr) {
    ti(this, "ndk");
    ti(this, "profile");
    ti(this, "_npub");
    ti(this, "_pubkey");
    ti(this, "relayUrls", []);
    /**
     * Returns a set of users that this user follows.
     */
    ti(this, "follows", follows.bind(this));
    /**
     * Pins a user or an event
     */
    ti(this, "pin", pin.bind(this));
    cr.npub && (this._npub = cr.npub), cr.hexpubkey && (this._pubkey = cr.hexpubkey), cr.pubkey && (this._pubkey = cr.pubkey), cr.relayUrls && (this.relayUrls = cr.relayUrls);
  }
  get npub() {
    if (!this._npub) {
      if (!this._pubkey)
        throw new Error("hexpubkey not set");
      this._npub = nip19_exports$2.npubEncode(this.pubkey);
    }
    return this._npub;
  }
  set npub(cr) {
    this._npub = cr;
  }
  /**
   * Get the user's hexpubkey
   * @returns {Hexpubkey} The user's hexpubkey
   *
   * @deprecated Use `pubkey` instead
   */
  get hexpubkey() {
    return this.pubkey;
  }
  /**
   * Set the user's hexpubkey
   * @param pubkey {Hexpubkey} The user's hexpubkey
   * @deprecated Use `pubkey` instead
   */
  set hexpubkey(cr) {
    this._pubkey = cr;
  }
  /**
   * Get the user's pubkey
   * @returns {string} The user's pubkey
   */
  get pubkey() {
    if (!this._pubkey) {
      if (!this._npub)
        throw new Error("npub not set");
      this._pubkey = nip19_exports$2.decode(this.npub).data;
    }
    return this._pubkey;
  }
  /**
   * Set the user's pubkey
   * @param pubkey {string} The user's pubkey
   */
  set pubkey(cr) {
    this._pubkey = cr;
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(cr) {
    const ar = await nip05_exports$2.queryProfile(cr);
    if (ar)
      return new NDKUser({
        pubkey: ar.pubkey,
        relayUrls: ar.relays
      });
  }
  /**
   * Fetch a user's profile
   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
   * @returns User Profile
   */
  async fetchProfile(cr) {
    if (!this.ndk)
      throw new Error("NDK not set");
    this.profile || (this.profile = {});
    let ar = null;
    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && (cr == null ? void 0 : cr.cacheUsage) !== "ONLY_RELAY") {
      const ur = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);
      if (ur)
        return this.profile = ur, ur;
    }
    !cr && // if no options have been set
    this.ndk.cacheAdapter && // and we have a cache
    this.ndk.cacheAdapter.locking && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      {
        cacheUsage: "ONLY_CACHE",
        closeOnEose: !0,
        groupable: !1
      }
    ), cr = {
      cacheUsage: "ONLY_RELAY",
      closeOnEose: !0,
      groupable: !0,
      groupableDelay: 250
    }), (!ar || ar.size === 0) && (ar = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.pubkey]
      },
      cr
    ));
    const lr = Array.from(ar).sort(
      (ur, dr) => ur.created_at - dr.created_at
    );
    return lr.length === 0 ? null : (this.profile = profileFromEvent(lr[0]), this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile && this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile), this.profile);
  }
  /**
   * Returns a set of relay list events for a user.
   * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.
   */
  async relayList() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const cr = this.ndk.outboxPool || this.ndk.pool, ar = /* @__PURE__ */ new Set();
    for (const dr of cr.relays.values())
      ar.add(dr);
    const lr = new NDKRelaySet(ar, this.ndk), ur = await this.ndk.fetchEvent(
      {
        kinds: [10002],
        authors: [this.pubkey]
      },
      {
        closeOnEose: !0,
        pool: cr,
        groupable: !0,
        subId: `relay-list-${this.pubkey.slice(0, 6)}`
      },
      lr
    );
    return ur ? NDKRelayList.from(ur) : await this.relayListFromKind3();
  }
  async relayListFromKind3() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const cr = await this.ndk.fetchEvent({
      kinds: [3],
      authors: [this.pubkey]
    });
    if (cr)
      try {
        const ar = JSON.parse(cr.content), lr = new NDKRelayList(this.ndk), ur = /* @__PURE__ */ new Set(), dr = /* @__PURE__ */ new Set();
        for (const [fr, gr] of Object.entries(ar))
          if (!gr)
            ur.add(fr), dr.add(fr);
          else {
            const mr = gr;
            mr.write && dr.add(fr), mr.read && ur.add(fr);
          }
        return lr.readRelayUrls = Array.from(ur), lr.writeRelayUrls = Array.from(dr), lr;
      } catch (ar) {
      }
  }
  /** @deprecated Use referenceTags instead. */
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.pubkey];
  }
  /**
   * Get the tags that can be used to reference this user in an event
   * @returns {NDKTag[]} an array of NDKTag
   */
  referenceTags(cr) {
    const ar = [["p", this.pubkey]];
    return cr && ar[0].push("", cr), ar;
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (!this.profile)
      throw new Error("No profile available");
    this.ndk.assertSigner(), await new NDKEvent(this.ndk, {
      kind: 0,
      content: serializeProfile(this.profile)
    }).publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(cr, ar, lr = 3) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    if (this.ndk.assertSigner(), ar || (ar = await this.follows(void 0, void 0, lr)), ar.has(cr))
      return !1;
    ar.add(cr);
    const ur = new NDKEvent(this.ndk, { kind: lr });
    for (const dr of ar)
      ur.tag(dr);
    return await ur.publish(), !0;
  }
  /**
   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
   *
   * @param nip05Id The NIP-05 string to validate
   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
   * False if the NIP-05 is found but doesn't match this user's pubkey,
   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
   */
  async validateNip05(cr) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    const ar = await nip05_exports$2.queryProfile(cr);
    return ar === null ? null : ar.pubkey === this.pubkey;
  }
  /**
   * Zap a user
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   * @param signer The signer to use (will default to the NDK instance's signer)
   */
  async zap(cr, ar, lr, ur) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    ur || this.ndk.assertSigner();
    const dr = new Zap$1({
      ndk: this.ndk,
      zappedUser: this
    }), fr = Array.from(this.ndk.pool.relays.keys());
    return await dr.createZapRequest(
      cr,
      ar,
      lr,
      fr,
      ur
    );
  }
}, NDKRepost = class extends NDKEvent {
  constructor(ar, lr) {
    super(ar, lr);
    ti(this, "_repostedEvents");
  }
  static from(ar) {
    return new NDKRepost(ar.ndk, ar.rawEvent());
  }
  /**
   * Returns all reposted events by the current event.
   *
   * @param klass Optional class to convert the events to.
   * @returns
   */
  async repostedEvents(ar, lr) {
    const ur = [];
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (this._repostedEvents !== void 0)
      return this._repostedEvents;
    for (const dr of this.repostedEventIds()) {
      const fr = filterForId(dr), gr = await this.ndk.fetchEvent(fr, lr);
      gr && ur.push(ar ? ar.from(gr) : gr);
    }
    return ur;
  }
  /**
   * Returns the reposted event IDs.
   */
  repostedEventIds() {
    return this.tags.filter((ar) => ar[0] === "e" || ar[0] === "a").map((ar) => ar[1]);
  }
};
function filterForId(cr) {
  if (cr.match(/:/)) {
    const [ar, lr, ur] = cr.split(":");
    return {
      kinds: [parseInt(ar)],
      authors: [lr],
      "#d": [ur]
    };
  } else
    return { ids: [cr] };
}
var NDKNip07Signer = class {
  /**
   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available
   */
  constructor(cr = 1e3) {
    ti(this, "_userPromise");
    ti(this, "nip04Queue", []);
    ti(this, "nip04Processing", !1);
    ti(this, "debug");
    ti(this, "waitTimeout");
    this.debug = _debug("ndk:nip07"), this.waitTimeout = cr;
  }
  async blockUntilReady() {
    await this.waitForExtension();
    const cr = await window.nostr.getPublicKey();
    if (!cr)
      throw new Error("User rejected access");
    return new NDKUser({ hexpubkey: cr });
  }
  /**
   * Getter for the user property.
   * @returns The NDKUser instance.
   */
  async user() {
    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;
  }
  /**
   * Signs the given Nostr event.
   * @param event - The Nostr event to be signed.
   * @returns The signature of the signed event.
   * @throws Error if the NIP-07 is not available on the window object.
   */
  async sign(cr) {
    return await this.waitForExtension(), (await window.nostr.signEvent(cr)).sig;
  }
  async relays() {
    var lr, ur;
    await this.waitForExtension();
    const cr = await ((ur = (lr = window.nostr).getRelays) == null ? void 0 : ur.call(lr)) || {}, ar = [];
    for (const dr of Object.keys(cr))
      cr[dr].read && cr[dr].write && ar.push(dr);
    return ar.map((dr) => new NDKRelay(dr));
  }
  async encrypt(cr, ar) {
    await this.waitForExtension();
    const lr = cr.hexpubkey;
    return this.queueNip04("encrypt", lr, ar);
  }
  async decrypt(cr, ar) {
    await this.waitForExtension();
    const lr = cr.hexpubkey;
    return this.queueNip04("decrypt", lr, ar);
  }
  async queueNip04(cr, ar, lr) {
    return new Promise((ur, dr) => {
      this.nip04Queue.push({
        type: cr,
        counterpartyHexpubkey: ar,
        value: lr,
        resolve: ur,
        reject: dr
      }), this.nip04Processing || this.processNip04Queue();
    });
  }
  async processNip04Queue(cr, ar = 0) {
    if (!cr && this.nip04Queue.length === 0) {
      this.nip04Processing = !1;
      return;
    }
    this.nip04Processing = !0;
    const { type: lr, counterpartyHexpubkey: ur, value: dr, resolve: fr, reject: gr } = cr || this.nip04Queue.shift();
    this.debug("Processing encryption queue item", {
      type: lr,
      counterpartyHexpubkey: ur,
      value: dr
    });
    try {
      let mr;
      lr === "encrypt" ? mr = await window.nostr.nip04.encrypt(ur, dr) : mr = await window.nostr.nip04.decrypt(ur, dr), fr(mr);
    } catch (mr) {
      if (mr.message && mr.message.includes("call already executing") && ar < 5) {
        this.debug("Retrying encryption queue item", {
          type: lr,
          counterpartyHexpubkey: ur,
          value: dr,
          retries: ar
        }), setTimeout(() => {
          this.processNip04Queue(cr, ar + 1);
        }, 50 * ar);
        return;
      }
      gr(mr);
    }
    this.processNip04Queue();
  }
  waitForExtension() {
    return new Promise((cr, ar) => {
      if (window.nostr) {
        cr();
        return;
      }
      let lr;
      const ur = setInterval(() => {
        window.nostr && (clearTimeout(lr), clearInterval(ur), cr());
      }, 100);
      lr = setTimeout(() => {
        clearInterval(ur), ar(new Error("NIP-07 extension not available"));
      }, this.waitTimeout);
    });
  }
}, NDKPrivateKeySigner = class {
  constructor(cr) {
    ti(this, "_user");
    ti(this, "privateKey");
    cr && (this.privateKey = cr, this._user = new NDKUser({
      hexpubkey: getPublicKey$1(this.privateKey)
    }));
  }
  static generate() {
    const cr = generatePrivateKey();
    return new NDKPrivateKeySigner(cr);
  }
  async blockUntilReady() {
    if (!this._user)
      throw new Error("NDKUser not initialized");
    return this._user;
  }
  async user() {
    return await this.blockUntilReady(), this._user;
  }
  async sign(cr) {
    if (!this.privateKey)
      throw Error("Attempted to sign without a private key");
    return getSignature$1(cr, this.privateKey);
  }
  async encrypt(cr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to encrypt without a private key");
    const lr = cr.hexpubkey;
    return await nip04_exports$2.encrypt(this.privateKey, lr, ar);
  }
  async decrypt(cr, ar) {
    if (!this.privateKey)
      throw Error("Attempted to decrypt without a private key");
    const lr = cr.hexpubkey;
    return await nip04_exports$2.decrypt(this.privateKey, lr, ar);
  }
};
function dedup(cr, ar) {
  return cr.created_at > ar.created_at ? cr : ar;
}
var OutboxItem = class {
  constructor(cr) {
    /**
     * Type of item
     */
    ti(this, "type");
    /**
     * The relay URLs that are of interest to this item
     */
    ti(this, "relayUrlScores");
    ti(this, "readRelays");
    ti(this, "writeRelays");
    this.type = cr, this.relayUrlScores = /* @__PURE__ */ new Map(), this.readRelays = /* @__PURE__ */ new Set(), this.writeRelays = /* @__PURE__ */ new Set();
  }
}, OutboxTracker = class extends lib$2.EventEmitter {
  constructor(ar) {
    super();
    ti(this, "data");
    ti(this, "ndk");
    ti(this, "debug");
    this.ndk = ar, this.debug = ar.debug.extend("outbox-tracker"), this.data = new dist$2.LRUCache({
      maxSize: 1e5,
      entryExpirationTimeInMS: 5e3
    });
  }
  trackUsers(ar) {
    for (const lr of ar) {
      const ur = getKeyFromItem(lr);
      if (this.data.has(ur))
        continue;
      const dr = this.track(lr, "user"), fr = lr instanceof NDKUser ? lr : new NDKUser({ hexpubkey: lr });
      fr.ndk = this.ndk, fr.relayList().then((gr) => {
        if (gr) {
          dr.readRelays = new Set(gr.readRelayUrls), dr.writeRelays = new Set(gr.writeRelayUrls);
          for (const mr of dr.readRelays)
            this.ndk.pool.blacklistRelayUrls.has(mr) && (this.debug(`removing blacklisted relay ${mr} from read relays`), dr.readRelays.delete(mr));
          for (const mr of dr.writeRelays)
            this.ndk.pool.blacklistRelayUrls.has(mr) && (this.debug(`removing blacklisted relay ${mr} from write relays`), dr.writeRelays.delete(mr));
          this.data.set(ur, dr), this.debug(
            `Adding ${dr.readRelays.size} read relays and ${dr.writeRelays.size} write relays for ${fr.hexpubkey}`
          );
        }
      });
    }
  }
  /**
   *
   * @param key
   * @param score
   */
  track(ar, lr) {
    const ur = getKeyFromItem(ar);
    lr != null || (lr = getTypeFromItem(ar));
    let dr = this.data.get(ur);
    return dr || (dr = new OutboxItem(lr)), this.data.set(ur, dr), dr;
  }
};
function getKeyFromItem(cr) {
  return cr instanceof NDKUser ? cr.hexpubkey : cr;
}
function getTypeFromItem(cr) {
  return cr instanceof NDKUser ? "user" : "kind";
}
var NDKPool = class extends lib$2.EventEmitter {
  constructor(ar = [], lr = [], ur, dr) {
    super();
    // TODO: This should probably be an LRU cache
    ti(this, "relays", /* @__PURE__ */ new Map());
    ti(this, "blacklistRelayUrls");
    ti(this, "debug");
    ti(this, "temporaryRelayTimers", /* @__PURE__ */ new Map());
    ti(this, "flappingRelays", /* @__PURE__ */ new Set());
    // A map to store timeouts for each flapping relay.
    ti(this, "backoffTimes", /* @__PURE__ */ new Map());
    this.debug = dr != null ? dr : ur.debug.extend("pool");
    for (const fr of ar) {
      const gr = new NDKRelay(fr);
      this.addRelay(gr, !1);
    }
    this.blacklistRelayUrls = new Set(lr);
  }
  /**
   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.
   * @param relay - The relay to add to the pool.
   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.
   */
  useTemporaryRelay(ar, lr = 6e5) {
    const ur = this.relays.has(ar.url);
    ur || this.addRelay(ar);
    const dr = this.temporaryRelayTimers.get(ar.url);
    if (dr && clearTimeout(dr), !ur || dr) {
      const fr = setTimeout(() => {
        this.removeRelay(ar.url);
      }, lr);
      this.temporaryRelayTimers.set(ar.url, fr);
    }
  }
  /**
   * Adds a relay to the pool.
   *
   * @param relay - The relay to add to the pool.
   * @param connect - Whether or not to connect to the relay.
   */
  addRelay(ar, lr = !0) {
    var dr;
    const ur = ar.url;
    if ((dr = this.blacklistRelayUrls) != null && dr.has(ur)) {
      this.debug(`Relay ${ur} is blacklisted`);
      return;
    }
    ar.on("notice", async (fr, gr) => this.emit("notice", fr, gr)), ar.on("connect", () => this.handleRelayConnect(ur)), ar.on("disconnect", async () => this.emit("relay:disconnect", ar)), ar.on("flapping", () => this.handleFlapping(ar)), this.relays.set(ur, ar), lr && ar.connect().catch((fr) => {
      this.debug(`Failed to connect to relay ${ur}`, fr);
    });
  }
  /**
   * Removes a relay from the pool.
   * @param relayUrl - The URL of the relay to remove.
   * @returns {boolean} True if the relay was removed, false if it was not found.
   */
  removeRelay(ar) {
    const lr = this.relays.get(ar);
    if (lr)
      return lr.disconnect(), this.relays.delete(ar), this.emit("relay:disconnect", lr), !0;
    const ur = this.temporaryRelayTimers.get(ar);
    return ur && (clearTimeout(ur), this.temporaryRelayTimers.delete(ar)), !1;
  }
  /**
   * Fetches a relay from the pool, or creates a new one if it does not exist.
   *
   * New relays will be attempted to be connected.
   */
  getRelay(ar) {
    let lr = this.relays.get(ar);
    return lr || (lr = new NDKRelay(ar), this.addRelay(lr)), lr;
  }
  handleRelayConnect(ar) {
    this.debug(`Relay ${ar} connected`), this.emit("relay:connect", this.relays.get(ar)), this.stats().connected === this.relays.size && this.emit("connect");
  }
  /**
   * Attempts to establish a connection to each relay in the pool.
   *
   * @async
   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
   * @throws {Error} If any of the connection attempts result in an error or timeout.
   */
  async connect(ar) {
    const lr = [];
    this.debug(
      `Connecting to ${this.relays.size} relays${ar ? `, timeout ${ar}...` : ""}`
    );
    for (const ur of this.relays.values())
      if (ar) {
        const dr = new Promise((fr, gr) => {
          setTimeout(() => gr(`Timed out after ${ar}ms`), ar);
        });
        lr.push(
          Promise.race([ur.connect(), dr]).catch((fr) => {
            this.debug(
              `Failed to connect to relay ${ur.url}: ${fr != null ? fr : "No reason specified"}`
            );
          })
        );
      } else
        lr.push(ur.connect());
    ar && setTimeout(() => {
      const ur = this.stats().connected === this.relays.size, dr = this.stats().connected > 0;
      !ur && dr && this.emit("connect");
    }, ar), await Promise.all(lr);
  }
  checkOnFlappingRelays() {
    const ar = this.flappingRelays.size, lr = this.relays.size;
    if (ar / lr >= 0.8)
      for (const ur of this.flappingRelays)
        this.backoffTimes.set(ur, 0);
  }
  handleFlapping(ar) {
    this.debug(`Relay ${ar.url} is flapping`);
    let lr = this.backoffTimes.get(ar.url) || 5e3;
    lr = lr * 2, this.backoffTimes.set(ar.url, lr), this.debug(`Backoff time for ${ar.url} is ${lr}ms`), setTimeout(() => {
      this.debug(`Attempting to reconnect to ${ar.url}`), ar.connect(), this.checkOnFlappingRelays();
    }, lr), ar.disconnect(), this.emit("flapping", ar);
  }
  size() {
    return this.relays.size;
  }
  /**
   * Returns the status of each relay in the pool.
   * @returns {NDKPoolStats} An object containing the number of relays in each status.
   */
  stats() {
    const ar = {
      total: 0,
      connected: 0,
      disconnected: 0,
      connecting: 0
    };
    for (const lr of this.relays.values())
      ar.total++, lr.status === 1 ? ar.connected++ : lr.status === 3 ? ar.disconnected++ : lr.status === 0 && ar.connecting++;
    return ar;
  }
  connectedRelays() {
    return Array.from(this.relays.values()).filter(
      (ar) => ar.status === 1
      /* CONNECTED */
    );
  }
  /**
   * Get a list of all relay urls in the pool.
   */
  urls() {
    return Array.from(this.relays.keys());
  }
};
function correctRelaySet(cr, ar) {
  const lr = ar.connectedRelays();
  if (!Array.from(cr.relays).some((dr) => lr.map((fr) => fr.url).includes(dr.url)))
    for (const dr of lr)
      cr.addRelay(dr);
  if (lr.length === 0)
    for (const dr of ar.relays.values())
      cr.addRelay(dr);
  return cr;
}
var DEFAULT_OUTBOX_RELAYS = ["wss://purplepag.es", "wss://relay.snort.social"], DEFAULT_BLACKLISTED_RELAYS = [
  "wss://brb.io"
  // BRB
], NDK = class extends lib$2.EventEmitter {
  constructor(ar = {}) {
    var lr, ur;
    super();
    ti(this, "explicitRelayUrls");
    ti(this, "pool");
    ti(this, "outboxPool");
    ti(this, "_signer");
    ti(this, "_activeUser");
    ti(this, "cacheAdapter");
    ti(this, "debug");
    ti(this, "devWriteRelaySet");
    ti(this, "outboxTracker");
    ti(this, "mutedIds");
    ti(this, "clientName");
    ti(this, "clientNip89");
    ti(this, "autoConnectUserRelays", !0);
    ti(this, "autoFetchUserMutelist", !0);
    this.debug = ar.debug || _debug("ndk"), this.explicitRelayUrls = ar.explicitRelayUrls, this.pool = new NDKPool(ar.explicitRelayUrls || [], ar.blacklistRelayUrls, this), this.debug(`Starting with explicit relays: ${JSON.stringify(this.explicitRelayUrls)}`), this.autoConnectUserRelays = (lr = ar.autoConnectUserRelays) != null ? lr : !0, this.autoFetchUserMutelist = (ur = ar.autoFetchUserMutelist) != null ? ur : !0, this.clientName = ar.clientName, this.clientNip89 = ar.clientNip89, ar.enableOutboxModel && (this.outboxPool = new NDKPool(
      ar.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,
      ar.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS,
      this,
      this.debug.extend("outbox-pool")
    ), this.outboxTracker = new OutboxTracker(this)), this.signer = ar.signer, this.cacheAdapter = ar.cacheAdapter, this.mutedIds = ar.mutedIds || /* @__PURE__ */ new Map(), ar.devWriteRelayUrls && (this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(ar.devWriteRelayUrls, this));
  }
  toJSON() {
    return { relayCount: this.pool.relays.size }.toString();
  }
  get activeUser() {
    return this._activeUser;
  }
  /**
   * Sets the active user for this NDK instance, typically this will be
   * called when assigning a signer to the NDK instance.
   *
   * This function will automatically connect to the user's relays if
   * `autoConnectUserRelays` is set to true.
   *
   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.
   */
  set activeUser(ar) {
    const lr = this._activeUser !== ar;
    if (this._activeUser = ar, ar && lr) {
      const ur = async (vr) => {
        const yr = await vr.relayList();
        if (!yr) {
          this.debug("No relay list found for user", { npub: vr.npub });
          return;
        }
        this.debug("Connecting to user relays", {
          npub: vr.npub,
          relays: yr.relays
        });
        for (const _r of yr.relays) {
          let kr = this.pool.relays.get(_r);
          kr || (kr = new NDKRelay(_r), this.pool.addRelay(kr));
        }
      }, dr = async (vr) => {
        const yr = await this.fetchEvents([
          { kinds: [
            1e4
            /* MuteList */
          ], authors: [vr.pubkey] },
          {
            kinds: [
              3e4
              /* FollowSet */
            ],
            authors: [vr.pubkey],
            "#d": ["mute"],
            limit: 1
          }
        ]);
        if (!yr) {
          this.debug("No mute list found for user", { npub: vr.npub });
          return;
        }
        for (const _r of yr) {
          const kr = lists_default.from(_r);
          for (const xr of kr.items)
            this.mutedIds.set(xr[1], xr[0]);
        }
      }, fr = [];
      this.autoConnectUserRelays && fr.push(ur), this.autoFetchUserMutelist && fr.push(dr);
      const gr = async (vr) => {
        for (const yr of fr)
          await yr(vr);
      }, mr = this.outboxPool || this.pool;
      mr.connectedRelays.length > 0 ? gr(ar) : (this.debug("Waiting for connection to main relays"), mr.once("relay:connect", (vr) => {
        this.debug("New relay came online", vr), gr(ar);
      }));
    } else
      ar || (this.mutedIds = /* @__PURE__ */ new Map());
  }
  get signer() {
    return this._signer;
  }
  set signer(ar) {
    this._signer = ar, this.debug("setting signer", this.autoConnectUserRelays), ar == null || ar.user().then((lr) => {
      lr.ndk = this, this.activeUser = lr;
    });
  }
  /**
   * Connect to relays with optional timeout.
   * If the timeout is reached, the connection will be continued to be established in the background.
   */
  async connect(ar) {
    this._signer && this.autoConnectUserRelays && (this.debug("Attempting to connect to user relays specified by signer"), this._signer.relays && (await this._signer.relays()).forEach((dr) => this.pool.addRelay(dr)));
    const lr = [this.pool.connect(ar)];
    return this.outboxPool && lr.push(this.outboxPool.connect(ar)), this.debug("Connecting to relays", { timeoutMs: ar }), Promise.allSettled(lr).then(() => {
    });
  }
  /**
   * Get a NDKUser object
   *
   * @param opts
   * @returns
   */
  getUser(ar) {
    const lr = new NDKUser(ar);
    return lr.ndk = this, lr;
  }
  /**
   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)
   *
   * @param filters
   * @param opts
   * @param relaySet explicit relay set to use
   * @param autoStart automatically start the subscription
   * @returns NDKSubscription
   */
  subscribe(ar, lr, ur, dr = !0) {
    var gr;
    const fr = new NDKSubscription(this, ar, lr, ur);
    if (ur)
      for (const mr of ur.relays)
        this.pool.useTemporaryRelay(mr);
    if (this.outboxPool && fr.hasAuthorsFilter()) {
      const mr = fr.filters.filter((vr) => {
        var yr;
        return vr.authors && ((yr = vr.authors) == null ? void 0 : yr.length) > 0;
      }).map((vr) => vr.authors).flat();
      (gr = this.outboxTracker) == null || gr.trackUsers(mr);
    }
    return dr && fr.start(), fr;
  }
  /**
   * Publish an event to a relay
   * @param event event to publish
   * @param relaySet explicit relay set to use
   * @param timeoutMs timeout in milliseconds to wait for the event to be published
   * @returns The relays the event was published to
   *
   * @deprecated Use `event.publish()` instead
   */
  async publish(ar, lr, ur) {
    return this.debug("Deprecated: Use `event.publish()` instead"), ar.publish(lr, ur);
  }
  /**
   * Fetch a single event.
   *
   * @param idOrFilter event id in bech32 format or filter
   * @param opts subscription options
   * @param relaySet explicit relay set to use
   */
  async fetchEvent(ar, lr, ur) {
    let dr;
    if (!ur && typeof ar == "string" && !isNip33AValue(ar)) {
      const fr = relaysFromBech32(ar);
      fr.length > 0 && (ur = new NDKRelaySet(new Set(fr), this), ur = correctRelaySet(ur, this.pool));
    }
    if (typeof ar == "string" ? dr = filterFromId(ar) : dr = ar, !dr)
      throw new Error(`Invalid filter: ${JSON.stringify(ar)}`);
    return new Promise((fr) => {
      const gr = this.subscribe(
        dr,
        { ...lr || {}, closeOnEose: !0 },
        ur,
        !1
      );
      gr.on("event", (mr) => {
        mr.ndk = this, fr(mr);
      }), gr.on("eose", () => {
        fr(null);
      }), gr.start();
    });
  }
  /**
   * Fetch events
   */
  async fetchEvents(ar, lr, ur) {
    return new Promise((dr) => {
      const fr = /* @__PURE__ */ new Map(), gr = this.subscribe(
        ar,
        { ...lr || {}, closeOnEose: !0 },
        ur,
        !1
      ), mr = (vr) => {
        const yr = vr.deduplicationKey(), _r = fr.get(yr);
        _r && (vr = dedup(_r, vr)), vr.ndk = this, fr.set(yr, vr);
      };
      gr.on("event", mr), gr.on("event:dup", mr), gr.on("eose", () => {
        dr(new Set(fr.values()));
      }), gr.start();
    });
  }
  /**
   * Ensures that a signer is available to sign an event.
   */
  assertSigner() {
    if (!this.signer)
      throw this.emit("signerRequired"), new Error("Signer required");
  }
}, NDKSvelte = class extends NDK {
  constructor(cr) {
    super(cr);
  }
  createEventStore(cr) {
    const ar = writable([]);
    return {
      refCount: 0,
      filters: cr,
      subscription: void 0,
      set: ar.set,
      update: ar.update,
      subscribe: ar.subscribe,
      unsubscribe: () => {
      },
      onEose: (lr) => {
      },
      startSubscription: () => {
        throw new Error("not implemented");
      },
      ref: () => {
        throw new Error("not implemented");
      },
      unref: () => {
        throw new Error("not implemented");
      },
      empty: () => {
        throw new Error("not implemented");
      },
      changeFilters: (lr) => {
        throw new Error("not implemented");
      }
    };
  }
  eventIsRepost(cr) {
    return [NDKKind.Repost, NDKKind.GenericRepost].includes(cr.kind);
  }
  eventIsLabel(cr) {
    return [NDKKind.Label].includes(cr.kind);
  }
  storeSubscribe(cr, ar, lr) {
    var kr;
    let ur = /* @__PURE__ */ new Set(), dr = [];
    const fr = this.createEventStore(
      Array.isArray(cr) ? cr : [cr]
    ), gr = (kr = ar == null ? void 0 : ar.autoStart) != null ? kr : !0, mr = ar == null ? void 0 : ar.relaySet, vr = (xr) => {
      console.log("handle event label", xr.rawEvent()), yr(xr);
    }, yr = (xr) => {
      const Ar = NDKRepost.from(xr);
      Ar.ndk = this;
      const Er = (Cr) => {
        Cr.repostedByEvents ? Cr.repostedByEvents.push(xr) : Cr.repostedByEvents = [xr], fr.set(dr);
      };
      for (const Cr of Ar.repostedEventIds()) {
        const Tr = dr.find((Sr) => Sr.id === Cr);
        Tr ? Er(Tr) : Ar.repostedEvents(lr).then((Sr) => {
          for (const Lr of Sr)
            Lr instanceof NDKEvent && _r(Lr);
        });
      }
    }, _r = (xr) => {
      if (fr.filters && this.eventIsRepost(xr)) {
        yr(xr);
        return;
      }
      if (this.eventIsLabel(xr)) {
        vr(xr);
        return;
      }
      let Ar = xr;
      lr && (Ar = lr.from(xr), Ar.relay = xr.relay), Ar.ndk = this;
      const Er = xr.deduplicationKey();
      if (ur.has(Er)) {
        const Tr = dr.find((Sr) => Sr.deduplicationKey() === Er);
        if (Tr && Tr.created_at < xr.created_at) {
          const Sr = dr.findIndex((Lr) => Lr.deduplicationKey() === Er);
          dr.splice(Sr, 1);
        } else
          return;
      }
      ur.add(Er);
      const Cr = dr.findIndex((Tr) => Tr.created_at < xr.created_at);
      Cr === -1 ? dr.push(Ar) : dr.splice(Cr === -1 ? dr.length : Cr, 0, Ar), fr.set(dr);
    };
    return fr.ref = () => (fr.refCount++, fr.refCount === 1 && fr.startSubscription(), fr.refCount), fr.unref = () => (--fr.refCount !== 0 || (ar != null && ar.unrefUnsubscribeTimeout ? setTimeout(() => {
      fr.refCount === 0 && fr.unsubscribe();
    }, ar.unrefUnsubscribeTimeout) : fr.unsubscribe()), fr.refCount), fr.empty = () => {
      fr.set([]), dr = [], ur = /* @__PURE__ */ new Set(), fr.unsubscribe();
    }, fr.changeFilters = (xr) => {
      fr.filters = xr, fr.empty(), fr.refCount > 0 && fr.startSubscription();
    }, fr.startSubscription = () => {
      if (!fr.filters)
        throw new Error("no filters");
      const xr = fr.filters;
      ar != null && ar.repostsFilters && xr.push(...ar.repostsFilters), fr.subscription = this.subscribe(xr, ar, mr), fr.subscription.on("event", (Ar, Er) => {
        _r(Ar);
      }), fr.unsubscribe = () => {
        var Ar;
        (Ar = fr.subscription) == null || Ar.stop(), fr.subscription = void 0;
      }, fr.onEose = (Ar) => {
        var Er;
        (Er = fr.subscription) == null || Er.on("eose", Ar);
      };
    }, gr && fr.startSubscription(), fr;
  }
}, src_default = NDKSvelte;
const crypto$3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$3 = (cr) => cr instanceof Uint8Array, createView$2 = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr$2 = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$2)
  throw new Error("Non little-endian hardware is not supported");
const hexes$2 = Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$2(cr) {
  if (!u8a$3(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes$2[cr[lr]];
  return ar;
}
function hexToBytes$3(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function utf8ToBytes$3(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$2(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$3(cr)), !u8a$3(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes$3(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$3(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
let Hash$2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(cr) {
  const ar = (ur) => cr().update(toBytes$2(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes$2(cr = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues == "function")
    return crypto$3.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number$2(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool$1(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes$2(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$2(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$2(cr.outputLen), number$2(cr.blockLen);
}
function exists$2(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(cr, ar) {
  bytes$2(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert$1 = {
  number: number$2,
  bool: bool$1,
  bytes: bytes$2,
  hash: hash$2,
  exists: exists$2,
  output: output$2
};
function setBigUint64$2(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
let SHA2$2 = class extends Hash$2 {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$2(this.buffer);
  }
  update(ar) {
    assert$1.exists(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes$2(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView$2(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.output(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64$2(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView$2(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
};
const Chi$3 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj$2 = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K$2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$2 = new Uint32Array(64);
let SHA256$2 = class extends SHA2$2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$2[0] | 0, this.B = IV$2[1] | 0, this.C = IV$2[2] | 0, this.D = IV$2[3] | 0, this.E = IV$2[4] | 0, this.F = IV$2[5] | 0, this.G = IV$2[6] | 0, this.H = IV$2[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W$2[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W$2[kr - 15], Ar = SHA256_W$2[kr - 2], Er = rotr$2(xr, 7) ^ rotr$2(xr, 18) ^ xr >>> 3, Cr = rotr$2(Ar, 17) ^ rotr$2(Ar, 19) ^ Ar >>> 10;
      SHA256_W$2[kr] = Cr + SHA256_W$2[kr - 7] + Er + SHA256_W$2[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr$2(mr, 6) ^ rotr$2(mr, 11) ^ rotr$2(mr, 25), Ar = _r + xr + Chi$3(mr, vr, yr) + SHA256_K$2[kr] + SHA256_W$2[kr] | 0, Cr = (rotr$2(ur, 2) ^ rotr$2(ur, 13) ^ rotr$2(ur, 22)) + Maj$2(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const sha256$2 = wrapConstructor$2(() => new SHA256$2());
wrapConstructor$2(() => new SHA224$1());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber$1(cr) {
  if (!Number.isSafeInteger(cr))
    throw new Error(`Wrong integer: ${cr}`);
}
function chain$1(...cr) {
  const ar = (dr, fr) => (gr) => dr(fr(gr)), lr = Array.from(cr).reverse().reduce((dr, fr) => dr ? ar(dr, fr.encode) : fr.encode, void 0), ur = cr.reduce((dr, fr) => dr ? ar(dr, fr.decode) : fr.decode, void 0);
  return { encode: lr, decode: ur };
}
function alphabet$1(cr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((lr) => {
        if (assertNumber$1(lr), lr < 0 || lr >= cr.length)
          throw new Error(`Digit index outside alphabet: ${lr} (alphabet: ${cr.length})`);
        return cr[lr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((lr) => {
        if (typeof lr != "string")
          throw new Error(`alphabet.decode: not string element=${lr}`);
        const ur = cr.indexOf(lr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${lr}". Allowed: ${cr}`);
        return ur;
      });
    }
  };
}
function join$2(cr = "") {
  if (typeof cr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let lr of ar)
        if (typeof lr != "string")
          throw new Error(`join.encode: non-string input=${lr}`);
      return ar.join(cr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(cr);
    }
  };
}
function padding$1(cr, ar = "=") {
  if (assertNumber$1(cr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of lr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; lr.length * cr % 8; )
        lr.push(ar);
      return lr;
    },
    decode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let dr of lr)
        if (typeof dr != "string")
          throw new Error(`padding.decode: non-string input=${dr}`);
      let ur = lr.length;
      if (ur * cr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && lr[ur - 1] === ar; ur--)
        if (!((ur - 1) * cr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return lr.slice(0, ur);
    }
  };
}
function normalize$2(cr) {
  if (typeof cr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => cr(ar) };
}
function convertRadix$1(cr, ar, lr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (lr < 2)
    throw new Error(`convertRadix: wrong to=${lr}, base cannot be less than 2`);
  if (!Array.isArray(cr))
    throw new Error("convertRadix: data should be array");
  if (!cr.length)
    return [];
  let ur = 0;
  const dr = [], fr = Array.from(cr);
  for (fr.forEach((gr) => {
    if (assertNumber$1(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < fr.length; vr++) {
      const yr = fr[vr], _r = ar * gr + yr;
      if (!Number.isSafeInteger(_r) || ar * gr / ar !== gr || _r - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = _r % lr, fr[vr] = Math.floor(_r / lr), !Number.isSafeInteger(fr[vr]) || fr[vr] * lr + gr !== _r)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        fr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (dr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < cr.length - 1 && cr[gr] === 0; gr++)
    dr.push(0);
  return dr.reverse();
}
const gcd$1 = (cr, ar) => ar ? gcd$1(ar, cr % ar) : cr, radix2carry$1 = (cr, ar) => cr + (ar - gcd$1(cr, ar));
function convertRadix2$1(cr, ar, lr, ur) {
  if (!Array.isArray(cr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (lr <= 0 || lr > 32)
    throw new Error(`convertRadix2: wrong to=${lr}`);
  if (radix2carry$1(ar, lr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${lr} carryBits=${radix2carry$1(ar, lr)}`);
  let dr = 0, fr = 0;
  const gr = 2 ** lr - 1, mr = [];
  for (const vr of cr) {
    if (assertNumber$1(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (dr = dr << ar | vr, fr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${fr} from=${ar}`);
    for (fr += ar; fr >= lr; fr -= lr)
      mr.push((dr >> fr - lr & gr) >>> 0);
    dr &= 2 ** fr - 1;
  }
  if (dr = dr << lr - fr & gr, !ur && fr >= ar)
    throw new Error("Excess padding");
  if (!ur && dr)
    throw new Error(`Non-zero padding: ${dr}`);
  return ur && fr > 0 && mr.push(dr >>> 0), mr;
}
function radix$1(cr) {
  return assertNumber$1(cr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix$1(Array.from(ar), 2 ** 8, cr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix$1(ar, cr, 2 ** 8));
    }
  };
}
function radix2$1(cr, ar = !1) {
  if (assertNumber$1(cr), cr <= 0 || cr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry$1(8, cr) > 32 || radix2carry$1(cr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (lr) => {
      if (!(lr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2$1(Array.from(lr), 8, cr, !ar);
    },
    decode: (lr) => {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2$1(lr, cr, 8, ar));
    }
  };
}
function unsafeWrapper$1(cr) {
  if (typeof cr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return cr.apply(null, ar);
    } catch (lr) {
    }
  };
}
const base16$1 = chain$1(radix2$1(4), alphabet$1("0123456789ABCDEF"), join$2("")), base32$1 = chain$1(radix2$1(5), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding$1(5), join$2(""));
chain$1(radix2$1(5), alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$2(""), normalize$2((cr) => cr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding$1(6), join$2("")), base64url$1 = chain$1(radix2$1(6), alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding$1(6), join$2("")), genBase58$1 = (cr) => chain$1(radix$1(58), alphabet$1(cr), join$2("")), base58$1 = genBase58$1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58$1("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58$1("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN$1 = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr$1 = {
  encode(cr) {
    let ar = "";
    for (let lr = 0; lr < cr.length; lr += 8) {
      const ur = cr.subarray(lr, lr + 8);
      ar += base58$1.encode(ur).padStart(XMR_BLOCK_LEN$1[ur.length], "1");
    }
    return ar;
  },
  decode(cr) {
    let ar = [];
    for (let lr = 0; lr < cr.length; lr += 11) {
      const ur = cr.slice(lr, lr + 11), dr = XMR_BLOCK_LEN$1.indexOf(ur.length), fr = base58$1.decode(ur);
      for (let gr = 0; gr < fr.length - dr; gr++)
        if (fr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(fr.slice(fr.length - dr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET$1 = chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$2("")), POLYMOD_GENERATORS$1 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod$1(cr) {
  const ar = cr >> 25;
  let lr = (cr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS$1.length; ur++)
    (ar >> ur & 1) === 1 && (lr ^= POLYMOD_GENERATORS$1[ur]);
  return lr;
}
function bechChecksum$1(cr, ar, lr = 1) {
  const ur = cr.length;
  let dr = 1;
  for (let fr = 0; fr < ur; fr++) {
    const gr = cr.charCodeAt(fr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${cr})`);
    dr = bech32Polymod$1(dr) ^ gr >> 5;
  }
  dr = bech32Polymod$1(dr);
  for (let fr = 0; fr < ur; fr++)
    dr = bech32Polymod$1(dr) ^ cr.charCodeAt(fr) & 31;
  for (let fr of ar)
    dr = bech32Polymod$1(dr) ^ fr;
  for (let fr = 0; fr < 6; fr++)
    dr = bech32Polymod$1(dr);
  return dr ^= lr, BECH_ALPHABET$1.encode(convertRadix2$1([dr % 2 ** 30], 30, 5, !1));
}
function genBech32$1(cr) {
  const ar = cr === "bech32" ? 1 : 734539939, lr = radix2$1(5), ur = lr.decode, dr = lr.encode, fr = unsafeWrapper$1(ur);
  function gr(_r, kr, xr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof _r}`);
    if (!Array.isArray(kr) || kr.length && typeof kr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof kr}`);
    const Ar = _r.length + 7 + kr.length;
    if (xr !== !1 && Ar > xr)
      throw new TypeError(`Length ${Ar} exceeds limit ${xr}`);
    return _r = _r.toLowerCase(), `${_r}1${BECH_ALPHABET$1.encode(kr)}${bechChecksum$1(_r, kr, ar)}`;
  }
  function mr(_r, kr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof _r}`);
    if (_r.length < 8 || kr !== !1 && _r.length > kr)
      throw new TypeError(`Wrong string length: ${_r.length} (${_r}). Expected (8..${kr})`);
    const xr = _r.toLowerCase();
    if (_r !== xr && _r !== _r.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    _r = xr;
    const Ar = _r.lastIndexOf("1");
    if (Ar === 0 || Ar === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = _r.slice(0, Ar), Cr = _r.slice(Ar + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET$1.decode(Cr).slice(0, -6), Sr = bechChecksum$1(Er, Tr, ar);
    if (!Cr.endsWith(Sr))
      throw new Error(`Invalid checksum in ${_r}: expected "${Sr}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper$1(mr);
  function yr(_r) {
    const { prefix: kr, words: xr } = mr(_r, !1);
    return { prefix: kr, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: fr, toWords: dr };
}
const bech32$2 = genBech32$1("bech32");
genBech32$1("bech32m");
const utf8$1 = {
  encode: (cr) => new TextDecoder().decode(cr),
  decode: (cr) => new TextEncoder().encode(cr)
}, hex$1 = chain$1(radix2$1(4), alphabet$1("0123456789abcdef"), join$2(""), normalize$2((cr) => {
  if (typeof cr != "string" || cr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof cr} with length ${cr.length}`);
  return cr.toLowerCase();
})), CODERS$1 = {
  utf8: utf8$1,
  hex: hex$1,
  base16: base16$1,
  base32: base32$1,
  base64: base64$1,
  base64url: base64url$1,
  base58: base58$1,
  base58xmr: base58xmr$1
};
`${Object.keys(CODERS$1).join(", ")}`;
let HMAC$2 = class extends Hash$2 {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, assert$1.hash(ar);
    const ur = toBytes$2(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return assert$1.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert$1.exists(this), assert$1.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$2 = (cr, ar, lr) => new HMAC$2(cr, ar).update(lr).digest();
hmac$2.create = (cr, ar) => new HMAC$2(cr, ar);
function extract$1(cr, ar, lr) {
  return assert$1.hash(cr), lr === void 0 && (lr = new Uint8Array(cr.outputLen)), hmac$2(cr, toBytes$2(lr), toBytes$2(ar));
}
const HKDF_COUNTER$1 = new Uint8Array([0]), EMPTY_BUFFER$1 = new Uint8Array();
function expand$1(cr, ar, lr, ur = 32) {
  if (assert$1.hash(cr), assert$1.number(ur), ur > 255 * cr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const dr = Math.ceil(ur / cr.outputLen);
  lr === void 0 && (lr = EMPTY_BUFFER$1);
  const fr = new Uint8Array(dr * cr.outputLen), gr = hmac$2.create(cr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < dr; yr++)
    HKDF_COUNTER$1[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER$1 : vr).update(lr).update(HKDF_COUNTER$1).digestInto(vr), fr.set(vr, cr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER$1.fill(0), fr.slice(0, ur);
}
const hkdf = (cr, ar, lr, ur, dr) => expand$1(cr, extract$1(cr, ar, lr), ur, dr);
var __defProp$1 = Object.defineProperty, __export$1 = (cr, ar) => {
  for (var lr in ar)
    __defProp$1(cr, lr, { get: ar[lr], enumerable: !0 });
};
function getPublicKey(cr) {
  return bytesToHex$2(schnorr$1.getPublicKey(cr));
}
var utils_exports$1 = {};
__export$1(utils_exports$1, {
  MessageNode: () => MessageNode,
  MessageQueue: () => MessageQueue,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList$1,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList$1,
  normalizeURL: () => normalizeURL$1,
  utf8Decoder: () => utf8Decoder$1,
  utf8Encoder: () => utf8Encoder$1
});
var utf8Decoder$1 = new TextDecoder("utf-8"), utf8Encoder$1 = new TextEncoder();
function normalizeURL$1(cr) {
  let ar = new URL(cr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList$1(cr, ar) {
  var gr;
  let lr = 0, ur = cr.length - 1, dr, fr = lr;
  if (ur < 0)
    fr = 0;
  else if (ar.created_at < cr[ur].created_at)
    fr = ur + 1;
  else if (ar.created_at >= cr[lr].created_at)
    fr = lr;
  else
    for (; ; ) {
      if (ur <= lr + 1) {
        fr = ur;
        break;
      }
      if (dr = Math.floor(lr + (ur - lr) / 2), cr[dr].created_at > ar.created_at)
        lr = dr;
      else if (cr[dr].created_at < ar.created_at)
        ur = dr;
      else {
        fr = dr;
        break;
      }
    }
  return ((gr = cr[fr]) == null ? void 0 : gr.id) !== ar.id ? [...cr.slice(0, fr), ar, ...cr.slice(fr)] : cr;
}
function insertEventIntoAscendingList$1(cr, ar) {
  var gr;
  let lr = 0, ur = cr.length - 1, dr, fr = lr;
  if (ur < 0)
    fr = 0;
  else if (ar.created_at > cr[ur].created_at)
    fr = ur + 1;
  else if (ar.created_at <= cr[lr].created_at)
    fr = lr;
  else
    for (; ; ) {
      if (ur <= lr + 1) {
        fr = ur;
        break;
      }
      if (dr = Math.floor(lr + (ur - lr) / 2), cr[dr].created_at < ar.created_at)
        lr = dr;
      else if (cr[dr].created_at > ar.created_at)
        ur = dr;
      else {
        fr = dr;
        break;
      }
    }
  return ((gr = cr[fr]) == null ? void 0 : gr.id) !== ar.id ? [...cr.slice(0, fr), ar, ...cr.slice(fr)] : cr;
}
var MessageNode = class {
  constructor(cr) {
    ti(this, "_value");
    ti(this, "_next");
    this._value = cr, this._next = null;
  }
  get value() {
    return this._value;
  }
  set value(cr) {
    this._value = cr;
  }
  get next() {
    return this._next;
  }
  set next(cr) {
    this._next = cr;
  }
}, MessageQueue = class {
  constructor() {
    ti(this, "_first");
    ti(this, "_last");
    ti(this, "_size");
    this._first = null, this._last = null, this._size = 0;
  }
  get first() {
    return this._first;
  }
  set first(cr) {
    this._first = cr;
  }
  get last() {
    return this._last;
  }
  set last(cr) {
    this._last = cr;
  }
  get size() {
    return this._size;
  }
  set size(cr) {
    this._size = cr;
  }
  enqueue(cr) {
    const ar = new MessageNode(cr);
    return this._size === 0 || !this._last ? (this._first = ar, this._last = ar) : (this._last.next = ar, this._last = ar), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    let cr = this._first;
    return this._first = cr.next, cr.next = null, this._size--, cr.value;
  }
}, verifiedSymbol$1 = Symbol("verified");
function getBlankEvent(cr = 255) {
  return {
    kind: cr,
    content: "",
    tags: [],
    created_at: 0
  };
}
function finishEvent(cr, ar) {
  const lr = cr;
  return lr.pubkey = getPublicKey(ar), lr.id = getEventHash$1(lr), lr.sig = getSignature(lr, ar), lr[verifiedSymbol$1] = !0, lr;
}
function serializeEvent$1(cr) {
  if (!validateEvent$1(cr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, cr.pubkey, cr.created_at, cr.kind, cr.tags, cr.content]);
}
function getEventHash$1(cr) {
  let ar = sha256$2(utf8Encoder$1.encode(serializeEvent$1(cr)));
  return bytesToHex$2(ar);
}
var isRecord$1 = (cr) => cr instanceof Object;
function validateEvent$1(cr) {
  if (!isRecord$1(cr) || typeof cr.kind != "number" || typeof cr.content != "string" || typeof cr.created_at != "number" || typeof cr.pubkey != "string" || !cr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(cr.tags))
    return !1;
  for (let ar = 0; ar < cr.tags.length; ar++) {
    let lr = cr.tags[ar];
    if (!Array.isArray(lr))
      return !1;
    for (let ur = 0; ur < lr.length; ur++)
      if (typeof lr[ur] == "object")
        return !1;
  }
  return !0;
}
function verifySignature(cr) {
  if (typeof cr[verifiedSymbol$1] == "boolean")
    return cr[verifiedSymbol$1];
  const ar = getEventHash$1(cr);
  if (ar !== cr.id)
    return cr[verifiedSymbol$1] = !1;
  try {
    return cr[verifiedSymbol$1] = schnorr$1.verify(cr.sig, ar, cr.pubkey);
  } catch (lr) {
    return cr[verifiedSymbol$1] = !1;
  }
}
function getSignature(cr, ar) {
  return bytesToHex$2(schnorr$1.sign(getEventHash$1(cr), ar));
}
function matchFilter(cr, ar) {
  if (cr.ids && cr.ids.indexOf(ar.id) === -1 && !cr.ids.some((lr) => ar.id.startsWith(lr)) || cr.kinds && cr.kinds.indexOf(ar.kind) === -1 || cr.authors && cr.authors.indexOf(ar.pubkey) === -1 && !cr.authors.some((lr) => ar.pubkey.startsWith(lr)))
    return !1;
  for (let lr in cr)
    if (lr[0] === "#") {
      let ur = lr.slice(1), dr = cr[`#${ur}`];
      if (dr && !ar.tags.find(([fr, gr]) => fr === lr.slice(1) && dr.indexOf(gr) !== -1))
        return !1;
    }
  return !(cr.since && ar.created_at < cr.since || cr.until && ar.created_at > cr.until);
}
var fakejson_exports$1 = {};
__export$1(fakejson_exports$1, {
  getHex64: () => getHex64$1,
  getInt: () => getInt$1,
  getSubscriptionId: () => getSubscriptionId$1,
  matchEventId: () => matchEventId$1,
  matchEventKind: () => matchEventKind$1,
  matchEventPubkey: () => matchEventPubkey$1
});
function getHex64$1(cr, ar) {
  let lr = ar.length + 3, ur = cr.indexOf(`"${ar}":`) + lr, dr = cr.slice(ur).indexOf('"') + ur + 1;
  return cr.slice(dr, dr + 64);
}
function getInt$1(cr, ar) {
  let lr = ar.length, ur = cr.indexOf(`"${ar}":`) + lr + 3, dr = cr.slice(ur), fr = Math.min(dr.indexOf(","), dr.indexOf("}"));
  return parseInt(dr.slice(0, fr), 10);
}
function getSubscriptionId$1(cr) {
  let ar = cr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let lr = cr.slice(ar + 7 + 1).indexOf('"');
  if (lr === -1)
    return null;
  let ur = ar + 7 + 1 + lr, dr = cr.slice(ur + 1, 80).indexOf('"');
  if (dr === -1)
    return null;
  let fr = ur + 1 + dr;
  return cr.slice(ur + 1, fr);
}
function matchEventId$1(cr, ar) {
  return ar === getHex64$1(cr, "id");
}
function matchEventPubkey$1(cr, ar) {
  return ar === getHex64$1(cr, "pubkey");
}
function matchEventKind$1(cr, ar) {
  return ar === getInt$1(cr, "kind");
}
var nip19_exports$1 = {};
__export$1(nip19_exports$1, {
  BECH32_REGEX: () => BECH32_REGEX$1,
  decode: () => decode$2,
  naddrEncode: () => naddrEncode$1,
  neventEncode: () => neventEncode$1,
  noteEncode: () => noteEncode$1,
  nprofileEncode: () => nprofileEncode$1,
  npubEncode: () => npubEncode$1,
  nrelayEncode: () => nrelayEncode$1,
  nsecEncode: () => nsecEncode$1
});
var Bech32MaxSize$1 = 5e3, BECH32_REGEX$1 = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array$1(cr) {
  const ar = new Uint8Array(4);
  return ar[0] = cr >> 24 & 255, ar[1] = cr >> 16 & 255, ar[2] = cr >> 8 & 255, ar[3] = cr & 255, ar;
}
function decode$2(cr) {
  var dr, fr, gr, mr, vr, yr, _r, kr;
  let { prefix: ar, words: lr } = bech32$2.decode(cr, Bech32MaxSize$1), ur = new Uint8Array(bech32$2.fromWords(lr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV$1(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex$2(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$1.decode(Ar)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV$1(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex$2(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$1.decode(Ar)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex$2(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex$2(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV$1(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_r = xr[3]) != null && _r[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder$1.decode(xr[0][0]),
          pubkey: bytesToHex$2(xr[2][0]),
          kind: parseInt(bytesToHex$2(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder$1.decode(Ar)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV$1(ur);
      if (!((kr = xr[0]) != null && kr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder$1.decode(xr[0][0])
      };
    }
    case "nsec":
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex$2(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV$1(cr) {
  let ar = {}, lr = cr;
  for (; lr.length > 0; ) {
    let ur = lr[0], dr = lr[1];
    if (!dr)
      throw new Error(`malformed TLV ${ur}`);
    let fr = lr.slice(2, 2 + dr);
    if (lr = lr.slice(2 + dr), fr.length < dr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(fr);
  }
  return ar;
}
function nsecEncode$1(cr) {
  return encodeBytes$1("nsec", cr);
}
function npubEncode$1(cr) {
  return encodeBytes$1("npub", cr);
}
function noteEncode$1(cr) {
  return encodeBytes$1("note", cr);
}
function encodeBech32$1(cr, ar) {
  let lr = bech32$2.toWords(ar);
  return bech32$2.encode(cr, lr, Bech32MaxSize$1);
}
function encodeBytes$1(cr, ar) {
  let lr = hexToBytes$3(ar);
  return encodeBech32$1(cr, lr);
}
function nprofileEncode$1(cr) {
  let ar = encodeTLV$1({
    0: [hexToBytes$3(cr.pubkey)],
    1: (cr.relays || []).map((lr) => utf8Encoder$1.encode(lr))
  });
  return encodeBech32$1("nprofile", ar);
}
function neventEncode$1(cr) {
  let ar;
  cr.kind != null && (ar = integerToUint8Array$1(cr.kind));
  let lr = encodeTLV$1({
    0: [hexToBytes$3(cr.id)],
    1: (cr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: cr.author ? [hexToBytes$3(cr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32$1("nevent", lr);
}
function naddrEncode$1(cr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, cr.kind, !1);
  let lr = encodeTLV$1({
    0: [utf8Encoder$1.encode(cr.identifier)],
    1: (cr.relays || []).map((ur) => utf8Encoder$1.encode(ur)),
    2: [hexToBytes$3(cr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32$1("naddr", lr);
}
function nrelayEncode$1(cr) {
  let ar = encodeTLV$1({
    0: [utf8Encoder$1.encode(cr)]
  });
  return encodeBech32$1("nrelay", ar);
}
function encodeTLV$1(cr) {
  let ar = [];
  return Object.entries(cr).forEach(([lr, ur]) => {
    ur.forEach((dr) => {
      let fr = new Uint8Array(dr.length + 2);
      fr.set([parseInt(lr)], 0), fr.set([dr.length], 1), fr.set(dr, 2), ar.push(fr);
    });
  }), concatBytes$3(...ar);
}
var nip04_exports$1 = {};
__export$1(nip04_exports$1, {
  decrypt: () => decrypt$1,
  encrypt: () => encrypt$1
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt$1(cr, ar, lr) {
  const ur = secp256k1$1.getSharedSecret(cr, "02" + ar), dr = getNormalizedX$1(ur);
  let fr = Uint8Array.from(randomBytes$2(16)), gr = utf8Encoder$1.encode(lr), mr = await crypto.subtle.importKey("raw", dr, { name: "AES-CBC" }, !1, ["encrypt"]), vr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: fr }, mr, gr), yr = base64$1.encode(new Uint8Array(vr)), _r = base64$1.encode(new Uint8Array(fr.buffer));
  return `${yr}?iv=${_r}`;
}
async function decrypt$1(cr, ar, lr) {
  let [ur, dr] = lr.split("?iv="), fr = secp256k1$1.getSharedSecret(cr, "02" + ar), gr = getNormalizedX$1(fr), mr = await crypto.subtle.importKey("raw", gr, { name: "AES-CBC" }, !1, ["decrypt"]), vr = base64$1.decode(ur), yr = base64$1.decode(dr), _r = await crypto.subtle.decrypt({ name: "AES-CBC", iv: yr }, mr, vr);
  return utf8Decoder$1.decode(_r);
}
function getNormalizedX$1(cr) {
  return cr.slice(1, 33);
}
var nip05_exports$1 = {};
__export$1(nip05_exports$1, {
  NIP05_REGEX: () => NIP05_REGEX$1,
  queryProfile: () => queryProfile$1,
  searchDomain: () => searchDomain$1,
  useFetchImplementation: () => useFetchImplementation$1
});
var NIP05_REGEX$1 = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch$1;
try {
  _fetch$1 = fetch;
} catch (cr) {
}
function useFetchImplementation$1(cr) {
  _fetch$1 = cr;
}
async function searchDomain$1(cr, ar = "") {
  try {
    return (await (await _fetch$1(`https://${cr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (lr) {
    return {};
  }
}
async function queryProfile$1(cr) {
  const ar = cr.match(NIP05_REGEX$1);
  if (!ar)
    return null;
  const [lr, ur = "_", dr] = ar;
  try {
    const fr = await _fetch$1(`https://${dr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result$1(await fr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (fr) {
    return null;
  }
}
function parseNIP05Result$1(cr) {
  const ar = {
    names: {}
  };
  for (const [lr, ur] of Object.entries(cr.names))
    typeof lr == "string" && typeof ur == "string" && (ar.names[lr] = ur);
  if (cr.relays) {
    ar.relays = {};
    for (const [lr, ur] of Object.entries(cr.relays))
      typeof lr == "string" && Array.isArray(ur) && (ar.relays[lr] = ur.filter((dr) => typeof dr == "string"));
  }
  return ar;
}
var nip06_exports = {};
__export$1(nip06_exports, {
  generateSeedWords: () => generateSeedWords,
  privateKeyFromSeedWords: () => privateKeyFromSeedWords,
  validateWords: () => validateWords
});
function privateKeyFromSeedWords(cr, ar) {
  let ur = HDKey.fromMasterSeed(mnemonicToSeedSync(cr, ar)).derive("m/44'/1237'/0'/0/0").privateKey;
  if (!ur)
    throw new Error("could not derive private key");
  return bytesToHex$2(ur);
}
function generateSeedWords() {
  return generateMnemonic(wordlist);
}
function validateWords(cr) {
  return validateMnemonic(cr, wordlist);
}
var nip10_exports$1 = {};
__export$1(nip10_exports$1, {
  parse: () => parse$1
});
function parse$1(cr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, lr = [];
  for (const ur of cr.tags)
    ur[0] === "e" && ur[1] && lr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = lr[ur], [fr, gr, mr, vr] = dr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, _r = ur === 0, kr = ur === lr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (_r) {
      ar.root = yr;
      continue;
    }
    if (kr) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip13_exports$1 = {};
__export$1(nip13_exports$1, {
  getPow: () => getPow$1,
  minePow: () => minePow$1
});
function getPow$1(cr) {
  let ar = 0;
  for (let lr = 0; lr < cr.length; lr++) {
    const ur = parseInt(cr[lr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow$1(cr, ar) {
  let lr = 0;
  const ur = cr, dr = ["nonce", lr.toString(), ar.toString()];
  for (ur.tags.push(dr); ; ) {
    const fr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (fr !== ur.created_at && (lr = 0, ur.created_at = fr), dr[1] = (++lr).toString(), ur.id = getEventHash$1(ur), getPow$1(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports$1 = {};
__export$1(nip18_exports$1, {
  finishRepostEvent: () => finishRepostEvent$1,
  getRepostedEvent: () => getRepostedEvent$1,
  getRepostedEventPointer: () => getRepostedEventPointer$1
});
function finishRepostEvent$1(cr, ar, lr, ur) {
  var dr;
  return finishEvent(
    {
      kind: 6,
      tags: [...(dr = cr.tags) != null ? dr : [], ["e", ar.id, lr], ["p", ar.pubkey]],
      content: cr.content === "" ? "" : JSON.stringify(ar),
      created_at: cr.created_at
    },
    ur
  );
}
function getRepostedEventPointer$1(cr) {
  if (cr.kind !== 6)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], lr == null ? void 0 : lr[2]].filter((ur) => typeof ur == "string"),
      author: lr == null ? void 0 : lr[1]
    };
}
function getRepostedEvent$1(cr, { skipVerification: ar } = {}) {
  const lr = getRepostedEventPointer$1(cr);
  if (lr === void 0 || cr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(cr.content);
  } catch (dr) {
    return;
  }
  if (ur.id === lr.id && !(!ar && !verifySignature(ur)))
    return ur;
}
var nip21_exports$1 = {};
__export$1(nip21_exports$1, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX$1,
  parse: () => parse2$1,
  test: () => test$1
});
var NOSTR_URI_REGEX$1 = new RegExp(`nostr:(${BECH32_REGEX$1.source})`);
function test$1(cr) {
  return typeof cr == "string" && new RegExp(`^${NOSTR_URI_REGEX$1.source}$`).test(cr);
}
function parse2$1(cr) {
  const ar = cr.match(new RegExp(`^${NOSTR_URI_REGEX$1.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${cr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$2(ar[1])
  };
}
var nip25_exports$1 = {};
__export$1(nip25_exports$1, {
  finishReactionEvent: () => finishReactionEvent$1,
  getReactedEventPointer: () => getReactedEventPointer$1
});
function finishReactionEvent$1(cr, ar, lr) {
  var dr, fr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finishEvent(
    {
      ...cr,
      kind: 7,
      tags: [...(dr = cr.tags) != null ? dr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (fr = cr.content) != null ? fr : "+"
    },
    lr
  );
}
function getReactedEventPointer$1(cr) {
  if (cr.kind !== 7)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (!(ar === void 0 || lr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], lr[2]].filter((ur) => ur !== void 0),
      author: lr[1]
    };
}
var nip26_exports = {};
__export$1(nip26_exports, {
  createDelegation: () => createDelegation,
  getDelegator: () => getDelegator
});
function createDelegation(cr, ar) {
  let lr = [];
  (ar.kind || -1) >= 0 && lr.push(`kind=${ar.kind}`), ar.until && lr.push(`created_at<${ar.until}`), ar.since && lr.push(`created_at>${ar.since}`);
  let ur = lr.join("&");
  if (ur === "")
    throw new Error("refusing to create a delegation without any conditions");
  let dr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${ar.pubkey}:${ur}`)), fr = bytesToHex$2(schnorr$1.sign(dr, cr));
  return {
    from: getPublicKey(cr),
    to: ar.pubkey,
    cond: ur,
    sig: fr
  };
}
function getDelegator(cr) {
  let ar = cr.tags.find((mr) => mr[0] === "delegation" && mr.length >= 4);
  if (!ar)
    return null;
  let lr = ar[1], ur = ar[2], dr = ar[3], fr = ur.split("&");
  for (let mr = 0; mr < fr.length; mr++) {
    let [vr, yr, _r] = fr[mr].split(/\b/);
    if (!(vr === "kind" && yr === "=" && cr.kind === parseInt(_r))) {
      if (vr === "created_at" && yr === "<" && cr.created_at < parseInt(_r))
        continue;
      if (vr === "created_at" && yr === ">" && cr.created_at > parseInt(_r))
        continue;
      return null;
    }
  }
  let gr = sha256$2(utf8Encoder$1.encode(`nostr:delegation:${cr.pubkey}:${ur}`));
  return schnorr$1.verify(dr, gr, lr) ? lr : null;
}
var nip27_exports$1 = {};
__export$1(nip27_exports$1, {
  matchAll: () => matchAll$1,
  regex: () => regex$1,
  replaceAll: () => replaceAll$1
});
var regex$1 = () => new RegExp(`\\b${NOSTR_URI_REGEX$1.source}\\b`, "g");
function* matchAll$1(cr) {
  const ar = cr.matchAll(regex$1());
  for (const lr of ar)
    try {
      const [ur, dr] = lr;
      yield {
        uri: ur,
        value: dr,
        decoded: decode$2(dr),
        start: lr.index,
        end: lr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll$1(cr, ar) {
  return cr.replaceAll(regex$1(), (lr, ur) => ar({
    uri: lr,
    value: ur,
    decoded: decode$2(ur)
  }));
}
var nip28_exports$1 = {};
__export$1(nip28_exports$1, {
  channelCreateEvent: () => channelCreateEvent$1,
  channelHideMessageEvent: () => channelHideMessageEvent$1,
  channelMessageEvent: () => channelMessageEvent$1,
  channelMetadataEvent: () => channelMetadataEvent$1,
  channelMuteUserEvent: () => channelMuteUserEvent$1
});
var channelCreateEvent$1 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent(
    {
      kind: 40,
      tags: [...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMetadataEvent$1 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent(
    {
      kind: 41,
      tags: [["e", cr.channel_create_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMessageEvent$1 = (cr, ar) => {
  var ur;
  const lr = [["e", cr.channel_create_event_id, cr.relay_url, "root"]];
  return cr.reply_to_channel_message_event_id && lr.push(["e", cr.reply_to_channel_message_event_id, cr.relay_url, "reply"]), finishEvent(
    {
      kind: 42,
      tags: [...lr, ...(ur = cr.tags) != null ? ur : []],
      content: cr.content,
      created_at: cr.created_at
    },
    ar
  );
}, channelHideMessageEvent$1 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent(
    {
      kind: 43,
      tags: [["e", cr.channel_message_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMuteUserEvent$1 = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finishEvent(
    {
      kind: 44,
      tags: [["p", cr.pubkey_to_mute], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, nip39_exports$1 = {};
__export$1(nip39_exports$1, {
  useFetchImplementation: () => useFetchImplementation2$1,
  validateGithub: () => validateGithub$1
});
var _fetch2$1;
try {
  _fetch2$1 = fetch;
} catch (cr) {
}
function useFetchImplementation2$1(cr) {
  _fetch2$1 = cr;
}
async function validateGithub$1(cr, ar, lr) {
  try {
    return await (await _fetch2$1(`https://gist.github.com/${ar}/${lr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${cr}`;
  } catch (ur) {
    return !1;
  }
}
var nip42_exports$1 = {};
__export$1(nip42_exports$1, {
  authenticate: () => authenticate
});
var authenticate = async ({
  challenge: cr,
  relay: ar,
  sign: lr
}) => {
  const ur = {
    kind: 22242,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", ar.url],
      ["challenge", cr]
    ],
    content: ""
  };
  return ar.auth(await lr(ur));
}, nip44_exports$1 = {};
__export$1(nip44_exports$1, {
  decrypt: () => decrypt2$1,
  encrypt: () => encrypt2$1,
  utils: () => utils$1
});
var utils$1 = {
  v2: {
    maxPlaintextSize: 65536 - 128,
    minCiphertextSize: 100,
    maxCiphertextSize: 102400,
    getConversationKey(cr, ar) {
      return secp256k1$1.getSharedSecret(cr, "02" + ar).subarray(1, 33);
    },
    getMessageKeys(cr, ar) {
      const lr = hkdf(sha256$2, cr, ar, "nip44-v2", 76);
      return {
        encryption: lr.subarray(0, 32),
        nonce: lr.subarray(32, 44),
        auth: lr.subarray(44, 76)
      };
    },
    calcPadding(cr) {
      if (!Number.isSafeInteger(cr) || cr < 0)
        throw new Error("expected positive integer");
      if (cr <= 32)
        return 32;
      const ar = 1 << Math.floor(Math.log2(cr - 1)) + 1, lr = ar <= 256 ? 32 : ar / 8;
      return lr * (Math.floor((cr - 1) / lr) + 1);
    },
    pad(cr) {
      const ar = utf8Encoder$1.encode(cr), lr = ar.length;
      if (lr < 1 || lr >= utils$1.v2.maxPlaintextSize)
        throw new Error("invalid plaintext length: must be between 1b and 64KB");
      const ur = utils$1.v2.calcPadding(lr), dr = new Uint8Array(ur - lr), fr = new Uint8Array(2);
      return new DataView(fr.buffer).setUint16(0, lr), concatBytes$3(fr, ar, dr);
    },
    unpad(cr) {
      const ar = new DataView(cr.buffer).getUint16(0), lr = cr.subarray(2, 2 + ar);
      if (ar === 0 || lr.length !== ar || cr.length !== 2 + utils$1.v2.calcPadding(ar))
        throw new Error("invalid padding");
      return utf8Decoder$1.decode(lr);
    }
  }
};
function encrypt2$1(cr, ar, lr = {}) {
  var yr, _r;
  const ur = (yr = lr.version) != null ? yr : 2;
  if (ur !== 2)
    throw new Error("unknown encryption version " + ur);
  const dr = (_r = lr.salt) != null ? _r : randomBytes$2(32);
  ensureBytes$1(dr, 32);
  const fr = utils$1.v2.getMessageKeys(cr, dr), gr = utils$1.v2.pad(ar), mr = chacha20(fr.encryption, fr.nonce, gr), vr = hmac$2(sha256$2, fr.auth, mr);
  return base64$1.encode(concatBytes$3(new Uint8Array([ur]), dr, mr, vr));
}
function decrypt2$1(cr, ar) {
  const lr = utils$1.v2;
  ensureBytes$1(cr, 32);
  const ur = ar.length;
  if (ur < lr.minCiphertextSize || ur >= lr.maxCiphertextSize)
    throw new Error("invalid ciphertext length: " + ur);
  if (ar[0] === "#")
    throw new Error("unknown encryption version");
  let dr;
  try {
    dr = base64$1.decode(ar);
  } catch (xr) {
    throw new Error("invalid base64: " + xr.message);
  }
  const fr = dr.subarray(0, 1)[0];
  if (fr !== 2)
    throw new Error("unknown encryption version " + fr);
  const gr = dr.subarray(1, 33), mr = dr.subarray(33, -32), vr = dr.subarray(-32), yr = lr.getMessageKeys(cr, gr), _r = hmac$2(sha256$2, yr.auth, mr);
  if (!equalBytes$1(_r, vr))
    throw new Error("invalid MAC");
  const kr = chacha20(yr.encryption, yr.nonce, mr);
  return lr.unpad(kr);
}
var nip47_exports$1 = {};
__export$1(nip47_exports$1, {
  makeNwcRequestEvent: () => makeNwcRequestEvent$1,
  parseConnectionString: () => parseConnectionString$1
});
function parseConnectionString$1(cr) {
  const { pathname: ar, searchParams: lr } = new URL(cr), ur = ar, dr = lr.get("relay"), fr = lr.get("secret");
  if (!ur || !dr || !fr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: dr, secret: fr };
}
async function makeNwcRequestEvent$1({
  pubkey: cr,
  secret: ar,
  invoice: lr
}) {
  const dr = await encrypt$1(ar, cr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: lr
    }
  })), fr = {
    kind: 23194,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [["p", cr]]
  };
  return finishEvent(fr, ar);
}
var nip57_exports$1 = {};
__export$1(nip57_exports$1, {
  getZapEndpoint: () => getZapEndpoint$1,
  makeZapReceipt: () => makeZapReceipt$1,
  makeZapRequest: () => makeZapRequest$1,
  useFetchImplementation: () => useFetchImplementation3$1,
  validateZapRequest: () => validateZapRequest$1
});
var _fetch3$1;
try {
  _fetch3$1 = fetch;
} catch (cr) {
}
function useFetchImplementation3$1(cr) {
  _fetch3$1 = cr;
}
async function getZapEndpoint$1(cr) {
  try {
    let ar = "", { lud06: lr, lud16: ur } = JSON.parse(cr.content);
    if (lr) {
      let { words: gr } = bech32$2.decode(lr, 1e3), mr = bech32$2.fromWords(gr);
      ar = utf8Decoder$1.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = `https://${mr}/.well-known/lnurlp/${gr}`;
    } else
      return null;
    let fr = await (await _fetch3$1(ar)).json();
    if (fr.allowsNostr && fr.nostrPubkey)
      return fr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest$1({
  profile: cr,
  event: ar,
  amount: lr,
  relays: ur,
  comment: dr = ""
}) {
  if (!lr)
    throw new Error("amount not given");
  if (!cr)
    throw new Error("profile not given");
  let fr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [
      ["p", cr],
      ["amount", lr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && fr.tags.push(["e", ar]), fr;
}
function validateZapRequest$1(cr) {
  let ar;
  try {
    ar = JSON.parse(cr);
  } catch (fr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent$1(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifySignature(ar))
    return "Invalid signature on zap request.";
  let lr = ar.tags.find(([fr, gr]) => fr === "p" && gr);
  if (!lr)
    return "Zap request doesn't have a 'p' tag.";
  if (!lr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([fr, gr]) => fr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([fr, gr]) => fr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt$1({
  zapRequest: cr,
  preimage: ar,
  bolt11: lr,
  paidAt: ur
}) {
  let fr = JSON.parse(cr).tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...fr, ["bolt11", lr], ["description", cr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports$1 = {};
__export$1(nip98_exports$1, {
  getToken: () => getToken$1,
  unpackEventFromToken: () => unpackEventFromToken$1,
  validateEvent: () => validateEvent2$1,
  validateToken: () => validateToken$1
});
var _authorizationScheme$1 = "Nostr ";
async function getToken$1(cr, ar, lr, ur = !1) {
  if (!cr || !ar)
    throw new Error("Missing loginUrl or httpMethod");
  const dr = getBlankEvent(
    27235
    /* HttpAuth */
  );
  dr.tags = [
    ["u", cr],
    ["method", ar]
  ], dr.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const fr = await lr(dr);
  return (ur ? _authorizationScheme$1 : "") + base64$1.encode(utf8Encoder$1.encode(JSON.stringify(fr)));
}
async function validateToken$1(cr, ar, lr) {
  const ur = await unpackEventFromToken$1(cr).catch((fr) => {
    throw fr;
  });
  return await validateEvent2$1(ur, ar, lr).catch((fr) => {
    throw fr;
  });
}
async function unpackEventFromToken$1(cr) {
  if (!cr)
    throw new Error("Missing token");
  cr = cr.replace(_authorizationScheme$1, "");
  const ar = utf8Decoder$1.decode(base64$1.decode(cr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
async function validateEvent2$1(cr, ar, lr) {
  if (!cr)
    throw new Error("Invalid nostr event");
  if (!verifySignature(cr))
    throw new Error("Invalid nostr event, signature invalid");
  if (cr.kind !== 27235)
    throw new Error("Invalid nostr event, kind invalid");
  if (!cr.created_at)
    throw new Error("Invalid nostr event, created_at invalid");
  if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - cr.created_at > 60)
    throw new Error("Invalid nostr event, expired");
  const ur = cr.tags.find((fr) => fr[0] === "u");
  if ((ur == null ? void 0 : ur.length) !== 1 && (ur == null ? void 0 : ur[1]) !== ar)
    throw new Error("Invalid nostr event, url tag invalid");
  const dr = cr.tags.find((fr) => fr[0] === "method");
  if ((dr == null ? void 0 : dr.length) !== 1 && (dr == null ? void 0 : dr[1].toLowerCase()) !== lr.toLowerCase())
    throw new Error("Invalid nostr event, method tag invalid");
  return !0;
}
const e = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : global, t = Object.keys, n = Array.isArray;
function r(cr, ar) {
  return typeof ar != "object" || t(ar).forEach(function(lr) {
    cr[lr] = ar[lr];
  }), cr;
}
typeof Promise == "undefined" || e.Promise || (e.Promise = Promise);
const s = Object.getPrototypeOf, i$2 = {}.hasOwnProperty;
function o(cr, ar) {
  return i$2.call(cr, ar);
}
function a(cr, ar) {
  typeof ar == "function" && (ar = ar(s(cr))), (typeof Reflect == "undefined" ? t : Reflect.ownKeys)(ar).forEach((lr) => {
    l(cr, lr, ar[lr]);
  });
}
const u$1 = Object.defineProperty;
function l(cr, ar, lr, ur) {
  u$1(cr, ar, r(lr && o(lr, "get") && typeof lr.get == "function" ? { get: lr.get, set: lr.set, configurable: !0 } : { value: lr, configurable: !0, writable: !0 }, ur));
}
function c(cr) {
  return { from: function(ar) {
    return cr.prototype = Object.create(ar.prototype), l(cr.prototype, "constructor", cr), { extend: a.bind(null, cr.prototype) };
  } };
}
const h$1 = Object.getOwnPropertyDescriptor;
function d(cr, ar) {
  let lr;
  return h$1(cr, ar) || (lr = s(cr)) && d(lr, ar);
}
const f = [].slice;
function p(cr, ar, lr) {
  return f.call(cr, ar, lr);
}
function y(cr, ar) {
  return ar(cr);
}
function m(cr) {
  if (!cr)
    throw new Error("Assertion Failed");
}
function v(cr) {
  e.setImmediate ? setImmediate(cr) : setTimeout(cr, 0);
}
function g(cr, ar) {
  return cr.reduce((lr, ur, dr) => {
    var fr = ar(ur, dr);
    return fr && (lr[fr[0]] = fr[1]), lr;
  }, {});
}
function b(cr, ar) {
  if (o(cr, ar))
    return cr[ar];
  if (!ar)
    return cr;
  if (typeof ar != "string") {
    for (var lr = [], ur = 0, dr = ar.length; ur < dr; ++ur) {
      var fr = b(cr, ar[ur]);
      lr.push(fr);
    }
    return lr;
  }
  var gr = ar.indexOf(".");
  if (gr !== -1) {
    var mr = cr[ar.substr(0, gr)];
    return mr === void 0 ? void 0 : b(mr, ar.substr(gr + 1));
  }
}
function _(cr, ar, lr) {
  if (cr && ar !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(cr)))
    if (typeof ar != "string" && "length" in ar) {
      m(typeof lr != "string" && "length" in lr);
      for (var ur = 0, dr = ar.length; ur < dr; ++ur)
        _(cr, ar[ur], lr[ur]);
    } else {
      var fr = ar.indexOf(".");
      if (fr !== -1) {
        var gr = ar.substr(0, fr), mr = ar.substr(fr + 1);
        if (mr === "")
          lr === void 0 ? n(cr) && !isNaN(parseInt(gr)) ? cr.splice(gr, 1) : delete cr[gr] : cr[gr] = lr;
        else {
          var vr = cr[gr];
          vr && o(cr, gr) || (vr = cr[gr] = {}), _(vr, mr, lr);
        }
      } else
        lr === void 0 ? n(cr) && !isNaN(parseInt(ar)) ? cr.splice(ar, 1) : delete cr[ar] : cr[ar] = lr;
    }
}
function w(cr) {
  var ar = {};
  for (var lr in cr)
    o(cr, lr) && (ar[lr] = cr[lr]);
  return ar;
}
const x = [].concat;
function k(cr) {
  return x.apply([], cr);
}
const E = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k([8, 16, 32, 64].map((cr) => ["Int", "Uint", "Float"].map((ar) => ar + cr + "Array")))).filter((cr) => e[cr]), P = E.map((cr) => e[cr]);
g(E, (cr) => [cr, !0]);
let K = null;
function O(cr) {
  K = typeof WeakMap != "undefined" && /* @__PURE__ */ new WeakMap();
  const ar = S(cr);
  return K = null, ar;
}
function S(cr) {
  if (!cr || typeof cr != "object")
    return cr;
  let ar = K && K.get(cr);
  if (ar)
    return ar;
  if (n(cr)) {
    ar = [], K && K.set(cr, ar);
    for (var lr = 0, ur = cr.length; lr < ur; ++lr)
      ar.push(S(cr[lr]));
  } else if (P.indexOf(cr.constructor) >= 0)
    ar = cr;
  else {
    const fr = s(cr);
    for (var dr in ar = fr === Object.prototype ? {} : Object.create(fr), K && K.set(cr, ar), cr)
      o(cr, dr) && (ar[dr] = S(cr[dr]));
  }
  return ar;
}
const { toString: A } = {};
function C(cr) {
  return A.call(cr).slice(8, -1);
}
const j = typeof Symbol != "undefined" ? Symbol.iterator : "@@iterator", D = typeof j == "symbol" ? function(cr) {
  var ar;
  return cr != null && (ar = cr[j]) && ar.apply(cr);
} : function() {
  return null;
}, I = {};
function B(cr) {
  var ar, lr, ur, dr;
  if (arguments.length === 1) {
    if (n(cr))
      return cr.slice();
    if (this === I && typeof cr == "string")
      return [cr];
    if (dr = D(cr)) {
      for (lr = []; !(ur = dr.next()).done; )
        lr.push(ur.value);
      return lr;
    }
    if (cr == null)
      return [cr];
    if (typeof (ar = cr.length) == "number") {
      for (lr = new Array(ar); ar--; )
        lr[ar] = cr[ar];
      return lr;
    }
    return [cr];
  }
  for (ar = arguments.length, lr = new Array(ar); ar--; )
    lr[ar] = arguments[ar];
  return lr;
}
const T = typeof Symbol != "undefined" ? (cr) => cr[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var R = typeof location != "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function F(cr, ar) {
  R = cr, M = ar;
}
var M = () => !0;
const N = !new Error("").stack;
function q() {
  if (N)
    try {
      throw q.arguments, new Error();
    } catch (cr) {
      return cr;
    }
  return new Error();
}
function $(cr, ar) {
  var lr = cr.stack;
  return lr ? (ar = ar || 0, lr.indexOf(cr.name) === 0 && (ar += (cr.name + cr.message).split(`
`).length), lr.split(`
`).slice(ar).filter(M).map((ur) => `
` + ur).join("")) : "";
}
var U = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], L = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(U), V = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function W(cr, ar) {
  this._e = q(), this.name = cr, this.message = ar;
}
function Y(cr, ar) {
  return cr + ". Errors: " + Object.keys(ar).map((lr) => ar[lr].toString()).filter((lr, ur, dr) => dr.indexOf(lr) === ur).join(`
`);
}
function z(cr, ar, lr, ur) {
  this._e = q(), this.failures = ar, this.failedKeys = ur, this.successCount = lr, this.message = Y(cr, ar);
}
function G(cr, ar) {
  this._e = q(), this.name = "BulkError", this.failures = Object.keys(ar).map((lr) => ar[lr]), this.failuresByPos = ar, this.message = Y(cr, ar);
}
c(W).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), c(z).from(W), c(G).from(W);
var H = L.reduce((cr, ar) => (cr[ar] = ar + "Error", cr), {});
const Q = W;
var X = L.reduce((cr, ar) => {
  var lr = ar + "Error";
  function ur(dr, fr) {
    this._e = q(), this.name = lr, dr ? typeof dr == "string" ? (this.message = `${dr}${fr ? `
 ` + fr : ""}`, this.inner = fr || null) : typeof dr == "object" && (this.message = `${dr.name} ${dr.message}`, this.inner = dr) : (this.message = V[ar] || lr, this.inner = null);
  }
  return c(ur).from(Q), cr[ar] = ur, cr;
}, {});
X.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;
var J = U.reduce((cr, ar) => (cr[ar + "Error"] = X[ar], cr), {}), Z = L.reduce((cr, ar) => (["Syntax", "Type", "Range"].indexOf(ar) === -1 && (cr[ar + "Error"] = X[ar]), cr), {});
function ee$1() {
}
function te(cr) {
  return cr;
}
function ne$1(cr, ar) {
  return cr == null || cr === te ? ar : function(lr) {
    return ar(cr(lr));
  };
}
function re(cr, ar) {
  return function() {
    cr.apply(this, arguments), ar.apply(this, arguments);
  };
}
function se(cr, ar) {
  return cr === ee$1 ? ar : function() {
    var lr = cr.apply(this, arguments);
    lr !== void 0 && (arguments[0] = lr);
    var ur = this.onsuccess, dr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var fr = ar.apply(this, arguments);
    return ur && (this.onsuccess = this.onsuccess ? re(ur, this.onsuccess) : ur), dr && (this.onerror = this.onerror ? re(dr, this.onerror) : dr), fr !== void 0 ? fr : lr;
  };
}
function ie$2(cr, ar) {
  return cr === ee$1 ? ar : function() {
    cr.apply(this, arguments);
    var lr = this.onsuccess, ur = this.onerror;
    this.onsuccess = this.onerror = null, ar.apply(this, arguments), lr && (this.onsuccess = this.onsuccess ? re(lr, this.onsuccess) : lr), ur && (this.onerror = this.onerror ? re(ur, this.onerror) : ur);
  };
}
function oe(cr, ar) {
  return cr === ee$1 ? ar : function(lr) {
    var ur = cr.apply(this, arguments);
    r(lr, ur);
    var dr = this.onsuccess, fr = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var gr = ar.apply(this, arguments);
    return dr && (this.onsuccess = this.onsuccess ? re(dr, this.onsuccess) : dr), fr && (this.onerror = this.onerror ? re(fr, this.onerror) : fr), ur === void 0 ? gr === void 0 ? void 0 : gr : r(ur, gr);
  };
}
function ae(cr, ar) {
  return cr === ee$1 ? ar : function() {
    return ar.apply(this, arguments) !== !1 && cr.apply(this, arguments);
  };
}
function ue(cr, ar) {
  return cr === ee$1 ? ar : function() {
    var lr = cr.apply(this, arguments);
    if (lr && typeof lr.then == "function") {
      for (var ur = this, dr = arguments.length, fr = new Array(dr); dr--; )
        fr[dr] = arguments[dr];
      return lr.then(function() {
        return ar.apply(ur, fr);
      });
    }
    return ar.apply(this, arguments);
  };
}
Z.ModifyError = z, Z.DexieError = W, Z.BulkError = G;
var le$1 = {};
const ce = 100, [he, de, fe$1] = typeof Promise == "undefined" ? [] : (() => {
  let cr = Promise.resolve();
  if (typeof crypto == "undefined" || !crypto.subtle)
    return [cr, s(cr), cr];
  const ar = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [ar, s(ar), cr];
})(), pe = de && de.then, ye = he && he.constructor, me = !!fe$1;
var ve = !1, ge$2 = fe$1 ? () => {
  fe$1.then($e);
} : e.setImmediate ? setImmediate.bind(null, $e) : e.MutationObserver ? () => {
  var cr = document.createElement("div");
  new MutationObserver(() => {
    $e(), cr = null;
  }).observe(cr, { attributes: !0 }), cr.setAttribute("i", "1");
} : () => {
  setTimeout($e, 0);
}, be = function(cr, ar) {
  Se.push([cr, ar]), we && (ge$2(), we = !1);
}, _e = !0, we = !0, xe = [], ke = [], Ee = null, Pe = te, Ke = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: dt, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((cr) => {
    try {
      dt(cr[0], cr[1]);
    } catch (ar) {
    }
  });
} }, Oe = Ke, Se = [], Ae = 0, Ce = [];
function je(cr) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = ee$1, this._lib = !1;
  var ar = this._PSD = Oe;
  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), typeof cr != "function") {
    if (cr !== le$1)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Te(this, this._value));
  }
  this._state = null, this._value = null, ++ar.ref, Be(this, cr);
}
const De = { get: function() {
  var cr = Oe, ar = Xe;
  function lr(ur, dr) {
    var fr = !cr.global && (cr !== Oe || ar !== Xe);
    const gr = fr && !tt();
    var mr = new je((vr, yr) => {
      Fe(this, new Ie(lt$3(ur, cr, fr, gr), lt$3(dr, cr, fr, gr), vr, yr, cr));
    });
    return R && qe(mr, this), mr;
  }
  return lr.prototype = le$1, lr;
}, set: function(cr) {
  l(this, "then", cr && cr.prototype === le$1 ? De : { get: function() {
    return cr;
  }, set: De.set });
} };
function Ie(cr, ar, lr, ur, dr) {
  this.onFulfilled = typeof cr == "function" ? cr : null, this.onRejected = typeof ar == "function" ? ar : null, this.resolve = lr, this.reject = ur, this.psd = dr;
}
function Be(cr, ar) {
  try {
    ar((lr) => {
      if (cr._state === null) {
        if (lr === cr)
          throw new TypeError("A promise cannot be resolved with itself.");
        var ur = cr._lib && Ue();
        lr && typeof lr.then == "function" ? Be(cr, (dr, fr) => {
          lr instanceof je ? lr._then(dr, fr) : lr.then(dr, fr);
        }) : (cr._state = !0, cr._value = lr, Re$1(cr)), ur && Le();
      }
    }, Te.bind(null, cr));
  } catch (lr) {
    Te(cr, lr);
  }
}
function Te(cr, ar) {
  if (ke.push(ar), cr._state === null) {
    var lr = cr._lib && Ue();
    ar = Pe(ar), cr._state = !1, cr._value = ar, R && ar !== null && typeof ar == "object" && !ar._promise && function(ur, dr, fr) {
      try {
        ur.apply(null, fr);
      } catch (gr) {
        dr && dr(gr);
      }
    }(() => {
      var ur = d(ar, "stack");
      ar._promise = cr, l(ar, "stack", { get: () => ve ? ur && (ur.get ? ur.get.apply(ar) : ur.value) : cr.stack });
    }), function(ur) {
      xe.some((dr) => dr._value === ur._value) || xe.push(ur);
    }(cr), Re$1(cr), lr && Le();
  }
}
function Re$1(cr) {
  var ar = cr._listeners;
  cr._listeners = [];
  for (var lr = 0, ur = ar.length; lr < ur; ++lr)
    Fe(cr, ar[lr]);
  var dr = cr._PSD;
  --dr.ref || dr.finalize(), Ae === 0 && (++Ae, be(() => {
    --Ae == 0 && Ve();
  }, []));
}
function Fe(cr, ar) {
  if (cr._state !== null) {
    var lr = cr._state ? ar.onFulfilled : ar.onRejected;
    if (lr === null)
      return (cr._state ? ar.resolve : ar.reject)(cr._value);
    ++ar.psd.ref, ++Ae, be(Me, [lr, cr, ar]);
  } else
    cr._listeners.push(ar);
}
function Me(cr, ar, lr) {
  try {
    Ee = ar;
    var ur, dr = ar._value;
    ar._state ? ur = cr(dr) : (ke.length && (ke = []), ur = cr(dr), ke.indexOf(dr) === -1 && function(fr) {
      for (var gr = xe.length; gr; )
        if (xe[--gr]._value === fr._value)
          return void xe.splice(gr, 1);
    }(ar)), lr.resolve(ur);
  } catch (fr) {
    lr.reject(fr);
  } finally {
    Ee = null, --Ae == 0 && Ve(), --lr.psd.ref || lr.psd.finalize();
  }
}
function Ne(cr, ar, lr) {
  if (ar.length === lr)
    return ar;
  var ur = "";
  if (cr._state === !1) {
    var dr, fr, gr = cr._value;
    gr != null ? (dr = gr.name || "Error", fr = gr.message || gr, ur = $(gr, 0)) : (dr = gr, fr = ""), ar.push(dr + (fr ? ": " + fr : "") + ur);
  }
  return R && ((ur = $(cr._stackHolder, 2)) && ar.indexOf(ur) === -1 && ar.push(ur), cr._prev && Ne(cr._prev, ar, lr)), ar;
}
function qe(cr, ar) {
  var lr = ar ? ar._numPrev + 1 : 0;
  lr < 100 && (cr._prev = ar, cr._numPrev = lr);
}
function $e() {
  Ue() && Le();
}
function Ue() {
  var cr = _e;
  return _e = !1, we = !1, cr;
}
function Le() {
  var cr, ar, lr;
  do
    for (; Se.length > 0; )
      for (cr = Se, Se = [], lr = cr.length, ar = 0; ar < lr; ++ar) {
        var ur = cr[ar];
        ur[0].apply(null, ur[1]);
      }
  while (Se.length > 0);
  _e = !0, we = !0;
}
function Ve() {
  var cr = xe;
  xe = [], cr.forEach((ur) => {
    ur._PSD.onunhandled.call(null, ur._value, ur);
  });
  for (var ar = Ce.slice(0), lr = ar.length; lr; )
    ar[--lr]();
}
function We(cr) {
  return new je(le$1, !1, cr);
}
function Ye(cr, ar) {
  var lr = Oe;
  return function() {
    var ur = Ue(), dr = Oe;
    try {
      return it$1(lr, !0), cr.apply(this, arguments);
    } catch (fr) {
      ar && ar(fr);
    } finally {
      it$1(dr, !1), ur && Le();
    }
  };
}
a(je.prototype, { then: De, _then: function(cr, ar) {
  Fe(this, new Ie(null, null, cr, ar, Oe));
}, catch: function(cr) {
  if (arguments.length === 1)
    return this.then(null, cr);
  var ar = arguments[0], lr = arguments[1];
  return typeof ar == "function" ? this.then(null, (ur) => ur instanceof ar ? lr(ur) : We(ur)) : this.then(null, (ur) => ur && ur.name === ar ? lr(ur) : We(ur));
}, finally: function(cr) {
  return this.then((ar) => (cr(), ar), (ar) => (cr(), We(ar)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    ve = !0;
    var cr = Ne(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = cr), cr;
  } finally {
    ve = !1;
  }
} }, timeout: function(cr, ar) {
  return cr < 1 / 0 ? new je((lr, ur) => {
    var dr = setTimeout(() => ur(new X.Timeout(ar)), cr);
    this.then(lr, ur).finally(clearTimeout.bind(null, dr));
  }) : this;
} }), typeof Symbol != "undefined" && Symbol.toStringTag && l(je.prototype, Symbol.toStringTag, "Dexie.Promise"), Ke.env = ot(), a(je, { all: function() {
  var cr = B.apply(null, arguments).map(nt);
  return new je(function(ar, lr) {
    cr.length === 0 && ar([]);
    var ur = cr.length;
    cr.forEach((dr, fr) => je.resolve(dr).then((gr) => {
      cr[fr] = gr, --ur || ar(cr);
    }, lr));
  });
}, resolve: (cr) => {
  if (cr instanceof je)
    return cr;
  if (cr && typeof cr.then == "function")
    return new je((lr, ur) => {
      cr.then(lr, ur);
    });
  var ar = new je(le$1, !0, cr);
  return qe(ar, Ee), ar;
}, reject: We, race: function() {
  var cr = B.apply(null, arguments).map(nt);
  return new je((ar, lr) => {
    cr.map((ur) => je.resolve(ur).then(ar, lr));
  });
}, PSD: { get: () => Oe, set: (cr) => Oe = cr }, totalEchoes: { get: () => Xe }, newPSD: Ze, usePSD: at, scheduler: { get: () => be, set: (cr) => {
  be = cr;
} }, rejectionMapper: { get: () => Pe, set: (cr) => {
  Pe = cr;
} }, follow: (cr, ar) => new je((lr, ur) => Ze((dr, fr) => {
  var gr = Oe;
  gr.unhandleds = [], gr.onunhandled = fr, gr.finalize = re(function() {
    (function(mr) {
      function vr() {
        mr(), Ce.splice(Ce.indexOf(vr), 1);
      }
      Ce.push(vr), ++Ae, be(() => {
        --Ae == 0 && Ve();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? dr() : fr(this.unhandleds[0]);
    });
  }, gr.finalize), cr();
}, ar, lr, ur)) }), ye && (ye.allSettled && l(je, "allSettled", function() {
  const cr = B.apply(null, arguments).map(nt);
  return new je((ar) => {
    cr.length === 0 && ar([]);
    let lr = cr.length;
    const ur = new Array(lr);
    cr.forEach((dr, fr) => je.resolve(dr).then((gr) => ur[fr] = { status: "fulfilled", value: gr }, (gr) => ur[fr] = { status: "rejected", reason: gr }).then(() => --lr || ar(ur)));
  });
}), ye.any && typeof AggregateError != "undefined" && l(je, "any", function() {
  const cr = B.apply(null, arguments).map(nt);
  return new je((ar, lr) => {
    cr.length === 0 && lr(new AggregateError([]));
    let ur = cr.length;
    const dr = new Array(ur);
    cr.forEach((fr, gr) => je.resolve(fr).then((mr) => ar(mr), (mr) => {
      dr[gr] = mr, --ur || lr(new AggregateError(dr));
    }));
  });
}));
const ze = { awaits: 0, echoes: 0, id: 0 };
var Ge = 0, He = [], Qe = 0, Xe = 0, Je = 0;
function Ze(cr, ar, lr, ur) {
  var dr = Oe, fr = Object.create(dr);
  fr.parent = dr, fr.ref = 0, fr.global = !1, fr.id = ++Je;
  var gr = Ke.env;
  fr.env = me ? { Promise: je, PromiseProp: { value: je, configurable: !0, writable: !0 }, all: je.all, race: je.race, allSettled: je.allSettled, any: je.any, resolve: je.resolve, reject: je.reject, nthen: ct(gr.nthen, fr), gthen: ct(gr.gthen, fr) } : {}, ar && r(fr, ar), ++dr.ref, fr.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var mr = at(fr, cr, lr, ur);
  return fr.ref === 0 && fr.finalize(), mr;
}
function et() {
  return ze.id || (ze.id = ++Ge), ++ze.awaits, ze.echoes += ce, ze.id;
}
function tt() {
  return !!ze.awaits && (--ze.awaits == 0 && (ze.id = 0), ze.echoes = ze.awaits * ce, !0);
}
function nt(cr) {
  return ze.echoes && cr && cr.constructor === ye ? (et(), cr.then((ar) => (tt(), ar), (ar) => (tt(), ft(ar)))) : cr;
}
function rt(cr) {
  ++Xe, ze.echoes && --ze.echoes != 0 || (ze.echoes = ze.id = 0), He.push(Oe), it$1(cr, !0);
}
function st() {
  var cr = He[He.length - 1];
  He.pop(), it$1(cr, !1);
}
function it$1(cr, ar) {
  var lr = Oe;
  if ((ar ? !ze.echoes || Qe++ && cr === Oe : !Qe || --Qe && cr === Oe) || ut$1(ar ? rt.bind(null, cr) : st), cr !== Oe && (Oe = cr, lr === Ke && (Ke.env = ot()), me)) {
    var ur = Ke.env.Promise, dr = cr.env;
    de.then = dr.nthen, ur.prototype.then = dr.gthen, (lr.global || cr.global) && (Object.defineProperty(e, "Promise", dr.PromiseProp), ur.all = dr.all, ur.race = dr.race, ur.resolve = dr.resolve, ur.reject = dr.reject, dr.allSettled && (ur.allSettled = dr.allSettled), dr.any && (ur.any = dr.any));
  }
}
function ot() {
  var cr = e.Promise;
  return me ? { Promise: cr, PromiseProp: Object.getOwnPropertyDescriptor(e, "Promise"), all: cr.all, race: cr.race, allSettled: cr.allSettled, any: cr.any, resolve: cr.resolve, reject: cr.reject, nthen: de.then, gthen: cr.prototype.then } : {};
}
function at(cr, ar, lr, ur, dr) {
  var fr = Oe;
  try {
    return it$1(cr, !0), ar(lr, ur, dr);
  } finally {
    it$1(fr, !1);
  }
}
function ut$1(cr) {
  pe.call(he, cr);
}
function lt$3(cr, ar, lr, ur) {
  return typeof cr != "function" ? cr : function() {
    var dr = Oe;
    lr && et(), it$1(ar, !0);
    try {
      return cr.apply(this, arguments);
    } finally {
      it$1(dr, !1), ur && ut$1(tt);
    }
  };
}
function ct(cr, ar) {
  return function(lr, ur) {
    return cr.call(this, lt$3(lr, ar), lt$3(ur, ar));
  };
}
("" + pe).indexOf("[native code]") === -1 && (et = tt = ee$1);
const ht = "unhandledrejection";
function dt(cr, ar) {
  var lr;
  try {
    lr = ar.onuncatched(cr);
  } catch (fr) {
  }
  if (lr !== !1)
    try {
      var ur, dr = { promise: ar, reason: cr };
      if (e.document && document.createEvent ? ((ur = document.createEvent("Event")).initEvent(ht, !0, !0), r(ur, dr)) : e.CustomEvent && r(ur = new CustomEvent(ht, { detail: dr }), dr), ur && e.dispatchEvent && (dispatchEvent(ur), !e.PromiseRejectionEvent && e.onunhandledrejection))
        try {
          e.onunhandledrejection(ur);
        } catch (fr) {
        }
      R && ur && !ur.defaultPrevented && console.warn(`Unhandled rejection: ${cr.stack || cr}`);
    } catch (fr) {
    }
}
var ft = je.reject;
function pt(cr, ar, lr, ur) {
  if (cr.idbdb && (cr._state.openComplete || Oe.letThrough || cr._vip)) {
    var dr = cr._createTransaction(ar, lr, cr._dbSchema);
    try {
      dr.create(), cr._state.PR1398_maxLoop = 3;
    } catch (fr) {
      return fr.name === H.InvalidState && cr.isOpen() && --cr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), cr._close(), cr.open().then(() => pt(cr, ar, lr, ur))) : ft(fr);
    }
    return dr._promise(ar, (fr, gr) => Ze(() => (Oe.trans = dr, ur(fr, gr, dr)))).then((fr) => dr._completion.then(() => fr));
  }
  if (cr._state.openComplete)
    return ft(new X.DatabaseClosed(cr._state.dbOpenError));
  if (!cr._state.isBeingOpened) {
    if (!cr._options.autoOpen)
      return ft(new X.DatabaseClosed());
    cr.open().catch(ee$1);
  }
  return cr._state.dbReadyPromise.then(() => pt(cr, ar, lr, ur));
}
const yt = "3.2.4", mt = String.fromCharCode(65535), vt = -1 / 0, gt$3 = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", bt = "String expected.", _t = [], wt = typeof navigator != "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), xt = wt, kt = wt, Et = (cr) => !/(dexie\.js|dexie\.min\.js)/.test(cr), Pt = "__dbnames", Kt = "readonly", Ot = "readwrite";
function St(cr, ar) {
  return cr ? ar ? function() {
    return cr.apply(this, arguments) && ar.apply(this, arguments);
  } : cr : ar;
}
const At = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Ct(cr) {
  return typeof cr != "string" || /\./.test(cr) ? (ar) => ar : (ar) => (ar[cr] === void 0 && cr in ar && delete (ar = O(ar))[cr], ar);
}
class jt {
  _trans(ar, lr, ur) {
    const dr = this._tx || Oe.trans, fr = this.name;
    function gr(vr, yr, _r) {
      if (!_r.schema[fr])
        throw new X.NotFound("Table " + fr + " not part of transaction");
      return lr(_r.idbtrans, _r);
    }
    const mr = Ue();
    try {
      return dr && dr.db === this.db ? dr === Oe.trans ? dr._promise(ar, gr, ur) : Ze(() => dr._promise(ar, gr, ur), { trans: dr, transless: Oe.transless || Oe }) : pt(this.db, ar, [this.name], gr);
    } finally {
      mr && Le();
    }
  }
  get(ar, lr) {
    return ar && ar.constructor === Object ? this.where(ar).first(lr) : this._trans("readonly", (ur) => this.core.get({ trans: ur, key: ar }).then((dr) => this.hook.reading.fire(dr))).then(lr);
  }
  where(ar) {
    if (typeof ar == "string")
      return new this.db.WhereClause(this, ar);
    if (n(ar))
      return new this.db.WhereClause(this, `[${ar.join("+")}]`);
    const lr = t(ar);
    if (lr.length === 1)
      return this.where(lr[0]).equals(ar[lr[0]]);
    const ur = this.schema.indexes.concat(this.schema.primKey).filter((yr) => yr.compound && lr.every((_r) => yr.keyPath.indexOf(_r) >= 0) && yr.keyPath.every((_r) => lr.indexOf(_r) >= 0))[0];
    if (ur && this.db._maxKey !== mt)
      return this.where(ur.name).equals(ur.keyPath.map((yr) => ar[yr]));
    !ur && R && console.warn(`The query ${JSON.stringify(ar)} on ${this.name} would benefit of a compound index [${lr.join("+")}]`);
    const { idxByName: dr } = this.schema, fr = this.db._deps.indexedDB;
    function gr(yr, _r) {
      try {
        return fr.cmp(yr, _r) === 0;
      } catch (kr) {
        return !1;
      }
    }
    const [mr, vr] = lr.reduce(([yr, _r], kr) => {
      const xr = dr[kr], Ar = ar[kr];
      return [yr || xr, yr || !xr ? St(_r, xr && xr.multi ? (Er) => {
        const Cr = b(Er, kr);
        return n(Cr) && Cr.some((Tr) => gr(Ar, Tr));
      } : (Er) => gr(Ar, b(Er, kr))) : _r];
    }, [null, null]);
    return mr ? this.where(mr.name).equals(ar[mr.keyPath]).filter(vr) : ur ? this.filter(vr) : this.where(lr).equals("");
  }
  filter(ar) {
    return this.toCollection().and(ar);
  }
  count(ar) {
    return this.toCollection().count(ar);
  }
  offset(ar) {
    return this.toCollection().offset(ar);
  }
  limit(ar) {
    return this.toCollection().limit(ar);
  }
  each(ar) {
    return this.toCollection().each(ar);
  }
  toArray(ar) {
    return this.toCollection().toArray(ar);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(ar) {
    return new this.db.Collection(new this.db.WhereClause(this, n(ar) ? `[${ar.join("+")}]` : ar));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(ar) {
    this.schema.mappedClass = ar;
    const lr = (ur) => {
      if (!ur)
        return ur;
      const dr = Object.create(ar.prototype);
      for (var fr in ur)
        if (o(ur, fr))
          try {
            dr[fr] = ur[fr];
          } catch (gr) {
          }
      return dr;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = lr, this.hook("reading", lr), ar;
  }
  defineClass() {
    return this.mapToClass(function(ar) {
      r(this, ar);
    });
  }
  add(ar, lr) {
    const { auto: ur, keyPath: dr } = this.schema.primKey;
    let fr = ar;
    return dr && ur && (fr = Ct(dr)(ar)), this._trans("readwrite", (gr) => this.core.mutate({ trans: gr, type: "add", keys: lr != null ? [lr] : null, values: [fr] })).then((gr) => gr.numFailures ? je.reject(gr.failures[0]) : gr.lastResult).then((gr) => {
      if (dr)
        try {
          _(ar, dr, gr);
        } catch (mr) {
        }
      return gr;
    });
  }
  update(ar, lr) {
    if (typeof ar != "object" || n(ar))
      return this.where(":id").equals(ar).modify(lr);
    {
      const ur = b(ar, this.schema.primKey.keyPath);
      if (ur === void 0)
        return ft(new X.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof lr != "function" ? t(lr).forEach((dr) => {
          _(ar, dr, lr[dr]);
        }) : lr(ar, { value: ar, primKey: ur });
      } catch (dr) {
      }
      return this.where(":id").equals(ur).modify(lr);
    }
  }
  put(ar, lr) {
    const { auto: ur, keyPath: dr } = this.schema.primKey;
    let fr = ar;
    return dr && ur && (fr = Ct(dr)(ar)), this._trans("readwrite", (gr) => this.core.mutate({ trans: gr, type: "put", values: [fr], keys: lr != null ? [lr] : null })).then((gr) => gr.numFailures ? je.reject(gr.failures[0]) : gr.lastResult).then((gr) => {
      if (dr)
        try {
          _(ar, dr, gr);
        } catch (mr) {
        }
      return gr;
    });
  }
  delete(ar) {
    return this._trans("readwrite", (lr) => this.core.mutate({ trans: lr, type: "delete", keys: [ar] })).then((lr) => lr.numFailures ? je.reject(lr.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (ar) => this.core.mutate({ trans: ar, type: "deleteRange", range: At })).then((ar) => ar.numFailures ? je.reject(ar.failures[0]) : void 0);
  }
  bulkGet(ar) {
    return this._trans("readonly", (lr) => this.core.getMany({ keys: ar, trans: lr }).then((ur) => ur.map((dr) => this.hook.reading.fire(dr))));
  }
  bulkAdd(ar, lr, ur) {
    const dr = Array.isArray(lr) ? lr : void 0, fr = (ur = ur || (dr ? void 0 : lr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (gr) => {
      const { auto: mr, keyPath: vr } = this.schema.primKey;
      if (vr && dr)
        throw new X.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (dr && dr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const yr = ar.length;
      let _r = vr && mr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: gr, type: "add", keys: dr, values: _r, wantResults: fr }).then(({ numFailures: kr, results: xr, lastResult: Ar, failures: Er }) => {
        if (kr === 0)
          return fr ? xr : Ar;
        throw new G(`${this.name}.bulkAdd(): ${kr} of ${yr} operations failed`, Er);
      });
    });
  }
  bulkPut(ar, lr, ur) {
    const dr = Array.isArray(lr) ? lr : void 0, fr = (ur = ur || (dr ? void 0 : lr)) ? ur.allKeys : void 0;
    return this._trans("readwrite", (gr) => {
      const { auto: mr, keyPath: vr } = this.schema.primKey;
      if (vr && dr)
        throw new X.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (dr && dr.length !== ar.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const yr = ar.length;
      let _r = vr && mr ? ar.map(Ct(vr)) : ar;
      return this.core.mutate({ trans: gr, type: "put", keys: dr, values: _r, wantResults: fr }).then(({ numFailures: kr, results: xr, lastResult: Ar, failures: Er }) => {
        if (kr === 0)
          return fr ? xr : Ar;
        throw new G(`${this.name}.bulkPut(): ${kr} of ${yr} operations failed`, Er);
      });
    });
  }
  bulkDelete(ar) {
    const lr = ar.length;
    return this._trans("readwrite", (ur) => this.core.mutate({ trans: ur, type: "delete", keys: ar })).then(({ numFailures: ur, lastResult: dr, failures: fr }) => {
      if (ur === 0)
        return dr;
      throw new G(`${this.name}.bulkDelete(): ${ur} of ${lr} operations failed`, fr);
    });
  }
}
function Dt(cr) {
  var ar = {}, lr = function(gr, mr) {
    if (mr) {
      for (var vr = arguments.length, yr = new Array(vr - 1); --vr; )
        yr[vr - 1] = arguments[vr];
      return ar[gr].subscribe.apply(null, yr), cr;
    }
    if (typeof gr == "string")
      return ar[gr];
  };
  lr.addEventType = fr;
  for (var ur = 1, dr = arguments.length; ur < dr; ++ur)
    fr(arguments[ur]);
  return lr;
  function fr(gr, mr, vr) {
    if (typeof gr != "object") {
      var yr;
      mr || (mr = ae), vr || (vr = ee$1);
      var _r = { subscribers: [], fire: vr, subscribe: function(kr) {
        _r.subscribers.indexOf(kr) === -1 && (_r.subscribers.push(kr), _r.fire = mr(_r.fire, kr));
      }, unsubscribe: function(kr) {
        _r.subscribers = _r.subscribers.filter(function(xr) {
          return xr !== kr;
        }), _r.fire = _r.subscribers.reduce(mr, vr);
      } };
      return ar[gr] = lr[gr] = _r, _r;
    }
    t(yr = gr).forEach(function(kr) {
      var xr = yr[kr];
      if (n(xr))
        fr(kr, yr[kr][0], yr[kr][1]);
      else {
        if (xr !== "asap")
          throw new X.InvalidArgument("Invalid event config");
        var Ar = fr(kr, te, function() {
          for (var Er = arguments.length, Cr = new Array(Er); Er--; )
            Cr[Er] = arguments[Er];
          Ar.subscribers.forEach(function(Tr) {
            v(function() {
              Tr.apply(null, Cr);
            });
          });
        });
      }
    });
  }
}
function It(cr, ar) {
  return c(ar).from({ prototype: cr }), ar;
}
function Bt(cr, ar) {
  return !(cr.filter || cr.algorithm || cr.or) && (ar ? cr.justLimit : !cr.replayFilter);
}
function Tt(cr, ar) {
  cr.filter = St(cr.filter, ar);
}
function Rt(cr, ar, lr) {
  var ur = cr.replayFilter;
  cr.replayFilter = ur ? () => St(ur(), ar()) : ar, cr.justLimit = lr && !ur;
}
function Ft(cr, ar) {
  if (cr.isPrimKey)
    return ar.primaryKey;
  const lr = ar.getIndexByKeyPath(cr.index);
  if (!lr)
    throw new X.Schema("KeyPath " + cr.index + " on object store " + ar.name + " is not indexed");
  return lr;
}
function Mt(cr, ar, lr) {
  const ur = Ft(cr, ar.schema);
  return ar.openCursor({ trans: lr, values: !cr.keysOnly, reverse: cr.dir === "prev", unique: !!cr.unique, query: { index: ur, range: cr.range } });
}
function Nt(cr, ar, lr, ur) {
  const dr = cr.replayFilter ? St(cr.filter, cr.replayFilter()) : cr.filter;
  if (cr.or) {
    const fr = {}, gr = (mr, vr, yr) => {
      if (!dr || dr(vr, yr, (xr) => vr.stop(xr), (xr) => vr.fail(xr))) {
        var _r = vr.primaryKey, kr = "" + _r;
        kr === "[object ArrayBuffer]" && (kr = "" + new Uint8Array(_r)), o(fr, kr) || (fr[kr] = !0, ar(mr, vr, yr));
      }
    };
    return Promise.all([cr.or._iterate(gr, lr), qt(Mt(cr, ur, lr), cr.algorithm, gr, !cr.keysOnly && cr.valueMapper)]);
  }
  return qt(Mt(cr, ur, lr), St(cr.algorithm, dr), ar, !cr.keysOnly && cr.valueMapper);
}
function qt(cr, ar, lr, ur) {
  var dr = Ye(ur ? (fr, gr, mr) => lr(ur(fr), gr, mr) : lr);
  return cr.then((fr) => {
    if (fr)
      return fr.start(() => {
        var gr = () => fr.continue();
        ar && !ar(fr, (mr) => gr = mr, (mr) => {
          fr.stop(mr), gr = ee$1;
        }, (mr) => {
          fr.fail(mr), gr = ee$1;
        }) || dr(fr.value, fr, (mr) => gr = mr), gr();
      });
  });
}
function $t(cr, ar) {
  try {
    const lr = Ut(cr), ur = Ut(ar);
    if (lr !== ur)
      return lr === "Array" ? 1 : ur === "Array" ? -1 : lr === "binary" ? 1 : ur === "binary" ? -1 : lr === "string" ? 1 : ur === "string" ? -1 : lr === "Date" ? 1 : ur !== "Date" ? NaN : -1;
    switch (lr) {
      case "number":
      case "Date":
      case "string":
        return cr > ar ? 1 : cr < ar ? -1 : 0;
      case "binary":
        return function(dr, fr) {
          const gr = dr.length, mr = fr.length, vr = gr < mr ? gr : mr;
          for (let yr = 0; yr < vr; ++yr)
            if (dr[yr] !== fr[yr])
              return dr[yr] < fr[yr] ? -1 : 1;
          return gr === mr ? 0 : gr < mr ? -1 : 1;
        }(Lt$1(cr), Lt$1(ar));
      case "Array":
        return function(dr, fr) {
          const gr = dr.length, mr = fr.length, vr = gr < mr ? gr : mr;
          for (let yr = 0; yr < vr; ++yr) {
            const _r = $t(dr[yr], fr[yr]);
            if (_r !== 0)
              return _r;
          }
          return gr === mr ? 0 : gr < mr ? -1 : 1;
        }(cr, ar);
    }
  } catch (lr) {
  }
  return NaN;
}
function Ut(cr) {
  const ar = typeof cr;
  if (ar !== "object")
    return ar;
  if (ArrayBuffer.isView(cr))
    return "binary";
  const lr = C(cr);
  return lr === "ArrayBuffer" ? "binary" : lr;
}
function Lt$1(cr) {
  return cr instanceof Uint8Array ? cr : ArrayBuffer.isView(cr) ? new Uint8Array(cr.buffer, cr.byteOffset, cr.byteLength) : new Uint8Array(cr);
}
class Vt {
  _read(ar, lr) {
    var ur = this._ctx;
    return ur.error ? ur.table._trans(null, ft.bind(null, ur.error)) : ur.table._trans("readonly", ar).then(lr);
  }
  _write(ar) {
    var lr = this._ctx;
    return lr.error ? lr.table._trans(null, ft.bind(null, lr.error)) : lr.table._trans("readwrite", ar, "locked");
  }
  _addAlgorithm(ar) {
    var lr = this._ctx;
    lr.algorithm = St(lr.algorithm, ar);
  }
  _iterate(ar, lr) {
    return Nt(this._ctx, ar, lr, this._ctx.table.core);
  }
  clone(ar) {
    var lr = Object.create(this.constructor.prototype), ur = Object.create(this._ctx);
    return ar && r(ur, ar), lr._ctx = ur, lr;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(ar) {
    var lr = this._ctx;
    return this._read((ur) => Nt(lr, ar, ur, lr.table.core));
  }
  count(ar) {
    return this._read((lr) => {
      const ur = this._ctx, dr = ur.table.core;
      if (Bt(ur, !0))
        return dr.count({ trans: lr, query: { index: Ft(ur, dr.schema), range: ur.range } }).then((gr) => Math.min(gr, ur.limit));
      var fr = 0;
      return Nt(ur, () => (++fr, !1), lr, dr).then(() => fr);
    }).then(ar);
  }
  sortBy(ar, lr) {
    const ur = ar.split(".").reverse(), dr = ur[0], fr = ur.length - 1;
    function gr(yr, _r) {
      return _r ? gr(yr[ur[_r]], _r - 1) : yr[dr];
    }
    var mr = this._ctx.dir === "next" ? 1 : -1;
    function vr(yr, _r) {
      var kr = gr(yr, fr), xr = gr(_r, fr);
      return kr < xr ? -mr : kr > xr ? mr : 0;
    }
    return this.toArray(function(yr) {
      return yr.sort(vr);
    }).then(lr);
  }
  toArray(ar) {
    return this._read((lr) => {
      var ur = this._ctx;
      if (ur.dir === "next" && Bt(ur, !0) && ur.limit > 0) {
        const { valueMapper: dr } = ur, fr = Ft(ur, ur.table.core.schema);
        return ur.table.core.query({ trans: lr, limit: ur.limit, values: !0, query: { index: fr, range: ur.range } }).then(({ result: gr }) => dr ? gr.map(dr) : gr);
      }
      {
        const dr = [];
        return Nt(ur, (fr) => dr.push(fr), lr, ur.table.core).then(() => dr);
      }
    }, ar);
  }
  offset(ar) {
    var lr = this._ctx;
    return ar <= 0 || (lr.offset += ar, Bt(lr) ? Rt(lr, () => {
      var ur = ar;
      return (dr, fr) => ur === 0 || (ur === 1 ? (--ur, !1) : (fr(() => {
        dr.advance(ur), ur = 0;
      }), !1));
    }) : Rt(lr, () => {
      var ur = ar;
      return () => --ur < 0;
    })), this;
  }
  limit(ar) {
    return this._ctx.limit = Math.min(this._ctx.limit, ar), Rt(this._ctx, () => {
      var lr = ar;
      return function(ur, dr, fr) {
        return --lr <= 0 && dr(fr), lr >= 0;
      };
    }, !0), this;
  }
  until(ar, lr) {
    return Tt(this._ctx, function(ur, dr, fr) {
      return !ar(ur.value) || (dr(fr), lr);
    }), this;
  }
  first(ar) {
    return this.limit(1).toArray(function(lr) {
      return lr[0];
    }).then(ar);
  }
  last(ar) {
    return this.reverse().first(ar);
  }
  filter(ar) {
    var lr, ur;
    return Tt(this._ctx, function(dr) {
      return ar(dr.value);
    }), lr = this._ctx, ur = ar, lr.isMatch = St(lr.isMatch, ur), this;
  }
  and(ar) {
    return this.filter(ar);
  }
  or(ar) {
    return new this.db.WhereClause(this._ctx.table, ar, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(ar) {
    var lr = this._ctx;
    return lr.keysOnly = !lr.isMatch, this.each(function(ur, dr) {
      ar(dr.key, dr);
    });
  }
  eachUniqueKey(ar) {
    return this._ctx.unique = "unique", this.eachKey(ar);
  }
  eachPrimaryKey(ar) {
    var lr = this._ctx;
    return lr.keysOnly = !lr.isMatch, this.each(function(ur, dr) {
      ar(dr.primaryKey, dr);
    });
  }
  keys(ar) {
    var lr = this._ctx;
    lr.keysOnly = !lr.isMatch;
    var ur = [];
    return this.each(function(dr, fr) {
      ur.push(fr.key);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  primaryKeys(ar) {
    var lr = this._ctx;
    if (lr.dir === "next" && Bt(lr, !0) && lr.limit > 0)
      return this._read((dr) => {
        var fr = Ft(lr, lr.table.core.schema);
        return lr.table.core.query({ trans: dr, values: !1, limit: lr.limit, query: { index: fr, range: lr.range } });
      }).then(({ result: dr }) => dr).then(ar);
    lr.keysOnly = !lr.isMatch;
    var ur = [];
    return this.each(function(dr, fr) {
      ur.push(fr.primaryKey);
    }).then(function() {
      return ur;
    }).then(ar);
  }
  uniqueKeys(ar) {
    return this._ctx.unique = "unique", this.keys(ar);
  }
  firstKey(ar) {
    return this.limit(1).keys(function(lr) {
      return lr[0];
    }).then(ar);
  }
  lastKey(ar) {
    return this.reverse().firstKey(ar);
  }
  distinct() {
    var ar = this._ctx, lr = ar.index && ar.table.schema.idxByName[ar.index];
    if (!lr || !lr.multi)
      return this;
    var ur = {};
    return Tt(this._ctx, function(dr) {
      var fr = dr.primaryKey.toString(), gr = o(ur, fr);
      return ur[fr] = !0, !gr;
    }), this;
  }
  modify(ar) {
    var lr = this._ctx;
    return this._write((ur) => {
      var dr;
      if (typeof ar == "function")
        dr = ar;
      else {
        var fr = t(ar), gr = fr.length;
        dr = function(Cr) {
          for (var Tr = !1, Sr = 0; Sr < gr; ++Sr) {
            var Lr = fr[Sr], Ir = ar[Lr];
            b(Cr, Lr) !== Ir && (_(Cr, Lr, Ir), Tr = !0);
          }
          return Tr;
        };
      }
      const mr = lr.table.core, { outbound: vr, extractKey: yr } = mr.schema.primaryKey, _r = this.db._options.modifyChunkSize || 200, kr = [];
      let xr = 0;
      const Ar = [], Er = (Cr, Tr) => {
        const { failures: Sr, numFailures: Lr } = Tr;
        xr += Cr - Lr;
        for (let Ir of t(Sr))
          kr.push(Sr[Ir]);
      };
      return this.clone().primaryKeys().then((Cr) => {
        const Tr = (Sr) => {
          const Lr = Math.min(_r, Cr.length - Sr);
          return mr.getMany({ trans: ur, keys: Cr.slice(Sr, Sr + Lr), cache: "immutable" }).then((Ir) => {
            const Nr = [], Rr = [], Mr = vr ? [] : null, Br = [];
            for (let Hr = 0; Hr < Lr; ++Hr) {
              const Fr = Ir[Hr], zr = { value: O(Fr), primKey: Cr[Sr + Hr] };
              dr.call(zr, zr.value, zr) !== !1 && (zr.value == null ? Br.push(Cr[Sr + Hr]) : vr || $t(yr(Fr), yr(zr.value)) === 0 ? (Rr.push(zr.value), vr && Mr.push(Cr[Sr + Hr])) : (Br.push(Cr[Sr + Hr]), Nr.push(zr.value)));
            }
            const Dr = Bt(lr) && lr.limit === 1 / 0 && (typeof ar != "function" || ar === Wt) && { index: lr.index, range: lr.range };
            return Promise.resolve(Nr.length > 0 && mr.mutate({ trans: ur, type: "add", values: Nr }).then((Hr) => {
              for (let Fr in Hr.failures)
                Br.splice(parseInt(Fr), 1);
              Er(Nr.length, Hr);
            })).then(() => (Rr.length > 0 || Dr && typeof ar == "object") && mr.mutate({ trans: ur, type: "put", keys: Mr, values: Rr, criteria: Dr, changeSpec: typeof ar != "function" && ar }).then((Hr) => Er(Rr.length, Hr))).then(() => (Br.length > 0 || Dr && ar === Wt) && mr.mutate({ trans: ur, type: "delete", keys: Br, criteria: Dr }).then((Hr) => Er(Br.length, Hr))).then(() => Cr.length > Sr + Lr && Tr(Sr + _r));
          });
        };
        return Tr(0).then(() => {
          if (kr.length > 0)
            throw new z("Error modifying one or more objects", kr, xr, Ar);
          return Cr.length;
        });
      });
    });
  }
  delete() {
    var ar = this._ctx, lr = ar.range;
    return Bt(ar) && (ar.isPrimKey && !kt || lr.type === 3) ? this._write((ur) => {
      const { primaryKey: dr } = ar.table.core.schema, fr = lr;
      return ar.table.core.count({ trans: ur, query: { index: dr, range: fr } }).then((gr) => ar.table.core.mutate({ trans: ur, type: "deleteRange", range: fr }).then(({ failures: mr, lastResult: vr, results: yr, numFailures: _r }) => {
        if (_r)
          throw new z("Could not delete some values", Object.keys(mr).map((kr) => mr[kr]), gr - _r);
        return gr - _r;
      }));
    }) : this.modify(Wt);
  }
}
const Wt = (cr, ar) => ar.value = null;
function Yt(cr, ar) {
  return cr < ar ? -1 : cr === ar ? 0 : 1;
}
function zt(cr, ar) {
  return cr > ar ? -1 : cr === ar ? 0 : 1;
}
function Gt$1(cr, ar, lr) {
  var ur = cr instanceof en ? new cr.Collection(cr) : cr;
  return ur._ctx.error = lr ? new lr(ar) : new TypeError(ar), ur;
}
function Ht(cr) {
  return new cr.Collection(cr, () => Zt("")).limit(0);
}
function Qt(cr, ar, lr, ur, dr, fr) {
  for (var gr = Math.min(cr.length, ur.length), mr = -1, vr = 0; vr < gr; ++vr) {
    var yr = ar[vr];
    if (yr !== ur[vr])
      return dr(cr[vr], lr[vr]) < 0 ? cr.substr(0, vr) + lr[vr] + lr.substr(vr + 1) : dr(cr[vr], ur[vr]) < 0 ? cr.substr(0, vr) + ur[vr] + lr.substr(vr + 1) : mr >= 0 ? cr.substr(0, mr) + ar[mr] + lr.substr(mr + 1) : null;
    dr(cr[vr], yr) < 0 && (mr = vr);
  }
  return gr < ur.length && fr === "next" ? cr + lr.substr(cr.length) : gr < cr.length && fr === "prev" ? cr.substr(0, lr.length) : mr < 0 ? null : cr.substr(0, mr) + ur[mr] + lr.substr(mr + 1);
}
function Xt(cr, ar, lr, ur) {
  var dr, fr, gr, mr, vr, yr, _r, kr = lr.length;
  if (!lr.every((Cr) => typeof Cr == "string"))
    return Gt$1(cr, bt);
  function xr(Cr) {
    dr = function(Sr) {
      return Sr === "next" ? (Lr) => Lr.toUpperCase() : (Lr) => Lr.toLowerCase();
    }(Cr), fr = function(Sr) {
      return Sr === "next" ? (Lr) => Lr.toLowerCase() : (Lr) => Lr.toUpperCase();
    }(Cr), gr = Cr === "next" ? Yt : zt;
    var Tr = lr.map(function(Sr) {
      return { lower: fr(Sr), upper: dr(Sr) };
    }).sort(function(Sr, Lr) {
      return gr(Sr.lower, Lr.lower);
    });
    mr = Tr.map(function(Sr) {
      return Sr.upper;
    }), vr = Tr.map(function(Sr) {
      return Sr.lower;
    }), yr = Cr, _r = Cr === "next" ? "" : ur;
  }
  xr("next");
  var Ar = new cr.Collection(cr, () => Jt(mr[0], vr[kr - 1] + ur));
  Ar._ondirectionchange = function(Cr) {
    xr(Cr);
  };
  var Er = 0;
  return Ar._addAlgorithm(function(Cr, Tr, Sr) {
    var Lr = Cr.key;
    if (typeof Lr != "string")
      return !1;
    var Ir = fr(Lr);
    if (ar(Ir, vr, Er))
      return !0;
    for (var Nr = null, Rr = Er; Rr < kr; ++Rr) {
      var Mr = Qt(Lr, Ir, mr[Rr], vr[Rr], gr, yr);
      Mr === null && Nr === null ? Er = Rr + 1 : (Nr === null || gr(Nr, Mr) > 0) && (Nr = Mr);
    }
    return Tr(Nr !== null ? function() {
      Cr.continue(Nr + _r);
    } : Sr), !1;
  }), Ar;
}
function Jt(cr, ar, lr, ur) {
  return { type: 2, lower: cr, upper: ar, lowerOpen: lr, upperOpen: ur };
}
function Zt(cr) {
  return { type: 1, lower: cr, upper: cr };
}
class en {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(ar, lr, ur, dr) {
    ur = ur !== !1, dr = dr === !0;
    try {
      return this._cmp(ar, lr) > 0 || this._cmp(ar, lr) === 0 && (ur || dr) && (!ur || !dr) ? Ht(this) : new this.Collection(this, () => Jt(ar, lr, !ur, !dr));
    } catch (fr) {
      return Gt$1(this, gt$3);
    }
  }
  equals(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Zt(ar));
  }
  above(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !0));
  }
  aboveOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(ar, void 0, !1));
  }
  below(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar, !1, !0));
  }
  belowOrEqual(ar) {
    return ar == null ? Gt$1(this, gt$3) : new this.Collection(this, () => Jt(void 0, ar));
  }
  startsWith(ar) {
    return typeof ar != "string" ? Gt$1(this, bt) : this.between(ar, ar + mt, !0, !0);
  }
  startsWithIgnoreCase(ar) {
    return ar === "" ? this.startsWith(ar) : Xt(this, (lr, ur) => lr.indexOf(ur[0]) === 0, [ar], mt);
  }
  equalsIgnoreCase(ar) {
    return Xt(this, (lr, ur) => lr === ur[0], [ar], "");
  }
  anyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (lr, ur) => ur.indexOf(lr) !== -1, ar, "");
  }
  startsWithAnyOfIgnoreCase() {
    var ar = B.apply(I, arguments);
    return ar.length === 0 ? Ht(this) : Xt(this, (lr, ur) => ur.some((dr) => lr.indexOf(dr) === 0), ar, mt);
  }
  anyOf() {
    const ar = B.apply(I, arguments);
    let lr = this._cmp;
    try {
      ar.sort(lr);
    } catch (fr) {
      return Gt$1(this, gt$3);
    }
    if (ar.length === 0)
      return Ht(this);
    const ur = new this.Collection(this, () => Jt(ar[0], ar[ar.length - 1]));
    ur._ondirectionchange = (fr) => {
      lr = fr === "next" ? this._ascending : this._descending, ar.sort(lr);
    };
    let dr = 0;
    return ur._addAlgorithm((fr, gr, mr) => {
      const vr = fr.key;
      for (; lr(vr, ar[dr]) > 0; )
        if (++dr, dr === ar.length)
          return gr(mr), !1;
      return lr(vr, ar[dr]) === 0 || (gr(() => {
        fr.continue(ar[dr]);
      }), !1);
    }), ur;
  }
  notEqual(ar) {
    return this.inAnyRange([[vt, ar], [ar, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const ar = B.apply(I, arguments);
    if (ar.length === 0)
      return new this.Collection(this);
    try {
      ar.sort(this._ascending);
    } catch (ur) {
      return Gt$1(this, gt$3);
    }
    const lr = ar.reduce((ur, dr) => ur ? ur.concat([[ur[ur.length - 1][1], dr]]) : [[vt, dr]], null);
    return lr.push([ar[ar.length - 1], this.db._maxKey]), this.inAnyRange(lr, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(ar, lr) {
    const ur = this._cmp, dr = this._ascending, fr = this._descending, gr = this._min, mr = this._max;
    if (ar.length === 0)
      return Ht(this);
    if (!ar.every((Lr) => Lr[0] !== void 0 && Lr[1] !== void 0 && dr(Lr[0], Lr[1]) <= 0))
      return Gt$1(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", X.InvalidArgument);
    const vr = !lr || lr.includeLowers !== !1, yr = lr && lr.includeUppers === !0;
    let _r, kr = dr;
    function xr(Lr, Ir) {
      return kr(Lr[0], Ir[0]);
    }
    try {
      _r = ar.reduce(function(Lr, Ir) {
        let Nr = 0, Rr = Lr.length;
        for (; Nr < Rr; ++Nr) {
          const Mr = Lr[Nr];
          if (ur(Ir[0], Mr[1]) < 0 && ur(Ir[1], Mr[0]) > 0) {
            Mr[0] = gr(Mr[0], Ir[0]), Mr[1] = mr(Mr[1], Ir[1]);
            break;
          }
        }
        return Nr === Rr && Lr.push(Ir), Lr;
      }, []), _r.sort(xr);
    } catch (Lr) {
      return Gt$1(this, gt$3);
    }
    let Ar = 0;
    const Er = yr ? (Lr) => dr(Lr, _r[Ar][1]) > 0 : (Lr) => dr(Lr, _r[Ar][1]) >= 0, Cr = vr ? (Lr) => fr(Lr, _r[Ar][0]) > 0 : (Lr) => fr(Lr, _r[Ar][0]) >= 0;
    let Tr = Er;
    const Sr = new this.Collection(this, () => Jt(_r[0][0], _r[_r.length - 1][1], !vr, !yr));
    return Sr._ondirectionchange = (Lr) => {
      Lr === "next" ? (Tr = Er, kr = dr) : (Tr = Cr, kr = fr), _r.sort(xr);
    }, Sr._addAlgorithm((Lr, Ir, Nr) => {
      for (var Rr = Lr.key; Tr(Rr); )
        if (++Ar, Ar === _r.length)
          return Ir(Nr), !1;
      return !!function(Mr) {
        return !Er(Mr) && !Cr(Mr);
      }(Rr) || (this._cmp(Rr, _r[Ar][1]) === 0 || this._cmp(Rr, _r[Ar][0]) === 0 || Ir(() => {
        kr === dr ? Lr.continue(_r[Ar][0]) : Lr.continue(_r[Ar][1]);
      }), !1);
    }), Sr;
  }
  startsWithAnyOf() {
    const ar = B.apply(I, arguments);
    return ar.every((lr) => typeof lr == "string") ? ar.length === 0 ? Ht(this) : this.inAnyRange(ar.map((lr) => [lr, lr + mt])) : Gt$1(this, "startsWithAnyOf() only works with strings");
  }
}
function tn(cr) {
  return Ye(function(ar) {
    return nn(ar), cr(ar.target.error), !1;
  });
}
function nn(cr) {
  cr.stopPropagation && cr.stopPropagation(), cr.preventDefault && cr.preventDefault();
}
const rn = "storagemutated", sn = "x-storagemutated-1", on$1 = Dt(null, rn);
class an {
  _lock() {
    return m(!Oe.global), ++this._reculock, this._reculock !== 1 || Oe.global || (Oe.lockOwnerFor = this), this;
  }
  _unlock() {
    if (m(!Oe.global), --this._reculock == 0)
      for (Oe.global || (Oe.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var ar = this._blockedFuncs.shift();
        try {
          at(ar[1], ar[0]);
        } catch (lr) {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Oe.lockOwnerFor !== this;
  }
  create(ar) {
    if (!this.mode)
      return this;
    const lr = this.db.idbdb, ur = this.db._state.dbOpenError;
    if (m(!this.idbtrans), !ar && !lr)
      switch (ur && ur.name) {
        case "DatabaseClosedError":
          throw new X.DatabaseClosed(ur);
        case "MissingAPIError":
          throw new X.MissingAPI(ur.message, ur);
        default:
          throw new X.OpenFailed(ur);
      }
    if (!this.active)
      throw new X.TransactionInactive();
    return m(this._completion._state === null), (ar = this.idbtrans = ar || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : lr.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Ye((dr) => {
      nn(dr), this._reject(ar.error);
    }), ar.onabort = Ye((dr) => {
      nn(dr), this.active && this._reject(new X.Abort(ar.error)), this.active = !1, this.on("abort").fire(dr);
    }), ar.oncomplete = Ye(() => {
      this.active = !1, this._resolve(), "mutatedParts" in ar && on$1.storagemutated.fire(ar.mutatedParts);
    }), this;
  }
  _promise(ar, lr, ur) {
    if (ar === "readwrite" && this.mode !== "readwrite")
      return ft(new X.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ft(new X.TransactionInactive());
    if (this._locked())
      return new je((fr, gr) => {
        this._blockedFuncs.push([() => {
          this._promise(ar, lr, ur).then(fr, gr);
        }, Oe]);
      });
    if (ur)
      return Ze(() => {
        var fr = new je((gr, mr) => {
          this._lock();
          const vr = lr(gr, mr, this);
          vr && vr.then && vr.then(gr, mr);
        });
        return fr.finally(() => this._unlock()), fr._lib = !0, fr;
      });
    var dr = new je((fr, gr) => {
      var mr = lr(fr, gr, this);
      mr && mr.then && mr.then(fr, gr);
    });
    return dr._lib = !0, dr;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(ar) {
    var lr = this._root();
    const ur = je.resolve(ar);
    if (lr._waitingFor)
      lr._waitingFor = lr._waitingFor.then(() => ur);
    else {
      lr._waitingFor = ur, lr._waitingQueue = [];
      var dr = lr.idbtrans.objectStore(lr.storeNames[0]);
      (function gr() {
        for (++lr._spinCount; lr._waitingQueue.length; )
          lr._waitingQueue.shift()();
        lr._waitingFor && (dr.get(-1 / 0).onsuccess = gr);
      })();
    }
    var fr = lr._waitingFor;
    return new je((gr, mr) => {
      ur.then((vr) => lr._waitingQueue.push(Ye(gr.bind(null, vr))), (vr) => lr._waitingQueue.push(Ye(mr.bind(null, vr)))).finally(() => {
        lr._waitingFor === fr && (lr._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));
  }
  table(ar) {
    const lr = this._memoizedTables || (this._memoizedTables = {});
    if (o(lr, ar))
      return lr[ar];
    const ur = this.schema[ar];
    if (!ur)
      throw new X.NotFound("Table " + ar + " not part of transaction");
    const dr = new this.db.Table(ar, ur, this);
    return dr.core = this.db.core.table(ar), lr[ar] = dr, dr;
  }
}
function un(cr, ar, lr, ur, dr, fr, gr) {
  return { name: cr, keyPath: ar, unique: lr, multi: ur, auto: dr, compound: fr, src: (lr && !gr ? "&" : "") + (ur ? "*" : "") + (dr ? "++" : "") + ln(ar) };
}
function ln(cr) {
  return typeof cr == "string" ? cr : cr ? "[" + [].join.call(cr, "+") + "]" : "";
}
function cn(cr, ar, lr) {
  return { name: cr, primKey: ar, indexes: lr, mappedClass: null, idxByName: g(lr, (ur) => [ur.name, ur]) };
}
let hn = (cr) => {
  try {
    return cr.only([[]]), hn = () => [[]], [[]];
  } catch (ar) {
    return hn = () => mt, mt;
  }
};
function dn(cr) {
  return cr == null ? () => {
  } : typeof cr == "string" ? function(ar) {
    return ar.split(".").length === 1 ? (ur) => ur[ar] : (ur) => b(ur, ar);
  }(cr) : (ar) => b(ar, cr);
}
function fn(cr) {
  return [].slice.call(cr);
}
let pn = 0;
function yn(cr) {
  return cr == null ? ":id" : typeof cr == "string" ? cr : `[${cr.join("+")}]`;
}
function mn(cr, ar, lr) {
  function ur(vr) {
    if (vr.type === 3)
      return null;
    if (vr.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: yr, upper: _r, lowerOpen: kr, upperOpen: xr } = vr;
    return yr === void 0 ? _r === void 0 ? null : ar.upperBound(_r, !!xr) : _r === void 0 ? ar.lowerBound(yr, !!kr) : ar.bound(yr, _r, !!kr, !!xr);
  }
  const { schema: dr, hasGetAll: fr } = function(vr, yr) {
    const _r = fn(vr.objectStoreNames);
    return { schema: { name: vr.name, tables: _r.map((kr) => yr.objectStore(kr)).map((kr) => {
      const { keyPath: xr, autoIncrement: Ar } = kr, Er = n(xr), Cr = xr == null, Tr = {}, Sr = { name: kr.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: Cr, compound: Er, keyPath: xr, autoIncrement: Ar, unique: !0, extractKey: dn(xr) }, indexes: fn(kr.indexNames).map((Lr) => kr.index(Lr)).map((Lr) => {
        const { name: Ir, unique: Nr, multiEntry: Rr, keyPath: Mr } = Lr, Br = { name: Ir, compound: n(Mr), keyPath: Mr, unique: Nr, multiEntry: Rr, extractKey: dn(Mr) };
        return Tr[yn(Mr)] = Br, Br;
      }), getIndexByKeyPath: (Lr) => Tr[yn(Lr)] };
      return Tr[":id"] = Sr.primaryKey, xr != null && (Tr[yn(xr)] = Sr.primaryKey), Sr;
    }) }, hasGetAll: _r.length > 0 && "getAll" in yr.objectStore(_r[0]) && !(typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(cr, lr), gr = dr.tables.map((vr) => function(yr) {
    const _r = yr.name;
    return { name: _r, schema: yr, mutate: function({ trans: kr, type: xr, keys: Ar, values: Er, range: Cr }) {
      return new Promise((Tr, Sr) => {
        Tr = Ye(Tr);
        const Lr = kr.objectStore(_r), Ir = Lr.keyPath == null, Nr = xr === "put" || xr === "add";
        if (!Nr && xr !== "delete" && xr !== "deleteRange")
          throw new Error("Invalid operation type: " + xr);
        const { length: Rr } = Ar || Er || { length: 1 };
        if (Ar && Er && Ar.length !== Er.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (Rr === 0)
          return Tr({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let Mr;
        const Br = [], Dr = [];
        let Hr = 0;
        const Fr = (Ur) => {
          ++Hr, nn(Ur);
        };
        if (xr === "deleteRange") {
          if (Cr.type === 4)
            return Tr({ numFailures: Hr, failures: Dr, results: [], lastResult: void 0 });
          Cr.type === 3 ? Br.push(Mr = Lr.clear()) : Br.push(Mr = Lr.delete(ur(Cr)));
        } else {
          const [Ur, jr] = Nr ? Ir ? [Er, Ar] : [Er, null] : [Ar, null];
          if (Nr)
            for (let Yr = 0; Yr < Rr; ++Yr)
              Br.push(Mr = jr && jr[Yr] !== void 0 ? Lr[xr](Ur[Yr], jr[Yr]) : Lr[xr](Ur[Yr])), Mr.onerror = Fr;
          else
            for (let Yr = 0; Yr < Rr; ++Yr)
              Br.push(Mr = Lr[xr](Ur[Yr])), Mr.onerror = Fr;
        }
        const zr = (Ur) => {
          const jr = Ur.target.result;
          Br.forEach((Yr, qr) => Yr.error != null && (Dr[qr] = Yr.error)), Tr({ numFailures: Hr, failures: Dr, results: xr === "delete" ? Ar : Br.map((Yr) => Yr.result), lastResult: jr });
        };
        Mr.onerror = (Ur) => {
          Fr(Ur), zr(Ur);
        }, Mr.onsuccess = zr;
      });
    }, getMany: ({ trans: kr, keys: xr }) => new Promise((Ar, Er) => {
      Ar = Ye(Ar);
      const Cr = kr.objectStore(_r), Tr = xr.length, Sr = new Array(Tr);
      let Lr, Ir = 0, Nr = 0;
      const Rr = (Br) => {
        const Dr = Br.target;
        Sr[Dr._pos] = Dr.result, ++Nr === Ir && Ar(Sr);
      }, Mr = tn(Er);
      for (let Br = 0; Br < Tr; ++Br)
        xr[Br] != null && (Lr = Cr.get(xr[Br]), Lr._pos = Br, Lr.onsuccess = Rr, Lr.onerror = Mr, ++Ir);
      Ir === 0 && Ar(Sr);
    }), get: ({ trans: kr, key: xr }) => new Promise((Ar, Er) => {
      Ar = Ye(Ar);
      const Cr = kr.objectStore(_r).get(xr);
      Cr.onsuccess = (Tr) => Ar(Tr.target.result), Cr.onerror = tn(Er);
    }), query: function(kr) {
      return (xr) => new Promise((Ar, Er) => {
        Ar = Ye(Ar);
        const { trans: Cr, values: Tr, limit: Sr, query: Lr } = xr, Ir = Sr === 1 / 0 ? void 0 : Sr, { index: Nr, range: Rr } = Lr, Mr = Cr.objectStore(_r), Br = Nr.isPrimaryKey ? Mr : Mr.index(Nr.name), Dr = ur(Rr);
        if (Sr === 0)
          return Ar({ result: [] });
        if (kr) {
          const Hr = Tr ? Br.getAll(Dr, Ir) : Br.getAllKeys(Dr, Ir);
          Hr.onsuccess = (Fr) => Ar({ result: Fr.target.result }), Hr.onerror = tn(Er);
        } else {
          let Hr = 0;
          const Fr = Tr || !("openKeyCursor" in Br) ? Br.openCursor(Dr) : Br.openKeyCursor(Dr), zr = [];
          Fr.onsuccess = (Ur) => {
            const jr = Fr.result;
            return jr ? (zr.push(Tr ? jr.value : jr.primaryKey), ++Hr === Sr ? Ar({ result: zr }) : void jr.continue()) : Ar({ result: zr });
          }, Fr.onerror = tn(Er);
        }
      });
    }(fr), openCursor: function({ trans: kr, values: xr, query: Ar, reverse: Er, unique: Cr }) {
      return new Promise((Tr, Sr) => {
        Tr = Ye(Tr);
        const { index: Lr, range: Ir } = Ar, Nr = kr.objectStore(_r), Rr = Lr.isPrimaryKey ? Nr : Nr.index(Lr.name), Mr = Er ? Cr ? "prevunique" : "prev" : Cr ? "nextunique" : "next", Br = xr || !("openKeyCursor" in Rr) ? Rr.openCursor(ur(Ir), Mr) : Rr.openKeyCursor(ur(Ir), Mr);
        Br.onerror = tn(Sr), Br.onsuccess = Ye((Dr) => {
          const Hr = Br.result;
          if (!Hr)
            return void Tr(null);
          Hr.___id = ++pn, Hr.done = !1;
          const Fr = Hr.continue.bind(Hr);
          let zr = Hr.continuePrimaryKey;
          zr && (zr = zr.bind(Hr));
          const Ur = Hr.advance.bind(Hr), jr = () => {
            throw new Error("Cursor not stopped");
          };
          Hr.trans = kr, Hr.stop = Hr.continue = Hr.continuePrimaryKey = Hr.advance = () => {
            throw new Error("Cursor not started");
          }, Hr.fail = Ye(Sr), Hr.next = function() {
            let Yr = 1;
            return this.start(() => Yr-- ? this.continue() : this.stop()).then(() => this);
          }, Hr.start = (Yr) => {
            const qr = new Promise((Jr, Gr) => {
              Jr = Ye(Jr), Br.onerror = tn(Gr), Hr.fail = Gr, Hr.stop = (Vr) => {
                Hr.stop = Hr.continue = Hr.continuePrimaryKey = Hr.advance = jr, Jr(Vr);
              };
            }), Wr = () => {
              if (Br.result)
                try {
                  Yr();
                } catch (Jr) {
                  Hr.fail(Jr);
                }
              else
                Hr.done = !0, Hr.start = () => {
                  throw new Error("Cursor behind last entry");
                }, Hr.stop();
            };
            return Br.onsuccess = Ye((Jr) => {
              Br.onsuccess = Wr, Wr();
            }), Hr.continue = Fr, Hr.continuePrimaryKey = zr, Hr.advance = Ur, Wr(), qr;
          }, Tr(Hr);
        }, Sr);
      });
    }, count({ query: kr, trans: xr }) {
      const { index: Ar, range: Er } = kr;
      return new Promise((Cr, Tr) => {
        const Sr = xr.objectStore(_r), Lr = Ar.isPrimaryKey ? Sr : Sr.index(Ar.name), Ir = ur(Er), Nr = Ir ? Lr.count(Ir) : Lr.count();
        Nr.onsuccess = Ye((Rr) => Cr(Rr.target.result)), Nr.onerror = tn(Tr);
      });
    } };
  }(vr)), mr = {};
  return gr.forEach((vr) => mr[vr.name] = vr), { stack: "dbcore", transaction: cr.transaction.bind(cr), table(vr) {
    if (!mr[vr])
      throw new Error(`Table '${vr}' not found`);
    return mr[vr];
  }, MIN_KEY: -1 / 0, MAX_KEY: hn(ar), schema: dr };
}
function vn({ _novip: cr }, ar) {
  const lr = ar.db, ur = function(dr, fr, { IDBKeyRange: gr, indexedDB: mr }, vr) {
    return { dbcore: function(_r, kr) {
      return kr.reduce((xr, { create: Ar }) => ({ ...xr, ...Ar(xr) }), _r);
    }(mn(fr, gr, vr), dr.dbcore) };
  }(cr._middlewares, lr, cr._deps, ar);
  cr.core = ur.dbcore, cr.tables.forEach((dr) => {
    const fr = dr.name;
    cr.core.schema.tables.some((gr) => gr.name === fr) && (dr.core = cr.core.table(fr), cr[fr] instanceof cr.Table && (cr[fr].core = dr.core));
  });
}
function gn({ _novip: cr }, ar, lr, ur) {
  lr.forEach((dr) => {
    const fr = ur[dr];
    ar.forEach((gr) => {
      const mr = d(gr, dr);
      (!mr || "value" in mr && mr.value === void 0) && (gr === cr.Transaction.prototype || gr instanceof cr.Transaction ? l(gr, dr, { get() {
        return this.table(dr);
      }, set(vr) {
        u$1(this, dr, { value: vr, writable: !0, configurable: !0, enumerable: !0 });
      } }) : gr[dr] = new cr.Table(dr, fr));
    });
  });
}
function bn({ _novip: cr }, ar) {
  ar.forEach((lr) => {
    for (let ur in lr)
      lr[ur] instanceof cr.Table && delete lr[ur];
  });
}
function _n(cr, ar) {
  return cr._cfg.version - ar._cfg.version;
}
function wn(cr, ar, lr, ur) {
  const dr = cr._dbSchema, fr = cr._createTransaction("readwrite", cr._storeNames, dr);
  fr.create(lr), fr._completion.catch(ur);
  const gr = fr._reject.bind(fr), mr = Oe.transless || Oe;
  Ze(() => {
    Oe.trans = fr, Oe.transless = mr, ar === 0 ? (t(dr).forEach((vr) => {
      kn(lr, vr, dr[vr].primKey, dr[vr].indexes);
    }), vn(cr, lr), je.follow(() => cr.on.populate.fire(fr)).catch(gr)) : function({ _novip: vr }, yr, _r, kr) {
      const xr = [], Ar = vr._versions;
      let Er = vr._dbSchema = Pn(vr, vr.idbdb, kr), Cr = !1;
      const Tr = Ar.filter((Lr) => Lr._cfg.version >= yr);
      function Sr() {
        return xr.length ? je.resolve(xr.shift()(_r.idbtrans)).then(Sr) : je.resolve();
      }
      return Tr.forEach((Lr) => {
        xr.push(() => {
          const Ir = Er, Nr = Lr._cfg.dbschema;
          Kn(vr, Ir, kr), Kn(vr, Nr, kr), Er = vr._dbSchema = Nr;
          const Rr = xn(Ir, Nr);
          Rr.add.forEach((Br) => {
            kn(kr, Br[0], Br[1].primKey, Br[1].indexes);
          }), Rr.change.forEach((Br) => {
            if (Br.recreate)
              throw new X.Upgrade("Not yet support for changing primary key");
            {
              const Dr = kr.objectStore(Br.name);
              Br.add.forEach((Hr) => En(Dr, Hr)), Br.change.forEach((Hr) => {
                Dr.deleteIndex(Hr.name), En(Dr, Hr);
              }), Br.del.forEach((Hr) => Dr.deleteIndex(Hr));
            }
          });
          const Mr = Lr._cfg.contentUpgrade;
          if (Mr && Lr._cfg.version > yr) {
            vn(vr, kr), _r._memoizedTables = {}, Cr = !0;
            let Br = w(Nr);
            Rr.del.forEach((zr) => {
              Br[zr] = Ir[zr];
            }), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], t(Br), Br), _r.schema = Br;
            const Dr = T(Mr);
            let Hr;
            Dr && et();
            const Fr = je.follow(() => {
              if (Hr = Mr(_r), Hr && Dr) {
                var zr = tt.bind(null, null);
                Hr.then(zr, zr);
              }
            });
            return Hr && typeof Hr.then == "function" ? je.resolve(Hr) : Fr.then(() => Hr);
          }
        }), xr.push((Ir) => {
          (!Cr || !xt) && function(Nr, Rr) {
            [].slice.call(Rr.db.objectStoreNames).forEach((Mr) => Nr[Mr] == null && Rr.db.deleteObjectStore(Mr));
          }(Lr._cfg.dbschema, Ir), bn(vr, [vr.Transaction.prototype]), gn(vr, [vr.Transaction.prototype], vr._storeNames, vr._dbSchema), _r.schema = vr._dbSchema;
        });
      }), Sr().then(() => {
        var Lr, Ir;
        Ir = kr, t(Lr = Er).forEach((Nr) => {
          Ir.db.objectStoreNames.contains(Nr) || kn(Ir, Nr, Lr[Nr].primKey, Lr[Nr].indexes);
        });
      });
    }(cr, ar, fr, lr).catch(gr);
  });
}
function xn(cr, ar) {
  const lr = { del: [], add: [], change: [] };
  let ur;
  for (ur in cr)
    ar[ur] || lr.del.push(ur);
  for (ur in ar) {
    const dr = cr[ur], fr = ar[ur];
    if (dr) {
      const gr = { name: ur, def: fr, recreate: !1, del: [], add: [], change: [] };
      if ("" + (dr.primKey.keyPath || "") != "" + (fr.primKey.keyPath || "") || dr.primKey.auto !== fr.primKey.auto && !wt)
        gr.recreate = !0, lr.change.push(gr);
      else {
        const mr = dr.idxByName, vr = fr.idxByName;
        let yr;
        for (yr in mr)
          vr[yr] || gr.del.push(yr);
        for (yr in vr) {
          const _r = mr[yr], kr = vr[yr];
          _r ? _r.src !== kr.src && gr.change.push(kr) : gr.add.push(kr);
        }
        (gr.del.length > 0 || gr.add.length > 0 || gr.change.length > 0) && lr.change.push(gr);
      }
    } else
      lr.add.push([ur, fr]);
  }
  return lr;
}
function kn(cr, ar, lr, ur) {
  const dr = cr.db.createObjectStore(ar, lr.keyPath ? { keyPath: lr.keyPath, autoIncrement: lr.auto } : { autoIncrement: lr.auto });
  return ur.forEach((fr) => En(dr, fr)), dr;
}
function En(cr, ar) {
  cr.createIndex(ar.name, ar.keyPath, { unique: ar.unique, multiEntry: ar.multi });
}
function Pn(cr, ar, lr) {
  const ur = {};
  return p(ar.objectStoreNames, 0).forEach((dr) => {
    const fr = lr.objectStore(dr);
    let gr = fr.keyPath;
    const mr = un(ln(gr), gr || "", !1, !1, !!fr.autoIncrement, gr && typeof gr != "string", !0), vr = [];
    for (let _r = 0; _r < fr.indexNames.length; ++_r) {
      const kr = fr.index(fr.indexNames[_r]);
      gr = kr.keyPath;
      var yr = un(kr.name, gr, !!kr.unique, !!kr.multiEntry, !1, gr && typeof gr != "string", !1);
      vr.push(yr);
    }
    ur[dr] = cn(dr, mr, vr);
  }), ur;
}
function Kn({ _novip: cr }, ar, lr) {
  const ur = lr.db.objectStoreNames;
  for (let dr = 0; dr < ur.length; ++dr) {
    const fr = ur[dr], gr = lr.objectStore(fr);
    cr._hasGetAll = "getAll" in gr;
    for (let mr = 0; mr < gr.indexNames.length; ++mr) {
      const vr = gr.indexNames[mr], yr = gr.index(vr).keyPath, _r = typeof yr == "string" ? yr : "[" + p(yr).join("+") + "]";
      if (ar[fr]) {
        const kr = ar[fr].idxByName[_r];
        kr && (kr.name = vr, delete ar[fr].idxByName[_r], ar[fr].idxByName[vr] = kr);
      }
    }
  }
  typeof navigator != "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (cr._hasGetAll = !1);
}
class On {
  _parseStoresSpec(ar, lr) {
    t(ar).forEach((ur) => {
      if (ar[ur] !== null) {
        var dr = ar[ur].split(",").map((gr, mr) => {
          const vr = (gr = gr.trim()).replace(/([&*]|\+\+)/g, ""), yr = /^\[/.test(vr) ? vr.match(/^\[(.*)\]$/)[1].split("+") : vr;
          return un(vr, yr || null, /\&/.test(gr), /\*/.test(gr), /\+\+/.test(gr), n(yr), mr === 0);
        }), fr = dr.shift();
        if (fr.multi)
          throw new X.Schema("Primary key cannot be multi-valued");
        dr.forEach((gr) => {
          if (gr.auto)
            throw new X.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!gr.keyPath)
            throw new X.Schema("Index must have a name and cannot be an empty string");
        }), lr[ur] = cn(ur, fr, dr);
      }
    });
  }
  stores(ar) {
    const lr = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, ar) : ar;
    const ur = lr._versions, dr = {};
    let fr = {};
    return ur.forEach((gr) => {
      r(dr, gr._cfg.storesSource), fr = gr._cfg.dbschema = {}, gr._parseStoresSpec(dr, fr);
    }), lr._dbSchema = fr, bn(lr, [lr._allTables, lr, lr.Transaction.prototype]), gn(lr, [lr._allTables, lr, lr.Transaction.prototype, this._cfg.tables], t(fr), fr), lr._storeNames = t(fr), this;
  }
  upgrade(ar) {
    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee$1, ar), this;
  }
}
function Sn(cr, ar) {
  let lr = cr._dbNamesDB;
  return lr || (lr = cr._dbNamesDB = new Xn(Pt, { addons: [], indexedDB: cr, IDBKeyRange: ar }), lr.version(1).stores({ dbnames: "name" })), lr.table("dbnames");
}
function An(cr) {
  return cr && typeof cr.databases == "function";
}
function Cn(cr) {
  return Ze(function() {
    return Oe.letThrough = !0, cr();
  });
}
function jn() {
  var cr;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ar) {
    var lr = function() {
      return indexedDB.databases().finally(ar);
    };
    cr = setInterval(lr, 100), lr();
  }).finally(function() {
    return clearInterval(cr);
  }) : Promise.resolve();
}
function Dn(cr) {
  const ar = cr._state, { indexedDB: lr } = cr._deps;
  if (ar.isBeingOpened || cr.idbdb)
    return ar.dbReadyPromise.then(() => ar.dbOpenError ? ft(ar.dbOpenError) : cr);
  R && (ar.openCanceller._stackHolder = q()), ar.isBeingOpened = !0, ar.dbOpenError = null, ar.openComplete = !1;
  const ur = ar.openCanceller;
  function dr() {
    if (ar.openCanceller !== ur)
      throw new X.DatabaseClosed("db.open() was cancelled");
  }
  let fr = ar.dbReadyResolve, gr = null, mr = !1;
  return je.race([ur, (typeof navigator == "undefined" ? je.resolve() : jn()).then(() => new je((vr, yr) => {
    if (dr(), !lr)
      throw new X.MissingAPI();
    const _r = cr.name, kr = ar.autoSchema ? lr.open(_r) : lr.open(_r, Math.round(10 * cr.verno));
    if (!kr)
      throw new X.MissingAPI();
    kr.onerror = tn(yr), kr.onblocked = Ye(cr._fireOnBlocked), kr.onupgradeneeded = Ye((xr) => {
      if (gr = kr.transaction, ar.autoSchema && !cr._options.allowEmptyDB) {
        kr.onerror = nn, gr.abort(), kr.result.close();
        const Er = lr.deleteDatabase(_r);
        Er.onsuccess = Er.onerror = Ye(() => {
          yr(new X.NoSuchDatabase(`Database ${_r} doesnt exist`));
        });
      } else {
        gr.onerror = tn(yr);
        var Ar = xr.oldVersion > Math.pow(2, 62) ? 0 : xr.oldVersion;
        mr = Ar < 1, cr._novip.idbdb = kr.result, wn(cr, Ar / 10, gr, yr);
      }
    }, yr), kr.onsuccess = Ye(() => {
      gr = null;
      const xr = cr._novip.idbdb = kr.result, Ar = p(xr.objectStoreNames);
      if (Ar.length > 0)
        try {
          const Cr = xr.transaction((Er = Ar).length === 1 ? Er[0] : Er, "readonly");
          ar.autoSchema ? function({ _novip: Tr }, Sr, Lr) {
            Tr.verno = Sr.version / 10;
            const Ir = Tr._dbSchema = Pn(0, Sr, Lr);
            Tr._storeNames = p(Sr.objectStoreNames, 0), gn(Tr, [Tr._allTables], t(Ir), Ir);
          }(cr, xr, Cr) : (Kn(cr, cr._dbSchema, Cr), function(Tr, Sr) {
            const Lr = xn(Pn(0, Tr.idbdb, Sr), Tr._dbSchema);
            return !(Lr.add.length || Lr.change.some((Ir) => Ir.add.length || Ir.change.length));
          }(cr, Cr) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), vn(cr, Cr);
        } catch (Cr) {
        }
      var Er;
      _t.push(cr), xr.onversionchange = Ye((Cr) => {
        ar.vcFired = !0, cr.on("versionchange").fire(Cr);
      }), xr.onclose = Ye((Cr) => {
        cr.on("close").fire(Cr);
      }), mr && function({ indexedDB: Cr, IDBKeyRange: Tr }, Sr) {
        !An(Cr) && Sr !== Pt && Sn(Cr, Tr).put({ name: Sr }).catch(ee$1);
      }(cr._deps, _r), vr();
    }, yr);
  }))]).then(() => (dr(), ar.onReadyBeingFired = [], je.resolve(Cn(() => cr.on.ready.fire(cr.vip))).then(function vr() {
    if (ar.onReadyBeingFired.length > 0) {
      let yr = ar.onReadyBeingFired.reduce(ue, ee$1);
      return ar.onReadyBeingFired = [], je.resolve(Cn(() => yr(cr.vip))).then(vr);
    }
  }))).finally(() => {
    ar.onReadyBeingFired = null, ar.isBeingOpened = !1;
  }).then(() => cr).catch((vr) => {
    ar.dbOpenError = vr;
    try {
      gr && gr.abort();
    } catch (yr) {
    }
    return ur === ar.openCanceller && cr._close(), ft(vr);
  }).finally(() => {
    ar.openComplete = !0, fr();
  });
}
function In(cr) {
  var ar = (fr) => cr.next(fr), lr = dr(ar), ur = dr((fr) => cr.throw(fr));
  function dr(fr) {
    return (gr) => {
      var mr = fr(gr), vr = mr.value;
      return mr.done ? vr : vr && typeof vr.then == "function" ? vr.then(lr, ur) : n(vr) ? Promise.all(vr).then(lr, ur) : lr(vr);
    };
  }
  return dr(ar)();
}
function Bn(cr, ar, lr) {
  var ur = arguments.length;
  if (ur < 2)
    throw new X.InvalidArgument("Too few arguments");
  for (var dr = new Array(ur - 1); --ur; )
    dr[ur - 1] = arguments[ur];
  return lr = dr.pop(), [cr, k(dr), lr];
}
function Tn(cr, ar, lr, ur, dr) {
  return je.resolve().then(() => {
    const fr = Oe.transless || Oe, gr = cr._createTransaction(ar, lr, cr._dbSchema, ur), mr = { trans: gr, transless: fr };
    if (ur)
      gr.idbtrans = ur.idbtrans;
    else
      try {
        gr.create(), cr._state.PR1398_maxLoop = 3;
      } catch (kr) {
        return kr.name === H.InvalidState && cr.isOpen() && --cr._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), cr._close(), cr.open().then(() => Tn(cr, ar, lr, null, dr))) : ft(kr);
      }
    const vr = T(dr);
    let yr;
    vr && et();
    const _r = je.follow(() => {
      if (yr = dr.call(gr, gr), yr)
        if (vr) {
          var kr = tt.bind(null, null);
          yr.then(kr, kr);
        } else
          typeof yr.next == "function" && typeof yr.throw == "function" && (yr = In(yr));
    }, mr);
    return (yr && typeof yr.then == "function" ? je.resolve(yr).then((kr) => gr.active ? kr : ft(new X.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : _r.then(() => yr)).then((kr) => (ur && gr._resolve(), gr._completion.then(() => kr))).catch((kr) => (gr._reject(kr), ft(kr)));
  });
}
function Rn(cr, ar, lr) {
  const ur = n(cr) ? cr.slice() : [cr];
  for (let dr = 0; dr < lr; ++dr)
    ur.push(ar);
  return ur;
}
const Fn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(cr) {
  return { ...cr, table(ar) {
    const lr = cr.table(ar), { schema: ur } = lr, dr = {}, fr = [];
    function gr(_r, kr, xr) {
      const Ar = yn(_r), Er = dr[Ar] = dr[Ar] || [], Cr = _r == null ? 0 : typeof _r == "string" ? 1 : _r.length, Tr = kr > 0, Sr = { ...xr, isVirtual: Tr, keyTail: kr, keyLength: Cr, extractKey: dn(_r), unique: !Tr && xr.unique };
      return Er.push(Sr), Sr.isPrimaryKey || fr.push(Sr), Cr > 1 && gr(Cr === 2 ? _r[0] : _r.slice(0, Cr - 1), kr + 1, xr), Er.sort((Lr, Ir) => Lr.keyTail - Ir.keyTail), Sr;
    }
    const mr = gr(ur.primaryKey.keyPath, 0, ur.primaryKey);
    dr[":id"] = [mr];
    for (const _r of ur.indexes)
      gr(_r.keyPath, 0, _r);
    function vr(_r) {
      const kr = _r.query.index;
      return kr.isVirtual ? { ..._r, query: { index: kr, range: (xr = _r.query.range, Ar = kr.keyTail, { type: xr.type === 1 ? 2 : xr.type, lower: Rn(xr.lower, xr.lowerOpen ? cr.MAX_KEY : cr.MIN_KEY, Ar), lowerOpen: !0, upper: Rn(xr.upper, xr.upperOpen ? cr.MIN_KEY : cr.MAX_KEY, Ar), upperOpen: !0 }) } } : _r;
      var xr, Ar;
    }
    return { ...lr, schema: { ...ur, primaryKey: mr, indexes: fr, getIndexByKeyPath: function(_r) {
      const kr = dr[yn(_r)];
      return kr && kr[0];
    } }, count: (_r) => lr.count(vr(_r)), query: (_r) => lr.query(vr(_r)), openCursor(_r) {
      const { keyTail: kr, isVirtual: xr, keyLength: Ar } = _r.query.index;
      return xr ? lr.openCursor(vr(_r)).then((Er) => Er && function(Cr) {
        return Object.create(Cr, { continue: { value: function(Sr) {
          Sr != null ? Cr.continue(Rn(Sr, _r.reverse ? cr.MAX_KEY : cr.MIN_KEY, kr)) : _r.unique ? Cr.continue(Cr.key.slice(0, Ar).concat(_r.reverse ? cr.MIN_KEY : cr.MAX_KEY, kr)) : Cr.continue();
        } }, continuePrimaryKey: { value(Sr, Lr) {
          Cr.continuePrimaryKey(Rn(Sr, cr.MAX_KEY, kr), Lr);
        } }, primaryKey: { get: () => Cr.primaryKey }, key: { get() {
          const Sr = Cr.key;
          return Ar === 1 ? Sr[0] : Sr.slice(0, Ar);
        } }, value: { get: () => Cr.value } });
      }(Er)) : lr.openCursor(_r);
    } };
  } };
} };
function Mn(cr, ar, lr, ur) {
  return lr = lr || {}, ur = ur || "", t(cr).forEach((dr) => {
    if (o(ar, dr)) {
      var fr = cr[dr], gr = ar[dr];
      if (typeof fr == "object" && typeof gr == "object" && fr && gr) {
        const mr = C(fr);
        mr !== C(gr) ? lr[ur + dr] = ar[dr] : mr === "Object" ? Mn(fr, gr, lr, ur + dr + ".") : fr !== gr && (lr[ur + dr] = ar[dr]);
      } else
        fr !== gr && (lr[ur + dr] = ar[dr]);
    } else
      lr[ur + dr] = void 0;
  }), t(ar).forEach((dr) => {
    o(cr, dr) || (lr[ur + dr] = ar[dr]);
  }), lr;
}
const Nn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (cr) => ({ ...cr, table(ar) {
  const lr = cr.table(ar), { primaryKey: ur } = lr.schema;
  return { ...lr, mutate(fr) {
    const gr = Oe.trans, { deleting: mr, creating: vr, updating: yr } = gr.table(ar).hook;
    switch (fr.type) {
      case "add":
        if (vr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => _r(fr), !0);
      case "put":
        if (vr.fire === ee$1 && yr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => _r(fr), !0);
      case "delete":
        if (mr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => _r(fr), !0);
      case "deleteRange":
        if (mr.fire === ee$1)
          break;
        return gr._promise("readwrite", () => function(xr) {
          return kr(xr.trans, xr.range, 1e4);
        }(fr), !0);
    }
    return lr.mutate(fr);
    function _r(xr) {
      const Ar = Oe.trans, Er = xr.keys || function(Cr, Tr) {
        return Tr.type === "delete" ? Tr.keys : Tr.keys || Tr.values.map(Cr.extractKey);
      }(ur, xr);
      if (!Er)
        throw new Error("Keys missing");
      return (xr = xr.type === "add" || xr.type === "put" ? { ...xr, keys: Er } : { ...xr }).type !== "delete" && (xr.values = [...xr.values]), xr.keys && (xr.keys = [...xr.keys]), function(Cr, Tr, Sr) {
        return Tr.type === "add" ? Promise.resolve([]) : Cr.getMany({ trans: Tr.trans, keys: Sr, cache: "immutable" });
      }(lr, xr, Er).then((Cr) => {
        const Tr = Er.map((Sr, Lr) => {
          const Ir = Cr[Lr], Nr = { onerror: null, onsuccess: null };
          if (xr.type === "delete")
            mr.fire.call(Nr, Sr, Ir, Ar);
          else if (xr.type === "add" || Ir === void 0) {
            const Rr = vr.fire.call(Nr, Sr, xr.values[Lr], Ar);
            Sr == null && Rr != null && (Sr = Rr, xr.keys[Lr] = Sr, ur.outbound || _(xr.values[Lr], ur.keyPath, Sr));
          } else {
            const Rr = Mn(Ir, xr.values[Lr]), Mr = yr.fire.call(Nr, Rr, Sr, Ir, Ar);
            if (Mr) {
              const Br = xr.values[Lr];
              Object.keys(Mr).forEach((Dr) => {
                o(Br, Dr) ? Br[Dr] = Mr[Dr] : _(Br, Dr, Mr[Dr]);
              });
            }
          }
          return Nr;
        });
        return lr.mutate(xr).then(({ failures: Sr, results: Lr, numFailures: Ir, lastResult: Nr }) => {
          for (let Rr = 0; Rr < Er.length; ++Rr) {
            const Mr = Lr ? Lr[Rr] : Er[Rr], Br = Tr[Rr];
            Mr == null ? Br.onerror && Br.onerror(Sr[Rr]) : Br.onsuccess && Br.onsuccess(xr.type === "put" && Cr[Rr] ? xr.values[Rr] : Mr);
          }
          return { failures: Sr, results: Lr, numFailures: Ir, lastResult: Nr };
        }).catch((Sr) => (Tr.forEach((Lr) => Lr.onerror && Lr.onerror(Sr)), Promise.reject(Sr)));
      });
    }
    function kr(xr, Ar, Er) {
      return lr.query({ trans: xr, values: !1, query: { index: ur, range: Ar }, limit: Er }).then(({ result: Cr }) => _r({ type: "delete", keys: Cr, trans: xr }).then((Tr) => Tr.numFailures > 0 ? Promise.reject(Tr.failures[0]) : Cr.length < Er ? { failures: [], numFailures: 0, lastResult: void 0 } : kr(xr, { ...Ar, lower: Cr[Cr.length - 1], lowerOpen: !0 }, Er)));
    }
  } };
} }) };
function qn(cr, ar, lr) {
  try {
    if (!ar || ar.keys.length < cr.length)
      return null;
    const ur = [];
    for (let dr = 0, fr = 0; dr < ar.keys.length && fr < cr.length; ++dr)
      $t(ar.keys[dr], cr[fr]) === 0 && (ur.push(lr ? O(ar.values[dr]) : ar.values[dr]), ++fr);
    return ur.length === cr.length ? ur : null;
  } catch (ur) {
    return null;
  }
}
const $n = { stack: "dbcore", level: -1, create: (cr) => ({ table: (ar) => {
  const lr = cr.table(ar);
  return { ...lr, getMany: (ur) => {
    if (!ur.cache)
      return lr.getMany(ur);
    const dr = qn(ur.keys, ur.trans._cache, ur.cache === "clone");
    return dr ? je.resolve(dr) : lr.getMany(ur).then((fr) => (ur.trans._cache = { keys: ur.keys, values: ur.cache === "clone" ? O(fr) : fr }, fr));
  }, mutate: (ur) => (ur.type !== "add" && (ur.trans._cache = null), lr.mutate(ur)) };
} }) };
function Un(cr) {
  return !("from" in cr);
}
const Ln = function(cr, ar) {
  if (!this) {
    const lr = new Ln();
    return cr && "d" in cr && r(lr, cr), lr;
  }
  r(this, arguments.length ? { d: 1, from: cr, to: arguments.length > 1 ? ar : cr } : { d: 0 });
};
function Vn(cr, ar, lr) {
  const ur = $t(ar, lr);
  if (isNaN(ur))
    return;
  if (ur > 0)
    throw RangeError();
  if (Un(cr))
    return r(cr, { from: ar, to: lr, d: 1 });
  const dr = cr.l, fr = cr.r;
  if ($t(lr, cr.from) < 0)
    return dr ? Vn(dr, ar, lr) : cr.l = { from: ar, to: lr, d: 1, l: null, r: null }, Gn(cr);
  if ($t(ar, cr.to) > 0)
    return fr ? Vn(fr, ar, lr) : cr.r = { from: ar, to: lr, d: 1, l: null, r: null }, Gn(cr);
  $t(ar, cr.from) < 0 && (cr.from = ar, cr.l = null, cr.d = fr ? fr.d + 1 : 1), $t(lr, cr.to) > 0 && (cr.to = lr, cr.r = null, cr.d = cr.l ? cr.l.d + 1 : 1);
  const gr = !cr.r;
  dr && !cr.l && Wn(cr, dr), fr && gr && Wn(cr, fr);
}
function Wn(cr, ar) {
  Un(ar) || function lr(ur, { from: dr, to: fr, l: gr, r: mr }) {
    Vn(ur, dr, fr), gr && lr(ur, gr), mr && lr(ur, mr);
  }(cr, ar);
}
function Yn(cr, ar) {
  const lr = zn(ar);
  let ur = lr.next();
  if (ur.done)
    return !1;
  let dr = ur.value;
  const fr = zn(cr);
  let gr = fr.next(dr.from), mr = gr.value;
  for (; !ur.done && !gr.done; ) {
    if ($t(mr.from, dr.to) <= 0 && $t(mr.to, dr.from) >= 0)
      return !0;
    $t(dr.from, mr.from) < 0 ? dr = (ur = lr.next(mr.from)).value : mr = (gr = fr.next(dr.from)).value;
  }
  return !1;
}
function zn(cr) {
  let ar = Un(cr) ? null : { s: 0, n: cr };
  return { next(lr) {
    const ur = arguments.length > 0;
    for (; ar; )
      switch (ar.s) {
        case 0:
          if (ar.s = 1, ur)
            for (; ar.n.l && $t(lr, ar.n.from) < 0; )
              ar = { up: ar, n: ar.n.l, s: 1 };
          else
            for (; ar.n.l; )
              ar = { up: ar, n: ar.n.l, s: 1 };
        case 1:
          if (ar.s = 2, !ur || $t(lr, ar.n.to) <= 0)
            return { value: ar.n, done: !1 };
        case 2:
          if (ar.n.r) {
            ar.s = 3, ar = { up: ar, n: ar.n.r, s: 0 };
            continue;
          }
        case 3:
          ar = ar.up;
      }
    return { done: !0 };
  } };
}
function Gn(cr) {
  var ar, lr;
  const ur = (((ar = cr.r) === null || ar === void 0 ? void 0 : ar.d) || 0) - (((lr = cr.l) === null || lr === void 0 ? void 0 : lr.d) || 0), dr = ur > 1 ? "r" : ur < -1 ? "l" : "";
  if (dr) {
    const fr = dr === "r" ? "l" : "r", gr = { ...cr }, mr = cr[dr];
    cr.from = mr.from, cr.to = mr.to, cr[dr] = mr[dr], gr[dr] = mr[fr], cr[fr] = gr, gr.d = Hn(gr);
  }
  cr.d = Hn(cr);
}
function Hn({ r: cr, l: ar }) {
  return (cr ? ar ? Math.max(cr.d, ar.d) : cr.d : ar ? ar.d : 0) + 1;
}
a(Ln.prototype, { add(cr) {
  return Wn(this, cr), this;
}, addKey(cr) {
  return Vn(this, cr, cr), this;
}, addKeys(cr) {
  return cr.forEach((ar) => Vn(this, ar, ar)), this;
}, [j]() {
  return zn(this);
} });
const Qn = { stack: "dbcore", level: 0, create: (cr) => {
  const ar = cr.schema.name, lr = new Ln(cr.MIN_KEY, cr.MAX_KEY);
  return { ...cr, table: (ur) => {
    const dr = cr.table(ur), { schema: fr } = dr, { primaryKey: gr } = fr, { extractKey: mr, outbound: vr } = gr, yr = { ...dr, mutate: (xr) => {
      const Ar = xr.trans, Er = Ar.mutatedParts || (Ar.mutatedParts = {}), Cr = (Mr) => {
        const Br = `idb://${ar}/${ur}/${Mr}`;
        return Er[Br] || (Er[Br] = new Ln());
      }, Tr = Cr(""), Sr = Cr(":dels"), { type: Lr } = xr;
      let [Ir, Nr] = xr.type === "deleteRange" ? [xr.range] : xr.type === "delete" ? [xr.keys] : xr.values.length < 50 ? [[], xr.values] : [];
      const Rr = xr.trans._cache;
      return dr.mutate(xr).then((Mr) => {
        if (n(Ir)) {
          Lr !== "delete" && (Ir = Mr.results), Tr.addKeys(Ir);
          const Br = qn(Ir, Rr);
          Br || Lr === "add" || Sr.addKeys(Ir), (Br || Nr) && function(Dr, Hr, Fr, zr) {
            function Ur(jr) {
              const Yr = Dr(jr.name || "");
              function qr(Jr) {
                return Jr != null ? jr.extractKey(Jr) : null;
              }
              const Wr = (Jr) => jr.multiEntry && n(Jr) ? Jr.forEach((Gr) => Yr.addKey(Gr)) : Yr.addKey(Jr);
              (Fr || zr).forEach((Jr, Gr) => {
                const Vr = Fr && qr(Fr[Gr]), Qr = zr && qr(zr[Gr]);
                $t(Vr, Qr) !== 0 && (Vr != null && Wr(Vr), Qr != null && Wr(Qr));
              });
            }
            Hr.indexes.forEach(Ur);
          }(Cr, fr, Br, Nr);
        } else if (Ir) {
          const Br = { from: Ir.lower, to: Ir.upper };
          Sr.add(Br), Tr.add(Br);
        } else
          Tr.add(lr), Sr.add(lr), fr.indexes.forEach((Br) => Cr(Br.name).add(lr));
        return Mr;
      });
    } }, _r = ({ query: { index: xr, range: Ar } }) => {
      var Er, Cr;
      return [xr, new Ln((Er = Ar.lower) !== null && Er !== void 0 ? Er : cr.MIN_KEY, (Cr = Ar.upper) !== null && Cr !== void 0 ? Cr : cr.MAX_KEY)];
    }, kr = { get: (xr) => [gr, new Ln(xr.key)], getMany: (xr) => [gr, new Ln().addKeys(xr.keys)], count: _r, query: _r, openCursor: _r };
    return t(kr).forEach((xr) => {
      yr[xr] = function(Ar) {
        const { subscr: Er } = Oe;
        if (Er) {
          const Cr = (Nr) => {
            const Rr = `idb://${ar}/${ur}/${Nr}`;
            return Er[Rr] || (Er[Rr] = new Ln());
          }, Tr = Cr(""), Sr = Cr(":dels"), [Lr, Ir] = kr[xr](Ar);
          if (Cr(Lr.name || "").add(Ir), !Lr.isPrimaryKey) {
            if (xr !== "count") {
              const Nr = xr === "query" && vr && Ar.values && dr.query({ ...Ar, values: !1 });
              return dr[xr].apply(this, arguments).then((Rr) => {
                if (xr === "query") {
                  if (vr && Ar.values)
                    return Nr.then(({ result: Br }) => (Tr.addKeys(Br), Rr));
                  const Mr = Ar.values ? Rr.result.map(mr) : Rr.result;
                  Ar.values ? Tr.addKeys(Mr) : Sr.addKeys(Mr);
                } else if (xr === "openCursor") {
                  const Mr = Rr, Br = Ar.values;
                  return Mr && Object.create(Mr, { key: { get: () => (Sr.addKey(Mr.primaryKey), Mr.key) }, primaryKey: { get() {
                    const Dr = Mr.primaryKey;
                    return Sr.addKey(Dr), Dr;
                  } }, value: { get: () => (Br && Tr.addKey(Mr.primaryKey), Mr.value) } });
                }
                return Rr;
              });
            }
            Sr.add(lr);
          }
        }
        return dr[xr].apply(this, arguments);
      };
    }), yr;
  } };
} };
class Xn {
  constructor(ar, lr) {
    this._middlewares = {}, this.verno = 0;
    const ur = Xn.dependencies;
    this._options = lr = { addons: Xn.addons, autoOpen: !0, indexedDB: ur.indexedDB, IDBKeyRange: ur.IDBKeyRange, ...lr }, this._deps = { indexedDB: lr.indexedDB, IDBKeyRange: lr.IDBKeyRange };
    const { addons: dr } = lr;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const fr = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: ee$1, dbReadyPromise: null, cancelOpen: ee$1, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var gr;
    fr.dbReadyPromise = new je((mr) => {
      fr.dbReadyResolve = mr;
    }), fr.openCanceller = new je((mr, vr) => {
      fr.cancelOpen = vr;
    }), this._state = fr, this.name = ar, this.on = Dt(this, "populate", "blocked", "versionchange", "close", { ready: [ue, ee$1] }), this.on.ready.subscribe = y(this.on.ready.subscribe, (mr) => (vr, yr) => {
      Xn.vip(() => {
        const _r = this._state;
        if (_r.openComplete)
          _r.dbOpenError || je.resolve().then(vr), yr && mr(vr);
        else if (_r.onReadyBeingFired)
          _r.onReadyBeingFired.push(vr), yr && mr(vr);
        else {
          mr(vr);
          const kr = this;
          yr || mr(function xr() {
            kr.on.ready.unsubscribe(vr), kr.on.ready.unsubscribe(xr);
          });
        }
      });
    }), this.Collection = (gr = this, It(Vt.prototype, function(mr, vr) {
      this.db = gr;
      let yr = At, _r = null;
      if (vr)
        try {
          yr = vr();
        } catch (Er) {
          _r = Er;
        }
      const kr = mr._ctx, xr = kr.table, Ar = xr.hook.reading.fire;
      this._ctx = { table: xr, index: kr.index, isPrimKey: !kr.index || xr.schema.primKey.keyPath && kr.index === xr.schema.primKey.name, range: yr, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: _r, or: kr.or, valueMapper: Ar !== te ? Ar : null };
    })), this.Table = function(mr) {
      return It(jt.prototype, function(vr, yr, _r) {
        this.db = mr, this._tx = _r, this.name = vr, this.schema = yr, this.hook = mr._allTables[vr] ? mr._allTables[vr].hook : Dt(null, { creating: [se, ee$1], reading: [ne$1, te], updating: [oe, ee$1], deleting: [ie$2, ee$1] });
      });
    }(this), this.Transaction = function(mr) {
      return It(an.prototype, function(vr, yr, _r, kr, xr) {
        this.db = mr, this.mode = vr, this.storeNames = yr, this.schema = _r, this.chromeTransactionDurability = kr, this.idbtrans = null, this.on = Dt(this, "complete", "error", "abort"), this.parent = xr || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je((Ar, Er) => {
          this._resolve = Ar, this._reject = Er;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (Ar) => {
          var Er = this.active;
          return this.active = !1, this.on.error.fire(Ar), this.parent ? this.parent._reject(Ar) : Er && this.idbtrans && this.idbtrans.abort(), ft(Ar);
        });
      });
    }(this), this.Version = function(mr) {
      return It(On.prototype, function(vr) {
        this.db = mr, this._cfg = { version: vr, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(mr) {
      return It(en.prototype, function(vr, yr, _r) {
        this.db = mr, this._ctx = { table: vr, index: yr === ":id" ? null : yr, or: _r };
        const kr = mr._deps.indexedDB;
        if (!kr)
          throw new X.MissingAPI();
        this._cmp = this._ascending = kr.cmp.bind(kr), this._descending = (xr, Ar) => kr.cmp(Ar, xr), this._max = (xr, Ar) => kr.cmp(xr, Ar) > 0 ? xr : Ar, this._min = (xr, Ar) => kr.cmp(xr, Ar) < 0 ? xr : Ar, this._IDBKeyRange = mr._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (mr) => {
      mr.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (mr) => {
      !mr.newVersion || mr.newVersion < mr.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${mr.oldVersion / 10}`);
    }), this._maxKey = hn(lr.IDBKeyRange), this._createTransaction = (mr, vr, yr, _r) => new this.Transaction(mr, vr, yr, this._options.chromeTransactionDurability, _r), this._fireOnBlocked = (mr) => {
      this.on("blocked").fire(mr), _t.filter((vr) => vr.name === this.name && vr !== this && !vr._state.vcFired).map((vr) => vr.on("versionchange").fire(mr));
    }, this.use(Fn), this.use(Nn), this.use(Qn), this.use($n), this.vip = Object.create(this, { _vip: { value: !0 } }), dr.forEach((mr) => mr(this));
  }
  version(ar) {
    if (isNaN(ar) || ar < 0.1)
      throw new X.Type("Given version is not a positive number");
    if (ar = Math.round(10 * ar) / 10, this.idbdb || this._state.isBeingOpened)
      throw new X.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, ar);
    const lr = this._versions;
    var ur = lr.filter((dr) => dr._cfg.version === ar)[0];
    return ur || (ur = new this.Version(ar), lr.push(ur), lr.sort(_n), ur.stores({}), this._state.autoSchema = !1, ur);
  }
  _whenReady(ar) {
    return this.idbdb && (this._state.openComplete || Oe.letThrough || this._vip) ? ar() : new je((lr, ur) => {
      if (this._state.openComplete)
        return ur(new X.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void ur(new X.DatabaseClosed());
        this.open().catch(ee$1);
      }
      this._state.dbReadyPromise.then(lr, ur);
    }).then(ar);
  }
  use({ stack: ar, create: lr, level: ur, name: dr }) {
    dr && this.unuse({ stack: ar, name: dr });
    const fr = this._middlewares[ar] || (this._middlewares[ar] = []);
    return fr.push({ stack: ar, create: lr, level: ur == null ? 10 : ur, name: dr }), fr.sort((gr, mr) => gr.level - mr.level), this;
  }
  unuse({ stack: ar, name: lr, create: ur }) {
    return ar && this._middlewares[ar] && (this._middlewares[ar] = this._middlewares[ar].filter((dr) => ur ? dr.create !== ur : !!lr && dr.name !== lr)), this;
  }
  open() {
    return Dn(this);
  }
  _close() {
    const ar = this._state, lr = _t.indexOf(this);
    if (lr >= 0 && _t.splice(lr, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch (ur) {
      }
      this._novip.idbdb = null;
    }
    ar.dbReadyPromise = new je((ur) => {
      ar.dbReadyResolve = ur;
    }), ar.openCanceller = new je((ur, dr) => {
      ar.cancelOpen = dr;
    });
  }
  close() {
    this._close();
    const ar = this._state;
    this._options.autoOpen = !1, ar.dbOpenError = new X.DatabaseClosed(), ar.isBeingOpened && ar.cancelOpen(ar.dbOpenError);
  }
  delete() {
    const ar = arguments.length > 0, lr = this._state;
    return new je((ur, dr) => {
      const fr = () => {
        this.close();
        var gr = this._deps.indexedDB.deleteDatabase(this.name);
        gr.onsuccess = Ye(() => {
          (function({ indexedDB: mr, IDBKeyRange: vr }, yr) {
            !An(mr) && yr !== Pt && Sn(mr, vr).delete(yr).catch(ee$1);
          })(this._deps, this.name), ur();
        }), gr.onerror = tn(dr), gr.onblocked = this._fireOnBlocked;
      };
      if (ar)
        throw new X.InvalidArgument("Arguments not allowed in db.delete()");
      lr.isBeingOpened ? lr.dbReadyPromise.then(fr) : fr();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const ar = this._state.dbOpenError;
    return ar && ar.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return t(this._allTables).map((ar) => this._allTables[ar]);
  }
  transaction() {
    const ar = Bn.apply(this, arguments);
    return this._transaction.apply(this, ar);
  }
  _transaction(ar, lr, ur) {
    let dr = Oe.trans;
    dr && dr.db === this && ar.indexOf("!") === -1 || (dr = null);
    const fr = ar.indexOf("?") !== -1;
    let gr, mr;
    ar = ar.replace("!", "").replace("?", "");
    try {
      if (mr = lr.map((yr) => {
        var _r = yr instanceof this.Table ? yr.name : yr;
        if (typeof _r != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return _r;
      }), ar == "r" || ar === Kt)
        gr = Kt;
      else {
        if (ar != "rw" && ar != Ot)
          throw new X.InvalidArgument("Invalid transaction mode: " + ar);
        gr = Ot;
      }
      if (dr) {
        if (dr.mode === Kt && gr === Ot) {
          if (!fr)
            throw new X.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          dr = null;
        }
        dr && mr.forEach((yr) => {
          if (dr && dr.storeNames.indexOf(yr) === -1) {
            if (!fr)
              throw new X.SubTransaction("Table " + yr + " not included in parent transaction.");
            dr = null;
          }
        }), fr && dr && !dr.active && (dr = null);
      }
    } catch (yr) {
      return dr ? dr._promise(null, (_r, kr) => {
        kr(yr);
      }) : ft(yr);
    }
    const vr = Tn.bind(null, this, gr, mr, dr, ur);
    return dr ? dr._promise(gr, vr, "lock") : Oe.trans ? at(Oe.transless, () => this._whenReady(vr)) : this._whenReady(vr);
  }
  table(ar) {
    if (!o(this._allTables, ar))
      throw new X.InvalidTable(`Table ${ar} does not exist`);
    return this._allTables[ar];
  }
}
const Jn = typeof Symbol != "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Zn {
  constructor(ar) {
    this._subscribe = ar;
  }
  subscribe(ar, lr, ur) {
    return this._subscribe(ar && typeof ar != "function" ? ar : { next: ar, error: lr, complete: ur });
  }
  [Jn]() {
    return this;
  }
}
function er(cr, ar) {
  return t(ar).forEach((lr) => {
    Wn(cr[lr] || (cr[lr] = new Ln()), ar[lr]);
  }), cr;
}
function tr(cr) {
  let ar, lr = !1;
  const ur = new Zn((dr) => {
    const fr = T(cr);
    let gr = !1, mr = {}, vr = {};
    const yr = { get closed() {
      return gr;
    }, unsubscribe: () => {
      gr = !0, on$1.storagemutated.unsubscribe(Ar);
    } };
    dr.start && dr.start(yr);
    let _r = !1, kr = !1;
    function xr() {
      return t(vr).some((Cr) => mr[Cr] && Yn(mr[Cr], vr[Cr]));
    }
    const Ar = (Cr) => {
      er(mr, Cr), xr() && Er();
    }, Er = () => {
      if (_r || gr)
        return;
      mr = {};
      const Cr = {}, Tr = function(Sr) {
        fr && et();
        const Lr = () => Ze(cr, { subscr: Sr, trans: null }), Ir = Oe.trans ? at(Oe.transless, Lr) : Lr();
        return fr && Ir.then(tt, tt), Ir;
      }(Cr);
      kr || (on$1(rn, Ar), kr = !0), _r = !0, Promise.resolve(Tr).then((Sr) => {
        lr = !0, ar = Sr, _r = !1, gr || (xr() ? Er() : (mr = {}, vr = Cr, dr.next && dr.next(Sr)));
      }, (Sr) => {
        _r = !1, lr = !1, dr.error && dr.error(Sr), yr.unsubscribe();
      });
    };
    return Er(), yr;
  });
  return ur.hasValue = () => lr, ur.getValue = () => ar, ur;
}
let nr;
try {
  nr = { indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB, IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange };
} catch (cr) {
  nr = { indexedDB: null, IDBKeyRange: null };
}
const rr = Xn;
function sr(cr) {
  let ar = ir;
  try {
    ir = !0, on$1.storagemutated.fire(cr);
  } finally {
    ir = ar;
  }
}
a(rr, { ...Z, delete: (cr) => new rr(cr, { addons: [] }).delete(), exists: (cr) => new rr(cr, { addons: [] }).open().then((ar) => (ar.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(cr) {
  try {
    return function({ indexedDB: ar, IDBKeyRange: lr }) {
      return An(ar) ? Promise.resolve(ar.databases()).then((ur) => ur.map((dr) => dr.name).filter((dr) => dr !== Pt)) : Sn(ar, lr).toCollection().primaryKeys();
    }(rr.dependencies).then(cr);
  } catch (ar) {
    return ft(new X.MissingAPI());
  }
}, defineClass: () => function(cr) {
  r(this, cr);
}, ignoreTransaction: (cr) => Oe.trans ? at(Oe.transless, cr) : cr(), vip: Cn, async: function(cr) {
  return function() {
    try {
      var ar = In(cr.apply(this, arguments));
      return ar && typeof ar.then == "function" ? ar : je.resolve(ar);
    } catch (lr) {
      return ft(lr);
    }
  };
}, spawn: function(cr, ar, lr) {
  try {
    var ur = In(cr.apply(lr, ar || []));
    return ur && typeof ur.then == "function" ? ur : je.resolve(ur);
  } catch (dr) {
    return ft(dr);
  }
}, currentTransaction: { get: () => Oe.trans || null }, waitFor: function(cr, ar) {
  const lr = je.resolve(typeof cr == "function" ? rr.ignoreTransaction(cr) : cr).timeout(ar || 6e4);
  return Oe.trans ? Oe.trans.waitFor(lr) : lr;
}, Promise: je, debug: { get: () => R, set: (cr) => {
  F(cr, cr === "dexie" ? () => !0 : Et);
} }, derive: c, extend: r, props: a, override: y, Events: Dt, on: on$1, liveQuery: tr, extendObservabilitySet: er, getByKeyPath: b, setByKeyPath: _, delByKeyPath: function(cr, ar) {
  typeof ar == "string" ? _(cr, ar, void 0) : "length" in ar && [].map.call(ar, function(lr) {
    _(cr, lr, void 0);
  });
}, shallowClone: w, deepClone: O, getObjectDiff: Mn, cmp: $t, asap: v, minKey: vt, addons: [], connections: _t, errnames: H, dependencies: nr, semVer: yt, version: yt.split(".").map((cr) => parseInt(cr)).reduce((cr, ar, lr) => cr + ar / Math.pow(10, 2 * lr)) }), rr.maxKey = hn(rr.dependencies.IDBKeyRange), typeof dispatchEvent != "undefined" && typeof addEventListener != "undefined" && (on$1(rn, (cr) => {
  if (!ir) {
    let ar;
    wt ? (ar = document.createEvent("CustomEvent"), ar.initCustomEvent(sn, !0, !0, cr)) : ar = new CustomEvent(sn, { detail: cr }), ir = !0, dispatchEvent(ar), ir = !1;
  }
}), addEventListener(sn, ({ detail: cr }) => {
  ir || sr(cr);
}));
let ir = !1;
if (typeof BroadcastChannel != "undefined") {
  const cr = new BroadcastChannel(sn);
  typeof cr.unref == "function" && cr.unref(), on$1(rn, (ar) => {
    ir || cr.postMessage(ar);
  }), cr.onmessage = (ar) => {
    ar.data && sr(ar.data);
  };
} else if (typeof self != "undefined" && typeof navigator != "undefined") {
  on$1(rn, (ar) => {
    try {
      ir || (typeof localStorage != "undefined" && localStorage.setItem(sn, JSON.stringify({ trig: Math.random(), changedParts: ar })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((lr) => lr.postMessage({ type: sn, changedParts: ar })));
    } catch (lr) {
    }
  }), typeof addEventListener != "undefined" && addEventListener("storage", (ar) => {
    if (ar.key === sn) {
      const lr = JSON.parse(ar.newValue);
      lr && sr(lr.changedParts);
    }
  });
  const cr = self.document && navigator.serviceWorker;
  cr && cr.addEventListener("message", function({ data: ar }) {
    ar && ar.type === sn && sr(ar.changedParts);
  });
}
je.rejectionMapper = function(cr, ar) {
  if (!cr || cr instanceof W || cr instanceof TypeError || cr instanceof SyntaxError || !cr.name || !J[cr.name])
    return cr;
  var lr = new J[cr.name](ar || cr.message, cr);
  return "stack" in cr && l(lr, "stack", { get: function() {
    return this.inner.stack;
  } }), lr;
}, F(R, Et);
var Database = class extends Xn {
  constructor(ar) {
    super(ar);
    ti(this, "users");
    ti(this, "events");
    ti(this, "eventTags");
    this.version(4).stores({
      users: "&pubkey, profile, createdAt",
      events: "&id, pubkey, content, kind, createdAt, relay, [kind+pubkey]",
      eventTags: "id, tagValue, tag, value, eventId"
    });
  }
}, db;
function createDatabase(cr) {
  db = new Database(cr);
}
var NDKCacheAdapterDexie = class {
  constructor(cr = {}) {
    ti(this, "debug");
    ti(this, "expirationTime");
    ti(this, "locking");
    ti(this, "profiles");
    ti(this, "dirtyProfiles", /* @__PURE__ */ new Set());
    createDatabase(cr.dbName || "ndk"), this.debug = cr.debug || _debug("ndk:dexie-adapter"), this.locking = !0, this.expirationTime = cr.expirationTime || 3600, cr.profileCacheSize !== "disabled" && (this.profiles = new dist$2.LRUCache({
      maxSize: cr.profileCacheSize || 1e5
    }), setInterval(() => {
      this.dumpProfiles();
    }, 1e3 * 10));
  }
  async query(cr) {
    Promise.allSettled(
      cr.filters.map((ar) => this.processFilter(ar, cr))
    );
  }
  async fetchProfile(cr) {
    if (!this.profiles)
      return null;
    let ar = this.profiles.get(cr);
    if (!ar) {
      const lr = await db.users.get({ pubkey: cr });
      lr && (ar = lr.profile, this.profiles.set(cr, ar));
    }
    return ar;
  }
  saveProfile(cr, ar) {
    this.profiles && (this.profiles.set(cr, ar), this.dirtyProfiles.add(cr));
  }
  async processFilter(cr, ar) {
    const lr = { ...cr };
    delete lr.limit;
    const ur = Object.keys(lr || {}).sort();
    try {
      await this.byKindAndAuthor(ur, cr, ar) || await this.byAuthors(ur, cr, ar) || await this.byKinds(ur, cr, ar) || await this.byIdsQuery(ur, cr, ar) || await this.byNip33Query(ur, cr, ar) || await this.byTagsAndOptionallyKinds(ur, cr, ar);
    } catch (dr) {
      console.error(dr);
    }
  }
  async setEvent(cr, ar, lr) {
    if (cr.kind === 0) {
      if (!this.profiles)
        return;
      const ur = profileFromEvent(cr);
      this.profiles.set(cr.pubkey, ur);
    } else {
      let ur = !0;
      if (cr.isParamReplaceable()) {
        const dr = `${cr.kind}:${cr.pubkey}:${cr.tagId()}`, fr = await db.events.where({ id: dr }).first();
        fr && cr.created_at && fr.createdAt > cr.created_at && (ur = !1);
      }
      ur && (db.events.put({
        id: cr.tagId(),
        pubkey: cr.pubkey,
        content: cr.content,
        kind: cr.kind,
        createdAt: cr.created_at,
        relay: lr == null ? void 0 : lr.url,
        event: JSON.stringify(cr.rawEvent())
      }), cr.kind !== 3 && cr.tags.forEach((dr) => {
        dr[0].length === 1 && db.eventTags.put({
          id: `${cr.id}:${dr[0]}:${dr[1]}`,
          eventId: cr.id,
          tag: dr[0],
          value: dr[1],
          tagValue: dr[0] + dr[1]
        });
      }));
    }
  }
  /**
   * Searches by authors
   */
  async byAuthors(cr, ar, lr) {
    const ur = ["authors"], dr = cr.length === ur.length && ur.every((gr) => cr.includes(gr));
    let fr = !1;
    if (dr && ar.authors)
      for (const gr of ar.authors) {
        const mr = await db.events.where({ pubkey: gr }).toArray();
        for (const vr of mr) {
          let yr;
          try {
            yr = JSON.parse(vr.event);
          } catch (xr) {
            console.log("failed to parse event", xr);
            continue;
          }
          const _r = new NDKEvent(void 0, yr), kr = vr.relay ? new NDKRelay(vr.relay) : void 0;
          lr.eventReceived(_r, kr, !0), fr = !0;
        }
      }
    return fr;
  }
  /**
   * Searches by kinds
   */
  async byKinds(cr, ar, lr) {
    const ur = ["kinds"], dr = cr.length === ur.length && ur.every((gr) => cr.includes(gr));
    let fr = !1;
    if (dr && ar.kinds)
      for (const gr of ar.kinds) {
        const mr = await db.events.where({ kind: gr }).toArray();
        for (const vr of mr) {
          let yr;
          try {
            yr = JSON.parse(vr.event);
          } catch (xr) {
            console.log("failed to parse event", xr);
            continue;
          }
          const _r = new NDKEvent(void 0, yr), kr = vr.relay ? new NDKRelay(vr.relay) : void 0;
          lr.eventReceived(_r, kr, !0), fr = !0;
        }
      }
    return fr;
  }
  /**
   * Searches by ids
   */
  async byIdsQuery(cr, ar, lr) {
    const ur = ["ids"];
    if (cr.length === ur.length && ur.every((fr) => cr.includes(fr)) && ar.ids) {
      for (const fr of ar.ids) {
        const gr = await db.events.where({ id: fr }).first();
        if (!gr)
          continue;
        let mr;
        try {
          mr = JSON.parse(gr.event);
        } catch (_r) {
          console.log("failed to parse event", _r);
          continue;
        }
        const vr = new NDKEvent(void 0, mr), yr = gr.relay ? new NDKRelay(gr.relay) : void 0;
        lr.eventReceived(vr, yr, !0);
      }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by NIP-33
   */
  async byNip33Query(cr, ar, lr) {
    const ur = ["#d", "authors", "kinds"];
    if (cr.length === ur.length && ur.every((fr) => cr.includes(fr)) && ar.kinds && ar.authors) {
      for (const fr of ar.kinds)
        if (fr >= 3e4 && fr < 4e4)
          for (const mr of ar.authors)
            for (const vr of ar["#d"]) {
              const yr = `${fr}:${mr}:${vr}`, _r = await db.events.where({ id: yr }).first();
              if (!_r)
                continue;
              let kr;
              try {
                kr = JSON.parse(_r.event);
              } catch (Er) {
                console.log("failed to parse event", Er);
                continue;
              }
              const xr = new NDKEvent(void 0, kr), Ar = _r.relay ? new NDKRelay(_r.relay) : void 0;
              lr.eventReceived(xr, Ar, !0);
            }
      return !0;
    }
    return !1;
  }
  /**
   * Searches by kind & author
   */
  async byKindAndAuthor(cr, ar, lr) {
    const ur = ["authors", "kinds"], dr = cr.length === ur.length && ur.every((gr) => cr.includes(gr));
    let fr = !1;
    if (!dr)
      return !1;
    if (ar.kinds && ar.authors)
      for (const gr of ar.kinds)
        for (const mr of ar.authors) {
          const vr = await db.events.where({ kind: gr, pubkey: mr }).toArray();
          for (const yr of vr) {
            let _r;
            try {
              _r = JSON.parse(yr.event);
            } catch (Ar) {
              console.log("failed to parse event", Ar);
              continue;
            }
            const kr = new NDKEvent(void 0, _r), xr = yr.relay ? new NDKRelay(yr.relay) : void 0;
            lr.eventReceived(kr, xr, !0), fr = !0;
          }
        }
    return fr;
  }
  /**
   * Searches by tags and optionally filters by tags
   */
  async byTagsAndOptionallyKinds(cr, ar, lr) {
    for (const fr of cr) {
      const gr = fr === "kinds", mr = fr.startsWith("#") && fr.length === 2;
      if (!gr && !mr)
        return !1;
    }
    const ur = await this.filterByTag(cr, ar), dr = ar.kinds;
    for (const fr of ur)
      dr != null && dr.includes(fr.kind) && lr.eventReceived(fr, void 0, !0);
    return !1;
  }
  async filterByTag(cr, ar) {
    const lr = [];
    for (const ur of cr) {
      if (ur.length !== 2)
        continue;
      const dr = ur.slice(1), fr = [];
      for (const [gr, mr] of Object.entries(ar))
        gr === ur && fr.push(mr);
      for (const gr of fr) {
        const mr = await db.eventTags.where({ tagValue: dr + gr }).toArray();
        if (!mr.length)
          continue;
        const vr = mr.map((_r) => _r.eventId), yr = await db.events.where("id").anyOf(vr).toArray();
        for (const _r of yr) {
          let kr;
          try {
            if (kr = JSON.parse(_r.event), !matchFilter(ar, kr))
              continue;
          } catch (Er) {
            console.log("failed to parse event", Er);
            continue;
          }
          const xr = new NDKEvent(void 0, kr), Ar = _r.relay ? new NDKRelay(_r.relay) : void 0;
          xr.relay = Ar, lr.push(xr);
        }
      }
    }
    return lr;
  }
  async dumpProfiles() {
    const cr = [];
    if (this.profiles) {
      for (const ar of this.dirtyProfiles) {
        const lr = this.profiles.get(ar);
        lr && cr.push({
          pubkey: ar,
          profile: lr,
          createdAt: Date.now()
        });
      }
      cr.length && await db.users.bulkPut(cr), this.dirtyProfiles.clear();
    }
  }
};
let cacheAdapter;
const defaulRelaysUrls = [
  // 'wss://purplepag.es',
  // 'wss://relay.nostr.band',
  "wss://nos.lol"
  // 'wss://offchain.pub/',
  // 'wss://nostr-pub.wellorder.net',
  // 'wss://nostr.mutinywallet.com '
];
window && (cacheAdapter = new NDKCacheAdapterDexie({
  dbName: "walletScrutiny",
  expirationTime: 3600 * 24 * 2
}));
const ndk = new src_default({
  explicitRelayUrls: defaulRelaysUrls,
  cacheAdapter,
  enableOutboxModel: !1
}), ndkStore = writable(ndk);
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: !0 });
dist$1.bech32m = bech32$1 = dist$1.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let cr = 0; cr < ALPHABET.length; cr++) {
  const ar = ALPHABET.charAt(cr);
  ALPHABET_MAP[ar] = cr;
}
function polymodStep(cr) {
  const ar = cr >> 25;
  return (cr & 33554431) << 5 ^ -(ar >> 0 & 1) & 996825010 ^ -(ar >> 1 & 1) & 642813549 ^ -(ar >> 2 & 1) & 513874426 ^ -(ar >> 3 & 1) & 1027748829 ^ -(ar >> 4 & 1) & 705979059;
}
function prefixChk(cr) {
  let ar = 1;
  for (let lr = 0; lr < cr.length; ++lr) {
    const ur = cr.charCodeAt(lr);
    if (ur < 33 || ur > 126)
      return "Invalid prefix (" + cr + ")";
    ar = polymodStep(ar) ^ ur >> 5;
  }
  ar = polymodStep(ar);
  for (let lr = 0; lr < cr.length; ++lr) {
    const ur = cr.charCodeAt(lr);
    ar = polymodStep(ar) ^ ur & 31;
  }
  return ar;
}
function convert(cr, ar, lr, ur) {
  let dr = 0, fr = 0;
  const gr = (1 << lr) - 1, mr = [];
  for (let vr = 0; vr < cr.length; ++vr)
    for (dr = dr << ar | cr[vr], fr += ar; fr >= lr; )
      fr -= lr, mr.push(dr >> fr & gr);
  if (ur)
    fr > 0 && mr.push(dr << lr - fr & gr);
  else {
    if (fr >= ar)
      return "Excess padding";
    if (dr << lr - fr & gr)
      return "Non-zero padding";
  }
  return mr;
}
function toWords(cr) {
  return convert(cr, 8, 5, !0);
}
function fromWordsUnsafe(cr) {
  const ar = convert(cr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
}
function fromWords(cr) {
  const ar = convert(cr, 5, 8, !1);
  if (Array.isArray(ar))
    return ar;
  throw new Error(ar);
}
function getLibraryFromEncoding(cr) {
  let ar;
  cr === "bech32" ? ar = 1 : ar = 734539939;
  function lr(gr, mr, vr) {
    if (vr = vr || 90, gr.length + 7 + mr.length > vr)
      throw new TypeError("Exceeds length limit");
    gr = gr.toLowerCase();
    let yr = prefixChk(gr);
    if (typeof yr == "string")
      throw new Error(yr);
    let _r = gr + "1";
    for (let kr = 0; kr < mr.length; ++kr) {
      const xr = mr[kr];
      if (xr >> 5)
        throw new Error("Non 5-bit word");
      yr = polymodStep(yr) ^ xr, _r += ALPHABET.charAt(xr);
    }
    for (let kr = 0; kr < 6; ++kr)
      yr = polymodStep(yr);
    yr ^= ar;
    for (let kr = 0; kr < 6; ++kr) {
      const xr = yr >> (5 - kr) * 5 & 31;
      _r += ALPHABET.charAt(xr);
    }
    return _r;
  }
  function ur(gr, mr) {
    if (mr = mr || 90, gr.length < 8)
      return gr + " too short";
    if (gr.length > mr)
      return "Exceeds length limit";
    const vr = gr.toLowerCase(), yr = gr.toUpperCase();
    if (gr !== vr && gr !== yr)
      return "Mixed-case string " + gr;
    gr = vr;
    const _r = gr.lastIndexOf("1");
    if (_r === -1)
      return "No separator character for " + gr;
    if (_r === 0)
      return "Missing prefix for " + gr;
    const kr = gr.slice(0, _r), xr = gr.slice(_r + 1);
    if (xr.length < 6)
      return "Data too short";
    let Ar = prefixChk(kr);
    if (typeof Ar == "string")
      return Ar;
    const Er = [];
    for (let Cr = 0; Cr < xr.length; ++Cr) {
      const Tr = xr.charAt(Cr), Sr = ALPHABET_MAP[Tr];
      if (Sr === void 0)
        return "Unknown character " + Tr;
      Ar = polymodStep(Ar) ^ Sr, !(Cr + 6 >= xr.length) && Er.push(Sr);
    }
    return Ar !== ar ? "Invalid checksum for " + gr : { prefix: kr, words: Er };
  }
  function dr(gr, mr) {
    const vr = ur(gr, mr);
    if (typeof vr == "object")
      return vr;
  }
  function fr(gr, mr) {
    const vr = ur(gr, mr);
    if (typeof vr == "object")
      return vr;
    throw new Error(vr);
  }
  return {
    decodeUnsafe: dr,
    decode: fr,
    encode: lr,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
var bech32$1 = dist$1.bech32 = getLibraryFromEncoding("bech32");
dist$1.bech32m = getLibraryFromEncoding("bech32m");
function hexToBytes$2(cr) {
  const ar = new Uint8Array(cr.length / 2);
  for (let lr = 0; lr < ar.length; lr++)
    ar[lr] = parseInt(cr.substring(lr * 2, lr * 2 + 2), 16);
  return ar;
}
function convertNostrPubKeyToBech32(cr, ar = "npub") {
  const lr = hexToBytes$2(cr);
  return bech32$1.encode(ar, bech32$1.toWords(lr));
}
async function fetchUserProfile(cr) {
  try {
    if (window) {
      const ar = await db.users.where({ pubkey: cr }).first();
      if (ar)
        return ar.profile;
      {
        const ur = get_store_value(ndkStore).getUser({ pubkey: cr });
        return await ur.fetchProfile({
          closeOnEose: !0,
          groupable: !1,
          groupableDelay: 200
        }), ur.profile;
      }
    } else
      return {};
  } catch (ar) {
    throw console.error(ar), ar;
  }
}
function logout() {
  ndkUser.set(null), isNip05Valid.set({
    isNip05Valid: null,
    Nip05address: void 0,
    UserNpub: void 0,
    Vanity: void 0,
    UserIdentifier: void 0
  }), activeProfile.set(null), localStore.update(() => ({
    lastUserLogged: void 0,
    pk: void 0
  }));
}
async function NDKlogin() {
  try {
    const cr = get_store_value(ndkStore), ar = new NDKNip07Signer();
    cr.signer = ar, ndkStore.set(cr);
    const lr = await ar.user(), ur = cr.getUser({
      pubkey: lr.pubkey,
      npub: lr.npub
    });
    return ndkUser.set(ur), localStore.set({ lastUserLogged: lr.npub, pk: void 0 }), ur;
  } catch (cr) {
    return;
  }
}
async function privkeyLogin(cr) {
  if (cr)
    try {
      const ar = get_store_value(ndkStore), lr = new NDKPrivateKeySigner(cr);
      ar.signer = lr, ndkStore.set(ar);
      const ur = await lr.user(), dr = ar.getUser({
        pubkey: ur.pubkey,
        npub: ur.npub
      });
      return ndkUser.set(dr), localStore.set({ lastUserLogged: ur.npub, pk: cr }), dr;
    } catch (ar) {
      return;
    }
}
function calculateRelativeTime(cr) {
  const ar = /* @__PURE__ */ new Date(), lr = new Date(cr * 1e3), ur = Math.floor((ar.valueOf() - lr.valueOf()) / 1e3);
  return ur < 60 ? `${ur} seconds ago` : ur < 3600 ? `${Math.floor(ur / 60)} minutes ago` : ur < 86400 ? `${Math.floor(ur / 3600)} hours ago` : `${Math.floor(ur / 86400)} days ago`;
}
function number$1(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bytes$1(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash$1(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(cr.outputLen), number$1(cr.blockLen);
}
function exists$1(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(cr, ar) {
  bytes$1(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const crypto$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$2 = (cr) => cr instanceof Uint8Array, createView$1 = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr$1 = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes$1(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes$2(cr)), !u8a$2(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes$2(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$2(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
let Hash$1 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(cr) {
  const ar = (ur) => cr().update(toBytes$1(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes$1(cr = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues == "function")
    return crypto$2.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
let SHA2$1 = class extends Hash$1 {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView$1(this.buffer);
  }
  update(ar) {
    exists$1(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes$1(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView$1(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    exists$1(this), output$1(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64$1(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView$1(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
};
const Chi$2 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj$1 = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class extends SHA2$1 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W$1[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W$1[kr - 15], Ar = SHA256_W$1[kr - 2], Er = rotr$1(xr, 7) ^ rotr$1(xr, 18) ^ xr >>> 3, Cr = rotr$1(Ar, 17) ^ rotr$1(Ar, 19) ^ Ar >>> 10;
      SHA256_W$1[kr] = Cr + SHA256_W$1[kr - 7] + Er + SHA256_W$1[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr$1(mr, 6) ^ rotr$1(mr, 11) ^ rotr$1(mr, 25), Ar = _r + xr + Chi$2(mr, vr, yr) + SHA256_K$1[kr] + SHA256_W$1[kr] | 0, Cr = (rotr$1(ur, 2) ^ rotr$1(ur, 13) ^ rotr$1(ur, 22)) + Maj$1(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a$1 = (cr) => cr instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex$1(cr) {
  if (!u8a$1(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes$1[cr[lr]];
  return ar;
}
function numberToHexUnpadded(cr) {
  const ar = cr.toString(16);
  return ar.length & 1 ? `0${ar}` : ar;
}
function hexToNumber(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  return BigInt(cr === "" ? "0" : `0x${cr}`);
}
function hexToBytes$1(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function bytesToNumberBE(cr) {
  return hexToNumber(bytesToHex$1(cr));
}
function bytesToNumberLE(cr) {
  if (!u8a$1(cr))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(cr).reverse()));
}
function numberToBytesBE(cr, ar) {
  return hexToBytes$1(cr.toString(16).padStart(ar * 2, "0"));
}
function numberToBytesLE(cr, ar) {
  return numberToBytesBE(cr, ar).reverse();
}
function numberToVarBytesBE(cr) {
  return hexToBytes$1(numberToHexUnpadded(cr));
}
function ensureBytes(cr, ar, lr) {
  let ur;
  if (typeof ar == "string")
    try {
      ur = hexToBytes$1(ar);
    } catch (fr) {
      throw new Error(`${cr} must be valid hex string, got "${ar}". Cause: ${fr}`);
    }
  else if (u8a$1(ar))
    ur = Uint8Array.from(ar);
  else
    throw new Error(`${cr} must be hex string or Uint8Array`);
  const dr = ur.length;
  if (typeof lr == "number" && dr !== lr)
    throw new Error(`${cr} expected ${lr} bytes, got ${dr}`);
  return ur;
}
function concatBytes$1(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a$1(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
function equalBytes(cr, ar) {
  if (cr.length !== ar.length)
    return !1;
  for (let lr = 0; lr < cr.length; lr++)
    if (cr[lr] !== ar[lr])
      return !1;
  return !0;
}
function utf8ToBytes$1(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function bitLen(cr) {
  let ar;
  for (ar = 0; cr > _0n$4; cr >>= _1n$4, ar += 1)
    ;
  return ar;
}
function bitGet(cr, ar) {
  return cr >> BigInt(ar) & _1n$4;
}
const bitSet = (cr, ar, lr) => cr | (lr ? _1n$4 : _0n$4) << BigInt(ar), bitMask = (cr) => (_2n$2 << BigInt(cr - 1)) - _1n$4, u8n = (cr) => new Uint8Array(cr), u8fr = (cr) => Uint8Array.from(cr);
function createHmacDrbg(cr, ar, lr) {
  if (typeof cr != "number" || cr < 2)
    throw new Error("hashLen must be a number");
  if (typeof ar != "number" || ar < 2)
    throw new Error("qByteLen must be a number");
  if (typeof lr != "function")
    throw new Error("hmacFn must be a function");
  let ur = u8n(cr), dr = u8n(cr), fr = 0;
  const gr = () => {
    ur.fill(1), dr.fill(0), fr = 0;
  }, mr = (...kr) => lr(dr, ur, ...kr), vr = (kr = u8n()) => {
    dr = mr(u8fr([0]), kr), ur = mr(), kr.length !== 0 && (dr = mr(u8fr([1]), kr), ur = mr());
  }, yr = () => {
    if (fr++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let kr = 0;
    const xr = [];
    for (; kr < ar; ) {
      ur = mr();
      const Ar = ur.slice();
      xr.push(Ar), kr += ur.length;
    }
    return concatBytes$1(...xr);
  };
  return (kr, xr) => {
    gr(), vr(kr);
    let Ar;
    for (; !(Ar = xr(yr())); )
      vr();
    return gr(), Ar;
  };
}
const validatorFns = {
  bigint: (cr) => typeof cr == "bigint",
  function: (cr) => typeof cr == "function",
  boolean: (cr) => typeof cr == "boolean",
  string: (cr) => typeof cr == "string",
  stringOrUint8Array: (cr) => typeof cr == "string" || cr instanceof Uint8Array,
  isSafeInteger: (cr) => Number.isSafeInteger(cr),
  array: (cr) => Array.isArray(cr),
  field: (cr, ar) => ar.Fp.isValid(cr),
  hash: (cr) => typeof cr == "function" && Number.isSafeInteger(cr.outputLen)
};
function validateObject(cr, ar, lr = {}) {
  const ur = (dr, fr, gr) => {
    const mr = validatorFns[fr];
    if (typeof mr != "function")
      throw new Error(`Invalid validator "${fr}", expected function`);
    const vr = cr[dr];
    if (!(gr && vr === void 0) && !mr(vr, cr))
      throw new Error(`Invalid param ${String(dr)}=${vr} (${typeof vr}), expected ${fr}`);
  };
  for (const [dr, fr] of Object.entries(ar))
    ur(dr, fr, !1);
  for (const [dr, fr] of Object.entries(lr))
    ur(dr, fr, !0);
  return cr;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes: concatBytes$1,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes: hexToBytes$1,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(cr, ar) {
  const lr = cr % ar;
  return lr >= _0n$3 ? lr : ar + lr;
}
function pow(cr, ar, lr) {
  if (lr <= _0n$3 || ar < _0n$3)
    throw new Error("Expected power/modulo > 0");
  if (lr === _1n$3)
    return _0n$3;
  let ur = _1n$3;
  for (; ar > _0n$3; )
    ar & _1n$3 && (ur = ur * cr % lr), cr = cr * cr % lr, ar >>= _1n$3;
  return ur;
}
function pow2(cr, ar, lr) {
  let ur = cr;
  for (; ar-- > _0n$3; )
    ur *= ur, ur %= lr;
  return ur;
}
function invert(cr, ar) {
  if (cr === _0n$3 || ar <= _0n$3)
    throw new Error(`invert: expected positive integers, got n=${cr} mod=${ar}`);
  let lr = mod(cr, ar), ur = ar, dr = _0n$3, fr = _1n$3;
  for (; lr !== _0n$3; ) {
    const mr = ur / lr, vr = ur % lr, yr = dr - fr * mr;
    ur = lr, lr = vr, dr = fr, fr = yr;
  }
  if (ur !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(dr, ar);
}
function tonelliShanks(cr) {
  const ar = (cr - _1n$3) / _2n$1;
  let lr, ur, dr;
  for (lr = cr - _1n$3, ur = 0; lr % _2n$1 === _0n$3; lr /= _2n$1, ur++)
    ;
  for (dr = _2n$1; dr < cr && pow(dr, ar, cr) !== cr - _1n$3; dr++)
    ;
  if (ur === 1) {
    const gr = (cr + _1n$3) / _4n;
    return function(vr, yr) {
      const _r = vr.pow(yr, gr);
      if (!vr.eql(vr.sqr(_r), yr))
        throw new Error("Cannot find square root");
      return _r;
    };
  }
  const fr = (lr + _1n$3) / _2n$1;
  return function(mr, vr) {
    if (mr.pow(vr, ar) === mr.neg(mr.ONE))
      throw new Error("Cannot find square root");
    let yr = ur, _r = mr.pow(mr.mul(mr.ONE, dr), lr), kr = mr.pow(vr, fr), xr = mr.pow(vr, lr);
    for (; !mr.eql(xr, mr.ONE); ) {
      if (mr.eql(xr, mr.ZERO))
        return mr.ZERO;
      let Ar = 1;
      for (let Cr = mr.sqr(xr); Ar < yr && !mr.eql(Cr, mr.ONE); Ar++)
        Cr = mr.sqr(Cr);
      const Er = mr.pow(_r, _1n$3 << BigInt(yr - Ar - 1));
      _r = mr.sqr(Er), kr = mr.mul(kr, Er), xr = mr.mul(xr, _r), yr = Ar;
    }
    return kr;
  };
}
function FpSqrt(cr) {
  if (cr % _4n === _3n$1) {
    const ar = (cr + _1n$3) / _4n;
    return function(ur, dr) {
      const fr = ur.pow(dr, ar);
      if (!ur.eql(ur.sqr(fr), dr))
        throw new Error("Cannot find square root");
      return fr;
    };
  }
  if (cr % _8n === _5n) {
    const ar = (cr - _5n) / _8n;
    return function(ur, dr) {
      const fr = ur.mul(dr, _2n$1), gr = ur.pow(fr, ar), mr = ur.mul(dr, gr), vr = ur.mul(ur.mul(mr, _2n$1), gr), yr = ur.mul(mr, ur.sub(vr, ur.ONE));
      if (!ur.eql(ur.sqr(yr), dr))
        throw new Error("Cannot find square root");
      return yr;
    };
  }
  return tonelliShanks(cr);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(cr) {
  const ar = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, lr = FIELD_FIELDS.reduce((ur, dr) => (ur[dr] = "function", ur), ar);
  return validateObject(cr, lr);
}
function FpPow(cr, ar, lr) {
  if (lr < _0n$3)
    throw new Error("Expected power > 0");
  if (lr === _0n$3)
    return cr.ONE;
  if (lr === _1n$3)
    return ar;
  let ur = cr.ONE, dr = ar;
  for (; lr > _0n$3; )
    lr & _1n$3 && (ur = cr.mul(ur, dr)), dr = cr.sqr(dr), lr >>= _1n$3;
  return ur;
}
function FpInvertBatch(cr, ar) {
  const lr = new Array(ar.length), ur = ar.reduce((fr, gr, mr) => cr.is0(gr) ? fr : (lr[mr] = fr, cr.mul(fr, gr)), cr.ONE), dr = cr.inv(ur);
  return ar.reduceRight((fr, gr, mr) => cr.is0(gr) ? fr : (lr[mr] = cr.mul(fr, lr[mr]), cr.mul(fr, gr)), dr), lr;
}
function nLength(cr, ar) {
  const lr = ar !== void 0 ? ar : cr.toString(2).length, ur = Math.ceil(lr / 8);
  return { nBitLength: lr, nByteLength: ur };
}
function Field(cr, ar, lr = !1, ur = {}) {
  if (cr <= _0n$3)
    throw new Error(`Expected Field ORDER > 0, got ${cr}`);
  const { nBitLength: dr, nByteLength: fr } = nLength(cr, ar);
  if (fr > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const gr = FpSqrt(cr), mr = Object.freeze({
    ORDER: cr,
    BITS: dr,
    BYTES: fr,
    MASK: bitMask(dr),
    ZERO: _0n$3,
    ONE: _1n$3,
    create: (vr) => mod(vr, cr),
    isValid: (vr) => {
      if (typeof vr != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof vr}`);
      return _0n$3 <= vr && vr < cr;
    },
    is0: (vr) => vr === _0n$3,
    isOdd: (vr) => (vr & _1n$3) === _1n$3,
    neg: (vr) => mod(-vr, cr),
    eql: (vr, yr) => vr === yr,
    sqr: (vr) => mod(vr * vr, cr),
    add: (vr, yr) => mod(vr + yr, cr),
    sub: (vr, yr) => mod(vr - yr, cr),
    mul: (vr, yr) => mod(vr * yr, cr),
    pow: (vr, yr) => FpPow(mr, vr, yr),
    div: (vr, yr) => mod(vr * invert(yr, cr), cr),
    // Same as above, but doesn't normalize
    sqrN: (vr) => vr * vr,
    addN: (vr, yr) => vr + yr,
    subN: (vr, yr) => vr - yr,
    mulN: (vr, yr) => vr * yr,
    inv: (vr) => invert(vr, cr),
    sqrt: ur.sqrt || ((vr) => gr(mr, vr)),
    invertBatch: (vr) => FpInvertBatch(mr, vr),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (vr, yr, _r) => _r ? yr : vr,
    toBytes: (vr) => lr ? numberToBytesLE(vr, fr) : numberToBytesBE(vr, fr),
    fromBytes: (vr) => {
      if (vr.length !== fr)
        throw new Error(`Fp.fromBytes: expected ${fr}, got ${vr.length}`);
      return lr ? bytesToNumberLE(vr) : bytesToNumberBE(vr);
    }
  });
  return Object.freeze(mr);
}
function getFieldBytesLength(cr) {
  if (typeof cr != "bigint")
    throw new Error("field order must be bigint");
  const ar = cr.toString(2).length;
  return Math.ceil(ar / 8);
}
function getMinHashLength(cr) {
  const ar = getFieldBytesLength(cr);
  return ar + Math.ceil(ar / 2);
}
function mapHashToField(cr, ar, lr = !1) {
  const ur = cr.length, dr = getFieldBytesLength(ar), fr = getMinHashLength(ar);
  if (ur < 16 || ur < fr || ur > 1024)
    throw new Error(`expected ${fr}-1024 bytes of input, got ${ur}`);
  const gr = lr ? bytesToNumberBE(cr) : bytesToNumberLE(cr), mr = mod(gr, ar - _1n$3) + _1n$3;
  return lr ? numberToBytesLE(mr, dr) : numberToBytesBE(mr, dr);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(cr, ar) {
  const lr = (dr, fr) => {
    const gr = fr.negate();
    return dr ? gr : fr;
  }, ur = (dr) => {
    const fr = Math.ceil(ar / dr) + 1, gr = 2 ** (dr - 1);
    return { windows: fr, windowSize: gr };
  };
  return {
    constTimeNegate: lr,
    // non-const time multiplication ladder
    unsafeLadder(dr, fr) {
      let gr = cr.ZERO, mr = dr;
      for (; fr > _0n$2; )
        fr & _1n$2 && (gr = gr.add(mr)), mr = mr.double(), fr >>= _1n$2;
      return gr;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(dr, fr) {
      const { windows: gr, windowSize: mr } = ur(fr), vr = [];
      let yr = dr, _r = yr;
      for (let kr = 0; kr < gr; kr++) {
        _r = yr, vr.push(_r);
        for (let xr = 1; xr < mr; xr++)
          _r = _r.add(yr), vr.push(_r);
        yr = _r.double();
      }
      return vr;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(dr, fr, gr) {
      const { windows: mr, windowSize: vr } = ur(dr);
      let yr = cr.ZERO, _r = cr.BASE;
      const kr = BigInt(2 ** dr - 1), xr = 2 ** dr, Ar = BigInt(dr);
      for (let Er = 0; Er < mr; Er++) {
        const Cr = Er * vr;
        let Tr = Number(gr & kr);
        gr >>= Ar, Tr > vr && (Tr -= xr, gr += _1n$2);
        const Sr = Cr, Lr = Cr + Math.abs(Tr) - 1, Ir = Er % 2 !== 0, Nr = Tr < 0;
        Tr === 0 ? _r = _r.add(lr(Ir, fr[Sr])) : yr = yr.add(lr(Nr, fr[Lr]));
      }
      return { p: yr, f: _r };
    },
    wNAFCached(dr, fr, gr, mr) {
      const vr = dr._WINDOW_SIZE || 1;
      let yr = fr.get(dr);
      return yr || (yr = this.precomputeWindow(dr, vr), vr !== 1 && fr.set(dr, mr(yr))), this.wNAF(vr, yr, gr);
    }
  };
}
function validateBasic(cr) {
  return validateField(cr.Fp), validateObject(cr, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(cr.n, cr.nBitLength),
    ...cr,
    p: cr.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(cr) {
  const ar = validateBasic(cr);
  validateObject(ar, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: lr, Fp: ur, a: dr } = ar;
  if (lr) {
    if (!ur.eql(dr, ur.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof lr != "object" || typeof lr.beta != "bigint" || typeof lr.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ar });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ar = "") {
      super(ar);
    }
  },
  _parseInt(cr) {
    const { Err: ar } = DER;
    if (cr.length < 2 || cr[0] !== 2)
      throw new ar("Invalid signature integer tag");
    const lr = cr[1], ur = cr.subarray(2, lr + 2);
    if (!lr || ur.length !== lr)
      throw new ar("Invalid signature integer: wrong length");
    if (ur[0] & 128)
      throw new ar("Invalid signature integer: negative");
    if (ur[0] === 0 && !(ur[1] & 128))
      throw new ar("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(ur), l: cr.subarray(lr + 2) };
  },
  toSig(cr) {
    const { Err: ar } = DER, lr = typeof cr == "string" ? h2b(cr) : cr;
    if (!(lr instanceof Uint8Array))
      throw new Error("ui8a expected");
    let ur = lr.length;
    if (ur < 2 || lr[0] != 48)
      throw new ar("Invalid signature tag");
    if (lr[1] !== ur - 2)
      throw new ar("Invalid signature: incorrect length");
    const { d: dr, l: fr } = DER._parseInt(lr.subarray(2)), { d: gr, l: mr } = DER._parseInt(fr);
    if (mr.length)
      throw new ar("Invalid signature: left bytes after parsing");
    return { r: dr, s: gr };
  },
  hexFromSig(cr) {
    const ar = (yr) => Number.parseInt(yr[0], 16) & 8 ? "00" + yr : yr, lr = (yr) => {
      const _r = yr.toString(16);
      return _r.length & 1 ? `0${_r}` : _r;
    }, ur = ar(lr(cr.s)), dr = ar(lr(cr.r)), fr = ur.length / 2, gr = dr.length / 2, mr = lr(fr), vr = lr(gr);
    return `30${lr(gr + fr + 4)}02${vr}${dr}02${mr}${ur}`;
  }
}, _0n$1 = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(cr) {
  const ar = validatePointOpts(cr), { Fp: lr } = ar, ur = ar.toBytes || ((Er, Cr, Tr) => {
    const Sr = Cr.toAffine();
    return concatBytes$1(Uint8Array.from([4]), lr.toBytes(Sr.x), lr.toBytes(Sr.y));
  }), dr = ar.fromBytes || ((Er) => {
    const Cr = Er.subarray(1), Tr = lr.fromBytes(Cr.subarray(0, lr.BYTES)), Sr = lr.fromBytes(Cr.subarray(lr.BYTES, 2 * lr.BYTES));
    return { x: Tr, y: Sr };
  });
  function fr(Er) {
    const { a: Cr, b: Tr } = ar, Sr = lr.sqr(Er), Lr = lr.mul(Sr, Er);
    return lr.add(lr.add(Lr, lr.mul(Er, Cr)), Tr);
  }
  if (!lr.eql(lr.sqr(ar.Gy), fr(ar.Gx)))
    throw new Error("bad generator point: equation left != right");
  function gr(Er) {
    return typeof Er == "bigint" && _0n$1 < Er && Er < ar.n;
  }
  function mr(Er) {
    if (!gr(Er))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function vr(Er) {
    const { allowedPrivateKeyLengths: Cr, nByteLength: Tr, wrapPrivateKey: Sr, n: Lr } = ar;
    if (Cr && typeof Er != "bigint") {
      if (Er instanceof Uint8Array && (Er = bytesToHex$1(Er)), typeof Er != "string" || !Cr.includes(Er.length))
        throw new Error("Invalid key");
      Er = Er.padStart(Tr * 2, "0");
    }
    let Ir;
    try {
      Ir = typeof Er == "bigint" ? Er : bytesToNumberBE(ensureBytes("private key", Er, Tr));
    } catch (Nr) {
      throw new Error(`private key must be ${Tr} bytes, hex or bigint, not ${typeof Er}`);
    }
    return Sr && (Ir = mod(Ir, Lr)), mr(Ir), Ir;
  }
  const yr = /* @__PURE__ */ new Map();
  function _r(Er) {
    if (!(Er instanceof kr))
      throw new Error("ProjectivePoint expected");
  }
  class kr {
    constructor(Cr, Tr, Sr) {
      if (this.px = Cr, this.py = Tr, this.pz = Sr, Cr == null || !lr.isValid(Cr))
        throw new Error("x required");
      if (Tr == null || !lr.isValid(Tr))
        throw new Error("y required");
      if (Sr == null || !lr.isValid(Sr))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Cr) {
      const { x: Tr, y: Sr } = Cr || {};
      if (!Cr || !lr.isValid(Tr) || !lr.isValid(Sr))
        throw new Error("invalid affine point");
      if (Cr instanceof kr)
        throw new Error("projective point not allowed");
      const Lr = (Ir) => lr.eql(Ir, lr.ZERO);
      return Lr(Tr) && Lr(Sr) ? kr.ZERO : new kr(Tr, Sr, lr.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Cr) {
      const Tr = lr.invertBatch(Cr.map((Sr) => Sr.pz));
      return Cr.map((Sr, Lr) => Sr.toAffine(Tr[Lr])).map(kr.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Cr) {
      const Tr = kr.fromAffine(dr(ensureBytes("pointHex", Cr)));
      return Tr.assertValidity(), Tr;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Cr) {
      return kr.BASE.multiply(vr(Cr));
    }
    // "Private method", don't use it directly
    _setWindowSize(Cr) {
      this._WINDOW_SIZE = Cr, yr.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ar.allowInfinityPoint && !lr.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Cr, y: Tr } = this.toAffine();
      if (!lr.isValid(Cr) || !lr.isValid(Tr))
        throw new Error("bad point: x or y not FE");
      const Sr = lr.sqr(Tr), Lr = fr(Cr);
      if (!lr.eql(Sr, Lr))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Cr } = this.toAffine();
      if (lr.isOdd)
        return !lr.isOdd(Cr);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Cr) {
      _r(Cr);
      const { px: Tr, py: Sr, pz: Lr } = this, { px: Ir, py: Nr, pz: Rr } = Cr, Mr = lr.eql(lr.mul(Tr, Rr), lr.mul(Ir, Lr)), Br = lr.eql(lr.mul(Sr, Rr), lr.mul(Nr, Lr));
      return Mr && Br;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new kr(this.px, lr.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Cr, b: Tr } = ar, Sr = lr.mul(Tr, _3n), { px: Lr, py: Ir, pz: Nr } = this;
      let Rr = lr.ZERO, Mr = lr.ZERO, Br = lr.ZERO, Dr = lr.mul(Lr, Lr), Hr = lr.mul(Ir, Ir), Fr = lr.mul(Nr, Nr), zr = lr.mul(Lr, Ir);
      return zr = lr.add(zr, zr), Br = lr.mul(Lr, Nr), Br = lr.add(Br, Br), Rr = lr.mul(Cr, Br), Mr = lr.mul(Sr, Fr), Mr = lr.add(Rr, Mr), Rr = lr.sub(Hr, Mr), Mr = lr.add(Hr, Mr), Mr = lr.mul(Rr, Mr), Rr = lr.mul(zr, Rr), Br = lr.mul(Sr, Br), Fr = lr.mul(Cr, Fr), zr = lr.sub(Dr, Fr), zr = lr.mul(Cr, zr), zr = lr.add(zr, Br), Br = lr.add(Dr, Dr), Dr = lr.add(Br, Dr), Dr = lr.add(Dr, Fr), Dr = lr.mul(Dr, zr), Mr = lr.add(Mr, Dr), Fr = lr.mul(Ir, Nr), Fr = lr.add(Fr, Fr), Dr = lr.mul(Fr, zr), Rr = lr.sub(Rr, Dr), Br = lr.mul(Fr, Hr), Br = lr.add(Br, Br), Br = lr.add(Br, Br), new kr(Rr, Mr, Br);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Cr) {
      _r(Cr);
      const { px: Tr, py: Sr, pz: Lr } = this, { px: Ir, py: Nr, pz: Rr } = Cr;
      let Mr = lr.ZERO, Br = lr.ZERO, Dr = lr.ZERO;
      const Hr = ar.a, Fr = lr.mul(ar.b, _3n);
      let zr = lr.mul(Tr, Ir), Ur = lr.mul(Sr, Nr), jr = lr.mul(Lr, Rr), Yr = lr.add(Tr, Sr), qr = lr.add(Ir, Nr);
      Yr = lr.mul(Yr, qr), qr = lr.add(zr, Ur), Yr = lr.sub(Yr, qr), qr = lr.add(Tr, Lr);
      let Wr = lr.add(Ir, Rr);
      return qr = lr.mul(qr, Wr), Wr = lr.add(zr, jr), qr = lr.sub(qr, Wr), Wr = lr.add(Sr, Lr), Mr = lr.add(Nr, Rr), Wr = lr.mul(Wr, Mr), Mr = lr.add(Ur, jr), Wr = lr.sub(Wr, Mr), Dr = lr.mul(Hr, qr), Mr = lr.mul(Fr, jr), Dr = lr.add(Mr, Dr), Mr = lr.sub(Ur, Dr), Dr = lr.add(Ur, Dr), Br = lr.mul(Mr, Dr), Ur = lr.add(zr, zr), Ur = lr.add(Ur, zr), jr = lr.mul(Hr, jr), qr = lr.mul(Fr, qr), Ur = lr.add(Ur, jr), jr = lr.sub(zr, jr), jr = lr.mul(Hr, jr), qr = lr.add(qr, jr), zr = lr.mul(Ur, qr), Br = lr.add(Br, zr), zr = lr.mul(Wr, qr), Mr = lr.mul(Yr, Mr), Mr = lr.sub(Mr, zr), zr = lr.mul(Yr, Ur), Dr = lr.mul(Wr, Dr), Dr = lr.add(Dr, zr), new kr(Mr, Br, Dr);
    }
    subtract(Cr) {
      return this.add(Cr.negate());
    }
    is0() {
      return this.equals(kr.ZERO);
    }
    wNAF(Cr) {
      return Ar.wNAFCached(this, yr, Cr, (Tr) => {
        const Sr = lr.invertBatch(Tr.map((Lr) => Lr.pz));
        return Tr.map((Lr, Ir) => Lr.toAffine(Sr[Ir])).map(kr.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Cr) {
      const Tr = kr.ZERO;
      if (Cr === _0n$1)
        return Tr;
      if (mr(Cr), Cr === _1n$1)
        return this;
      const { endo: Sr } = ar;
      if (!Sr)
        return Ar.unsafeLadder(this, Cr);
      let { k1neg: Lr, k1: Ir, k2neg: Nr, k2: Rr } = Sr.splitScalar(Cr), Mr = Tr, Br = Tr, Dr = this;
      for (; Ir > _0n$1 || Rr > _0n$1; )
        Ir & _1n$1 && (Mr = Mr.add(Dr)), Rr & _1n$1 && (Br = Br.add(Dr)), Dr = Dr.double(), Ir >>= _1n$1, Rr >>= _1n$1;
      return Lr && (Mr = Mr.negate()), Nr && (Br = Br.negate()), Br = new kr(lr.mul(Br.px, Sr.beta), Br.py, Br.pz), Mr.add(Br);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Cr) {
      mr(Cr);
      let Tr = Cr, Sr, Lr;
      const { endo: Ir } = ar;
      if (Ir) {
        const { k1neg: Nr, k1: Rr, k2neg: Mr, k2: Br } = Ir.splitScalar(Tr);
        let { p: Dr, f: Hr } = this.wNAF(Rr), { p: Fr, f: zr } = this.wNAF(Br);
        Dr = Ar.constTimeNegate(Nr, Dr), Fr = Ar.constTimeNegate(Mr, Fr), Fr = new kr(lr.mul(Fr.px, Ir.beta), Fr.py, Fr.pz), Sr = Dr.add(Fr), Lr = Hr.add(zr);
      } else {
        const { p: Nr, f: Rr } = this.wNAF(Tr);
        Sr = Nr, Lr = Rr;
      }
      return kr.normalizeZ([Sr, Lr])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Cr, Tr, Sr) {
      const Lr = kr.BASE, Ir = (Rr, Mr) => Mr === _0n$1 || Mr === _1n$1 || !Rr.equals(Lr) ? Rr.multiplyUnsafe(Mr) : Rr.multiply(Mr), Nr = Ir(this, Tr).add(Ir(Cr, Sr));
      return Nr.is0() ? void 0 : Nr;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(Cr) {
      const { px: Tr, py: Sr, pz: Lr } = this, Ir = this.is0();
      Cr == null && (Cr = Ir ? lr.ONE : lr.inv(Lr));
      const Nr = lr.mul(Tr, Cr), Rr = lr.mul(Sr, Cr), Mr = lr.mul(Lr, Cr);
      if (Ir)
        return { x: lr.ZERO, y: lr.ZERO };
      if (!lr.eql(Mr, lr.ONE))
        throw new Error("invZ was invalid");
      return { x: Nr, y: Rr };
    }
    isTorsionFree() {
      const { h: Cr, isTorsionFree: Tr } = ar;
      if (Cr === _1n$1)
        return !0;
      if (Tr)
        return Tr(kr, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Cr, clearCofactor: Tr } = ar;
      return Cr === _1n$1 ? this : Tr ? Tr(kr, this) : this.multiplyUnsafe(ar.h);
    }
    toRawBytes(Cr = !0) {
      return this.assertValidity(), ur(kr, this, Cr);
    }
    toHex(Cr = !0) {
      return bytesToHex$1(this.toRawBytes(Cr));
    }
  }
  kr.BASE = new kr(ar.Gx, ar.Gy, lr.ONE), kr.ZERO = new kr(lr.ZERO, lr.ONE, lr.ZERO);
  const xr = ar.nBitLength, Ar = wNAF(kr, ar.endo ? Math.ceil(xr / 2) : xr);
  return {
    CURVE: ar,
    ProjectivePoint: kr,
    normPrivateKeyToScalar: vr,
    weierstrassEquation: fr,
    isWithinCurveOrder: gr
  };
}
function validateOpts(cr) {
  const ar = validateBasic(cr);
  return validateObject(ar, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ar });
}
function weierstrass(cr) {
  const ar = validateOpts(cr), { Fp: lr, n: ur } = ar, dr = lr.BYTES + 1, fr = 2 * lr.BYTES + 1;
  function gr(qr) {
    return _0n$1 < qr && qr < lr.ORDER;
  }
  function mr(qr) {
    return mod(qr, ur);
  }
  function vr(qr) {
    return invert(qr, ur);
  }
  const { ProjectivePoint: yr, normPrivateKeyToScalar: _r, weierstrassEquation: kr, isWithinCurveOrder: xr } = weierstrassPoints({
    ...ar,
    toBytes(qr, Wr, Jr) {
      const Gr = Wr.toAffine(), Vr = lr.toBytes(Gr.x), Qr = concatBytes$1;
      return Jr ? Qr(Uint8Array.from([Wr.hasEvenY() ? 2 : 3]), Vr) : Qr(Uint8Array.from([4]), Vr, lr.toBytes(Gr.y));
    },
    fromBytes(qr) {
      const Wr = qr.length, Jr = qr[0], Gr = qr.subarray(1);
      if (Wr === dr && (Jr === 2 || Jr === 3)) {
        const Vr = bytesToNumberBE(Gr);
        if (!gr(Vr))
          throw new Error("Point is not on curve");
        const Qr = kr(Vr);
        let $r = lr.sqrt(Qr);
        const Xr = ($r & _1n$1) === _1n$1;
        return (Jr & 1) === 1 !== Xr && ($r = lr.neg($r)), { x: Vr, y: $r };
      } else if (Wr === fr && Jr === 4) {
        const Vr = lr.fromBytes(Gr.subarray(0, lr.BYTES)), Qr = lr.fromBytes(Gr.subarray(lr.BYTES, 2 * lr.BYTES));
        return { x: Vr, y: Qr };
      } else
        throw new Error(`Point of length ${Wr} was invalid. Expected ${dr} compressed bytes or ${fr} uncompressed bytes`);
    }
  }), Ar = (qr) => bytesToHex$1(numberToBytesBE(qr, ar.nByteLength));
  function Er(qr) {
    const Wr = ur >> _1n$1;
    return qr > Wr;
  }
  function Cr(qr) {
    return Er(qr) ? mr(-qr) : qr;
  }
  const Tr = (qr, Wr, Jr) => bytesToNumberBE(qr.slice(Wr, Jr));
  class Sr {
    constructor(Wr, Jr, Gr) {
      this.r = Wr, this.s = Jr, this.recovery = Gr, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Wr) {
      const Jr = ar.nByteLength;
      return Wr = ensureBytes("compactSignature", Wr, Jr * 2), new Sr(Tr(Wr, 0, Jr), Tr(Wr, Jr, 2 * Jr));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Wr) {
      const { r: Jr, s: Gr } = DER.toSig(ensureBytes("DER", Wr));
      return new Sr(Jr, Gr);
    }
    assertValidity() {
      if (!xr(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!xr(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Wr) {
      return new Sr(this.r, this.s, Wr);
    }
    recoverPublicKey(Wr) {
      const { r: Jr, s: Gr, recovery: Vr } = this, Qr = Br(ensureBytes("msgHash", Wr));
      if (Vr == null || ![0, 1, 2, 3].includes(Vr))
        throw new Error("recovery id invalid");
      const $r = Vr === 2 || Vr === 3 ? Jr + ar.n : Jr;
      if ($r >= lr.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Xr = Vr & 1 ? "03" : "02", si = yr.fromHex(Xr + Ar($r)), Zr = vr($r), li = mr(-Qr * Zr), Ei = mr(Gr * Zr), ki = yr.BASE.multiplyAndAddUnsafe(si, li, Ei);
      if (!ki)
        throw new Error("point at infinify");
      return ki.assertValidity(), ki;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return Er(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Sr(this.r, mr(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return Ar(this.r) + Ar(this.s);
    }
  }
  const Lr = {
    isValidPrivateKey(qr) {
      try {
        return _r(qr), !0;
      } catch (Wr) {
        return !1;
      }
    },
    normPrivateKeyToScalar: _r,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const qr = getMinHashLength(ar.n);
      return mapHashToField(ar.randomBytes(qr), ar.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(qr = 8, Wr = yr.BASE) {
      return Wr._setWindowSize(qr), Wr.multiply(BigInt(3)), Wr;
    }
  };
  function Ir(qr, Wr = !0) {
    return yr.fromPrivateKey(qr).toRawBytes(Wr);
  }
  function Nr(qr) {
    const Wr = qr instanceof Uint8Array, Jr = typeof qr == "string", Gr = (Wr || Jr) && qr.length;
    return Wr ? Gr === dr || Gr === fr : Jr ? Gr === 2 * dr || Gr === 2 * fr : qr instanceof yr;
  }
  function Rr(qr, Wr, Jr = !0) {
    if (Nr(qr))
      throw new Error("first arg must be private key");
    if (!Nr(Wr))
      throw new Error("second arg must be public key");
    return yr.fromHex(Wr).multiply(_r(qr)).toRawBytes(Jr);
  }
  const Mr = ar.bits2int || function(qr) {
    const Wr = bytesToNumberBE(qr), Jr = qr.length * 8 - ar.nBitLength;
    return Jr > 0 ? Wr >> BigInt(Jr) : Wr;
  }, Br = ar.bits2int_modN || function(qr) {
    return mr(Mr(qr));
  }, Dr = bitMask(ar.nBitLength);
  function Hr(qr) {
    if (typeof qr != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$1 <= qr && qr < Dr))
      throw new Error(`bigint expected < 2^${ar.nBitLength}`);
    return numberToBytesBE(qr, ar.nByteLength);
  }
  function Fr(qr, Wr, Jr = zr) {
    if (["recovered", "canonical"].some((hi) => hi in Jr))
      throw new Error("sign() legacy options not supported");
    const { hash: Gr, randomBytes: Vr } = ar;
    let { lowS: Qr, prehash: $r, extraEntropy: Xr } = Jr;
    Qr == null && (Qr = !0), qr = ensureBytes("msgHash", qr), $r && (qr = ensureBytes("prehashed msgHash", Gr(qr)));
    const si = Br(qr), Zr = _r(Wr), li = [Hr(Zr), Hr(si)];
    if (Xr != null) {
      const hi = Xr === !0 ? Vr(lr.BYTES) : Xr;
      li.push(ensureBytes("extraEntropy", hi));
    }
    const Ei = concatBytes$1(...li), ki = si;
    function Di(hi) {
      const Ti = Mr(hi);
      if (!xr(Ti))
        return;
      const fi = vr(Ti), Mi = yr.BASE.multiply(Ti).toAffine(), oi = mr(Mi.x);
      if (oi === _0n$1)
        return;
      const Ri = mr(fi * mr(ki + oi * Zr));
      if (Ri === _0n$1)
        return;
      let qi = (Mi.x === oi ? 0 : 2) | Number(Mi.y & _1n$1), zi = Ri;
      return Qr && Er(Ri) && (zi = Cr(Ri), qi ^= 1), new Sr(oi, zi, qi);
    }
    return { seed: Ei, k2sig: Di };
  }
  const zr = { lowS: ar.lowS, prehash: !1 }, Ur = { lowS: ar.lowS, prehash: !1 };
  function jr(qr, Wr, Jr = zr) {
    const { seed: Gr, k2sig: Vr } = Fr(qr, Wr, Jr), Qr = ar;
    return createHmacDrbg(Qr.hash.outputLen, Qr.nByteLength, Qr.hmac)(Gr, Vr);
  }
  yr.BASE._setWindowSize(8);
  function Yr(qr, Wr, Jr, Gr = Ur) {
    var Mi;
    const Vr = qr;
    if (Wr = ensureBytes("msgHash", Wr), Jr = ensureBytes("publicKey", Jr), "strict" in Gr)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Qr, prehash: $r } = Gr;
    let Xr, si;
    try {
      if (typeof Vr == "string" || Vr instanceof Uint8Array)
        try {
          Xr = Sr.fromDER(Vr);
        } catch (oi) {
          if (!(oi instanceof DER.Err))
            throw oi;
          Xr = Sr.fromCompact(Vr);
        }
      else if (typeof Vr == "object" && typeof Vr.r == "bigint" && typeof Vr.s == "bigint") {
        const { r: oi, s: Ri } = Vr;
        Xr = new Sr(oi, Ri);
      } else
        throw new Error("PARSE");
      si = yr.fromHex(Jr);
    } catch (oi) {
      if (oi.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Qr && Xr.hasHighS())
      return !1;
    $r && (Wr = ar.hash(Wr));
    const { r: Zr, s: li } = Xr, Ei = Br(Wr), ki = vr(li), Di = mr(Ei * ki), hi = mr(Zr * ki), Ti = (Mi = yr.BASE.multiplyAndAddUnsafe(si, Di, hi)) == null ? void 0 : Mi.toAffine();
    return Ti ? mr(Ti.x) === Zr : !1;
  }
  return {
    CURVE: ar,
    getPublicKey: Ir,
    getSharedSecret: Rr,
    sign: jr,
    verify: Yr,
    ProjectivePoint: yr,
    Signature: Sr,
    utils: Lr
  };
}
let HMAC$1 = class extends Hash$1 {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(ar);
    const ur = toBytes$1(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return exists$1(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    exists$1(this), bytes$1(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$1 = (cr, ar, lr) => new HMAC$1(cr, ar).update(lr).digest();
hmac$1.create = (cr, ar) => new HMAC$1(cr, ar);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(cr) {
  return {
    hash: cr,
    hmac: (ar, ...lr) => hmac$1(cr, ar, concatBytes$2(...lr)),
    randomBytes: randomBytes$1
  };
}
function createCurve(cr, ar) {
  const lr = (ur) => weierstrass({ ...cr, ...getHash(ur) });
  return Object.freeze({ ...lr(ar), create: lr });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (cr, ar) => (cr + ar / _2n) / ar;
function sqrtMod(cr) {
  const ar = secp256k1P, lr = BigInt(3), ur = BigInt(6), dr = BigInt(11), fr = BigInt(22), gr = BigInt(23), mr = BigInt(44), vr = BigInt(88), yr = cr * cr * cr % ar, _r = yr * yr * cr % ar, kr = pow2(_r, lr, ar) * _r % ar, xr = pow2(kr, lr, ar) * _r % ar, Ar = pow2(xr, _2n, ar) * yr % ar, Er = pow2(Ar, dr, ar) * Ar % ar, Cr = pow2(Er, fr, ar) * Er % ar, Tr = pow2(Cr, mr, ar) * Cr % ar, Sr = pow2(Tr, vr, ar) * Tr % ar, Lr = pow2(Sr, mr, ar) * Cr % ar, Ir = pow2(Lr, lr, ar) * _r % ar, Nr = pow2(Ir, gr, ar) * Er % ar, Rr = pow2(Nr, ur, ar) * yr % ar, Mr = pow2(Rr, _2n, ar);
  if (!Fp.eql(Fp.sqr(Mr), cr))
    throw new Error("Cannot find square root");
  return Mr;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (cr) => {
      const ar = secp256k1N, lr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ur = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), dr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), fr = lr, gr = BigInt("0x100000000000000000000000000000000"), mr = divNearest(fr * cr, ar), vr = divNearest(-ur * cr, ar);
      let yr = mod(cr - mr * lr - vr * dr, ar), _r = mod(-mr * ur - vr * fr, ar);
      const kr = yr > gr, xr = _r > gr;
      if (kr && (yr = ar - yr), xr && (_r = ar - _r), yr > gr || _r > gr)
        throw new Error("splitScalar: Endomorphism failed, k=" + cr);
      return { k1neg: kr, k1: yr, k2neg: xr, k2: _r };
    }
  }
}, sha256$1), _0n = BigInt(0), fe = (cr) => typeof cr == "bigint" && _0n < cr && cr < secp256k1P, ge$1 = (cr) => typeof cr == "bigint" && _0n < cr && cr < secp256k1N, TAGGED_HASH_PREFIXES = {};
function taggedHash(cr, ...ar) {
  let lr = TAGGED_HASH_PREFIXES[cr];
  if (lr === void 0) {
    const ur = sha256$1(Uint8Array.from(cr, (dr) => dr.charCodeAt(0)));
    lr = concatBytes$1(ur, ur), TAGGED_HASH_PREFIXES[cr] = lr;
  }
  return sha256$1(concatBytes$1(lr, ...ar));
}
const pointToBytes = (cr) => cr.toRawBytes(!0).slice(1), numTo32b = (cr) => numberToBytesBE(cr, 32), modP = (cr) => mod(cr, secp256k1P), modN = (cr) => mod(cr, secp256k1N), Point = secp256k1.ProjectivePoint, GmulAdd = (cr, ar, lr) => Point.BASE.multiplyAndAddUnsafe(cr, ar, lr);
function schnorrGetExtPubKey(cr) {
  let ar = secp256k1.utils.normPrivateKeyToScalar(cr), lr = Point.fromPrivateKey(ar);
  return { scalar: lr.hasEvenY() ? ar : modN(-ar), bytes: pointToBytes(lr) };
}
function lift_x(cr) {
  if (!fe(cr))
    throw new Error("bad x: need 0 < x < p");
  const ar = modP(cr * cr), lr = modP(ar * cr + BigInt(7));
  let ur = sqrtMod(lr);
  ur % _2n !== _0n && (ur = modP(-ur));
  const dr = new Point(cr, ur, _1n);
  return dr.assertValidity(), dr;
}
function challenge(...cr) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...cr)));
}
function schnorrGetPublicKey(cr) {
  return schnorrGetExtPubKey(cr).bytes;
}
function schnorrSign(cr, ar, lr = randomBytes$1(32)) {
  const ur = ensureBytes("message", cr), { bytes: dr, scalar: fr } = schnorrGetExtPubKey(ar), gr = ensureBytes("auxRand", lr, 32), mr = numTo32b(fr ^ bytesToNumberBE(taggedHash("BIP0340/aux", gr))), vr = taggedHash("BIP0340/nonce", mr, dr, ur), yr = modN(bytesToNumberBE(vr));
  if (yr === _0n)
    throw new Error("sign failed: k is zero");
  const { bytes: _r, scalar: kr } = schnorrGetExtPubKey(yr), xr = challenge(_r, dr, ur), Ar = new Uint8Array(64);
  if (Ar.set(_r, 0), Ar.set(numTo32b(modN(kr + xr * fr)), 32), !schnorrVerify(Ar, ur, dr))
    throw new Error("sign: Invalid signature produced");
  return Ar;
}
function schnorrVerify(cr, ar, lr) {
  const ur = ensureBytes("signature", cr, 64), dr = ensureBytes("message", ar), fr = ensureBytes("publicKey", lr, 32);
  try {
    const gr = lift_x(bytesToNumberBE(fr)), mr = bytesToNumberBE(ur.subarray(0, 32));
    if (!fe(mr))
      return !1;
    const vr = bytesToNumberBE(ur.subarray(32, 64));
    if (!ge$1(vr))
      return !1;
    const yr = challenge(numTo32b(mr), pointToBytes(gr), dr), _r = GmulAdd(gr, vr, modN(-yr));
    return !(!_r || !_r.hasEvenY() || _r.toAffine().x !== mr);
  } catch (gr) {
    return !1;
  }
}
const schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))(), crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (cr) => cr instanceof Uint8Array, createView = (cr) => new DataView(cr.buffer, cr.byteOffset, cr.byteLength), rotr = (cr, ar) => cr << 32 - ar | cr >>> ar, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const hexes = Array.from({ length: 256 }, (cr, ar) => ar.toString(16).padStart(2, "0"));
function bytesToHex(cr) {
  if (!u8a(cr))
    throw new Error("Uint8Array expected");
  let ar = "";
  for (let lr = 0; lr < cr.length; lr++)
    ar += hexes[cr[lr]];
  return ar;
}
function hexToBytes(cr) {
  if (typeof cr != "string")
    throw new Error("hex string expected, got " + typeof cr);
  const ar = cr.length;
  if (ar % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ar);
  const lr = new Uint8Array(ar / 2);
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = ur * 2, fr = cr.slice(dr, dr + 2), gr = Number.parseInt(fr, 16);
    if (Number.isNaN(gr) || gr < 0)
      throw new Error("Invalid byte sequence");
    lr[ur] = gr;
  }
  return lr;
}
function utf8ToBytes(cr) {
  if (typeof cr != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof cr}`);
  return new Uint8Array(new TextEncoder().encode(cr));
}
function toBytes(cr) {
  if (typeof cr == "string" && (cr = utf8ToBytes(cr)), !u8a(cr))
    throw new Error(`expected Uint8Array, got ${typeof cr}`);
  return cr;
}
function concatBytes(...cr) {
  const ar = new Uint8Array(cr.reduce((ur, dr) => ur + dr.length, 0));
  let lr = 0;
  return cr.forEach((ur) => {
    if (!u8a(ur))
      throw new Error("Uint8Array expected");
    ar.set(ur, lr), lr += ur.length;
  }), ar;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(cr) {
  const ar = (ur) => cr().update(toBytes(ur)).digest(), lr = cr();
  return ar.outputLen = lr.outputLen, ar.blockLen = lr.blockLen, ar.create = () => cr(), ar;
}
function randomBytes(cr = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(cr));
  throw new Error("crypto.getRandomValues must be defined");
}
function number(cr) {
  if (!Number.isSafeInteger(cr) || cr < 0)
    throw new Error(`Wrong positive integer: ${cr}`);
}
function bool(cr) {
  if (typeof cr != "boolean")
    throw new Error(`Expected boolean, not ${cr}`);
}
function bytes(cr, ...ar) {
  if (!(cr instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (ar.length > 0 && !ar.includes(cr.length))
    throw new Error(`Expected Uint8Array of length ${ar}, not of length=${cr.length}`);
}
function hash(cr) {
  if (typeof cr != "function" || typeof cr.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(cr.outputLen), number(cr.blockLen);
}
function exists(cr, ar = !0) {
  if (cr.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ar && cr.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(cr, ar) {
  bytes(cr);
  const lr = ar.outputLen;
  if (cr.length < lr)
    throw new Error(`digestInto() expects output buffer of length at least ${lr}`);
}
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
function setBigUint64(cr, ar, lr, ur) {
  if (typeof cr.setBigUint64 == "function")
    return cr.setBigUint64(ar, lr, ur);
  const dr = BigInt(32), fr = BigInt(4294967295), gr = Number(lr >> dr & fr), mr = Number(lr & fr), vr = ur ? 4 : 0, yr = ur ? 0 : 4;
  cr.setUint32(ar + vr, gr, ur), cr.setUint32(ar + yr, mr, ur);
}
class SHA2 extends Hash {
  constructor(ar, lr, ur, dr) {
    super(), this.blockLen = ar, this.outputLen = lr, this.padOffset = ur, this.isLE = dr, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ar), this.view = createView(this.buffer);
  }
  update(ar) {
    assert.exists(this);
    const { view: lr, buffer: ur, blockLen: dr } = this;
    ar = toBytes(ar);
    const fr = ar.length;
    for (let gr = 0; gr < fr; ) {
      const mr = Math.min(dr - this.pos, fr - gr);
      if (mr === dr) {
        const vr = createView(ar);
        for (; dr <= fr - gr; gr += dr)
          this.process(vr, gr);
        continue;
      }
      ur.set(ar.subarray(gr, gr + mr), this.pos), this.pos += mr, gr += mr, this.pos === dr && (this.process(lr, 0), this.pos = 0);
    }
    return this.length += ar.length, this.roundClean(), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.output(ar, this), this.finished = !0;
    const { buffer: lr, view: ur, blockLen: dr, isLE: fr } = this;
    let { pos: gr } = this;
    lr[gr++] = 128, this.buffer.subarray(gr).fill(0), this.padOffset > dr - gr && (this.process(ur, 0), gr = 0);
    for (let kr = gr; kr < dr; kr++)
      lr[kr] = 0;
    setBigUint64(ur, dr - 8, BigInt(this.length * 8), fr), this.process(ur, 0);
    const mr = createView(ar), vr = this.outputLen;
    if (vr % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const yr = vr / 4, _r = this.get();
    if (yr > _r.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let kr = 0; kr < yr; kr++)
      mr.setUint32(4 * kr, _r[kr], fr);
  }
  digest() {
    const { buffer: ar, outputLen: lr } = this;
    this.digestInto(ar);
    const ur = ar.slice(0, lr);
    return this.destroy(), ur;
  }
  _cloneInto(ar) {
    ar || (ar = new this.constructor()), ar.set(...this.get());
    const { blockLen: lr, buffer: ur, length: dr, finished: fr, destroyed: gr, pos: mr } = this;
    return ar.length = dr, ar.pos = mr, ar.finished = fr, ar.destroyed = gr, dr % lr && ar.buffer.set(ur), ar;
  }
}
const Chi$1 = (cr, ar, lr) => cr & ar ^ ~cr & lr, Maj = (cr, ar, lr) => cr & ar ^ cr & lr ^ ar & lr, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: ar, B: lr, C: ur, D: dr, E: fr, F: gr, G: mr, H: vr } = this;
    return [ar, lr, ur, dr, fr, gr, mr, vr];
  }
  // prettier-ignore
  set(ar, lr, ur, dr, fr, gr, mr, vr) {
    this.A = ar | 0, this.B = lr | 0, this.C = ur | 0, this.D = dr | 0, this.E = fr | 0, this.F = gr | 0, this.G = mr | 0, this.H = vr | 0;
  }
  process(ar, lr) {
    for (let kr = 0; kr < 16; kr++, lr += 4)
      SHA256_W[kr] = ar.getUint32(lr, !1);
    for (let kr = 16; kr < 64; kr++) {
      const xr = SHA256_W[kr - 15], Ar = SHA256_W[kr - 2], Er = rotr(xr, 7) ^ rotr(xr, 18) ^ xr >>> 3, Cr = rotr(Ar, 17) ^ rotr(Ar, 19) ^ Ar >>> 10;
      SHA256_W[kr] = Cr + SHA256_W[kr - 7] + Er + SHA256_W[kr - 16] | 0;
    }
    let { A: ur, B: dr, C: fr, D: gr, E: mr, F: vr, G: yr, H: _r } = this;
    for (let kr = 0; kr < 64; kr++) {
      const xr = rotr(mr, 6) ^ rotr(mr, 11) ^ rotr(mr, 25), Ar = _r + xr + Chi$1(mr, vr, yr) + SHA256_K[kr] + SHA256_W[kr] | 0, Cr = (rotr(ur, 2) ^ rotr(ur, 13) ^ rotr(ur, 22)) + Maj(ur, dr, fr) | 0;
      _r = yr, yr = vr, vr = mr, mr = gr + Ar | 0, gr = fr, fr = dr, dr = ur, ur = Ar + Cr | 0;
    }
    ur = ur + this.A | 0, dr = dr + this.B | 0, fr = fr + this.C | 0, gr = gr + this.D | 0, mr = mr + this.E | 0, vr = vr + this.F | 0, yr = yr + this.G | 0, _r = _r + this.H | 0, this.set(ur, dr, fr, gr, mr, vr, yr, _r);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const sha256 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber(cr) {
  if (!Number.isSafeInteger(cr))
    throw new Error(`Wrong integer: ${cr}`);
}
function chain(...cr) {
  const ar = (dr, fr) => (gr) => dr(fr(gr)), lr = Array.from(cr).reverse().reduce((dr, fr) => dr ? ar(dr, fr.encode) : fr.encode, void 0), ur = cr.reduce((dr, fr) => dr ? ar(dr, fr.decode) : fr.decode, void 0);
  return { encode: lr, decode: ur };
}
function alphabet(cr) {
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ar.map((lr) => {
        if (assertNumber(lr), lr < 0 || lr >= cr.length)
          throw new Error(`Digit index outside alphabet: ${lr} (alphabet: ${cr.length})`);
        return cr[lr];
      });
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ar.map((lr) => {
        if (typeof lr != "string")
          throw new Error(`alphabet.decode: not string element=${lr}`);
        const ur = cr.indexOf(lr);
        if (ur === -1)
          throw new Error(`Unknown letter: "${lr}". Allowed: ${cr}`);
        return ur;
      });
    }
  };
}
function join$1(cr = "") {
  if (typeof cr != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let lr of ar)
        if (typeof lr != "string")
          throw new Error(`join.encode: non-string input=${lr}`);
      return ar.join(cr);
    },
    decode: (ar) => {
      if (typeof ar != "string")
        throw new Error("join.decode input should be string");
      return ar.split(cr);
    }
  };
}
function padding(cr, ar = "=") {
  if (assertNumber(cr), typeof ar != "string")
    throw new Error("padding chr should be string");
  return {
    encode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let ur of lr)
        if (typeof ur != "string")
          throw new Error(`padding.encode: non-string input=${ur}`);
      for (; lr.length * cr % 8; )
        lr.push(ar);
      return lr;
    },
    decode(lr) {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let dr of lr)
        if (typeof dr != "string")
          throw new Error(`padding.decode: non-string input=${dr}`);
      let ur = lr.length;
      if (ur * cr % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; ur > 0 && lr[ur - 1] === ar; ur--)
        if (!((ur - 1) * cr % 8))
          throw new Error("Invalid padding: string has too much padding");
      return lr.slice(0, ur);
    }
  };
}
function normalize$1(cr) {
  if (typeof cr != "function")
    throw new Error("normalize fn should be function");
  return { encode: (ar) => ar, decode: (ar) => cr(ar) };
}
function convertRadix(cr, ar, lr) {
  if (ar < 2)
    throw new Error(`convertRadix: wrong from=${ar}, base cannot be less than 2`);
  if (lr < 2)
    throw new Error(`convertRadix: wrong to=${lr}, base cannot be less than 2`);
  if (!Array.isArray(cr))
    throw new Error("convertRadix: data should be array");
  if (!cr.length)
    return [];
  let ur = 0;
  const dr = [], fr = Array.from(cr);
  for (fr.forEach((gr) => {
    if (assertNumber(gr), gr < 0 || gr >= ar)
      throw new Error(`Wrong integer: ${gr}`);
  }); ; ) {
    let gr = 0, mr = !0;
    for (let vr = ur; vr < fr.length; vr++) {
      const yr = fr[vr], _r = ar * gr + yr;
      if (!Number.isSafeInteger(_r) || ar * gr / ar !== gr || _r - yr !== ar * gr)
        throw new Error("convertRadix: carry overflow");
      if (gr = _r % lr, fr[vr] = Math.floor(_r / lr), !Number.isSafeInteger(fr[vr]) || fr[vr] * lr + gr !== _r)
        throw new Error("convertRadix: carry overflow");
      if (mr)
        fr[vr] ? mr = !1 : ur = vr;
      else
        continue;
    }
    if (dr.push(gr), mr)
      break;
  }
  for (let gr = 0; gr < cr.length - 1 && cr[gr] === 0; gr++)
    dr.push(0);
  return dr.reverse();
}
const gcd = (cr, ar) => ar ? gcd(ar, cr % ar) : cr, radix2carry = (cr, ar) => cr + (ar - gcd(cr, ar));
function convertRadix2(cr, ar, lr, ur) {
  if (!Array.isArray(cr))
    throw new Error("convertRadix2: data should be array");
  if (ar <= 0 || ar > 32)
    throw new Error(`convertRadix2: wrong from=${ar}`);
  if (lr <= 0 || lr > 32)
    throw new Error(`convertRadix2: wrong to=${lr}`);
  if (radix2carry(ar, lr) > 32)
    throw new Error(`convertRadix2: carry overflow from=${ar} to=${lr} carryBits=${radix2carry(ar, lr)}`);
  let dr = 0, fr = 0;
  const gr = 2 ** lr - 1, mr = [];
  for (const vr of cr) {
    if (assertNumber(vr), vr >= 2 ** ar)
      throw new Error(`convertRadix2: invalid data word=${vr} from=${ar}`);
    if (dr = dr << ar | vr, fr + ar > 32)
      throw new Error(`convertRadix2: carry overflow pos=${fr} from=${ar}`);
    for (fr += ar; fr >= lr; fr -= lr)
      mr.push((dr >> fr - lr & gr) >>> 0);
    dr &= 2 ** fr - 1;
  }
  if (dr = dr << lr - fr & gr, !ur && fr >= ar)
    throw new Error("Excess padding");
  if (!ur && dr)
    throw new Error(`Non-zero padding: ${dr}`);
  return ur && fr > 0 && mr.push(dr >>> 0), mr;
}
function radix(cr) {
  return assertNumber(cr), {
    encode: (ar) => {
      if (!(ar instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(ar), 2 ** 8, cr);
    },
    decode: (ar) => {
      if (!Array.isArray(ar) || ar.length && typeof ar[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(ar, cr, 2 ** 8));
    }
  };
}
function radix2(cr, ar = !1) {
  if (assertNumber(cr), cr <= 0 || cr > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, cr) > 32 || radix2carry(cr, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (lr) => {
      if (!(lr instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(lr), 8, cr, !ar);
    },
    decode: (lr) => {
      if (!Array.isArray(lr) || lr.length && typeof lr[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(lr, cr, 8, ar));
    }
  };
}
function unsafeWrapper(cr) {
  if (typeof cr != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...ar) {
    try {
      return cr.apply(null, ar);
    } catch (lr) {
    }
  };
}
const base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join$1("")), base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join$1(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join$1(""), normalize$1((cr) => cr.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join$1("")), base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join$1("")), genBase58 = (cr) => chain(radix(58), alphabet(cr), join$1("")), base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11], base58xmr = {
  encode(cr) {
    let ar = "";
    for (let lr = 0; lr < cr.length; lr += 8) {
      const ur = cr.subarray(lr, lr + 8);
      ar += base58.encode(ur).padStart(XMR_BLOCK_LEN[ur.length], "1");
    }
    return ar;
  },
  decode(cr) {
    let ar = [];
    for (let lr = 0; lr < cr.length; lr += 11) {
      const ur = cr.slice(lr, lr + 11), dr = XMR_BLOCK_LEN.indexOf(ur.length), fr = base58.decode(ur);
      for (let gr = 0; gr < fr.length - dr; gr++)
        if (fr[gr] !== 0)
          throw new Error("base58xmr: wrong padding");
      ar = ar.concat(Array.from(fr.slice(fr.length - dr)));
    }
    return Uint8Array.from(ar);
  }
}, BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join$1("")), POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(cr) {
  const ar = cr >> 25;
  let lr = (cr & 33554431) << 5;
  for (let ur = 0; ur < POLYMOD_GENERATORS.length; ur++)
    (ar >> ur & 1) === 1 && (lr ^= POLYMOD_GENERATORS[ur]);
  return lr;
}
function bechChecksum(cr, ar, lr = 1) {
  const ur = cr.length;
  let dr = 1;
  for (let fr = 0; fr < ur; fr++) {
    const gr = cr.charCodeAt(fr);
    if (gr < 33 || gr > 126)
      throw new Error(`Invalid prefix (${cr})`);
    dr = bech32Polymod(dr) ^ gr >> 5;
  }
  dr = bech32Polymod(dr);
  for (let fr = 0; fr < ur; fr++)
    dr = bech32Polymod(dr) ^ cr.charCodeAt(fr) & 31;
  for (let fr of ar)
    dr = bech32Polymod(dr) ^ fr;
  for (let fr = 0; fr < 6; fr++)
    dr = bech32Polymod(dr);
  return dr ^= lr, BECH_ALPHABET.encode(convertRadix2([dr % 2 ** 30], 30, 5, !1));
}
function genBech32(cr) {
  const ar = cr === "bech32" ? 1 : 734539939, lr = radix2(5), ur = lr.decode, dr = lr.encode, fr = unsafeWrapper(ur);
  function gr(_r, kr, xr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof _r}`);
    if (!Array.isArray(kr) || kr.length && typeof kr[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof kr}`);
    const Ar = _r.length + 7 + kr.length;
    if (xr !== !1 && Ar > xr)
      throw new TypeError(`Length ${Ar} exceeds limit ${xr}`);
    return _r = _r.toLowerCase(), `${_r}1${BECH_ALPHABET.encode(kr)}${bechChecksum(_r, kr, ar)}`;
  }
  function mr(_r, kr = 90) {
    if (typeof _r != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof _r}`);
    if (_r.length < 8 || kr !== !1 && _r.length > kr)
      throw new TypeError(`Wrong string length: ${_r.length} (${_r}). Expected (8..${kr})`);
    const xr = _r.toLowerCase();
    if (_r !== xr && _r !== _r.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    _r = xr;
    const Ar = _r.lastIndexOf("1");
    if (Ar === 0 || Ar === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const Er = _r.slice(0, Ar), Cr = _r.slice(Ar + 1);
    if (Cr.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const Tr = BECH_ALPHABET.decode(Cr).slice(0, -6), Sr = bechChecksum(Er, Tr, ar);
    if (!Cr.endsWith(Sr))
      throw new Error(`Invalid checksum in ${_r}: expected "${Sr}"`);
    return { prefix: Er, words: Tr };
  }
  const vr = unsafeWrapper(mr);
  function yr(_r) {
    const { prefix: kr, words: xr } = mr(_r, !1);
    return { prefix: kr, words: xr, bytes: ur(xr) };
  }
  return { encode: gr, decode: mr, decodeToBytes: yr, decodeUnsafe: vr, fromWords: ur, fromWordsUnsafe: fr, toWords: dr };
}
const bech32 = genBech32("bech32");
genBech32("bech32m");
const utf8 = {
  encode: (cr) => new TextDecoder().decode(cr),
  decode: (cr) => new TextEncoder().encode(cr)
}, hex = chain(radix2(4), alphabet("0123456789abcdef"), join$1(""), normalize$1((cr) => {
  if (typeof cr != "string" || cr.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof cr} with length ${cr.length}`);
  return cr.toLowerCase();
})), CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
`${Object.keys(CODERS).join(", ")}`;
class HMAC extends Hash {
  constructor(ar, lr) {
    super(), this.finished = !1, this.destroyed = !1, assert.hash(ar);
    const ur = toBytes(lr);
    if (this.iHash = ar.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const dr = this.blockLen, fr = new Uint8Array(dr);
    fr.set(ur.length > dr ? ar.create().update(ur).digest() : ur);
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 54;
    this.iHash.update(fr), this.oHash = ar.create();
    for (let gr = 0; gr < fr.length; gr++)
      fr[gr] ^= 106;
    this.oHash.update(fr), fr.fill(0);
  }
  update(ar) {
    return assert.exists(this), this.iHash.update(ar), this;
  }
  digestInto(ar) {
    assert.exists(this), assert.bytes(ar, this.outputLen), this.finished = !0, this.iHash.digestInto(ar), this.oHash.update(ar), this.oHash.digestInto(ar), this.destroy();
  }
  digest() {
    const ar = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ar), ar;
  }
  _cloneInto(ar) {
    ar || (ar = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: lr, iHash: ur, finished: dr, destroyed: fr, blockLen: gr, outputLen: mr } = this;
    return ar = ar, ar.finished = dr, ar.destroyed = fr, ar.blockLen = gr, ar.outputLen = mr, ar.oHash = lr._cloneInto(ar.oHash), ar.iHash = ur._cloneInto(ar.iHash), ar;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (cr, ar, lr) => new HMAC(cr, ar).update(lr).digest();
hmac.create = (cr, ar) => new HMAC(cr, ar);
function extract(cr, ar, lr) {
  return assert.hash(cr), lr === void 0 && (lr = new Uint8Array(cr.outputLen)), hmac(cr, toBytes(lr), toBytes(ar));
}
const HKDF_COUNTER = new Uint8Array([0]), EMPTY_BUFFER = new Uint8Array();
function expand(cr, ar, lr, ur = 32) {
  if (assert.hash(cr), assert.number(ur), ur > 255 * cr.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const dr = Math.ceil(ur / cr.outputLen);
  lr === void 0 && (lr = EMPTY_BUFFER);
  const fr = new Uint8Array(dr * cr.outputLen), gr = hmac.create(cr, ar), mr = gr._cloneInto(), vr = new Uint8Array(gr.outputLen);
  for (let yr = 0; yr < dr; yr++)
    HKDF_COUNTER[0] = yr + 1, mr.update(yr === 0 ? EMPTY_BUFFER : vr).update(lr).update(HKDF_COUNTER).digestInto(vr), fr.set(vr, cr.outputLen * yr), gr._cloneInto(mr);
  return gr.destroy(), mr.destroy(), vr.fill(0), HKDF_COUNTER.fill(0), fr.slice(0, ur);
}
var __defProp = Object.defineProperty, __export = (cr, ar) => {
  for (var lr in ar)
    __defProp(cr, lr, { get: ar[lr], enumerable: !0 });
}, verifiedSymbol = Symbol("verified"), isRecord = (cr) => cr instanceof Object;
function validateEvent(cr) {
  if (!isRecord(cr) || typeof cr.kind != "number" || typeof cr.content != "string" || typeof cr.created_at != "number" || typeof cr.pubkey != "string" || !cr.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(cr.tags))
    return !1;
  for (let ar = 0; ar < cr.tags.length; ar++) {
    let lr = cr.tags[ar];
    if (!Array.isArray(lr))
      return !1;
    for (let ur = 0; ur < lr.length; ur++)
      if (typeof lr[ur] == "object")
        return !1;
  }
  return !0;
}
var utils_exports = {};
__export(utils_exports, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8"), utf8Encoder = new TextEncoder();
function normalizeURL(cr) {
  cr.indexOf("://") === -1 && (cr = "wss://" + cr);
  let ar = new URL(cr);
  return ar.pathname = ar.pathname.replace(/\/+/g, "/"), ar.pathname.endsWith("/") && (ar.pathname = ar.pathname.slice(0, -1)), (ar.port === "80" && ar.protocol === "ws:" || ar.port === "443" && ar.protocol === "wss:") && (ar.port = ""), ar.searchParams.sort(), ar.hash = "", ar.toString();
}
function insertEventIntoDescendingList(cr, ar) {
  const [lr, ur] = binarySearch(cr, (dr) => ar.id === dr.id ? 0 : ar.created_at === dr.created_at ? -1 : dr.created_at - ar.created_at);
  return ur || cr.splice(lr, 0, ar), cr;
}
function insertEventIntoAscendingList(cr, ar) {
  const [lr, ur] = binarySearch(cr, (dr) => ar.id === dr.id ? 0 : ar.created_at === dr.created_at ? -1 : ar.created_at - dr.created_at);
  return ur || cr.splice(lr, 0, ar), cr;
}
function binarySearch(cr, ar) {
  let lr = 0, ur = cr.length - 1;
  for (; lr <= ur; ) {
    const dr = Math.floor((lr + ur) / 2), fr = ar(cr[dr]);
    if (fr === 0)
      return [dr, !0];
    fr < 0 ? ur = dr - 1 : lr = dr + 1;
  }
  return [lr, !1];
}
var QueueNode = class {
  constructor(cr) {
    ti(this, "value");
    ti(this, "next", null);
    ti(this, "prev", null);
    this.value = cr;
  }
}, Queue = class {
  constructor() {
    ti(this, "first");
    ti(this, "last");
    this.first = null, this.last = null;
  }
  enqueue(cr) {
    const ar = new QueueNode(cr);
    return this.last ? this.last === this.first ? (this.last = ar, this.last.prev = this.first, this.first.next = ar) : (ar.prev = this.last, this.last.next = ar, this.last = ar) : (this.first = ar, this.last = ar), !0;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const ar = this.first;
      return this.first = null, this.last = null, ar.value;
    }
    const cr = this.first;
    return this.first = cr.next, cr.value;
  }
}, JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(cr) {
    return bytesToHex(schnorr.getPublicKey(cr));
  }
  finalizeEvent(cr, ar) {
    const lr = cr;
    return lr.pubkey = bytesToHex(schnorr.getPublicKey(ar)), lr.id = getEventHash(lr), lr.sig = bytesToHex(schnorr.sign(getEventHash(lr), ar)), lr[verifiedSymbol] = !0, lr;
  }
  verifyEvent(cr) {
    if (typeof cr[verifiedSymbol] == "boolean")
      return cr[verifiedSymbol];
    const ar = getEventHash(cr);
    if (ar !== cr.id)
      return cr[verifiedSymbol] = !1, !1;
    try {
      const lr = schnorr.verify(cr.sig, ar, cr.pubkey);
      return cr[verifiedSymbol] = lr, lr;
    } catch (lr) {
      return cr[verifiedSymbol] = !1, !1;
    }
  }
};
function serializeEvent(cr) {
  if (!validateEvent(cr))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, cr.pubkey, cr.created_at, cr.kind, cr.tags, cr.content]);
}
function getEventHash(cr) {
  let ar = sha256(utf8Encoder.encode(serializeEvent(cr)));
  return bytesToHex(ar);
}
var i$1 = new JS();
i$1.generateSecretKey;
i$1.getPublicKey;
var finalizeEvent = i$1.finalizeEvent, verifyEvent = i$1.verifyEvent, kinds_exports = {};
__export(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EncryptedDirectMessages: () => EncryptedDirectMessages,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isEphemeralKind: () => isEphemeralKind,
  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(cr) {
  return 1e3 <= cr && cr < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(cr);
}
function isReplaceableKind(cr) {
  return [0, 3].includes(cr) || 1e4 <= cr && cr < 2e4;
}
function isEphemeralKind(cr) {
  return 2e4 <= cr && cr < 3e4;
}
function isParameterizedReplaceableKind(cr) {
  return 3e4 <= cr && cr < 4e4;
}
function classifyKind(cr) {
  return isRegularKind(cr) ? "regular" : isReplaceableKind(cr) ? "replaceable" : isEphemeralKind(cr) ? "ephemeral" : isParameterizedReplaceableKind(cr) ? "parameterized" : "unknown";
}
var Metadata = 0, ShortTextNote = 1, RecommendRelay = 2, Contacts = 3, EncryptedDirectMessage = 4, EncryptedDirectMessages = 4, EventDeletion = 5, Repost = 6, Reaction = 7, BadgeAward = 8, GenericRepost = 16, ChannelCreation = 40, ChannelMetadata = 41, ChannelMessage = 42, ChannelHideMessage = 43, ChannelMuteUser = 44, OpenTimestamps = 1040, FileMetadata = 1063, LiveChatMessage = 1311, ProblemTracker = 1971, Report = 1984, Reporting = 1984, Label = 1985, CommunityPostApproval = 4550, JobRequest = 5999, JobResult = 6999, JobFeedback = 7e3, ZapGoal = 9041, ZapRequest = 9734, Zap = 9735, Highlights = 9802, Mutelist = 1e4, Pinlist = 10001, RelayList = 10002, BookmarkList = 10003, CommunitiesList = 10004, PublicChatsList = 10005, BlockedRelaysList = 10006, SearchRelaysList = 10007, InterestsList = 10015, UserEmojiList = 10030, FileServerPreference = 10096, NWCWalletInfo = 13194, LightningPubRPC = 21e3, ClientAuth = 22242, NWCWalletRequest = 23194, NWCWalletResponse = 23195, NostrConnect = 24133, HTTPAuth = 27235, Followsets = 3e4, Genericlists = 30001, Relaysets = 30002, Bookmarksets = 30003, Curationsets = 30004, ProfileBadges = 30008, BadgeDefinition = 30009, Interestsets = 30015, CreateOrUpdateStall = 30017, CreateOrUpdateProduct = 30018, LongFormArticle = 30023, DraftLong = 30024, Emojisets = 30030, Application = 30078, LiveEvent = 30311, UserStatuses = 30315, ClassifiedListing = 30402, DraftClassifiedListing = 30403, Date2 = 31922, Time = 31923, Calendar = 31924, CalendarEventRSVP = 31925, Handlerrecommendation = 31989, Handlerinformation = 31990, CommunityDefinition = 34550, fakejson_exports = {};
__export(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(cr, ar) {
  let lr = ar.length + 3, ur = cr.indexOf(`"${ar}":`) + lr, dr = cr.slice(ur).indexOf('"') + ur + 1;
  return cr.slice(dr, dr + 64);
}
function getInt(cr, ar) {
  let lr = ar.length, ur = cr.indexOf(`"${ar}":`) + lr + 3, dr = cr.slice(ur), fr = Math.min(dr.indexOf(","), dr.indexOf("}"));
  return parseInt(dr.slice(0, fr), 10);
}
function getSubscriptionId(cr) {
  let ar = cr.slice(0, 22).indexOf('"EVENT"');
  if (ar === -1)
    return null;
  let lr = cr.slice(ar + 7 + 1).indexOf('"');
  if (lr === -1)
    return null;
  let ur = ar + 7 + 1 + lr, dr = cr.slice(ur + 1, 80).indexOf('"');
  if (dr === -1)
    return null;
  let fr = ur + 1 + dr;
  return cr.slice(ur + 1, fr);
}
function matchEventId(cr, ar) {
  return ar === getHex64(cr, "id");
}
function matchEventPubkey(cr, ar) {
  return ar === getHex64(cr, "pubkey");
}
function matchEventKind(cr, ar) {
  return ar === getInt(cr, "kind");
}
var nip42_exports = {};
__export(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(cr, ar) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", cr],
      ["challenge", ar]
    ],
    content: ""
  };
}
var nip19_exports = {};
__export(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  decode: () => decode$1,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nrelayEncode: () => nrelayEncode,
  nsecEncode: () => nsecEncode
});
var Bech32MaxSize = 5e3, BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(cr) {
  const ar = new Uint8Array(4);
  return ar[0] = cr >> 24 & 255, ar[1] = cr >> 16 & 255, ar[2] = cr >> 8 & 255, ar[3] = cr & 255, ar;
}
function decode$1(cr) {
  var dr, fr, gr, mr, vr, yr, _r, kr;
  let { prefix: ar, words: lr } = bech32.decode(cr, Bech32MaxSize), ur = new Uint8Array(bech32.fromWords(lr));
  switch (ar) {
    case "nprofile": {
      let xr = parseTLV(ur);
      if (!((dr = xr[0]) != null && dr[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder.decode(Ar)) : []
        }
      };
    }
    case "nevent": {
      let xr = parseTLV(ur);
      if (!((fr = xr[0]) != null && fr[0]))
        throw new Error("missing TLV 0 for nevent");
      if (xr[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (xr[2] && xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (xr[3] && xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex(xr[0][0]),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder.decode(Ar)) : [],
          author: (gr = xr[2]) != null && gr[0] ? bytesToHex(xr[2][0]) : void 0,
          kind: (mr = xr[3]) != null && mr[0] ? parseInt(bytesToHex(xr[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let xr = parseTLV(ur);
      if (!((vr = xr[0]) != null && vr[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((yr = xr[2]) != null && yr[0]))
        throw new Error("missing TLV 2 for naddr");
      if (xr[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_r = xr[3]) != null && _r[0]))
        throw new Error("missing TLV 3 for naddr");
      if (xr[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(xr[0][0]),
          pubkey: bytesToHex(xr[2][0]),
          kind: parseInt(bytesToHex(xr[3][0]), 16),
          relays: xr[1] ? xr[1].map((Ar) => utf8Decoder.decode(Ar)) : []
        }
      };
    }
    case "nrelay": {
      let xr = parseTLV(ur);
      if (!((kr = xr[0]) != null && kr[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder.decode(xr[0][0])
      };
    }
    case "nsec":
      return { type: ar, data: ur };
    case "npub":
    case "note":
      return { type: ar, data: bytesToHex(ur) };
    default:
      throw new Error(`unknown prefix ${ar}`);
  }
}
function parseTLV(cr) {
  let ar = {}, lr = cr;
  for (; lr.length > 0; ) {
    let ur = lr[0], dr = lr[1], fr = lr.slice(2, 2 + dr);
    if (lr = lr.slice(2 + dr), fr.length < dr)
      throw new Error(`not enough data to read on TLV ${ur}`);
    ar[ur] = ar[ur] || [], ar[ur].push(fr);
  }
  return ar;
}
function nsecEncode(cr) {
  return encodeBytes("nsec", cr);
}
function npubEncode(cr) {
  return encodeBytes("npub", hexToBytes(cr));
}
function noteEncode(cr) {
  return encodeBytes("note", hexToBytes(cr));
}
function encodeBech32(cr, ar) {
  let lr = bech32.toWords(ar);
  return bech32.encode(cr, lr, Bech32MaxSize);
}
function encodeBytes(cr, ar) {
  return encodeBech32(cr, ar);
}
function nprofileEncode(cr) {
  let ar = encodeTLV({
    0: [hexToBytes(cr.pubkey)],
    1: (cr.relays || []).map((lr) => utf8Encoder.encode(lr))
  });
  return encodeBech32("nprofile", ar);
}
function neventEncode(cr) {
  let ar;
  cr.kind !== void 0 && (ar = integerToUint8Array(cr.kind));
  let lr = encodeTLV({
    0: [hexToBytes(cr.id)],
    1: (cr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: cr.author ? [hexToBytes(cr.author)] : [],
    3: ar ? [new Uint8Array(ar)] : []
  });
  return encodeBech32("nevent", lr);
}
function naddrEncode(cr) {
  let ar = new ArrayBuffer(4);
  new DataView(ar).setUint32(0, cr.kind, !1);
  let lr = encodeTLV({
    0: [utf8Encoder.encode(cr.identifier)],
    1: (cr.relays || []).map((ur) => utf8Encoder.encode(ur)),
    2: [hexToBytes(cr.pubkey)],
    3: [new Uint8Array(ar)]
  });
  return encodeBech32("naddr", lr);
}
function nrelayEncode(cr) {
  let ar = encodeTLV({
    0: [utf8Encoder.encode(cr)]
  });
  return encodeBech32("nrelay", ar);
}
function encodeTLV(cr) {
  let ar = [];
  return Object.entries(cr).reverse().forEach(([lr, ur]) => {
    ur.forEach((dr) => {
      let fr = new Uint8Array(dr.length + 2);
      fr.set([parseInt(lr)], 0), fr.set([dr.length], 1), fr.set(dr, 2), ar.push(fr);
    });
  }), concatBytes(...ar);
}
var nip04_exports = {};
__export(nip04_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
typeof crypto != "undefined" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);
async function encrypt(cr, ar, lr) {
  const ur = cr instanceof Uint8Array ? bytesToHex(cr) : cr, dr = secp256k1.getSharedSecret(ur, "02" + ar), fr = getNormalizedX(dr);
  let gr = Uint8Array.from(randomBytes(16)), mr = utf8Encoder.encode(lr), vr = await crypto.subtle.importKey("raw", fr, { name: "AES-CBC" }, !1, ["encrypt"]), yr = await crypto.subtle.encrypt({ name: "AES-CBC", iv: gr }, vr, mr), _r = base64.encode(new Uint8Array(yr)), kr = base64.encode(new Uint8Array(gr.buffer));
  return `${_r}?iv=${kr}`;
}
async function decrypt(cr, ar, lr) {
  const ur = cr instanceof Uint8Array ? bytesToHex(cr) : cr;
  let [dr, fr] = lr.split("?iv="), gr = secp256k1.getSharedSecret(ur, "02" + ar), mr = getNormalizedX(gr), vr = await crypto.subtle.importKey("raw", mr, { name: "AES-CBC" }, !1, ["decrypt"]), yr = base64.decode(dr), _r = base64.decode(fr), kr = await crypto.subtle.decrypt({ name: "AES-CBC", iv: _r }, vr, yr);
  return utf8Decoder.decode(kr);
}
function getNormalizedX(cr) {
  return cr.slice(1, 33);
}
var nip05_exports = {};
__export(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/, _fetch;
try {
  _fetch = fetch;
} catch (cr) {
}
function useFetchImplementation(cr) {
  _fetch = cr;
}
async function searchDomain(cr, ar = "") {
  try {
    return (await (await _fetch(`https://${cr}/.well-known/nostr.json?name=${ar}`)).json()).names;
  } catch (lr) {
    return {};
  }
}
async function queryProfile(cr) {
  const ar = cr.match(NIP05_REGEX);
  if (!ar)
    return null;
  const [lr, ur = "_", dr] = ar;
  try {
    const fr = await _fetch(`https://${dr}/.well-known/nostr.json?name=${ur}`), { names: gr, relays: mr } = parseNIP05Result(await fr.json()), vr = gr[ur];
    return vr ? { pubkey: vr, relays: mr == null ? void 0 : mr[vr] } : null;
  } catch (fr) {
    return null;
  }
}
function parseNIP05Result(cr) {
  const ar = {
    names: {}
  };
  for (const [lr, ur] of Object.entries(cr.names))
    typeof lr == "string" && typeof ur == "string" && (ar.names[lr] = ur);
  if (cr.relays) {
    ar.relays = {};
    for (const [lr, ur] of Object.entries(cr.relays))
      typeof lr == "string" && Array.isArray(ur) && (ar.relays[lr] = ur.filter((dr) => typeof dr == "string"));
  }
  return ar;
}
var nip10_exports = {};
__export(nip10_exports, {
  parse: () => parse
});
function parse(cr) {
  const ar = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  }, lr = [];
  for (const ur of cr.tags)
    ur[0] === "e" && ur[1] && lr.push(ur), ur[0] === "p" && ur[1] && ar.profiles.push({
      pubkey: ur[1],
      relays: ur[2] ? [ur[2]] : []
    });
  for (let ur = 0; ur < lr.length; ur++) {
    const dr = lr[ur], [fr, gr, mr, vr] = dr, yr = {
      id: gr,
      relays: mr ? [mr] : []
    }, _r = ur === 0, kr = ur === lr.length - 1;
    if (vr === "root") {
      ar.root = yr;
      continue;
    }
    if (vr === "reply") {
      ar.reply = yr;
      continue;
    }
    if (vr === "mention") {
      ar.mentions.push(yr);
      continue;
    }
    if (_r) {
      ar.root = yr;
      continue;
    }
    if (kr) {
      ar.reply = yr;
      continue;
    }
    ar.mentions.push(yr);
  }
  return ar;
}
var nip11_exports = {};
__export(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch (cr) {
}
function useFetchImplementation2(cr) {
  _fetch2 = cr;
}
async function fetchRelayInformation(cr) {
  return await (await fetch(cr.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export(nip13_exports, {
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(cr) {
  let ar = 0;
  for (let lr = 0; lr < cr.length; lr++) {
    const ur = parseInt(cr[lr], 16);
    if (ur === 0)
      ar += 4;
    else {
      ar += Math.clz32(ur) - 28;
      break;
    }
  }
  return ar;
}
function minePow(cr, ar) {
  let lr = 0;
  const ur = cr, dr = ["nonce", lr.toString(), ar.toString()];
  for (ur.tags.push(dr); ; ) {
    const fr = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (fr !== ur.created_at && (lr = 0, ur.created_at = fr), dr[1] = (++lr).toString(), ur.id = getEventHash(ur), getPow(ur.id) >= ar)
      break;
  }
  return ur;
}
var nip18_exports = {};
__export(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(cr, ar, lr, ur) {
  var dr;
  return finalizeEvent(
    {
      kind: Repost,
      tags: [...(dr = cr.tags) != null ? dr : [], ["e", ar.id, lr], ["p", ar.pubkey]],
      content: cr.content === "" ? "" : JSON.stringify(ar),
      created_at: cr.created_at
    },
    ur
  );
}
function getRepostedEventPointer(cr) {
  if (cr.kind !== Repost)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (ar !== void 0)
    return {
      id: ar[1],
      relays: [ar[2], lr == null ? void 0 : lr[2]].filter((ur) => typeof ur == "string"),
      author: lr == null ? void 0 : lr[1]
    };
}
function getRepostedEvent(cr, { skipVerification: ar } = {}) {
  const lr = getRepostedEventPointer(cr);
  if (lr === void 0 || cr.content === "")
    return;
  let ur;
  try {
    ur = JSON.parse(cr.content);
  } catch (dr) {
    return;
  }
  if (ur.id === lr.id && !(!ar && !verifyEvent(ur)))
    return ur;
}
var nip21_exports = {};
__export(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(cr) {
  return typeof cr == "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(cr);
}
function parse2(cr) {
  const ar = cr.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!ar)
    throw new Error(`Invalid Nostr URI: ${cr}`);
  return {
    uri: ar[0],
    value: ar[1],
    decoded: decode$1(ar[1])
  };
}
var nip25_exports = {};
__export(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(cr, ar, lr) {
  var dr, fr;
  const ur = ar.tags.filter((gr) => gr.length >= 2 && (gr[0] === "e" || gr[0] === "p"));
  return finalizeEvent(
    {
      ...cr,
      kind: Reaction,
      tags: [...(dr = cr.tags) != null ? dr : [], ...ur, ["e", ar.id], ["p", ar.pubkey]],
      content: (fr = cr.content) != null ? fr : "+"
    },
    lr
  );
}
function getReactedEventPointer(cr) {
  if (cr.kind !== Reaction)
    return;
  let ar, lr;
  for (let ur = cr.tags.length - 1; ur >= 0 && (ar === void 0 || lr === void 0); ur--) {
    const dr = cr.tags[ur];
    dr.length >= 2 && (dr[0] === "e" && ar === void 0 ? ar = dr : dr[0] === "p" && lr === void 0 && (lr = dr));
  }
  if (!(ar === void 0 || lr === void 0))
    return {
      id: ar[1],
      relays: [ar[2], lr[2]].filter((ur) => ur !== void 0),
      author: lr[1]
    };
}
var nip27_exports = {};
__export(nip27_exports, {
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
function* matchAll(cr) {
  const ar = cr.matchAll(regex());
  for (const lr of ar)
    try {
      const [ur, dr] = lr;
      yield {
        uri: ur,
        value: dr,
        decoded: decode$1(dr),
        start: lr.index,
        end: lr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll(cr, ar) {
  return cr.replaceAll(regex(), (lr, ur) => ar({
    uri: lr,
    value: ur,
    decoded: decode$1(ur)
  }));
}
var nip28_exports = {};
__export(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMetadataEvent = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", cr.channel_create_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMessageEvent = (cr, ar) => {
  var ur;
  const lr = [["e", cr.channel_create_event_id, cr.relay_url, "root"]];
  return cr.reply_to_channel_message_event_id && lr.push(["e", cr.reply_to_channel_message_event_id, cr.relay_url, "reply"]), finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...lr, ...(ur = cr.tags) != null ? ur : []],
      content: cr.content,
      created_at: cr.created_at
    },
    ar
  );
}, channelHideMessageEvent = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", cr.channel_message_event_id], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, channelMuteUserEvent = (cr, ar) => {
  var ur;
  let lr;
  if (typeof cr.content == "object")
    lr = JSON.stringify(cr.content);
  else if (typeof cr.content == "string")
    lr = cr.content;
  else
    return;
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", cr.pubkey_to_mute], ...(ur = cr.tags) != null ? ur : []],
      content: lr,
      created_at: cr.created_at
    },
    ar
  );
}, nip30_exports = {};
__export(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll2,
  regex: () => regex2,
  replaceAll: () => replaceAll2
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/, regex2 = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll2(cr) {
  const ar = cr.matchAll(regex2());
  for (const lr of ar)
    try {
      const [ur, dr] = lr;
      yield {
        shortcode: ur,
        name: dr,
        start: lr.index,
        end: lr.index + ur.length
      };
    } catch (ur) {
    }
}
function replaceAll2(cr, ar) {
  return cr.replaceAll(regex2(), (lr, ur) => ar({
    shortcode: lr,
    name: ur
  }));
}
var nip39_exports = {};
__export(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch (cr) {
}
function useFetchImplementation3(cr) {
  _fetch3 = cr;
}
async function validateGithub(cr, ar, lr) {
  try {
    return await (await _fetch3(`https://gist.github.com/${ar}/${lr}/raw`)).text() === `Verifying that I control the following Nostr public key: ${cr}`;
  } catch (ur) {
    return !1;
  }
}
var nip44_exports = {};
__export(nip44_exports, {
  default: () => nip44_default,
  v2: () => v2
});
var decoder = new TextDecoder(), u = {
  minPlaintextSize: 1,
  maxPlaintextSize: 65535,
  utf8Encode: utf8ToBytes,
  utf8Decode(cr) {
    return decoder.decode(cr);
  },
  getConversationKey(cr, ar) {
    const lr = secp256k1.getSharedSecret(cr, "02" + ar).subarray(1, 33);
    return extract(sha256, lr, "nip44-v2");
  },
  getMessageKeys(cr, ar) {
    ensureBytes$1(cr, 32), ensureBytes$1(ar, 32);
    const lr = expand(sha256, cr, ar, 76);
    return {
      chacha_key: lr.subarray(0, 32),
      chacha_nonce: lr.subarray(32, 44),
      hmac_key: lr.subarray(44, 76)
    };
  },
  calcPaddedLen(cr) {
    if (!Number.isSafeInteger(cr) || cr < 1)
      throw new Error("expected positive integer");
    if (cr <= 32)
      return 32;
    const ar = 1 << Math.floor(Math.log2(cr - 1)) + 1, lr = ar <= 256 ? 32 : ar / 8;
    return lr * (Math.floor((cr - 1) / lr) + 1);
  },
  writeU16BE(cr) {
    if (!Number.isSafeInteger(cr) || cr < u.minPlaintextSize || cr > u.maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const ar = new Uint8Array(2);
    return new DataView(ar.buffer).setUint16(0, cr, !1), ar;
  },
  pad(cr) {
    const ar = u.utf8Encode(cr), lr = ar.length, ur = u.writeU16BE(lr), dr = new Uint8Array(u.calcPaddedLen(lr) - lr);
    return concatBytes(ur, ar, dr);
  },
  unpad(cr) {
    const ar = new DataView(cr.buffer).getUint16(0), lr = cr.subarray(2, 2 + ar);
    if (ar < u.minPlaintextSize || ar > u.maxPlaintextSize || lr.length !== ar || cr.length !== 2 + u.calcPaddedLen(ar))
      throw new Error("invalid padding");
    return u.utf8Decode(lr);
  },
  hmacAad(cr, ar, lr) {
    if (lr.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const ur = concatBytes(lr, ar);
    return hmac(sha256, cr, ur);
  },
  decodePayload(cr) {
    if (typeof cr != "string")
      throw new Error("payload must be a valid string");
    const ar = cr.length;
    if (ar < 132 || ar > 87472)
      throw new Error("invalid payload length: " + ar);
    if (cr[0] === "#")
      throw new Error("unknown encryption version");
    let lr;
    try {
      lr = base64.decode(cr);
    } catch (fr) {
      throw new Error("invalid base64: " + fr.message);
    }
    const ur = lr.length;
    if (ur < 99 || ur > 65603)
      throw new Error("invalid data length: " + ur);
    const dr = lr[0];
    if (dr !== 2)
      throw new Error("unknown encryption version " + dr);
    return {
      nonce: lr.subarray(1, 33),
      ciphertext: lr.subarray(33, -32),
      mac: lr.subarray(-32)
    };
  }
};
function encrypt2(cr, ar, lr = randomBytes(32)) {
  const { chacha_key: ur, chacha_nonce: dr, hmac_key: fr } = u.getMessageKeys(ar, lr), gr = u.pad(cr), mr = chacha20(ur, dr, gr), vr = u.hmacAad(fr, mr, lr);
  return base64.encode(concatBytes(new Uint8Array([2]), lr, mr, vr));
}
function decrypt2(cr, ar) {
  const { nonce: lr, ciphertext: ur, mac: dr } = u.decodePayload(cr), { chacha_key: fr, chacha_nonce: gr, hmac_key: mr } = u.getMessageKeys(ar, lr), vr = u.hmacAad(mr, ur, lr);
  if (!equalBytes$1(vr, dr))
    throw new Error("invalid MAC");
  const yr = chacha20(fr, gr, ur);
  return u.unpad(yr);
}
var v2 = {
  utils: u,
  encrypt: encrypt2,
  decrypt: decrypt2
}, nip44_default = { v2 }, nip47_exports = {};
__export(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(cr) {
  const { pathname: ar, searchParams: lr } = new URL(cr), ur = ar, dr = lr.get("relay"), fr = lr.get("secret");
  if (!ur || !dr || !fr)
    throw new Error("invalid connection string");
  return { pubkey: ur, relay: dr, secret: fr };
}
async function makeNwcRequestEvent(cr, ar, lr) {
  const dr = await encrypt(ar, cr, JSON.stringify({
    method: "pay_invoice",
    params: {
      invoice: lr
    }
  })), fr = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [["p", cr]]
  };
  return finalizeEvent(fr, ar);
}
var nip57_exports = {};
__export(nip57_exports, {
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch (cr) {
}
function useFetchImplementation4(cr) {
  _fetch4 = cr;
}
async function getZapEndpoint(cr) {
  try {
    let ar = "", { lud06: lr, lud16: ur } = JSON.parse(cr.content);
    if (lr) {
      let { words: gr } = bech32.decode(lr, 1e3), mr = bech32.fromWords(gr);
      ar = utf8Decoder.decode(mr);
    } else if (ur) {
      let [gr, mr] = ur.split("@");
      ar = new URL(`/.well-known/lnurlp/${gr}`, `https://${mr}`).toString();
    } else
      return null;
    let fr = await (await _fetch4(ar)).json();
    if (fr.allowsNostr && fr.nostrPubkey)
      return fr.callback;
  } catch (ar) {
  }
  return null;
}
function makeZapRequest({
  profile: cr,
  event: ar,
  amount: lr,
  relays: ur,
  comment: dr = ""
}) {
  if (!lr)
    throw new Error("amount not given");
  if (!cr)
    throw new Error("profile not given");
  let fr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: dr,
    tags: [
      ["p", cr],
      ["amount", lr.toString()],
      ["relays", ...ur]
    ]
  };
  return ar && fr.tags.push(["e", ar]), fr;
}
function validateZapRequest(cr) {
  let ar;
  try {
    ar = JSON.parse(cr);
  } catch (fr) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(ar))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(ar))
    return "Invalid signature on zap request.";
  let lr = ar.tags.find(([fr, gr]) => fr === "p" && gr);
  if (!lr)
    return "Zap request doesn't have a 'p' tag.";
  if (!lr[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let ur = ar.tags.find(([fr, gr]) => fr === "e" && gr);
  return ur && !ur[1].match(/^[a-f0-9]{64}$/) ? "Zap request 'e' tag is not valid hex." : ar.tags.find(([fr, gr]) => fr === "relays" && gr) ? null : "Zap request doesn't have a 'relays' tag.";
}
function makeZapReceipt({
  zapRequest: cr,
  preimage: ar,
  bolt11: lr,
  paidAt: ur
}) {
  let dr = JSON.parse(cr), fr = dr.tags.filter(([mr]) => mr === "e" || mr === "p" || mr === "a"), gr = {
    kind: 9735,
    created_at: Math.round(ur.getTime() / 1e3),
    content: "",
    tags: [...fr, ["P", dr.pubkey], ["bolt11", lr], ["description", cr]]
  };
  return ar && gr.tags.push(["preimage", ar]), gr;
}
var nip98_exports = {};
__export(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(cr, ar, lr, ur = !1, dr) {
  const fr = {
    kind: HTTPAuth,
    tags: [
      ["u", cr],
      ["method", ar]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  dr && fr.tags.push(["payload", hashPayload(dr)]);
  const gr = await lr(fr);
  return (ur ? _authorizationScheme : "") + base64.encode(utf8Encoder.encode(JSON.stringify(gr)));
}
async function validateToken(cr, ar, lr) {
  const ur = await unpackEventFromToken(cr).catch((fr) => {
    throw fr;
  });
  return await validateEvent2(ur, ar, lr).catch((fr) => {
    throw fr;
  });
}
async function unpackEventFromToken(cr) {
  if (!cr)
    throw new Error("Missing token");
  cr = cr.replace(_authorizationScheme, "");
  const ar = utf8Decoder.decode(base64.decode(cr));
  if (!ar || ar.length === 0 || !ar.startsWith("{"))
    throw new Error("Invalid token");
  return JSON.parse(ar);
}
function validateEventTimestamp(cr) {
  return cr.created_at ? Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - cr.created_at < 60 : !1;
}
function validateEventKind(cr) {
  return cr.kind === HTTPAuth;
}
function validateEventUrlTag(cr, ar) {
  const lr = cr.tags.find((ur) => ur[0] === "u");
  return lr ? lr.length > 0 && lr[1] === ar : !1;
}
function validateEventMethodTag(cr, ar) {
  const lr = cr.tags.find((ur) => ur[0] === "method");
  return lr ? lr.length > 0 && lr[1].toLowerCase() === ar.toLowerCase() : !1;
}
function hashPayload(cr) {
  const ar = sha256(utf8Encoder.encode(JSON.stringify(cr)));
  return bytesToHex(ar);
}
function validateEventPayloadTag(cr, ar) {
  const lr = cr.tags.find((dr) => dr[0] === "payload");
  if (!lr)
    return !1;
  const ur = hashPayload(ar);
  return lr.length > 0 && lr[1] === ur;
}
async function validateEvent2(cr, ar, lr, ur) {
  if (!verifyEvent(cr))
    throw new Error("Invalid nostr event, signature invalid");
  if (!validateEventKind(cr))
    throw new Error("Invalid nostr event, kind invalid");
  if (!validateEventTimestamp(cr))
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  if (!validateEventUrlTag(cr, ar))
    throw new Error("Invalid nostr event, url tag invalid");
  if (!validateEventMethodTag(cr, lr))
    throw new Error("Invalid nostr event, method tag invalid");
  if (ur && typeof ur == "object" && Object.keys(ur).length > 0 && !validateEventPayloadTag(cr, ur))
    throw new Error("Invalid nostr event, payload tag does not match request body hash");
  return !0;
}
function add_css$7(cr) {
  append_styles(cr, "svelte-1xutw13", 'h3.svelte-1xutw13.svelte-1xutw13,h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13,input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13,button.svelte-1xutw13.svelte-1xutw13{font-family:sans-serif}h3.svelte-1xutw13.svelte-1xutw13{font-size:1.5em;color:#767676;margin-top:0}form.svelte-1xutw13.svelte-1xutw13{padding-right:1.5rem}h2.svelte-1xutw13.svelte-1xutw13,p.svelte-1xutw13.svelte-1xutw13{color:#767676}input.svelte-1xutw13.svelte-1xutw13,textarea.svelte-1xutw13.svelte-1xutw13{color:#333;background-color:#f8f8f8;margin-bottom:1em;width:100%;display:block;border:1px solid #888;padding:0.5em;font-size:1.1em;border-radius:0.3rem}input[type="text"].svelte-1xutw13.svelte-1xutw13{height:50px}textarea.svelte-1xutw13.svelte-1xutw13{height:120px}button.svelte-1xutw13.svelte-1xutw13{background-color:#4DA84D;color:white;border:none;padding:12px 18px;cursor:pointer;font-size:1.1em;border-radius:5px}.copy-key-button.svelte-1xutw13.svelte-1xutw13,.continue-button.svelte-1xutw13.svelte-1xutw13{margin-top:0.5em}.continue-button.svelte-1xutw13.svelte-1xutw13{background-color:#6c757d;border:2px solid #565e66}.key-container.svelte-1xutw13.svelte-1xutw13{background-color:#eaeaea;padding:1em;border-radius:4px;border:1px solid #ccc}.key-container.svelte-1xutw13 input.svelte-1xutw13{background-color:#fff;border:1px solid #888;border-radius:4px;padding:1em;width:100%;box-sizing:border-box;font-size:1.1em}');
}
function create_else_block$3(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar;
  return {
    c() {
      ar = element("div"), lr = element("p"), lr.innerHTML = "We use <strong>Nostr</strong> to store opinions. You can post and access your posts via your unique private key. Copy your key and keep it in a safe place.", ur = space(), dr = element("div"), fr = element("input"), gr = space(), mr = element("button"), mr.textContent = "Copy my key", vr = space(), yr = element("button"), yr.textContent = "Continue", attr(lr, "class", "svelte-1xutw13"), attr(fr, "id", "privkey"), attr(fr, "type", "text"), fr.readOnly = !0, attr(fr, "class", "svelte-1xutw13"), attr(mr, "class", "copy-key-button svelte-1xutw13"), attr(dr, "class", "key-container svelte-1xutw13"), attr(yr, "class", "continue-button svelte-1xutw13");
    },
    m(Er, Cr) {
      insert(Er, ar, Cr), append(ar, lr), append(ar, ur), append(ar, dr), append(dr, fr), set_input_value(
        fr,
        /*nsec*/
        cr[0]
      ), append(dr, gr), append(dr, mr), append(ar, vr), append(ar, yr), kr = !0, xr || (Ar = [
        listen(
          fr,
          "input",
          /*input_input_handler*/
          cr[12]
        ),
        listen(
          mr,
          "click",
          /*copyToClipboard*/
          cr[6]
        ),
        listen(
          yr,
          "click",
          /*click_handler*/
          cr[13]
        )
      ], xr = !0);
    },
    p(Er, Cr) {
      Cr & /*nsec*/
      1 && fr.value !== /*nsec*/
      Er[0] && set_input_value(
        fr,
        /*nsec*/
        Er[0]
      );
    },
    i(Er) {
      kr || (Er && add_render_callback(() => {
        kr && (_r || (_r = create_bidirectional_transition(ar, slide, {}, !0)), _r.run(1));
      }), kr = !0);
    },
    o(Er) {
      Er && (_r || (_r = create_bidirectional_transition(ar, slide, {}, !1)), _r.run(0)), kr = !1;
    },
    d(Er) {
      Er && detach(ar), Er && _r && _r.end(), xr = !1, run_all(Ar);
    }
  };
}
function create_if_block$4(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr;
  return {
    c() {
      ar = element("form"), lr = element("h2"), lr.textContent = "Set up your profile", ur = space(), dr = element("p"), dr.textContent = "This information will be shown with your comments. To upload images, use a service like Piccy.", fr = space(), gr = element("input"), mr = space(), vr = element("textarea"), yr = space(), _r = element("input"), kr = space(), xr = element("button"), xr.textContent = "Save profile", attr(lr, "class", "svelte-1xutw13"), attr(dr, "class", "svelte-1xutw13"), attr(gr, "type", "text"), attr(gr, "placeholder", "Enter your name..."), gr.required = !0, attr(gr, "class", "svelte-1xutw13"), attr(vr, "placeholder", "Share a bit about yourself..."), vr.required = !0, attr(vr, "class", "svelte-1xutw13"), attr(_r, "type", "text"), attr(_r, "placeholder", "Link to a profile image..."), attr(_r, "class", "svelte-1xutw13"), attr(xr, "type", "submit"), attr(xr, "class", "svelte-1xutw13"), attr(ar, "class", "svelte-1xutw13");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), append(ar, ur), append(ar, dr), append(ar, fr), append(ar, gr), set_input_value(
        gr,
        /*name*/
        cr[2]
      ), append(ar, mr), append(ar, vr), set_input_value(
        vr,
        /*about*/
        cr[3]
      ), append(ar, yr), append(ar, _r), set_input_value(
        _r,
        /*imageUrl*/
        cr[4]
      ), append(ar, kr), append(ar, xr), Er = !0, Cr || (Tr = [
        listen(
          gr,
          "input",
          /*input0_input_handler*/
          cr[9]
        ),
        listen(
          vr,
          "input",
          /*textarea_input_handler*/
          cr[10]
        ),
        listen(
          _r,
          "input",
          /*input1_input_handler*/
          cr[11]
        ),
        listen(ar, "submit", prevent_default(
          /*saveProfile*/
          cr[5]
        ))
      ], Cr = !0);
    },
    p(Sr, Lr) {
      Lr & /*name*/
      4 && gr.value !== /*name*/
      Sr[2] && set_input_value(
        gr,
        /*name*/
        Sr[2]
      ), Lr & /*about*/
      8 && set_input_value(
        vr,
        /*about*/
        Sr[3]
      ), Lr & /*imageUrl*/
      16 && _r.value !== /*imageUrl*/
      Sr[4] && set_input_value(
        _r,
        /*imageUrl*/
        Sr[4]
      );
    },
    i(Sr) {
      Er || (Sr && add_render_callback(() => {
        Er && (Ar || (Ar = create_bidirectional_transition(ar, slide, {}, !0)), Ar.run(1));
      }), Er = !0);
    },
    o(Sr) {
      Sr && (Ar || (Ar = create_bidirectional_transition(ar, slide, {}, !1)), Ar.run(0)), Er = !1;
    },
    d(Sr) {
      Sr && detach(ar), Sr && Ar && Ar.end(), Cr = !1, run_all(Tr);
    }
  };
}
function create_fragment$h(cr) {
  let ar, lr, ur, dr, fr;
  const gr = [create_if_block$4, create_else_block$3], mr = [];
  function vr(yr, _r) {
    return (
      /*showProfileSetup*/
      yr[1] ? 0 : 1
    );
  }
  return ur = vr(cr), dr = mr[ur] = gr[ur](cr), {
    c() {
      ar = element("h3"), ar.textContent = "Register", lr = space(), dr.c(), fr = empty$2(), attr(ar, "class", "svelte-1xutw13");
    },
    m(yr, _r) {
      insert(yr, ar, _r), insert(yr, lr, _r), mr[ur].m(yr, _r), insert(yr, fr, _r);
    },
    p(yr, [_r]) {
      let kr = ur;
      ur = vr(yr), ur === kr ? mr[ur].p(yr, _r) : (group_outros(), transition_out(mr[kr], 1, 1, () => {
        mr[kr] = null;
      }), check_outros(), dr = mr[ur], dr ? dr.p(yr, _r) : (dr = mr[ur] = gr[ur](yr), dr.c()), transition_in(dr, 1), dr.m(fr.parentNode, fr));
    },
    i(yr) {
      transition_in(dr);
    },
    o(yr) {
      transition_out(dr);
    },
    d(yr) {
      yr && (detach(ar), detach(lr), detach(fr)), mr[ur].d(yr);
    }
  };
}
let pubkey = "";
function instance$8(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, ndkUser, (Rr) => lr(16, ur = Rr)), component_subscribe(cr, ndkStore, (Rr) => lr(17, dr = Rr));
  let fr = "", gr = "", mr = !1, vr = "", yr = "", _r = "", kr, { profiles: xr = {} } = ar, { showNewOpinion: Ar } = ar;
  onMount(() => {
    kr = NDKPrivateKeySigner.generate(), gr = kr.privateKey, lr(0, fr = nip19_exports.nsecEncode(hexToBytes$2(gr)));
  });
  const Er = async () => {
    if (!fr)
      return;
    (_r == "" || !_r) && lr(4, _r = profileImageUrl + pubkey);
    const Rr = { name: vr, about: yr, image: _r, pubkey: "" };
    set_store_value(ndkStore, dr.signer = kr, dr), set_store_value(ndkUser, ur = await dr.signer.user(), ur), set_store_value(ndkUser, ur.ndk = dr, ur);
    let Mr = Rr;
    Mr = { ...Mr, pubkey: ur.pubkey }, set_store_value(ndkUser, ur.profile = Rr, ur), lr(7, xr[ur.pubkey] = { content: Mr }, xr), lr(8, Ar = !1), await ur.publish(), await privkeyLogin(gr);
  }, Cr = () => {
    navigator.clipboard.writeText(fr).then(
      () => {
        alert("Private Key copied");
      },
      (Rr) => {
        console.error("Could not copy text: ", Rr);
      }
    );
  };
  function Tr() {
    vr = this.value, lr(2, vr);
  }
  function Sr() {
    yr = this.value, lr(3, yr);
  }
  function Lr() {
    _r = this.value, lr(4, _r);
  }
  function Ir() {
    fr = this.value, lr(0, fr);
  }
  const Nr = () => lr(1, mr = !mr);
  return cr.$$set = (Rr) => {
    "profiles" in Rr && lr(7, xr = Rr.profiles), "showNewOpinion" in Rr && lr(8, Ar = Rr.showNewOpinion);
  }, [
    fr,
    mr,
    vr,
    yr,
    _r,
    Er,
    Cr,
    xr,
    Ar,
    Tr,
    Sr,
    Lr,
    Ir,
    Nr
  ];
}
class Register extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$8, create_fragment$h, safe_not_equal, { profiles: 7, showNewOpinion: 8 }, add_css$7);
  }
  get profiles() {
    return this.$$.ctx[7];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[8];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
create_custom_element(Register, { profiles: {}, showNewOpinion: {} }, [], [], !0);
function add_css$6(cr) {
  append_styles(cr, "svelte-19w231", ".container.svelte-19w231{max-width:600px;text-align:left;font-family:sans-serif}.heading.svelte-19w231{font-size:24px;margin-bottom:8px}.text.svelte-19w231{margin-bottom:24px}.input.svelte-19w231{padding:10px;margin-bottom:16px;border:2px solid #ccc;border-radius:4px;width:100%;display:block}.button.svelte-19w231{background-color:#4DA84D;color:white;border:none;font-size:16px;cursor:pointer;padding:10px;margin-bottom:16px}");
}
function create_else_block$2(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r = window && create_if_block_1$2(cr);
  return {
    c() {
      ar = element("div"), lr = element("h2"), lr.textContent = "Log in", ur = space(), dr = element("p"), dr.innerHTML = `You have two options to log in. You can connect with an authentication tool like Alby that
				supports Nostr. Or you can enter your private key (<a href="/" class="text svelte-19w231">view associated risks</a>).`, fr = space(), _r && _r.c(), gr = space(), mr = element("button"), mr.textContent = "Connect using private key", attr(lr, "class", "heading svelte-19w231"), attr(dr, "class", "text svelte-19w231"), attr(mr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(kr, xr) {
      insert(kr, ar, xr), append(ar, lr), append(ar, ur), append(ar, dr), append(ar, fr), _r && _r.m(ar, null), append(ar, gr), append(ar, mr), vr || (yr = listen(
        mr,
        "click",
        /*click_handler_2*/
        cr[10]
      ), vr = !0);
    },
    p(kr, xr) {
      window && _r.p(kr, xr);
    },
    i: noop$1,
    o: noop$1,
    d(kr) {
      kr && detach(ar), _r && _r.d(), vr = !1, yr();
    }
  };
}
function create_if_block$3(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr;
  return {
    c() {
      ar = element("div"), lr = element("h2"), lr.textContent = "Log in", ur = space(), dr = element("p"), dr.innerHTML = `Enter your <strong>Nostr</strong> private key below to be able to post an opinion.<br/>
				Don&#39;t have a key? <a href="/" class="text svelte-19w231">Register</a>.`, fr = space(), gr = element("input"), mr = space(), vr = element("button"), vr.textContent = "Log in", attr(lr, "class", "heading svelte-19w231"), attr(dr, "class", "text svelte-19w231"), attr(gr, "id", "privkey"), attr(gr, "type", "text"), attr(gr, "placeholder", "Your private key..."), attr(gr, "class", "input svelte-19w231"), attr(vr, "class", "button svelte-19w231"), attr(ar, "class", "container svelte-19w231");
    },
    m(Ar, Er) {
      insert(Ar, ar, Er), append(ar, lr), append(ar, ur), append(ar, dr), append(ar, fr), append(ar, gr), set_input_value(
        gr,
        /*nsec*/
        cr[1]
      ), append(ar, mr), append(ar, vr), _r = !0, kr || (xr = [
        listen(
          gr,
          "input",
          /*input_input_handler*/
          cr[7]
        ),
        listen(
          vr,
          "click",
          /*click_handler*/
          cr[8]
        )
      ], kr = !0);
    },
    p(Ar, Er) {
      Er & /*nsec*/
      2 && gr.value !== /*nsec*/
      Ar[1] && set_input_value(
        gr,
        /*nsec*/
        Ar[1]
      );
    },
    i(Ar) {
      _r || (Ar && add_render_callback(() => {
        _r && (yr || (yr = create_bidirectional_transition(ar, slide, {}, !0)), yr.run(1));
      }), _r = !0);
    },
    o(Ar) {
      Ar && (yr || (yr = create_bidirectional_transition(ar, slide, {}, !1)), yr.run(0)), _r = !1;
    },
    d(Ar) {
      Ar && detach(ar), Ar && yr && yr.end(), kr = !1, run_all(xr);
    }
  };
}
function create_if_block_1$2(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("button"), ar.textContent = "Connect using browser extension", attr(ar, "class", "button svelte-19w231");
    },
    m(dr, fr) {
      insert(dr, ar, fr), lr || (ur = listen(
        ar,
        "click",
        /*click_handler_1*/
        cr[9]
      ), lr = !0);
    },
    p: noop$1,
    d(dr) {
      dr && detach(ar), lr = !1, ur();
    }
  };
}
function create_fragment$g(cr) {
  let ar, lr, ur, dr, fr;
  const gr = [create_if_block$3, create_else_block$2], mr = [];
  function vr(yr, _r) {
    return (
      /*showPrivateKeyInput*/
      yr[0] ? 0 : 1
    );
  }
  return lr = vr(cr), ur = mr[lr] = gr[lr](cr), {
    c() {
      ar = element("div"), ur.c();
    },
    m(yr, _r) {
      insert(yr, ar, _r), mr[lr].m(ar, null), fr = !0;
    },
    p(yr, [_r]) {
      let kr = lr;
      lr = vr(yr), lr === kr ? mr[lr].p(yr, _r) : (group_outros(), transition_out(mr[kr], 1, 1, () => {
        mr[kr] = null;
      }), check_outros(), ur = mr[lr], ur ? ur.p(yr, _r) : (ur = mr[lr] = gr[lr](yr), ur.c()), transition_in(ur, 1), ur.m(ar, null));
    },
    i(yr) {
      fr || (transition_in(ur), yr && add_render_callback(() => {
        fr && (dr || (dr = create_bidirectional_transition(ar, slide, {}, !0)), dr.run(1));
      }), fr = !0);
    },
    o(yr) {
      transition_out(ur), yr && (dr || (dr = create_bidirectional_transition(ar, slide, {}, !1)), dr.run(0)), fr = !1;
    },
    d(yr) {
      yr && detach(ar), mr[lr].d(), yr && dr && dr.end();
    }
  };
}
function instance$7(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, ndkUser, (Tr) => lr(11, ur = Tr)), component_subscribe(cr, ndkStore, (Tr) => lr(12, dr = Tr));
  let fr = !1, gr = "", { profiles: mr = {} } = ar, { opinionContent: vr } = ar, { subject: yr } = ar, { showNewOpinion: _r } = ar;
  const kr = async (Tr) => {
    if (!Tr)
      return;
    let Sr;
    switch (Tr) {
      case "pk":
        Sr = await privkeyLogin(nip19_exports.decode(gr).data);
        break;
      case "nip07":
        Sr = await NDKlogin();
        break;
    }
    if (!Sr) {
      console.log("Something went wrong while login!!");
      return;
    }
    if (!ur) {
      console.log("Can't proceed. $ndkUser is null");
      return;
    }
    let Lr = await fetchUserProfile(ur.pubkey);
    Lr || (Lr = {
      image: profileImageUrl + ur.pubkey,
      pubkey: ur.pubkey
    }), Lr.image || (Lr.image = profileImageUrl + ur.pubkey), Lr.pubkey || (Lr.pubkey = ur.pubkey), lr(5, _r = !1);
    const Ir = {
      kinds: [kindOpinion],
      "#d": [yr],
      authors: [ur.pubkey]
    };
    let Nr = await dr.fetchEvent(Ir, { closeOnEose: !0 });
    lr(3, mr[ur.pubkey] = { content: Lr }, mr), Nr && Nr.content && lr(4, vr = Nr.content);
  };
  function xr() {
    gr = this.value, lr(1, gr);
  }
  const Ar = () => {
    kr("pk");
  }, Er = () => {
    kr("nip07");
  }, Cr = () => lr(0, fr = !fr);
  return cr.$$set = (Tr) => {
    "profiles" in Tr && lr(3, mr = Tr.profiles), "opinionContent" in Tr && lr(4, vr = Tr.opinionContent), "subject" in Tr && lr(6, yr = Tr.subject), "showNewOpinion" in Tr && lr(5, _r = Tr.showNewOpinion);
  }, [
    fr,
    gr,
    kr,
    mr,
    vr,
    _r,
    yr,
    xr,
    Ar,
    Er,
    Cr
  ];
}
class Login extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$7,
      create_fragment$g,
      safe_not_equal,
      {
        profiles: 3,
        opinionContent: 4,
        subject: 6,
        showNewOpinion: 5
      },
      add_css$6
    );
  }
  get profiles() {
    return this.$$.ctx[3];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[4];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[6];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get showNewOpinion() {
    return this.$$.ctx[5];
  }
  set showNewOpinion(ar) {
    this.$$set({ showNewOpinion: ar }), flush();
  }
}
customElements.define("nostr-opinion-login", create_custom_element(Login, { profiles: {}, opinionContent: {}, subject: {}, showNewOpinion: {} }, [], [], !0));
function OrderedMap(cr) {
  this.content = cr;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(cr) {
    for (var ar = 0; ar < this.content.length; ar += 2)
      if (this.content[ar] === cr)
        return ar;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(cr) {
    var ar = this.find(cr);
    return ar == -1 ? void 0 : this.content[ar + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(cr, ar, lr) {
    var ur = lr && lr != cr ? this.remove(lr) : this, dr = ur.find(cr), fr = ur.content.slice();
    return dr == -1 ? fr.push(lr || cr, ar) : (fr[dr + 1] = ar, lr && (fr[dr] = lr)), new OrderedMap(fr);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(cr) {
    var ar = this.find(cr);
    if (ar == -1)
      return this;
    var lr = this.content.slice();
    return lr.splice(ar, 2), new OrderedMap(lr);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(cr, ar) {
    return new OrderedMap([cr, ar].concat(this.remove(cr).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(cr, ar) {
    var lr = this.remove(cr).content.slice();
    return lr.push(cr, ar), new OrderedMap(lr);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(cr, ar, lr) {
    var ur = this.remove(ar), dr = ur.content.slice(), fr = ur.find(cr);
    return dr.splice(fr == -1 ? dr.length : fr, 0, ar, lr), new OrderedMap(dr);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(cr) {
    for (var ar = 0; ar < this.content.length; ar += 2)
      cr(this.content[ar], this.content[ar + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(cr) {
    return cr = OrderedMap.from(cr), cr.size ? new OrderedMap(cr.content.concat(this.subtract(cr).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(cr) {
    return cr = OrderedMap.from(cr), cr.size ? new OrderedMap(this.subtract(cr).content.concat(cr.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(cr) {
    var ar = this;
    cr = OrderedMap.from(cr);
    for (var lr = 0; lr < cr.content.length; lr += 2)
      ar = ar.remove(cr.content[lr]);
    return ar;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var cr = {};
    return this.forEach(function(ar, lr) {
      cr[ar] = lr;
    }), cr;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(cr) {
  if (cr instanceof OrderedMap)
    return cr;
  var ar = [];
  if (cr)
    for (var lr in cr)
      ar.push(lr, cr[lr]);
  return new OrderedMap(ar);
};
function findDiffStart(cr, ar, lr) {
  for (let ur = 0; ; ur++) {
    if (ur == cr.childCount || ur == ar.childCount)
      return cr.childCount == ar.childCount ? null : lr;
    let dr = cr.child(ur), fr = ar.child(ur);
    if (dr == fr) {
      lr += dr.nodeSize;
      continue;
    }
    if (!dr.sameMarkup(fr))
      return lr;
    if (dr.isText && dr.text != fr.text) {
      for (let gr = 0; dr.text[gr] == fr.text[gr]; gr++)
        lr++;
      return lr;
    }
    if (dr.content.size || fr.content.size) {
      let gr = findDiffStart(dr.content, fr.content, lr + 1);
      if (gr != null)
        return gr;
    }
    lr += dr.nodeSize;
  }
}
function findDiffEnd(cr, ar, lr, ur) {
  for (let dr = cr.childCount, fr = ar.childCount; ; ) {
    if (dr == 0 || fr == 0)
      return dr == fr ? null : { a: lr, b: ur };
    let gr = cr.child(--dr), mr = ar.child(--fr), vr = gr.nodeSize;
    if (gr == mr) {
      lr -= vr, ur -= vr;
      continue;
    }
    if (!gr.sameMarkup(mr))
      return { a: lr, b: ur };
    if (gr.isText && gr.text != mr.text) {
      let yr = 0, _r = Math.min(gr.text.length, mr.text.length);
      for (; yr < _r && gr.text[gr.text.length - yr - 1] == mr.text[mr.text.length - yr - 1]; )
        yr++, lr--, ur--;
      return { a: lr, b: ur };
    }
    if (gr.content.size || mr.content.size) {
      let yr = findDiffEnd(gr.content, mr.content, lr - 1, ur - 1);
      if (yr)
        return yr;
    }
    lr -= vr, ur -= vr;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(ar, lr) {
    if (this.content = ar, this.size = lr || 0, lr == null)
      for (let ur = 0; ur < ar.length; ur++)
        this.size += ar[ur].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(ar, lr, ur, dr = 0, fr) {
    for (let gr = 0, mr = 0; mr < lr; gr++) {
      let vr = this.content[gr], yr = mr + vr.nodeSize;
      if (yr > ar && ur(vr, dr + mr, fr || null, gr) !== !1 && vr.content.size) {
        let _r = mr + 1;
        vr.nodesBetween(Math.max(0, ar - _r), Math.min(vr.content.size, lr - _r), ur, dr + _r);
      }
      mr = yr;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(ar) {
    this.nodesBetween(0, this.size, ar);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(ar, lr, ur, dr) {
    let fr = "", gr = !0;
    return this.nodesBetween(ar, lr, (mr, vr) => {
      mr.isText ? (fr += mr.text.slice(Math.max(ar, vr) - vr, lr - vr), gr = !ur) : mr.isLeaf ? (dr ? fr += typeof dr == "function" ? dr(mr) : dr : mr.type.spec.leafText && (fr += mr.type.spec.leafText(mr)), gr = !ur) : !gr && mr.isBlock && (fr += ur, gr = !0);
    }, 0), fr;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(ar) {
    if (!ar.size)
      return this;
    if (!this.size)
      return ar;
    let lr = this.lastChild, ur = ar.firstChild, dr = this.content.slice(), fr = 0;
    for (lr.isText && lr.sameMarkup(ur) && (dr[dr.length - 1] = lr.withText(lr.text + ur.text), fr = 1); fr < ar.content.length; fr++)
      dr.push(ar.content[fr]);
    return new Fragment(dr, this.size + ar.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(ar, lr = this.size) {
    if (ar == 0 && lr == this.size)
      return this;
    let ur = [], dr = 0;
    if (lr > ar)
      for (let fr = 0, gr = 0; gr < lr; fr++) {
        let mr = this.content[fr], vr = gr + mr.nodeSize;
        vr > ar && ((gr < ar || vr > lr) && (mr.isText ? mr = mr.cut(Math.max(0, ar - gr), Math.min(mr.text.length, lr - gr)) : mr = mr.cut(Math.max(0, ar - gr - 1), Math.min(mr.content.size, lr - gr - 1))), ur.push(mr), dr += mr.nodeSize), gr = vr;
      }
    return new Fragment(ur, dr);
  }
  /**
  @internal
  */
  cutByIndex(ar, lr) {
    return ar == lr ? Fragment.empty : ar == 0 && lr == this.content.length ? this : new Fragment(this.content.slice(ar, lr));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(ar, lr) {
    let ur = this.content[ar];
    if (ur == lr)
      return this;
    let dr = this.content.slice(), fr = this.size + lr.nodeSize - ur.nodeSize;
    return dr[ar] = lr, new Fragment(dr, fr);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(ar) {
    return new Fragment([ar].concat(this.content), this.size + ar.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(ar) {
    return new Fragment(this.content.concat(ar), this.size + ar.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(ar) {
    if (this.content.length != ar.content.length)
      return !1;
    for (let lr = 0; lr < this.content.length; lr++)
      if (!this.content[lr].eq(ar.content[lr]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(ar) {
    let lr = this.content[ar];
    if (!lr)
      throw new RangeError("Index " + ar + " out of range for " + this);
    return lr;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(ar) {
    return this.content[ar] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(ar) {
    for (let lr = 0, ur = 0; lr < this.content.length; lr++) {
      let dr = this.content[lr];
      ar(dr, ur, lr), ur += dr.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(ar, lr = 0) {
    return findDiffStart(this, ar, lr);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(ar, lr = this.size, ur = ar.size) {
    return findDiffEnd(this, ar, lr, ur);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(ar, lr = -1) {
    if (ar == 0)
      return retIndex(0, ar);
    if (ar == this.size)
      return retIndex(this.content.length, ar);
    if (ar > this.size || ar < 0)
      throw new RangeError(`Position ${ar} outside of fragment (${this})`);
    for (let ur = 0, dr = 0; ; ur++) {
      let fr = this.child(ur), gr = dr + fr.nodeSize;
      if (gr >= ar)
        return gr == ar || lr > 0 ? retIndex(ur + 1, gr) : retIndex(ur, dr);
      dr = gr;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((ar) => ar.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(ar, lr) {
    if (!lr)
      return Fragment.empty;
    if (!Array.isArray(lr))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(lr.map(ar.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(ar) {
    if (!ar.length)
      return Fragment.empty;
    let lr, ur = 0;
    for (let dr = 0; dr < ar.length; dr++) {
      let fr = ar[dr];
      ur += fr.nodeSize, dr && fr.isText && ar[dr - 1].sameMarkup(fr) ? (lr || (lr = ar.slice(0, dr)), lr[lr.length - 1] = fr.withText(lr[lr.length - 1].text + fr.text)) : lr && lr.push(fr);
    }
    return new Fragment(lr || ar, ur);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(ar) {
    if (!ar)
      return Fragment.empty;
    if (ar instanceof Fragment)
      return ar;
    if (Array.isArray(ar))
      return this.fromArray(ar);
    if (ar.attrs)
      return new Fragment([ar], ar.nodeSize);
    throw new RangeError("Can not convert " + ar + " to a Fragment" + (ar.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(cr, ar) {
  return found.index = cr, found.offset = ar, found;
}
function compareDeep(cr, ar) {
  if (cr === ar)
    return !0;
  if (!(cr && typeof cr == "object") || !(ar && typeof ar == "object"))
    return !1;
  let lr = Array.isArray(cr);
  if (Array.isArray(ar) != lr)
    return !1;
  if (lr) {
    if (cr.length != ar.length)
      return !1;
    for (let ur = 0; ur < cr.length; ur++)
      if (!compareDeep(cr[ur], ar[ur]))
        return !1;
  } else {
    for (let ur in cr)
      if (!(ur in ar) || !compareDeep(cr[ur], ar[ur]))
        return !1;
    for (let ur in ar)
      if (!(ur in cr))
        return !1;
  }
  return !0;
}
let Mark$1 = class Uo {
  /**
  @internal
  */
  constructor(ar, lr) {
    this.type = ar, this.attrs = lr;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(ar) {
    let lr, ur = !1;
    for (let dr = 0; dr < ar.length; dr++) {
      let fr = ar[dr];
      if (this.eq(fr))
        return ar;
      if (this.type.excludes(fr.type))
        lr || (lr = ar.slice(0, dr));
      else {
        if (fr.type.excludes(this.type))
          return ar;
        !ur && fr.type.rank > this.type.rank && (lr || (lr = ar.slice(0, dr)), lr.push(this), ur = !0), lr && lr.push(fr);
      }
    }
    return lr || (lr = ar.slice()), ur || lr.push(this), lr;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(ar) {
    for (let lr = 0; lr < ar.length; lr++)
      if (this.eq(ar[lr]))
        return ar.slice(0, lr).concat(ar.slice(lr + 1));
    return ar;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(ar) {
    for (let lr = 0; lr < ar.length; lr++)
      if (this.eq(ar[lr]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(ar) {
    return this == ar || this.type == ar.type && compareDeep(this.attrs, ar.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let ar = { type: this.type.name };
    for (let lr in this.attrs) {
      ar.attrs = this.attrs;
      break;
    }
    return ar;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(ar, lr) {
    if (!lr)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let ur = ar.marks[lr.type];
    if (!ur)
      throw new RangeError(`There is no mark type ${lr.type} in this schema`);
    return ur.create(lr.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(ar, lr) {
    if (ar == lr)
      return !0;
    if (ar.length != lr.length)
      return !1;
    for (let ur = 0; ur < ar.length; ur++)
      if (!ar[ur].eq(lr[ur]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(ar) {
    if (!ar || Array.isArray(ar) && ar.length == 0)
      return Uo.none;
    if (ar instanceof Uo)
      return [ar];
    let lr = ar.slice();
    return lr.sort((ur, dr) => ur.type.rank - dr.type.rank), lr;
  }
};
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(ar, lr, ur) {
    this.content = ar, this.openStart = lr, this.openEnd = ur;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(ar, lr) {
    let ur = insertInto(this.content, ar + this.openStart, lr);
    return ur && new Slice(ur, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(ar, lr) {
    return new Slice(removeRange(this.content, ar + this.openStart, lr + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(ar) {
    return this.content.eq(ar.content) && this.openStart == ar.openStart && this.openEnd == ar.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let ar = { content: this.content.toJSON() };
    return this.openStart > 0 && (ar.openStart = this.openStart), this.openEnd > 0 && (ar.openEnd = this.openEnd), ar;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(ar, lr) {
    if (!lr)
      return Slice.empty;
    let ur = lr.openStart || 0, dr = lr.openEnd || 0;
    if (typeof ur != "number" || typeof dr != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(ar, lr.content), ur, dr);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(ar, lr = !0) {
    let ur = 0, dr = 0;
    for (let fr = ar.firstChild; fr && !fr.isLeaf && (lr || !fr.type.spec.isolating); fr = fr.firstChild)
      ur++;
    for (let fr = ar.lastChild; fr && !fr.isLeaf && (lr || !fr.type.spec.isolating); fr = fr.lastChild)
      dr++;
    return new Slice(ar, ur, dr);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(cr, ar, lr) {
  let { index: ur, offset: dr } = cr.findIndex(ar), fr = cr.maybeChild(ur), { index: gr, offset: mr } = cr.findIndex(lr);
  if (dr == ar || fr.isText) {
    if (mr != lr && !cr.child(gr).isText)
      throw new RangeError("Removing non-flat range");
    return cr.cut(0, ar).append(cr.cut(lr));
  }
  if (ur != gr)
    throw new RangeError("Removing non-flat range");
  return cr.replaceChild(ur, fr.copy(removeRange(fr.content, ar - dr - 1, lr - dr - 1)));
}
function insertInto(cr, ar, lr, ur) {
  let { index: dr, offset: fr } = cr.findIndex(ar), gr = cr.maybeChild(dr);
  if (fr == ar || gr.isText)
    return ur && !ur.canReplace(dr, dr, lr) ? null : cr.cut(0, ar).append(lr).append(cr.cut(ar));
  let mr = insertInto(gr.content, ar - fr - 1, lr);
  return mr && cr.replaceChild(dr, gr.copy(mr));
}
function replace(cr, ar, lr) {
  if (lr.openStart > cr.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if (cr.depth - lr.openStart != ar.depth - lr.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter(cr, ar, lr, 0);
}
function replaceOuter(cr, ar, lr, ur) {
  let dr = cr.index(ur), fr = cr.node(ur);
  if (dr == ar.index(ur) && ur < cr.depth - lr.openStart) {
    let gr = replaceOuter(cr, ar, lr, ur + 1);
    return fr.copy(fr.content.replaceChild(dr, gr));
  } else if (lr.content.size)
    if (!lr.openStart && !lr.openEnd && cr.depth == ur && ar.depth == ur) {
      let gr = cr.parent, mr = gr.content;
      return close(gr, mr.cut(0, cr.parentOffset).append(lr.content).append(mr.cut(ar.parentOffset)));
    } else {
      let { start: gr, end: mr } = prepareSliceForReplace(lr, cr);
      return close(fr, replaceThreeWay(cr, gr, mr, ar, ur));
    }
  else
    return close(fr, replaceTwoWay(cr, ar, ur));
}
function checkJoin(cr, ar) {
  if (!ar.type.compatibleContent(cr.type))
    throw new ReplaceError("Cannot join " + ar.type.name + " onto " + cr.type.name);
}
function joinable$1(cr, ar, lr) {
  let ur = cr.node(lr);
  return checkJoin(ur, ar.node(lr)), ur;
}
function addNode(cr, ar) {
  let lr = ar.length - 1;
  lr >= 0 && cr.isText && cr.sameMarkup(ar[lr]) ? ar[lr] = cr.withText(ar[lr].text + cr.text) : ar.push(cr);
}
function addRange(cr, ar, lr, ur) {
  let dr = (ar || cr).node(lr), fr = 0, gr = ar ? ar.index(lr) : dr.childCount;
  cr && (fr = cr.index(lr), cr.depth > lr ? fr++ : cr.textOffset && (addNode(cr.nodeAfter, ur), fr++));
  for (let mr = fr; mr < gr; mr++)
    addNode(dr.child(mr), ur);
  ar && ar.depth == lr && ar.textOffset && addNode(ar.nodeBefore, ur);
}
function close(cr, ar) {
  return cr.type.checkContent(ar), cr.copy(ar);
}
function replaceThreeWay(cr, ar, lr, ur, dr) {
  let fr = cr.depth > dr && joinable$1(cr, ar, dr + 1), gr = ur.depth > dr && joinable$1(lr, ur, dr + 1), mr = [];
  return addRange(null, cr, dr, mr), fr && gr && ar.index(dr) == lr.index(dr) ? (checkJoin(fr, gr), addNode(close(fr, replaceThreeWay(cr, ar, lr, ur, dr + 1)), mr)) : (fr && addNode(close(fr, replaceTwoWay(cr, ar, dr + 1)), mr), addRange(ar, lr, dr, mr), gr && addNode(close(gr, replaceTwoWay(lr, ur, dr + 1)), mr)), addRange(ur, null, dr, mr), new Fragment(mr);
}
function replaceTwoWay(cr, ar, lr) {
  let ur = [];
  if (addRange(null, cr, lr, ur), cr.depth > lr) {
    let dr = joinable$1(cr, ar, lr + 1);
    addNode(close(dr, replaceTwoWay(cr, ar, lr + 1)), ur);
  }
  return addRange(ar, null, lr, ur), new Fragment(ur);
}
function prepareSliceForReplace(cr, ar) {
  let lr = ar.depth - cr.openStart, dr = ar.node(lr).copy(cr.content);
  for (let fr = lr - 1; fr >= 0; fr--)
    dr = ar.node(fr).copy(Fragment.from(dr));
  return {
    start: dr.resolveNoCache(cr.openStart + lr),
    end: dr.resolveNoCache(dr.content.size - cr.openEnd - lr)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(ar, lr, ur) {
    this.pos = ar, this.path = lr, this.parentOffset = ur, this.depth = lr.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(ar) {
    return ar == null ? this.depth : ar < 0 ? this.depth + ar : ar;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(ar) {
    return this.path[this.resolveDepth(ar) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(ar) {
    return this.path[this.resolveDepth(ar) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(ar) {
    return ar = this.resolveDepth(ar), this.index(ar) + (ar == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(ar) {
    return ar = this.resolveDepth(ar), ar == 0 ? 0 : this.path[ar * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(ar) {
    return ar = this.resolveDepth(ar), this.start(ar) + this.node(ar).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(ar) {
    if (ar = this.resolveDepth(ar), !ar)
      throw new RangeError("There is no position before the top-level node");
    return ar == this.depth + 1 ? this.pos : this.path[ar * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(ar) {
    if (ar = this.resolveDepth(ar), !ar)
      throw new RangeError("There is no position after the top-level node");
    return ar == this.depth + 1 ? this.pos : this.path[ar * 3 - 1] + this.path[ar * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let ar = this.parent, lr = this.index(this.depth);
    if (lr == ar.childCount)
      return null;
    let ur = this.pos - this.path[this.path.length - 1], dr = ar.child(lr);
    return ur ? ar.child(lr).cut(ur) : dr;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let ar = this.index(this.depth), lr = this.pos - this.path[this.path.length - 1];
    return lr ? this.parent.child(ar).cut(0, lr) : ar == 0 ? null : this.parent.child(ar - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(ar, lr) {
    lr = this.resolveDepth(lr);
    let ur = this.path[lr * 3], dr = lr == 0 ? 0 : this.path[lr * 3 - 1] + 1;
    for (let fr = 0; fr < ar; fr++)
      dr += ur.child(fr).nodeSize;
    return dr;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let ar = this.parent, lr = this.index();
    if (ar.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return ar.child(lr).marks;
    let ur = ar.maybeChild(lr - 1), dr = ar.maybeChild(lr);
    if (!ur) {
      let mr = ur;
      ur = dr, dr = mr;
    }
    let fr = ur.marks;
    for (var gr = 0; gr < fr.length; gr++)
      fr[gr].type.spec.inclusive === !1 && (!dr || !fr[gr].isInSet(dr.marks)) && (fr = fr[gr--].removeFromSet(fr));
    return fr;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(ar) {
    let lr = this.parent.maybeChild(this.index());
    if (!lr || !lr.isInline)
      return null;
    let ur = lr.marks, dr = ar.parent.maybeChild(ar.index());
    for (var fr = 0; fr < ur.length; fr++)
      ur[fr].type.spec.inclusive === !1 && (!dr || !ur[fr].isInSet(dr.marks)) && (ur = ur[fr--].removeFromSet(ur));
    return ur;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(ar) {
    for (let lr = this.depth; lr > 0; lr--)
      if (this.start(lr) <= ar && this.end(lr) >= ar)
        return lr;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(ar = this, lr) {
    if (ar.pos < this.pos)
      return ar.blockRange(this);
    for (let ur = this.depth - (this.parent.inlineContent || this.pos == ar.pos ? 1 : 0); ur >= 0; ur--)
      if (ar.pos <= this.end(ur) && (!lr || lr(this.node(ur))))
        return new NodeRange(this, ar, ur);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(ar) {
    return this.pos - this.parentOffset == ar.pos - ar.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(ar) {
    return ar.pos > this.pos ? ar : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(ar) {
    return ar.pos < this.pos ? ar : this;
  }
  /**
  @internal
  */
  toString() {
    let ar = "";
    for (let lr = 1; lr <= this.depth; lr++)
      ar += (ar ? "/" : "") + this.node(lr).type.name + "_" + this.index(lr - 1);
    return ar + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(ar, lr) {
    if (!(lr >= 0 && lr <= ar.content.size))
      throw new RangeError("Position " + lr + " out of range");
    let ur = [], dr = 0, fr = lr;
    for (let gr = ar; ; ) {
      let { index: mr, offset: vr } = gr.content.findIndex(fr), yr = fr - vr;
      if (ur.push(gr, mr, dr + vr), !yr || (gr = gr.child(mr), gr.isText))
        break;
      fr = yr - 1, dr += vr + 1;
    }
    return new ResolvedPos(lr, ur, fr);
  }
  /**
  @internal
  */
  static resolveCached(ar, lr) {
    for (let dr = 0; dr < resolveCache.length; dr++) {
      let fr = resolveCache[dr];
      if (fr.pos == lr && fr.doc == ar)
        return fr;
    }
    let ur = resolveCache[resolveCachePos] = ResolvedPos.resolve(ar, lr);
    return resolveCachePos = (resolveCachePos + 1) % resolveCacheSize, ur;
  }
}
let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(ar, lr, ur) {
    this.$from = ar, this.$to = lr, this.depth = ur;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$3 = class zo {
  /**
  @internal
  */
  constructor(ar, lr, ur, dr = Mark$1.none) {
    this.type = ar, this.attrs = lr, this.marks = dr, this.content = ur || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(ar) {
    return this.content.child(ar);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(ar) {
    return this.content.maybeChild(ar);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(ar) {
    this.content.forEach(ar);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(ar, lr, ur, dr = 0) {
    this.content.nodesBetween(ar, lr, ur, dr, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(ar) {
    this.nodesBetween(0, this.content.size, ar);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(ar, lr, ur, dr) {
    return this.content.textBetween(ar, lr, ur, dr);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(ar) {
    return this == ar || this.sameMarkup(ar) && this.content.eq(ar.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(ar) {
    return this.hasMarkup(ar.type, ar.attrs, ar.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(ar, lr, ur) {
    return this.type == ar && compareDeep(this.attrs, lr || ar.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, ur || Mark$1.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(ar = null) {
    return ar == this.content ? this : new zo(this.type, this.attrs, ar, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(ar) {
    return ar == this.marks ? this : new zo(this.type, this.attrs, this.content, ar);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(ar, lr = this.content.size) {
    return ar == 0 && lr == this.content.size ? this : this.copy(this.content.cut(ar, lr));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(ar, lr = this.content.size, ur = !1) {
    if (ar == lr)
      return Slice.empty;
    let dr = this.resolve(ar), fr = this.resolve(lr), gr = ur ? 0 : dr.sharedDepth(lr), mr = dr.start(gr), yr = dr.node(gr).content.cut(dr.pos - mr, fr.pos - mr);
    return new Slice(yr, dr.depth - gr, fr.depth - gr);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(ar, lr, ur) {
    return replace(this.resolve(ar), this.resolve(lr), ur);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(ar) {
    for (let lr = this; ; ) {
      let { index: ur, offset: dr } = lr.content.findIndex(ar);
      if (lr = lr.maybeChild(ur), !lr)
        return null;
      if (dr == ar || lr.isText)
        return lr;
      ar -= dr + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(ar) {
    let { index: lr, offset: ur } = this.content.findIndex(ar);
    return { node: this.content.maybeChild(lr), index: lr, offset: ur };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(ar) {
    if (ar == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: lr, offset: ur } = this.content.findIndex(ar);
    if (ur < ar)
      return { node: this.content.child(lr), index: lr, offset: ur };
    let dr = this.content.child(lr - 1);
    return { node: dr, index: lr - 1, offset: ur - dr.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(ar) {
    return ResolvedPos.resolveCached(this, ar);
  }
  /**
  @internal
  */
  resolveNoCache(ar) {
    return ResolvedPos.resolve(this, ar);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(ar, lr, ur) {
    let dr = !1;
    return lr > ar && this.nodesBetween(ar, lr, (fr) => (ur.isInSet(fr.marks) && (dr = !0), !dr)), dr;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let ar = this.type.name;
    return this.content.size && (ar += "(" + this.content.toStringInner() + ")"), wrapMarks(this.marks, ar);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(ar) {
    let lr = this.type.contentMatch.matchFragment(this.content, 0, ar);
    if (!lr)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return lr;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(ar, lr, ur = Fragment.empty, dr = 0, fr = ur.childCount) {
    let gr = this.contentMatchAt(ar).matchFragment(ur, dr, fr), mr = gr && gr.matchFragment(this.content, lr);
    if (!mr || !mr.validEnd)
      return !1;
    for (let vr = dr; vr < fr; vr++)
      if (!this.type.allowsMarks(ur.child(vr).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(ar, lr, ur, dr) {
    if (dr && !this.type.allowsMarks(dr))
      return !1;
    let fr = this.contentMatchAt(ar).matchType(ur), gr = fr && fr.matchFragment(this.content, lr);
    return gr ? gr.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(ar) {
    return ar.content.size ? this.canReplace(this.childCount, this.childCount, ar.content) : this.type.compatibleContent(ar.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let ar = Mark$1.none;
    for (let lr = 0; lr < this.marks.length; lr++)
      ar = this.marks[lr].addToSet(ar);
    if (!Mark$1.sameSet(ar, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((lr) => lr.type.name)}`);
    this.content.forEach((lr) => lr.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let ar = { type: this.type.name };
    for (let lr in this.attrs) {
      ar.attrs = this.attrs;
      break;
    }
    return this.content.size && (ar.content = this.content.toJSON()), this.marks.length && (ar.marks = this.marks.map((lr) => lr.toJSON())), ar;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(ar, lr) {
    if (!lr)
      throw new RangeError("Invalid input for Node.fromJSON");
    let ur = null;
    if (lr.marks) {
      if (!Array.isArray(lr.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      ur = lr.marks.map(ar.markFromJSON);
    }
    if (lr.type == "text") {
      if (typeof lr.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return ar.text(lr.text, ur);
    }
    let dr = Fragment.fromJSON(ar, lr.content);
    return ar.nodeType(lr.type).create(lr.attrs, dr, ur);
  }
};
Node$3.prototype.text = void 0;
class TextNode extends Node$3 {
  /**
  @internal
  */
  constructor(ar, lr, ur, dr) {
    if (super(ar, lr, null, dr), !ur)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = ur;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(ar, lr) {
    return this.text.slice(ar, lr);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(ar) {
    return ar == this.marks ? this : new TextNode(this.type, this.attrs, this.text, ar);
  }
  withText(ar) {
    return ar == this.text ? this : new TextNode(this.type, this.attrs, ar, this.marks);
  }
  cut(ar = 0, lr = this.text.length) {
    return ar == 0 && lr == this.text.length ? this : this.withText(this.text.slice(ar, lr));
  }
  eq(ar) {
    return this.sameMarkup(ar) && this.text == ar.text;
  }
  toJSON() {
    let ar = super.toJSON();
    return ar.text = this.text, ar;
  }
}
function wrapMarks(cr, ar) {
  for (let lr = cr.length - 1; lr >= 0; lr--)
    ar = cr[lr].type.name + "(" + ar + ")";
  return ar;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(ar) {
    this.validEnd = ar, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(ar, lr) {
    let ur = new TokenStream(ar, lr);
    if (ur.next == null)
      return ContentMatch.empty;
    let dr = parseExpr(ur);
    ur.next && ur.err("Unexpected trailing text");
    let fr = dfa(nfa(dr));
    return checkForDeadEnds(fr, ur), fr;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(ar) {
    for (let lr = 0; lr < this.next.length; lr++)
      if (this.next[lr].type == ar)
        return this.next[lr].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(ar, lr = 0, ur = ar.childCount) {
    let dr = this;
    for (let fr = lr; dr && fr < ur; fr++)
      dr = dr.matchType(ar.child(fr).type);
    return dr;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let ar = 0; ar < this.next.length; ar++) {
      let { type: lr } = this.next[ar];
      if (!(lr.isText || lr.hasRequiredAttrs()))
        return lr;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(ar) {
    for (let lr = 0; lr < this.next.length; lr++)
      for (let ur = 0; ur < ar.next.length; ur++)
        if (this.next[lr].type == ar.next[ur].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(ar, lr = !1, ur = 0) {
    let dr = [this];
    function fr(gr, mr) {
      let vr = gr.matchFragment(ar, ur);
      if (vr && (!lr || vr.validEnd))
        return Fragment.from(mr.map((yr) => yr.createAndFill()));
      for (let yr = 0; yr < gr.next.length; yr++) {
        let { type: _r, next: kr } = gr.next[yr];
        if (!(_r.isText || _r.hasRequiredAttrs()) && dr.indexOf(kr) == -1) {
          dr.push(kr);
          let xr = fr(kr, mr.concat(_r));
          if (xr)
            return xr;
        }
      }
      return null;
    }
    return fr(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(ar) {
    for (let ur = 0; ur < this.wrapCache.length; ur += 2)
      if (this.wrapCache[ur] == ar)
        return this.wrapCache[ur + 1];
    let lr = this.computeWrapping(ar);
    return this.wrapCache.push(ar, lr), lr;
  }
  /**
  @internal
  */
  computeWrapping(ar) {
    let lr = /* @__PURE__ */ Object.create(null), ur = [{ match: this, type: null, via: null }];
    for (; ur.length; ) {
      let dr = ur.shift(), fr = dr.match;
      if (fr.matchType(ar)) {
        let gr = [];
        for (let mr = dr; mr.type; mr = mr.via)
          gr.push(mr.type);
        return gr.reverse();
      }
      for (let gr = 0; gr < fr.next.length; gr++) {
        let { type: mr, next: vr } = fr.next[gr];
        !mr.isLeaf && !mr.hasRequiredAttrs() && !(mr.name in lr) && (!dr.type || vr.validEnd) && (ur.push({ match: mr.contentMatch, type: mr, via: dr }), lr[mr.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(ar) {
    if (ar >= this.next.length)
      throw new RangeError(`There's no ${ar}th edge in this content match`);
    return this.next[ar];
  }
  /**
  @internal
  */
  toString() {
    let ar = [];
    function lr(ur) {
      ar.push(ur);
      for (let dr = 0; dr < ur.next.length; dr++)
        ar.indexOf(ur.next[dr].next) == -1 && lr(ur.next[dr].next);
    }
    return lr(this), ar.map((ur, dr) => {
      let fr = dr + (ur.validEnd ? "*" : " ") + " ";
      for (let gr = 0; gr < ur.next.length; gr++)
        fr += (gr ? ", " : "") + ur.next[gr].type.name + "->" + ar.indexOf(ur.next[gr].next);
      return fr;
    }).join(`
`);
  }
}
ContentMatch.empty = new ContentMatch(!0);
class TokenStream {
  constructor(ar, lr) {
    this.string = ar, this.nodeTypes = lr, this.inline = null, this.pos = 0, this.tokens = ar.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(ar) {
    return this.next == ar && (this.pos++ || !0);
  }
  err(ar) {
    throw new SyntaxError(ar + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(cr) {
  let ar = [];
  do
    ar.push(parseExprSeq(cr));
  while (cr.eat("|"));
  return ar.length == 1 ? ar[0] : { type: "choice", exprs: ar };
}
function parseExprSeq(cr) {
  let ar = [];
  do
    ar.push(parseExprSubscript(cr));
  while (cr.next && cr.next != ")" && cr.next != "|");
  return ar.length == 1 ? ar[0] : { type: "seq", exprs: ar };
}
function parseExprSubscript(cr) {
  let ar = parseExprAtom(cr);
  for (; ; )
    if (cr.eat("+"))
      ar = { type: "plus", expr: ar };
    else if (cr.eat("*"))
      ar = { type: "star", expr: ar };
    else if (cr.eat("?"))
      ar = { type: "opt", expr: ar };
    else if (cr.eat("{"))
      ar = parseExprRange(cr, ar);
    else
      break;
  return ar;
}
function parseNum(cr) {
  /\D/.test(cr.next) && cr.err("Expected number, got '" + cr.next + "'");
  let ar = Number(cr.next);
  return cr.pos++, ar;
}
function parseExprRange(cr, ar) {
  let lr = parseNum(cr), ur = lr;
  return cr.eat(",") && (cr.next != "}" ? ur = parseNum(cr) : ur = -1), cr.eat("}") || cr.err("Unclosed braced range"), { type: "range", min: lr, max: ur, expr: ar };
}
function resolveName(cr, ar) {
  let lr = cr.nodeTypes, ur = lr[ar];
  if (ur)
    return [ur];
  let dr = [];
  for (let fr in lr) {
    let gr = lr[fr];
    gr.groups.indexOf(ar) > -1 && dr.push(gr);
  }
  return dr.length == 0 && cr.err("No node type or group '" + ar + "' found"), dr;
}
function parseExprAtom(cr) {
  if (cr.eat("(")) {
    let ar = parseExpr(cr);
    return cr.eat(")") || cr.err("Missing closing paren"), ar;
  } else if (/\W/.test(cr.next))
    cr.err("Unexpected token '" + cr.next + "'");
  else {
    let ar = resolveName(cr, cr.next).map((lr) => (cr.inline == null ? cr.inline = lr.isInline : cr.inline != lr.isInline && cr.err("Mixing inline and block content"), { type: "name", value: lr }));
    return cr.pos++, ar.length == 1 ? ar[0] : { type: "choice", exprs: ar };
  }
}
function nfa(cr) {
  let ar = [[]];
  return dr(fr(cr, 0), lr()), ar;
  function lr() {
    return ar.push([]) - 1;
  }
  function ur(gr, mr, vr) {
    let yr = { term: vr, to: mr };
    return ar[gr].push(yr), yr;
  }
  function dr(gr, mr) {
    gr.forEach((vr) => vr.to = mr);
  }
  function fr(gr, mr) {
    if (gr.type == "choice")
      return gr.exprs.reduce((vr, yr) => vr.concat(fr(yr, mr)), []);
    if (gr.type == "seq")
      for (let vr = 0; ; vr++) {
        let yr = fr(gr.exprs[vr], mr);
        if (vr == gr.exprs.length - 1)
          return yr;
        dr(yr, mr = lr());
      }
    else if (gr.type == "star") {
      let vr = lr();
      return ur(mr, vr), dr(fr(gr.expr, vr), vr), [ur(vr)];
    } else if (gr.type == "plus") {
      let vr = lr();
      return dr(fr(gr.expr, mr), vr), dr(fr(gr.expr, vr), vr), [ur(vr)];
    } else {
      if (gr.type == "opt")
        return [ur(mr)].concat(fr(gr.expr, mr));
      if (gr.type == "range") {
        let vr = mr;
        for (let yr = 0; yr < gr.min; yr++) {
          let _r = lr();
          dr(fr(gr.expr, vr), _r), vr = _r;
        }
        if (gr.max == -1)
          dr(fr(gr.expr, vr), vr);
        else
          for (let yr = gr.min; yr < gr.max; yr++) {
            let _r = lr();
            ur(vr, _r), dr(fr(gr.expr, vr), _r), vr = _r;
          }
        return [ur(vr)];
      } else {
        if (gr.type == "name")
          return [ur(mr, void 0, gr.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function cmp(cr, ar) {
  return ar - cr;
}
function nullFrom(cr, ar) {
  let lr = [];
  return ur(ar), lr.sort(cmp);
  function ur(dr) {
    let fr = cr[dr];
    if (fr.length == 1 && !fr[0].term)
      return ur(fr[0].to);
    lr.push(dr);
    for (let gr = 0; gr < fr.length; gr++) {
      let { term: mr, to: vr } = fr[gr];
      !mr && lr.indexOf(vr) == -1 && ur(vr);
    }
  }
}
function dfa(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  return lr(nullFrom(cr, 0));
  function lr(ur) {
    let dr = [];
    ur.forEach((gr) => {
      cr[gr].forEach(({ term: mr, to: vr }) => {
        if (!mr)
          return;
        let yr;
        for (let _r = 0; _r < dr.length; _r++)
          dr[_r][0] == mr && (yr = dr[_r][1]);
        nullFrom(cr, vr).forEach((_r) => {
          yr || dr.push([mr, yr = []]), yr.indexOf(_r) == -1 && yr.push(_r);
        });
      });
    });
    let fr = ar[ur.join(",")] = new ContentMatch(ur.indexOf(cr.length - 1) > -1);
    for (let gr = 0; gr < dr.length; gr++) {
      let mr = dr[gr][1].sort(cmp);
      fr.next.push({ type: dr[gr][0], next: ar[mr.join(",")] || lr(mr) });
    }
    return fr;
  }
}
function checkForDeadEnds(cr, ar) {
  for (let lr = 0, ur = [cr]; lr < ur.length; lr++) {
    let dr = ur[lr], fr = !dr.validEnd, gr = [];
    for (let mr = 0; mr < dr.next.length; mr++) {
      let { type: vr, next: yr } = dr.next[mr];
      gr.push(vr.name), fr && !(vr.isText || vr.hasRequiredAttrs()) && (fr = !1), ur.indexOf(yr) == -1 && ur.push(yr);
    }
    fr && ar.err("Only non-generatable nodes (" + gr.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  for (let lr in cr) {
    let ur = cr[lr];
    if (!ur.hasDefault)
      return null;
    ar[lr] = ur.default;
  }
  return ar;
}
function computeAttrs(cr, ar) {
  let lr = /* @__PURE__ */ Object.create(null);
  for (let ur in cr) {
    let dr = ar && ar[ur];
    if (dr === void 0) {
      let fr = cr[ur];
      if (fr.hasDefault)
        dr = fr.default;
      else
        throw new RangeError("No value supplied for attribute " + ur);
    }
    lr[ur] = dr;
  }
  return lr;
}
function initAttrs(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  if (cr)
    for (let lr in cr)
      ar[lr] = new Attribute(cr[lr]);
  return ar;
}
let NodeType$1 = class Vo {
  /**
  @internal
  */
  constructor(ar, lr, ur) {
    this.name = ar, this.schema = lr, this.spec = ur, this.markSet = null, this.groups = ur.group ? ur.group.split(" ") : [], this.attrs = initAttrs(ur.attrs), this.defaultAttrs = defaultAttrs(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(ur.inline || ar == "text"), this.isText = ar == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let ar in this.attrs)
      if (this.attrs[ar].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(ar) {
    return this == ar || this.contentMatch.compatible(ar.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(ar) {
    return !ar && this.defaultAttrs ? this.defaultAttrs : computeAttrs(this.attrs, ar);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(ar = null, lr, ur) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$3(this, this.computeAttrs(ar), Fragment.from(lr), Mark$1.setFrom(ur));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(ar = null, lr, ur) {
    return lr = Fragment.from(lr), this.checkContent(lr), new Node$3(this, this.computeAttrs(ar), lr, Mark$1.setFrom(ur));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(ar = null, lr, ur) {
    if (ar = this.computeAttrs(ar), lr = Fragment.from(lr), lr.size) {
      let gr = this.contentMatch.fillBefore(lr);
      if (!gr)
        return null;
      lr = gr.append(lr);
    }
    let dr = this.contentMatch.matchFragment(lr), fr = dr && dr.fillBefore(Fragment.empty, !0);
    return fr ? new Node$3(this, ar, lr.append(fr), Mark$1.setFrom(ur)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(ar) {
    let lr = this.contentMatch.matchFragment(ar);
    if (!lr || !lr.validEnd)
      return !1;
    for (let ur = 0; ur < ar.childCount; ur++)
      if (!this.allowsMarks(ar.child(ur).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(ar) {
    if (!this.validContent(ar))
      throw new RangeError(`Invalid content for node ${this.name}: ${ar.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(ar) {
    return this.markSet == null || this.markSet.indexOf(ar) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(ar) {
    if (this.markSet == null)
      return !0;
    for (let lr = 0; lr < ar.length; lr++)
      if (!this.allowsMarkType(ar[lr].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(ar) {
    if (this.markSet == null)
      return ar;
    let lr;
    for (let ur = 0; ur < ar.length; ur++)
      this.allowsMarkType(ar[ur].type) ? lr && lr.push(ar[ur]) : lr || (lr = ar.slice(0, ur));
    return lr ? lr.length ? lr : Mark$1.none : ar;
  }
  /**
  @internal
  */
  static compile(ar, lr) {
    let ur = /* @__PURE__ */ Object.create(null);
    ar.forEach((fr, gr) => ur[fr] = new Vo(fr, lr, gr));
    let dr = lr.spec.topNode || "doc";
    if (!ur[dr])
      throw new RangeError("Schema is missing its top node type ('" + dr + "')");
    if (!ur.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let fr in ur.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return ur;
  }
};
class Attribute {
  constructor(ar) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(ar, "default"), this.default = ar.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(ar, lr, ur, dr) {
    this.name = ar, this.rank = lr, this.schema = ur, this.spec = dr, this.attrs = initAttrs(dr.attrs), this.excluded = null;
    let fr = defaultAttrs(this.attrs);
    this.instance = fr ? new Mark$1(this, fr) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(ar = null) {
    return !ar && this.instance ? this.instance : new Mark$1(this, computeAttrs(this.attrs, ar));
  }
  /**
  @internal
  */
  static compile(ar, lr) {
    let ur = /* @__PURE__ */ Object.create(null), dr = 0;
    return ar.forEach((fr, gr) => ur[fr] = new MarkType(fr, dr++, lr, gr)), ur;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(ar) {
    for (var lr = 0; lr < ar.length; lr++)
      ar[lr].type == this && (ar = ar.slice(0, lr).concat(ar.slice(lr + 1)), lr--);
    return ar;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(ar) {
    for (let lr = 0; lr < ar.length; lr++)
      if (ar[lr].type == this)
        return ar[lr];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(ar) {
    return this.excluded.indexOf(ar) > -1;
  }
}
class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(ar) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let lr = this.spec = {};
    for (let dr in ar)
      lr[dr] = ar[dr];
    lr.nodes = OrderedMap.from(ar.nodes), lr.marks = OrderedMap.from(ar.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this), this.marks = MarkType.compile(this.spec.marks, this);
    let ur = /* @__PURE__ */ Object.create(null);
    for (let dr in this.nodes) {
      if (dr in this.marks)
        throw new RangeError(dr + " can not be both a node and a mark");
      let fr = this.nodes[dr], gr = fr.spec.content || "", mr = fr.spec.marks;
      fr.contentMatch = ur[gr] || (ur[gr] = ContentMatch.parse(gr, this.nodes)), fr.inlineContent = fr.contentMatch.inlineContent, fr.markSet = mr == "_" ? null : mr ? gatherMarks(this, mr.split(" ")) : mr == "" || !fr.inlineContent ? [] : null;
    }
    for (let dr in this.marks) {
      let fr = this.marks[dr], gr = fr.spec.excludes;
      fr.excluded = gr == null ? [fr] : gr == "" ? [] : gatherMarks(this, gr.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(ar, lr = null, ur, dr) {
    if (typeof ar == "string")
      ar = this.nodeType(ar);
    else if (ar instanceof NodeType$1) {
      if (ar.schema != this)
        throw new RangeError("Node type from different schema used (" + ar.name + ")");
    } else
      throw new RangeError("Invalid node type: " + ar);
    return ar.createChecked(lr, ur, dr);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(ar, lr) {
    let ur = this.nodes.text;
    return new TextNode(ur, ur.defaultAttrs, ar, Mark$1.setFrom(lr));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(ar, lr) {
    return typeof ar == "string" && (ar = this.marks[ar]), ar.create(lr);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(ar) {
    return Node$3.fromJSON(this, ar);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(ar) {
    return Mark$1.fromJSON(this, ar);
  }
  /**
  @internal
  */
  nodeType(ar) {
    let lr = this.nodes[ar];
    if (!lr)
      throw new RangeError("Unknown node type: " + ar);
    return lr;
  }
}
function gatherMarks(cr, ar) {
  let lr = [];
  for (let ur = 0; ur < ar.length; ur++) {
    let dr = ar[ur], fr = cr.marks[dr], gr = fr;
    if (fr)
      lr.push(fr);
    else
      for (let mr in cr.marks) {
        let vr = cr.marks[mr];
        (dr == "_" || vr.spec.group && vr.spec.group.split(" ").indexOf(dr) > -1) && lr.push(gr = vr);
      }
    if (!gr)
      throw new SyntaxError("Unknown mark type: '" + ar[ur] + "'");
  }
  return lr;
}
class DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(ar, lr) {
    this.schema = ar, this.rules = lr, this.tags = [], this.styles = [], lr.forEach((ur) => {
      ur.tag ? this.tags.push(ur) : ur.style && this.styles.push(ur);
    }), this.normalizeLists = !this.tags.some((ur) => {
      if (!/^(ul|ol)\b/.test(ur.tag) || !ur.node)
        return !1;
      let dr = ar.nodes[ur.node];
      return dr.contentMatch.matchType(dr);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(ar, lr = {}) {
    let ur = new ParseContext(this, lr, !1);
    return ur.addAll(ar, lr.from, lr.to), ur.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(ar, lr = {}) {
    let ur = new ParseContext(this, lr, !0);
    return ur.addAll(ar, lr.from, lr.to), Slice.maxOpen(ur.finish());
  }
  /**
  @internal
  */
  matchTag(ar, lr, ur) {
    for (let dr = ur ? this.tags.indexOf(ur) + 1 : 0; dr < this.tags.length; dr++) {
      let fr = this.tags[dr];
      if (matches$1(ar, fr.tag) && (fr.namespace === void 0 || ar.namespaceURI == fr.namespace) && (!fr.context || lr.matchesContext(fr.context))) {
        if (fr.getAttrs) {
          let gr = fr.getAttrs(ar);
          if (gr === !1)
            continue;
          fr.attrs = gr || void 0;
        }
        return fr;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(ar, lr, ur, dr) {
    for (let fr = dr ? this.styles.indexOf(dr) + 1 : 0; fr < this.styles.length; fr++) {
      let gr = this.styles[fr], mr = gr.style;
      if (!(mr.indexOf(ar) != 0 || gr.context && !ur.matchesContext(gr.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      mr.length > ar.length && (mr.charCodeAt(ar.length) != 61 || mr.slice(ar.length + 1) != lr))) {
        if (gr.getAttrs) {
          let vr = gr.getAttrs(lr);
          if (vr === !1)
            continue;
          gr.attrs = vr || void 0;
        }
        return gr;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(ar) {
    let lr = [];
    function ur(dr) {
      let fr = dr.priority == null ? 50 : dr.priority, gr = 0;
      for (; gr < lr.length; gr++) {
        let mr = lr[gr];
        if ((mr.priority == null ? 50 : mr.priority) < fr)
          break;
      }
      lr.splice(gr, 0, dr);
    }
    for (let dr in ar.marks) {
      let fr = ar.marks[dr].spec.parseDOM;
      fr && fr.forEach((gr) => {
        ur(gr = copy$2(gr)), gr.mark || gr.ignore || gr.clearMark || (gr.mark = dr);
      });
    }
    for (let dr in ar.nodes) {
      let fr = ar.nodes[dr].spec.parseDOM;
      fr && fr.forEach((gr) => {
        ur(gr = copy$2(gr)), gr.node || gr.ignore || gr.mark || (gr.node = dr);
      });
    }
    return lr;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(ar) {
    return ar.cached.domParser || (ar.cached.domParser = new DOMParser(ar, DOMParser.schemaRules(ar)));
  }
}
const blockTags = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, ignoreTags = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, listTags = { ol: !0, ul: !0 }, OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(cr, ar, lr) {
  return ar != null ? (ar ? OPT_PRESERVE_WS : 0) | (ar === "full" ? OPT_PRESERVE_WS_FULL : 0) : cr && cr.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : lr & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(ar, lr, ur, dr, fr, gr, mr) {
    this.type = ar, this.attrs = lr, this.marks = ur, this.pendingMarks = dr, this.solid = fr, this.options = mr, this.content = [], this.activeMarks = Mark$1.none, this.stashMarks = [], this.match = gr || (mr & OPT_OPEN_LEFT ? null : ar.contentMatch);
  }
  findWrapping(ar) {
    if (!this.match) {
      if (!this.type)
        return [];
      let lr = this.type.contentMatch.fillBefore(Fragment.from(ar));
      if (lr)
        this.match = this.type.contentMatch.matchFragment(lr);
      else {
        let ur = this.type.contentMatch, dr;
        return (dr = ur.findWrapping(ar.type)) ? (this.match = ur, dr) : null;
      }
    }
    return this.match.findWrapping(ar.type);
  }
  finish(ar) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let ur = this.content[this.content.length - 1], dr;
      if (ur && ur.isText && (dr = /[ \t\r\n\u000c]+$/.exec(ur.text))) {
        let fr = ur;
        ur.text.length == dr[0].length ? this.content.pop() : this.content[this.content.length - 1] = fr.withText(fr.text.slice(0, fr.text.length - dr[0].length));
      }
    }
    let lr = Fragment.from(this.content);
    return !ar && this.match && (lr = lr.append(this.match.fillBefore(Fragment.empty, !0))), this.type ? this.type.create(this.attrs, lr, this.marks) : lr;
  }
  popFromStashMark(ar) {
    for (let lr = this.stashMarks.length - 1; lr >= 0; lr--)
      if (ar.eq(this.stashMarks[lr]))
        return this.stashMarks.splice(lr, 1)[0];
  }
  applyPending(ar) {
    for (let lr = 0, ur = this.pendingMarks; lr < ur.length; lr++) {
      let dr = ur[lr];
      (this.type ? this.type.allowsMarkType(dr.type) : markMayApply(dr.type, ar)) && !dr.isInSet(this.activeMarks) && (this.activeMarks = dr.addToSet(this.activeMarks), this.pendingMarks = dr.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(ar) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : ar.parentNode && !blockTags.hasOwnProperty(ar.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(ar, lr, ur) {
    this.parser = ar, this.options = lr, this.isOpen = ur, this.open = 0;
    let dr = lr.topNode, fr, gr = wsOptionsFor(null, lr.preserveWhitespace, 0) | (ur ? OPT_OPEN_LEFT : 0);
    dr ? fr = new NodeContext(dr.type, dr.attrs, Mark$1.none, Mark$1.none, !0, lr.topMatch || dr.type.contentMatch, gr) : ur ? fr = new NodeContext(null, null, Mark$1.none, Mark$1.none, !0, null, gr) : fr = new NodeContext(ar.schema.topNodeType, null, Mark$1.none, Mark$1.none, !0, null, gr), this.nodes = [fr], this.find = lr.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(ar) {
    ar.nodeType == 3 ? this.addTextNode(ar) : ar.nodeType == 1 && this.addElement(ar);
  }
  withStyleRules(ar, lr) {
    let ur = ar.getAttribute("style");
    if (!ur)
      return lr();
    let dr = this.readStyles(parseStyles(ur));
    if (!dr)
      return;
    let [fr, gr] = dr, mr = this.top;
    for (let vr = 0; vr < gr.length; vr++)
      this.removePendingMark(gr[vr], mr);
    for (let vr = 0; vr < fr.length; vr++)
      this.addPendingMark(fr[vr]);
    lr();
    for (let vr = 0; vr < fr.length; vr++)
      this.removePendingMark(fr[vr], mr);
    for (let vr = 0; vr < gr.length; vr++)
      this.addPendingMark(gr[vr]);
  }
  addTextNode(ar) {
    let lr = ar.nodeValue, ur = this.top;
    if (ur.options & OPT_PRESERVE_WS_FULL || ur.inlineContext(ar) || /[^ \t\r\n\u000c]/.test(lr)) {
      if (ur.options & OPT_PRESERVE_WS)
        ur.options & OPT_PRESERVE_WS_FULL ? lr = lr.replace(/\r\n?/g, `
`) : lr = lr.replace(/\r?\n|\r/g, " ");
      else if (lr = lr.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(lr) && this.open == this.nodes.length - 1) {
        let dr = ur.content[ur.content.length - 1], fr = ar.previousSibling;
        (!dr || fr && fr.nodeName == "BR" || dr.isText && /[ \t\r\n\u000c]$/.test(dr.text)) && (lr = lr.slice(1));
      }
      lr && this.insertNode(this.parser.schema.text(lr)), this.findInText(ar);
    } else
      this.findInside(ar);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(ar, lr) {
    let ur = ar.nodeName.toLowerCase(), dr;
    listTags.hasOwnProperty(ur) && this.parser.normalizeLists && normalizeList(ar);
    let fr = this.options.ruleFromNode && this.options.ruleFromNode(ar) || (dr = this.parser.matchTag(ar, this, lr));
    if (fr ? fr.ignore : ignoreTags.hasOwnProperty(ur))
      this.findInside(ar), this.ignoreFallback(ar);
    else if (!fr || fr.skip || fr.closeParent) {
      fr && fr.closeParent ? this.open = Math.max(0, this.open - 1) : fr && fr.skip.nodeType && (ar = fr.skip);
      let gr, mr = this.top, vr = this.needsBlock;
      if (blockTags.hasOwnProperty(ur))
        mr.content.length && mr.content[0].isInline && this.open && (this.open--, mr = this.top), gr = !0, mr.type || (this.needsBlock = !0);
      else if (!ar.firstChild) {
        this.leafFallback(ar);
        return;
      }
      fr && fr.skip ? this.addAll(ar) : this.withStyleRules(ar, () => this.addAll(ar)), gr && this.sync(mr), this.needsBlock = vr;
    } else
      this.withStyleRules(ar, () => {
        this.addElementByRule(ar, fr, fr.consuming === !1 ? dr : void 0);
      });
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(ar) {
    ar.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(ar.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(ar) {
    ar.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(ar) {
    let lr = Mark$1.none, ur = Mark$1.none;
    for (let dr = 0; dr < ar.length; dr += 2)
      for (let fr = void 0; ; ) {
        let gr = this.parser.matchStyle(ar[dr], ar[dr + 1], this, fr);
        if (!gr)
          break;
        if (gr.ignore)
          return null;
        if (gr.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((mr) => {
          gr.clearMark(mr) && (ur = mr.addToSet(ur));
        }) : lr = this.parser.schema.marks[gr.mark].create(gr.attrs).addToSet(lr), gr.consuming === !1)
          fr = gr;
        else
          break;
      }
    return [lr, ur];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(ar, lr, ur) {
    let dr, fr, gr;
    lr.node ? (fr = this.parser.schema.nodes[lr.node], fr.isLeaf ? this.insertNode(fr.create(lr.attrs)) || this.leafFallback(ar) : dr = this.enter(fr, lr.attrs || null, lr.preserveWhitespace)) : (gr = this.parser.schema.marks[lr.mark].create(lr.attrs), this.addPendingMark(gr));
    let mr = this.top;
    if (fr && fr.isLeaf)
      this.findInside(ar);
    else if (ur)
      this.addElement(ar, ur);
    else if (lr.getContent)
      this.findInside(ar), lr.getContent(ar, this.parser.schema).forEach((vr) => this.insertNode(vr));
    else {
      let vr = ar;
      typeof lr.contentElement == "string" ? vr = ar.querySelector(lr.contentElement) : typeof lr.contentElement == "function" ? vr = lr.contentElement(ar) : lr.contentElement && (vr = lr.contentElement), this.findAround(ar, vr, !0), this.addAll(vr);
    }
    dr && this.sync(mr) && this.open--, gr && this.removePendingMark(gr, mr);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(ar, lr, ur) {
    let dr = lr || 0;
    for (let fr = lr ? ar.childNodes[lr] : ar.firstChild, gr = ur == null ? null : ar.childNodes[ur]; fr != gr; fr = fr.nextSibling, ++dr)
      this.findAtPoint(ar, dr), this.addDOM(fr);
    this.findAtPoint(ar, dr);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(ar) {
    let lr, ur;
    for (let dr = this.open; dr >= 0; dr--) {
      let fr = this.nodes[dr], gr = fr.findWrapping(ar);
      if (gr && (!lr || lr.length > gr.length) && (lr = gr, ur = fr, !gr.length) || fr.solid)
        break;
    }
    if (!lr)
      return !1;
    this.sync(ur);
    for (let dr = 0; dr < lr.length; dr++)
      this.enterInner(lr[dr], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(ar) {
    if (ar.isInline && this.needsBlock && !this.top.type) {
      let lr = this.textblockFromContext();
      lr && this.enterInner(lr);
    }
    if (this.findPlace(ar)) {
      this.closeExtra();
      let lr = this.top;
      lr.applyPending(ar.type), lr.match && (lr.match = lr.match.matchType(ar.type));
      let ur = lr.activeMarks;
      for (let dr = 0; dr < ar.marks.length; dr++)
        (!lr.type || lr.type.allowsMarkType(ar.marks[dr].type)) && (ur = ar.marks[dr].addToSet(ur));
      return lr.content.push(ar.mark(ur)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(ar, lr, ur) {
    let dr = this.findPlace(ar.create(lr));
    return dr && this.enterInner(ar, lr, !0, ur), dr;
  }
  // Open a node of the given type
  enterInner(ar, lr = null, ur = !1, dr) {
    this.closeExtra();
    let fr = this.top;
    fr.applyPending(ar), fr.match = fr.match && fr.match.matchType(ar);
    let gr = wsOptionsFor(ar, dr, fr.options);
    fr.options & OPT_OPEN_LEFT && fr.content.length == 0 && (gr |= OPT_OPEN_LEFT), this.nodes.push(new NodeContext(ar, lr, fr.activeMarks, fr.pendingMarks, ur, null, gr)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(ar = !1) {
    let lr = this.nodes.length - 1;
    if (lr > this.open) {
      for (; lr > this.open; lr--)
        this.nodes[lr - 1].content.push(this.nodes[lr].finish(ar));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(ar) {
    for (let lr = this.open; lr >= 0; lr--)
      if (this.nodes[lr] == ar)
        return this.open = lr, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let ar = 0;
    for (let lr = this.open; lr >= 0; lr--) {
      let ur = this.nodes[lr].content;
      for (let dr = ur.length - 1; dr >= 0; dr--)
        ar += ur[dr].nodeSize;
      lr && ar++;
    }
    return ar;
  }
  findAtPoint(ar, lr) {
    if (this.find)
      for (let ur = 0; ur < this.find.length; ur++)
        this.find[ur].node == ar && this.find[ur].offset == lr && (this.find[ur].pos = this.currentPos);
  }
  findInside(ar) {
    if (this.find)
      for (let lr = 0; lr < this.find.length; lr++)
        this.find[lr].pos == null && ar.nodeType == 1 && ar.contains(this.find[lr].node) && (this.find[lr].pos = this.currentPos);
  }
  findAround(ar, lr, ur) {
    if (ar != lr && this.find)
      for (let dr = 0; dr < this.find.length; dr++)
        this.find[dr].pos == null && ar.nodeType == 1 && ar.contains(this.find[dr].node) && lr.compareDocumentPosition(this.find[dr].node) & (ur ? 2 : 4) && (this.find[dr].pos = this.currentPos);
  }
  findInText(ar) {
    if (this.find)
      for (let lr = 0; lr < this.find.length; lr++)
        this.find[lr].node == ar && (this.find[lr].pos = this.currentPos - (ar.nodeValue.length - this.find[lr].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(ar) {
    if (ar.indexOf("|") > -1)
      return ar.split(/\s*\|\s*/).some(this.matchesContext, this);
    let lr = ar.split("/"), ur = this.options.context, dr = !this.isOpen && (!ur || ur.parent.type == this.nodes[0].type), fr = -(ur ? ur.depth + 1 : 0) + (dr ? 0 : 1), gr = (mr, vr) => {
      for (; mr >= 0; mr--) {
        let yr = lr[mr];
        if (yr == "") {
          if (mr == lr.length - 1 || mr == 0)
            continue;
          for (; vr >= fr; vr--)
            if (gr(mr - 1, vr))
              return !0;
          return !1;
        } else {
          let _r = vr > 0 || vr == 0 && dr ? this.nodes[vr].type : ur && vr >= fr ? ur.node(vr - fr).type : null;
          if (!_r || _r.name != yr && _r.groups.indexOf(yr) == -1)
            return !1;
          vr--;
        }
      }
      return !0;
    };
    return gr(lr.length - 1, this.open);
  }
  textblockFromContext() {
    let ar = this.options.context;
    if (ar)
      for (let lr = ar.depth; lr >= 0; lr--) {
        let ur = ar.node(lr).contentMatchAt(ar.indexAfter(lr)).defaultType;
        if (ur && ur.isTextblock && ur.defaultAttrs)
          return ur;
      }
    for (let lr in this.parser.schema.nodes) {
      let ur = this.parser.schema.nodes[lr];
      if (ur.isTextblock && ur.defaultAttrs)
        return ur;
    }
  }
  addPendingMark(ar) {
    let lr = findSameMarkInSet(ar, this.top.pendingMarks);
    lr && this.top.stashMarks.push(lr), this.top.pendingMarks = ar.addToSet(this.top.pendingMarks);
  }
  removePendingMark(ar, lr) {
    for (let ur = this.open; ur >= 0; ur--) {
      let dr = this.nodes[ur];
      if (dr.pendingMarks.lastIndexOf(ar) > -1)
        dr.pendingMarks = ar.removeFromSet(dr.pendingMarks);
      else {
        dr.activeMarks = ar.removeFromSet(dr.activeMarks);
        let gr = dr.popFromStashMark(ar);
        gr && dr.type && dr.type.allowsMarkType(gr.type) && (dr.activeMarks = gr.addToSet(dr.activeMarks));
      }
      if (dr == lr)
        break;
    }
  }
}
function normalizeList(cr) {
  for (let ar = cr.firstChild, lr = null; ar; ar = ar.nextSibling) {
    let ur = ar.nodeType == 1 ? ar.nodeName.toLowerCase() : null;
    ur && listTags.hasOwnProperty(ur) && lr ? (lr.appendChild(ar), ar = lr) : ur == "li" ? lr = ar : ur && (lr = null);
  }
}
function matches$1(cr, ar) {
  return (cr.matches || cr.msMatchesSelector || cr.webkitMatchesSelector || cr.mozMatchesSelector).call(cr, ar);
}
function parseStyles(cr) {
  let ar = /\s*([\w-]+)\s*:\s*([^;]+)/g, lr, ur = [];
  for (; lr = ar.exec(cr); )
    ur.push(lr[1], lr[2].trim());
  return ur;
}
function copy$2(cr) {
  let ar = {};
  for (let lr in cr)
    ar[lr] = cr[lr];
  return ar;
}
function markMayApply(cr, ar) {
  let lr = ar.schema.nodes;
  for (let ur in lr) {
    let dr = lr[ur];
    if (!dr.allowsMarkType(cr))
      continue;
    let fr = [], gr = (mr) => {
      fr.push(mr);
      for (let vr = 0; vr < mr.edgeCount; vr++) {
        let { type: yr, next: _r } = mr.edge(vr);
        if (yr == ar || fr.indexOf(_r) < 0 && gr(_r))
          return !0;
      }
    };
    if (gr(dr.contentMatch))
      return !0;
  }
}
function findSameMarkInSet(cr, ar) {
  for (let lr = 0; lr < ar.length; lr++)
    if (cr.eq(ar[lr]))
      return ar[lr];
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(ar, lr) {
    this.nodes = ar, this.marks = lr;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(ar, lr = {}, ur) {
    ur || (ur = doc$1(lr).createDocumentFragment());
    let dr = ur, fr = [];
    return ar.forEach((gr) => {
      if (fr.length || gr.marks.length) {
        let mr = 0, vr = 0;
        for (; mr < fr.length && vr < gr.marks.length; ) {
          let yr = gr.marks[vr];
          if (!this.marks[yr.type.name]) {
            vr++;
            continue;
          }
          if (!yr.eq(fr[mr][0]) || yr.type.spec.spanning === !1)
            break;
          mr++, vr++;
        }
        for (; mr < fr.length; )
          dr = fr.pop()[1];
        for (; vr < gr.marks.length; ) {
          let yr = gr.marks[vr++], _r = this.serializeMark(yr, gr.isInline, lr);
          _r && (fr.push([yr, dr]), dr.appendChild(_r.dom), dr = _r.contentDOM || _r.dom);
        }
      }
      dr.appendChild(this.serializeNodeInner(gr, lr));
    }), ur;
  }
  /**
  @internal
  */
  serializeNodeInner(ar, lr) {
    let { dom: ur, contentDOM: dr } = DOMSerializer.renderSpec(doc$1(lr), this.nodes[ar.type.name](ar));
    if (dr) {
      if (ar.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(ar.content, lr, dr);
    }
    return ur;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(ar, lr = {}) {
    let ur = this.serializeNodeInner(ar, lr);
    for (let dr = ar.marks.length - 1; dr >= 0; dr--) {
      let fr = this.serializeMark(ar.marks[dr], ar.isInline, lr);
      fr && ((fr.contentDOM || fr.dom).appendChild(ur), ur = fr.dom);
    }
    return ur;
  }
  /**
  @internal
  */
  serializeMark(ar, lr, ur = {}) {
    let dr = this.marks[ar.type.name];
    return dr && DOMSerializer.renderSpec(doc$1(ur), dr(ar, lr));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(ar, lr, ur = null) {
    if (typeof lr == "string")
      return { dom: ar.createTextNode(lr) };
    if (lr.nodeType != null)
      return { dom: lr };
    if (lr.dom && lr.dom.nodeType != null)
      return lr;
    let dr = lr[0], fr = dr.indexOf(" ");
    fr > 0 && (ur = dr.slice(0, fr), dr = dr.slice(fr + 1));
    let gr, mr = ur ? ar.createElementNS(ur, dr) : ar.createElement(dr), vr = lr[1], yr = 1;
    if (vr && typeof vr == "object" && vr.nodeType == null && !Array.isArray(vr)) {
      yr = 2;
      for (let _r in vr)
        if (vr[_r] != null) {
          let kr = _r.indexOf(" ");
          kr > 0 ? mr.setAttributeNS(_r.slice(0, kr), _r.slice(kr + 1), vr[_r]) : mr.setAttribute(_r, vr[_r]);
        }
    }
    for (let _r = yr; _r < lr.length; _r++) {
      let kr = lr[_r];
      if (kr === 0) {
        if (_r < lr.length - 1 || _r > yr)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: mr, contentDOM: mr };
      } else {
        let { dom: xr, contentDOM: Ar } = DOMSerializer.renderSpec(ar, kr, ur);
        if (mr.appendChild(xr), Ar) {
          if (gr)
            throw new RangeError("Multiple content holes");
          gr = Ar;
        }
      }
    }
    return { dom: mr, contentDOM: gr };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(ar) {
    return ar.cached.domSerializer || (ar.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(ar), this.marksFromSchema(ar)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(ar) {
    let lr = gatherToDOM(ar.nodes);
    return lr.text || (lr.text = (ur) => ur.text), lr;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(ar) {
    return gatherToDOM(ar.marks);
  }
}
function gatherToDOM(cr) {
  let ar = {};
  for (let lr in cr) {
    let ur = cr[lr].spec.toDOM;
    ur && (ar[lr] = ur);
  }
  return ar;
}
function doc$1(cr) {
  return cr.document || window.document;
}
const lower16 = 65535, factor16 = Math.pow(2, 16);
function makeRecover(cr, ar) {
  return cr + ar * factor16;
}
function recoverIndex(cr) {
  return cr & lower16;
}
function recoverOffset(cr) {
  return (cr - (cr & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(ar, lr, ur) {
    this.pos = ar, this.delInfo = lr, this.recover = ur;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ar, lr = !1) {
    if (this.ranges = ar, this.inverted = lr, !ar.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(ar) {
    let lr = 0, ur = recoverIndex(ar);
    if (!this.inverted)
      for (let dr = 0; dr < ur; dr++)
        lr += this.ranges[dr * 3 + 2] - this.ranges[dr * 3 + 1];
    return this.ranges[ur * 3] + lr + recoverOffset(ar);
  }
  mapResult(ar, lr = 1) {
    return this._map(ar, lr, !1);
  }
  map(ar, lr = 1) {
    return this._map(ar, lr, !0);
  }
  /**
  @internal
  */
  _map(ar, lr, ur) {
    let dr = 0, fr = this.inverted ? 2 : 1, gr = this.inverted ? 1 : 2;
    for (let mr = 0; mr < this.ranges.length; mr += 3) {
      let vr = this.ranges[mr] - (this.inverted ? dr : 0);
      if (vr > ar)
        break;
      let yr = this.ranges[mr + fr], _r = this.ranges[mr + gr], kr = vr + yr;
      if (ar <= kr) {
        let xr = yr ? ar == vr ? -1 : ar == kr ? 1 : lr : lr, Ar = vr + dr + (xr < 0 ? 0 : _r);
        if (ur)
          return Ar;
        let Er = ar == (lr < 0 ? vr : kr) ? null : makeRecover(mr / 3, ar - vr), Cr = ar == vr ? DEL_AFTER : ar == kr ? DEL_BEFORE : DEL_ACROSS;
        return (lr < 0 ? ar != vr : ar != kr) && (Cr |= DEL_SIDE), new MapResult(Ar, Cr, Er);
      }
      dr += _r - yr;
    }
    return ur ? ar + dr : new MapResult(ar + dr, 0, null);
  }
  /**
  @internal
  */
  touches(ar, lr) {
    let ur = 0, dr = recoverIndex(lr), fr = this.inverted ? 2 : 1, gr = this.inverted ? 1 : 2;
    for (let mr = 0; mr < this.ranges.length; mr += 3) {
      let vr = this.ranges[mr] - (this.inverted ? ur : 0);
      if (vr > ar)
        break;
      let yr = this.ranges[mr + fr], _r = vr + yr;
      if (ar <= _r && mr == dr * 3)
        return !0;
      ur += this.ranges[mr + gr] - yr;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(ar) {
    let lr = this.inverted ? 2 : 1, ur = this.inverted ? 1 : 2;
    for (let dr = 0, fr = 0; dr < this.ranges.length; dr += 3) {
      let gr = this.ranges[dr], mr = gr - (this.inverted ? fr : 0), vr = gr + (this.inverted ? 0 : fr), yr = this.ranges[dr + lr], _r = this.ranges[dr + ur];
      ar(mr, mr + yr, vr, vr + _r), fr += _r - yr;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(ar) {
    return ar == 0 ? StepMap.empty : new StepMap(ar < 0 ? [0, -ar, 0] : [0, 0, ar]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(ar = [], lr, ur = 0, dr = ar.length) {
    this.maps = ar, this.mirror = lr, this.from = ur, this.to = dr;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(ar = 0, lr = this.maps.length) {
    return new Mapping(this.maps, this.mirror, ar, lr);
  }
  /**
  @internal
  */
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(ar, lr) {
    this.to = this.maps.push(ar), lr != null && this.setMirror(this.maps.length - 1, lr);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(ar) {
    for (let lr = 0, ur = this.maps.length; lr < ar.maps.length; lr++) {
      let dr = ar.getMirror(lr);
      this.appendMap(ar.maps[lr], dr != null && dr < lr ? ur + dr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(ar) {
    if (this.mirror) {
      for (let lr = 0; lr < this.mirror.length; lr++)
        if (this.mirror[lr] == ar)
          return this.mirror[lr + (lr % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(ar, lr) {
    this.mirror || (this.mirror = []), this.mirror.push(ar, lr);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(ar) {
    for (let lr = ar.maps.length - 1, ur = this.maps.length + ar.maps.length; lr >= 0; lr--) {
      let dr = ar.getMirror(lr);
      this.appendMap(ar.maps[lr].invert(), dr != null && dr > lr ? ur - dr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let ar = new Mapping();
    return ar.appendMappingInverted(this), ar;
  }
  /**
  Map a position through this mapping.
  */
  map(ar, lr = 1) {
    if (this.mirror)
      return this._map(ar, lr, !0);
    for (let ur = this.from; ur < this.to; ur++)
      ar = this.maps[ur].map(ar, lr);
    return ar;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(ar, lr = 1) {
    return this._map(ar, lr, !1);
  }
  /**
  @internal
  */
  _map(ar, lr, ur) {
    let dr = 0;
    for (let fr = this.from; fr < this.to; fr++) {
      let gr = this.maps[fr], mr = gr.mapResult(ar, lr);
      if (mr.recover != null) {
        let vr = this.getMirror(fr);
        if (vr != null && vr > fr && vr < this.to) {
          fr = vr, ar = this.maps[vr].recover(mr.recover);
          continue;
        }
      }
      dr |= mr.delInfo, ar = mr.pos;
    }
    return ur ? ar : new MapResult(ar, dr, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(ar) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(ar, lr) {
    if (!lr || !lr.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let ur = stepsByID[lr.stepType];
    if (!ur)
      throw new RangeError(`No step type ${lr.stepType} defined`);
    return ur.fromJSON(ar, lr);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(ar, lr) {
    if (ar in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + ar);
    return stepsByID[ar] = lr, lr.prototype.jsonID = ar, lr;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(ar, lr) {
    this.doc = ar, this.failed = lr;
  }
  /**
  Create a successful step result.
  */
  static ok(ar) {
    return new StepResult(ar, null);
  }
  /**
  Create a failed step result.
  */
  static fail(ar) {
    return new StepResult(null, ar);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(ar, lr, ur, dr) {
    try {
      return StepResult.ok(ar.replace(lr, ur, dr));
    } catch (fr) {
      if (fr instanceof ReplaceError)
        return StepResult.fail(fr.message);
      throw fr;
    }
  }
}
function mapFragment(cr, ar, lr) {
  let ur = [];
  for (let dr = 0; dr < cr.childCount; dr++) {
    let fr = cr.child(dr);
    fr.content.size && (fr = fr.copy(mapFragment(fr.content, ar, fr))), fr.isInline && (fr = ar(fr, lr, dr)), ur.push(fr);
  }
  return Fragment.fromArray(ur);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(ar, lr, ur) {
    super(), this.from = ar, this.to = lr, this.mark = ur;
  }
  apply(ar) {
    let lr = ar.slice(this.from, this.to), ur = ar.resolve(this.from), dr = ur.node(ur.sharedDepth(this.to)), fr = new Slice(mapFragment(lr.content, (gr, mr) => !gr.isAtom || !mr.type.allowsMarkType(this.mark.type) ? gr : gr.mark(this.mark.addToSet(gr.marks)), dr), lr.openStart, lr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, fr);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let lr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return lr.deleted && ur.deleted || lr.pos >= ur.pos ? null : new AddMarkStep(lr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof AddMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new AddMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.from != "number" || typeof lr.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(lr.from, lr.to, ar.markFromJSON(lr.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, lr, ur) {
    super(), this.from = ar, this.to = lr, this.mark = ur;
  }
  apply(ar) {
    let lr = ar.slice(this.from, this.to), ur = new Slice(mapFragment(lr.content, (dr) => dr.mark(this.mark.removeFromSet(dr.marks)), ar), lr.openStart, lr.openEnd);
    return StepResult.fromReplace(ar, this.from, this.to, ur);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(ar) {
    let lr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return lr.deleted && ur.deleted || lr.pos >= ur.pos ? null : new RemoveMarkStep(lr.pos, ur.pos, this.mark);
  }
  merge(ar) {
    return ar instanceof RemoveMarkStep && ar.mark.eq(this.mark) && this.from <= ar.to && this.to >= ar.from ? new RemoveMarkStep(Math.min(this.from, ar.from), Math.max(this.to, ar.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.from != "number" || typeof lr.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(lr.from, lr.to, ar.markFromJSON(lr.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(ar, lr) {
    super(), this.pos = ar, this.mark = lr;
  }
  apply(ar) {
    let lr = ar.nodeAt(this.pos);
    if (!lr)
      return StepResult.fail("No node at mark step's position");
    let ur = lr.type.create(lr.attrs, null, this.mark.addToSet(lr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new Slice(Fragment.from(ur), 0, lr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let lr = ar.nodeAt(this.pos);
    if (lr) {
      let ur = this.mark.addToSet(lr.marks);
      if (ur.length == lr.marks.length) {
        for (let dr = 0; dr < lr.marks.length; dr++)
          if (!lr.marks[dr].isInSet(ur))
            return new AddNodeMarkStep(this.pos, lr.marks[dr]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let lr = ar.mapResult(this.pos, 1);
    return lr.deletedAfter ? null : new AddNodeMarkStep(lr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(lr.pos, ar.markFromJSON(lr.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(ar, lr) {
    super(), this.pos = ar, this.mark = lr;
  }
  apply(ar) {
    let lr = ar.nodeAt(this.pos);
    if (!lr)
      return StepResult.fail("No node at mark step's position");
    let ur = lr.type.create(lr.attrs, null, this.mark.removeFromSet(lr.marks));
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new Slice(Fragment.from(ur), 0, lr.isLeaf ? 0 : 1));
  }
  invert(ar) {
    let lr = ar.nodeAt(this.pos);
    return !lr || !this.mark.isInSet(lr.marks) ? this : new AddNodeMarkStep(this.pos, this.mark);
  }
  map(ar) {
    let lr = ar.mapResult(this.pos, 1);
    return lr.deletedAfter ? null : new RemoveNodeMarkStep(lr.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(lr.pos, ar.markFromJSON(lr.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(ar, lr, ur, dr = !1) {
    super(), this.from = ar, this.to = lr, this.slice = ur, this.structure = dr;
  }
  apply(ar) {
    return this.structure && contentBetween(ar, this.from, this.to) ? StepResult.fail("Structure replace would overwrite content") : StepResult.fromReplace(ar, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(ar) {
    return new ReplaceStep(this.from, this.from + this.slice.size, ar.slice(this.from, this.to));
  }
  map(ar) {
    let lr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1);
    return lr.deletedAcross && ur.deletedAcross ? null : new ReplaceStep(lr.pos, Math.max(lr.pos, ur.pos), this.slice);
  }
  merge(ar) {
    if (!(ar instanceof ReplaceStep) || ar.structure || this.structure)
      return null;
    if (this.from + this.slice.size == ar.from && !this.slice.openEnd && !ar.slice.openStart) {
      let lr = this.slice.size + ar.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(ar.slice.content), this.slice.openStart, ar.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (ar.to - ar.from), lr, this.structure);
    } else if (ar.to == this.from && !this.slice.openStart && !ar.slice.openEnd) {
      let lr = this.slice.size + ar.slice.size == 0 ? Slice.empty : new Slice(ar.slice.content.append(this.slice.content), ar.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(ar.from, this.to, lr, this.structure);
    } else
      return null;
  }
  toJSON() {
    let ar = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.from != "number" || typeof lr.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(lr.from, lr.to, Slice.fromJSON(ar, lr.slice), !!lr.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(ar, lr, ur, dr, fr, gr, mr = !1) {
    super(), this.from = ar, this.to = lr, this.gapFrom = ur, this.gapTo = dr, this.slice = fr, this.insert = gr, this.structure = mr;
  }
  apply(ar) {
    if (this.structure && (contentBetween(ar, this.from, this.gapFrom) || contentBetween(ar, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let lr = ar.slice(this.gapFrom, this.gapTo);
    if (lr.openStart || lr.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let ur = this.slice.insertAt(this.insert, lr.content);
    return ur ? StepResult.fromReplace(ar, this.from, this.to, ur) : StepResult.fail("Content does not fit in gap");
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(ar) {
    let lr = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + lr, this.from + this.insert, this.from + this.insert + lr, ar.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(ar) {
    let lr = ar.mapResult(this.from, 1), ur = ar.mapResult(this.to, -1), dr = ar.map(this.gapFrom, -1), fr = ar.map(this.gapTo, 1);
    return lr.deletedAcross && ur.deletedAcross || dr < lr.pos || fr > ur.pos ? null : new ReplaceAroundStep(lr.pos, ur.pos, dr, fr, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let ar = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (ar.slice = this.slice.toJSON()), this.structure && (ar.structure = !0), ar;
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.from != "number" || typeof lr.to != "number" || typeof lr.gapFrom != "number" || typeof lr.gapTo != "number" || typeof lr.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(lr.from, lr.to, lr.gapFrom, lr.gapTo, Slice.fromJSON(ar, lr.slice), lr.insert, !!lr.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(cr, ar, lr) {
  let ur = cr.resolve(ar), dr = lr - ar, fr = ur.depth;
  for (; dr > 0 && fr > 0 && ur.indexAfter(fr) == ur.node(fr).childCount; )
    fr--, dr--;
  if (dr > 0) {
    let gr = ur.node(fr).maybeChild(ur.indexAfter(fr));
    for (; dr > 0; ) {
      if (!gr || gr.isLeaf)
        return !0;
      gr = gr.firstChild, dr--;
    }
  }
  return !1;
}
function addMark(cr, ar, lr, ur) {
  let dr = [], fr = [], gr, mr;
  cr.doc.nodesBetween(ar, lr, (vr, yr, _r) => {
    if (!vr.isInline)
      return;
    let kr = vr.marks;
    if (!ur.isInSet(kr) && _r.type.allowsMarkType(ur.type)) {
      let xr = Math.max(yr, ar), Ar = Math.min(yr + vr.nodeSize, lr), Er = ur.addToSet(kr);
      for (let Cr = 0; Cr < kr.length; Cr++)
        kr[Cr].isInSet(Er) || (gr && gr.to == xr && gr.mark.eq(kr[Cr]) ? gr.to = Ar : dr.push(gr = new RemoveMarkStep(xr, Ar, kr[Cr])));
      mr && mr.to == xr ? mr.to = Ar : fr.push(mr = new AddMarkStep(xr, Ar, ur));
    }
  }), dr.forEach((vr) => cr.step(vr)), fr.forEach((vr) => cr.step(vr));
}
function removeMark(cr, ar, lr, ur) {
  let dr = [], fr = 0;
  cr.doc.nodesBetween(ar, lr, (gr, mr) => {
    if (!gr.isInline)
      return;
    fr++;
    let vr = null;
    if (ur instanceof MarkType) {
      let yr = gr.marks, _r;
      for (; _r = ur.isInSet(yr); )
        (vr || (vr = [])).push(_r), yr = _r.removeFromSet(yr);
    } else
      ur ? ur.isInSet(gr.marks) && (vr = [ur]) : vr = gr.marks;
    if (vr && vr.length) {
      let yr = Math.min(mr + gr.nodeSize, lr);
      for (let _r = 0; _r < vr.length; _r++) {
        let kr = vr[_r], xr;
        for (let Ar = 0; Ar < dr.length; Ar++) {
          let Er = dr[Ar];
          Er.step == fr - 1 && kr.eq(dr[Ar].style) && (xr = Er);
        }
        xr ? (xr.to = yr, xr.step = fr) : dr.push({ style: kr, from: Math.max(mr, ar), to: yr, step: fr });
      }
    }
  }), dr.forEach((gr) => cr.step(new RemoveMarkStep(gr.from, gr.to, gr.style)));
}
function clearIncompatible(cr, ar, lr, ur = lr.contentMatch) {
  let dr = cr.doc.nodeAt(ar), fr = [], gr = ar + 1;
  for (let mr = 0; mr < dr.childCount; mr++) {
    let vr = dr.child(mr), yr = gr + vr.nodeSize, _r = ur.matchType(vr.type);
    if (!_r)
      fr.push(new ReplaceStep(gr, yr, Slice.empty));
    else {
      ur = _r;
      for (let kr = 0; kr < vr.marks.length; kr++)
        lr.allowsMarkType(vr.marks[kr].type) || cr.step(new RemoveMarkStep(gr, yr, vr.marks[kr]));
      if (vr.isText && !lr.spec.code) {
        let kr, xr = /\r?\n|\r/g, Ar;
        for (; kr = xr.exec(vr.text); )
          Ar || (Ar = new Slice(Fragment.from(lr.schema.text(" ", lr.allowedMarks(vr.marks))), 0, 0)), fr.push(new ReplaceStep(gr + kr.index, gr + kr.index + kr[0].length, Ar));
      }
    }
    gr = yr;
  }
  if (!ur.validEnd) {
    let mr = ur.fillBefore(Fragment.empty, !0);
    cr.replace(gr, gr, new Slice(mr, 0, 0));
  }
  for (let mr = fr.length - 1; mr >= 0; mr--)
    cr.step(fr[mr]);
}
function canCut(cr, ar, lr) {
  return (ar == 0 || cr.canReplace(ar, cr.childCount)) && (lr == cr.childCount || cr.canReplace(0, lr));
}
function liftTarget(cr) {
  let lr = cr.parent.content.cutByIndex(cr.startIndex, cr.endIndex);
  for (let ur = cr.depth; ; --ur) {
    let dr = cr.$from.node(ur), fr = cr.$from.index(ur), gr = cr.$to.indexAfter(ur);
    if (ur < cr.depth && dr.canReplace(fr, gr, lr))
      return ur;
    if (ur == 0 || dr.type.spec.isolating || !canCut(dr, fr, gr))
      break;
  }
  return null;
}
function lift(cr, ar, lr) {
  let { $from: ur, $to: dr, depth: fr } = ar, gr = ur.before(fr + 1), mr = dr.after(fr + 1), vr = gr, yr = mr, _r = Fragment.empty, kr = 0;
  for (let Er = fr, Cr = !1; Er > lr; Er--)
    Cr || ur.index(Er) > 0 ? (Cr = !0, _r = Fragment.from(ur.node(Er).copy(_r)), kr++) : vr--;
  let xr = Fragment.empty, Ar = 0;
  for (let Er = fr, Cr = !1; Er > lr; Er--)
    Cr || dr.after(Er + 1) < dr.end(Er) ? (Cr = !0, xr = Fragment.from(dr.node(Er).copy(xr)), Ar++) : yr++;
  cr.step(new ReplaceAroundStep(vr, yr, gr, mr, new Slice(_r.append(xr), kr, Ar), _r.size - kr, !0));
}
function findWrapping(cr, ar, lr = null, ur = cr) {
  let dr = findWrappingOutside$1(cr, ar), fr = dr && findWrappingInside$1(ur, ar);
  return fr ? dr.map(withAttrs).concat({ type: ar, attrs: lr }).concat(fr.map(withAttrs)) : null;
}
function withAttrs(cr) {
  return { type: cr, attrs: null };
}
function findWrappingOutside$1(cr, ar) {
  let { parent: lr, startIndex: ur, endIndex: dr } = cr, fr = lr.contentMatchAt(ur).findWrapping(ar);
  if (!fr)
    return null;
  let gr = fr.length ? fr[0] : ar;
  return lr.canReplaceWith(ur, dr, gr) ? fr : null;
}
function findWrappingInside$1(cr, ar) {
  let { parent: lr, startIndex: ur, endIndex: dr } = cr, fr = lr.child(ur), gr = ar.contentMatch.findWrapping(fr.type);
  if (!gr)
    return null;
  let vr = (gr.length ? gr[gr.length - 1] : ar).contentMatch;
  for (let yr = ur; vr && yr < dr; yr++)
    vr = vr.matchType(lr.child(yr).type);
  return !vr || !vr.validEnd ? null : gr;
}
function wrap(cr, ar, lr) {
  let ur = Fragment.empty;
  for (let gr = lr.length - 1; gr >= 0; gr--) {
    if (ur.size) {
      let mr = lr[gr].type.contentMatch.matchFragment(ur);
      if (!mr || !mr.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    ur = Fragment.from(lr[gr].type.create(lr[gr].attrs, ur));
  }
  let dr = ar.start, fr = ar.end;
  cr.step(new ReplaceAroundStep(dr, fr, dr, fr, new Slice(ur, 0, 0), lr.length, !0));
}
function setBlockType$1(cr, ar, lr, ur, dr) {
  if (!ur.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let fr = cr.steps.length;
  cr.doc.nodesBetween(ar, lr, (gr, mr) => {
    if (gr.isTextblock && !gr.hasMarkup(ur, dr) && canChangeType(cr.doc, cr.mapping.slice(fr).map(mr), ur)) {
      cr.clearIncompatible(cr.mapping.slice(fr).map(mr, 1), ur);
      let vr = cr.mapping.slice(fr), yr = vr.map(mr, 1), _r = vr.map(mr + gr.nodeSize, 1);
      return cr.step(new ReplaceAroundStep(yr, _r, yr + 1, _r - 1, new Slice(Fragment.from(ur.create(dr, null, gr.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function canChangeType(cr, ar, lr) {
  let ur = cr.resolve(ar), dr = ur.index();
  return ur.parent.canReplaceWith(dr, dr + 1, lr);
}
function setNodeMarkup(cr, ar, lr, ur, dr) {
  let fr = cr.doc.nodeAt(ar);
  if (!fr)
    throw new RangeError("No node at given position");
  lr || (lr = fr.type);
  let gr = lr.create(ur, null, dr || fr.marks);
  if (fr.isLeaf)
    return cr.replaceWith(ar, ar + fr.nodeSize, gr);
  if (!lr.validContent(fr.content))
    throw new RangeError("Invalid content for node type " + lr.name);
  cr.step(new ReplaceAroundStep(ar, ar + fr.nodeSize, ar + 1, ar + fr.nodeSize - 1, new Slice(Fragment.from(gr), 0, 0), 1, !0));
}
function canSplit(cr, ar, lr = 1, ur) {
  let dr = cr.resolve(ar), fr = dr.depth - lr, gr = ur && ur[ur.length - 1] || dr.parent;
  if (fr < 0 || dr.parent.type.spec.isolating || !dr.parent.canReplace(dr.index(), dr.parent.childCount) || !gr.type.validContent(dr.parent.content.cutByIndex(dr.index(), dr.parent.childCount)))
    return !1;
  for (let yr = dr.depth - 1, _r = lr - 2; yr > fr; yr--, _r--) {
    let kr = dr.node(yr), xr = dr.index(yr);
    if (kr.type.spec.isolating)
      return !1;
    let Ar = kr.content.cutByIndex(xr, kr.childCount), Er = ur && ur[_r + 1];
    Er && (Ar = Ar.replaceChild(0, Er.type.create(Er.attrs)));
    let Cr = ur && ur[_r] || kr;
    if (!kr.canReplace(xr + 1, kr.childCount) || !Cr.type.validContent(Ar))
      return !1;
  }
  let mr = dr.indexAfter(fr), vr = ur && ur[0];
  return dr.node(fr).canReplaceWith(mr, mr, vr ? vr.type : dr.node(fr + 1).type);
}
function split(cr, ar, lr = 1, ur) {
  let dr = cr.doc.resolve(ar), fr = Fragment.empty, gr = Fragment.empty;
  for (let mr = dr.depth, vr = dr.depth - lr, yr = lr - 1; mr > vr; mr--, yr--) {
    fr = Fragment.from(dr.node(mr).copy(fr));
    let _r = ur && ur[yr];
    gr = Fragment.from(_r ? _r.type.create(_r.attrs, gr) : dr.node(mr).copy(gr));
  }
  cr.step(new ReplaceStep(ar, ar, new Slice(fr.append(gr), lr, lr), !0));
}
function canJoin(cr, ar) {
  let lr = cr.resolve(ar), ur = lr.index();
  return joinable(lr.nodeBefore, lr.nodeAfter) && lr.parent.canReplace(ur, ur + 1);
}
function joinable(cr, ar) {
  return !!(cr && ar && !cr.isLeaf && cr.canAppend(ar));
}
function join(cr, ar, lr) {
  let ur = new ReplaceStep(ar - lr, ar + lr, Slice.empty, !0);
  cr.step(ur);
}
function insertPoint(cr, ar, lr) {
  let ur = cr.resolve(ar);
  if (ur.parent.canReplaceWith(ur.index(), ur.index(), lr))
    return ar;
  if (ur.parentOffset == 0)
    for (let dr = ur.depth - 1; dr >= 0; dr--) {
      let fr = ur.index(dr);
      if (ur.node(dr).canReplaceWith(fr, fr, lr))
        return ur.before(dr + 1);
      if (fr > 0)
        return null;
    }
  if (ur.parentOffset == ur.parent.content.size)
    for (let dr = ur.depth - 1; dr >= 0; dr--) {
      let fr = ur.indexAfter(dr);
      if (ur.node(dr).canReplaceWith(fr, fr, lr))
        return ur.after(dr + 1);
      if (fr < ur.node(dr).childCount)
        return null;
    }
  return null;
}
function dropPoint(cr, ar, lr) {
  let ur = cr.resolve(ar);
  if (!lr.content.size)
    return ar;
  let dr = lr.content;
  for (let fr = 0; fr < lr.openStart; fr++)
    dr = dr.firstChild.content;
  for (let fr = 1; fr <= (lr.openStart == 0 && lr.size ? 2 : 1); fr++)
    for (let gr = ur.depth; gr >= 0; gr--) {
      let mr = gr == ur.depth ? 0 : ur.pos <= (ur.start(gr + 1) + ur.end(gr + 1)) / 2 ? -1 : 1, vr = ur.index(gr) + (mr > 0 ? 1 : 0), yr = ur.node(gr), _r = !1;
      if (fr == 1)
        _r = yr.canReplace(vr, vr, dr);
      else {
        let kr = yr.contentMatchAt(vr).findWrapping(dr.firstChild.type);
        _r = kr && yr.canReplaceWith(vr, vr, kr[0]);
      }
      if (_r)
        return mr == 0 ? ur.pos : mr < 0 ? ur.before(gr + 1) : ur.after(gr + 1);
    }
  return null;
}
function replaceStep(cr, ar, lr = ar, ur = Slice.empty) {
  if (ar == lr && !ur.size)
    return null;
  let dr = cr.resolve(ar), fr = cr.resolve(lr);
  return fitsTrivially(dr, fr, ur) ? new ReplaceStep(ar, lr, ur) : new Fitter(dr, fr, ur).fit();
}
function fitsTrivially(cr, ar, lr) {
  return !lr.openStart && !lr.openEnd && cr.start() == ar.start() && cr.parent.canReplace(cr.index(), ar.index(), lr.content);
}
class Fitter {
  constructor(ar, lr, ur) {
    this.$from = ar, this.$to = lr, this.unplaced = ur, this.frontier = [], this.placed = Fragment.empty;
    for (let dr = 0; dr <= ar.depth; dr++) {
      let fr = ar.node(dr);
      this.frontier.push({
        type: fr.type,
        match: fr.contentMatchAt(ar.indexAfter(dr))
      });
    }
    for (let dr = ar.depth; dr > 0; dr--)
      this.placed = Fragment.from(ar.node(dr).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let yr = this.findFittable();
      yr ? this.placeNodes(yr) : this.openMore() || this.dropNode();
    }
    let ar = this.mustMoveInline(), lr = this.placed.size - this.depth - this.$from.depth, ur = this.$from, dr = this.close(ar < 0 ? this.$to : ur.doc.resolve(ar));
    if (!dr)
      return null;
    let fr = this.placed, gr = ur.depth, mr = dr.depth;
    for (; gr && mr && fr.childCount == 1; )
      fr = fr.firstChild.content, gr--, mr--;
    let vr = new Slice(fr, gr, mr);
    return ar > -1 ? new ReplaceAroundStep(ur.pos, ar, this.$to.pos, this.$to.end(), vr, lr) : vr.size || ur.pos != this.$to.pos ? new ReplaceStep(ur.pos, dr.pos, vr) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let ar = this.unplaced.openStart;
    for (let lr = this.unplaced.content, ur = 0, dr = this.unplaced.openEnd; ur < ar; ur++) {
      let fr = lr.firstChild;
      if (lr.childCount > 1 && (dr = 0), fr.type.spec.isolating && dr <= ur) {
        ar = ur;
        break;
      }
      lr = fr.content;
    }
    for (let lr = 1; lr <= 2; lr++)
      for (let ur = lr == 1 ? ar : this.unplaced.openStart; ur >= 0; ur--) {
        let dr, fr = null;
        ur ? (fr = contentAt(this.unplaced.content, ur - 1).firstChild, dr = fr.content) : dr = this.unplaced.content;
        let gr = dr.firstChild;
        for (let mr = this.depth; mr >= 0; mr--) {
          let { type: vr, match: yr } = this.frontier[mr], _r, kr = null;
          if (lr == 1 && (gr ? yr.matchType(gr.type) || (kr = yr.fillBefore(Fragment.from(gr), !1)) : fr && vr.compatibleContent(fr.type)))
            return { sliceDepth: ur, frontierDepth: mr, parent: fr, inject: kr };
          if (lr == 2 && gr && (_r = yr.findWrapping(gr.type)))
            return { sliceDepth: ur, frontierDepth: mr, parent: fr, wrap: _r };
          if (fr && yr.matchType(fr.type))
            break;
        }
      }
  }
  openMore() {
    let { content: ar, openStart: lr, openEnd: ur } = this.unplaced, dr = contentAt(ar, lr);
    return !dr.childCount || dr.firstChild.isLeaf ? !1 : (this.unplaced = new Slice(ar, lr + 1, Math.max(ur, dr.size + lr >= ar.size - ur ? lr + 1 : 0)), !0);
  }
  dropNode() {
    let { content: ar, openStart: lr, openEnd: ur } = this.unplaced, dr = contentAt(ar, lr);
    if (dr.childCount <= 1 && lr > 0) {
      let fr = ar.size - lr <= lr + dr.size;
      this.unplaced = new Slice(dropFromFragment(ar, lr - 1, 1), lr - 1, fr ? lr - 1 : ur);
    } else
      this.unplaced = new Slice(dropFromFragment(ar, lr, 1), lr, ur);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: ar, frontierDepth: lr, parent: ur, inject: dr, wrap: fr }) {
    for (; this.depth > lr; )
      this.closeFrontierNode();
    if (fr)
      for (let Cr = 0; Cr < fr.length; Cr++)
        this.openFrontierNode(fr[Cr]);
    let gr = this.unplaced, mr = ur ? ur.content : gr.content, vr = gr.openStart - ar, yr = 0, _r = [], { match: kr, type: xr } = this.frontier[lr];
    if (dr) {
      for (let Cr = 0; Cr < dr.childCount; Cr++)
        _r.push(dr.child(Cr));
      kr = kr.matchFragment(dr);
    }
    let Ar = mr.size + ar - (gr.content.size - gr.openEnd);
    for (; yr < mr.childCount; ) {
      let Cr = mr.child(yr), Tr = kr.matchType(Cr.type);
      if (!Tr)
        break;
      yr++, (yr > 1 || vr == 0 || Cr.content.size) && (kr = Tr, _r.push(closeNodeStart(Cr.mark(xr.allowedMarks(Cr.marks)), yr == 1 ? vr : 0, yr == mr.childCount ? Ar : -1)));
    }
    let Er = yr == mr.childCount;
    Er || (Ar = -1), this.placed = addToFragment(this.placed, lr, Fragment.from(_r)), this.frontier[lr].match = kr, Er && Ar < 0 && ur && ur.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let Cr = 0, Tr = mr; Cr < Ar; Cr++) {
      let Sr = Tr.lastChild;
      this.frontier.push({ type: Sr.type, match: Sr.contentMatchAt(Sr.childCount) }), Tr = Sr.content;
    }
    this.unplaced = Er ? ar == 0 ? Slice.empty : new Slice(dropFromFragment(gr.content, ar - 1, 1), ar - 1, Ar < 0 ? gr.openEnd : ar - 1) : new Slice(dropFromFragment(gr.content, ar, yr), gr.openStart, gr.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let ar = this.frontier[this.depth], lr;
    if (!ar.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, ar.type, ar.match, !1) || this.$to.depth == this.depth && (lr = this.findCloseLevel(this.$to)) && lr.depth == this.depth)
      return -1;
    let { depth: ur } = this.$to, dr = this.$to.after(ur);
    for (; ur > 1 && dr == this.$to.end(--ur); )
      ++dr;
    return dr;
  }
  findCloseLevel(ar) {
    e:
      for (let lr = Math.min(this.depth, ar.depth); lr >= 0; lr--) {
        let { match: ur, type: dr } = this.frontier[lr], fr = lr < ar.depth && ar.end(lr + 1) == ar.pos + (ar.depth - (lr + 1)), gr = contentAfterFits(ar, lr, dr, ur, fr);
        if (gr) {
          for (let mr = lr - 1; mr >= 0; mr--) {
            let { match: vr, type: yr } = this.frontier[mr], _r = contentAfterFits(ar, mr, yr, vr, !0);
            if (!_r || _r.childCount)
              continue e;
          }
          return { depth: lr, fit: gr, move: fr ? ar.doc.resolve(ar.after(lr + 1)) : ar };
        }
      }
  }
  close(ar) {
    let lr = this.findCloseLevel(ar);
    if (!lr)
      return null;
    for (; this.depth > lr.depth; )
      this.closeFrontierNode();
    lr.fit.childCount && (this.placed = addToFragment(this.placed, lr.depth, lr.fit)), ar = lr.move;
    for (let ur = lr.depth + 1; ur <= ar.depth; ur++) {
      let dr = ar.node(ur), fr = dr.type.contentMatch.fillBefore(dr.content, !0, ar.index(ur));
      this.openFrontierNode(dr.type, dr.attrs, fr);
    }
    return ar;
  }
  openFrontierNode(ar, lr = null, ur) {
    let dr = this.frontier[this.depth];
    dr.match = dr.match.matchType(ar), this.placed = addToFragment(this.placed, this.depth, Fragment.from(ar.create(lr, ur))), this.frontier.push({ type: ar, match: ar.contentMatch });
  }
  closeFrontierNode() {
    let lr = this.frontier.pop().match.fillBefore(Fragment.empty, !0);
    lr.childCount && (this.placed = addToFragment(this.placed, this.frontier.length, lr));
  }
}
function dropFromFragment(cr, ar, lr) {
  return ar == 0 ? cr.cutByIndex(lr, cr.childCount) : cr.replaceChild(0, cr.firstChild.copy(dropFromFragment(cr.firstChild.content, ar - 1, lr)));
}
function addToFragment(cr, ar, lr) {
  return ar == 0 ? cr.append(lr) : cr.replaceChild(cr.childCount - 1, cr.lastChild.copy(addToFragment(cr.lastChild.content, ar - 1, lr)));
}
function contentAt(cr, ar) {
  for (let lr = 0; lr < ar; lr++)
    cr = cr.firstChild.content;
  return cr;
}
function closeNodeStart(cr, ar, lr) {
  if (ar <= 0)
    return cr;
  let ur = cr.content;
  return ar > 1 && (ur = ur.replaceChild(0, closeNodeStart(ur.firstChild, ar - 1, ur.childCount == 1 ? lr - 1 : 0))), ar > 0 && (ur = cr.type.contentMatch.fillBefore(ur).append(ur), lr <= 0 && (ur = ur.append(cr.type.contentMatch.matchFragment(ur).fillBefore(Fragment.empty, !0)))), cr.copy(ur);
}
function contentAfterFits(cr, ar, lr, ur, dr) {
  let fr = cr.node(ar), gr = dr ? cr.indexAfter(ar) : cr.index(ar);
  if (gr == fr.childCount && !lr.compatibleContent(fr.type))
    return null;
  let mr = ur.fillBefore(fr.content, !0, gr);
  return mr && !invalidMarks(lr, fr.content, gr) ? mr : null;
}
function invalidMarks(cr, ar, lr) {
  for (let ur = lr; ur < ar.childCount; ur++)
    if (!cr.allowsMarks(ar.child(ur).marks))
      return !0;
  return !1;
}
function definesContent(cr) {
  return cr.spec.defining || cr.spec.definingForContent;
}
function replaceRange(cr, ar, lr, ur) {
  if (!ur.size)
    return cr.deleteRange(ar, lr);
  let dr = cr.doc.resolve(ar), fr = cr.doc.resolve(lr);
  if (fitsTrivially(dr, fr, ur))
    return cr.step(new ReplaceStep(ar, lr, ur));
  let gr = coveredDepths(dr, cr.doc.resolve(lr));
  gr[gr.length - 1] == 0 && gr.pop();
  let mr = -(dr.depth + 1);
  gr.unshift(mr);
  for (let xr = dr.depth, Ar = dr.pos - 1; xr > 0; xr--, Ar--) {
    let Er = dr.node(xr).type.spec;
    if (Er.defining || Er.definingAsContext || Er.isolating)
      break;
    gr.indexOf(xr) > -1 ? mr = xr : dr.before(xr) == Ar && gr.splice(1, 0, -xr);
  }
  let vr = gr.indexOf(mr), yr = [], _r = ur.openStart;
  for (let xr = ur.content, Ar = 0; ; Ar++) {
    let Er = xr.firstChild;
    if (yr.push(Er), Ar == ur.openStart)
      break;
    xr = Er.content;
  }
  for (let xr = _r - 1; xr >= 0; xr--) {
    let Ar = yr[xr], Er = definesContent(Ar.type);
    if (Er && !Ar.sameMarkup(dr.node(Math.abs(mr) - 1)))
      _r = xr;
    else if (Er || !Ar.type.isTextblock)
      break;
  }
  for (let xr = ur.openStart; xr >= 0; xr--) {
    let Ar = (xr + _r + 1) % (ur.openStart + 1), Er = yr[Ar];
    if (Er)
      for (let Cr = 0; Cr < gr.length; Cr++) {
        let Tr = gr[(Cr + vr) % gr.length], Sr = !0;
        Tr < 0 && (Sr = !1, Tr = -Tr);
        let Lr = dr.node(Tr - 1), Ir = dr.index(Tr - 1);
        if (Lr.canReplaceWith(Ir, Ir, Er.type, Er.marks))
          return cr.replace(dr.before(Tr), Sr ? fr.after(Tr) : lr, new Slice(closeFragment(ur.content, 0, ur.openStart, Ar), Ar, ur.openEnd));
      }
  }
  let kr = cr.steps.length;
  for (let xr = gr.length - 1; xr >= 0 && (cr.replace(ar, lr, ur), !(cr.steps.length > kr)); xr--) {
    let Ar = gr[xr];
    Ar < 0 || (ar = dr.before(Ar), lr = fr.after(Ar));
  }
}
function closeFragment(cr, ar, lr, ur, dr) {
  if (ar < lr) {
    let fr = cr.firstChild;
    cr = cr.replaceChild(0, fr.copy(closeFragment(fr.content, ar + 1, lr, ur, fr)));
  }
  if (ar > ur) {
    let fr = dr.contentMatchAt(0), gr = fr.fillBefore(cr).append(cr);
    cr = gr.append(fr.matchFragment(gr).fillBefore(Fragment.empty, !0));
  }
  return cr;
}
function replaceRangeWith(cr, ar, lr, ur) {
  if (!ur.isInline && ar == lr && cr.doc.resolve(ar).parent.content.size) {
    let dr = insertPoint(cr.doc, ar, ur.type);
    dr != null && (ar = lr = dr);
  }
  cr.replaceRange(ar, lr, new Slice(Fragment.from(ur), 0, 0));
}
function deleteRange(cr, ar, lr) {
  let ur = cr.doc.resolve(ar), dr = cr.doc.resolve(lr), fr = coveredDepths(ur, dr);
  for (let gr = 0; gr < fr.length; gr++) {
    let mr = fr[gr], vr = gr == fr.length - 1;
    if (vr && mr == 0 || ur.node(mr).type.contentMatch.validEnd)
      return cr.delete(ur.start(mr), dr.end(mr));
    if (mr > 0 && (vr || ur.node(mr - 1).canReplace(ur.index(mr - 1), dr.indexAfter(mr - 1))))
      return cr.delete(ur.before(mr), dr.after(mr));
  }
  for (let gr = 1; gr <= ur.depth && gr <= dr.depth; gr++)
    if (ar - ur.start(gr) == ur.depth - gr && lr > ur.end(gr) && dr.end(gr) - lr != dr.depth - gr)
      return cr.delete(ur.before(gr), lr);
  cr.delete(ar, lr);
}
function coveredDepths(cr, ar) {
  let lr = [], ur = Math.min(cr.depth, ar.depth);
  for (let dr = ur; dr >= 0; dr--) {
    let fr = cr.start(dr);
    if (fr < cr.pos - (cr.depth - dr) || ar.end(dr) > ar.pos + (ar.depth - dr) || cr.node(dr).type.spec.isolating || ar.node(dr).type.spec.isolating)
      break;
    (fr == ar.start(dr) || dr == cr.depth && dr == ar.depth && cr.parent.inlineContent && ar.parent.inlineContent && dr && ar.start(dr - 1) == fr - 1) && lr.push(dr);
  }
  return lr;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, lr, ur) {
    super(), this.pos = ar, this.attr = lr, this.value = ur;
  }
  apply(ar) {
    let lr = ar.nodeAt(this.pos);
    if (!lr)
      return StepResult.fail("No node at attribute step's position");
    let ur = /* @__PURE__ */ Object.create(null);
    for (let fr in lr.attrs)
      ur[fr] = lr.attrs[fr];
    ur[this.attr] = this.value;
    let dr = lr.type.create(ur, null, lr.marks);
    return StepResult.fromReplace(ar, this.pos, this.pos + 1, new Slice(Fragment.from(dr), 0, lr.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new AttrStep(this.pos, this.attr, ar.nodeAt(this.pos).attrs[this.attr]);
  }
  map(ar) {
    let lr = ar.mapResult(this.pos, 1);
    return lr.deletedAfter ? null : new AttrStep(lr.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(ar, lr) {
    if (typeof lr.pos != "number" || typeof lr.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(lr.pos, lr.attr, lr.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(ar, lr) {
    super(), this.attr = ar, this.value = lr;
  }
  apply(ar) {
    let lr = /* @__PURE__ */ Object.create(null);
    for (let dr in ar.attrs)
      lr[dr] = ar.attrs[dr];
    lr[this.attr] = this.value;
    let ur = ar.type.create(lr, ar.content, ar.marks);
    return StepResult.ok(ur);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(ar) {
    return new DocAttrStep(this.attr, ar.attrs[this.attr]);
  }
  map(ar) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(ar, lr) {
    if (typeof lr.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(lr.attr, lr.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function cr(ar) {
  let lr = Error.call(this, ar);
  return lr.__proto__ = cr.prototype, lr;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(ar) {
    this.doc = ar, this.steps = [], this.docs = [], this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(ar) {
    let lr = this.maybeStep(ar);
    if (lr.failed)
      throw new TransformError(lr.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(ar) {
    let lr = ar.apply(this.doc);
    return lr.failed || this.addStep(ar, lr.doc), lr;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(ar, lr) {
    this.docs.push(this.doc), this.steps.push(ar), this.mapping.appendMap(ar.getMap()), this.doc = lr;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(ar, lr = ar, ur = Slice.empty) {
    let dr = replaceStep(this.doc, ar, lr, ur);
    return dr && this.step(dr), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(ar, lr, ur) {
    return this.replace(ar, lr, new Slice(Fragment.from(ur), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(ar, lr) {
    return this.replace(ar, lr, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(ar, lr) {
    return this.replaceWith(ar, ar, lr);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(ar, lr, ur) {
    return replaceRange(this, ar, lr, ur), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(ar, lr, ur) {
    return replaceRangeWith(this, ar, lr, ur), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(ar, lr) {
    return deleteRange(this, ar, lr), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(ar, lr) {
    return lift(this, ar, lr), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(ar, lr = 1) {
    return join(this, ar, lr), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(ar, lr) {
    return wrap(this, ar, lr), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(ar, lr = ar, ur, dr = null) {
    return setBlockType$1(this, ar, lr, ur, dr), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(ar, lr, ur = null, dr) {
    return setNodeMarkup(this, ar, lr, ur, dr), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(ar, lr, ur) {
    return this.step(new AttrStep(ar, lr, ur)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(ar, lr) {
    return this.step(new DocAttrStep(ar, lr)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(ar, lr) {
    return this.step(new AddNodeMarkStep(ar, lr)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(ar, lr) {
    if (!(lr instanceof Mark$1)) {
      let ur = this.doc.nodeAt(ar);
      if (!ur)
        throw new RangeError("No node at position " + ar);
      if (lr = lr.isInSet(ur.marks), !lr)
        return this;
    }
    return this.step(new RemoveNodeMarkStep(ar, lr)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(ar, lr = 1, ur) {
    return split(this, ar, lr, ur), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(ar, lr, ur) {
    return addMark(this, ar, lr, ur), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(ar, lr, ur) {
    return removeMark(this, ar, lr, ur), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(ar, lr, ur) {
    return clearIncompatible(this, ar, lr, ur), this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(ar, lr, ur) {
    this.$anchor = ar, this.$head = lr, this.ranges = ur || [new SelectionRange(ar.min(lr), ar.max(lr))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ar = this.ranges;
    for (let lr = 0; lr < ar.length; lr++)
      if (ar[lr].$from.pos != ar[lr].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(ar, lr = Slice.empty) {
    let ur = lr.content.lastChild, dr = null;
    for (let mr = 0; mr < lr.openEnd; mr++)
      dr = ur, ur = ur.lastChild;
    let fr = ar.steps.length, gr = this.ranges;
    for (let mr = 0; mr < gr.length; mr++) {
      let { $from: vr, $to: yr } = gr[mr], _r = ar.mapping.slice(fr);
      ar.replaceRange(_r.map(vr.pos), _r.map(yr.pos), mr ? Slice.empty : lr), mr == 0 && selectionToInsertionEnd(ar, fr, (ur ? ur.isInline : dr && dr.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(ar, lr) {
    let ur = ar.steps.length, dr = this.ranges;
    for (let fr = 0; fr < dr.length; fr++) {
      let { $from: gr, $to: mr } = dr[fr], vr = ar.mapping.slice(ur), yr = vr.map(gr.pos), _r = vr.map(mr.pos);
      fr ? ar.deleteRange(yr, _r) : (ar.replaceRangeWith(yr, _r, lr), selectionToInsertionEnd(ar, ur, lr.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(ar, lr, ur = !1) {
    let dr = ar.parent.inlineContent ? new TextSelection(ar) : findSelectionIn(ar.node(0), ar.parent, ar.pos, ar.index(), lr, ur);
    if (dr)
      return dr;
    for (let fr = ar.depth - 1; fr >= 0; fr--) {
      let gr = lr < 0 ? findSelectionIn(ar.node(0), ar.node(fr), ar.before(fr + 1), ar.index(fr), lr, ur) : findSelectionIn(ar.node(0), ar.node(fr), ar.after(fr + 1), ar.index(fr) + 1, lr, ur);
      if (gr)
        return gr;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(ar, lr = 1) {
    return this.findFrom(ar, lr) || this.findFrom(ar, -lr) || new AllSelection(ar.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(ar) {
    return findSelectionIn(ar, ar, 0, 0, 1) || new AllSelection(ar);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(ar) {
    return findSelectionIn(ar, ar, ar.content.size, ar.childCount, -1) || new AllSelection(ar);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(ar, lr) {
    if (!lr || !lr.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let ur = classesById[lr.type];
    if (!ur)
      throw new RangeError(`No selection type ${lr.type} defined`);
    return ur.fromJSON(ar, lr);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(ar, lr) {
    if (ar in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + ar);
    return classesById[ar] = lr, lr.prototype.jsonID = ar, lr;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = !0;
class SelectionRange {
  /**
  Create a range.
  */
  constructor(ar, lr) {
    this.$from = ar, this.$to = lr;
  }
}
let warnedAboutTextSelection = !1;
function checkTextSelection(cr) {
  !warnedAboutTextSelection && !cr.parent.inlineContent && (warnedAboutTextSelection = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + cr.parent.type.name + ")"));
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor(ar, lr = ar) {
    checkTextSelection(ar), checkTextSelection(lr), super(ar, lr);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(ar, lr) {
    let ur = ar.resolve(lr.map(this.head));
    if (!ur.parent.inlineContent)
      return Selection.near(ur);
    let dr = ar.resolve(lr.map(this.anchor));
    return new TextSelection(dr.parent.inlineContent ? dr : ur, ur);
  }
  replace(ar, lr = Slice.empty) {
    if (super.replace(ar, lr), lr == Slice.empty) {
      let ur = this.$from.marksAcross(this.$to);
      ur && ar.ensureMarks(ur);
    }
  }
  eq(ar) {
    return ar instanceof TextSelection && ar.anchor == this.anchor && ar.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.anchor != "number" || typeof lr.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(ar.resolve(lr.anchor), ar.resolve(lr.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(ar, lr, ur = lr) {
    let dr = ar.resolve(lr);
    return new this(dr, ur == lr ? dr : ar.resolve(ur));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(ar, lr, ur) {
    let dr = ar.pos - lr.pos;
    if ((!ur || dr) && (ur = dr >= 0 ? 1 : -1), !lr.parent.inlineContent) {
      let fr = Selection.findFrom(lr, ur, !0) || Selection.findFrom(lr, -ur, !0);
      if (fr)
        lr = fr.$head;
      else
        return Selection.near(lr, ur);
    }
    return ar.parent.inlineContent || (dr == 0 ? ar = lr : (ar = (Selection.findFrom(ar, -ur, !0) || Selection.findFrom(ar, ur, !0)).$anchor, ar.pos < lr.pos != dr < 0 && (ar = lr))), new TextSelection(ar, lr);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(ar, lr) {
    this.anchor = ar, this.head = lr;
  }
  map(ar) {
    return new TextBookmark(ar.map(this.anchor), ar.map(this.head));
  }
  resolve(ar) {
    return TextSelection.between(ar.resolve(this.anchor), ar.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(ar) {
    let lr = ar.nodeAfter, ur = ar.node(0).resolve(ar.pos + lr.nodeSize);
    super(ar, ur), this.node = lr;
  }
  map(ar, lr) {
    let { deleted: ur, pos: dr } = lr.mapResult(this.anchor), fr = ar.resolve(dr);
    return ur ? Selection.near(fr) : new NodeSelection(fr);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(ar) {
    return ar instanceof NodeSelection && ar.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(ar, lr) {
    if (typeof lr.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(ar.resolve(lr.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(ar, lr) {
    return new NodeSelection(ar.resolve(lr));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(ar) {
    return !ar.isText && ar.type.spec.selectable !== !1;
  }
}
NodeSelection.prototype.visible = !1;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(ar) {
    this.anchor = ar;
  }
  map(ar) {
    let { deleted: lr, pos: ur } = ar.mapResult(this.anchor);
    return lr ? new TextBookmark(ur, ur) : new NodeBookmark(ur);
  }
  resolve(ar) {
    let lr = ar.resolve(this.anchor), ur = lr.nodeAfter;
    return ur && NodeSelection.isSelectable(ur) ? new NodeSelection(lr) : Selection.near(lr);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(ar) {
    super(ar.resolve(0), ar.resolve(ar.content.size));
  }
  replace(ar, lr = Slice.empty) {
    if (lr == Slice.empty) {
      ar.delete(0, ar.doc.content.size);
      let ur = Selection.atStart(ar.doc);
      ur.eq(ar.selection) || ar.setSelection(ur);
    } else
      super.replace(ar, lr);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(ar) {
    return new AllSelection(ar);
  }
  map(ar) {
    return new AllSelection(ar);
  }
  eq(ar) {
    return ar instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(cr) {
    return new AllSelection(cr);
  }
};
function findSelectionIn(cr, ar, lr, ur, dr, fr = !1) {
  if (ar.inlineContent)
    return TextSelection.create(cr, lr);
  for (let gr = ur - (dr > 0 ? 0 : 1); dr > 0 ? gr < ar.childCount : gr >= 0; gr += dr) {
    let mr = ar.child(gr);
    if (mr.isAtom) {
      if (!fr && NodeSelection.isSelectable(mr))
        return NodeSelection.create(cr, lr - (dr < 0 ? mr.nodeSize : 0));
    } else {
      let vr = findSelectionIn(cr, mr, lr + dr, dr < 0 ? mr.childCount : 0, dr, fr);
      if (vr)
        return vr;
    }
    lr += mr.nodeSize * dr;
  }
  return null;
}
function selectionToInsertionEnd(cr, ar, lr) {
  let ur = cr.steps.length - 1;
  if (ur < ar)
    return;
  let dr = cr.steps[ur];
  if (!(dr instanceof ReplaceStep || dr instanceof ReplaceAroundStep))
    return;
  let fr = cr.mapping.maps[ur], gr;
  fr.forEach((mr, vr, yr, _r) => {
    gr == null && (gr = _r);
  }), cr.setSelection(Selection.near(cr.doc.resolve(gr), lr));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(ar) {
    super(ar.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = ar.selection, this.storedMarks = ar.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(ar) {
    if (ar.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = ar, this.curSelectionFor = this.steps.length, this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(ar) {
    return this.storedMarks = ar, this.updated |= UPDATED_MARKS, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(ar) {
    return Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), ar) || this.setStoredMarks(ar), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(ar) {
    return this.ensureMarks(ar.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(ar) {
    return this.ensureMarks(ar.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(ar, lr) {
    super.addStep(ar, lr), this.updated = this.updated & ~UPDATED_MARKS, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(ar) {
    return this.time = ar, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(ar) {
    return this.selection.replace(this, ar), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(ar, lr = !0) {
    let ur = this.selection;
    return lr && (ar = ar.mark(this.storedMarks || (ur.empty ? ur.$from.marks() : ur.$from.marksAcross(ur.$to) || Mark$1.none))), ur.replaceWith(this, ar), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(ar, lr, ur) {
    let dr = this.doc.type.schema;
    if (lr == null)
      return ar ? this.replaceSelectionWith(dr.text(ar), !0) : this.deleteSelection();
    {
      if (ur == null && (ur = lr), ur = ur == null ? lr : ur, !ar)
        return this.deleteRange(lr, ur);
      let fr = this.storedMarks;
      if (!fr) {
        let gr = this.doc.resolve(lr);
        fr = ur == lr ? gr.marks() : gr.marksAcross(this.doc.resolve(ur));
      }
      return this.replaceRangeWith(lr, ur, dr.text(ar, fr)), this.selection.empty || this.setSelection(Selection.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(ar, lr) {
    return this.meta[typeof ar == "string" ? ar : ar.key] = lr, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(ar) {
    return this.meta[typeof ar == "string" ? ar : ar.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let ar in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= UPDATED_SCROLL, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(cr, ar) {
  return !ar || !cr ? cr : cr.bind(ar);
}
class FieldDesc {
  constructor(ar, lr, ur) {
    this.name = ar, this.init = bind(lr.init, ur), this.apply = bind(lr.apply, ur);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(cr) {
      return cr.doc || cr.schema.topNodeType.createAndFill();
    },
    apply(cr) {
      return cr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(cr, ar) {
      return cr.selection || Selection.atStart(ar.doc);
    },
    apply(cr) {
      return cr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(cr) {
      return cr.storedMarks || null;
    },
    apply(cr, ar, lr, ur) {
      return ur.selection.$cursor ? cr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(cr, ar) {
      return cr.scrolledIntoView ? ar + 1 : ar;
    }
  })
];
class Configuration {
  constructor(ar, lr) {
    this.schema = ar, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = baseFields.slice(), lr && lr.forEach((ur) => {
      if (this.pluginsByKey[ur.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + ur.key + ")");
      this.plugins.push(ur), this.pluginsByKey[ur.key] = ur, ur.spec.state && this.fields.push(new FieldDesc(ur.key, ur.spec.state, ur));
    });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(ar) {
    this.config = ar;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(ar) {
    return this.applyTransaction(ar).state;
  }
  /**
  @internal
  */
  filterTransaction(ar, lr = -1) {
    for (let ur = 0; ur < this.config.plugins.length; ur++)
      if (ur != lr) {
        let dr = this.config.plugins[ur];
        if (dr.spec.filterTransaction && !dr.spec.filterTransaction.call(dr, ar, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(ar) {
    if (!this.filterTransaction(ar))
      return { state: this, transactions: [] };
    let lr = [ar], ur = this.applyInner(ar), dr = null;
    for (; ; ) {
      let fr = !1;
      for (let gr = 0; gr < this.config.plugins.length; gr++) {
        let mr = this.config.plugins[gr];
        if (mr.spec.appendTransaction) {
          let vr = dr ? dr[gr].n : 0, yr = dr ? dr[gr].state : this, _r = vr < lr.length && mr.spec.appendTransaction.call(mr, vr ? lr.slice(vr) : lr, yr, ur);
          if (_r && ur.filterTransaction(_r, gr)) {
            if (_r.setMeta("appendedTransaction", ar), !dr) {
              dr = [];
              for (let kr = 0; kr < this.config.plugins.length; kr++)
                dr.push(kr < gr ? { state: ur, n: lr.length } : { state: this, n: 0 });
            }
            lr.push(_r), ur = ur.applyInner(_r), fr = !0;
          }
          dr && (dr[gr] = { state: ur, n: lr.length });
        }
      }
      if (!fr)
        return { state: ur, transactions: lr };
    }
  }
  /**
  @internal
  */
  applyInner(ar) {
    if (!ar.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let lr = new EditorState(this.config), ur = this.config.fields;
    for (let dr = 0; dr < ur.length; dr++) {
      let fr = ur[dr];
      lr[fr.name] = fr.apply(ar, this[fr.name], this, lr);
    }
    return lr;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(ar) {
    let lr = new Configuration(ar.doc ? ar.doc.type.schema : ar.schema, ar.plugins), ur = new EditorState(lr);
    for (let dr = 0; dr < lr.fields.length; dr++)
      ur[lr.fields[dr].name] = lr.fields[dr].init(ar, ur);
    return ur;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(ar) {
    let lr = new Configuration(this.schema, ar.plugins), ur = lr.fields, dr = new EditorState(lr);
    for (let fr = 0; fr < ur.length; fr++) {
      let gr = ur[fr].name;
      dr[gr] = this.hasOwnProperty(gr) ? this[gr] : ur[fr].init(ar, dr);
    }
    return dr;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(ar) {
    let lr = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (lr.storedMarks = this.storedMarks.map((ur) => ur.toJSON())), ar && typeof ar == "object")
      for (let ur in ar) {
        if (ur == "doc" || ur == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let dr = ar[ur], fr = dr.spec.state;
        fr && fr.toJSON && (lr[ur] = fr.toJSON.call(dr, this[dr.key]));
      }
    return lr;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(ar, lr, ur) {
    if (!lr)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!ar.schema)
      throw new RangeError("Required config field 'schema' missing");
    let dr = new Configuration(ar.schema, ar.plugins), fr = new EditorState(dr);
    return dr.fields.forEach((gr) => {
      if (gr.name == "doc")
        fr.doc = Node$3.fromJSON(ar.schema, lr.doc);
      else if (gr.name == "selection")
        fr.selection = Selection.fromJSON(fr.doc, lr.selection);
      else if (gr.name == "storedMarks")
        lr.storedMarks && (fr.storedMarks = lr.storedMarks.map(ar.schema.markFromJSON));
      else {
        if (ur)
          for (let mr in ur) {
            let vr = ur[mr], yr = vr.spec.state;
            if (vr.key == gr.name && yr && yr.fromJSON && Object.prototype.hasOwnProperty.call(lr, mr)) {
              fr[gr.name] = yr.fromJSON.call(vr, ar, lr[mr], fr);
              return;
            }
          }
        fr[gr.name] = gr.init(ar, fr);
      }
    }), fr;
  }
}
function bindProps(cr, ar, lr) {
  for (let ur in cr) {
    let dr = cr[ur];
    dr instanceof Function ? dr = dr.bind(ar) : ur == "handleDOMEvents" && (dr = bindProps(dr, ar, {})), lr[ur] = dr;
  }
  return lr;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(ar) {
    this.spec = ar, this.props = {}, ar.props && bindProps(ar.props, this, this.props), this.key = ar.key ? ar.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(ar) {
    return ar[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(cr) {
  return cr in keys ? cr + "$" + ++keys[cr] : (keys[cr] = 0, cr + "$");
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(ar = "key") {
    this.key = createKey(ar);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(ar) {
    return ar.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(ar) {
    return ar[this.key];
  }
}
const domIndex = function(cr) {
  for (var ar = 0; ; ar++)
    if (cr = cr.previousSibling, !cr)
      return ar;
}, parentNode = function(cr) {
  let ar = cr.assignedSlot || cr.parentNode;
  return ar && ar.nodeType == 11 ? ar.host : ar;
};
let reusedRange = null;
const textRange = function(cr, ar, lr) {
  let ur = reusedRange || (reusedRange = document.createRange());
  return ur.setEnd(cr, lr == null ? cr.nodeValue.length : lr), ur.setStart(cr, ar || 0), ur;
}, isEquivalentPosition = function(cr, ar, lr, ur) {
  return lr && (scanFor(cr, ar, lr, ur, -1) || scanFor(cr, ar, lr, ur, 1));
}, atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(cr, ar, lr, ur, dr) {
  for (; ; ) {
    if (cr == lr && ar == ur)
      return !0;
    if (ar == (dr < 0 ? 0 : nodeSize(cr))) {
      let fr = cr.parentNode;
      if (!fr || fr.nodeType != 1 || hasBlockDesc(cr) || atomElements.test(cr.nodeName) || cr.contentEditable == "false")
        return !1;
      ar = domIndex(cr) + (dr < 0 ? 0 : 1), cr = fr;
    } else if (cr.nodeType == 1) {
      if (cr = cr.childNodes[ar + (dr < 0 ? -1 : 0)], cr.contentEditable == "false")
        return !1;
      ar = dr < 0 ? nodeSize(cr) : 0;
    } else
      return !1;
  }
}
function nodeSize(cr) {
  return cr.nodeType == 3 ? cr.nodeValue.length : cr.childNodes.length;
}
function isOnEdge(cr, ar, lr) {
  for (let ur = ar == 0, dr = ar == nodeSize(cr); ur || dr; ) {
    if (cr == lr)
      return !0;
    let fr = domIndex(cr);
    if (cr = cr.parentNode, !cr)
      return !1;
    ur = ur && fr == 0, dr = dr && fr == nodeSize(cr);
  }
}
function hasBlockDesc(cr) {
  let ar;
  for (let lr = cr; lr && !(ar = lr.pmViewDesc); lr = lr.parentNode)
    ;
  return ar && ar.node && ar.node.isBlock && (ar.dom == cr || ar.contentDOM == cr);
}
const selectionCollapsed = function(cr) {
  return cr.focusNode && isEquivalentPosition(cr.focusNode, cr.focusOffset, cr.anchorNode, cr.anchorOffset);
};
function keyEvent(cr, ar) {
  let lr = document.createEvent("Event");
  return lr.initEvent("keydown", !0, !0), lr.keyCode = cr, lr.key = lr.code = ar, lr;
}
function deepActiveElement(cr) {
  let ar = cr.activeElement;
  for (; ar && ar.shadowRoot; )
    ar = ar.shadowRoot.activeElement;
  return ar;
}
function caretFromPoint(cr, ar, lr) {
  if (cr.caretPositionFromPoint)
    try {
      let ur = cr.caretPositionFromPoint(ar, lr);
      if (ur)
        return { node: ur.offsetNode, offset: ur.offset };
    } catch (ur) {
    }
  if (cr.caretRangeFromPoint) {
    let ur = cr.caretRangeFromPoint(ar, lr);
    if (ur)
      return { node: ur.startContainer, offset: ur.startOffset };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null, doc = typeof document != "undefined" ? document : null, agent = nav && nav.userAgent || "", ie_edge = /Edge\/(\d+)/.exec(agent), ie_upto10 = /MSIE \d/.exec(agent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent), ie$1 = !!(ie_upto10 || ie_11up || ie_edge), ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0, gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent), chrome = !!_chrome, chrome_version = _chrome ? +_chrome[1] : 0, safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor), ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2), mac$3 = ios || (nav ? /Mac/.test(nav.platform) : !1), windows = nav ? /Win/.test(nav.platform) : !1, android = /Android \d/.test(agent), webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style, webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(cr) {
  return {
    left: 0,
    right: cr.documentElement.clientWidth,
    top: 0,
    bottom: cr.documentElement.clientHeight
  };
}
function getSide(cr, ar) {
  return typeof cr == "number" ? cr : cr[ar];
}
function clientRect(cr) {
  let ar = cr.getBoundingClientRect(), lr = ar.width / cr.offsetWidth || 1, ur = ar.height / cr.offsetHeight || 1;
  return {
    left: ar.left,
    right: ar.left + cr.clientWidth * lr,
    top: ar.top,
    bottom: ar.top + cr.clientHeight * ur
  };
}
function scrollRectIntoView(cr, ar, lr) {
  let ur = cr.someProp("scrollThreshold") || 0, dr = cr.someProp("scrollMargin") || 5, fr = cr.dom.ownerDocument;
  for (let gr = lr || cr.dom; gr; gr = parentNode(gr)) {
    if (gr.nodeType != 1)
      continue;
    let mr = gr, vr = mr == fr.body, yr = vr ? windowRect(fr) : clientRect(mr), _r = 0, kr = 0;
    if (ar.top < yr.top + getSide(ur, "top") ? kr = -(yr.top - ar.top + getSide(dr, "top")) : ar.bottom > yr.bottom - getSide(ur, "bottom") && (kr = ar.bottom - ar.top > yr.bottom - yr.top ? ar.top + getSide(dr, "top") - yr.top : ar.bottom - yr.bottom + getSide(dr, "bottom")), ar.left < yr.left + getSide(ur, "left") ? _r = -(yr.left - ar.left + getSide(dr, "left")) : ar.right > yr.right - getSide(ur, "right") && (_r = ar.right - yr.right + getSide(dr, "right")), _r || kr)
      if (vr)
        fr.defaultView.scrollBy(_r, kr);
      else {
        let xr = mr.scrollLeft, Ar = mr.scrollTop;
        kr && (mr.scrollTop += kr), _r && (mr.scrollLeft += _r);
        let Er = mr.scrollLeft - xr, Cr = mr.scrollTop - Ar;
        ar = { left: ar.left - Er, top: ar.top - Cr, right: ar.right - Er, bottom: ar.bottom - Cr };
      }
    if (vr || /^(fixed|sticky)$/.test(getComputedStyle(gr).position))
      break;
  }
}
function storeScrollPos(cr) {
  let ar = cr.dom.getBoundingClientRect(), lr = Math.max(0, ar.top), ur, dr;
  for (let fr = (ar.left + ar.right) / 2, gr = lr + 1; gr < Math.min(innerHeight, ar.bottom); gr += 5) {
    let mr = cr.root.elementFromPoint(fr, gr);
    if (!mr || mr == cr.dom || !cr.dom.contains(mr))
      continue;
    let vr = mr.getBoundingClientRect();
    if (vr.top >= lr - 20) {
      ur = mr, dr = vr.top;
      break;
    }
  }
  return { refDOM: ur, refTop: dr, stack: scrollStack(cr.dom) };
}
function scrollStack(cr) {
  let ar = [], lr = cr.ownerDocument;
  for (let ur = cr; ur && (ar.push({ dom: ur, top: ur.scrollTop, left: ur.scrollLeft }), cr != lr); ur = parentNode(ur))
    ;
  return ar;
}
function resetScrollPos({ refDOM: cr, refTop: ar, stack: lr }) {
  let ur = cr ? cr.getBoundingClientRect().top : 0;
  restoreScrollStack(lr, ur == 0 ? 0 : ur - ar);
}
function restoreScrollStack(cr, ar) {
  for (let lr = 0; lr < cr.length; lr++) {
    let { dom: ur, top: dr, left: fr } = cr[lr];
    ur.scrollTop != dr + ar && (ur.scrollTop = dr + ar), ur.scrollLeft != fr && (ur.scrollLeft = fr);
  }
}
let preventScrollSupported = null;
function focusPreventScroll(cr) {
  if (cr.setActive)
    return cr.setActive();
  if (preventScrollSupported)
    return cr.focus(preventScrollSupported);
  let ar = scrollStack(cr);
  cr.focus(preventScrollSupported == null ? {
    get preventScroll() {
      return preventScrollSupported = { preventScroll: !0 }, !0;
    }
  } : void 0), preventScrollSupported || (preventScrollSupported = !1, restoreScrollStack(ar, 0));
}
function findOffsetInNode(cr, ar) {
  let lr, ur = 2e8, dr, fr = 0, gr = ar.top, mr = ar.top, vr, yr;
  for (let _r = cr.firstChild, kr = 0; _r; _r = _r.nextSibling, kr++) {
    let xr;
    if (_r.nodeType == 1)
      xr = _r.getClientRects();
    else if (_r.nodeType == 3)
      xr = textRange(_r).getClientRects();
    else
      continue;
    for (let Ar = 0; Ar < xr.length; Ar++) {
      let Er = xr[Ar];
      if (Er.top <= gr && Er.bottom >= mr) {
        gr = Math.max(Er.bottom, gr), mr = Math.min(Er.top, mr);
        let Cr = Er.left > ar.left ? Er.left - ar.left : Er.right < ar.left ? ar.left - Er.right : 0;
        if (Cr < ur) {
          lr = _r, ur = Cr, dr = Cr && lr.nodeType == 3 ? {
            left: Er.right < ar.left ? Er.right : Er.left,
            top: ar.top
          } : ar, _r.nodeType == 1 && Cr && (fr = kr + (ar.left >= (Er.left + Er.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        Er.top > ar.top && !vr && Er.left <= ar.left && Er.right >= ar.left && (vr = _r, yr = { left: Math.max(Er.left, Math.min(Er.right, ar.left)), top: Er.top });
      !lr && (ar.left >= Er.right && ar.top >= Er.top || ar.left >= Er.left && ar.top >= Er.bottom) && (fr = kr + 1);
    }
  }
  return !lr && vr && (lr = vr, dr = yr, ur = 0), lr && lr.nodeType == 3 ? findOffsetInText(lr, dr) : !lr || ur && lr.nodeType == 1 ? { node: cr, offset: fr } : findOffsetInNode(lr, dr);
}
function findOffsetInText(cr, ar) {
  let lr = cr.nodeValue.length, ur = document.createRange();
  for (let dr = 0; dr < lr; dr++) {
    ur.setEnd(cr, dr + 1), ur.setStart(cr, dr);
    let fr = singleRect(ur, 1);
    if (fr.top != fr.bottom && inRect(ar, fr))
      return { node: cr, offset: dr + (ar.left >= (fr.left + fr.right) / 2 ? 1 : 0) };
  }
  return { node: cr, offset: 0 };
}
function inRect(cr, ar) {
  return cr.left >= ar.left - 1 && cr.left <= ar.right + 1 && cr.top >= ar.top - 1 && cr.top <= ar.bottom + 1;
}
function targetKludge(cr, ar) {
  let lr = cr.parentNode;
  return lr && /^li$/i.test(lr.nodeName) && ar.left < cr.getBoundingClientRect().left ? lr : cr;
}
function posFromElement(cr, ar, lr) {
  let { node: ur, offset: dr } = findOffsetInNode(ar, lr), fr = -1;
  if (ur.nodeType == 1 && !ur.firstChild) {
    let gr = ur.getBoundingClientRect();
    fr = gr.left != gr.right && lr.left > (gr.left + gr.right) / 2 ? 1 : -1;
  }
  return cr.docView.posFromDOM(ur, dr, fr);
}
function posFromCaret(cr, ar, lr, ur) {
  let dr = -1;
  for (let fr = ar, gr = !1; fr != cr.dom; ) {
    let mr = cr.docView.nearestDesc(fr, !0);
    if (!mr)
      return null;
    if (mr.dom.nodeType == 1 && (mr.node.isBlock && mr.parent && !gr || !mr.contentDOM)) {
      let vr = mr.dom.getBoundingClientRect();
      if (mr.node.isBlock && mr.parent && !gr && (gr = !0, vr.left > ur.left || vr.top > ur.top ? dr = mr.posBefore : (vr.right < ur.left || vr.bottom < ur.top) && (dr = mr.posAfter)), !mr.contentDOM && dr < 0 && !mr.node.isText)
        return (mr.node.isBlock ? ur.top < (vr.top + vr.bottom) / 2 : ur.left < (vr.left + vr.right) / 2) ? mr.posBefore : mr.posAfter;
    }
    fr = mr.dom.parentNode;
  }
  return dr > -1 ? dr : cr.docView.posFromDOM(ar, lr, -1);
}
function elementFromPoint(cr, ar, lr) {
  let ur = cr.childNodes.length;
  if (ur && lr.top < lr.bottom)
    for (let dr = Math.max(0, Math.min(ur - 1, Math.floor(ur * (ar.top - lr.top) / (lr.bottom - lr.top)) - 2)), fr = dr; ; ) {
      let gr = cr.childNodes[fr];
      if (gr.nodeType == 1) {
        let mr = gr.getClientRects();
        for (let vr = 0; vr < mr.length; vr++) {
          let yr = mr[vr];
          if (inRect(ar, yr))
            return elementFromPoint(gr, ar, yr);
        }
      }
      if ((fr = (fr + 1) % ur) == dr)
        break;
    }
  return cr;
}
function posAtCoords(cr, ar) {
  let lr = cr.dom.ownerDocument, ur, dr = 0, fr = caretFromPoint(lr, ar.left, ar.top);
  fr && ({ node: ur, offset: dr } = fr);
  let gr = (cr.root.elementFromPoint ? cr.root : lr).elementFromPoint(ar.left, ar.top), mr;
  if (!gr || !cr.dom.contains(gr.nodeType != 1 ? gr.parentNode : gr)) {
    let yr = cr.dom.getBoundingClientRect();
    if (!inRect(ar, yr) || (gr = elementFromPoint(cr.dom, ar, yr), !gr))
      return null;
  }
  if (safari)
    for (let yr = gr; ur && yr; yr = parentNode(yr))
      yr.draggable && (ur = void 0);
  if (gr = targetKludge(gr, ar), ur) {
    if (gecko && ur.nodeType == 1 && (dr = Math.min(dr, ur.childNodes.length), dr < ur.childNodes.length)) {
      let _r = ur.childNodes[dr], kr;
      _r.nodeName == "IMG" && (kr = _r.getBoundingClientRect()).right <= ar.left && kr.bottom > ar.top && dr++;
    }
    let yr;
    webkit && dr && ur.nodeType == 1 && (yr = ur.childNodes[dr - 1]).nodeType == 1 && yr.contentEditable == "false" && yr.getBoundingClientRect().top >= ar.top && dr--, ur == cr.dom && dr == ur.childNodes.length - 1 && ur.lastChild.nodeType == 1 && ar.top > ur.lastChild.getBoundingClientRect().bottom ? mr = cr.state.doc.content.size : (dr == 0 || ur.nodeType != 1 || ur.childNodes[dr - 1].nodeName != "BR") && (mr = posFromCaret(cr, ur, dr, ar));
  }
  mr == null && (mr = posFromElement(cr, gr, ar));
  let vr = cr.docView.nearestDesc(gr, !0);
  return { pos: mr, inside: vr ? vr.posAtStart - vr.border : -1 };
}
function nonZero(cr) {
  return cr.top < cr.bottom || cr.left < cr.right;
}
function singleRect(cr, ar) {
  let lr = cr.getClientRects();
  if (lr.length) {
    let ur = lr[ar < 0 ? 0 : lr.length - 1];
    if (nonZero(ur))
      return ur;
  }
  return Array.prototype.find.call(lr, nonZero) || cr.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(cr, ar, lr) {
  let { node: ur, offset: dr, atom: fr } = cr.docView.domFromPos(ar, lr < 0 ? -1 : 1), gr = webkit || gecko;
  if (ur.nodeType == 3)
    if (gr && (BIDI.test(ur.nodeValue) || (lr < 0 ? !dr : dr == ur.nodeValue.length))) {
      let vr = singleRect(textRange(ur, dr, dr), lr);
      if (gecko && dr && /\s/.test(ur.nodeValue[dr - 1]) && dr < ur.nodeValue.length) {
        let yr = singleRect(textRange(ur, dr - 1, dr - 1), -1);
        if (yr.top == vr.top) {
          let _r = singleRect(textRange(ur, dr, dr + 1), -1);
          if (_r.top != vr.top)
            return flattenV(_r, _r.left < yr.left);
        }
      }
      return vr;
    } else {
      let vr = dr, yr = dr, _r = lr < 0 ? 1 : -1;
      return lr < 0 && !dr ? (yr++, _r = -1) : lr >= 0 && dr == ur.nodeValue.length ? (vr--, _r = 1) : lr < 0 ? vr-- : yr++, flattenV(singleRect(textRange(ur, vr, yr), _r), _r < 0);
    }
  if (!cr.state.doc.resolve(ar - (fr || 0)).parent.inlineContent) {
    if (fr == null && dr && (lr < 0 || dr == nodeSize(ur))) {
      let vr = ur.childNodes[dr - 1];
      if (vr.nodeType == 1)
        return flattenH(vr.getBoundingClientRect(), !1);
    }
    if (fr == null && dr < nodeSize(ur)) {
      let vr = ur.childNodes[dr];
      if (vr.nodeType == 1)
        return flattenH(vr.getBoundingClientRect(), !0);
    }
    return flattenH(ur.getBoundingClientRect(), lr >= 0);
  }
  if (fr == null && dr && (lr < 0 || dr == nodeSize(ur))) {
    let vr = ur.childNodes[dr - 1], yr = vr.nodeType == 3 ? textRange(vr, nodeSize(vr) - (gr ? 0 : 1)) : vr.nodeType == 1 && (vr.nodeName != "BR" || !vr.nextSibling) ? vr : null;
    if (yr)
      return flattenV(singleRect(yr, 1), !1);
  }
  if (fr == null && dr < nodeSize(ur)) {
    let vr = ur.childNodes[dr];
    for (; vr.pmViewDesc && vr.pmViewDesc.ignoreForCoords; )
      vr = vr.nextSibling;
    let yr = vr ? vr.nodeType == 3 ? textRange(vr, 0, gr ? 0 : 1) : vr.nodeType == 1 ? vr : null : null;
    if (yr)
      return flattenV(singleRect(yr, -1), !0);
  }
  return flattenV(singleRect(ur.nodeType == 3 ? textRange(ur) : ur, -lr), lr >= 0);
}
function flattenV(cr, ar) {
  if (cr.width == 0)
    return cr;
  let lr = ar ? cr.left : cr.right;
  return { top: cr.top, bottom: cr.bottom, left: lr, right: lr };
}
function flattenH(cr, ar) {
  if (cr.height == 0)
    return cr;
  let lr = ar ? cr.top : cr.bottom;
  return { top: lr, bottom: lr, left: cr.left, right: cr.right };
}
function withFlushedState(cr, ar, lr) {
  let ur = cr.state, dr = cr.root.activeElement;
  ur != ar && cr.updateState(ar), dr != cr.dom && cr.focus();
  try {
    return lr();
  } finally {
    ur != ar && cr.updateState(ur), dr != cr.dom && dr && dr.focus();
  }
}
function endOfTextblockVertical(cr, ar, lr) {
  let ur = ar.selection, dr = lr == "up" ? ur.$from : ur.$to;
  return withFlushedState(cr, ar, () => {
    let { node: fr } = cr.docView.domFromPos(dr.pos, lr == "up" ? -1 : 1);
    for (; ; ) {
      let mr = cr.docView.nearestDesc(fr, !0);
      if (!mr)
        break;
      if (mr.node.isBlock) {
        fr = mr.contentDOM || mr.dom;
        break;
      }
      fr = mr.dom.parentNode;
    }
    let gr = coordsAtPos(cr, dr.pos, 1);
    for (let mr = fr.firstChild; mr; mr = mr.nextSibling) {
      let vr;
      if (mr.nodeType == 1)
        vr = mr.getClientRects();
      else if (mr.nodeType == 3)
        vr = textRange(mr, 0, mr.nodeValue.length).getClientRects();
      else
        continue;
      for (let yr = 0; yr < vr.length; yr++) {
        let _r = vr[yr];
        if (_r.bottom > _r.top + 1 && (lr == "up" ? gr.top - _r.top > (_r.bottom - gr.top) * 2 : _r.bottom - gr.bottom > (gr.bottom - _r.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(cr, ar, lr) {
  let { $head: ur } = ar.selection;
  if (!ur.parent.isTextblock)
    return !1;
  let dr = ur.parentOffset, fr = !dr, gr = dr == ur.parent.content.size, mr = cr.domSelection();
  return !maybeRTL.test(ur.parent.textContent) || !mr.modify ? lr == "left" || lr == "backward" ? fr : gr : withFlushedState(cr, ar, () => {
    let { focusNode: vr, focusOffset: yr, anchorNode: _r, anchorOffset: kr } = cr.domSelectionRange(), xr = mr.caretBidiLevel;
    mr.modify("move", lr, "character");
    let Ar = ur.depth ? cr.docView.domAfterPos(ur.before()) : cr.dom, { focusNode: Er, focusOffset: Cr } = cr.domSelectionRange(), Tr = Er && !Ar.contains(Er.nodeType == 1 ? Er : Er.parentNode) || vr == Er && yr == Cr;
    try {
      mr.collapse(_r, kr), vr && (vr != _r || yr != kr) && mr.extend && mr.extend(vr, yr);
    } catch (Sr) {
    }
    return xr != null && (mr.caretBidiLevel = xr), Tr;
  });
}
let cachedState = null, cachedDir = null, cachedResult = !1;
function endOfTextblock(cr, ar, lr) {
  return cachedState == ar && cachedDir == lr ? cachedResult : (cachedState = ar, cachedDir = lr, cachedResult = lr == "up" || lr == "down" ? endOfTextblockVertical(cr, ar, lr) : endOfTextblockHorizontal(cr, ar, lr));
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(ar, lr, ur, dr) {
    this.parent = ar, this.children = lr, this.dom = ur, this.contentDOM = dr, this.dirty = NOT_DIRTY, ur.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(ar) {
    return !1;
  }
  matchesMark(ar) {
    return !1;
  }
  matchesNode(ar, lr, ur) {
    return !1;
  }
  matchesHack(ar) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(ar) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let ar = 0;
    for (let lr = 0; lr < this.children.length; lr++)
      ar += this.children[lr].size;
    return ar;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let ar = 0; ar < this.children.length; ar++)
      this.children[ar].destroy();
  }
  posBeforeChild(ar) {
    for (let lr = 0, ur = this.posAtStart; ; lr++) {
      let dr = this.children[lr];
      if (dr == ar)
        return ur;
      ur += dr.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(ar, lr, ur) {
    if (this.contentDOM && this.contentDOM.contains(ar.nodeType == 1 ? ar : ar.parentNode))
      if (ur < 0) {
        let fr, gr;
        if (ar == this.contentDOM)
          fr = ar.childNodes[lr - 1];
        else {
          for (; ar.parentNode != this.contentDOM; )
            ar = ar.parentNode;
          fr = ar.previousSibling;
        }
        for (; fr && !((gr = fr.pmViewDesc) && gr.parent == this); )
          fr = fr.previousSibling;
        return fr ? this.posBeforeChild(gr) + gr.size : this.posAtStart;
      } else {
        let fr, gr;
        if (ar == this.contentDOM)
          fr = ar.childNodes[lr];
        else {
          for (; ar.parentNode != this.contentDOM; )
            ar = ar.parentNode;
          fr = ar.nextSibling;
        }
        for (; fr && !((gr = fr.pmViewDesc) && gr.parent == this); )
          fr = fr.nextSibling;
        return fr ? this.posBeforeChild(gr) : this.posAtEnd;
      }
    let dr;
    if (ar == this.dom && this.contentDOM)
      dr = lr > domIndex(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      dr = ar.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (lr == 0)
        for (let fr = ar; ; fr = fr.parentNode) {
          if (fr == this.dom) {
            dr = !1;
            break;
          }
          if (fr.previousSibling)
            break;
        }
      if (dr == null && lr == ar.childNodes.length)
        for (let fr = ar; ; fr = fr.parentNode) {
          if (fr == this.dom) {
            dr = !0;
            break;
          }
          if (fr.nextSibling)
            break;
        }
    }
    return (dr == null ? ur > 0 : dr) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(ar, lr = !1) {
    for (let ur = !0, dr = ar; dr; dr = dr.parentNode) {
      let fr = this.getDesc(dr), gr;
      if (fr && (!lr || fr.node))
        if (ur && (gr = fr.nodeDOM) && !(gr.nodeType == 1 ? gr.contains(ar.nodeType == 1 ? ar : ar.parentNode) : gr == ar))
          ur = !1;
        else
          return fr;
    }
  }
  getDesc(ar) {
    let lr = ar.pmViewDesc;
    for (let ur = lr; ur; ur = ur.parent)
      if (ur == this)
        return lr;
  }
  posFromDOM(ar, lr, ur) {
    for (let dr = ar; dr; dr = dr.parentNode) {
      let fr = this.getDesc(dr);
      if (fr)
        return fr.localPosFromDOM(ar, lr, ur);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(ar) {
    for (let lr = 0, ur = 0; lr < this.children.length; lr++) {
      let dr = this.children[lr], fr = ur + dr.size;
      if (ur == ar && fr != ur) {
        for (; !dr.border && dr.children.length; )
          dr = dr.children[0];
        return dr;
      }
      if (ar < fr)
        return dr.descAt(ar - ur - dr.border);
      ur = fr;
    }
  }
  domFromPos(ar, lr) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: ar + 1 };
    let ur = 0, dr = 0;
    for (let fr = 0; ur < this.children.length; ur++) {
      let gr = this.children[ur], mr = fr + gr.size;
      if (mr > ar || gr instanceof TrailingHackViewDesc) {
        dr = ar - fr;
        break;
      }
      fr = mr;
    }
    if (dr)
      return this.children[ur].domFromPos(dr - this.children[ur].border, lr);
    for (let fr; ur && !(fr = this.children[ur - 1]).size && fr instanceof WidgetViewDesc && fr.side >= 0; ur--)
      ;
    if (lr <= 0) {
      let fr, gr = !0;
      for (; fr = ur ? this.children[ur - 1] : null, !(!fr || fr.dom.parentNode == this.contentDOM); ur--, gr = !1)
        ;
      return fr && lr && gr && !fr.border && !fr.domAtom ? fr.domFromPos(fr.size, lr) : { node: this.contentDOM, offset: fr ? domIndex(fr.dom) + 1 : 0 };
    } else {
      let fr, gr = !0;
      for (; fr = ur < this.children.length ? this.children[ur] : null, !(!fr || fr.dom.parentNode == this.contentDOM); ur++, gr = !1)
        ;
      return fr && gr && !fr.border && !fr.domAtom ? fr.domFromPos(0, lr) : { node: this.contentDOM, offset: fr ? domIndex(fr.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(ar, lr, ur = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: ar, to: lr, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let dr = -1, fr = -1;
    for (let gr = ur, mr = 0; ; mr++) {
      let vr = this.children[mr], yr = gr + vr.size;
      if (dr == -1 && ar <= yr) {
        let _r = gr + vr.border;
        if (ar >= _r && lr <= yr - vr.border && vr.node && vr.contentDOM && this.contentDOM.contains(vr.contentDOM))
          return vr.parseRange(ar, lr, _r);
        ar = gr;
        for (let kr = mr; kr > 0; kr--) {
          let xr = this.children[kr - 1];
          if (xr.size && xr.dom.parentNode == this.contentDOM && !xr.emptyChildAt(1)) {
            dr = domIndex(xr.dom) + 1;
            break;
          }
          ar -= xr.size;
        }
        dr == -1 && (dr = 0);
      }
      if (dr > -1 && (yr > lr || mr == this.children.length - 1)) {
        lr = yr;
        for (let _r = mr + 1; _r < this.children.length; _r++) {
          let kr = this.children[_r];
          if (kr.size && kr.dom.parentNode == this.contentDOM && !kr.emptyChildAt(-1)) {
            fr = domIndex(kr.dom);
            break;
          }
          lr += kr.size;
        }
        fr == -1 && (fr = this.contentDOM.childNodes.length);
        break;
      }
      gr = yr;
    }
    return { node: this.contentDOM, from: ar, to: lr, fromOffset: dr, toOffset: fr };
  }
  emptyChildAt(ar) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let lr = this.children[ar < 0 ? 0 : this.children.length - 1];
    return lr.size == 0 || lr.emptyChildAt(ar);
  }
  domAfterPos(ar) {
    let { node: lr, offset: ur } = this.domFromPos(ar, 0);
    if (lr.nodeType != 1 || ur == lr.childNodes.length)
      throw new RangeError("No node after pos " + ar);
    return lr.childNodes[ur];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(ar, lr, ur, dr = !1) {
    let fr = Math.min(ar, lr), gr = Math.max(ar, lr);
    for (let xr = 0, Ar = 0; xr < this.children.length; xr++) {
      let Er = this.children[xr], Cr = Ar + Er.size;
      if (fr > Ar && gr < Cr)
        return Er.setSelection(ar - Ar - Er.border, lr - Ar - Er.border, ur, dr);
      Ar = Cr;
    }
    let mr = this.domFromPos(ar, ar ? -1 : 1), vr = lr == ar ? mr : this.domFromPos(lr, lr ? -1 : 1), yr = ur.getSelection(), _r = !1;
    if ((gecko || safari) && ar == lr) {
      let { node: xr, offset: Ar } = mr;
      if (xr.nodeType == 3) {
        if (_r = !!(Ar && xr.nodeValue[Ar - 1] == `
`), _r && Ar == xr.nodeValue.length)
          for (let Er = xr, Cr; Er; Er = Er.parentNode) {
            if (Cr = Er.nextSibling) {
              Cr.nodeName == "BR" && (mr = vr = { node: Cr.parentNode, offset: domIndex(Cr) + 1 });
              break;
            }
            let Tr = Er.pmViewDesc;
            if (Tr && Tr.node && Tr.node.isBlock)
              break;
          }
      } else {
        let Er = xr.childNodes[Ar - 1];
        _r = Er && (Er.nodeName == "BR" || Er.contentEditable == "false");
      }
    }
    if (gecko && yr.focusNode && yr.focusNode != vr.node && yr.focusNode.nodeType == 1) {
      let xr = yr.focusNode.childNodes[yr.focusOffset];
      xr && xr.contentEditable == "false" && (dr = !0);
    }
    if (!(dr || _r && safari) && isEquivalentPosition(mr.node, mr.offset, yr.anchorNode, yr.anchorOffset) && isEquivalentPosition(vr.node, vr.offset, yr.focusNode, yr.focusOffset))
      return;
    let kr = !1;
    if ((yr.extend || ar == lr) && !_r) {
      yr.collapse(mr.node, mr.offset);
      try {
        ar != lr && yr.extend(vr.node, vr.offset), kr = !0;
      } catch (xr) {
      }
    }
    if (!kr) {
      if (ar > lr) {
        let Ar = mr;
        mr = vr, vr = Ar;
      }
      let xr = document.createRange();
      xr.setEnd(vr.node, vr.offset), xr.setStart(mr.node, mr.offset), yr.removeAllRanges(), yr.addRange(xr);
    }
  }
  ignoreMutation(ar) {
    return !this.contentDOM && ar.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(ar, lr) {
    for (let ur = 0, dr = 0; dr < this.children.length; dr++) {
      let fr = this.children[dr], gr = ur + fr.size;
      if (ur == gr ? ar <= gr && lr >= ur : ar < gr && lr > ur) {
        let mr = ur + fr.border, vr = gr - fr.border;
        if (ar >= mr && lr <= vr) {
          this.dirty = ar == ur || lr == gr ? CONTENT_DIRTY : CHILD_DIRTY, ar == mr && lr == vr && (fr.contentLost || fr.dom.parentNode != this.contentDOM) ? fr.dirty = NODE_DIRTY : fr.markDirty(ar - mr, lr - mr);
          return;
        } else
          fr.dirty = fr.dom == fr.contentDOM && fr.dom.parentNode == this.contentDOM && !fr.children.length ? CONTENT_DIRTY : NODE_DIRTY;
      }
      ur = gr;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let ar = 1;
    for (let lr = this.parent; lr; lr = lr.parent, ar++) {
      let ur = ar == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      lr.dirty < ur && (lr.dirty = ur);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(ar, lr, ur, dr) {
    let fr, gr = lr.type.toDOM;
    if (typeof gr == "function" && (gr = gr(ur, () => {
      if (!fr)
        return dr;
      if (fr.parent)
        return fr.parent.posBeforeChild(fr);
    })), !lr.type.spec.raw) {
      if (gr.nodeType != 1) {
        let mr = document.createElement("span");
        mr.appendChild(gr), gr = mr;
      }
      gr.contentEditable = "false", gr.classList.add("ProseMirror-widget");
    }
    super(ar, [], gr, null), this.widget = lr, this.widget = lr, fr = this;
  }
  matchesWidget(ar) {
    return this.dirty == NOT_DIRTY && ar.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(ar) {
    let lr = this.widget.spec.stopEvent;
    return lr ? lr(ar) : !1;
  }
  ignoreMutation(ar) {
    return ar.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(ar, lr, ur, dr) {
    super(ar, [], lr, null), this.textDOM = ur, this.text = dr;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(ar, lr) {
    return ar != this.textDOM ? this.posAtStart + (lr ? this.size : 0) : this.posAtStart + lr;
  }
  domFromPos(ar) {
    return { node: this.textDOM, offset: ar };
  }
  ignoreMutation(ar) {
    return ar.type === "characterData" && ar.target.nodeValue == ar.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(ar, lr, ur, dr) {
    super(ar, [], ur, dr), this.mark = lr;
  }
  static create(ar, lr, ur, dr) {
    let fr = dr.nodeViews[lr.type.name], gr = fr && fr(lr, dr, ur);
    return (!gr || !gr.dom) && (gr = DOMSerializer.renderSpec(document, lr.type.spec.toDOM(lr, ur))), new MarkViewDesc(ar, lr, gr.dom, gr.contentDOM || gr.dom);
  }
  parseRule() {
    return this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(ar) {
    return this.dirty != NODE_DIRTY && this.mark.eq(ar);
  }
  markDirty(ar, lr) {
    if (super.markDirty(ar, lr), this.dirty != NOT_DIRTY) {
      let ur = this.parent;
      for (; !ur.node; )
        ur = ur.parent;
      ur.dirty < this.dirty && (ur.dirty = this.dirty), this.dirty = NOT_DIRTY;
    }
  }
  slice(ar, lr, ur) {
    let dr = MarkViewDesc.create(this.parent, this.mark, !0, ur), fr = this.children, gr = this.size;
    lr < gr && (fr = replaceNodes(fr, lr, gr, ur)), ar > 0 && (fr = replaceNodes(fr, 0, ar, ur));
    for (let mr = 0; mr < fr.length; mr++)
      fr[mr].parent = dr;
    return dr.children = fr, dr;
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(ar, lr, ur, dr, fr, gr, mr, vr, yr) {
    super(ar, [], fr, gr), this.node = lr, this.outerDeco = ur, this.innerDeco = dr, this.nodeDOM = mr;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(ar, lr, ur, dr, fr, gr) {
    let mr = fr.nodeViews[lr.type.name], vr, yr = mr && mr(lr, fr, () => {
      if (!vr)
        return gr;
      if (vr.parent)
        return vr.parent.posBeforeChild(vr);
    }, ur, dr), _r = yr && yr.dom, kr = yr && yr.contentDOM;
    if (lr.isText) {
      if (!_r)
        _r = document.createTextNode(lr.text);
      else if (_r.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      _r || ({ dom: _r, contentDOM: kr } = DOMSerializer.renderSpec(document, lr.type.spec.toDOM(lr)));
    !kr && !lr.isText && _r.nodeName != "BR" && (_r.hasAttribute("contenteditable") || (_r.contentEditable = "false"), lr.type.spec.draggable && (_r.draggable = !0));
    let xr = _r;
    return _r = applyOuterDeco(_r, ur, lr), yr ? vr = new CustomNodeViewDesc(ar, lr, ur, dr, _r, kr || null, xr, yr, fr, gr + 1) : lr.isText ? new TextViewDesc(ar, lr, ur, dr, _r, xr, fr) : new NodeViewDesc(ar, lr, ur, dr, _r, kr || null, xr, fr, gr + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let ar = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (ar.preserveWhitespace = "full"), !this.contentDOM)
      ar.getContent = () => this.node.content;
    else if (!this.contentLost)
      ar.contentElement = this.contentDOM;
    else {
      for (let lr = this.children.length - 1; lr >= 0; lr--) {
        let ur = this.children[lr];
        if (this.dom.contains(ur.dom.parentNode)) {
          ar.contentElement = ur.dom.parentNode;
          break;
        }
      }
      ar.contentElement || (ar.getContent = () => Fragment.empty);
    }
    return ar;
  }
  matchesNode(ar, lr, ur) {
    return this.dirty == NOT_DIRTY && ar.eq(this.node) && sameOuterDeco(lr, this.outerDeco) && ur.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(ar, lr) {
    let ur = this.node.inlineContent, dr = lr, fr = ar.composing ? this.localCompositionInfo(ar, lr) : null, gr = fr && fr.pos > -1 ? fr : null, mr = fr && fr.pos < 0, vr = new ViewTreeUpdater(this, gr && gr.node, ar);
    iterDeco(this.node, this.innerDeco, (yr, _r, kr) => {
      yr.spec.marks ? vr.syncToMarks(yr.spec.marks, ur, ar) : yr.type.side >= 0 && !kr && vr.syncToMarks(_r == this.node.childCount ? Mark$1.none : this.node.child(_r).marks, ur, ar), vr.placeWidget(yr, ar, dr);
    }, (yr, _r, kr, xr) => {
      vr.syncToMarks(yr.marks, ur, ar);
      let Ar;
      vr.findNodeMatch(yr, _r, kr, xr) || mr && ar.state.selection.from > dr && ar.state.selection.to < dr + yr.nodeSize && (Ar = vr.findIndexWithChild(fr.node)) > -1 && vr.updateNodeAt(yr, _r, kr, Ar, ar) || vr.updateNextNode(yr, _r, kr, ar, xr, dr) || vr.addNode(yr, _r, kr, ar, dr), dr += yr.nodeSize;
    }), vr.syncToMarks([], ur, ar), this.node.isTextblock && vr.addTextblockHacks(), vr.destroyRest(), (vr.changed || this.dirty == CONTENT_DIRTY) && (gr && this.protectLocalComposition(ar, gr), renderDescs(this.contentDOM, this.children, ar), ios && iosHacks(this.dom));
  }
  localCompositionInfo(ar, lr) {
    let { from: ur, to: dr } = ar.state.selection;
    if (!(ar.state.selection instanceof TextSelection) || ur < lr || dr > lr + this.node.content.size)
      return null;
    let fr = ar.domSelectionRange(), gr = nearbyTextNode(fr.focusNode, fr.focusOffset);
    if (!gr || !this.dom.contains(gr.parentNode))
      return null;
    if (this.node.inlineContent) {
      let mr = gr.nodeValue, vr = findTextInFragment(this.node.content, mr, ur - lr, dr - lr);
      return vr < 0 ? null : { node: gr, pos: vr, text: mr };
    } else
      return { node: gr, pos: -1, text: "" };
  }
  protectLocalComposition(ar, { node: lr, pos: ur, text: dr }) {
    if (this.getDesc(lr))
      return;
    let fr = lr;
    for (; fr.parentNode != this.contentDOM; fr = fr.parentNode) {
      for (; fr.previousSibling; )
        fr.parentNode.removeChild(fr.previousSibling);
      for (; fr.nextSibling; )
        fr.parentNode.removeChild(fr.nextSibling);
      fr.pmViewDesc && (fr.pmViewDesc = void 0);
    }
    let gr = new CompositionViewDesc(this, fr, lr, dr);
    ar.input.compositionNodes.push(gr), this.children = replaceNodes(this.children, ur, ur + dr.length, ar, gr);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(ar, lr, ur, dr) {
    return this.dirty == NODE_DIRTY || !ar.sameMarkup(this.node) ? !1 : (this.updateInner(ar, lr, ur, dr), !0);
  }
  updateInner(ar, lr, ur, dr) {
    this.updateOuterDeco(lr), this.node = ar, this.innerDeco = ur, this.contentDOM && this.updateChildren(dr, this.posAtStart), this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(ar) {
    if (sameOuterDeco(ar, this.outerDeco))
      return;
    let lr = this.nodeDOM.nodeType != 1, ur = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, lr), computeOuterDeco(ar, this.node, lr)), this.dom != ur && (ur.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = ar;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(cr, ar, lr, ur, dr) {
  applyOuterDeco(ur, ar, cr);
  let fr = new NodeViewDesc(void 0, cr, ar, lr, ur, ur, ur, dr, 0);
  return fr.contentDOM && fr.updateChildren(dr, 0), fr;
}
class TextViewDesc extends NodeViewDesc {
  constructor(ar, lr, ur, dr, fr, gr, mr) {
    super(ar, lr, ur, dr, fr, null, gr, mr, 0);
  }
  parseRule() {
    let ar = this.nodeDOM.parentNode;
    for (; ar && ar != this.dom && !ar.pmIsDeco; )
      ar = ar.parentNode;
    return { skip: ar || !0 };
  }
  update(ar, lr, ur, dr) {
    return this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !ar.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(lr), (this.dirty != NOT_DIRTY || ar.text != this.node.text) && ar.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = ar.text, dr.trackWrites == this.nodeDOM && (dr.trackWrites = null)), this.node = ar, this.dirty = NOT_DIRTY, !0);
  }
  inParent() {
    let ar = this.parent.contentDOM;
    for (let lr = this.nodeDOM; lr; lr = lr.parentNode)
      if (lr == ar)
        return !0;
    return !1;
  }
  domFromPos(ar) {
    return { node: this.nodeDOM, offset: ar };
  }
  localPosFromDOM(ar, lr, ur) {
    return ar == this.nodeDOM ? this.posAtStart + Math.min(lr, this.node.text.length) : super.localPosFromDOM(ar, lr, ur);
  }
  ignoreMutation(ar) {
    return ar.type != "characterData" && ar.type != "selection";
  }
  slice(ar, lr, ur) {
    let dr = this.node.cut(ar, lr), fr = document.createTextNode(dr.text);
    return new TextViewDesc(this.parent, dr, this.outerDeco, this.innerDeco, fr, fr, ur);
  }
  markDirty(ar, lr) {
    super.markDirty(ar, lr), this.dom != this.nodeDOM && (ar == 0 || lr == this.nodeDOM.nodeValue.length) && (this.dirty = NODE_DIRTY);
  }
  get domAtom() {
    return !1;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(ar) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == ar;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(ar, lr, ur, dr, fr, gr, mr, vr, yr, _r) {
    super(ar, lr, ur, dr, fr, gr, mr, yr, _r), this.spec = vr;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(ar, lr, ur, dr) {
    if (this.dirty == NODE_DIRTY)
      return !1;
    if (this.spec.update) {
      let fr = this.spec.update(ar, lr, ur);
      return fr && this.updateInner(ar, lr, ur, dr), fr;
    } else
      return !this.contentDOM && !ar.isLeaf ? !1 : super.update(ar, lr, ur, dr);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(ar, lr, ur, dr) {
    this.spec.setSelection ? this.spec.setSelection(ar, lr, ur) : super.setSelection(ar, lr, ur, dr);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(ar) {
    return this.spec.stopEvent ? this.spec.stopEvent(ar) : !1;
  }
  ignoreMutation(ar) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(ar) : super.ignoreMutation(ar);
  }
}
function renderDescs(cr, ar, lr) {
  let ur = cr.firstChild, dr = !1;
  for (let fr = 0; fr < ar.length; fr++) {
    let gr = ar[fr], mr = gr.dom;
    if (mr.parentNode == cr) {
      for (; mr != ur; )
        ur = rm(ur), dr = !0;
      ur = ur.nextSibling;
    } else
      dr = !0, cr.insertBefore(mr, ur);
    if (gr instanceof MarkViewDesc) {
      let vr = ur ? ur.previousSibling : cr.lastChild;
      renderDescs(gr.contentDOM, gr.children, lr), ur = vr ? vr.nextSibling : cr.firstChild;
    }
  }
  for (; ur; )
    ur = rm(ur), dr = !0;
  dr && lr.trackWrites == cr && (lr.trackWrites = null);
}
const OuterDecoLevel = function(cr) {
  cr && (this.nodeName = cr);
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(cr, ar, lr) {
  if (cr.length == 0)
    return noDeco;
  let ur = lr ? noDeco[0] : new OuterDecoLevel(), dr = [ur];
  for (let fr = 0; fr < cr.length; fr++) {
    let gr = cr[fr].type.attrs;
    if (gr) {
      gr.nodeName && dr.push(ur = new OuterDecoLevel(gr.nodeName));
      for (let mr in gr) {
        let vr = gr[mr];
        vr != null && (lr && dr.length == 1 && dr.push(ur = new OuterDecoLevel(ar.isInline ? "span" : "div")), mr == "class" ? ur.class = (ur.class ? ur.class + " " : "") + vr : mr == "style" ? ur.style = (ur.style ? ur.style + ";" : "") + vr : mr != "nodeName" && (ur[mr] = vr));
      }
    }
  }
  return dr;
}
function patchOuterDeco(cr, ar, lr, ur) {
  if (lr == noDeco && ur == noDeco)
    return ar;
  let dr = ar;
  for (let fr = 0; fr < ur.length; fr++) {
    let gr = ur[fr], mr = lr[fr];
    if (fr) {
      let vr;
      mr && mr.nodeName == gr.nodeName && dr != cr && (vr = dr.parentNode) && vr.nodeName.toLowerCase() == gr.nodeName || (vr = document.createElement(gr.nodeName), vr.pmIsDeco = !0, vr.appendChild(dr), mr = noDeco[0]), dr = vr;
    }
    patchAttributes(dr, mr || noDeco[0], gr);
  }
  return dr;
}
function patchAttributes(cr, ar, lr) {
  for (let ur in ar)
    ur != "class" && ur != "style" && ur != "nodeName" && !(ur in lr) && cr.removeAttribute(ur);
  for (let ur in lr)
    ur != "class" && ur != "style" && ur != "nodeName" && lr[ur] != ar[ur] && cr.setAttribute(ur, lr[ur]);
  if (ar.class != lr.class) {
    let ur = ar.class ? ar.class.split(" ").filter(Boolean) : [], dr = lr.class ? lr.class.split(" ").filter(Boolean) : [];
    for (let fr = 0; fr < ur.length; fr++)
      dr.indexOf(ur[fr]) == -1 && cr.classList.remove(ur[fr]);
    for (let fr = 0; fr < dr.length; fr++)
      ur.indexOf(dr[fr]) == -1 && cr.classList.add(dr[fr]);
    cr.classList.length == 0 && cr.removeAttribute("class");
  }
  if (ar.style != lr.style) {
    if (ar.style) {
      let ur = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, dr;
      for (; dr = ur.exec(ar.style); )
        cr.style.removeProperty(dr[1]);
    }
    lr.style && (cr.style.cssText += lr.style);
  }
}
function applyOuterDeco(cr, ar, lr) {
  return patchOuterDeco(cr, cr, noDeco, computeOuterDeco(ar, lr, cr.nodeType != 1));
}
function sameOuterDeco(cr, ar) {
  if (cr.length != ar.length)
    return !1;
  for (let lr = 0; lr < cr.length; lr++)
    if (!cr[lr].type.eq(ar[lr].type))
      return !1;
  return !0;
}
function rm(cr) {
  let ar = cr.nextSibling;
  return cr.parentNode.removeChild(cr), ar;
}
class ViewTreeUpdater {
  constructor(ar, lr, ur) {
    this.lock = lr, this.view = ur, this.index = 0, this.stack = [], this.changed = !1, this.top = ar, this.preMatch = preMatch(ar.node.content, ar);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(ar, lr) {
    if (ar != lr) {
      for (let ur = ar; ur < lr; ur++)
        this.top.children[ur].destroy();
      this.top.children.splice(ar, lr - ar), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(ar, lr, ur) {
    let dr = 0, fr = this.stack.length >> 1, gr = Math.min(fr, ar.length);
    for (; dr < gr && (dr == fr - 1 ? this.top : this.stack[dr + 1 << 1]).matchesMark(ar[dr]) && ar[dr].type.spec.spanning !== !1; )
      dr++;
    for (; dr < fr; )
      this.destroyRest(), this.top.dirty = NOT_DIRTY, this.index = this.stack.pop(), this.top = this.stack.pop(), fr--;
    for (; fr < ar.length; ) {
      this.stack.push(this.top, this.index + 1);
      let mr = -1;
      for (let vr = this.index; vr < Math.min(this.index + 3, this.top.children.length); vr++) {
        let yr = this.top.children[vr];
        if (yr.matchesMark(ar[fr]) && !this.isLocked(yr.dom)) {
          mr = vr;
          break;
        }
      }
      if (mr > -1)
        mr > this.index && (this.changed = !0, this.destroyBetween(this.index, mr)), this.top = this.top.children[this.index];
      else {
        let vr = MarkViewDesc.create(this.top, ar[fr], lr, ur);
        this.top.children.splice(this.index, 0, vr), this.top = vr, this.changed = !0;
      }
      this.index = 0, fr++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(ar, lr, ur, dr) {
    let fr = -1, gr;
    if (dr >= this.preMatch.index && (gr = this.preMatch.matches[dr - this.preMatch.index]).parent == this.top && gr.matchesNode(ar, lr, ur))
      fr = this.top.children.indexOf(gr, this.index);
    else
      for (let mr = this.index, vr = Math.min(this.top.children.length, mr + 5); mr < vr; mr++) {
        let yr = this.top.children[mr];
        if (yr.matchesNode(ar, lr, ur) && !this.preMatch.matched.has(yr)) {
          fr = mr;
          break;
        }
      }
    return fr < 0 ? !1 : (this.destroyBetween(this.index, fr), this.index++, !0);
  }
  updateNodeAt(ar, lr, ur, dr, fr) {
    let gr = this.top.children[dr];
    return gr.dirty == NODE_DIRTY && gr.dom == gr.contentDOM && (gr.dirty = CONTENT_DIRTY), gr.update(ar, lr, ur, fr) ? (this.destroyBetween(this.index, dr), this.index++, !0) : !1;
  }
  findIndexWithChild(ar) {
    for (; ; ) {
      let lr = ar.parentNode;
      if (!lr)
        return -1;
      if (lr == this.top.contentDOM) {
        let ur = ar.pmViewDesc;
        if (ur) {
          for (let dr = this.index; dr < this.top.children.length; dr++)
            if (this.top.children[dr] == ur)
              return dr;
        }
        return -1;
      }
      ar = lr;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(ar, lr, ur, dr, fr, gr) {
    for (let mr = this.index; mr < this.top.children.length; mr++) {
      let vr = this.top.children[mr];
      if (vr instanceof NodeViewDesc) {
        let yr = this.preMatch.matched.get(vr);
        if (yr != null && yr != fr)
          return !1;
        let _r = vr.dom, kr, xr = this.isLocked(_r) && !(ar.isText && vr.node && vr.node.isText && vr.nodeDOM.nodeValue == ar.text && vr.dirty != NODE_DIRTY && sameOuterDeco(lr, vr.outerDeco));
        if (!xr && vr.update(ar, lr, ur, dr))
          return this.destroyBetween(this.index, mr), vr.dom != _r && (this.changed = !0), this.index++, !0;
        if (!xr && (kr = this.recreateWrapper(vr, ar, lr, ur, dr, gr)))
          return this.top.children[this.index] = kr, kr.contentDOM && (kr.dirty = CONTENT_DIRTY, kr.updateChildren(dr, gr + 1), kr.dirty = NOT_DIRTY), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(ar, lr, ur, dr, fr, gr) {
    if (ar.dirty || lr.isAtom || !ar.children.length || !ar.node.content.eq(lr.content))
      return null;
    let mr = NodeViewDesc.create(this.top, lr, ur, dr, fr, gr);
    if (mr.contentDOM) {
      mr.children = ar.children, ar.children = [];
      for (let vr of mr.children)
        vr.parent = mr;
    }
    return ar.destroy(), mr;
  }
  // Insert the node as a newly created node desc.
  addNode(ar, lr, ur, dr, fr) {
    let gr = NodeViewDesc.create(this.top, ar, lr, ur, dr, fr);
    gr.contentDOM && gr.updateChildren(dr, fr + 1), this.top.children.splice(this.index++, 0, gr), this.changed = !0;
  }
  placeWidget(ar, lr, ur) {
    let dr = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (dr && dr.matchesWidget(ar) && (ar == dr.widget || !dr.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let fr = new WidgetViewDesc(this.top, ar, lr, ur);
      this.top.children.splice(this.index++, 0, fr), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let ar = this.top.children[this.index - 1], lr = this.top;
    for (; ar instanceof MarkViewDesc; )
      lr = ar, ar = lr.children[lr.children.length - 1];
    (!ar || // Empty textblock
    !(ar instanceof TextViewDesc) || /\n$/.test(ar.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(ar.node.text)) && ((safari || chrome) && ar && ar.dom.contentEditable == "false" && this.addHackNode("IMG", lr), this.addHackNode("BR", this.top));
  }
  addHackNode(ar, lr) {
    if (lr == this.top && this.index < lr.children.length && lr.children[this.index].matchesHack(ar))
      this.index++;
    else {
      let ur = document.createElement(ar);
      ar == "IMG" && (ur.className = "ProseMirror-separator", ur.alt = ""), ar == "BR" && (ur.className = "ProseMirror-trailingBreak");
      let dr = new TrailingHackViewDesc(this.top, [], ur, null);
      lr != this.top ? lr.children.push(dr) : lr.children.splice(this.index++, 0, dr), this.changed = !0;
    }
  }
  isLocked(ar) {
    return this.lock && (ar == this.lock || ar.nodeType == 1 && ar.contains(this.lock.parentNode));
  }
}
function preMatch(cr, ar) {
  let lr = ar, ur = lr.children.length, dr = cr.childCount, fr = /* @__PURE__ */ new Map(), gr = [];
  e:
    for (; dr > 0; ) {
      let mr;
      for (; ; )
        if (ur) {
          let yr = lr.children[ur - 1];
          if (yr instanceof MarkViewDesc)
            lr = yr, ur = yr.children.length;
          else {
            mr = yr, ur--;
            break;
          }
        } else {
          if (lr == ar)
            break e;
          ur = lr.parent.children.indexOf(lr), lr = lr.parent;
        }
      let vr = mr.node;
      if (vr) {
        if (vr != cr.child(dr - 1))
          break;
        --dr, fr.set(mr, dr), gr.push(mr);
      }
    }
  return { index: dr, matched: fr, matches: gr.reverse() };
}
function compareSide(cr, ar) {
  return cr.type.side - ar.type.side;
}
function iterDeco(cr, ar, lr, ur) {
  let dr = ar.locals(cr), fr = 0;
  if (dr.length == 0) {
    for (let yr = 0; yr < cr.childCount; yr++) {
      let _r = cr.child(yr);
      ur(_r, dr, ar.forChild(fr, _r), yr), fr += _r.nodeSize;
    }
    return;
  }
  let gr = 0, mr = [], vr = null;
  for (let yr = 0; ; ) {
    let _r, kr;
    for (; gr < dr.length && dr[gr].to == fr; ) {
      let Tr = dr[gr++];
      Tr.widget && (_r ? (kr || (kr = [_r])).push(Tr) : _r = Tr);
    }
    if (_r)
      if (kr) {
        kr.sort(compareSide);
        for (let Tr = 0; Tr < kr.length; Tr++)
          lr(kr[Tr], yr, !!vr);
      } else
        lr(_r, yr, !!vr);
    let xr, Ar;
    if (vr)
      Ar = -1, xr = vr, vr = null;
    else if (yr < cr.childCount)
      Ar = yr, xr = cr.child(yr++);
    else
      break;
    for (let Tr = 0; Tr < mr.length; Tr++)
      mr[Tr].to <= fr && mr.splice(Tr--, 1);
    for (; gr < dr.length && dr[gr].from <= fr && dr[gr].to > fr; )
      mr.push(dr[gr++]);
    let Er = fr + xr.nodeSize;
    if (xr.isText) {
      let Tr = Er;
      gr < dr.length && dr[gr].from < Tr && (Tr = dr[gr].from);
      for (let Sr = 0; Sr < mr.length; Sr++)
        mr[Sr].to < Tr && (Tr = mr[Sr].to);
      Tr < Er && (vr = xr.cut(Tr - fr), xr = xr.cut(0, Tr - fr), Er = Tr, Ar = -1);
    }
    let Cr = xr.isInline && !xr.isLeaf ? mr.filter((Tr) => !Tr.inline) : mr.slice();
    ur(xr, Cr, ar.forChild(fr, xr), Ar), fr = Er;
  }
}
function iosHacks(cr) {
  if (cr.nodeName == "UL" || cr.nodeName == "OL") {
    let ar = cr.style.cssText;
    cr.style.cssText = ar + "; list-style: square !important", window.getComputedStyle(cr).listStyle, cr.style.cssText = ar;
  }
}
function nearbyTextNode(cr, ar) {
  for (; ; ) {
    if (cr.nodeType == 3)
      return cr;
    if (cr.nodeType == 1 && ar > 0) {
      if (cr.childNodes.length > ar && cr.childNodes[ar].nodeType == 3)
        return cr.childNodes[ar];
      cr = cr.childNodes[ar - 1], ar = nodeSize(cr);
    } else if (cr.nodeType == 1 && ar < cr.childNodes.length)
      cr = cr.childNodes[ar], ar = 0;
    else
      return null;
  }
}
function findTextInFragment(cr, ar, lr, ur) {
  for (let dr = 0, fr = 0; dr < cr.childCount && fr <= ur; ) {
    let gr = cr.child(dr++), mr = fr;
    if (fr += gr.nodeSize, !gr.isText)
      continue;
    let vr = gr.text;
    for (; dr < cr.childCount; ) {
      let yr = cr.child(dr++);
      if (fr += yr.nodeSize, !yr.isText)
        break;
      vr += yr.text;
    }
    if (fr >= lr) {
      if (fr >= ur && vr.slice(ur - ar.length - mr, ur - mr) == ar)
        return ur - ar.length;
      let yr = mr < ur ? vr.lastIndexOf(ar, ur - mr - 1) : -1;
      if (yr >= 0 && yr + ar.length + mr >= lr)
        return mr + yr;
      if (lr == ur && vr.length >= ur + ar.length - mr && vr.slice(ur - mr, ur - mr + ar.length) == ar)
        return ur;
    }
  }
  return -1;
}
function replaceNodes(cr, ar, lr, ur, dr) {
  let fr = [];
  for (let gr = 0, mr = 0; gr < cr.length; gr++) {
    let vr = cr[gr], yr = mr, _r = mr += vr.size;
    yr >= lr || _r <= ar ? fr.push(vr) : (yr < ar && fr.push(vr.slice(0, ar - yr, ur)), dr && (fr.push(dr), dr = void 0), _r > lr && fr.push(vr.slice(lr - yr, vr.size, ur)));
  }
  return fr;
}
function selectionFromDOM(cr, ar = null) {
  let lr = cr.domSelectionRange(), ur = cr.state.doc;
  if (!lr.focusNode)
    return null;
  let dr = cr.docView.nearestDesc(lr.focusNode), fr = dr && dr.size == 0, gr = cr.docView.posFromDOM(lr.focusNode, lr.focusOffset, 1);
  if (gr < 0)
    return null;
  let mr = ur.resolve(gr), vr, yr;
  if (selectionCollapsed(lr)) {
    for (vr = mr; dr && !dr.node; )
      dr = dr.parent;
    let _r = dr.node;
    if (dr && _r.isAtom && NodeSelection.isSelectable(_r) && dr.parent && !(_r.isInline && isOnEdge(lr.focusNode, lr.focusOffset, dr.dom))) {
      let kr = dr.posBefore;
      yr = new NodeSelection(gr == kr ? mr : ur.resolve(kr));
    }
  } else {
    let _r = cr.docView.posFromDOM(lr.anchorNode, lr.anchorOffset, 1);
    if (_r < 0)
      return null;
    vr = ur.resolve(_r);
  }
  if (!yr) {
    let _r = ar == "pointer" || cr.state.selection.head < mr.pos && !fr ? 1 : -1;
    yr = selectionBetween(cr, vr, mr, _r);
  }
  return yr;
}
function editorOwnsSelection(cr) {
  return cr.editable ? cr.hasFocus() : hasSelection(cr) && document.activeElement && document.activeElement.contains(cr.dom);
}
function selectionToDOM(cr, ar = !1) {
  let lr = cr.state.selection;
  if (syncNodeSelection(cr, lr), !!editorOwnsSelection(cr)) {
    if (!ar && cr.input.mouseDown && cr.input.mouseDown.allowDefault && chrome) {
      let ur = cr.domSelectionRange(), dr = cr.domObserver.currentSelection;
      if (ur.anchorNode && dr.anchorNode && isEquivalentPosition(ur.anchorNode, ur.anchorOffset, dr.anchorNode, dr.anchorOffset)) {
        cr.input.mouseDown.delayedSelectionSync = !0, cr.domObserver.setCurSelection();
        return;
      }
    }
    if (cr.domObserver.disconnectSelection(), cr.cursorWrapper)
      selectCursorWrapper(cr);
    else {
      let { anchor: ur, head: dr } = lr, fr, gr;
      brokenSelectBetweenUneditable && !(lr instanceof TextSelection) && (lr.$from.parent.inlineContent || (fr = temporarilyEditableNear(cr, lr.from)), !lr.empty && !lr.$from.parent.inlineContent && (gr = temporarilyEditableNear(cr, lr.to))), cr.docView.setSelection(ur, dr, cr.root, ar), brokenSelectBetweenUneditable && (fr && resetEditable(fr), gr && resetEditable(gr)), lr.visible ? cr.dom.classList.remove("ProseMirror-hideselection") : (cr.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && removeClassOnSelectionChange(cr));
    }
    cr.domObserver.setCurSelection(), cr.domObserver.connectSelection();
  }
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(cr, ar) {
  let { node: lr, offset: ur } = cr.docView.domFromPos(ar, 0), dr = ur < lr.childNodes.length ? lr.childNodes[ur] : null, fr = ur ? lr.childNodes[ur - 1] : null;
  if (safari && dr && dr.contentEditable == "false")
    return setEditable(dr);
  if ((!dr || dr.contentEditable == "false") && (!fr || fr.contentEditable == "false")) {
    if (dr)
      return setEditable(dr);
    if (fr)
      return setEditable(fr);
  }
}
function setEditable(cr) {
  return cr.contentEditable = "true", safari && cr.draggable && (cr.draggable = !1, cr.wasDraggable = !0), cr;
}
function resetEditable(cr) {
  cr.contentEditable = "false", cr.wasDraggable && (cr.draggable = !0, cr.wasDraggable = null);
}
function removeClassOnSelectionChange(cr) {
  let ar = cr.dom.ownerDocument;
  ar.removeEventListener("selectionchange", cr.input.hideSelectionGuard);
  let lr = cr.domSelectionRange(), ur = lr.anchorNode, dr = lr.anchorOffset;
  ar.addEventListener("selectionchange", cr.input.hideSelectionGuard = () => {
    (lr.anchorNode != ur || lr.anchorOffset != dr) && (ar.removeEventListener("selectionchange", cr.input.hideSelectionGuard), setTimeout(() => {
      (!editorOwnsSelection(cr) || cr.state.selection.visible) && cr.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function selectCursorWrapper(cr) {
  let ar = cr.domSelection(), lr = document.createRange(), ur = cr.cursorWrapper.dom, dr = ur.nodeName == "IMG";
  dr ? lr.setEnd(ur.parentNode, domIndex(ur) + 1) : lr.setEnd(ur, 0), lr.collapse(!1), ar.removeAllRanges(), ar.addRange(lr), !dr && !cr.state.selection.visible && ie$1 && ie_version <= 11 && (ur.disabled = !0, ur.disabled = !1);
}
function syncNodeSelection(cr, ar) {
  if (ar instanceof NodeSelection) {
    let lr = cr.docView.descAt(ar.from);
    lr != cr.lastSelectedViewDesc && (clearNodeSelection(cr), lr && lr.selectNode(), cr.lastSelectedViewDesc = lr);
  } else
    clearNodeSelection(cr);
}
function clearNodeSelection(cr) {
  cr.lastSelectedViewDesc && (cr.lastSelectedViewDesc.parent && cr.lastSelectedViewDesc.deselectNode(), cr.lastSelectedViewDesc = void 0);
}
function selectionBetween(cr, ar, lr, ur) {
  return cr.someProp("createSelectionBetween", (dr) => dr(cr, ar, lr)) || TextSelection.between(ar, lr, ur);
}
function hasFocusAndSelection(cr) {
  return cr.editable && !cr.hasFocus() ? !1 : hasSelection(cr);
}
function hasSelection(cr) {
  let ar = cr.domSelectionRange();
  if (!ar.anchorNode)
    return !1;
  try {
    return cr.dom.contains(ar.anchorNode.nodeType == 3 ? ar.anchorNode.parentNode : ar.anchorNode) && (cr.editable || cr.dom.contains(ar.focusNode.nodeType == 3 ? ar.focusNode.parentNode : ar.focusNode));
  } catch (lr) {
    return !1;
  }
}
function anchorInRightPlace(cr) {
  let ar = cr.docView.domFromPos(cr.state.selection.anchor, 0), lr = cr.domSelectionRange();
  return isEquivalentPosition(ar.node, ar.offset, lr.anchorNode, lr.anchorOffset);
}
function moveSelectionBlock(cr, ar) {
  let { $anchor: lr, $head: ur } = cr.selection, dr = ar > 0 ? lr.max(ur) : lr.min(ur), fr = dr.parent.inlineContent ? dr.depth ? cr.doc.resolve(ar > 0 ? dr.after() : dr.before()) : null : dr;
  return fr && Selection.findFrom(fr, ar);
}
function apply$2(cr, ar) {
  return cr.dispatch(cr.state.tr.setSelection(ar).scrollIntoView()), !0;
}
function selectHorizontally(cr, ar, lr) {
  let ur = cr.state.selection;
  if (ur instanceof TextSelection)
    if (lr.indexOf("s") > -1) {
      let { $head: dr } = ur, fr = dr.textOffset ? null : ar < 0 ? dr.nodeBefore : dr.nodeAfter;
      if (!fr || fr.isText || !fr.isLeaf)
        return !1;
      let gr = cr.state.doc.resolve(dr.pos + fr.nodeSize * (ar < 0 ? -1 : 1));
      return apply$2(cr, new TextSelection(ur.$anchor, gr));
    } else if (ur.empty) {
      if (cr.endOfTextblock(ar > 0 ? "forward" : "backward")) {
        let dr = moveSelectionBlock(cr.state, ar);
        return dr && dr instanceof NodeSelection ? apply$2(cr, dr) : !1;
      } else if (!(mac$3 && lr.indexOf("m") > -1)) {
        let dr = ur.$head, fr = dr.textOffset ? null : ar < 0 ? dr.nodeBefore : dr.nodeAfter, gr;
        if (!fr || fr.isText)
          return !1;
        let mr = ar < 0 ? dr.pos - fr.nodeSize : dr.pos;
        return fr.isAtom || (gr = cr.docView.descAt(mr)) && !gr.contentDOM ? NodeSelection.isSelectable(fr) ? apply$2(cr, new NodeSelection(ar < 0 ? cr.state.doc.resolve(dr.pos - fr.nodeSize) : dr)) : webkit ? apply$2(cr, new TextSelection(cr.state.doc.resolve(ar < 0 ? mr : mr + fr.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (ur instanceof NodeSelection && ur.node.isInline)
      return apply$2(cr, new TextSelection(ar > 0 ? ur.$to : ur.$from));
    {
      let dr = moveSelectionBlock(cr.state, ar);
      return dr ? apply$2(cr, dr) : !1;
    }
  }
}
function nodeLen(cr) {
  return cr.nodeType == 3 ? cr.nodeValue.length : cr.childNodes.length;
}
function isIgnorable(cr, ar) {
  let lr = cr.pmViewDesc;
  return lr && lr.size == 0 && (ar < 0 || cr.nextSibling || cr.nodeName != "BR");
}
function skipIgnoredNodes(cr, ar) {
  return ar < 0 ? skipIgnoredNodesBefore(cr) : skipIgnoredNodesAfter(cr);
}
function skipIgnoredNodesBefore(cr) {
  let ar = cr.domSelectionRange(), lr = ar.focusNode, ur = ar.focusOffset;
  if (!lr)
    return;
  let dr, fr, gr = !1;
  for (gecko && lr.nodeType == 1 && ur < nodeLen(lr) && isIgnorable(lr.childNodes[ur], -1) && (gr = !0); ; )
    if (ur > 0) {
      if (lr.nodeType != 1)
        break;
      {
        let mr = lr.childNodes[ur - 1];
        if (isIgnorable(mr, -1))
          dr = lr, fr = --ur;
        else if (mr.nodeType == 3)
          lr = mr, ur = lr.nodeValue.length;
        else
          break;
      }
    } else {
      if (isBlockNode(lr))
        break;
      {
        let mr = lr.previousSibling;
        for (; mr && isIgnorable(mr, -1); )
          dr = lr.parentNode, fr = domIndex(mr), mr = mr.previousSibling;
        if (mr)
          lr = mr, ur = nodeLen(lr);
        else {
          if (lr = lr.parentNode, lr == cr.dom)
            break;
          ur = 0;
        }
      }
    }
  gr ? setSelFocus(cr, lr, ur) : dr && setSelFocus(cr, dr, fr);
}
function skipIgnoredNodesAfter(cr) {
  let ar = cr.domSelectionRange(), lr = ar.focusNode, ur = ar.focusOffset;
  if (!lr)
    return;
  let dr = nodeLen(lr), fr, gr;
  for (; ; )
    if (ur < dr) {
      if (lr.nodeType != 1)
        break;
      let mr = lr.childNodes[ur];
      if (isIgnorable(mr, 1))
        fr = lr, gr = ++ur;
      else
        break;
    } else {
      if (isBlockNode(lr))
        break;
      {
        let mr = lr.nextSibling;
        for (; mr && isIgnorable(mr, 1); )
          fr = mr.parentNode, gr = domIndex(mr) + 1, mr = mr.nextSibling;
        if (mr)
          lr = mr, ur = 0, dr = nodeLen(lr);
        else {
          if (lr = lr.parentNode, lr == cr.dom)
            break;
          ur = dr = 0;
        }
      }
    }
  fr && setSelFocus(cr, fr, gr);
}
function isBlockNode(cr) {
  let ar = cr.pmViewDesc;
  return ar && ar.node && ar.node.isBlock;
}
function textNodeAfter(cr, ar) {
  for (; cr && ar == cr.childNodes.length && !hasBlockDesc(cr); )
    ar = domIndex(cr) + 1, cr = cr.parentNode;
  for (; cr && ar < cr.childNodes.length; ) {
    let lr = cr.childNodes[ar];
    if (lr.nodeType == 3)
      return lr;
    if (lr.nodeType == 1 && lr.contentEditable == "false")
      break;
    cr = lr, ar = 0;
  }
}
function textNodeBefore(cr, ar) {
  for (; cr && !ar && !hasBlockDesc(cr); )
    ar = domIndex(cr), cr = cr.parentNode;
  for (; cr && ar; ) {
    let lr = cr.childNodes[ar - 1];
    if (lr.nodeType == 3)
      return lr;
    if (lr.nodeType == 1 && lr.contentEditable == "false")
      break;
    cr = lr, ar = cr.childNodes.length;
  }
}
function setSelFocus(cr, ar, lr) {
  if (ar.nodeType != 3) {
    let fr, gr;
    (gr = textNodeAfter(ar, lr)) ? (ar = gr, lr = 0) : (fr = textNodeBefore(ar, lr)) && (ar = fr, lr = fr.nodeValue.length);
  }
  let ur = cr.domSelection();
  if (selectionCollapsed(ur)) {
    let fr = document.createRange();
    fr.setEnd(ar, lr), fr.setStart(ar, lr), ur.removeAllRanges(), ur.addRange(fr);
  } else
    ur.extend && ur.extend(ar, lr);
  cr.domObserver.setCurSelection();
  let { state: dr } = cr;
  setTimeout(() => {
    cr.state == dr && selectionToDOM(cr);
  }, 50);
}
function findDirection(cr, ar) {
  let lr = cr.state.doc.resolve(ar);
  if (!(chrome || windows) && lr.parent.inlineContent) {
    let dr = cr.coordsAtPos(ar);
    if (ar > lr.start()) {
      let fr = cr.coordsAtPos(ar - 1), gr = (fr.top + fr.bottom) / 2;
      if (gr > dr.top && gr < dr.bottom && Math.abs(fr.left - dr.left) > 1)
        return fr.left < dr.left ? "ltr" : "rtl";
    }
    if (ar < lr.end()) {
      let fr = cr.coordsAtPos(ar + 1), gr = (fr.top + fr.bottom) / 2;
      if (gr > dr.top && gr < dr.bottom && Math.abs(fr.left - dr.left) > 1)
        return fr.left > dr.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(cr.dom).direction == "rtl" ? "rtl" : "ltr";
}
function selectVertically(cr, ar, lr) {
  let ur = cr.state.selection;
  if (ur instanceof TextSelection && !ur.empty || lr.indexOf("s") > -1 || mac$3 && lr.indexOf("m") > -1)
    return !1;
  let { $from: dr, $to: fr } = ur;
  if (!dr.parent.inlineContent || cr.endOfTextblock(ar < 0 ? "up" : "down")) {
    let gr = moveSelectionBlock(cr.state, ar);
    if (gr && gr instanceof NodeSelection)
      return apply$2(cr, gr);
  }
  if (!dr.parent.inlineContent) {
    let gr = ar < 0 ? dr : fr, mr = ur instanceof AllSelection ? Selection.near(gr, ar) : Selection.findFrom(gr, ar);
    return mr ? apply$2(cr, mr) : !1;
  }
  return !1;
}
function stopNativeHorizontalDelete(cr, ar) {
  if (!(cr.state.selection instanceof TextSelection))
    return !0;
  let { $head: lr, $anchor: ur, empty: dr } = cr.state.selection;
  if (!lr.sameParent(ur))
    return !0;
  if (!dr)
    return !1;
  if (cr.endOfTextblock(ar > 0 ? "forward" : "backward"))
    return !0;
  let fr = !lr.textOffset && (ar < 0 ? lr.nodeBefore : lr.nodeAfter);
  if (fr && !fr.isText) {
    let gr = cr.state.tr;
    return ar < 0 ? gr.delete(lr.pos - fr.nodeSize, lr.pos) : gr.delete(lr.pos, lr.pos + fr.nodeSize), cr.dispatch(gr), !0;
  }
  return !1;
}
function switchEditable(cr, ar, lr) {
  cr.domObserver.stop(), ar.contentEditable = lr, cr.domObserver.start();
}
function safariDownArrowBug(cr) {
  if (!safari || cr.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: ar, focusOffset: lr } = cr.domSelectionRange();
  if (ar && ar.nodeType == 1 && lr == 0 && ar.firstChild && ar.firstChild.contentEditable == "false") {
    let ur = ar.firstChild;
    switchEditable(cr, ur, "true"), setTimeout(() => switchEditable(cr, ur, "false"), 20);
  }
  return !1;
}
function getMods(cr) {
  let ar = "";
  return cr.ctrlKey && (ar += "c"), cr.metaKey && (ar += "m"), cr.altKey && (ar += "a"), cr.shiftKey && (ar += "s"), ar;
}
function captureKeyDown(cr, ar) {
  let lr = ar.keyCode, ur = getMods(ar);
  if (lr == 8 || mac$3 && lr == 72 && ur == "c")
    return stopNativeHorizontalDelete(cr, -1) || skipIgnoredNodes(cr, -1);
  if (lr == 46 && !ar.shiftKey || mac$3 && lr == 68 && ur == "c")
    return stopNativeHorizontalDelete(cr, 1) || skipIgnoredNodes(cr, 1);
  if (lr == 13 || lr == 27)
    return !0;
  if (lr == 37 || mac$3 && lr == 66 && ur == "c") {
    let dr = lr == 37 ? findDirection(cr, cr.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(cr, dr, ur) || skipIgnoredNodes(cr, dr);
  } else if (lr == 39 || mac$3 && lr == 70 && ur == "c") {
    let dr = lr == 39 ? findDirection(cr, cr.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(cr, dr, ur) || skipIgnoredNodes(cr, dr);
  } else {
    if (lr == 38 || mac$3 && lr == 80 && ur == "c")
      return selectVertically(cr, -1, ur) || skipIgnoredNodes(cr, -1);
    if (lr == 40 || mac$3 && lr == 78 && ur == "c")
      return safariDownArrowBug(cr) || selectVertically(cr, 1, ur) || skipIgnoredNodes(cr, 1);
    if (ur == (mac$3 ? "m" : "c") && (lr == 66 || lr == 73 || lr == 89 || lr == 90))
      return !0;
  }
  return !1;
}
function serializeForClipboard(cr, ar) {
  cr.someProp("transformCopied", (Ar) => {
    ar = Ar(ar, cr);
  });
  let lr = [], { content: ur, openStart: dr, openEnd: fr } = ar;
  for (; dr > 1 && fr > 1 && ur.childCount == 1 && ur.firstChild.childCount == 1; ) {
    dr--, fr--;
    let Ar = ur.firstChild;
    lr.push(Ar.type.name, Ar.attrs != Ar.type.defaultAttrs ? Ar.attrs : null), ur = Ar.content;
  }
  let gr = cr.someProp("clipboardSerializer") || DOMSerializer.fromSchema(cr.state.schema), mr = detachedDoc(), vr = mr.createElement("div");
  vr.appendChild(gr.serializeFragment(ur, { document: mr }));
  let yr = vr.firstChild, _r, kr = 0;
  for (; yr && yr.nodeType == 1 && (_r = wrapMap[yr.nodeName.toLowerCase()]); ) {
    for (let Ar = _r.length - 1; Ar >= 0; Ar--) {
      let Er = mr.createElement(_r[Ar]);
      for (; vr.firstChild; )
        Er.appendChild(vr.firstChild);
      vr.appendChild(Er), kr++;
    }
    yr = vr.firstChild;
  }
  yr && yr.nodeType == 1 && yr.setAttribute("data-pm-slice", `${dr} ${fr}${kr ? ` -${kr}` : ""} ${JSON.stringify(lr)}`);
  let xr = cr.someProp("clipboardTextSerializer", (Ar) => Ar(ar, cr)) || ar.content.textBetween(0, ar.content.size, `

`);
  return { dom: vr, text: xr };
}
function parseFromClipboard(cr, ar, lr, ur, dr) {
  let fr = dr.parent.type.spec.code, gr, mr;
  if (!lr && !ar)
    return null;
  let vr = ar && (ur || fr || !lr);
  if (vr) {
    if (cr.someProp("transformPastedText", (xr) => {
      ar = xr(ar, fr || ur, cr);
    }), fr)
      return ar ? new Slice(Fragment.from(cr.state.schema.text(ar.replace(/\r\n?/g, `
`))), 0, 0) : Slice.empty;
    let kr = cr.someProp("clipboardTextParser", (xr) => xr(ar, dr, ur, cr));
    if (kr)
      mr = kr;
    else {
      let xr = dr.marks(), { schema: Ar } = cr.state, Er = DOMSerializer.fromSchema(Ar);
      gr = document.createElement("div"), ar.split(/(?:\r\n?|\n)+/).forEach((Cr) => {
        let Tr = gr.appendChild(document.createElement("p"));
        Cr && Tr.appendChild(Er.serializeNode(Ar.text(Cr, xr)));
      });
    }
  } else
    cr.someProp("transformPastedHTML", (kr) => {
      lr = kr(lr, cr);
    }), gr = readHTML(lr), webkit && restoreReplacedSpaces(gr);
  let yr = gr && gr.querySelector("[data-pm-slice]"), _r = yr && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(yr.getAttribute("data-pm-slice") || "");
  if (_r && _r[3])
    for (let kr = +_r[3]; kr > 0; kr--) {
      let xr = gr.firstChild;
      for (; xr && xr.nodeType != 1; )
        xr = xr.nextSibling;
      if (!xr)
        break;
      gr = xr;
    }
  if (mr || (mr = (cr.someProp("clipboardParser") || cr.someProp("domParser") || DOMParser.fromSchema(cr.state.schema)).parseSlice(gr, {
    preserveWhitespace: !!(vr || _r),
    context: dr,
    ruleFromNode(xr) {
      return xr.nodeName == "BR" && !xr.nextSibling && xr.parentNode && !inlineParents.test(xr.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), _r)
    mr = addContext(closeSlice(mr, +_r[1], +_r[2]), _r[4]);
  else if (mr = Slice.maxOpen(normalizeSiblings(mr.content, dr), !0), mr.openStart || mr.openEnd) {
    let kr = 0, xr = 0;
    for (let Ar = mr.content.firstChild; kr < mr.openStart && !Ar.type.spec.isolating; kr++, Ar = Ar.firstChild)
      ;
    for (let Ar = mr.content.lastChild; xr < mr.openEnd && !Ar.type.spec.isolating; xr++, Ar = Ar.lastChild)
      ;
    mr = closeSlice(mr, kr, xr);
  }
  return cr.someProp("transformPasted", (kr) => {
    mr = kr(mr, cr);
  }), mr;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(cr, ar) {
  if (cr.childCount < 2)
    return cr;
  for (let lr = ar.depth; lr >= 0; lr--) {
    let dr = ar.node(lr).contentMatchAt(ar.index(lr)), fr, gr = [];
    if (cr.forEach((mr) => {
      if (!gr)
        return;
      let vr = dr.findWrapping(mr.type), yr;
      if (!vr)
        return gr = null;
      if (yr = gr.length && fr.length && addToSibling(vr, fr, mr, gr[gr.length - 1], 0))
        gr[gr.length - 1] = yr;
      else {
        gr.length && (gr[gr.length - 1] = closeRight(gr[gr.length - 1], fr.length));
        let _r = withWrappers(mr, vr);
        gr.push(_r), dr = dr.matchType(_r.type), fr = vr;
      }
    }), gr)
      return Fragment.from(gr);
  }
  return cr;
}
function withWrappers(cr, ar, lr = 0) {
  for (let ur = ar.length - 1; ur >= lr; ur--)
    cr = ar[ur].create(null, Fragment.from(cr));
  return cr;
}
function addToSibling(cr, ar, lr, ur, dr) {
  if (dr < cr.length && dr < ar.length && cr[dr] == ar[dr]) {
    let fr = addToSibling(cr, ar, lr, ur.lastChild, dr + 1);
    if (fr)
      return ur.copy(ur.content.replaceChild(ur.childCount - 1, fr));
    if (ur.contentMatchAt(ur.childCount).matchType(dr == cr.length - 1 ? lr.type : cr[dr + 1]))
      return ur.copy(ur.content.append(Fragment.from(withWrappers(lr, cr, dr + 1))));
  }
}
function closeRight(cr, ar) {
  if (ar == 0)
    return cr;
  let lr = cr.content.replaceChild(cr.childCount - 1, closeRight(cr.lastChild, ar - 1)), ur = cr.contentMatchAt(cr.childCount).fillBefore(Fragment.empty, !0);
  return cr.copy(lr.append(ur));
}
function closeRange(cr, ar, lr, ur, dr, fr) {
  let gr = ar < 0 ? cr.firstChild : cr.lastChild, mr = gr.content;
  return cr.childCount > 1 && (fr = 0), dr < ur - 1 && (mr = closeRange(mr, ar, lr, ur, dr + 1, fr)), dr >= lr && (mr = ar < 0 ? gr.contentMatchAt(0).fillBefore(mr, fr <= dr).append(mr) : mr.append(gr.contentMatchAt(gr.childCount).fillBefore(Fragment.empty, !0))), cr.replaceChild(ar < 0 ? 0 : cr.childCount - 1, gr.copy(mr));
}
function closeSlice(cr, ar, lr) {
  return ar < cr.openStart && (cr = new Slice(closeRange(cr.content, -1, ar, cr.openStart, 0, cr.openEnd), ar, cr.openEnd)), lr < cr.openEnd && (cr = new Slice(closeRange(cr.content, 1, lr, cr.openEnd, 0, 0), cr.openStart, lr)), cr;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(cr) {
  let ar = /^(\s*<meta [^>]*>)*/.exec(cr);
  ar && (cr = cr.slice(ar[0].length));
  let lr = detachedDoc().createElement("div"), ur = /<([a-z][^>\s]+)/i.exec(cr), dr;
  if ((dr = ur && wrapMap[ur[1].toLowerCase()]) && (cr = dr.map((fr) => "<" + fr + ">").join("") + cr + dr.map((fr) => "</" + fr + ">").reverse().join("")), lr.innerHTML = cr, dr)
    for (let fr = 0; fr < dr.length; fr++)
      lr = lr.querySelector(dr[fr]) || lr;
  return lr;
}
function restoreReplacedSpaces(cr) {
  let ar = cr.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let lr = 0; lr < ar.length; lr++) {
    let ur = ar[lr];
    ur.childNodes.length == 1 && ur.textContent == "" && ur.parentNode && ur.parentNode.replaceChild(cr.ownerDocument.createTextNode(" "), ur);
  }
}
function addContext(cr, ar) {
  if (!cr.size)
    return cr;
  let lr = cr.content.firstChild.type.schema, ur;
  try {
    ur = JSON.parse(ar);
  } catch (mr) {
    return cr;
  }
  let { content: dr, openStart: fr, openEnd: gr } = cr;
  for (let mr = ur.length - 2; mr >= 0; mr -= 2) {
    let vr = lr.nodes[ur[mr]];
    if (!vr || vr.hasRequiredAttrs())
      break;
    dr = Fragment.from(vr.create(ur[mr + 1], dr)), fr++, gr++;
  }
  return new Slice(dr, fr, gr);
}
const handlers = {}, editHandlers = {}, passiveHandlers = { touchstart: !0, touchmove: !0 };
class InputState {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function initInput(cr) {
  for (let ar in handlers) {
    let lr = handlers[ar];
    cr.dom.addEventListener(ar, cr.input.eventHandlers[ar] = (ur) => {
      eventBelongsToView(cr, ur) && !runCustomHandler(cr, ur) && (cr.editable || !(ur.type in editHandlers)) && lr(cr, ur);
    }, passiveHandlers[ar] ? { passive: !0 } : void 0);
  }
  safari && cr.dom.addEventListener("input", () => null), ensureListeners(cr);
}
function setSelectionOrigin(cr, ar) {
  cr.input.lastSelectionOrigin = ar, cr.input.lastSelectionTime = Date.now();
}
function destroyInput(cr) {
  cr.domObserver.stop();
  for (let ar in cr.input.eventHandlers)
    cr.dom.removeEventListener(ar, cr.input.eventHandlers[ar]);
  clearTimeout(cr.input.composingTimeout), clearTimeout(cr.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(cr) {
  cr.someProp("handleDOMEvents", (ar) => {
    for (let lr in ar)
      cr.input.eventHandlers[lr] || cr.dom.addEventListener(lr, cr.input.eventHandlers[lr] = (ur) => runCustomHandler(cr, ur));
  });
}
function runCustomHandler(cr, ar) {
  return cr.someProp("handleDOMEvents", (lr) => {
    let ur = lr[ar.type];
    return ur ? ur(cr, ar) || ar.defaultPrevented : !1;
  });
}
function eventBelongsToView(cr, ar) {
  if (!ar.bubbles)
    return !0;
  if (ar.defaultPrevented)
    return !1;
  for (let lr = ar.target; lr != cr.dom; lr = lr.parentNode)
    if (!lr || lr.nodeType == 11 || lr.pmViewDesc && lr.pmViewDesc.stopEvent(ar))
      return !1;
  return !0;
}
function dispatchEvent$1(cr, ar) {
  !runCustomHandler(cr, ar) && handlers[ar.type] && (cr.editable || !(ar.type in editHandlers)) && handlers[ar.type](cr, ar);
}
editHandlers.keydown = (cr, ar) => {
  let lr = ar;
  if (cr.input.shiftKey = lr.keyCode == 16 || lr.shiftKey, !inOrNearComposition(cr, lr) && (cr.input.lastKeyCode = lr.keyCode, cr.input.lastKeyCodeTime = Date.now(), !(android && chrome && lr.keyCode == 13)))
    if (lr.keyCode != 229 && cr.domObserver.forceFlush(), ios && lr.keyCode == 13 && !lr.ctrlKey && !lr.altKey && !lr.metaKey) {
      let ur = Date.now();
      cr.input.lastIOSEnter = ur, cr.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        cr.input.lastIOSEnter == ur && (cr.someProp("handleKeyDown", (dr) => dr(cr, keyEvent(13, "Enter"))), cr.input.lastIOSEnter = 0);
      }, 200);
    } else
      cr.someProp("handleKeyDown", (ur) => ur(cr, lr)) || captureKeyDown(cr, lr) ? lr.preventDefault() : setSelectionOrigin(cr, "key");
};
editHandlers.keyup = (cr, ar) => {
  ar.keyCode == 16 && (cr.input.shiftKey = !1);
};
editHandlers.keypress = (cr, ar) => {
  let lr = ar;
  if (inOrNearComposition(cr, lr) || !lr.charCode || lr.ctrlKey && !lr.altKey || mac$3 && lr.metaKey)
    return;
  if (cr.someProp("handleKeyPress", (dr) => dr(cr, lr))) {
    lr.preventDefault();
    return;
  }
  let ur = cr.state.selection;
  if (!(ur instanceof TextSelection) || !ur.$from.sameParent(ur.$to)) {
    let dr = String.fromCharCode(lr.charCode);
    !/[\r\n]/.test(dr) && !cr.someProp("handleTextInput", (fr) => fr(cr, ur.$from.pos, ur.$to.pos, dr)) && cr.dispatch(cr.state.tr.insertText(dr).scrollIntoView()), lr.preventDefault();
  }
};
function eventCoords(cr) {
  return { left: cr.clientX, top: cr.clientY };
}
function isNear(cr, ar) {
  let lr = ar.x - cr.clientX, ur = ar.y - cr.clientY;
  return lr * lr + ur * ur < 100;
}
function runHandlerOnContext(cr, ar, lr, ur, dr) {
  if (ur == -1)
    return !1;
  let fr = cr.state.doc.resolve(ur);
  for (let gr = fr.depth + 1; gr > 0; gr--)
    if (cr.someProp(ar, (mr) => gr > fr.depth ? mr(cr, lr, fr.nodeAfter, fr.before(gr), dr, !0) : mr(cr, lr, fr.node(gr), fr.before(gr), dr, !1)))
      return !0;
  return !1;
}
function updateSelection(cr, ar, lr) {
  cr.focused || cr.focus();
  let ur = cr.state.tr.setSelection(ar);
  lr == "pointer" && ur.setMeta("pointer", !0), cr.dispatch(ur);
}
function selectClickedLeaf(cr, ar) {
  if (ar == -1)
    return !1;
  let lr = cr.state.doc.resolve(ar), ur = lr.nodeAfter;
  return ur && ur.isAtom && NodeSelection.isSelectable(ur) ? (updateSelection(cr, new NodeSelection(lr), "pointer"), !0) : !1;
}
function selectClickedNode(cr, ar) {
  if (ar == -1)
    return !1;
  let lr = cr.state.selection, ur, dr;
  lr instanceof NodeSelection && (ur = lr.node);
  let fr = cr.state.doc.resolve(ar);
  for (let gr = fr.depth + 1; gr > 0; gr--) {
    let mr = gr > fr.depth ? fr.nodeAfter : fr.node(gr);
    if (NodeSelection.isSelectable(mr)) {
      ur && lr.$from.depth > 0 && gr >= lr.$from.depth && fr.before(lr.$from.depth + 1) == lr.$from.pos ? dr = fr.before(lr.$from.depth) : dr = fr.before(gr);
      break;
    }
  }
  return dr != null ? (updateSelection(cr, NodeSelection.create(cr.state.doc, dr), "pointer"), !0) : !1;
}
function handleSingleClick(cr, ar, lr, ur, dr) {
  return runHandlerOnContext(cr, "handleClickOn", ar, lr, ur) || cr.someProp("handleClick", (fr) => fr(cr, ar, ur)) || (dr ? selectClickedNode(cr, lr) : selectClickedLeaf(cr, lr));
}
function handleDoubleClick(cr, ar, lr, ur) {
  return runHandlerOnContext(cr, "handleDoubleClickOn", ar, lr, ur) || cr.someProp("handleDoubleClick", (dr) => dr(cr, ar, ur));
}
function handleTripleClick(cr, ar, lr, ur) {
  return runHandlerOnContext(cr, "handleTripleClickOn", ar, lr, ur) || cr.someProp("handleTripleClick", (dr) => dr(cr, ar, ur)) || defaultTripleClick(cr, lr, ur);
}
function defaultTripleClick(cr, ar, lr) {
  if (lr.button != 0)
    return !1;
  let ur = cr.state.doc;
  if (ar == -1)
    return ur.inlineContent ? (updateSelection(cr, TextSelection.create(ur, 0, ur.content.size), "pointer"), !0) : !1;
  let dr = ur.resolve(ar);
  for (let fr = dr.depth + 1; fr > 0; fr--) {
    let gr = fr > dr.depth ? dr.nodeAfter : dr.node(fr), mr = dr.before(fr);
    if (gr.inlineContent)
      updateSelection(cr, TextSelection.create(ur, mr + 1, mr + 1 + gr.content.size), "pointer");
    else if (NodeSelection.isSelectable(gr))
      updateSelection(cr, NodeSelection.create(ur, mr), "pointer");
    else
      continue;
    return !0;
  }
}
function forceDOMFlush(cr) {
  return endComposition(cr);
}
const selectNodeModifier = mac$3 ? "metaKey" : "ctrlKey";
handlers.mousedown = (cr, ar) => {
  let lr = ar;
  cr.input.shiftKey = lr.shiftKey;
  let ur = forceDOMFlush(cr), dr = Date.now(), fr = "singleClick";
  dr - cr.input.lastClick.time < 500 && isNear(lr, cr.input.lastClick) && !lr[selectNodeModifier] && (cr.input.lastClick.type == "singleClick" ? fr = "doubleClick" : cr.input.lastClick.type == "doubleClick" && (fr = "tripleClick")), cr.input.lastClick = { time: dr, x: lr.clientX, y: lr.clientY, type: fr };
  let gr = cr.posAtCoords(eventCoords(lr));
  gr && (fr == "singleClick" ? (cr.input.mouseDown && cr.input.mouseDown.done(), cr.input.mouseDown = new MouseDown(cr, gr, lr, !!ur)) : (fr == "doubleClick" ? handleDoubleClick : handleTripleClick)(cr, gr.pos, gr.inside, lr) ? lr.preventDefault() : setSelectionOrigin(cr, "pointer"));
};
class MouseDown {
  constructor(ar, lr, ur, dr) {
    this.view = ar, this.pos = lr, this.event = ur, this.flushed = dr, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = ar.state.doc, this.selectNode = !!ur[selectNodeModifier], this.allowDefault = ur.shiftKey;
    let fr, gr;
    if (lr.inside > -1)
      fr = ar.state.doc.nodeAt(lr.inside), gr = lr.inside;
    else {
      let _r = ar.state.doc.resolve(lr.pos);
      fr = _r.parent, gr = _r.depth ? _r.before() : 0;
    }
    const mr = dr ? null : ur.target, vr = mr ? ar.docView.nearestDesc(mr, !0) : null;
    this.target = vr ? vr.dom : null;
    let { selection: yr } = ar.state;
    (ur.button == 0 && fr.type.spec.draggable && fr.type.spec.selectable !== !1 || yr instanceof NodeSelection && yr.from <= gr && yr.to > gr) && (this.mightDrag = {
      node: fr,
      pos: gr,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), ar.root.addEventListener("mouseup", this.up = this.up.bind(this)), ar.root.addEventListener("mousemove", this.move = this.move.bind(this)), setSelectionOrigin(ar, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => selectionToDOM(this.view)), this.view.input.mouseDown = null;
  }
  up(ar) {
    if (this.done(), !this.view.dom.contains(ar.target))
      return;
    let lr = this.pos;
    this.view.state.doc != this.startDoc && (lr = this.view.posAtCoords(eventCoords(ar))), this.updateAllowDefault(ar), this.allowDefault || !lr ? setSelectionOrigin(this.view, "pointer") : handleSingleClick(this.view, lr.pos, lr.inside, ar, this.selectNode) ? ar.preventDefault() : ar.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(lr.pos - this.view.state.selection.from), Math.abs(lr.pos - this.view.state.selection.to)) <= 2) ? (updateSelection(this.view, Selection.near(this.view.state.doc.resolve(lr.pos)), "pointer"), ar.preventDefault()) : setSelectionOrigin(this.view, "pointer");
  }
  move(ar) {
    this.updateAllowDefault(ar), setSelectionOrigin(this.view, "pointer"), ar.buttons == 0 && this.done();
  }
  updateAllowDefault(ar) {
    !this.allowDefault && (Math.abs(this.event.x - ar.clientX) > 4 || Math.abs(this.event.y - ar.clientY) > 4) && (this.allowDefault = !0);
  }
}
handlers.touchstart = (cr) => {
  cr.input.lastTouch = Date.now(), forceDOMFlush(cr), setSelectionOrigin(cr, "pointer");
};
handlers.touchmove = (cr) => {
  cr.input.lastTouch = Date.now(), setSelectionOrigin(cr, "pointer");
};
handlers.contextmenu = (cr) => forceDOMFlush(cr);
function inOrNearComposition(cr, ar) {
  return cr.composing ? !0 : safari && Math.abs(ar.timeStamp - cr.input.compositionEndedAt) < 500 ? (cr.input.compositionEndedAt = -2e8, !0) : !1;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (cr) => {
  if (!cr.composing) {
    cr.domObserver.flush();
    let { state: ar } = cr, lr = ar.selection.$from;
    if (ar.selection.empty && (ar.storedMarks || !lr.textOffset && lr.parentOffset && lr.nodeBefore.marks.some((ur) => ur.type.spec.inclusive === !1)))
      cr.markCursor = cr.state.storedMarks || lr.marks(), endComposition(cr, !0), cr.markCursor = null;
    else if (endComposition(cr), gecko && ar.selection.empty && lr.parentOffset && !lr.textOffset && lr.nodeBefore.marks.length) {
      let ur = cr.domSelectionRange();
      for (let dr = ur.focusNode, fr = ur.focusOffset; dr && dr.nodeType == 1 && fr != 0; ) {
        let gr = fr < 0 ? dr.lastChild : dr.childNodes[fr - 1];
        if (!gr)
          break;
        if (gr.nodeType == 3) {
          cr.domSelection().collapse(gr, gr.nodeValue.length);
          break;
        } else
          dr = gr, fr = -1;
      }
    }
    cr.input.composing = !0;
  }
  scheduleComposeEnd(cr, timeoutComposition);
};
editHandlers.compositionend = (cr, ar) => {
  cr.composing && (cr.input.composing = !1, cr.input.compositionEndedAt = ar.timeStamp, cr.input.compositionPendingChanges = cr.domObserver.pendingRecords().length ? cr.input.compositionID : 0, cr.input.compositionPendingChanges && Promise.resolve().then(() => cr.domObserver.flush()), cr.input.compositionID++, scheduleComposeEnd(cr, 20));
};
function scheduleComposeEnd(cr, ar) {
  clearTimeout(cr.input.composingTimeout), ar > -1 && (cr.input.composingTimeout = setTimeout(() => endComposition(cr), ar));
}
function clearComposition(cr) {
  for (cr.composing && (cr.input.composing = !1, cr.input.compositionEndedAt = timestampFromCustomEvent()); cr.input.compositionNodes.length > 0; )
    cr.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let cr = document.createEvent("Event");
  return cr.initEvent("event", !0, !0), cr.timeStamp;
}
function endComposition(cr, ar = !1) {
  if (!(android && cr.domObserver.flushingSoon >= 0)) {
    if (cr.domObserver.forceFlush(), clearComposition(cr), ar || cr.docView && cr.docView.dirty) {
      let lr = selectionFromDOM(cr);
      return lr && !lr.eq(cr.state.selection) ? cr.dispatch(cr.state.tr.setSelection(lr)) : cr.updateState(cr.state), !0;
    }
    return !1;
  }
}
function captureCopy(cr, ar) {
  if (!cr.dom.parentNode)
    return;
  let lr = cr.dom.parentNode.appendChild(document.createElement("div"));
  lr.appendChild(ar), lr.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let ur = getSelection(), dr = document.createRange();
  dr.selectNodeContents(ar), cr.dom.blur(), ur.removeAllRanges(), ur.addRange(dr), setTimeout(() => {
    lr.parentNode && lr.parentNode.removeChild(lr), cr.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (cr, ar) => {
  let lr = ar, ur = cr.state.selection, dr = lr.type == "cut";
  if (ur.empty)
    return;
  let fr = brokenClipboardAPI ? null : lr.clipboardData, gr = ur.content(), { dom: mr, text: vr } = serializeForClipboard(cr, gr);
  fr ? (lr.preventDefault(), fr.clearData(), fr.setData("text/html", mr.innerHTML), fr.setData("text/plain", vr)) : captureCopy(cr, mr), dr && cr.dispatch(cr.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(cr) {
  return cr.openStart == 0 && cr.openEnd == 0 && cr.content.childCount == 1 ? cr.content.firstChild : null;
}
function capturePaste(cr, ar) {
  if (!cr.dom.parentNode)
    return;
  let lr = cr.input.shiftKey || cr.state.selection.$from.parent.type.spec.code, ur = cr.dom.parentNode.appendChild(document.createElement(lr ? "textarea" : "div"));
  lr || (ur.contentEditable = "true"), ur.style.cssText = "position: fixed; left: -10000px; top: 10px", ur.focus();
  let dr = cr.input.shiftKey && cr.input.lastKeyCode != 45;
  setTimeout(() => {
    cr.focus(), ur.parentNode && ur.parentNode.removeChild(ur), lr ? doPaste(cr, ur.value, null, dr, ar) : doPaste(cr, ur.textContent, ur.innerHTML, dr, ar);
  }, 50);
}
function doPaste(cr, ar, lr, ur, dr) {
  let fr = parseFromClipboard(cr, ar, lr, ur, cr.state.selection.$from);
  if (cr.someProp("handlePaste", (vr) => vr(cr, dr, fr || Slice.empty)))
    return !0;
  if (!fr)
    return !1;
  let gr = sliceSingleNode(fr), mr = gr ? cr.state.tr.replaceSelectionWith(gr, ur) : cr.state.tr.replaceSelection(fr);
  return cr.dispatch(mr.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function getText(cr) {
  let ar = cr.getData("text/plain") || cr.getData("Text");
  if (ar)
    return ar;
  let lr = cr.getData("text/uri-list");
  return lr ? lr.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (cr, ar) => {
  let lr = ar;
  if (cr.composing && !android)
    return;
  let ur = brokenClipboardAPI ? null : lr.clipboardData, dr = cr.input.shiftKey && cr.input.lastKeyCode != 45;
  ur && doPaste(cr, getText(ur), ur.getData("text/html"), dr, lr) ? lr.preventDefault() : capturePaste(cr, lr);
};
class Dragging {
  constructor(ar, lr, ur) {
    this.slice = ar, this.move = lr, this.node = ur;
  }
}
const dragCopyModifier = mac$3 ? "altKey" : "ctrlKey";
handlers.dragstart = (cr, ar) => {
  let lr = ar, ur = cr.input.mouseDown;
  if (ur && ur.done(), !lr.dataTransfer)
    return;
  let dr = cr.state.selection, fr = dr.empty ? null : cr.posAtCoords(eventCoords(lr)), gr;
  if (!(fr && fr.pos >= dr.from && fr.pos <= (dr instanceof NodeSelection ? dr.to - 1 : dr.to))) {
    if (ur && ur.mightDrag)
      gr = NodeSelection.create(cr.state.doc, ur.mightDrag.pos);
    else if (lr.target && lr.target.nodeType == 1) {
      let _r = cr.docView.nearestDesc(lr.target, !0);
      _r && _r.node.type.spec.draggable && _r != cr.docView && (gr = NodeSelection.create(cr.state.doc, _r.posBefore));
    }
  }
  let mr = (gr || cr.state.selection).content(), { dom: vr, text: yr } = serializeForClipboard(cr, mr);
  lr.dataTransfer.clearData(), lr.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", vr.innerHTML), lr.dataTransfer.effectAllowed = "copyMove", brokenClipboardAPI || lr.dataTransfer.setData("text/plain", yr), cr.dragging = new Dragging(mr, !lr[dragCopyModifier], gr);
};
handlers.dragend = (cr) => {
  let ar = cr.dragging;
  window.setTimeout(() => {
    cr.dragging == ar && (cr.dragging = null);
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (cr, ar) => ar.preventDefault();
editHandlers.drop = (cr, ar) => {
  let lr = ar, ur = cr.dragging;
  if (cr.dragging = null, !lr.dataTransfer)
    return;
  let dr = cr.posAtCoords(eventCoords(lr));
  if (!dr)
    return;
  let fr = cr.state.doc.resolve(dr.pos), gr = ur && ur.slice;
  gr ? cr.someProp("transformPasted", (Er) => {
    gr = Er(gr, cr);
  }) : gr = parseFromClipboard(cr, getText(lr.dataTransfer), brokenClipboardAPI ? null : lr.dataTransfer.getData("text/html"), !1, fr);
  let mr = !!(ur && !lr[dragCopyModifier]);
  if (cr.someProp("handleDrop", (Er) => Er(cr, lr, gr || Slice.empty, mr))) {
    lr.preventDefault();
    return;
  }
  if (!gr)
    return;
  lr.preventDefault();
  let vr = gr ? dropPoint(cr.state.doc, fr.pos, gr) : fr.pos;
  vr == null && (vr = fr.pos);
  let yr = cr.state.tr;
  if (mr) {
    let { node: Er } = ur;
    Er ? Er.replace(yr) : yr.deleteSelection();
  }
  let _r = yr.mapping.map(vr), kr = gr.openStart == 0 && gr.openEnd == 0 && gr.content.childCount == 1, xr = yr.doc;
  if (kr ? yr.replaceRangeWith(_r, _r, gr.content.firstChild) : yr.replaceRange(_r, _r, gr), yr.doc.eq(xr))
    return;
  let Ar = yr.doc.resolve(_r);
  if (kr && NodeSelection.isSelectable(gr.content.firstChild) && Ar.nodeAfter && Ar.nodeAfter.sameMarkup(gr.content.firstChild))
    yr.setSelection(new NodeSelection(Ar));
  else {
    let Er = yr.mapping.map(vr);
    yr.mapping.maps[yr.mapping.maps.length - 1].forEach((Cr, Tr, Sr, Lr) => Er = Lr), yr.setSelection(selectionBetween(cr, Ar, yr.doc.resolve(Er)));
  }
  cr.focus(), cr.dispatch(yr.setMeta("uiEvent", "drop"));
};
handlers.focus = (cr) => {
  cr.input.lastFocus = Date.now(), cr.focused || (cr.domObserver.stop(), cr.dom.classList.add("ProseMirror-focused"), cr.domObserver.start(), cr.focused = !0, setTimeout(() => {
    cr.docView && cr.hasFocus() && !cr.domObserver.currentSelection.eq(cr.domSelectionRange()) && selectionToDOM(cr);
  }, 20));
};
handlers.blur = (cr, ar) => {
  let lr = ar;
  cr.focused && (cr.domObserver.stop(), cr.dom.classList.remove("ProseMirror-focused"), cr.domObserver.start(), lr.relatedTarget && cr.dom.contains(lr.relatedTarget) && cr.domObserver.currentSelection.clear(), cr.focused = !1);
};
handlers.beforeinput = (cr, ar) => {
  if (chrome && android && ar.inputType == "deleteContentBackward") {
    cr.domObserver.flushSoon();
    let { domChangeCount: ur } = cr.input;
    setTimeout(() => {
      if (cr.input.domChangeCount != ur || (cr.dom.blur(), cr.focus(), cr.someProp("handleKeyDown", (fr) => fr(cr, keyEvent(8, "Backspace")))))
        return;
      let { $cursor: dr } = cr.state.selection;
      dr && dr.pos > 0 && cr.dispatch(cr.state.tr.delete(dr.pos - 1, dr.pos).scrollIntoView());
    }, 50);
  }
};
for (let cr in editHandlers)
  handlers[cr] = editHandlers[cr];
function compareObjs(cr, ar) {
  if (cr == ar)
    return !0;
  for (let lr in cr)
    if (cr[lr] !== ar[lr])
      return !1;
  for (let lr in ar)
    if (!(lr in cr))
      return !1;
  return !0;
}
class WidgetType {
  constructor(ar, lr) {
    this.toDOM = ar, this.spec = lr || noSpec, this.side = this.spec.side || 0;
  }
  map(ar, lr, ur, dr) {
    let { pos: fr, deleted: gr } = ar.mapResult(lr.from + dr, this.side < 0 ? -1 : 1);
    return gr ? null : new Decoration(fr - ur, fr - ur, this);
  }
  valid() {
    return !0;
  }
  eq(ar) {
    return this == ar || ar instanceof WidgetType && (this.spec.key && this.spec.key == ar.spec.key || this.toDOM == ar.toDOM && compareObjs(this.spec, ar.spec));
  }
  destroy(ar) {
    this.spec.destroy && this.spec.destroy(ar);
  }
}
class InlineType {
  constructor(ar, lr) {
    this.attrs = ar, this.spec = lr || noSpec;
  }
  map(ar, lr, ur, dr) {
    let fr = ar.map(lr.from + dr, this.spec.inclusiveStart ? -1 : 1) - ur, gr = ar.map(lr.to + dr, this.spec.inclusiveEnd ? 1 : -1) - ur;
    return fr >= gr ? null : new Decoration(fr, gr, this);
  }
  valid(ar, lr) {
    return lr.from < lr.to;
  }
  eq(ar) {
    return this == ar || ar instanceof InlineType && compareObjs(this.attrs, ar.attrs) && compareObjs(this.spec, ar.spec);
  }
  static is(ar) {
    return ar.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType {
  constructor(ar, lr) {
    this.attrs = ar, this.spec = lr || noSpec;
  }
  map(ar, lr, ur, dr) {
    let fr = ar.mapResult(lr.from + dr, 1);
    if (fr.deleted)
      return null;
    let gr = ar.mapResult(lr.to + dr, -1);
    return gr.deleted || gr.pos <= fr.pos ? null : new Decoration(fr.pos - ur, gr.pos - ur, this);
  }
  valid(ar, lr) {
    let { index: ur, offset: dr } = ar.content.findIndex(lr.from), fr;
    return dr == lr.from && !(fr = ar.child(ur)).isText && dr + fr.nodeSize == lr.to;
  }
  eq(ar) {
    return this == ar || ar instanceof NodeType && compareObjs(this.attrs, ar.attrs) && compareObjs(this.spec, ar.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(ar, lr, ur) {
    this.from = ar, this.to = lr, this.type = ur;
  }
  /**
  @internal
  */
  copy(ar, lr) {
    return new Decoration(ar, lr, this.type);
  }
  /**
  @internal
  */
  eq(ar, lr = 0) {
    return this.type.eq(ar.type) && this.from + lr == ar.from && this.to + lr == ar.to;
  }
  /**
  @internal
  */
  map(ar, lr, ur) {
    return this.type.map(ar, this, lr, ur);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(ar, lr, ur) {
    return new Decoration(ar, ar, new WidgetType(lr, ur));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(ar, lr, ur, dr) {
    return new Decoration(ar, lr, new InlineType(ur, dr));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(ar, lr, ur, dr) {
    return new Decoration(ar, lr, new NodeType(ur, dr));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(ar, lr) {
    this.local = ar.length ? ar : none, this.children = lr.length ? lr : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(ar, lr) {
    return lr.length ? buildTree(lr, ar, 0, noSpec) : empty$1;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(ar, lr, ur) {
    let dr = [];
    return this.findInner(ar == null ? 0 : ar, lr == null ? 1e9 : lr, dr, 0, ur), dr;
  }
  findInner(ar, lr, ur, dr, fr) {
    for (let gr = 0; gr < this.local.length; gr++) {
      let mr = this.local[gr];
      mr.from <= lr && mr.to >= ar && (!fr || fr(mr.spec)) && ur.push(mr.copy(mr.from + dr, mr.to + dr));
    }
    for (let gr = 0; gr < this.children.length; gr += 3)
      if (this.children[gr] < lr && this.children[gr + 1] > ar) {
        let mr = this.children[gr] + 1;
        this.children[gr + 2].findInner(ar - mr, lr - mr, ur, dr + mr, fr);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(ar, lr, ur) {
    return this == empty$1 || ar.maps.length == 0 ? this : this.mapInner(ar, lr, 0, 0, ur || noSpec);
  }
  /**
  @internal
  */
  mapInner(ar, lr, ur, dr, fr) {
    let gr;
    for (let mr = 0; mr < this.local.length; mr++) {
      let vr = this.local[mr].map(ar, ur, dr);
      vr && vr.type.valid(lr, vr) ? (gr || (gr = [])).push(vr) : fr.onRemove && fr.onRemove(this.local[mr].spec);
    }
    return this.children.length ? mapChildren(this.children, gr || [], ar, lr, ur, dr, fr) : gr ? new DecorationSet(gr.sort(byPos), none) : empty$1;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(ar, lr) {
    return lr.length ? this == empty$1 ? DecorationSet.create(ar, lr) : this.addInner(ar, lr, 0) : this;
  }
  addInner(ar, lr, ur) {
    let dr, fr = 0;
    ar.forEach((mr, vr) => {
      let yr = vr + ur, _r;
      if (_r = takeSpansForNode(lr, mr, yr)) {
        for (dr || (dr = this.children.slice()); fr < dr.length && dr[fr] < vr; )
          fr += 3;
        dr[fr] == vr ? dr[fr + 2] = dr[fr + 2].addInner(mr, _r, yr + 1) : dr.splice(fr, 0, vr, vr + mr.nodeSize, buildTree(_r, mr, yr + 1, noSpec)), fr += 3;
      }
    });
    let gr = moveSpans(fr ? withoutNulls(lr) : lr, -ur);
    for (let mr = 0; mr < gr.length; mr++)
      gr[mr].type.valid(ar, gr[mr]) || gr.splice(mr--, 1);
    return new DecorationSet(gr.length ? this.local.concat(gr).sort(byPos) : this.local, dr || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(ar) {
    return ar.length == 0 || this == empty$1 ? this : this.removeInner(ar, 0);
  }
  removeInner(ar, lr) {
    let ur = this.children, dr = this.local;
    for (let fr = 0; fr < ur.length; fr += 3) {
      let gr, mr = ur[fr] + lr, vr = ur[fr + 1] + lr;
      for (let _r = 0, kr; _r < ar.length; _r++)
        (kr = ar[_r]) && kr.from > mr && kr.to < vr && (ar[_r] = null, (gr || (gr = [])).push(kr));
      if (!gr)
        continue;
      ur == this.children && (ur = this.children.slice());
      let yr = ur[fr + 2].removeInner(gr, mr + 1);
      yr != empty$1 ? ur[fr + 2] = yr : (ur.splice(fr, 3), fr -= 3);
    }
    if (dr.length) {
      for (let fr = 0, gr; fr < ar.length; fr++)
        if (gr = ar[fr])
          for (let mr = 0; mr < dr.length; mr++)
            dr[mr].eq(gr, lr) && (dr == this.local && (dr = this.local.slice()), dr.splice(mr--, 1));
    }
    return ur == this.children && dr == this.local ? this : dr.length || ur.length ? new DecorationSet(dr, ur) : empty$1;
  }
  /**
  @internal
  */
  forChild(ar, lr) {
    if (this == empty$1)
      return this;
    if (lr.isLeaf)
      return DecorationSet.empty;
    let ur, dr;
    for (let mr = 0; mr < this.children.length; mr += 3)
      if (this.children[mr] >= ar) {
        this.children[mr] == ar && (ur = this.children[mr + 2]);
        break;
      }
    let fr = ar + 1, gr = fr + lr.content.size;
    for (let mr = 0; mr < this.local.length; mr++) {
      let vr = this.local[mr];
      if (vr.from < gr && vr.to > fr && vr.type instanceof InlineType) {
        let yr = Math.max(fr, vr.from) - fr, _r = Math.min(gr, vr.to) - fr;
        yr < _r && (dr || (dr = [])).push(vr.copy(yr, _r));
      }
    }
    if (dr) {
      let mr = new DecorationSet(dr.sort(byPos), none);
      return ur ? new DecorationGroup([mr, ur]) : mr;
    }
    return ur || empty$1;
  }
  /**
  @internal
  */
  eq(ar) {
    if (this == ar)
      return !0;
    if (!(ar instanceof DecorationSet) || this.local.length != ar.local.length || this.children.length != ar.children.length)
      return !1;
    for (let lr = 0; lr < this.local.length; lr++)
      if (!this.local[lr].eq(ar.local[lr]))
        return !1;
    for (let lr = 0; lr < this.children.length; lr += 3)
      if (this.children[lr] != ar.children[lr] || this.children[lr + 1] != ar.children[lr + 1] || !this.children[lr + 2].eq(ar.children[lr + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(ar) {
    return removeOverlap(this.localsInner(ar));
  }
  /**
  @internal
  */
  localsInner(ar) {
    if (this == empty$1)
      return none;
    if (ar.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let lr = [];
    for (let ur = 0; ur < this.local.length; ur++)
      this.local[ur].type instanceof InlineType || lr.push(this.local[ur]);
    return lr;
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty$1 = DecorationSet.empty;
class DecorationGroup {
  constructor(ar) {
    this.members = ar;
  }
  map(ar, lr) {
    const ur = this.members.map((dr) => dr.map(ar, lr, noSpec));
    return DecorationGroup.from(ur);
  }
  forChild(ar, lr) {
    if (lr.isLeaf)
      return DecorationSet.empty;
    let ur = [];
    for (let dr = 0; dr < this.members.length; dr++) {
      let fr = this.members[dr].forChild(ar, lr);
      fr != empty$1 && (fr instanceof DecorationGroup ? ur = ur.concat(fr.members) : ur.push(fr));
    }
    return DecorationGroup.from(ur);
  }
  eq(ar) {
    if (!(ar instanceof DecorationGroup) || ar.members.length != this.members.length)
      return !1;
    for (let lr = 0; lr < this.members.length; lr++)
      if (!this.members[lr].eq(ar.members[lr]))
        return !1;
    return !0;
  }
  locals(ar) {
    let lr, ur = !0;
    for (let dr = 0; dr < this.members.length; dr++) {
      let fr = this.members[dr].localsInner(ar);
      if (fr.length)
        if (!lr)
          lr = fr;
        else {
          ur && (lr = lr.slice(), ur = !1);
          for (let gr = 0; gr < fr.length; gr++)
            lr.push(fr[gr]);
        }
    }
    return lr ? removeOverlap(ur ? lr : lr.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(ar) {
    switch (ar.length) {
      case 0:
        return empty$1;
      case 1:
        return ar[0];
      default:
        return new DecorationGroup(ar.every((lr) => lr instanceof DecorationSet) ? ar : ar.reduce((lr, ur) => lr.concat(ur instanceof DecorationSet ? ur : ur.members), []));
    }
  }
}
function mapChildren(cr, ar, lr, ur, dr, fr, gr) {
  let mr = cr.slice();
  for (let yr = 0, _r = fr; yr < lr.maps.length; yr++) {
    let kr = 0;
    lr.maps[yr].forEach((xr, Ar, Er, Cr) => {
      let Tr = Cr - Er - (Ar - xr);
      for (let Sr = 0; Sr < mr.length; Sr += 3) {
        let Lr = mr[Sr + 1];
        if (Lr < 0 || xr > Lr + _r - kr)
          continue;
        let Ir = mr[Sr] + _r - kr;
        Ar >= Ir ? mr[Sr + 1] = xr <= Ir ? -2 : -1 : Er >= dr && Tr && (mr[Sr] += Tr, mr[Sr + 1] += Tr);
      }
      kr += Tr;
    }), _r = lr.maps[yr].map(_r, -1);
  }
  let vr = !1;
  for (let yr = 0; yr < mr.length; yr += 3)
    if (mr[yr + 1] < 0) {
      if (mr[yr + 1] == -2) {
        vr = !0, mr[yr + 1] = -1;
        continue;
      }
      let _r = lr.map(cr[yr] + fr), kr = _r - dr;
      if (kr < 0 || kr >= ur.content.size) {
        vr = !0;
        continue;
      }
      let xr = lr.map(cr[yr + 1] + fr, -1), Ar = xr - dr, { index: Er, offset: Cr } = ur.content.findIndex(kr), Tr = ur.maybeChild(Er);
      if (Tr && Cr == kr && Cr + Tr.nodeSize == Ar) {
        let Sr = mr[yr + 2].mapInner(lr, Tr, _r + 1, cr[yr] + fr + 1, gr);
        Sr != empty$1 ? (mr[yr] = kr, mr[yr + 1] = Ar, mr[yr + 2] = Sr) : (mr[yr + 1] = -2, vr = !0);
      } else
        vr = !0;
    }
  if (vr) {
    let yr = mapAndGatherRemainingDecorations(mr, cr, ar, lr, dr, fr, gr), _r = buildTree(yr, ur, 0, gr);
    ar = _r.local;
    for (let kr = 0; kr < mr.length; kr += 3)
      mr[kr + 1] < 0 && (mr.splice(kr, 3), kr -= 3);
    for (let kr = 0, xr = 0; kr < _r.children.length; kr += 3) {
      let Ar = _r.children[kr];
      for (; xr < mr.length && mr[xr] < Ar; )
        xr += 3;
      mr.splice(xr, 0, _r.children[kr], _r.children[kr + 1], _r.children[kr + 2]);
    }
  }
  return new DecorationSet(ar.sort(byPos), mr);
}
function moveSpans(cr, ar) {
  if (!ar || !cr.length)
    return cr;
  let lr = [];
  for (let ur = 0; ur < cr.length; ur++) {
    let dr = cr[ur];
    lr.push(new Decoration(dr.from + ar, dr.to + ar, dr.type));
  }
  return lr;
}
function mapAndGatherRemainingDecorations(cr, ar, lr, ur, dr, fr, gr) {
  function mr(vr, yr) {
    for (let _r = 0; _r < vr.local.length; _r++) {
      let kr = vr.local[_r].map(ur, dr, yr);
      kr ? lr.push(kr) : gr.onRemove && gr.onRemove(vr.local[_r].spec);
    }
    for (let _r = 0; _r < vr.children.length; _r += 3)
      mr(vr.children[_r + 2], vr.children[_r] + yr + 1);
  }
  for (let vr = 0; vr < cr.length; vr += 3)
    cr[vr + 1] == -1 && mr(cr[vr + 2], ar[vr] + fr + 1);
  return lr;
}
function takeSpansForNode(cr, ar, lr) {
  if (ar.isLeaf)
    return null;
  let ur = lr + ar.nodeSize, dr = null;
  for (let fr = 0, gr; fr < cr.length; fr++)
    (gr = cr[fr]) && gr.from > lr && gr.to < ur && ((dr || (dr = [])).push(gr), cr[fr] = null);
  return dr;
}
function withoutNulls(cr) {
  let ar = [];
  for (let lr = 0; lr < cr.length; lr++)
    cr[lr] != null && ar.push(cr[lr]);
  return ar;
}
function buildTree(cr, ar, lr, ur) {
  let dr = [], fr = !1;
  ar.forEach((mr, vr) => {
    let yr = takeSpansForNode(cr, mr, vr + lr);
    if (yr) {
      fr = !0;
      let _r = buildTree(yr, mr, lr + vr + 1, ur);
      _r != empty$1 && dr.push(vr, vr + mr.nodeSize, _r);
    }
  });
  let gr = moveSpans(fr ? withoutNulls(cr) : cr, -lr).sort(byPos);
  for (let mr = 0; mr < gr.length; mr++)
    gr[mr].type.valid(ar, gr[mr]) || (ur.onRemove && ur.onRemove(gr[mr].spec), gr.splice(mr--, 1));
  return gr.length || dr.length ? new DecorationSet(gr, dr) : empty$1;
}
function byPos(cr, ar) {
  return cr.from - ar.from || cr.to - ar.to;
}
function removeOverlap(cr) {
  let ar = cr;
  for (let lr = 0; lr < ar.length - 1; lr++) {
    let ur = ar[lr];
    if (ur.from != ur.to)
      for (let dr = lr + 1; dr < ar.length; dr++) {
        let fr = ar[dr];
        if (fr.from == ur.from) {
          fr.to != ur.to && (ar == cr && (ar = cr.slice()), ar[dr] = fr.copy(fr.from, ur.to), insertAhead(ar, dr + 1, fr.copy(ur.to, fr.to)));
          continue;
        } else {
          fr.from < ur.to && (ar == cr && (ar = cr.slice()), ar[lr] = ur.copy(ur.from, fr.from), insertAhead(ar, dr, ur.copy(fr.from, ur.to)));
          break;
        }
      }
  }
  return ar;
}
function insertAhead(cr, ar, lr) {
  for (; ar < cr.length && byPos(lr, cr[ar]) > 0; )
    ar++;
  cr.splice(ar, 0, lr);
}
function viewDecorations(cr) {
  let ar = [];
  return cr.someProp("decorations", (lr) => {
    let ur = lr(cr.state);
    ur && ur != empty$1 && ar.push(ur);
  }), cr.cursorWrapper && ar.push(DecorationSet.create(cr.state.doc, [cr.cursorWrapper.deco])), DecorationGroup.from(ar);
}
const observeOptions = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(ar) {
    this.anchorNode = ar.anchorNode, this.anchorOffset = ar.anchorOffset, this.focusNode = ar.focusNode, this.focusOffset = ar.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(ar) {
    return ar.anchorNode == this.anchorNode && ar.anchorOffset == this.anchorOffset && ar.focusNode == this.focusNode && ar.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(ar, lr) {
    this.view = ar, this.handleDOMChange = lr, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new SelectionState(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((ur) => {
      for (let dr = 0; dr < ur.length; dr++)
        this.queue.push(ur[dr]);
      ie$1 && ie_version <= 11 && ur.some((dr) => dr.type == "childList" && dr.removedNodes.length || dr.type == "characterData" && dr.oldValue.length > dr.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), useCharData && (this.onCharData = (ur) => {
      this.queue.push({ target: ur.target, type: "characterData", oldValue: ur.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, observeOptions)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let ar = this.observer.takeRecords();
      if (ar.length) {
        for (let lr = 0; lr < ar.length; lr++)
          this.queue.push(ar[lr]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (hasFocusAndSelection(this.view)) {
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
        let ar = this.view.domSelectionRange();
        if (ar.focusNode && isEquivalentPosition(ar.focusNode, ar.focusOffset, ar.anchorNode, ar.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(ar) {
    if (!ar.focusNode)
      return !0;
    let lr = /* @__PURE__ */ new Set(), ur;
    for (let fr = ar.focusNode; fr; fr = parentNode(fr))
      lr.add(fr);
    for (let fr = ar.anchorNode; fr; fr = parentNode(fr))
      if (lr.has(fr)) {
        ur = fr;
        break;
      }
    let dr = ur && this.view.docView.nearestDesc(ur);
    if (dr && dr.ignoreMutation({
      type: "selection",
      target: ur.nodeType == 3 ? ur.parentNode : ur
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let ar of this.observer.takeRecords())
        this.queue.push(ar);
    return this.queue;
  }
  flush() {
    let { view: ar } = this;
    if (!ar.docView || this.flushingSoon > -1)
      return;
    let lr = this.pendingRecords();
    lr.length && (this.queue = []);
    let ur = ar.domSelectionRange(), dr = !this.suppressingSelectionUpdates && !this.currentSelection.eq(ur) && hasFocusAndSelection(ar) && !this.ignoreSelectionChange(ur), fr = -1, gr = -1, mr = !1, vr = [];
    if (ar.editable)
      for (let _r = 0; _r < lr.length; _r++) {
        let kr = this.registerMutation(lr[_r], vr);
        kr && (fr = fr < 0 ? kr.from : Math.min(kr.from, fr), gr = gr < 0 ? kr.to : Math.max(kr.to, gr), kr.typeOver && (mr = !0));
      }
    if (gecko && vr.length > 1) {
      let _r = vr.filter((kr) => kr.nodeName == "BR");
      if (_r.length == 2) {
        let kr = _r[0], xr = _r[1];
        kr.parentNode && kr.parentNode.parentNode == xr.parentNode ? xr.remove() : kr.remove();
      }
    }
    let yr = null;
    fr < 0 && dr && ar.input.lastFocus > Date.now() - 200 && Math.max(ar.input.lastTouch, ar.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(ur) && (yr = selectionFromDOM(ar)) && yr.eq(Selection.near(ar.state.doc.resolve(0), 1)) ? (ar.input.lastFocus = 0, selectionToDOM(ar), this.currentSelection.set(ur), ar.scrollToSelection()) : (fr > -1 || dr) && (fr > -1 && (ar.docView.markDirty(fr, gr), checkCSS(ar)), this.handleDOMChange(fr, gr, mr, vr), ar.docView && ar.docView.dirty ? ar.updateState(ar.state) : this.currentSelection.eq(ur) || selectionToDOM(ar), this.currentSelection.set(ur));
  }
  registerMutation(ar, lr) {
    if (lr.indexOf(ar.target) > -1)
      return null;
    let ur = this.view.docView.nearestDesc(ar.target);
    if (ar.type == "attributes" && (ur == this.view.docView || ar.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    ar.attributeName == "style" && !ar.oldValue && !ar.target.getAttribute("style")) || !ur || ur.ignoreMutation(ar))
      return null;
    if (ar.type == "childList") {
      for (let _r = 0; _r < ar.addedNodes.length; _r++)
        lr.push(ar.addedNodes[_r]);
      if (ur.contentDOM && ur.contentDOM != ur.dom && !ur.contentDOM.contains(ar.target))
        return { from: ur.posBefore, to: ur.posAfter };
      let dr = ar.previousSibling, fr = ar.nextSibling;
      if (ie$1 && ie_version <= 11 && ar.addedNodes.length)
        for (let _r = 0; _r < ar.addedNodes.length; _r++) {
          let { previousSibling: kr, nextSibling: xr } = ar.addedNodes[_r];
          (!kr || Array.prototype.indexOf.call(ar.addedNodes, kr) < 0) && (dr = kr), (!xr || Array.prototype.indexOf.call(ar.addedNodes, xr) < 0) && (fr = xr);
        }
      let gr = dr && dr.parentNode == ar.target ? domIndex(dr) + 1 : 0, mr = ur.localPosFromDOM(ar.target, gr, -1), vr = fr && fr.parentNode == ar.target ? domIndex(fr) : ar.target.childNodes.length, yr = ur.localPosFromDOM(ar.target, vr, 1);
      return { from: mr, to: yr };
    } else
      return ar.type == "attributes" ? { from: ur.posAtStart - ur.border, to: ur.posAtEnd + ur.border } : {
        from: ur.posAtStart,
        to: ur.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: ar.target.nodeValue == ar.oldValue
      };
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap(), cssCheckWarned = !1;
function checkCSS(cr) {
  if (!cssChecked.has(cr) && (cssChecked.set(cr, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(cr.dom).whiteSpace) !== -1)) {
    if (cr.requiresGeckoHackNode = gecko, cssCheckWarned)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), cssCheckWarned = !0;
  }
}
function safariShadowSelectionRange(cr) {
  let ar;
  function lr(vr) {
    vr.preventDefault(), vr.stopImmediatePropagation(), ar = vr.getTargetRanges()[0];
  }
  cr.dom.addEventListener("beforeinput", lr, !0), document.execCommand("indent"), cr.dom.removeEventListener("beforeinput", lr, !0);
  let ur = ar.startContainer, dr = ar.startOffset, fr = ar.endContainer, gr = ar.endOffset, mr = cr.domAtPos(cr.state.selection.anchor);
  return isEquivalentPosition(mr.node, mr.offset, fr, gr) && ([ur, dr, fr, gr] = [fr, gr, ur, dr]), { anchorNode: ur, anchorOffset: dr, focusNode: fr, focusOffset: gr };
}
function parseBetween(cr, ar, lr) {
  let { node: ur, fromOffset: dr, toOffset: fr, from: gr, to: mr } = cr.docView.parseRange(ar, lr), vr = cr.domSelectionRange(), yr, _r = vr.anchorNode;
  if (_r && cr.dom.contains(_r.nodeType == 1 ? _r : _r.parentNode) && (yr = [{ node: _r, offset: vr.anchorOffset }], selectionCollapsed(vr) || yr.push({ node: vr.focusNode, offset: vr.focusOffset })), chrome && cr.input.lastKeyCode === 8)
    for (let Tr = fr; Tr > dr; Tr--) {
      let Sr = ur.childNodes[Tr - 1], Lr = Sr.pmViewDesc;
      if (Sr.nodeName == "BR" && !Lr) {
        fr = Tr;
        break;
      }
      if (!Lr || Lr.size)
        break;
    }
  let kr = cr.state.doc, xr = cr.someProp("domParser") || DOMParser.fromSchema(cr.state.schema), Ar = kr.resolve(gr), Er = null, Cr = xr.parse(ur, {
    topNode: Ar.parent,
    topMatch: Ar.parent.contentMatchAt(Ar.index()),
    topOpen: !0,
    from: dr,
    to: fr,
    preserveWhitespace: Ar.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: yr,
    ruleFromNode,
    context: Ar
  });
  if (yr && yr[0].pos != null) {
    let Tr = yr[0].pos, Sr = yr[1] && yr[1].pos;
    Sr == null && (Sr = Tr), Er = { anchor: Tr + gr, head: Sr + gr };
  }
  return { doc: Cr, sel: Er, from: gr, to: mr };
}
function ruleFromNode(cr) {
  let ar = cr.pmViewDesc;
  if (ar)
    return ar.parseRule();
  if (cr.nodeName == "BR" && cr.parentNode) {
    if (safari && /^(ul|ol)$/i.test(cr.parentNode.nodeName)) {
      let lr = document.createElement("div");
      return lr.appendChild(document.createElement("li")), { skip: lr };
    } else if (cr.parentNode.lastChild == cr || safari && /^(tr|table)$/i.test(cr.parentNode.nodeName))
      return { ignore: !0 };
  } else if (cr.nodeName == "IMG" && cr.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(cr, ar, lr, ur, dr) {
  let fr = cr.input.compositionPendingChanges || (cr.composing ? cr.input.compositionID : 0);
  if (cr.input.compositionPendingChanges = 0, ar < 0) {
    let Hr = cr.input.lastSelectionTime > Date.now() - 50 ? cr.input.lastSelectionOrigin : null, Fr = selectionFromDOM(cr, Hr);
    if (Fr && !cr.state.selection.eq(Fr)) {
      if (chrome && android && cr.input.lastKeyCode === 13 && Date.now() - 100 < cr.input.lastKeyCodeTime && cr.someProp("handleKeyDown", (Ur) => Ur(cr, keyEvent(13, "Enter"))))
        return;
      let zr = cr.state.tr.setSelection(Fr);
      Hr == "pointer" ? zr.setMeta("pointer", !0) : Hr == "key" && zr.scrollIntoView(), fr && zr.setMeta("composition", fr), cr.dispatch(zr);
    }
    return;
  }
  let gr = cr.state.doc.resolve(ar), mr = gr.sharedDepth(lr);
  ar = gr.before(mr + 1), lr = cr.state.doc.resolve(lr).after(mr + 1);
  let vr = cr.state.selection, yr = parseBetween(cr, ar, lr), _r = cr.state.doc, kr = _r.slice(yr.from, yr.to), xr, Ar;
  cr.input.lastKeyCode === 8 && Date.now() - 100 < cr.input.lastKeyCodeTime ? (xr = cr.state.selection.to, Ar = "end") : (xr = cr.state.selection.from, Ar = "start"), cr.input.lastKeyCode = null;
  let Er = findDiff(kr.content, yr.doc.content, yr.from, xr, Ar);
  if ((ios && cr.input.lastIOSEnter > Date.now() - 225 || android) && dr.some((Hr) => Hr.nodeType == 1 && !isInline.test(Hr.nodeName)) && (!Er || Er.endA >= Er.endB) && cr.someProp("handleKeyDown", (Hr) => Hr(cr, keyEvent(13, "Enter")))) {
    cr.input.lastIOSEnter = 0;
    return;
  }
  if (!Er)
    if (ur && vr instanceof TextSelection && !vr.empty && vr.$head.sameParent(vr.$anchor) && !cr.composing && !(yr.sel && yr.sel.anchor != yr.sel.head))
      Er = { start: vr.from, endA: vr.to, endB: vr.to };
    else {
      if (yr.sel) {
        let Hr = resolveSelection(cr, cr.state.doc, yr.sel);
        if (Hr && !Hr.eq(cr.state.selection)) {
          let Fr = cr.state.tr.setSelection(Hr);
          fr && Fr.setMeta("composition", fr), cr.dispatch(Fr);
        }
      }
      return;
    }
  if (chrome && cr.cursorWrapper && yr.sel && yr.sel.anchor == cr.cursorWrapper.deco.from && yr.sel.head == yr.sel.anchor) {
    let Hr = Er.endB - Er.start;
    yr.sel = { anchor: yr.sel.anchor + Hr, head: yr.sel.anchor + Hr };
  }
  cr.input.domChangeCount++, cr.state.selection.from < cr.state.selection.to && Er.start == Er.endB && cr.state.selection instanceof TextSelection && (Er.start > cr.state.selection.from && Er.start <= cr.state.selection.from + 2 && cr.state.selection.from >= yr.from ? Er.start = cr.state.selection.from : Er.endA < cr.state.selection.to && Er.endA >= cr.state.selection.to - 2 && cr.state.selection.to <= yr.to && (Er.endB += cr.state.selection.to - Er.endA, Er.endA = cr.state.selection.to)), ie$1 && ie_version <= 11 && Er.endB == Er.start + 1 && Er.endA == Er.start && Er.start > yr.from && yr.doc.textBetween(Er.start - yr.from - 1, Er.start - yr.from + 1) == " " && (Er.start--, Er.endA--, Er.endB--);
  let Cr = yr.doc.resolveNoCache(Er.start - yr.from), Tr = yr.doc.resolveNoCache(Er.endB - yr.from), Sr = _r.resolve(Er.start), Lr = Cr.sameParent(Tr) && Cr.parent.inlineContent && Sr.end() >= Er.endA, Ir;
  if ((ios && cr.input.lastIOSEnter > Date.now() - 225 && (!Lr || dr.some((Hr) => Hr.nodeName == "DIV" || Hr.nodeName == "P")) || !Lr && Cr.pos < yr.doc.content.size && !Cr.sameParent(Tr) && (Ir = Selection.findFrom(yr.doc.resolve(Cr.pos + 1), 1, !0)) && Ir.head == Tr.pos) && cr.someProp("handleKeyDown", (Hr) => Hr(cr, keyEvent(13, "Enter")))) {
    cr.input.lastIOSEnter = 0;
    return;
  }
  if (cr.state.selection.anchor > Er.start && looksLikeJoin(_r, Er.start, Er.endA, Cr, Tr) && cr.someProp("handleKeyDown", (Hr) => Hr(cr, keyEvent(8, "Backspace")))) {
    android && chrome && cr.domObserver.suppressSelectionUpdates();
    return;
  }
  chrome && android && Er.endB == Er.start && (cr.input.lastAndroidDelete = Date.now()), android && !Lr && Cr.start() != Tr.start() && Tr.parentOffset == 0 && Cr.depth == Tr.depth && yr.sel && yr.sel.anchor == yr.sel.head && yr.sel.head == Er.endA && (Er.endB -= 2, Tr = yr.doc.resolveNoCache(Er.endB - yr.from), setTimeout(() => {
    cr.someProp("handleKeyDown", function(Hr) {
      return Hr(cr, keyEvent(13, "Enter"));
    });
  }, 20));
  let Nr = Er.start, Rr = Er.endA, Mr, Br, Dr;
  if (Lr) {
    if (Cr.pos == Tr.pos)
      ie$1 && ie_version <= 11 && Cr.parentOffset == 0 && (cr.domObserver.suppressSelectionUpdates(), setTimeout(() => selectionToDOM(cr), 20)), Mr = cr.state.tr.delete(Nr, Rr), Br = _r.resolve(Er.start).marksAcross(_r.resolve(Er.endA));
    else if (
      // Adding or removing a mark
      Er.endA == Er.endB && (Dr = isMarkChange(Cr.parent.content.cut(Cr.parentOffset, Tr.parentOffset), Sr.parent.content.cut(Sr.parentOffset, Er.endA - Sr.start())))
    )
      Mr = cr.state.tr, Dr.type == "add" ? Mr.addMark(Nr, Rr, Dr.mark) : Mr.removeMark(Nr, Rr, Dr.mark);
    else if (Cr.parent.child(Cr.index()).isText && Cr.index() == Tr.index() - (Tr.textOffset ? 0 : 1)) {
      let Hr = Cr.parent.textBetween(Cr.parentOffset, Tr.parentOffset);
      if (cr.someProp("handleTextInput", (Fr) => Fr(cr, Nr, Rr, Hr)))
        return;
      Mr = cr.state.tr.insertText(Hr, Nr, Rr);
    }
  }
  if (Mr || (Mr = cr.state.tr.replace(Nr, Rr, yr.doc.slice(Er.start - yr.from, Er.endB - yr.from))), yr.sel) {
    let Hr = resolveSelection(cr, Mr.doc, yr.sel);
    Hr && !(chrome && android && cr.composing && Hr.empty && (Er.start != Er.endB || cr.input.lastAndroidDelete < Date.now() - 100) && (Hr.head == Nr || Hr.head == Mr.mapping.map(Rr) - 1) || ie$1 && Hr.empty && Hr.head == Nr) && Mr.setSelection(Hr);
  }
  Br && Mr.ensureMarks(Br), fr && Mr.setMeta("composition", fr), cr.dispatch(Mr.scrollIntoView());
}
function resolveSelection(cr, ar, lr) {
  return Math.max(lr.anchor, lr.head) > ar.content.size ? null : selectionBetween(cr, ar.resolve(lr.anchor), ar.resolve(lr.head));
}
function isMarkChange(cr, ar) {
  let lr = cr.firstChild.marks, ur = ar.firstChild.marks, dr = lr, fr = ur, gr, mr, vr;
  for (let _r = 0; _r < ur.length; _r++)
    dr = ur[_r].removeFromSet(dr);
  for (let _r = 0; _r < lr.length; _r++)
    fr = lr[_r].removeFromSet(fr);
  if (dr.length == 1 && fr.length == 0)
    mr = dr[0], gr = "add", vr = (_r) => _r.mark(mr.addToSet(_r.marks));
  else if (dr.length == 0 && fr.length == 1)
    mr = fr[0], gr = "remove", vr = (_r) => _r.mark(mr.removeFromSet(_r.marks));
  else
    return null;
  let yr = [];
  for (let _r = 0; _r < ar.childCount; _r++)
    yr.push(vr(ar.child(_r)));
  if (Fragment.from(yr).eq(cr))
    return { mark: mr, type: gr };
}
function looksLikeJoin(cr, ar, lr, ur, dr) {
  if (!ur.parent.isTextblock || // The content must have shrunk
  lr - ar <= dr.pos - ur.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening(ur, !0, !1) < dr.pos)
    return !1;
  let fr = cr.resolve(ar);
  if (fr.parentOffset < fr.parent.content.size || !fr.parent.isTextblock)
    return !1;
  let gr = cr.resolve(skipClosingAndOpening(fr, !0, !0));
  return !gr.parent.isTextblock || gr.pos > lr || skipClosingAndOpening(gr, !0, !1) < lr ? !1 : ur.parent.content.cut(ur.parentOffset).eq(gr.parent.content);
}
function skipClosingAndOpening(cr, ar, lr) {
  let ur = cr.depth, dr = ar ? cr.end() : cr.pos;
  for (; ur > 0 && (ar || cr.indexAfter(ur) == cr.node(ur).childCount); )
    ur--, dr++, ar = !1;
  if (lr) {
    let fr = cr.node(ur).maybeChild(cr.indexAfter(ur));
    for (; fr && !fr.isLeaf; )
      fr = fr.firstChild, dr++;
  }
  return dr;
}
function findDiff(cr, ar, lr, ur, dr) {
  let fr = cr.findDiffStart(ar, lr);
  if (fr == null)
    return null;
  let { a: gr, b: mr } = cr.findDiffEnd(ar, lr + cr.size, lr + ar.size);
  if (dr == "end") {
    let vr = Math.max(0, fr - Math.min(gr, mr));
    ur -= gr + vr - fr;
  }
  if (gr < fr && cr.size < ar.size) {
    let vr = ur <= fr && ur >= gr ? fr - ur : 0;
    fr -= vr, fr && fr < ar.size && isSurrogatePair(ar.textBetween(fr - 1, fr + 1)) && (fr += vr ? 1 : -1), mr = fr + (mr - gr), gr = fr;
  } else if (mr < fr) {
    let vr = ur <= fr && ur >= mr ? fr - ur : 0;
    fr -= vr, fr && fr < cr.size && isSurrogatePair(cr.textBetween(fr - 1, fr + 1)) && (fr += vr ? 1 : -1), gr = fr + (gr - mr), mr = fr;
  }
  return { start: fr, endA: gr, endB: mr };
}
function isSurrogatePair(cr) {
  if (cr.length != 2)
    return !1;
  let ar = cr.charCodeAt(0), lr = cr.charCodeAt(1);
  return ar >= 56320 && ar <= 57343 && lr >= 55296 && lr <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(ar, lr) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new InputState(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = lr, this.state = lr.state, this.directPlugins = lr.plugins || [], this.directPlugins.forEach(checkStateComponent), this.dispatch = this.dispatch.bind(this), this.dom = ar && ar.mount || document.createElement("div"), ar && (ar.appendChild ? ar.appendChild(this.dom) : typeof ar == "function" ? ar(this.dom) : ar.mount && (this.mounted = !0)), this.editable = getEditable(this), updateCursorWrapper(this), this.nodeViews = buildNodeViews(this), this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this), this.domObserver = new DOMObserver(this, (ur, dr, fr, gr) => readDOMChange(this, ur, dr, fr, gr)), this.domObserver.start(), initInput(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let ar = this._props;
      this._props = {};
      for (let lr in ar)
        this._props[lr] = ar[lr];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(ar) {
    ar.handleDOMEvents != this._props.handleDOMEvents && ensureListeners(this);
    let lr = this._props;
    this._props = ar, ar.plugins && (ar.plugins.forEach(checkStateComponent), this.directPlugins = ar.plugins), this.updateStateInner(ar.state, lr);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(ar) {
    let lr = {};
    for (let ur in this._props)
      lr[ur] = this._props[ur];
    lr.state = this.state;
    for (let ur in ar)
      lr[ur] = ar[ur];
    this.update(lr);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(ar) {
    this.updateStateInner(ar, this._props);
  }
  updateStateInner(ar, lr) {
    var ur;
    let dr = this.state, fr = !1, gr = !1;
    ar.storedMarks && this.composing && (clearComposition(this), gr = !0), this.state = ar;
    let mr = dr.plugins != ar.plugins || this._props.plugins != lr.plugins;
    if (mr || this._props.plugins != lr.plugins || this._props.nodeViews != lr.nodeViews) {
      let Ar = buildNodeViews(this);
      changedNodeViews(Ar, this.nodeViews) && (this.nodeViews = Ar, fr = !0);
    }
    (mr || lr.handleDOMEvents != this._props.handleDOMEvents) && ensureListeners(this), this.editable = getEditable(this), updateCursorWrapper(this);
    let vr = viewDecorations(this), yr = computeDocDeco(this), _r = dr.plugins != ar.plugins && !dr.doc.eq(ar.doc) ? "reset" : ar.scrollToSelection > dr.scrollToSelection ? "to selection" : "preserve", kr = fr || !this.docView.matchesNode(ar.doc, yr, vr);
    (kr || !ar.selection.eq(dr.selection)) && (gr = !0);
    let xr = _r == "preserve" && gr && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (gr) {
      this.domObserver.stop();
      let Ar = kr && (ie$1 || chrome) && !this.composing && !dr.selection.empty && !ar.selection.empty && selectionContextChanged(dr.selection, ar.selection);
      if (kr) {
        let Er = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (fr || !this.docView.update(ar.doc, yr, vr, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = docViewDesc(ar.doc, yr, vr, this.dom, this)), Er && !this.trackWrites && (Ar = !0);
      }
      Ar || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this)) ? selectionToDOM(this, Ar) : (syncNodeSelection(this, ar.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(dr), !((ur = this.dragging) === null || ur === void 0) && ur.node && !dr.doc.eq(ar.doc) && this.updateDraggedNode(this.dragging, dr), _r == "reset" ? this.dom.scrollTop = 0 : _r == "to selection" ? this.scrollToSelection() : xr && resetScrollPos(xr);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let ar = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (lr) => lr(this)))
      if (this.state.selection instanceof NodeSelection) {
        let lr = this.docView.domAfterPos(this.state.selection.from);
        lr.nodeType == 1 && scrollRectIntoView(this, lr.getBoundingClientRect(), ar);
      } else
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), ar);
  }
  destroyPluginViews() {
    let ar;
    for (; ar = this.pluginViews.pop(); )
      ar.destroy && ar.destroy();
  }
  updatePluginViews(ar) {
    if (!ar || ar.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let lr = 0; lr < this.directPlugins.length; lr++) {
        let ur = this.directPlugins[lr];
        ur.spec.view && this.pluginViews.push(ur.spec.view(this));
      }
      for (let lr = 0; lr < this.state.plugins.length; lr++) {
        let ur = this.state.plugins[lr];
        ur.spec.view && this.pluginViews.push(ur.spec.view(this));
      }
    } else
      for (let lr = 0; lr < this.pluginViews.length; lr++) {
        let ur = this.pluginViews[lr];
        ur.update && ur.update(this, ar);
      }
  }
  updateDraggedNode(ar, lr) {
    let ur = ar.node, dr = -1;
    if (this.state.doc.nodeAt(ur.from) == ur.node)
      dr = ur.from;
    else {
      let fr = ur.from + (this.state.doc.content.size - lr.doc.content.size);
      (fr > 0 && this.state.doc.nodeAt(fr)) == ur.node && (dr = fr);
    }
    this.dragging = new Dragging(ar.slice, ar.move, dr < 0 ? void 0 : NodeSelection.create(this.state.doc, dr));
  }
  someProp(ar, lr) {
    let ur = this._props && this._props[ar], dr;
    if (ur != null && (dr = lr ? lr(ur) : ur))
      return dr;
    for (let gr = 0; gr < this.directPlugins.length; gr++) {
      let mr = this.directPlugins[gr].props[ar];
      if (mr != null && (dr = lr ? lr(mr) : mr))
        return dr;
    }
    let fr = this.state.plugins;
    if (fr)
      for (let gr = 0; gr < fr.length; gr++) {
        let mr = fr[gr].props[ar];
        if (mr != null && (dr = lr ? lr(mr) : mr))
          return dr;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let ar = this.root.activeElement;
      if (ar == this.dom)
        return !0;
      if (!ar || !this.dom.contains(ar))
        return !1;
      for (; ar && this.dom != ar && this.dom.contains(ar); ) {
        if (ar.contentEditable == "false")
          return !1;
        ar = ar.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && focusPreventScroll(this.dom), selectionToDOM(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let ar = this._root;
    if (ar == null) {
      for (let lr = this.dom.parentNode; lr; lr = lr.parentNode)
        if (lr.nodeType == 9 || lr.nodeType == 11 && lr.host)
          return lr.getSelection || (Object.getPrototypeOf(lr).getSelection = () => lr.ownerDocument.getSelection()), this._root = lr;
    }
    return ar || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(ar) {
    return posAtCoords(this, ar);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(ar, lr = 1) {
    return coordsAtPos(this, ar, lr);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(ar, lr = 0) {
    return this.docView.domFromPos(ar, lr);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(ar) {
    let lr = this.docView.descAt(ar);
    return lr ? lr.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(ar, lr, ur = -1) {
    let dr = this.docView.posFromDOM(ar, lr, ur);
    if (dr == null)
      throw new RangeError("DOM position not inside the editor");
    return dr;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(ar, lr) {
    return endOfTextblock(this, lr || this.state, ar);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(ar, lr) {
    return doPaste(this, "", ar, !1, lr || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(ar, lr) {
    return doPaste(this, ar, null, !0, lr || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (destroyInput(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], viewDecorations(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(ar) {
    return dispatchEvent$1(this, ar);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(ar) {
    let lr = this._props.dispatchTransaction;
    lr ? lr.call(this, ar) : this.updateState(this.state.apply(ar));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function computeDocDeco(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  return ar.class = "ProseMirror", ar.contenteditable = String(cr.editable), cr.someProp("attributes", (lr) => {
    if (typeof lr == "function" && (lr = lr(cr.state)), lr)
      for (let ur in lr)
        ur == "class" ? ar.class += " " + lr[ur] : ur == "style" ? ar.style = (ar.style ? ar.style + ";" : "") + lr[ur] : !ar[ur] && ur != "contenteditable" && ur != "nodeName" && (ar[ur] = String(lr[ur]));
  }), ar.translate || (ar.translate = "no"), [Decoration.node(0, cr.state.doc.content.size, ar)];
}
function updateCursorWrapper(cr) {
  if (cr.markCursor) {
    let ar = document.createElement("img");
    ar.className = "ProseMirror-separator", ar.setAttribute("mark-placeholder", "true"), ar.setAttribute("alt", ""), cr.cursorWrapper = { dom: ar, deco: Decoration.widget(cr.state.selection.head, ar, { raw: !0, marks: cr.markCursor }) };
  } else
    cr.cursorWrapper = null;
}
function getEditable(cr) {
  return !cr.someProp("editable", (ar) => ar(cr.state) === !1);
}
function selectionContextChanged(cr, ar) {
  let lr = Math.min(cr.$anchor.sharedDepth(cr.head), ar.$anchor.sharedDepth(ar.head));
  return cr.$anchor.start(lr) != ar.$anchor.start(lr);
}
function buildNodeViews(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  function lr(ur) {
    for (let dr in ur)
      Object.prototype.hasOwnProperty.call(ar, dr) || (ar[dr] = ur[dr]);
  }
  return cr.someProp("nodeViews", lr), cr.someProp("markViews", lr), ar;
}
function changedNodeViews(cr, ar) {
  let lr = 0, ur = 0;
  for (let dr in cr) {
    if (cr[dr] != ar[dr])
      return !0;
    lr++;
  }
  for (let dr in ar)
    ur++;
  return lr != ur;
}
function checkStateComponent(cr) {
  if (cr.spec.state || cr.spec.filterTransaction || cr.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, mac$2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform), ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++)
  base[i] = String.fromCharCode(i + 32), shift[i] = String.fromCharCode(i);
for (var code$1 in base)
  shift.hasOwnProperty(code$1) || (shift[code$1] = base[code$1]);
function keyName(cr) {
  var ar = mac$2 && cr.metaKey && cr.shiftKey && !cr.ctrlKey && !cr.altKey || ie && cr.shiftKey && cr.key && cr.key.length == 1 || cr.key == "Unidentified", lr = !ar && cr.key || (cr.shiftKey ? shift : base)[cr.keyCode] || cr.key || "Unidentified";
  return lr == "Esc" && (lr = "Escape"), lr == "Del" && (lr = "Delete"), lr == "Left" && (lr = "ArrowLeft"), lr == "Up" && (lr = "ArrowUp"), lr == "Right" && (lr = "ArrowRight"), lr == "Down" && (lr = "ArrowDown"), lr;
}
const mac$1 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function normalizeKeyName(cr) {
  let ar = cr.split(/-(?!$)/), lr = ar[ar.length - 1];
  lr == "Space" && (lr = " ");
  let ur, dr, fr, gr;
  for (let mr = 0; mr < ar.length - 1; mr++) {
    let vr = ar[mr];
    if (/^(cmd|meta|m)$/i.test(vr))
      gr = !0;
    else if (/^a(lt)?$/i.test(vr))
      ur = !0;
    else if (/^(c|ctrl|control)$/i.test(vr))
      dr = !0;
    else if (/^s(hift)?$/i.test(vr))
      fr = !0;
    else if (/^mod$/i.test(vr))
      mac$1 ? gr = !0 : dr = !0;
    else
      throw new Error("Unrecognized modifier name: " + vr);
  }
  return ur && (lr = "Alt-" + lr), dr && (lr = "Ctrl-" + lr), gr && (lr = "Meta-" + lr), fr && (lr = "Shift-" + lr), lr;
}
function normalize(cr) {
  let ar = /* @__PURE__ */ Object.create(null);
  for (let lr in cr)
    ar[normalizeKeyName(lr)] = cr[lr];
  return ar;
}
function modifiers(cr, ar, lr = !0) {
  return ar.altKey && (cr = "Alt-" + cr), ar.ctrlKey && (cr = "Ctrl-" + cr), ar.metaKey && (cr = "Meta-" + cr), lr && ar.shiftKey && (cr = "Shift-" + cr), cr;
}
function keymap(cr) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(cr) } });
}
function keydownHandler(cr) {
  let ar = normalize(cr);
  return function(lr, ur) {
    let dr = keyName(ur), fr, gr = ar[modifiers(dr, ur)];
    if (gr && gr(lr.state, lr.dispatch, lr))
      return !0;
    if (dr.length == 1 && dr != " ") {
      if (ur.shiftKey) {
        let mr = ar[modifiers(dr, ur, !1)];
        if (mr && mr(lr.state, lr.dispatch, lr))
          return !0;
      }
      if ((ur.shiftKey || ur.altKey || ur.metaKey || dr.charCodeAt(0) > 127) && (fr = base[ur.keyCode]) && fr != dr) {
        let mr = ar[modifiers(fr, ur)];
        if (mr && mr(lr.state, lr.dispatch, lr))
          return !0;
      }
    }
    return !1;
  };
}
const deleteSelection = (cr, ar) => cr.selection.empty ? !1 : (ar && ar(cr.tr.deleteSelection().scrollIntoView()), !0);
function atBlockStart(cr, ar) {
  let { $cursor: lr } = cr.selection;
  return !lr || (ar ? !ar.endOfTextblock("backward", cr) : lr.parentOffset > 0) ? null : lr;
}
const joinBackward = (cr, ar, lr) => {
  let ur = atBlockStart(cr, lr);
  if (!ur)
    return !1;
  let dr = findCutBefore(ur);
  if (!dr) {
    let gr = ur.blockRange(), mr = gr && liftTarget(gr);
    return mr == null ? !1 : (ar && ar(cr.tr.lift(gr, mr).scrollIntoView()), !0);
  }
  let fr = dr.nodeBefore;
  if (!fr.type.spec.isolating && deleteBarrier(cr, dr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(fr, "end") || NodeSelection.isSelectable(fr))) {
    let gr = replaceStep(cr.doc, ur.before(), ur.after(), Slice.empty);
    if (gr && gr.slice.size < gr.to - gr.from) {
      if (ar) {
        let mr = cr.tr.step(gr);
        mr.setSelection(textblockAt(fr, "end") ? Selection.findFrom(mr.doc.resolve(mr.mapping.map(dr.pos, -1)), -1) : NodeSelection.create(mr.doc, dr.pos - fr.nodeSize)), ar(mr.scrollIntoView());
      }
      return !0;
    }
  }
  return fr.isAtom && dr.depth == ur.depth - 1 ? (ar && ar(cr.tr.delete(dr.pos - fr.nodeSize, dr.pos).scrollIntoView()), !0) : !1;
};
function textblockAt(cr, ar, lr = !1) {
  for (let ur = cr; ur; ur = ar == "start" ? ur.firstChild : ur.lastChild) {
    if (ur.isTextblock)
      return !0;
    if (lr && ur.childCount != 1)
      return !1;
  }
  return !1;
}
const selectNodeBackward = (cr, ar, lr) => {
  let { $head: ur, empty: dr } = cr.selection, fr = ur;
  if (!dr)
    return !1;
  if (ur.parent.isTextblock) {
    if (lr ? !lr.endOfTextblock("backward", cr) : ur.parentOffset > 0)
      return !1;
    fr = findCutBefore(ur);
  }
  let gr = fr && fr.nodeBefore;
  return !gr || !NodeSelection.isSelectable(gr) ? !1 : (ar && ar(cr.tr.setSelection(NodeSelection.create(cr.doc, fr.pos - gr.nodeSize)).scrollIntoView()), !0);
};
function findCutBefore(cr) {
  if (!cr.parent.type.spec.isolating)
    for (let ar = cr.depth - 1; ar >= 0; ar--) {
      if (cr.index(ar) > 0)
        return cr.doc.resolve(cr.before(ar + 1));
      if (cr.node(ar).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(cr, ar) {
  let { $cursor: lr } = cr.selection;
  return !lr || (ar ? !ar.endOfTextblock("forward", cr) : lr.parentOffset < lr.parent.content.size) ? null : lr;
}
const joinForward = (cr, ar, lr) => {
  let ur = atBlockEnd(cr, lr);
  if (!ur)
    return !1;
  let dr = findCutAfter(ur);
  if (!dr)
    return !1;
  let fr = dr.nodeAfter;
  if (deleteBarrier(cr, dr, ar))
    return !0;
  if (ur.parent.content.size == 0 && (textblockAt(fr, "start") || NodeSelection.isSelectable(fr))) {
    let gr = replaceStep(cr.doc, ur.before(), ur.after(), Slice.empty);
    if (gr && gr.slice.size < gr.to - gr.from) {
      if (ar) {
        let mr = cr.tr.step(gr);
        mr.setSelection(textblockAt(fr, "start") ? Selection.findFrom(mr.doc.resolve(mr.mapping.map(dr.pos)), 1) : NodeSelection.create(mr.doc, mr.mapping.map(dr.pos))), ar(mr.scrollIntoView());
      }
      return !0;
    }
  }
  return fr.isAtom && dr.depth == ur.depth - 1 ? (ar && ar(cr.tr.delete(dr.pos, dr.pos + fr.nodeSize).scrollIntoView()), !0) : !1;
}, selectNodeForward = (cr, ar, lr) => {
  let { $head: ur, empty: dr } = cr.selection, fr = ur;
  if (!dr)
    return !1;
  if (ur.parent.isTextblock) {
    if (lr ? !lr.endOfTextblock("forward", cr) : ur.parentOffset < ur.parent.content.size)
      return !1;
    fr = findCutAfter(ur);
  }
  let gr = fr && fr.nodeAfter;
  return !gr || !NodeSelection.isSelectable(gr) ? !1 : (ar && ar(cr.tr.setSelection(NodeSelection.create(cr.doc, fr.pos)).scrollIntoView()), !0);
};
function findCutAfter(cr) {
  if (!cr.parent.type.spec.isolating)
    for (let ar = cr.depth - 1; ar >= 0; ar--) {
      let lr = cr.node(ar);
      if (cr.index(ar) + 1 < lr.childCount)
        return cr.doc.resolve(cr.after(ar + 1));
      if (lr.type.spec.isolating)
        break;
    }
  return null;
}
const newlineInCode = (cr, ar) => {
  let { $head: lr, $anchor: ur } = cr.selection;
  return !lr.parent.type.spec.code || !lr.sameParent(ur) ? !1 : (ar && ar(cr.tr.insertText(`
`).scrollIntoView()), !0);
};
function defaultBlockAt(cr) {
  for (let ar = 0; ar < cr.edgeCount; ar++) {
    let { type: lr } = cr.edge(ar);
    if (lr.isTextblock && !lr.hasRequiredAttrs())
      return lr;
  }
  return null;
}
const exitCode = (cr, ar) => {
  let { $head: lr, $anchor: ur } = cr.selection;
  if (!lr.parent.type.spec.code || !lr.sameParent(ur))
    return !1;
  let dr = lr.node(-1), fr = lr.indexAfter(-1), gr = defaultBlockAt(dr.contentMatchAt(fr));
  if (!gr || !dr.canReplaceWith(fr, fr, gr))
    return !1;
  if (ar) {
    let mr = lr.after(), vr = cr.tr.replaceWith(mr, mr, gr.createAndFill());
    vr.setSelection(Selection.near(vr.doc.resolve(mr), 1)), ar(vr.scrollIntoView());
  }
  return !0;
}, createParagraphNear = (cr, ar) => {
  let lr = cr.selection, { $from: ur, $to: dr } = lr;
  if (lr instanceof AllSelection || ur.parent.inlineContent || dr.parent.inlineContent)
    return !1;
  let fr = defaultBlockAt(dr.parent.contentMatchAt(dr.indexAfter()));
  if (!fr || !fr.isTextblock)
    return !1;
  if (ar) {
    let gr = (!ur.parentOffset && dr.index() < dr.parent.childCount ? ur : dr).pos, mr = cr.tr.insert(gr, fr.createAndFill());
    mr.setSelection(TextSelection.create(mr.doc, gr + 1)), ar(mr.scrollIntoView());
  }
  return !0;
}, liftEmptyBlock = (cr, ar) => {
  let { $cursor: lr } = cr.selection;
  if (!lr || lr.parent.content.size)
    return !1;
  if (lr.depth > 1 && lr.after() != lr.end(-1)) {
    let fr = lr.before();
    if (canSplit(cr.doc, fr))
      return ar && ar(cr.tr.split(fr).scrollIntoView()), !0;
  }
  let ur = lr.blockRange(), dr = ur && liftTarget(ur);
  return dr == null ? !1 : (ar && ar(cr.tr.lift(ur, dr).scrollIntoView()), !0);
};
function splitBlockAs(cr) {
  return (ar, lr) => {
    let { $from: ur, $to: dr } = ar.selection;
    if (ar.selection instanceof NodeSelection && ar.selection.node.isBlock)
      return !ur.parentOffset || !canSplit(ar.doc, ur.pos) ? !1 : (lr && lr(ar.tr.split(ur.pos).scrollIntoView()), !0);
    if (!ur.parent.isBlock)
      return !1;
    if (lr) {
      let fr = dr.parentOffset == dr.parent.content.size, gr = ar.tr;
      (ar.selection instanceof TextSelection || ar.selection instanceof AllSelection) && gr.deleteSelection();
      let mr = ur.depth == 0 ? null : defaultBlockAt(ur.node(-1).contentMatchAt(ur.indexAfter(-1))), vr = cr && cr(dr.parent, fr), yr = vr ? [vr] : fr && mr ? [{ type: mr }] : void 0, _r = canSplit(gr.doc, gr.mapping.map(ur.pos), 1, yr);
      if (!yr && !_r && canSplit(gr.doc, gr.mapping.map(ur.pos), 1, mr ? [{ type: mr }] : void 0) && (mr && (yr = [{ type: mr }]), _r = !0), _r && (gr.split(gr.mapping.map(ur.pos), 1, yr), !fr && !ur.parentOffset && ur.parent.type != mr)) {
        let kr = gr.mapping.map(ur.before()), xr = gr.doc.resolve(kr);
        mr && ur.node(-1).canReplaceWith(xr.index(), xr.index() + 1, mr) && gr.setNodeMarkup(gr.mapping.map(ur.before()), mr);
      }
      lr(gr.scrollIntoView());
    }
    return !0;
  };
}
const splitBlock = splitBlockAs(), selectAll = (cr, ar) => (ar && ar(cr.tr.setSelection(new AllSelection(cr.doc))), !0);
function joinMaybeClear(cr, ar, lr) {
  let ur = ar.nodeBefore, dr = ar.nodeAfter, fr = ar.index();
  return !ur || !dr || !ur.type.compatibleContent(dr.type) ? !1 : !ur.content.size && ar.parent.canReplace(fr - 1, fr) ? (lr && lr(cr.tr.delete(ar.pos - ur.nodeSize, ar.pos).scrollIntoView()), !0) : !ar.parent.canReplace(fr, fr + 1) || !(dr.isTextblock || canJoin(cr.doc, ar.pos)) ? !1 : (lr && lr(cr.tr.clearIncompatible(ar.pos, ur.type, ur.contentMatchAt(ur.childCount)).join(ar.pos).scrollIntoView()), !0);
}
function deleteBarrier(cr, ar, lr) {
  let ur = ar.nodeBefore, dr = ar.nodeAfter, fr, gr;
  if (ur.type.spec.isolating || dr.type.spec.isolating)
    return !1;
  if (joinMaybeClear(cr, ar, lr))
    return !0;
  let mr = ar.parent.canReplace(ar.index(), ar.index() + 1);
  if (mr && (fr = (gr = ur.contentMatchAt(ur.childCount)).findWrapping(dr.type)) && gr.matchType(fr[0] || dr.type).validEnd) {
    if (lr) {
      let kr = ar.pos + dr.nodeSize, xr = Fragment.empty;
      for (let Cr = fr.length - 1; Cr >= 0; Cr--)
        xr = Fragment.from(fr[Cr].create(null, xr));
      xr = Fragment.from(ur.copy(xr));
      let Ar = cr.tr.step(new ReplaceAroundStep(ar.pos - 1, kr, ar.pos, kr, new Slice(xr, 1, 0), fr.length, !0)), Er = kr + 2 * fr.length;
      canJoin(Ar.doc, Er) && Ar.join(Er), lr(Ar.scrollIntoView());
    }
    return !0;
  }
  let vr = Selection.findFrom(ar, 1), yr = vr && vr.$from.blockRange(vr.$to), _r = yr && liftTarget(yr);
  if (_r != null && _r >= ar.depth)
    return lr && lr(cr.tr.lift(yr, _r).scrollIntoView()), !0;
  if (mr && textblockAt(dr, "start", !0) && textblockAt(ur, "end")) {
    let kr = ur, xr = [];
    for (; xr.push(kr), !kr.isTextblock; )
      kr = kr.lastChild;
    let Ar = dr, Er = 1;
    for (; !Ar.isTextblock; Ar = Ar.firstChild)
      Er++;
    if (kr.canReplace(kr.childCount, kr.childCount, Ar.content)) {
      if (lr) {
        let Cr = Fragment.empty;
        for (let Sr = xr.length - 1; Sr >= 0; Sr--)
          Cr = Fragment.from(xr[Sr].copy(Cr));
        let Tr = cr.tr.step(new ReplaceAroundStep(ar.pos - xr.length, ar.pos + dr.nodeSize, ar.pos + Er, ar.pos + dr.nodeSize - Er, new Slice(Cr, xr.length, 0), 0, !0));
        lr(Tr.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function selectTextblockSide(cr) {
  return function(ar, lr) {
    let ur = ar.selection, dr = cr < 0 ? ur.$from : ur.$to, fr = dr.depth;
    for (; dr.node(fr).isInline; ) {
      if (!fr)
        return !1;
      fr--;
    }
    return dr.node(fr).isTextblock ? (lr && lr(ar.tr.setSelection(TextSelection.create(ar.doc, cr < 0 ? dr.start(fr) : dr.end(fr)))), !0) : !1;
  };
}
const selectTextblockStart = selectTextblockSide(-1), selectTextblockEnd = selectTextblockSide(1);
function wrapIn(cr, ar = null) {
  return function(lr, ur) {
    let { $from: dr, $to: fr } = lr.selection, gr = dr.blockRange(fr), mr = gr && findWrapping(gr, cr, ar);
    return mr ? (ur && ur(lr.tr.wrap(gr, mr).scrollIntoView()), !0) : !1;
  };
}
function setBlockType(cr, ar = null) {
  return function(lr, ur) {
    let dr = !1;
    for (let fr = 0; fr < lr.selection.ranges.length && !dr; fr++) {
      let { $from: { pos: gr }, $to: { pos: mr } } = lr.selection.ranges[fr];
      lr.doc.nodesBetween(gr, mr, (vr, yr) => {
        if (dr)
          return !1;
        if (!(!vr.isTextblock || vr.hasMarkup(cr, ar)))
          if (vr.type == cr)
            dr = !0;
          else {
            let _r = lr.doc.resolve(yr), kr = _r.index();
            dr = _r.parent.canReplaceWith(kr, kr + 1, cr);
          }
      });
    }
    if (!dr)
      return !1;
    if (ur) {
      let fr = lr.tr;
      for (let gr = 0; gr < lr.selection.ranges.length; gr++) {
        let { $from: { pos: mr }, $to: { pos: vr } } = lr.selection.ranges[gr];
        fr.setBlockType(mr, vr, cr, ar);
      }
      ur(fr.scrollIntoView());
    }
    return !0;
  };
}
function markApplies(cr, ar, lr) {
  for (let ur = 0; ur < ar.length; ur++) {
    let { $from: dr, $to: fr } = ar[ur], gr = dr.depth == 0 ? cr.inlineContent && cr.type.allowsMarkType(lr) : !1;
    if (cr.nodesBetween(dr.pos, fr.pos, (mr) => {
      if (gr)
        return !1;
      gr = mr.inlineContent && mr.type.allowsMarkType(lr);
    }), gr)
      return !0;
  }
  return !1;
}
function toggleMark$1(cr, ar = null) {
  return function(lr, ur) {
    let { empty: dr, $cursor: fr, ranges: gr } = lr.selection;
    if (dr && !fr || !markApplies(lr.doc, gr, cr))
      return !1;
    if (ur)
      if (fr)
        cr.isInSet(lr.storedMarks || fr.marks()) ? ur(lr.tr.removeStoredMark(cr)) : ur(lr.tr.addStoredMark(cr.create(ar)));
      else {
        let mr = !1, vr = lr.tr;
        for (let yr = 0; !mr && yr < gr.length; yr++) {
          let { $from: _r, $to: kr } = gr[yr];
          mr = lr.doc.rangeHasMark(_r.pos, kr.pos, cr);
        }
        for (let yr = 0; yr < gr.length; yr++) {
          let { $from: _r, $to: kr } = gr[yr];
          if (mr)
            vr.removeMark(_r.pos, kr.pos, cr);
          else {
            let xr = _r.pos, Ar = kr.pos, Er = _r.nodeAfter, Cr = kr.nodeBefore, Tr = Er && Er.isText ? /^\s*/.exec(Er.text)[0].length : 0, Sr = Cr && Cr.isText ? /\s*$/.exec(Cr.text)[0].length : 0;
            xr + Tr < Ar && (xr += Tr, Ar -= Sr), vr.addMark(xr, Ar, cr.create(ar));
          }
        }
        ur(vr.scrollIntoView());
      }
    return !0;
  };
}
function chainCommands(...cr) {
  return function(ar, lr, ur) {
    for (let dr = 0; dr < cr.length; dr++)
      if (cr[dr](ar, lr, ur))
        return !0;
    return !1;
  };
}
let backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward), del = chainCommands(deleteSelection, joinForward, selectNodeForward);
const pcBaseKeymap = {
  Enter: chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  Backspace: backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  Delete: del,
  "Mod-Delete": del,
  "Mod-a": selectAll
}, macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap.Backspace,
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap.Delete,
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let cr in pcBaseKeymap)
  macBaseKeymap[cr] = pcBaseKeymap[cr];
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : !1, baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
class InputRule {
  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number)  ?Transaction>)
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(ar, lr, ur = {}) {
    this.match = ar, this.match = ar, this.handler = typeof lr == "string" ? stringHandler(lr) : lr, this.undoable = ur.undoable !== !1;
  }
}
function stringHandler(cr) {
  return function(ar, lr, ur, dr) {
    let fr = cr;
    if (lr[1]) {
      let gr = lr[0].lastIndexOf(lr[1]);
      fr += lr[0].slice(gr + lr[1].length), ur += gr;
      let mr = ur - dr;
      mr > 0 && (fr = lr[0].slice(gr - mr, gr) + fr, ur = dr);
    }
    return ar.tr.insertText(fr, ur, dr);
  };
}
const MAX_MATCH = 500;
function inputRules({ rules: cr }) {
  let ar = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(lr, ur) {
        let dr = lr.getMeta(this);
        return dr || (lr.selectionSet || lr.docChanged ? null : ur);
      }
    },
    props: {
      handleTextInput(lr, ur, dr, fr) {
        return run$1(lr, ur, dr, fr, cr, ar);
      },
      handleDOMEvents: {
        compositionend: (lr) => {
          setTimeout(() => {
            let { $cursor: ur } = lr.state.selection;
            ur && run$1(lr, ur.pos, ur.pos, "", cr, ar);
          });
        }
      }
    },
    isInputRules: !0
  });
  return ar;
}
function run$1(cr, ar, lr, ur, dr, fr) {
  if (cr.composing)
    return !1;
  let gr = cr.state, mr = gr.doc.resolve(ar);
  if (mr.parent.type.spec.code)
    return !1;
  let vr = mr.parent.textBetween(Math.max(0, mr.parentOffset - MAX_MATCH), mr.parentOffset, null, "") + ur;
  for (let yr = 0; yr < dr.length; yr++) {
    let _r = dr[yr], kr = _r.match.exec(vr), xr = kr && _r.handler(gr, kr, ar - (kr[0].length - ur.length), lr);
    if (xr)
      return _r.undoable && xr.setMeta(fr, { transform: xr, from: ar, to: lr, text: ur }), cr.dispatch(xr), !0;
  }
  return !1;
}
const undoInputRule = (cr, ar) => {
  let lr = cr.plugins;
  for (let ur = 0; ur < lr.length; ur++) {
    let dr = lr[ur], fr;
    if (dr.spec.isInputRules && (fr = dr.getState(cr))) {
      if (ar) {
        let gr = cr.tr, mr = fr.transform;
        for (let vr = mr.steps.length - 1; vr >= 0; vr--)
          gr.step(mr.steps[vr].invert(mr.docs[vr]));
        if (fr.text) {
          let vr = gr.doc.resolve(fr.from).marks();
          gr.replaceWith(fr.from, fr.to, cr.schema.text(fr.text, vr));
        } else
          gr.delete(fr.from, fr.to);
        ar(gr);
      }
      return !0;
    }
  }
  return !1;
};
new InputRule(/--$/, "");
new InputRule(/\.\.\.$/, "");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "");
new InputRule(/"$/, "");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "");
new InputRule(/'$/, "");
var GOOD_LEAF_SIZE = 200, RopeSequence = function cr() {
};
RopeSequence.prototype.append = function cr(ar) {
  return ar.length ? (ar = RopeSequence.from(ar), !this.length && ar || ar.length < GOOD_LEAF_SIZE && this.leafAppend(ar) || this.length < GOOD_LEAF_SIZE && ar.leafPrepend(this) || this.appendInner(ar)) : this;
};
RopeSequence.prototype.prepend = function cr(ar) {
  return ar.length ? RopeSequence.from(ar).append(this) : this;
};
RopeSequence.prototype.appendInner = function cr(ar) {
  return new Append(this, ar);
};
RopeSequence.prototype.slice = function cr(ar, lr) {
  return ar === void 0 && (ar = 0), lr === void 0 && (lr = this.length), ar >= lr ? RopeSequence.empty : this.sliceInner(Math.max(0, ar), Math.min(this.length, lr));
};
RopeSequence.prototype.get = function cr(ar) {
  if (!(ar < 0 || ar >= this.length))
    return this.getInner(ar);
};
RopeSequence.prototype.forEach = function cr(ar, lr, ur) {
  lr === void 0 && (lr = 0), ur === void 0 && (ur = this.length), lr <= ur ? this.forEachInner(ar, lr, ur, 0) : this.forEachInvertedInner(ar, lr, ur, 0);
};
RopeSequence.prototype.map = function cr(ar, lr, ur) {
  lr === void 0 && (lr = 0), ur === void 0 && (ur = this.length);
  var dr = [];
  return this.forEach(function(fr, gr) {
    return dr.push(ar(fr, gr));
  }, lr, ur), dr;
};
RopeSequence.from = function cr(ar) {
  return ar instanceof RopeSequence ? ar : ar && ar.length ? new Leaf(ar) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(cr) {
  function ar(ur) {
    cr.call(this), this.values = ur;
  }
  cr && (ar.__proto__ = cr), ar.prototype = Object.create(cr && cr.prototype), ar.prototype.constructor = ar;
  var lr = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return ar.prototype.flatten = function() {
    return this.values;
  }, ar.prototype.sliceInner = function(dr, fr) {
    return dr == 0 && fr == this.length ? this : new ar(this.values.slice(dr, fr));
  }, ar.prototype.getInner = function(dr) {
    return this.values[dr];
  }, ar.prototype.forEachInner = function(dr, fr, gr, mr) {
    for (var vr = fr; vr < gr; vr++)
      if (dr(this.values[vr], mr + vr) === !1)
        return !1;
  }, ar.prototype.forEachInvertedInner = function(dr, fr, gr, mr) {
    for (var vr = fr - 1; vr >= gr; vr--)
      if (dr(this.values[vr], mr + vr) === !1)
        return !1;
  }, ar.prototype.leafAppend = function(dr) {
    if (this.length + dr.length <= GOOD_LEAF_SIZE)
      return new ar(this.values.concat(dr.flatten()));
  }, ar.prototype.leafPrepend = function(dr) {
    if (this.length + dr.length <= GOOD_LEAF_SIZE)
      return new ar(dr.flatten().concat(this.values));
  }, lr.length.get = function() {
    return this.values.length;
  }, lr.depth.get = function() {
    return 0;
  }, Object.defineProperties(ar.prototype, lr), ar;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(cr) {
  function ar(lr, ur) {
    cr.call(this), this.left = lr, this.right = ur, this.length = lr.length + ur.length, this.depth = Math.max(lr.depth, ur.depth) + 1;
  }
  return cr && (ar.__proto__ = cr), ar.prototype = Object.create(cr && cr.prototype), ar.prototype.constructor = ar, ar.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, ar.prototype.getInner = function(ur) {
    return ur < this.left.length ? this.left.get(ur) : this.right.get(ur - this.left.length);
  }, ar.prototype.forEachInner = function(ur, dr, fr, gr) {
    var mr = this.left.length;
    if (dr < mr && this.left.forEachInner(ur, dr, Math.min(fr, mr), gr) === !1 || fr > mr && this.right.forEachInner(ur, Math.max(dr - mr, 0), Math.min(this.length, fr) - mr, gr + mr) === !1)
      return !1;
  }, ar.prototype.forEachInvertedInner = function(ur, dr, fr, gr) {
    var mr = this.left.length;
    if (dr > mr && this.right.forEachInvertedInner(ur, dr - mr, Math.max(fr, mr) - mr, gr + mr) === !1 || fr < mr && this.left.forEachInvertedInner(ur, Math.min(dr, mr), fr, gr) === !1)
      return !1;
  }, ar.prototype.sliceInner = function(ur, dr) {
    if (ur == 0 && dr == this.length)
      return this;
    var fr = this.left.length;
    return dr <= fr ? this.left.slice(ur, dr) : ur >= fr ? this.right.slice(ur - fr, dr - fr) : this.left.slice(ur, fr).append(this.right.slice(0, dr - fr));
  }, ar.prototype.leafAppend = function(ur) {
    var dr = this.right.leafAppend(ur);
    if (dr)
      return new ar(this.left, dr);
  }, ar.prototype.leafPrepend = function(ur) {
    var dr = this.left.leafPrepend(ur);
    if (dr)
      return new ar(dr, this.right);
  }, ar.prototype.appendInner = function(ur) {
    return this.left.depth >= Math.max(this.right.depth, ur.depth) + 1 ? new ar(this.left, new ar(this.right, ur)) : new ar(this, ur);
  }, ar;
}(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(ar, lr) {
    this.items = ar, this.eventCount = lr;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(ar, lr) {
    if (this.eventCount == 0)
      return null;
    let ur = this.items.length;
    for (; ; ur--)
      if (this.items.get(ur - 1).selection) {
        --ur;
        break;
      }
    let dr, fr;
    lr && (dr = this.remapping(ur, this.items.length), fr = dr.maps.length);
    let gr = ar.tr, mr, vr, yr = [], _r = [];
    return this.items.forEach((kr, xr) => {
      if (!kr.step) {
        dr || (dr = this.remapping(ur, xr + 1), fr = dr.maps.length), fr--, _r.push(kr);
        return;
      }
      if (dr) {
        _r.push(new Item(kr.map));
        let Ar = kr.step.map(dr.slice(fr)), Er;
        Ar && gr.maybeStep(Ar).doc && (Er = gr.mapping.maps[gr.mapping.maps.length - 1], yr.push(new Item(Er, void 0, void 0, yr.length + _r.length))), fr--, Er && dr.appendMap(Er, fr);
      } else
        gr.maybeStep(kr.step);
      if (kr.selection)
        return mr = dr ? kr.selection.map(dr.slice(fr)) : kr.selection, vr = new Branch(this.items.slice(0, ur).append(_r.reverse().concat(yr)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: vr, transform: gr, selection: mr };
  }
  // Create a new branch with the given transform added.
  addTransform(ar, lr, ur, dr) {
    let fr = [], gr = this.eventCount, mr = this.items, vr = !dr && mr.length ? mr.get(mr.length - 1) : null;
    for (let _r = 0; _r < ar.steps.length; _r++) {
      let kr = ar.steps[_r].invert(ar.docs[_r]), xr = new Item(ar.mapping.maps[_r], kr, lr), Ar;
      (Ar = vr && vr.merge(xr)) && (xr = Ar, _r ? fr.pop() : mr = mr.slice(0, mr.length - 1)), fr.push(xr), lr && (gr++, lr = void 0), dr || (vr = xr);
    }
    let yr = gr - ur.depth;
    return yr > DEPTH_OVERFLOW && (mr = cutOffEvents(mr, yr), gr -= yr), new Branch(mr.append(fr), gr);
  }
  remapping(ar, lr) {
    let ur = new Mapping();
    return this.items.forEach((dr, fr) => {
      let gr = dr.mirrorOffset != null && fr - dr.mirrorOffset >= ar ? ur.maps.length - dr.mirrorOffset : void 0;
      ur.appendMap(dr.map, gr);
    }, ar, lr), ur;
  }
  addMaps(ar) {
    return this.eventCount == 0 ? this : new Branch(this.items.append(ar.map((lr) => new Item(lr))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(ar, lr) {
    if (!this.eventCount)
      return this;
    let ur = [], dr = Math.max(0, this.items.length - lr), fr = ar.mapping, gr = ar.steps.length, mr = this.eventCount;
    this.items.forEach((xr) => {
      xr.selection && mr--;
    }, dr);
    let vr = lr;
    this.items.forEach((xr) => {
      let Ar = fr.getMirror(--vr);
      if (Ar == null)
        return;
      gr = Math.min(gr, Ar);
      let Er = fr.maps[Ar];
      if (xr.step) {
        let Cr = ar.steps[Ar].invert(ar.docs[Ar]), Tr = xr.selection && xr.selection.map(fr.slice(vr + 1, Ar));
        Tr && mr++, ur.push(new Item(Er, Cr, Tr));
      } else
        ur.push(new Item(Er));
    }, dr);
    let yr = [];
    for (let xr = lr; xr < gr; xr++)
      yr.push(new Item(fr.maps[xr]));
    let _r = this.items.slice(0, dr).append(yr).append(ur), kr = new Branch(_r, mr);
    return kr.emptyItemCount() > max_empty_items && (kr = kr.compress(this.items.length - ur.length)), kr;
  }
  emptyItemCount() {
    let ar = 0;
    return this.items.forEach((lr) => {
      lr.step || ar++;
    }), ar;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(ar = this.items.length) {
    let lr = this.remapping(0, ar), ur = lr.maps.length, dr = [], fr = 0;
    return this.items.forEach((gr, mr) => {
      if (mr >= ar)
        dr.push(gr), gr.selection && fr++;
      else if (gr.step) {
        let vr = gr.step.map(lr.slice(ur)), yr = vr && vr.getMap();
        if (ur--, yr && lr.appendMap(yr, ur), vr) {
          let _r = gr.selection && gr.selection.map(lr.slice(ur));
          _r && fr++;
          let kr = new Item(yr.invert(), vr, _r), xr, Ar = dr.length - 1;
          (xr = dr.length && dr[Ar].merge(kr)) ? dr[Ar] = xr : dr.push(kr);
        }
      } else
        gr.map && ur--;
    }, this.items.length, 0), new Branch(RopeSequence.from(dr.reverse()), fr);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(cr, ar) {
  let lr;
  return cr.forEach((ur, dr) => {
    if (ur.selection && ar-- == 0)
      return lr = dr, !1;
  }), cr.slice(lr);
}
class Item {
  constructor(ar, lr, ur, dr) {
    this.map = ar, this.step = lr, this.selection = ur, this.mirrorOffset = dr;
  }
  merge(ar) {
    if (this.step && ar.step && !ar.selection) {
      let lr = ar.step.merge(this.step);
      if (lr)
        return new Item(lr.getMap().invert(), lr, this.selection);
    }
  }
}
class HistoryState {
  constructor(ar, lr, ur, dr, fr) {
    this.done = ar, this.undone = lr, this.prevRanges = ur, this.prevTime = dr, this.prevComposition = fr;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(cr, ar, lr, ur) {
  let dr = lr.getMeta(historyKey), fr;
  if (dr)
    return dr.historyState;
  lr.getMeta(closeHistoryKey) && (cr = new HistoryState(cr.done, cr.undone, null, 0, -1));
  let gr = lr.getMeta("appendedTransaction");
  if (lr.steps.length == 0)
    return cr;
  if (gr && gr.getMeta(historyKey))
    return gr.getMeta(historyKey).redo ? new HistoryState(cr.done.addTransform(lr, void 0, ur, mustPreserveItems(ar)), cr.undone, rangesFor(lr.mapping.maps[lr.steps.length - 1]), cr.prevTime, cr.prevComposition) : new HistoryState(cr.done, cr.undone.addTransform(lr, void 0, ur, mustPreserveItems(ar)), null, cr.prevTime, cr.prevComposition);
  if (lr.getMeta("addToHistory") !== !1 && !(gr && gr.getMeta("addToHistory") === !1)) {
    let mr = lr.getMeta("composition"), vr = cr.prevTime == 0 || !gr && cr.prevComposition != mr && (cr.prevTime < (lr.time || 0) - ur.newGroupDelay || !isAdjacentTo(lr, cr.prevRanges)), yr = gr ? mapRanges(cr.prevRanges, lr.mapping) : rangesFor(lr.mapping.maps[lr.steps.length - 1]);
    return new HistoryState(cr.done.addTransform(lr, vr ? ar.selection.getBookmark() : void 0, ur, mustPreserveItems(ar)), Branch.empty, yr, lr.time, mr == null ? cr.prevComposition : mr);
  } else
    return (fr = lr.getMeta("rebased")) ? new HistoryState(cr.done.rebased(lr, fr), cr.undone.rebased(lr, fr), mapRanges(cr.prevRanges, lr.mapping), cr.prevTime, cr.prevComposition) : new HistoryState(cr.done.addMaps(lr.mapping.maps), cr.undone.addMaps(lr.mapping.maps), mapRanges(cr.prevRanges, lr.mapping), cr.prevTime, cr.prevComposition);
}
function isAdjacentTo(cr, ar) {
  if (!ar)
    return !1;
  if (!cr.docChanged)
    return !0;
  let lr = !1;
  return cr.mapping.maps[0].forEach((ur, dr) => {
    for (let fr = 0; fr < ar.length; fr += 2)
      ur <= ar[fr + 1] && dr >= ar[fr] && (lr = !0);
  }), lr;
}
function rangesFor(cr) {
  let ar = [];
  return cr.forEach((lr, ur, dr, fr) => ar.push(dr, fr)), ar;
}
function mapRanges(cr, ar) {
  if (!cr)
    return null;
  let lr = [];
  for (let ur = 0; ur < cr.length; ur += 2) {
    let dr = ar.map(cr[ur], 1), fr = ar.map(cr[ur + 1], -1);
    dr <= fr && lr.push(dr, fr);
  }
  return lr;
}
function histTransaction(cr, ar, lr, ur) {
  let dr = mustPreserveItems(ar), fr = historyKey.get(ar).spec.config, gr = (ur ? cr.undone : cr.done).popEvent(ar, dr);
  if (!gr)
    return;
  let mr = gr.selection.resolve(gr.transform.doc), vr = (ur ? cr.done : cr.undone).addTransform(gr.transform, ar.selection.getBookmark(), fr, dr), yr = new HistoryState(ur ? vr : gr.remaining, ur ? gr.remaining : vr, null, 0, -1);
  lr(gr.transform.setSelection(mr).setMeta(historyKey, { redo: ur, historyState: yr }).scrollIntoView());
}
let cachedPreserveItems = !1, cachedPreserveItemsPlugins = null;
function mustPreserveItems(cr) {
  let ar = cr.plugins;
  if (cachedPreserveItemsPlugins != ar) {
    cachedPreserveItems = !1, cachedPreserveItemsPlugins = ar;
    for (let lr = 0; lr < ar.length; lr++)
      if (ar[lr].spec.historyPreserveItems) {
        cachedPreserveItems = !0;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history"), closeHistoryKey = new PluginKey("closeHistory");
function history(cr = {}) {
  return cr = {
    depth: cr.depth || 100,
    newGroupDelay: cr.newGroupDelay || 500
  }, new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(ar, lr, ur) {
        return applyTransaction(lr, ur, ar, cr);
      }
    },
    config: cr,
    props: {
      handleDOMEvents: {
        beforeinput(ar, lr) {
          let ur = lr.inputType, dr = ur == "historyUndo" ? undo : ur == "historyRedo" ? redo : null;
          return dr ? (lr.preventDefault(), dr(ar.state, ar.dispatch)) : !1;
        }
      }
    }
  });
}
const undo = (cr, ar) => {
  let lr = historyKey.getState(cr);
  return !lr || lr.done.eventCount == 0 ? !1 : (ar && histTransaction(lr, cr, ar, !1), !0);
}, redo = (cr, ar) => {
  let lr = historyKey.getState(cr);
  return !lr || lr.undone.eventCount == 0 ? !1 : (ar && histTransaction(lr, cr, ar, !0), !0);
};
function undoDepth(cr) {
  let ar = historyKey.getState(cr);
  return ar ? ar.done.eventCount : 0;
}
/**
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(cr, ar) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(lr, ur) {
    lr.__proto__ = ur;
  } || function(lr, ur) {
    for (var dr in ur)
      Object.prototype.hasOwnProperty.call(ur, dr) && (lr[dr] = ur[dr]);
  }, extendStatics$1(cr, ar);
};
function __extends$1(cr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics$1(cr, ar);
  function lr() {
    this.constructor = cr;
  }
  cr.prototype = ar === null ? Object.create(ar) : (lr.prototype = ar.prototype, new lr());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(ar) {
    for (var lr, ur = 1, dr = arguments.length; ur < dr; ur++) {
      lr = arguments[ur];
      for (var fr in lr)
        Object.prototype.hasOwnProperty.call(lr, fr) && (ar[fr] = lr[fr]);
    }
    return ar;
  }, __assign$1.apply(this, arguments);
};
function __spreadArray$1(cr, ar, lr) {
  if (lr || arguments.length === 2)
    for (var ur = 0, dr = ar.length, fr; ur < dr; ur++)
      (fr || !(ur in ar)) && (fr || (fr = Array.prototype.slice.call(ar, 0, ur)), fr[ur] = ar[ur]);
  return cr.concat(fr || Array.prototype.slice.call(ar));
}
function __makeTemplateObject(cr, ar) {
  return Object.defineProperty ? Object.defineProperty(cr, "raw", { value: ar }) : cr.raw = ar, cr;
}
function forEachOwnProperties$2(cr, ar, lr) {
  var ur;
  lr = lr || null;
  for (ur in cr)
    if (cr.hasOwnProperty(ur) && ar.call(lr, cr[ur], ur, cr) === !1)
      break;
}
var forEachOwnProperties_1 = forEachOwnProperties$2;
function extend(cr, ar) {
  var lr = Object.prototype.hasOwnProperty, ur, dr, fr, gr;
  for (fr = 1, gr = arguments.length; fr < gr; fr += 1) {
    ur = arguments[fr];
    for (dr in ur)
      lr.call(ur, dr) && (cr[dr] = ur[dr]);
  }
  return cr;
}
var extend_1 = extend;
function isString$3(cr) {
  return typeof cr == "string" || cr instanceof String;
}
var isString_1 = isString$3;
function isArray$3(cr) {
  return cr instanceof Array;
}
var isArray_1 = isArray$3;
function forEachArray$3(cr, ar, lr) {
  var ur = 0, dr = cr.length;
  for (lr = lr || null; ur < dr && ar.call(lr, cr[ur], ur, cr) !== !1; ur += 1)
    ;
}
var forEachArray_1 = forEachArray$3, isArray$2 = isArray_1, forEachArray$2 = forEachArray_1, forEachOwnProperties$1 = forEachOwnProperties_1;
function forEach$4(cr, ar, lr) {
  isArray$2(cr) ? forEachArray$2(cr, ar, lr) : forEachOwnProperties$1(cr, ar, lr);
}
var forEach_1 = forEach$4, isString$2 = isString_1, forEach$3 = forEach_1;
function css$1(cr, ar, lr) {
  var ur = cr.style;
  if (isString$2(ar)) {
    ur[ar] = lr;
    return;
  }
  forEach$3(ar, function(dr, fr) {
    ur[fr] = dr;
  });
}
var css_1 = css$1, isArray$1 = isArray_1;
function inArray$4(cr, ar, lr) {
  var ur, dr;
  if (lr = lr || 0, !isArray$1(ar))
    return -1;
  if (Array.prototype.indexOf)
    return Array.prototype.indexOf.call(ar, cr, lr);
  for (dr = ar.length, ur = lr; lr >= 0 && ur < dr; ur += 1)
    if (ar[ur] === cr)
      return ur;
  return -1;
}
var inArray_1 = inArray$4;
function isUndefined$4(cr) {
  return cr === void 0;
}
var isUndefined_1 = isUndefined$4, isUndefined$3 = isUndefined_1;
function getClass$3(cr) {
  return !cr || !cr.className ? "" : isUndefined$3(cr.className.baseVal) ? cr.className : cr.className.baseVal;
}
var getClass_1 = getClass$3, isArray = isArray_1, isUndefined$2 = isUndefined_1;
function setClassName$2(cr, ar) {
  if (ar = isArray(ar) ? ar.join(" ") : ar, ar = ar.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), isUndefined$2(cr.className.baseVal)) {
    cr.className = ar;
    return;
  }
  cr.className.baseVal = ar;
}
var _setClassName = setClassName$2, forEach$2 = forEach_1, inArray$3 = inArray_1, getClass$2 = getClass_1, setClassName$1 = _setClassName;
function addClass(cr) {
  var ar = Array.prototype.slice.call(arguments, 1), lr = cr.classList, ur = [], dr;
  if (lr) {
    forEach$2(ar, function(fr) {
      cr.classList.add(fr);
    });
    return;
  }
  dr = getClass$2(cr), dr && (ar = [].concat(dr.split(/\s+/), ar)), forEach$2(ar, function(fr) {
    inArray$3(fr, ur) < 0 && ur.push(fr);
  }), setClassName$1(cr, ur);
}
var addClass_1 = addClass, forEachArray$1 = forEachArray_1, inArray$2 = inArray_1, getClass$1 = getClass_1, setClassName = _setClassName;
function removeClass(cr) {
  var ar = Array.prototype.slice.call(arguments, 1), lr = cr.classList, ur, dr;
  if (lr) {
    forEachArray$1(ar, function(fr) {
      lr.remove(fr);
    });
    return;
  }
  ur = getClass$1(cr).split(/\s+/), dr = [], forEachArray$1(ur, function(fr) {
    inArray$2(fr, ar) < 0 && dr.push(fr);
  }), setClassName(cr, dr);
}
var removeClass_1 = removeClass;
function isNumber(cr) {
  return typeof cr == "number" || cr instanceof Number;
}
var isNumber_1 = isNumber;
function isNull$1(cr) {
  return cr === null;
}
var isNull_1 = isNull$1, forEachOwnProperties = forEachOwnProperties_1;
function imagePing$1(cr, ar) {
  var lr = document.createElement("img"), ur = "";
  return forEachOwnProperties(ar, function(dr, fr) {
    ur += "&" + fr + "=" + dr;
  }), ur = ur.substring(1), lr.src = cr + "?" + ur, lr.style.display = "none", document.body.appendChild(lr), document.body.removeChild(lr), lr;
}
var imagePing_1 = imagePing$1, isUndefined$1 = isUndefined_1, imagePing = imagePing_1, ms7days = 7 * 24 * 60 * 60 * 1e3;
function isExpired(cr) {
  var ar = (/* @__PURE__ */ new Date()).getTime();
  return ar - cr > ms7days;
}
function sendHostname(cr, ar) {
  var lr = "https://www.google-analytics.com/collect", ur = location.hostname, dr = "event", fr = "use", gr = "TOAST UI " + cr + " for " + ur + ": Statistics", mr = window.localStorage.getItem(gr);
  !isUndefined$1(window.tui) && window.tui.usageStatistics === !1 || mr && !isExpired(mr) || (window.localStorage.setItem(gr, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
    (document.readyState === "interactive" || document.readyState === "complete") && imagePing(lr, {
      v: 1,
      t: dr,
      tid: ar,
      cid: ur,
      dp: ur,
      dh: cr,
      el: cr,
      ec: fr
    });
  }, 1e3));
}
var sendHostname_1 = sendHostname, reSpaceMoreThanOne = /[\u0020]+/g, reEscapeChars$1 = /[>(){}[\]+-.!#|]/g, reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g, reEscapeBackSlash = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g, reEscapePairedChars = /[*_~`]/g, reMdImageSyntax = /!\[.*\]\(.*\)/g, reEscapedCharInLinkSyntax = /[[\]]/g, reEscapeBackSlashInSentence = /(?:^|[^\\])\\(?!\\)/g, XMLSPECIAL$1 = '[&<>"]', reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, "g");
function replaceUnsafeChar$1(cr) {
  switch (cr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return cr;
  }
}
function escapeXml$1(cr) {
  return reXmlSpecial$1.test(cr) ? cr.replace(reXmlSpecial$1, replaceUnsafeChar$1) : cr;
}
function sendHostName() {
  sendHostname_1("editor", "UA-129966929-1");
}
function includes(cr, ar) {
  return cr.indexOf(ar) !== -1;
}
var availableLinkAttributes = ["rel", "target", "hreflang", "type"], reMarkdownTextToEscapeMap = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function sanitizeLinkAttribute(cr) {
  if (!cr)
    return null;
  var ar = {};
  return availableLinkAttributes.forEach(function(lr) {
    isUndefined_1(cr[lr]) || (ar[lr] = cr[lr]);
  }), ar;
}
function repeat$1(cr, ar) {
  for (var lr = "", ur = 0; ur < ar; ur += 1)
    lr += cr;
  return lr;
}
function isNeedEscapeText(cr) {
  var ar = !1;
  return forEachOwnProperties_1(reMarkdownTextToEscapeMap, function(lr) {
    return lr.test(cr) && (ar = !0), !ar;
  }), ar;
}
function escapeTextForLink(cr) {
  for (var ar = [], lr = reMdImageSyntax.exec(cr); lr; )
    ar.push([lr.index, lr.index + lr[0].length]), lr = reMdImageSyntax.exec(cr);
  return cr.replace(reEscapedCharInLinkSyntax, function(ur, dr) {
    var fr = ar.some(function(gr) {
      return dr > gr[0] && dr < gr[1];
    });
    return fr ? ur : "\\" + ur;
  });
}
function escape$1$1(cr) {
  var ar = function(dr) {
    return "\\" + dr;
  }, lr = function(dr) {
    return dr + "\\";
  }, ur = cr.replace(reSpaceMoreThanOne, " ");
  return reEscapeBackSlash.test(ur) && (ur = ur.replace(reEscapeBackSlash, ar)), reEscapeBackSlashInSentence.test(ur) && (ur = ur.replace(reEscapeBackSlashInSentence, lr)), ur = ur.replace(reEscapePairedChars, ar), reEscapeHTML.test(ur) && (ur = ur.replace(reEscapeHTML, ar)), isNeedEscapeText(ur) && (ur = ur.replace(reEscapeChars$1, ar)), ur;
}
function quote(cr) {
  var ar;
  return cr.indexOf('"') === -1 ? ar = '""' : ar = cr.indexOf("'") === -1 ? "''" : "()", ar[0] + cr + ar[1];
}
function isNil(cr) {
  return isNull_1(cr) || isUndefined_1(cr);
}
function shallowEqual(cr, ar) {
  if (cr === null && cr === ar)
    return !0;
  if (typeof cr != "object" || typeof ar != "object" || isNil(cr) || isNil(ar))
    return cr === ar;
  for (var lr in cr)
    if (cr[lr] !== ar[lr])
      return !1;
  for (var lr in ar)
    if (!(lr in cr))
      return !1;
  return !0;
}
function last$1(cr) {
  return cr[cr.length - 1];
}
function between$1(cr, ar, lr) {
  return cr >= ar && cr <= lr;
}
function isObject$1(cr) {
  return typeof cr == "object" && cr !== null;
}
function deepMergedCopy(cr, ar) {
  var lr = __assign$1({}, cr);
  return cr && ar && Object.keys(ar).forEach(function(ur) {
    isObject$1(lr[ur]) ? Array.isArray(ar[ur]) ? lr[ur] = deepCopyArray(ar[ur]) : lr.hasOwnProperty(ur) ? lr[ur] = deepMergedCopy(lr[ur], ar[ur]) : lr[ur] = deepCopy(ar[ur]) : lr[ur] = ar[ur];
  }), lr;
}
function deepCopyArray(cr) {
  return cr.map(function(ar) {
    return isObject$1(ar) ? Array.isArray(ar) ? deepCopyArray(ar) : deepCopy(ar) : ar;
  });
}
function deepCopy(cr) {
  var ar = Object.keys(cr);
  return ar.length ? ar.reduce(function(lr, ur) {
    return isObject$1(cr[ur]) ? lr[ur] = Array.isArray(cr[ur]) ? deepCopyArray(cr[ur]) : deepCopy(cr[ur]) : lr[ur] = cr[ur], lr;
  }, {}) : cr;
}
function assign(cr, ar) {
  return ar === void 0 && (ar = {}), Object.keys(ar).forEach(function(lr) {
    cr.hasOwnProperty(lr) && typeof cr[lr] == "object" ? Array.isArray(ar[lr]) ? cr[lr] = ar[lr] : assign(cr[lr], ar[lr]) : cr[lr] = ar[lr];
  }), cr;
}
function getSortedNumPair(cr, ar) {
  return cr > ar ? [ar, cr] : [cr, ar];
}
var forEachArray = forEachArray_1;
function toArray$1(cr) {
  var ar;
  try {
    ar = Array.prototype.slice.call(cr);
  } catch (lr) {
    ar = [], forEachArray(cr, function(ur) {
      ar.push(ur);
    });
  }
  return ar;
}
var toArray_1 = toArray$1;
function createParagraph(cr, ar) {
  var lr = cr.nodes.paragraph;
  return ar ? lr.create(null, isString_1(ar) ? cr.text(ar) : ar) : lr.createAndFill();
}
function createTextNode$1(cr, ar, lr) {
  return cr.text(ar, lr);
}
function createTextSelection(cr, ar, lr) {
  lr === void 0 && (lr = ar);
  var ur = cr.doc.content.size, dr = ur > 0 ? ur - 1 : 1;
  return TextSelection.create(cr.doc, Math.min(ar, dr), Math.min(lr, dr));
}
function addParagraph(cr, ar, lr) {
  var ur = ar.pos;
  return cr.replaceWith(ur, ur, createParagraph(lr)), cr.setSelection(createTextSelection(cr, ur + 1));
}
function replaceTextNode(cr) {
  for (var ar = cr.state, lr = cr.from, ur = cr.startIndex, dr = cr.endIndex, fr = cr.createText, gr = ar.tr, mr = ar.doc, vr = ar.schema, yr = ur; yr <= dr; yr += 1) {
    var _r = mr.child(yr), kr = _r.nodeSize, xr = _r.textContent, Ar = _r.content, Er = fr(xr), Cr = Er ? createTextNode$1(vr, Er) : Fragment.empty, Tr = gr.mapping.map(lr), Sr = Tr + Ar.size;
    gr.replaceWith(Tr, Sr, Cr), lr += kr;
  }
  return gr;
}
function splitAndExtendBlock(cr, ar, lr, ur) {
  var dr = lr.length;
  cr.split(ar).delete(ar - dr, ar).insert(cr.mapping.map(ar), ur).setSelection(createTextSelection(cr, cr.mapping.map(ar) - dr));
}
function getMdStartLine(cr) {
  return cr.sourcepos[0][0];
}
function getMdEndLine(cr) {
  return cr.sourcepos[1][0];
}
function getMdStartCh(cr) {
  return cr.sourcepos[0][1];
}
function getMdEndCh(cr) {
  return cr.sourcepos[1][1];
}
function isHTMLNode(cr) {
  var ar = cr.type;
  return ar === "htmlBlock" || ar === "htmlInline";
}
function isStyledInlineNode(cr) {
  var ar = cr.type;
  return ar === "strike" || ar === "strong" || ar === "emph" || ar === "code" || ar === "link" || ar === "image";
}
function isCodeBlockNode(cr) {
  return cr && cr.type === "codeBlock";
}
function isListNode$1(cr) {
  return cr && (cr.type === "item" || cr.type === "list");
}
function isOrderedListNode(cr) {
  return isListNode$1(cr) && cr.listData.type === "ordered";
}
function isBulletListNode(cr) {
  return isListNode$1(cr) && cr.listData.type !== "ordered";
}
function isTableCellNode(cr) {
  return cr && (cr.type === "tableCell" || cr.type === "tableDelimCell");
}
function isInlineNode$1(cr) {
  switch (cr.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function findClosestNode(cr, ar, lr) {
  for (lr === void 0 && (lr = !0), cr = lr ? cr : cr.parent; cr && cr.type !== "document"; ) {
    if (ar(cr))
      return cr;
    cr = cr.parent;
  }
  return null;
}
function traverseParentNodes(cr, ar, lr) {
  for (lr === void 0 && (lr = !0), cr = lr ? cr : cr.parent; cr && cr.type !== "document"; )
    ar(cr), cr = cr.parent;
}
function addOffsetPos(cr, ar) {
  return [cr[0], cr[1] + ar];
}
function setOffsetPos(cr, ar) {
  return [cr[0], ar];
}
function getInlineMarkdownText(cr) {
  var ar = cr.firstChild.literal;
  switch (cr.type) {
    case "emph":
      return "*" + ar + "*";
    case "strong":
      return "**" + ar + "**";
    case "strike":
      return "~~" + ar + "~~";
    case "code":
      return "`" + ar + "`";
    case "link":
    case "image":
      var lr = cr, ur = lr.destination, dr = lr.title, fr = cr.type === "link" ? "" : "!";
      return fr + "[" + ar + "](" + ur + (dr ? ' "' + dr + '"' : "") + ")";
    default:
      return null;
  }
}
function isContainer$2(cr) {
  switch (cr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function getChildrenText$1(cr) {
  for (var ar = [], lr = cr.walker(), ur = null; ur = lr.next(); ) {
    var dr = ur.node;
    dr.type === "text" && ar.push(dr.literal);
  }
  return ar.join("");
}
var widgetRules = [], widgetRuleMap = {}, reWidgetPrefix = /\$\$widget\d+\s/;
function unwrapWidgetSyntax(cr) {
  var ar = cr.search(reWidgetPrefix);
  if (ar !== -1) {
    var lr = cr.substring(ar), ur = lr.replace(reWidgetPrefix, "").replace("$$", "");
    cr = cr.substring(0, ar), cr += unwrapWidgetSyntax(ur);
  }
  return cr;
}
function createWidgetContent(cr, ar) {
  return "$$" + cr + " " + ar + "$$";
}
function widgetToDOM(cr, ar) {
  var lr = widgetRuleMap[cr], ur = lr.rule, dr = lr.toDOM, fr = unwrapWidgetSyntax(ar).match(ur);
  return fr && (ar = fr[0]), dr(ar);
}
function getWidgetRules() {
  return widgetRules;
}
function setWidgetRules(cr) {
  widgetRules = cr, widgetRules.forEach(function(ar, lr) {
    widgetRuleMap["widget" + lr] = ar;
  });
}
function mergeNodes(cr, ar, lr, ur) {
  return cr.concat(createNodesWithWidget(ar, lr, ur));
}
function createNodesWithWidget(cr, ar, lr) {
  lr === void 0 && (lr = 0);
  var ur = [], dr = (widgetRules[lr] || {}).rule, fr = lr + 1;
  if (cr = unwrapWidgetSyntax(cr), dr && dr.test(cr)) {
    for (var gr = void 0; (gr = cr.search(dr)) !== -1; ) {
      var mr = cr.substring(0, gr);
      mr && (ur = mergeNodes(ur, mr, ar, fr)), cr = cr.substring(gr);
      var vr = cr.match(dr)[0], yr = "widget" + lr;
      ur.push(ar.nodes.widget.create({ info: yr }, ar.text(createWidgetContent(yr, vr)))), cr = cr.substring(vr.length);
    }
    cr && (ur = mergeNodes(ur, cr, ar, fr));
  } else
    cr && (ur = lr < widgetRules.length - 1 ? mergeNodes(ur, cr, ar, fr) : [ar.text(cr)]);
  return ur;
}
function getWidgetContent(cr) {
  for (var ar, lr = "", ur = cr.walker(); ar = ur.next(); ) {
    var dr = ar.node, fr = ar.entering;
    fr && (dr !== cr && dr.type !== "text" ? (lr += getInlineMarkdownText(dr), ur.resumeAt(cr, !1), ur.next()) : dr.type === "text" && (lr += dr.literal));
  }
  return lr;
}
function getDefaultCommands() {
  return {
    deleteSelection: function() {
      return deleteSelection;
    },
    selectAll: function() {
      return selectAll;
    },
    undo: function() {
      return undo;
    },
    redo: function() {
      return redo;
    }
  };
}
function placeholder(cr) {
  return new Plugin({
    props: {
      decorations: function(ar) {
        var lr = ar.doc;
        if (cr.text && lr.childCount === 1 && lr.firstChild.isTextblock && lr.firstChild.content.size === 0) {
          var ur = document.createElement("span");
          return addClass_1(ur, "placeholder"), cr.className && addClass_1(ur, cr.className), ur.textContent = cr.text, DecorationSet.create(lr, [Decoration.widget(1, ur)]);
        }
        return null;
      }
    }
  });
}
var inArray$1 = inArray_1, getClass = getClass_1;
function hasClass(cr, ar) {
  var lr;
  return cr.classList ? cr.classList.contains(ar) : (lr = getClass(cr).split(/\s+/), inArray$1(ar, lr) > -1);
}
var hasClass_1 = hasClass, inArray = inArray_1, toArray = toArray_1, elProto = Element.prototype, matchSelector = elProto.matches || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || function(cr) {
  var ar = this.document || this.ownerDocument;
  return inArray(this, toArray(ar.querySelectorAll(cr))) > -1;
};
function matches(cr, ar) {
  return matchSelector.call(cr, ar);
}
var matches_1 = matches, TAG_NAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTE_NAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTED_VALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLE_QUOTED_VALUE = "'[^']*'", DOUBLE_QUOTED_VALUE = '"[^"]*"', ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")", ATTRIBUTE_VALUE_SPEC = "(?:\\s*=\\s*" + ATTRIBUTE_VALUE + ")", ATTRIBUTE$1 = "(?:\\s+" + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)", OPEN_TAG = "<(" + TAG_NAME + ")(" + ATTRIBUTE$1 + ")*\\s*/?>", CLOSE_TAG = "</(" + TAG_NAME + ")\\s*[>]", HTML_TAG = "(?:" + OPEN_TAG + "|" + CLOSE_TAG + ")", reHTMLTag = new RegExp("^" + HTML_TAG, "i"), reBR = /<br\s*\/*>/i, reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/, ALTERNATIVE_TAG_FOR_BR = "</p><p>";
function isPositionInBox(cr, ar, lr) {
  var ur = parseInt(cr.left, 10), dr = parseInt(cr.top, 10), fr = parseInt(cr.width, 10) + parseInt(cr.paddingLeft, 10) + parseInt(cr.paddingRight, 10), gr = parseInt(cr.height, 10) + parseInt(cr.paddingTop, 10) + parseInt(cr.paddingBottom, 10);
  return ar >= ur && ar <= ur + fr && lr >= dr && lr <= dr + gr;
}
var CLS_PREFIX = "toastui-editor-";
function cls() {
  for (var cr = [], ar = 0; ar < arguments.length; ar++)
    cr[ar] = arguments[ar];
  for (var lr = [], ur = 0, dr = cr; ur < dr.length; ur++) {
    var fr = dr[ur], gr = void 0;
    Array.isArray(fr) ? gr = fr[0] ? fr[1] : null : gr = fr, gr && lr.push("" + CLS_PREFIX + gr);
  }
  return lr.join(" ");
}
function clsWithMdPrefix() {
  for (var cr = [], ar = 0; ar < arguments.length; ar++)
    cr[ar] = arguments[ar];
  return cr.map(function(lr) {
    return CLS_PREFIX + "md-" + lr;
  }).join(" ");
}
function isTextNode(cr) {
  return (cr == null ? void 0 : cr.nodeType) === Node.TEXT_NODE;
}
function isElemNode(cr) {
  return cr && cr.nodeType === Node.ELEMENT_NODE;
}
function findNodes(cr, ar) {
  var lr = toArray_1(cr.querySelectorAll(ar));
  return lr.length ? lr : [];
}
function appendNodes(cr, ar) {
  ar = isArray_1(ar) ? toArray_1(ar) : [ar], ar.forEach(function(lr) {
    cr.appendChild(lr);
  });
}
function insertBeforeNode(cr, ar) {
  ar.parentNode && ar.parentNode.insertBefore(cr, ar);
}
function removeNode$1(cr) {
  cr.parentNode && cr.parentNode.removeChild(cr);
}
function unwrapNode(cr) {
  for (var ar = []; cr.firstChild; )
    ar.push(cr.firstChild), cr.parentNode && cr.parentNode.insertBefore(cr.firstChild, cr);
  return removeNode$1(cr), ar;
}
function toggleClass(cr, ar, lr) {
  isUndefined_1(lr) && (lr = !hasClass_1(cr, ar));
  var ur = lr ? addClass_1 : removeClass_1;
  ur(cr, ar);
}
function createElementWith(cr, ar) {
  var lr = document.createElement("div");
  isString_1(cr) ? lr.innerHTML = cr : lr.appendChild(cr);
  var ur = lr.firstChild;
  return ar && ar.appendChild(ur), ur;
}
function getOuterWidth(cr) {
  var ar = window.getComputedStyle(cr);
  return ["margin-left", "margin-right"].reduce(function(lr, ur) {
    return lr + parseInt(ar.getPropertyValue(ur), 10);
  }, 0) + cr.offsetWidth;
}
function closest(cr, ar) {
  var lr;
  for (isString_1(ar) ? lr = function(ur) {
    return matches_1(ur, ar);
  } : lr = function(ur) {
    return ur === ar;
  }; cr && cr !== document; ) {
    if (isElemNode(cr) && lr(cr))
      return cr;
    cr = cr.parentNode;
  }
  return null;
}
function getTotalOffset(cr, ar) {
  for (var lr = 0, ur = 0; cr && cr !== ar; ) {
    var dr = cr.offsetTop, fr = cr.offsetLeft, gr = cr.offsetParent;
    if (lr += dr, ur += fr, gr === ar.offsetParent)
      break;
    cr = cr.offsetParent;
  }
  return { offsetTop: lr, offsetLeft: ur };
}
function setAttributes(cr, ar) {
  Object.keys(cr).forEach(function(lr) {
    isNil(cr[lr]) ? ar.removeAttribute(lr) : ar.setAttribute(lr, cr[lr]);
  });
}
function replaceBRWithEmptyBlock(cr) {
  var ar = cr.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"), lr = new RegExp(HTML_TAG, "ig"), ur = ar.match(lr);
  return ur == null || ur.forEach(function(dr, fr) {
    if (reBR.test(dr)) {
      var gr = ALTERNATIVE_TAG_FOR_BR;
      if (fr) {
        var mr = ur[fr - 1], vr = mr.match(OPEN_TAG);
        if (vr && !/br/i.test(vr[1])) {
          var yr = vr[1];
          gr = "</" + yr + "><" + yr + ">";
        }
      }
      ar = ar.replace(reBR, gr);
    }
  }), ar;
}
function removeProseMirrorHackNodes(cr) {
  var ar = /<img class="ProseMirror-separator" alt="">/g, lr = / class="ProseMirror-trailingBreak"/g, ur = cr;
  return ur = ur.replace(ar, ""), ur = ur.replace(lr, ""), ur;
}
var pluginKey$1 = new PluginKey("widget"), MARGIN = 5, PopupWidget = (
  /** @class */
  function() {
    function cr(ar, lr) {
      var ur = this;
      this.popup = null, this.removeWidget = function() {
        ur.popup && (ur.rootEl.removeChild(ur.popup), ur.popup = null);
      }, this.rootEl = ar.dom.parentElement, this.eventEmitter = lr, this.eventEmitter.listen("blur", this.removeWidget), this.eventEmitter.listen("loadUI", function() {
        ur.rootEl = closest(ar.dom.parentElement, "." + cls("defaultUI"));
      }), this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    return cr.prototype.update = function(ar) {
      var lr = pluginKey$1.getState(ar.state);
      if (this.removeWidget(), lr) {
        var ur = lr.node, dr = lr.style, fr = ar.coordsAtPos(lr.pos), gr = fr.top, mr = fr.left, vr = fr.bottom, yr = vr - gr, _r = this.rootEl.getBoundingClientRect(), kr = gr - _r.top;
        css_1(ur, { opacity: "0" }), this.rootEl.appendChild(ur), css_1(ur, {
          position: "absolute",
          left: mr - _r.left + MARGIN + "px",
          top: (dr === "bottom" ? kr + yr - MARGIN : kr - yr) + "px",
          opacity: "1"
        }), this.popup = ur, ar.focus();
      }
    }, cr.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    }, cr;
  }()
);
function addWidget(cr) {
  return new Plugin({
    key: pluginKey$1,
    state: {
      init: function() {
        return null;
      },
      apply: function(ar) {
        return ar.getMeta("widget");
      }
    },
    view: function(ar) {
      return new PopupWidget(ar, cr);
    }
  });
}
function addDefaultImageBlobHook(cr) {
  cr.listen("addImageBlobHook", function(ar, lr) {
    var ur = new FileReader();
    ur.onload = function(dr) {
      var fr = dr.target;
      return lr(fr.result);
    }, ur.readAsDataURL(ar);
  });
}
function emitImageBlobHook(cr, ar, lr) {
  var ur = function(dr, fr) {
    cr.emit("command", "addImage", {
      imageUrl: dr,
      altText: fr || ar.name || "image"
    });
  };
  cr.emit("addImageBlobHook", ar, ur, lr);
}
function pasteImageOnly(cr) {
  var ar = toArray_1(cr).filter(function(ur) {
    var dr = ur.type;
    return dr.indexOf("image") !== -1;
  });
  if (ar.length === 1) {
    var lr = ar[0];
    if (lr)
      return lr.getAsFile();
  }
  return null;
}
function dropImage(cr) {
  var ar = cr.eventEmitter;
  return new Plugin({
    props: {
      handleDOMEvents: {
        drop: function(lr, ur) {
          var dr, fr = (dr = ur.dataTransfer) === null || dr === void 0 ? void 0 : dr.files;
          return fr && forEachArray_1(fr, function(gr) {
            return gr.type.indexOf("image") !== -1 ? (ur.preventDefault(), ur.stopPropagation(), emitImageBlobHook(ar, gr, ur.type), !1) : !0;
          }), !0;
        }
      }
    }
  });
}
var Node$2 = (
  /** @class */
  function() {
    function cr() {
    }
    return Object.defineProperty(cr.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: !1,
      configurable: !0
    }), cr.prototype.setContext = function(ar) {
      this.context = ar;
    }, cr;
  }()
);
function widgetNodeView(cr) {
  var ar = document.createElement("span"), lr = widgetToDOM(cr.attrs.info, cr.textContent);
  return ar.className = "tui-widget", ar.appendChild(lr), { dom: ar };
}
function isWidgetNode(cr) {
  return cr.type.name === "widget";
}
var Widget = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: !0,
          content: "text*",
          selectable: !1,
          atom: !0,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(lr) {
                var ur = lr.textContent, dr = ur.match(/\$\$(widget\d+)/), fr = dr[1];
                return { info: fr };
              }
            }
          ]
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), EditorBase = (
  /** @class */
  function() {
    function cr(ar) {
      this.timer = null, this.el = document.createElement("div"), this.el.className = "toastui-editor", this.eventEmitter = ar, this.placeholder = { text: "" };
    }
    return cr.prototype.createState = function() {
      return EditorState.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    }, cr.prototype.initEvent = function() {
      var ar = this, lr = ar.eventEmitter, ur = ar.view, dr = ar.editorType;
      ur.dom.addEventListener("focus", function() {
        return lr.emit("focus", dr);
      }), ur.dom.addEventListener("blur", function() {
        return lr.emit("blur", dr);
      });
    }, cr.prototype.emitChangeEvent = function(ar) {
      this.eventEmitter.emit("caretChange", this.editorType), ar.docChanged && this.eventEmitter.emit("change", this.editorType);
    }, Object.defineProperty(cr.prototype, "defaultPlugins", {
      get: function() {
        var ar = this.createInputRules(), lr = __spreadArray$1(__spreadArray$1([], this.keymaps), [
          keymap(__assign$1({ "Shift-Enter": baseKeymap.Enter }, baseKeymap)),
          history(),
          placeholder(this.placeholder),
          addWidget(this.eventEmitter),
          dropImage(this.context)
        ]);
        return ar ? lr.concat(ar) : lr;
      },
      enumerable: !1,
      configurable: !0
    }), cr.prototype.createInputRules = function() {
      var ar = getWidgetRules(), lr = ar.map(function(ur) {
        var dr = ur.rule;
        return new InputRule(dr, function(fr, gr, mr, vr) {
          var yr = fr.schema, _r = fr.tr, kr = fr.doc, xr = gr.input.match(new RegExp(dr, "g")), Ar = kr.resolve(mr), Er = Ar.parent, Cr = 0;
          if (isWidgetNode(Er) && (Er = Ar.node(Ar.depth - 1)), Er.forEach(function(Lr) {
            return isWidgetNode(Lr) && (Cr += 1);
          }), xr.length > Cr) {
            var Tr = last$1(xr), Sr = createNodesWithWidget(Tr, yr);
            return _r.replaceWith(vr - Tr.length + 1, vr, Sr);
          }
          return null;
        });
      });
      return lr.length ? inputRules({ rules: lr }) : null;
    }, cr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, cr.prototype.createSchema = function() {
      return new Schema({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    }, cr.prototype.createKeymaps = function(ar) {
      var lr = getDefaultCommands(), ur = lr.undo, dr = lr.redo, fr = this.specs.keymaps(ar), gr = {
        "Mod-z": ur(),
        "Shift-Mod-z": dr()
      };
      return ar ? fr.concat(keymap(gr)) : fr;
    }, cr.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, cr.prototype.createPluginProps = function() {
      var ar = this;
      return this.extraPlugins.map(function(lr) {
        return lr(ar.eventEmitter);
      });
    }, cr.prototype.focus = function() {
      var ar = this;
      this.clearTimer(), this.timer = setTimeout(function() {
        ar.view.focus(), ar.view.dispatch(ar.view.state.tr.scrollIntoView());
      });
    }, cr.prototype.blur = function() {
      this.view.dom.blur();
    }, cr.prototype.destroy = function() {
      var ar = this;
      this.clearTimer(), this.view.destroy(), Object.keys(this).forEach(function(lr) {
        delete ar[lr];
      });
    }, cr.prototype.moveCursorToStart = function(ar) {
      var lr = this.view.state.tr;
      this.view.dispatch(lr.setSelection(createTextSelection(lr, 1)).scrollIntoView()), ar && this.focus();
    }, cr.prototype.moveCursorToEnd = function(ar) {
      var lr = this.view.state.tr;
      this.view.dispatch(lr.setSelection(createTextSelection(lr, lr.doc.content.size - 1)).scrollIntoView()), ar && this.focus();
    }, cr.prototype.setScrollTop = function(ar) {
      this.view.dom.scrollTop = ar;
    }, cr.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    }, cr.prototype.setPlaceholder = function(ar) {
      this.placeholder.text = ar, this.view.dispatch(this.view.state.tr.scrollIntoView());
    }, cr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, cr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, cr.prototype.getElement = function() {
      return this.el;
    }, cr;
  }()
);
function isFunction(cr) {
  return cr instanceof Function;
}
var isFunction_1 = isFunction, defaultCommandShortcuts = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function execCommand(cr, ar, lr) {
  return cr.focus(), ar(lr)(cr.state, cr.dispatch, cr);
}
var SpecManager = (
  /** @class */
  function() {
    function cr(ar) {
      this.specs = ar;
    }
    return Object.defineProperty(cr.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "node";
        }).reduce(function(ar, lr) {
          var ur, dr = lr.name, fr = lr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[dr] = fr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(cr.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(ar) {
          return ar.type === "mark";
        }).reduce(function(ar, lr) {
          var ur, dr = lr.name, fr = lr.schema;
          return __assign$1(__assign$1({}, ar), (ur = {}, ur[dr] = fr, ur));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), cr.prototype.commands = function(ar, lr) {
      var ur = this.specs.filter(function(fr) {
        var gr = fr.commands;
        return gr;
      }).reduce(function(fr, gr) {
        var mr = {}, vr = gr.commands();
        return isFunction_1(vr) ? mr[gr.name] = function(yr) {
          return execCommand(ar, vr, yr);
        } : Object.keys(vr).forEach(function(yr) {
          mr[yr] = function(_r) {
            return execCommand(ar, vr[yr], _r);
          };
        }), __assign$1(__assign$1({}, fr), mr);
      }, {}), dr = getDefaultCommands();
      return Object.keys(dr).forEach(function(fr) {
        ur[fr] = function(gr) {
          return execCommand(ar, dr[fr], gr);
        };
      }), lr && Object.keys(lr).forEach(function(fr) {
        ur[fr] = function(gr) {
          return execCommand(ar, lr[fr], gr);
        };
      }), ur;
    }, cr.prototype.keymaps = function(ar) {
      var lr = this.specs.filter(function(ur) {
        return ur.keymaps;
      }).map(function(ur) {
        return ur.keymaps();
      });
      return lr.map(function(ur) {
        return ar || Object.keys(ur).forEach(function(dr) {
          includes(defaultCommandShortcuts, dr) || delete ur[dr];
        }), keymap(ur);
      });
    }, cr.prototype.setContext = function(ar) {
      this.specs.forEach(function(lr) {
        lr.setContext(ar);
      });
    }, cr;
  }()
);
function resolveSelectionPos(cr) {
  var ar = cr.from, lr = cr.to;
  return cr instanceof AllSelection ? [ar + 1, lr - 1] : [ar, lr];
}
function getMdLine(cr) {
  return cr.index(0) + 1;
}
function getWidgetNodePos(cr, ar, lr) {
  lr === void 0 && (lr = 1);
  var ur = 0;
  return cr.forEach(function(dr, fr) {
    isWidgetNode(dr) && fr + 2 < ar && (ur += 2 * lr);
  }), ur;
}
function getEditorToMdPos(cr, ar, lr) {
  lr === void 0 && (lr = ar);
  var ur = ar === lr, dr = cr.resolve(ar), fr = getMdLine(dr), gr = fr, mr = dr.start(1), vr = mr;
  if (!ur) {
    var yr = cr.resolve(lr === cr.content.size ? lr - 1 : lr);
    vr = yr.start(1), gr = getMdLine(yr), yr.pos === cr.content.size && (lr = cr.content.size - 2);
  }
  var _r = Math.max(ar - mr + 1, 1), kr = Math.max(lr - vr + 1, 1);
  return [
    [fr, _r + getWidgetNodePos(cr.child(fr - 1), _r, -1)],
    [gr, kr + getWidgetNodePos(cr.child(gr - 1), kr, -1)]
  ];
}
function getStartPosListPerLine(cr, ar) {
  for (var lr = [], ur = 0, dr = 0; ur < ar; ur += 1) {
    var fr = cr.child(ur);
    lr[ur] = dr, dr += fr.nodeSize;
  }
  return lr;
}
function getMdToEditorPos(cr, ar, lr) {
  var ur = getStartPosListPerLine(cr, lr[0]), dr = ar[0] - 1, fr = lr[0] - 1, gr = cr.child(dr), mr = cr.child(fr), vr = ur[dr], yr = ur[fr];
  return vr += ar[1] + getWidgetNodePos(gr, ar[1] - 1), yr += lr[1] + getWidgetNodePos(mr, lr[1] - 1), [vr, Math.min(yr, cr.content.size)];
}
function getRangeInfo(cr) {
  var ar = cr.$from, lr = cr.$to, ur = cr.from, dr = cr.to, fr = ar.doc;
  return cr instanceof AllSelection && (ar = fr.resolve(ur + 1), lr = fr.resolve(dr - 1)), ar.depth === 0 && (ar = fr.resolve(ur - 1), lr = ar), {
    startFromOffset: ar.start(1),
    endFromOffset: lr.start(1),
    startToOffset: ar.end(1),
    endToOffset: lr.end(1),
    startIndex: ar.index(0),
    endIndex: lr.index(0),
    from: ar.pos,
    to: lr.pos
  };
}
function getNodeContentOffsetRange(cr, ar) {
  for (var lr = 1, ur = 1, dr = 0, fr = 0; dr < cr.childCount; dr += 1) {
    var gr = cr.child(dr).nodeSize;
    if (lr = fr + 1, ur = fr + gr - 1, dr === ar)
      break;
    fr += gr;
  }
  return { startOffset: lr, endOffset: ur };
}
var HEADING = "heading", BLOCK_QUOTE = "blockQuote", LIST_ITEM = "listItem", TABLE = "table", TABLE_CELL = "tableCell", CODE_BLOCK = "codeBlock", THEMATIC_BREAK = "thematicBreak", LINK = "link", CODE = "code", META = "meta", DELIM = "delimiter", TASK_DELIM = "taskDelimiter", TEXT = "markedText", HTML = "html", CUSTOM_BLOCK = "customBlock", delimSize = {
  strong: 2,
  emph: 1,
  strike: 2
};
function markInfo(cr, ar, lr, ur) {
  return { start: cr, end: ar, spec: { type: lr, attrs: ur } };
}
function heading$1(cr, ar, lr) {
  var ur = cr.level, dr = cr.headingType, fr = [markInfo(ar, lr, HEADING, { level: ur })];
  return dr === "atx" ? fr.push(markInfo(ar, addOffsetPos(ar, ur), DELIM)) : fr.push(markInfo(setOffsetPos(lr, 0), lr, HEADING, { seText: !0 })), fr;
}
function emphasisAndStrikethrough(cr, ar, lr) {
  var ur = cr.type, dr = addOffsetPos(ar, delimSize[ur]), fr = addOffsetPos(lr, -delimSize[ur]);
  return [
    markInfo(dr, fr, ur),
    markInfo(ar, dr, DELIM),
    markInfo(fr, lr, DELIM)
  ];
}
function markLink(cr, ar, lr, ur) {
  return [
    markInfo(cr, ar, LINK),
    markInfo(setOffsetPos(cr, lr[1] + 1), setOffsetPos(ar, ur), LINK, {
      desc: !0
    }),
    markInfo(setOffsetPos(ar, ur + 2), addOffsetPos(ar, -1), LINK, { url: !0 })
  ];
}
function image$1(cr, ar, lr) {
  var ur = cr.lastChild, dr = ur ? getMdEndCh(ur) + 1 : 3, fr = addOffsetPos(ar, 1);
  return __spreadArray$1([markInfo(ar, fr, META)], markLink(ar, lr, fr, dr));
}
function link$1(cr, ar, lr) {
  var ur = cr.lastChild, dr = cr.extendedAutolink, fr = ur ? getMdEndCh(ur) + 1 : 2;
  return dr ? [markInfo(ar, lr, LINK, { desc: !0 })] : markLink(ar, lr, ar, fr);
}
function code(cr, ar, lr) {
  var ur = cr.tickCount, dr = addOffsetPos(ar, ur), fr = addOffsetPos(lr, -ur);
  return [
    markInfo(ar, lr, CODE),
    markInfo(ar, dr, CODE, { start: !0 }),
    markInfo(dr, fr, CODE, { marked: !0 }),
    markInfo(fr, lr, CODE, { end: !0 })
  ];
}
function lineBackground(cr, ar, lr, ur) {
  var dr = {
    start: ar,
    end: lr,
    spec: {
      attrs: { className: ur + "-line-background", codeStart: ar[0], codeEnd: lr[0] }
    },
    lineBackground: !0
  };
  return cr.type !== "item" && cr.type !== "blockQuote" ? [
    __assign$1(__assign$1({}, dr), { end: ar, spec: { attrs: { className: ur + "-line-background start" } } }),
    __assign$1(__assign$1({}, dr), { start: [Math.min(ar[0] + 1, lr[0]), ar[1]] })
  ] : null;
}
function codeBlock$1(cr, ar, lr, ur) {
  var dr = cr.fenceOffset, fr = cr.fenceLength, gr = cr.fenceChar, mr = cr.info, vr = cr.infoPadding, yr = cr.parent, _r = dr + fr, kr = [markInfo(setOffsetPos(ar, 1), lr, CODE_BLOCK)];
  gr && kr.push(markInfo(ar, addOffsetPos(ar, _r), DELIM)), mr && kr.push(markInfo(addOffsetPos(ar, fr), addOffsetPos(ar, fr + vr + mr.length), META));
  var xr = "^(\\s{0,4})(" + gr + "{" + fr + ",})", Ar = new RegExp(xr);
  Ar.test(ur) && kr.push(markInfo(setOffsetPos(lr, 1), lr, DELIM));
  var Er = lineBackground(yr, ar, lr, "code-block");
  return Er ? kr.concat(Er) : kr;
}
function customBlock$2(cr, ar, lr) {
  var ur = cr, dr = ur.offset, fr = ur.syntaxLength, gr = ur.info, mr = ur.parent, vr = dr + fr, yr = [markInfo(setOffsetPos(ar, 1), lr, CUSTOM_BLOCK)];
  yr.push(markInfo(ar, addOffsetPos(ar, vr), DELIM)), gr && yr.push(markInfo(addOffsetPos(ar, vr), addOffsetPos(ar, fr + gr.length), META)), yr.push(markInfo(setOffsetPos(lr, 1), lr, DELIM));
  var _r = lineBackground(mr, ar, lr, "custom-block");
  return _r ? yr.concat(_r) : yr;
}
function markListItemChildren(cr, ar) {
  for (var lr = []; cr; ) {
    var ur = cr.type;
    (ur === "paragraph" || ur === "codeBlock") && lr.push(markInfo([getMdStartLine(cr), getMdStartCh(cr) - 1], [getMdEndLine(cr), getMdEndCh(cr) + 1], ar)), cr = cr.next;
  }
  return lr;
}
function markParagraphInBlockQuote(cr) {
  for (var ar = []; cr; )
    ar.push(markInfo([getMdStartLine(cr), getMdStartCh(cr)], [getMdEndLine(cr), getMdEndCh(cr) + 1], TEXT)), cr = cr.next;
  return ar;
}
function blockQuote$2(cr, ar, lr) {
  var ur = cr.parent && cr.parent.type !== "blockQuote" ? [markInfo(ar, lr, BLOCK_QUOTE)] : [];
  if (cr.firstChild) {
    var dr = [];
    cr.firstChild.type === "paragraph" ? dr = markParagraphInBlockQuote(cr.firstChild.firstChild) : cr.firstChild.type === "list" && (dr = markListItemChildren(cr.firstChild, TEXT)), ur = __spreadArray$1(__spreadArray$1([], ur), dr);
  }
  return ur;
}
function getSpecOfListItemStyle(cr) {
  for (var ar = 0; cr.parent.parent && cr.parent.parent.type === "item"; )
    cr = cr.parent.parent, ar += 1;
  var lr = [{ odd: !0 }, { even: !0 }][ar % 2];
  return [LIST_ITEM, __assign$1(__assign$1({}, lr), { listStyle: !0 })];
}
function item$1(cr, ar) {
  var lr = cr.listData, ur = lr.padding, dr = lr.task, fr = getSpecOfListItemStyle(cr), gr = [markInfo.apply(void 0, __spreadArray$1([ar, addOffsetPos(ar, ur)], fr))];
  return dr && (gr.push(markInfo(addOffsetPos(ar, ur), addOffsetPos(ar, ur + 3), TASK_DELIM)), gr.push(markInfo(addOffsetPos(ar, ur + 1), addOffsetPos(ar, ur + 2), META))), gr.concat(markListItemChildren(cr.firstChild, TEXT));
}
var markNodeFuncMap = {
  heading: heading$1,
  strong: emphasisAndStrikethrough,
  emph: emphasisAndStrikethrough,
  strike: emphasisAndStrikethrough,
  link: link$1,
  image: image$1,
  code,
  codeBlock: codeBlock$1,
  blockQuote: blockQuote$2,
  item: item$1,
  customBlock: customBlock$2
}, simpleMarkClassNameMap = {
  thematicBreak: THEMATIC_BREAK,
  table: TABLE,
  tableCell: TABLE_CELL,
  htmlInline: HTML
};
function getMarkInfo(cr, ar, lr, ur) {
  var dr = cr.type;
  return isFunction_1(markNodeFuncMap[dr]) ? markNodeFuncMap[dr](cr, ar, lr, ur) : simpleMarkClassNameMap[dr] ? [markInfo(ar, lr, simpleMarkClassNameMap[dr])] : null;
}
var removingBackgroundIndexMap = {};
function syntaxHighlight(cr) {
  var ar = cr.schema, lr = cr.toastMark;
  return new Plugin({
    appendTransaction: function(ur, dr, fr) {
      var gr = ur[0], mr = fr.tr;
      if (gr.docChanged) {
        var vr = [], yr = gr.getMeta("editResult");
        yr.forEach(function(_r) {
          var kr = _r.nodes, xr = _r.removedNodeRange;
          if (kr.length) {
            vr = vr.concat(getMarkForRemoving(mr, kr));
            for (var Ar = 0, Er = kr; Ar < Er.length; Ar++)
              for (var Cr = Er[Ar], Tr = Cr.walker(), Sr = Tr.next(); Sr; ) {
                var Lr = Sr.node, Ir = Sr.entering;
                Ir && (vr = vr.concat(getMarkForAdding(Lr, lr))), Sr = Tr.next();
              }
          } else if (xr)
            for (var Nr = mr.doc.childCount - 1, Rr = xr.line, Mr = Rr[0], Br = Rr[1], Dr = Math.min(Mr, Nr), Hr = Math.min(Br, Nr), Fr = Dr; Fr <= Hr; Fr += 1)
              removingBackgroundIndexMap[Fr] = !0;
        }), appendMarkTr(mr, ar, vr);
      }
      return mr.setMeta("widget", gr.getMeta("widget"));
    }
  });
}
function isDifferentBlock(cr, ar, lr) {
  return Object.keys(lr).some(function(ur) {
    return lr[ur] !== cr.child(ar).attrs[ur];
  });
}
function addLineBackground(cr, ar, lr, ur, dr) {
  dr === void 0 && (dr = {});
  for (var fr = ur.startIndex, gr = ur.endIndex, mr = ur.from, vr = ur.to, yr = !1, _r = fr; _r <= gr; _r += 1)
    delete removingBackgroundIndexMap[_r], yr = isDifferentBlock(ar, _r, dr);
  yr && cr.setBlockType(mr, vr, lr, dr);
}
function appendMarkTr(cr, ar, lr) {
  var ur = cr.doc, dr = ar.nodes.paragraph, fr = getStartPosListPerLine(ur, ur.childCount);
  lr.forEach(function(gr) {
    var mr = gr.start, vr = gr.end, yr = gr.spec, _r = gr.lineBackground, kr = Math.min(mr[0], ur.childCount) - 1, xr = Math.min(vr[0], ur.childCount) - 1, Ar = ur.child(kr), Er = ur.child(xr), Cr = fr[kr], Tr = fr[xr];
    if (Cr += mr[1] + getWidgetNodePos(Ar, mr[1] - 1), Tr += vr[1] + getWidgetNodePos(Er, vr[1] - 1), yr)
      if (_r) {
        var Sr = { from: Cr, to: Tr, startIndex: kr, endIndex: xr };
        addLineBackground(cr, ur, dr, Sr, yr.attrs);
      } else
        cr.addMark(Cr, Tr, ar.mark(yr.type, yr.attrs));
    else
      cr.removeMark(Cr, Tr);
  }), removeBlockBackground(cr, fr, dr);
}
function removeBlockBackground(cr, ar, lr) {
  Object.keys(removingBackgroundIndexMap).forEach(function(ur) {
    var dr = Number(ur), fr = Math.min(Number(ur) + 1, cr.doc.childCount - 1), gr = ar[dr], mr = ar[fr] - 1;
    dr === fr && (mr += 2), cr.setBlockType(gr, mr, lr);
  });
}
function cacheIndexToRemoveBackground(cr, ar, lr) {
  var ur = [];
  removingBackgroundIndexMap = {};
  for (var dr = ar[0] - 1; dr < lr[0]; dr += 1) {
    var fr = cr.child(dr), gr = fr.attrs.codeEnd, mr = fr.attrs.codeStart;
    if (mr && gr && !includes(ur, mr)) {
      ur.push(mr), gr = Math.min(gr, cr.childCount);
      for (var vr = mr - 1, yr = lr[0], _r = vr; _r < yr; _r += 1)
        removingBackgroundIndexMap[_r] = !0;
    }
  }
}
function getMarkForRemoving(cr, ar) {
  var lr = cr.doc, ur = ar[0].sourcepos[0], dr = last$1(ar).sourcepos, fr = dr[1], gr = [ur[0], ur[1]], mr = [fr[0], fr[1] + 1], vr = [];
  return cacheIndexToRemoveBackground(lr, ur, fr), vr.push({ start: gr, end: mr }), vr;
}
function getMarkForAdding(cr, ar) {
  var lr = ar.getLineTexts(), ur = [getMdStartLine(cr), getMdStartCh(cr)], dr = [getMdEndLine(cr), getMdEndCh(cr) + 1], fr = getMarkInfo(cr, ur, dr, lr[dr[0] - 1]);
  return fr != null ? fr : [];
}
var defaultToolbarStateKeys = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function getToolbarStateType$1(cr) {
  var ar = cr.type;
  return isListNode$1(cr) ? cr.listData.task ? "taskList" : cr.listData.type === "ordered" ? "orderedList" : "bulletList" : ar.indexOf("table") !== -1 ? "table" : includes(defaultToolbarStateKeys, ar) ? ar : null;
}
function getToolbarState$1(cr) {
  var ar = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  }, lr = !0;
  return traverseParentNodes(cr, function(ur) {
    var dr = getToolbarStateType$1(ur);
    dr && (dr === "bulletList" || dr === "orderedList" ? lr && (ar[dr] = { active: !0 }, ar.indent.disabled = !1, ar.outdent.disabled = !1, lr = !1) : ar[dr] = { active: !0 });
  }), ar;
}
function previewHighlight(cr) {
  var ar = cr.toastMark, lr = cr.eventEmitter;
  return new Plugin({
    view: function() {
      return {
        update: function(ur, dr) {
          var fr = ur.state, gr = fr.doc, mr = fr.selection;
          if (!(dr && dr.doc.eq(gr) && dr.selection.eq(mr))) {
            var vr = mr.from, yr = fr.doc.resolve(vr).start(), _r = fr.doc.content.findIndex(vr).index + 1, kr = vr - yr;
            vr === yr && (kr += 1);
            var xr = [_r, kr], Ar = ar.findNodeAtPosition(xr), Er = getToolbarState$1(Ar);
            lr.emit("changeToolbarState", {
              cursorPos: xr,
              mdNode: Ar,
              toolbarState: Er
            }), lr.emit("setFocusedNode", Ar);
          }
        }
      };
    }
  });
}
var Doc$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Mark = (
  /** @class */
  function() {
    function cr() {
    }
    return Object.defineProperty(cr.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: !1,
      configurable: !0
    }), cr.prototype.setContext = function(ar) {
      this.context = ar;
    }, cr;
  }()
);
function getTextByMdLine(cr, ar) {
  return getTextContent(cr, ar - 1);
}
function getTextContent(cr, ar) {
  return cr.child(ar).textContent;
}
var reBlockQuote = /^\s*> ?/, BlockQuote$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("block-quote") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createBlockQuoteText = function(lr, ur) {
      return ur ? lr.replace(reBlockQuote, "").trim() : "> " + lr.trim();
    }, ar.prototype.extendBlockQuote = function() {
      var lr = this;
      return function(ur, dr) {
        var fr = ur.selection, gr = ur.doc, mr = ur.tr, vr = ur.schema, yr = getRangeInfo(fr), _r = yr.endFromOffset, kr = yr.endToOffset, xr = yr.endIndex, Ar = yr.to, Er = getTextContent(gr, xr), Cr = reBlockQuote.test(Er);
        if (Cr && Ar > _r && fr.empty) {
          var Tr = !Er.replace(reBlockQuote, "").trim();
          if (Tr)
            mr.deleteRange(_r, kr).split(mr.mapping.map(kr));
          else {
            var Sr = Er.slice(Ar - _r).trim(), Lr = createTextNode$1(vr, lr.createBlockQuoteText(Sr));
            splitAndExtendBlock(mr, kr, Sr, Lr);
          }
          return dr(mr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      var lr = this;
      return function() {
        return function(ur, dr) {
          var fr = ur.selection, gr = ur.doc, mr = getRangeInfo(fr), vr = mr.startFromOffset, yr = mr.endToOffset, _r = mr.startIndex, kr = mr.endIndex, xr = reBlockQuote.test(getTextContent(gr, _r)), Ar = replaceTextNode({
            state: ur,
            startIndex: _r,
            endIndex: kr,
            from: vr,
            createText: function(Er) {
              return lr.createBlockQuoteText(Er, xr);
            }
          });
          return dr(Ar.setSelection(createTextSelection(Ar, Ar.mapping.map(yr)))), !0;
        };
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "alt-q": lr,
        "alt-Q": lr,
        Enter: this.extendBlockQuote()
      };
    }, ar;
  }(Mark)
), reList = /(^\s*)([-*+] |[\d]+\. )/, reOrderedList = /(^\s*)([\d])+\.( \[[ xX]])? /, reOrderedListGroup = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/, reCanBeTaskList = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /, reBulletListGroup = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/, reTaskList = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/, reBulletTaskList = /(^\s*)([-*+])( \[[ xX]]) /;
function getListType(cr) {
  return reOrderedList.test(cr) ? "ordered" : "bullet";
}
function getListDepth(cr) {
  for (var ar = 0; cr && cr.type !== "document"; )
    cr.type === "list" && (ar += 1), cr = cr.parent;
  return ar;
}
function findSameDepthList(cr, ar, lr, ur) {
  for (var dr = cr.getLineTexts(), fr = dr.length, gr = [], mr = ar; ur ? mr < fr : mr > 1; ) {
    mr = ur ? mr + 1 : mr - 1;
    var vr = cr.findFirstNodeAtLine(mr), yr = getListDepth(vr);
    if (yr === lr)
      gr.push({ line: mr, depth: lr, mdNode: vr });
    else if (yr < lr)
      break;
  }
  return gr;
}
function getSameDepthItems(cr) {
  var ar = cr.toastMark, lr = cr.mdNode, ur = cr.line, dr = getListDepth(lr), fr = findSameDepthList(ar, ur, dr, !1).reverse(), gr = findSameDepthList(ar, ur, dr, !0);
  return fr.concat([{ line: ur, depth: dr, mdNode: lr }]).concat(gr);
}
function textToBullet(cr) {
  if (!reList.test(cr))
    return "* " + cr;
  var ar = getListType(cr);
  return ar === "bullet" && reCanBeTaskList.test(cr) ? cr = cr.replace(reBulletTaskList, "$1$2 ") : ar === "ordered" && (cr = cr.replace(reOrderedList, "$1* ")), cr;
}
function textToOrdered(cr, ar) {
  if (!reList.test(cr))
    return ar + ". " + cr;
  var lr = getListType(cr);
  if (lr === "bullet" || lr === "ordered" && reCanBeTaskList.test(cr))
    cr = cr.replace(reCanBeTaskList, "$1" + ar + ". ");
  else if (lr === "ordered") {
    var ur = reOrderedListGroup.exec(cr)[3];
    Number(ur) !== ar && (cr = cr.replace(reOrderedList, "$1" + ar + ". "));
  }
  return cr;
}
function getChangedInfo(cr, ar, lr, ur) {
  ur === void 0 && (ur = 0);
  var dr = Number.MAX_VALUE, fr = 0, gr = ar.map(function(mr, vr) {
    var yr = mr.line;
    dr = Math.min(yr - 1, dr), fr = Math.max(yr - 1, fr);
    var _r = getTextByMdLine(cr, yr);
    return _r = lr === "bullet" ? textToBullet(_r) : textToOrdered(_r, vr + 1 + ur), { text: _r, line: yr };
  });
  return { changedResults: gr, firstIndex: dr, lastIndex: fr };
}
function getBulletOrOrdered(cr, ar) {
  var lr = getSameDepthItems(ar);
  return getChangedInfo(ar.doc, lr, cr);
}
var otherListToList = {
  bullet: function(cr) {
    return getBulletOrOrdered("bullet", cr);
  },
  ordered: function(cr) {
    return getBulletOrOrdered("ordered", cr);
  },
  task: function(cr) {
    var ar = cr.mdNode, lr = cr.doc, ur = cr.line, dr = getTextByMdLine(lr, ur);
    return ar.listData.task ? dr = dr.replace(reTaskList, "$1$2") : isListNode$1(ar) && (dr = dr.replace(reList, "$1$2[ ] ")), { changedResults: [{ text: dr, line: ur }] };
  }
}, otherNodeToList = {
  bullet: function(cr) {
    var ar = cr.doc, lr = cr.line, ur = getTextByMdLine(ar, lr), dr = [{ text: "* " + ur, line: lr }];
    return { changedResults: dr };
  },
  ordered: function(cr) {
    for (var ar = cr.toastMark, lr = cr.doc, ur = cr.line, dr = cr.startLine, fr = getTextByMdLine(lr, ur), gr = 1, mr = dr, vr = 0, yr = dr - 1; yr > 0; yr -= 1) {
      var _r = ar.findFirstNodeAtLine(yr), kr = getTextByMdLine(lr, yr), xr = kr && !!findClosestNode(_r, function(Ir) {
        return isListNode$1(Ir);
      }), Ar = reOrderedListGroup.exec(getTextByMdLine(lr, yr));
      if (!Ar && !xr)
        break;
      if (!Ar && xr) {
        vr += 1;
        continue;
      }
      var Er = Ar, Cr = Er[1], Tr = Er[3];
      if (!Cr) {
        gr = Number(Tr), mr = yr;
        break;
      }
    }
    var Sr = gr + ur - mr - vr, Lr = [{ text: Sr + ". " + fr, line: ur }];
    return { changedResults: Lr };
  },
  task: function(cr) {
    var ar = cr.doc, lr = cr.line, ur = getTextByMdLine(ar, lr), dr = [{ text: "* [ ] " + ur, line: lr }];
    return { changedResults: dr };
  }
}, extendList = {
  bullet: function(cr) {
    var ar = cr.line, lr = cr.doc, ur = getTextByMdLine(lr, ar), dr = reBulletListGroup.exec(ur), fr = dr[1], gr = dr[2];
    return { listSyntax: "" + fr + gr };
  },
  ordered: function(cr) {
    var ar = cr.toastMark, lr = cr.line, ur = cr.mdNode, dr = cr.doc, fr = getListDepth(ur), gr = getTextByMdLine(dr, lr), mr = reOrderedListGroup.exec(gr), vr = mr[1], yr = mr[3], _r = mr[4], kr = Number(yr) + 1, xr = "" + vr + kr + _r, Ar = findSameDepthList(ar, lr, fr, !0), Er = Ar.filter(function(Cr) {
      var Tr = reOrderedListGroup.exec(getTextByMdLine(dr, Cr.line));
      return Tr && Tr[1].length === vr.length && !!findClosestNode(Cr.mdNode, function(Sr) {
        return isOrderedListNode(Sr);
      });
    });
    return __assign$1({ listSyntax: xr }, getChangedInfo(dr, Er, "ordered", kr));
  }
};
function getReorderedListInfo(cr, ar, lr, ur, dr) {
  for (var fr = [], gr = getTextByMdLine(cr, lr), mr = reOrderedListGroup.exec(gr); mr; ) {
    var vr = mr[1], yr = mr[4], _r = mr[5], kr = vr.length;
    if (kr === dr)
      fr.push(createTextNode$1(ar, "" + vr + ur + yr + _r)), ur += 1, lr += 1;
    else if (kr > dr) {
      var xr = getReorderedListInfo(cr, ar, lr, 1, kr);
      lr = xr.line, fr = fr.concat(xr.nodes);
    }
    if (kr < dr || lr > cr.childCount)
      break;
    gr = getTextByMdLine(cr, lr), mr = reOrderedListGroup.exec(gr);
  }
  return { nodes: fr, line: lr };
}
var reStartSpace = /(^\s{1,4})(.*)/;
function isBlockUnit(cr, ar, lr) {
  return cr < ar || reList.test(lr) || reBlockQuote.test(lr);
}
function isInTableCellNode(cr, ar, lr) {
  var ur = lr.$from;
  ur.depth === 0 && (ur = cr.resolve(ur.pos - 1));
  var dr = ur.node(1), fr = ur.start(1), gr = dr.content.size;
  return dr.rangeHasMark(0, gr, ar.marks.table) && ur.pos - fr !== gr && ur.pos !== fr;
}
function createSelection(cr, ar) {
  var lr = ar.from, ur = ar.to;
  if (ar.type === "indent") {
    var dr = 4;
    lr += dr, ur += (ar.lineLen + 1) * dr;
  } else {
    var fr = ar.spaceLenList;
    lr -= fr[0];
    for (var gr = 0; gr < fr.length; gr += 1)
      ur -= fr[gr];
  }
  return createTextSelection(cr, lr, ur);
}
var Paragraph$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: !1,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ur.className ? ["div", { class: clsWithMdPrefix(ur.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.reorderList = function(lr, ur) {
      for (var dr = this.context, fr = dr.view, gr = dr.toastMark, mr = dr.schema, vr = fr.state, yr = vr.tr, _r = vr.selection, kr = vr.doc, xr = gr.findFirstNodeAtLine(lr), Ar = xr; xr && !isBulletListNode(xr) && xr.parent.type !== "document"; )
        if (xr = xr.parent, isOrderedListNode(xr)) {
          Ar = xr;
          break;
        }
      Ar && (lr = Ar.sourcepos[0][0]);
      var Er = reOrderedListGroup.exec(getTextByMdLine(kr, lr)), Cr = Er[1], Tr = Er[3], Sr = Cr.length, Lr = getReorderedListInfo(kr, mr, lr, Number(Tr), Sr), Ir = Lr.line, Nr = Lr.nodes;
      ur = Math.max(ur, Ir - 1);
      for (var Rr = getNodeContentOffsetRange(kr, lr - 1).startOffset, Mr = lr - 1; Mr <= ur - 1; Mr += 1) {
        var Br = kr.child(Mr), Dr = Br.nodeSize, Hr = Br.content, Fr = yr.mapping.map(Rr), zr = Fr + Hr.size;
        yr.replaceWith(Fr, zr, Nr[Mr - lr + 1]), Rr += Dr;
      }
      var Ur = createTextSelection(yr, _r.from, _r.to);
      fr.dispatch(yr.setSelection(Ur));
    }, ar.prototype.indent = function(lr) {
      var ur = this;
      return lr === void 0 && (lr = !1), function() {
        return function(dr, fr) {
          var gr = dr.schema, mr = dr.selection, vr = dr.doc, yr = getRangeInfo(mr), _r = yr.from, kr = yr.to, xr = yr.startFromOffset, Ar = yr.startIndex, Er = yr.endIndex;
          if (lr && isInTableCellNode(vr, gr, mr))
            return !1;
          var Cr = getTextContent(vr, Ar);
          if (lr && isBlockUnit(_r, kr, Cr) || !lr && reList.test(Cr)) {
            var Tr = replaceTextNode({
              state: dr,
              from: xr,
              startIndex: Ar,
              endIndex: Er,
              createText: function(Lr) {
                return "    " + Lr;
              }
            }), Sr = {
              type: "indent",
              from: _r,
              to: kr,
              lineLen: Er - Ar
            };
            fr(Tr.setSelection(createSelection(Tr, Sr))), reOrderedListGroup.test(Cr) && ur.reorderList(Ar + 1, Er + 1);
          } else
            lr && fr(dr.tr.insert(kr, createTextNode$1(gr, "    ")));
          return !0;
        };
      };
    }, ar.prototype.outdent = function(lr) {
      var ur = this;
      return lr === void 0 && (lr = !1), function() {
        return function(dr, fr) {
          var gr = dr.selection, mr = dr.doc, vr = dr.schema, yr = getRangeInfo(gr), _r = yr.from, kr = yr.to, xr = yr.startFromOffset, Ar = yr.startIndex, Er = yr.endIndex;
          if (lr && isInTableCellNode(mr, vr, gr))
            return !1;
          var Cr = getTextContent(mr, Ar);
          if (lr && isBlockUnit(_r, kr, Cr) || !lr && reList.test(Cr)) {
            var Tr = [], Sr = replaceTextNode({
              state: dr,
              from: xr,
              startIndex: Ar,
              endIndex: Er,
              createText: function(Mr) {
                var Br = reStartSpace.exec(Mr);
                return Tr.push(Br ? Br[1].length : 0), Mr.replace(reStartSpace, "$2");
              }
            }), Lr = { type: "outdent", from: _r, to: kr, spaceLenList: Tr };
            fr(Sr.setSelection(createSelection(Sr, Lr))), reOrderedListGroup.test(Cr) && ur.reorderList(Ar + 1, Er + 1);
          } else if (lr) {
            var Ir = Cr.slice(0, kr - xr), Nr = Ir.replace(/\s{1,4}$/, ""), Rr = kr - (Ir.length - Nr.length);
            fr(dr.tr.delete(Rr, kr));
          }
          return !0;
        };
      };
    }, ar.prototype.deleteLines = function() {
      var lr = this;
      return function(ur, dr) {
        var fr = lr.context.view, gr = getRangeInfo(ur.selection), mr = gr.startFromOffset, vr = gr.endToOffset, yr = function() {
          return dr(ur.tr.deleteRange(mr, vr)), !0;
        };
        return chainCommands(yr, joinForward)(ur, dr, fr);
      };
    }, ar.prototype.moveDown = function() {
      return function(lr, ur) {
        var dr = lr.doc, fr = lr.tr, gr = lr.selection, mr = lr.schema, vr = getRangeInfo(gr), yr = vr.startFromOffset, _r = vr.endToOffset, kr = vr.endIndex;
        if (kr < dr.content.childCount - 1) {
          var xr = dr.child(kr + 1), Ar = xr.nodeSize, Er = xr.textContent;
          return fr.delete(_r, _r + Ar).split(yr).insert(fr.mapping.map(yr) - 2, createTextNode$1(mr, Er)), ur(fr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveUp = function() {
      return function(lr, ur) {
        var dr = lr.tr, fr = lr.doc, gr = lr.selection, mr = lr.schema, vr = getRangeInfo(gr), yr = vr.startFromOffset, _r = vr.endToOffset, kr = vr.startIndex;
        if (kr > 0) {
          var xr = fr.child(kr - 1), Ar = xr.nodeSize, Er = xr.textContent;
          return dr.delete(yr - Ar, yr).split(dr.mapping.map(_r)).insert(dr.mapping.map(_r), createTextNode$1(mr, Er)), ur(dr), !0;
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.indent(!0)(),
        "Shift-Tab": this.outdent(!0)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    }, ar;
  }(Node$2)
), Text$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reHeading = /^#{1,6}\s/, Heading$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: !1 }
          },
          toDOM: function(lr) {
            var ur = lr.attrs, dr = ur.level, fr = ur.seText, gr = "heading|heading" + dr;
            return fr && (gr += "|delimiter|setext"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.createHeadingText = function(lr, ur, dr) {
      for (var fr = ur.replace(dr, "").trim(), gr = ""; lr > 0; )
        gr += "#", lr -= 1;
      return gr + " " + fr;
    }, ar.prototype.commands = function() {
      var lr = this;
      return function(ur) {
        return function(dr, fr) {
          var gr = ur.level, mr = getRangeInfo(dr.selection), vr = mr.startFromOffset, yr = mr.endToOffset, _r = mr.startIndex, kr = mr.endIndex, xr = replaceTextNode({
            state: dr,
            from: vr,
            startIndex: _r,
            endIndex: kr,
            createText: function(Ar) {
              var Er = Ar.match(reHeading), Cr = Er ? Er[0] : "";
              return lr.createHeadingText(gr, Ar, Cr);
            }
          });
          return fr(xr.setSelection(createTextSelection(xr, xr.mapping.map(yr)))), !0;
        };
      };
    }, ar;
  }(Mark)
), fencedCodeBlockSyntax = "```", CodeBlock$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("code-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          var dr = lr.selection, fr = lr.schema, gr = lr.tr, mr = getRangeInfo(dr), vr = mr.startFromOffset, yr = mr.endToOffset, _r = createTextNode$1(fr, fencedCodeBlockSyntax);
          return gr.insert(vr, _r).split(vr + fencedCodeBlockSyntax.length), gr.split(gr.mapping.map(yr)).insert(gr.mapping.map(yr), _r), ur(gr.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            createTextSelection(gr, gr.mapping.map(yr) - (fencedCodeBlockSyntax.length + 2))
          )), !0;
        };
      };
    }, ar.prototype.keepIndentation = function() {
      var lr = this;
      return function(ur, dr) {
        var fr = ur.selection, gr = ur.tr, mr = ur.doc, vr = ur.schema, yr = lr.context.toastMark, _r = getRangeInfo(fr), kr = _r.startFromOffset, xr = _r.endToOffset, Ar = _r.endIndex, Er = _r.from, Cr = _r.to, Tr = getTextContent(mr, Ar);
        if (Er === Cr && Tr.trim()) {
          var Sr = Tr.match(/^\s+/), Lr = yr.findFirstNodeAtLine(Ar + 1);
          if (isCodeBlockNode(Lr) && Sr) {
            var Ir = Sr[0], Nr = Tr.slice(Cr - kr), Rr = createTextNode$1(vr, Ir + Nr);
            return splitAndExtendBlock(gr, xr, Nr, Rr), dr(gr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "Shift-Mod-p": lr,
        "Shift-Mod-P": lr,
        Enter: this.keepIndentation()
      };
    }, ar;
  }(Mark)
), reEmptyTable = /\||\s/g;
function createTableHeader(cr) {
  return [createTableRow(cr), createTableRow(cr, !0)];
}
function createTableBody$1(cr, ar) {
  for (var lr = [], ur = 0; ur < ar; ur += 1)
    lr.push(createTableRow(cr));
  return lr;
}
function createTableRow(cr, ar) {
  for (var lr = "|", ur = 0; ur < cr; ur += 1)
    lr += ar ? " --- |" : "  |";
  return lr;
}
function createTargetTypes(cr) {
  return cr ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var Table$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendTable = function() {
      var lr = this;
      return function(ur, dr) {
        var fr = ur.selection, gr = ur.doc, mr = ur.tr, vr = ur.schema;
        if (!fr.empty)
          return !1;
        var yr = getRangeInfo(fr), _r = yr.endFromOffset, kr = yr.endToOffset, xr = yr.endIndex, Ar = yr.to, Er = getTextContent(gr, xr), Cr = [xr + 1, Ar - _r + 1], Tr = lr.context.toastMark.findNodeAtPosition(Cr), Sr = findClosestNode(Tr, function(Mr) {
          return isTableCellNode(Mr) && (Mr.parent.type === "tableDelimRow" || Mr.parent.parent.type === "tableBody");
        });
        if (Sr) {
          var Lr = !Er.replace(reEmptyTable, "").trim(), Ir = Sr.parent, Nr = Ir.parent.parent.columns.length, Rr = createTableRow(Nr);
          return Lr ? mr.deleteRange(_r, kr).split(mr.mapping.map(kr)) : mr.split(kr).insert(mr.mapping.map(kr), createTextNode$1(vr, Rr)).setSelection(createTextSelection(mr, mr.mapping.map(kr) - 2)), dr(mr), !0;
        }
        return !1;
      };
    }, ar.prototype.moveTableCell = function(lr) {
      var ur = this;
      return function(dr, fr) {
        var gr = dr.selection, mr = dr.tr, vr = getRangeInfo(gr), yr = vr.endFromOffset, _r = vr.endIndex, kr = vr.to, xr = [_r + 1, kr - yr], Ar = ur.context.toastMark.findNodeAtPosition(xr), Er = findClosestNode(Ar, function(Br) {
          return isTableCellNode(Br);
        });
        if (Er) {
          var Cr = Er.parent, Tr = createTargetTypes(lr), Sr = Tr.type, Lr = Tr.parentType, Ir = Tr.childType, Nr = getMdEndCh(Er);
          if (Er[Sr])
            Nr = getMdEndCh(Er[Sr]) - 1;
          else {
            var Rr = !Cr[Sr] && Cr.parent.type === Lr ? Cr.parent[Sr][Ir] : Cr[Sr];
            if (Sr === "next") {
              var Mr = Rr ? getMdEndCh(Rr[Ir]) : 0;
              Nr += Mr + 2;
            } else
              Sr === "prev" && (Nr = Rr ? -4 : 0);
          }
          return fr(mr.setSelection(createTextSelection(mr, yr + Nr))), !0;
        }
        return !1;
      };
    }, ar.prototype.addTable = function() {
      return function(lr) {
        return function(ur, dr) {
          var fr = ur.selection, gr = ur.tr, mr = ur.schema, vr = lr, yr = vr.columnCount, _r = vr.rowCount, kr = getRangeInfo(fr).endToOffset, xr = createTableHeader(yr), Ar = createTableBody$1(yr, _r - 1), Er = __spreadArray$1(__spreadArray$1([], xr), Ar);
          return Er.forEach(function(Cr) {
            gr.split(gr.mapping.map(kr)).insert(gr.mapping.map(kr), createTextNode$1(mr, Cr));
          }), dr(gr.setSelection(createTextSelection(gr, kr + 4))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { addTable: this.addTable() };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(!0),
        "Shift-Tab": this.moveTableCell(!1)
      };
    }, ar;
  }(Mark)
), thematicBreakSyntax = "***", ThematicBreak$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("thematic-break") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      return function() {
        return function(lr, ur) {
          var dr = lr.selection, fr = lr.schema, gr = lr.tr, mr = getRangeInfo(dr), vr = mr.from, yr = mr.to, _r = mr.endToOffset, kr = createTextNode$1(fr, thematicBreakSyntax);
          return gr.split(vr).replaceWith(gr.mapping.map(vr), gr.mapping.map(yr), kr).split(gr.mapping.map(yr)).setSelection(createTextSelection(gr, gr.mapping.map(_r))), ur(gr), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var lr = this.hr()();
      return { "Mod-l": lr, "Mod-L": lr };
    }, ar;
  }(Mark)
);
function cannotBeListNode(cr, ar) {
  var lr = cr.type, ur = cr.sourcepos, dr = ur[0][0];
  return ar <= dr && (lr === "codeBlock" || lr === "heading" || lr.match("table"));
}
var ListItem$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: !1 },
            even: { default: !1 },
            listStyle: { default: !1 }
          },
          toDOM: function(lr) {
            var ur = lr.attrs, dr = ur.odd, fr = ur.even, gr = ur.listStyle, mr = "list-item";
            return gr && (mr += "|list-item-style"), dr && (mr += "|list-item-odd"), fr && (mr += "|list-item-even"), ["span", { class: clsWithMdPrefix.apply(void 0, mr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.extendList = function() {
      var lr = this;
      return function(ur, dr) {
        var fr = ur.selection, gr = ur.doc, mr = ur.schema, vr = ur.tr, yr = lr.context.toastMark, _r = getRangeInfo(fr), kr = _r.to, xr = _r.startFromOffset, Ar = _r.endFromOffset, Er = _r.endIndex, Cr = _r.endToOffset, Tr = getTextContent(gr, Er), Sr = reList.test(Tr);
        if (!Sr || fr.from === xr || !fr.empty)
          return !1;
        var Lr = !Tr.replace(reCanBeTaskList, "").trim();
        if (Lr)
          vr.deleteRange(Ar, Cr).split(vr.mapping.map(Cr));
        else {
          var Ir = getListType(Tr), Nr = yr.findFirstNodeAtLine(Er + 1), Rr = Tr.slice(kr - Ar), Mr = { toastMark: yr, mdNode: Nr, doc: gr, line: Er + 1 }, Br = extendList[Ir](Mr), Dr = Br.listSyntax, Hr = Br.changedResults;
          if (Hr != null && Hr.length) {
            vr.split(kr), Hr.unshift({ text: Dr + Rr, line: Er + 1 }), lr.changeToListPerLine(vr, Hr, {
              from: kr,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: Hr[0].line,
              endLine: last$1(Hr).line
            });
            var Fr = vr.mapping.map(Cr) - Rr.length;
            vr.setSelection(createTextSelection(vr, Fr));
          } else {
            var zr = createTextNode$1(mr, Dr + Rr);
            splitAndExtendBlock(vr, Cr, Rr, zr);
          }
        }
        return dr(vr), !0;
      };
    }, ar.prototype.toList = function(lr) {
      var ur = this;
      return function() {
        return function(dr, fr) {
          for (var gr = dr.doc, mr = dr.tr, vr = dr.selection, yr = ur.context.toastMark, _r = getRangeInfo(vr), kr = _r.startIndex + 1, xr = _r.endIndex + 1, Ar = _r.endToOffset, Er = [], Cr = kr; Cr <= xr; Cr += 1) {
            var Tr = yr.findFirstNodeAtLine(Cr);
            if (Tr && cannotBeListNode(Tr, Cr))
              break;
            if (Er.indexOf(Cr) === -1) {
              var Sr = { toastMark: yr, mdNode: Tr, doc: gr, line: Cr, startLine: kr }, Lr = (isListNode$1(Tr) ? otherListToList[lr](Sr) : otherNodeToList[lr](Sr)).changedResults, Ir = ur.changeToListPerLine(mr, Lr, {
                from: getNodeContentOffsetRange(gr, Lr[0].line - 1).startOffset,
                startLine: Lr[0].line,
                endLine: last$1(Lr).line,
                indexDiff: 1
              });
              Ar = Math.max(Ir, Ar), Lr && (Er = Er.concat(Lr.map(function(Nr) {
                return Nr.line;
              })));
            }
          }
          return fr(mr.setSelection(createTextSelection(mr, mr.mapping.map(Ar)))), !0;
        };
      };
    }, ar.prototype.changeToListPerLine = function(lr, ur, dr) {
      for (var fr = dr.from, gr = dr.startLine, mr = dr.endLine, vr = dr.indexDiff, yr = vr === void 0 ? 0 : vr, _r = 0, kr = function(Er) {
        var Cr = lr.doc.child(Er), Tr = Cr.nodeSize, Sr = Cr.content, Lr = lr.mapping.map(fr), Ir = Lr + Sr.size, Nr = ur.filter(function(Rr) {
          return Rr.line - yr === Er;
        })[0];
        Nr && (lr.replaceWith(Lr, Ir, createTextNode$1(xr.context.schema, Nr.text)), _r = Math.max(_r, fr + Sr.size)), fr += Tr;
      }, xr = this, Ar = gr - yr; Ar <= mr - yr; Ar += 1)
        kr(Ar);
      return _r;
    }, ar.prototype.toggleTask = function() {
      var lr = this;
      return function(ur, dr) {
        for (var fr = ur.selection, gr = ur.tr, mr = ur.doc, vr = ur.schema, yr = lr.context.toastMark, _r = getRangeInfo(fr), kr = _r.startIndex, xr = _r.endIndex, Ar = null, Er = kr; Er <= xr; Er += 1) {
          var Cr = yr.findFirstNodeAtLine(Er + 1);
          if (isListNode$1(Cr) && Cr.listData.task) {
            var Tr = Cr.listData, Sr = Tr.checked, Lr = Tr.padding, Ir = Sr ? " " : "x", Nr = Cr.sourcepos[0], Rr = getNodeContentOffsetRange(mr, Nr[0] - 1).startOffset;
            Rr += Nr[1] + Lr, Ar = gr.replaceWith(Rr, Rr + 1, vr.text(Ir));
          }
        }
        return Ar ? (dr(Ar), !0) : !1;
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.toList("bullet")(), ur = this.toList("ordered")(), dr = this.toList("task")(), fr = this.toggleTask();
      return {
        "Mod-u": lr,
        "Mod-U": lr,
        "Mod-o": ur,
        "Mod-O": ur,
        "alt-t": dr,
        "alt-T": dr,
        "Shift-Ctrl-x": fr,
        "Shift-Ctrl-X": fr,
        Enter: this.extendList()
      };
    }, ar;
  }(Mark)
);
function toggleMark(cr, ar) {
  return function() {
    return function(lr, ur) {
      var dr = lr.tr, fr = lr.selection, gr = isFunction_1(cr) ? cr : function(Ir) {
        return cr.test(Ir);
      }, mr = ar.length, vr = dr.doc, yr = resolveSelectionPos(fr), _r = yr[0], kr = yr[1], xr = Math.max(_r - mr, 1), Ar = Math.min(kr + mr, vr.content.size - 1), Er = fr.content(), Cr = Er.content.textBetween(0, Er.content.size, `
`), Tr = vr.textBetween(xr, _r, `
`), Sr = vr.textBetween(kr, Ar, `
`);
      if (Cr = "" + Tr + Cr + Sr, Tr && Sr && gr(Cr))
        dr.delete(Ar - mr, Ar).delete(xr, xr + mr);
      else {
        dr.insertText(ar, kr).insertText(ar, _r);
        var Lr = fr.empty ? createTextSelection(dr, _r + mr) : createTextSelection(dr, _r + mr, kr + mr);
        dr.setSelection(Lr);
      }
      return ur(dr), !0;
    };
  };
}
var reStrong = /^(\*{2}|_{2}).*([\s\S]*)\1$/m, strongSyntax = "**", Strong$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strong") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return toggleMark(reStrong, strongSyntax);
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var lr = this.bold()();
      return { "Mod-b": lr, "Mod-B": lr };
    }, ar;
  }(Mark)
), reStrike = /^(~{2}).*([\s\S]*)\1$/m, strikeSyntax = "~~", Strike$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strike") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reStrike, strikeSyntax);
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return { "Mod-s": lr, "Mod-S": lr };
    }, ar;
  }(Mark)
), reEmph = /^(\*|_).*([\s\S]*)\1$/m, emphSyntax = "*", Emph$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("emph") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return toggleMark(reEmph, emphSyntax);
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var lr = this.italic()();
      return { "Mod-i": lr, "Mod-I": lr };
    }, ar;
  }(Mark)
), reCode = /^(`).*([\s\S]*)\1$/m, codeSyntax = "`", Code$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: !1 },
            end: { default: !1 },
            marked: { default: !1 }
          },
          toDOM: function(lr) {
            var ur = lr.attrs, dr = ur.start, fr = ur.end, gr = ur.marked, mr = "code";
            return dr && (mr += "|delimiter|start"), fr && (mr += "|delimiter|end"), gr && (mr += "|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, mr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return toggleMark(reCode, codeSyntax);
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return { "Shift-Mod-c": lr, "Shift-Mod-C": lr };
    }, ar;
  }(Mark)
), Link$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: !1 },
            desc: { default: !1 }
          },
          toDOM: function(lr) {
            var ur = lr.attrs, dr = ur.url, fr = ur.desc, gr = "link";
            return dr && (gr += "|link-url|marked-text"), fr && (gr += "|link-desc|marked-text"), ["span", { class: clsWithMdPrefix.apply(void 0, gr.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLinkOrImage = function(lr) {
      return function(ur) {
        return function(dr, fr) {
          var gr = dr.selection, mr = dr.tr, vr = dr.schema, yr = resolveSelectionPos(gr), _r = yr[0], kr = yr[1], xr = ur, Ar = xr.linkText, Er = xr.altText, Cr = xr.linkUrl, Tr = xr.imageUrl, Sr = Ar, Lr = Cr, Ir = "";
          return lr === "image" && (Sr = Er, Lr = Tr, Ir = "!"), Sr = escapeTextForLink(Sr), Ir += "[" + Sr + "](" + Lr + ")", fr(mr.replaceWith(_r, kr, createTextNode$1(vr, Ir))), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    }, ar;
  }(Mark)
), TaskDelimiter = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Delimiter = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Meta = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("meta") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), MarkedText = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("marked-text") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), TableCell = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table-cell") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), Html = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("html") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Mark)
), customBlockSyntax = "$$", CustomBlock$1 = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("custom-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(lr) {
        return function(ur, dr) {
          var fr = ur.selection, gr = ur.schema, mr = ur.tr, vr = getRangeInfo(fr), yr = vr.startFromOffset, _r = vr.endToOffset;
          if (!(lr != null && lr.info))
            return !1;
          var kr = "" + customBlockSyntax + lr.info, xr = createTextNode$1(gr, kr), Ar = createTextNode$1(gr, customBlockSyntax);
          return mr.insert(yr, xr).split(yr + kr.length), mr.split(mr.mapping.map(_r)).insert(mr.mapping.map(_r), Ar), dr(mr.setSelection(createTextSelection(mr, mr.mapping.map(_r) - (customBlockSyntax.length + 2)))), !0;
        };
      };
    }, ar;
  }(Mark)
), reTaskMarkerKey = /x|backspace/i, reTaskMarker = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function smartTask(cr) {
  var ar = cr.schema, lr = cr.toastMark;
  return new Plugin({
    props: {
      handleDOMEvents: {
        keyup: function(ur, dr) {
          var fr, gr = ur.state, mr = gr.doc, vr = gr.tr, yr = gr.selection;
          if (yr.empty && reTaskMarkerKey.test(dr.key)) {
            var _r = getRangeInfo(yr), kr = _r.startIndex, xr = _r.startFromOffset, Ar = _r.from, Er = [kr + 1, Ar - xr + 1], Cr = lr.findNodeAtPosition(Er), Tr = findClosestNode(Cr, function(zr) {
              var Ur;
              return zr.type === "paragraph" && ((Ur = zr.parent) === null || Ur === void 0 ? void 0 : Ur.type) === "item";
            });
            if (!((fr = Tr == null ? void 0 : Tr.firstChild) === null || fr === void 0) && fr.literal) {
              var Sr = Tr.firstChild, Lr = Sr.literal.match(reTaskMarker);
              if (Lr) {
                var Ir = Sr.sourcepos[0], Nr = Lr[1], Rr = Lr[2], Mr = Lr[3], Br = Nr.length + Mr.length, Dr = getNodeContentOffsetRange(mr, Ir[0] - 1).startOffset, Hr = Ir[1] + Dr;
                if (Rr) {
                  var Fr = Br ? Br + 1 : 0;
                  vr.replaceWith(Hr, Fr + Hr, ar.text(Rr)), ur.dispatch(vr);
                } else
                  Br || (vr.insertText(" ", Hr), ur.dispatch(vr));
              }
            }
          }
          return !1;
        }
      }
    }
  });
}
var EVENT_TYPE = "cut", reLineEnding$2 = /\r\n|\n|\r/, MdEditor = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr, ur) {
      var dr = cr.call(this, lr) || this, fr = ur.toastMark, gr = ur.useCommandShortcut, mr = gr === void 0 ? !0 : gr, vr = ur.mdPlugins, yr = vr === void 0 ? [] : vr;
      return dr.editorType = "markdown", dr.el.classList.add("md-mode"), dr.toastMark = fr, dr.extraPlugins = yr, dr.specs = dr.createSpecs(), dr.schema = dr.createSchema(), dr.context = dr.createContext(), dr.keymaps = dr.createKeymaps(mr), dr.view = dr.createView(), dr.commands = dr.createCommands(), dr.specs.setContext(__assign$1(__assign$1({}, dr.context), { view: dr.view })), dr.createClipboard(), dr.eventEmitter.listen("changePreviewTabWrite", function(_r) {
        return dr.toggleActive(!0, _r);
      }), dr.eventEmitter.listen("changePreviewTabPreview", function() {
        return dr.toggleActive(!1);
      }), dr.initEvent(), dr;
    }
    return ar.prototype.toggleActive = function(lr, ur) {
      toggleClass(this.el, "active", lr), lr ? ur || this.focus() : this.blur();
    }, ar.prototype.createClipboard = function() {
      var lr = this;
      this.clipboard = document.createElement("textarea"), this.clipboard.className = cls("pseudo-clipboard"), this.clipboard.addEventListener("paste", function(ur) {
        var dr = ur.clipboardData || window.clipboardData, fr = dr && dr.items;
        if (fr) {
          var gr = toArray_1(fr).some(function(vr) {
            return vr.kind === "string" && vr.type === "text/rtf";
          });
          if (!gr) {
            var mr = pasteImageOnly(fr);
            mr && (ur.preventDefault(), emitImageBlobHook(lr.eventEmitter, mr, ur.type));
          }
        }
      }), this.clipboard.addEventListener("input", function(ur) {
        var dr = ur.target.value;
        lr.replaceSelection(dr), ur.preventDefault(), ur.target.value = "";
      }), this.el.insertBefore(this.clipboard, this.view.dom);
    }, ar.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSpecs = function() {
      return new SpecManager([
        new Doc$1(),
        new Paragraph$1(),
        new Widget(),
        new Text$1(),
        new Heading$1(),
        new BlockQuote$1(),
        new CodeBlock$1(),
        new CustomBlock$1(),
        new Table$1(),
        new TableCell(),
        new ThematicBreak$1(),
        new ListItem$1(),
        new Strong$1(),
        new Strike$1(),
        new Emph$1(),
        new Code$1(),
        new Link$1(),
        new Delimiter(),
        new TaskDelimiter(),
        new MarkedText(),
        new Meta(),
        new Html()
      ]);
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        syntaxHighlight(this.context),
        previewHighlight(this.context),
        smartTask(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createView = function() {
      var lr = this;
      return new EditorView(this.el, {
        state: this.createState(),
        dispatchTransaction: function(ur) {
          lr.updateMarkdown(ur);
          var dr = lr.view.state.applyTransaction(ur).state;
          lr.view.updateState(dr), lr.emitChangeEvent(ur);
        },
        handleKeyDown: function(ur, dr) {
          return (dr.metaKey || dr.ctrlKey) && dr.key.toUpperCase() === "V" && lr.clipboard.focus(), lr.eventEmitter.emit("keydown", lr.editorType, dr), !1;
        },
        handleDOMEvents: {
          copy: function(ur, dr) {
            return lr.captureCopy(dr);
          },
          cut: function(ur, dr) {
            return lr.captureCopy(dr, EVENT_TYPE);
          },
          scroll: function() {
            return lr.eventEmitter.emit("scroll", "editor"), !0;
          },
          keyup: function(ur, dr) {
            return lr.eventEmitter.emit("keyup", lr.editorType, dr), !1;
          }
        },
        nodeViews: {
          widget: widgetNodeView
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, ar.prototype.captureCopy = function(lr, ur) {
      lr.preventDefault();
      var dr = this.view.state, fr = dr.selection, gr = dr.tr;
      if (fr.empty)
        return !0;
      var mr = this.getChanged(fr.content());
      return lr.clipboardData ? lr.clipboardData.setData("text/plain", mr) : window.clipboardData.setData("Text", mr), ur === EVENT_TYPE && this.view.dispatch(gr.deleteSelection().scrollIntoView().setMeta("uiEvent", EVENT_TYPE)), !0;
    }, ar.prototype.updateMarkdown = function(lr) {
      var ur = this;
      lr.docChanged && lr.steps.forEach(function(dr, fr) {
        if (dr.slice && !(dr instanceof ReplaceAroundStep)) {
          var gr = lr.docs[fr], mr = [dr.from, dr.to], vr = mr[0], yr = mr[1], _r = getEditorToMdPos(gr, vr, yr), kr = _r[0], xr = _r[1], Ar = ur.getChanged(dr.slice);
          kr[0] === xr[0] && kr[1] === xr[1] && Ar === "" && (Ar = `
`);
          var Er = ur.toastMark.editMarkdown(kr, xr, Ar);
          ur.eventEmitter.emit("updatePreview", Er), lr.setMeta("editResult", Er).scrollIntoView();
        }
      });
    }, ar.prototype.getChanged = function(lr) {
      var ur = "", dr = 0, fr = lr.content.size;
      return lr.content.nodesBetween(dr, fr, function(gr, mr) {
        gr.isText ? ur += gr.text.slice(Math.max(dr, mr) - mr, fr - mr) : gr.isBlock && mr > 0 && (ur += `
`);
      }), ur;
    }, ar.prototype.setSelection = function(lr, ur) {
      ur === void 0 && (ur = lr);
      var dr = this.view.state.tr, fr = getMdToEditorPos(dr.doc, lr, ur), gr = fr[0], mr = fr[1];
      this.view.dispatch(dr.setSelection(createTextSelection(dr, gr, mr)).scrollIntoView());
    }, ar.prototype.replaceSelection = function(lr, ur, dr) {
      var fr, gr = this.view.state, mr = gr.tr, vr = gr.schema, yr = gr.doc, _r = lr.split(reLineEnding$2), kr = _r.map(function(Tr) {
        return createParagraph(vr, createNodesWithWidget(Tr, vr));
      }), xr = new Slice(Fragment.from(kr), 1, 1);
      if (this.focus(), ur && dr) {
        var Ar = getMdToEditorPos(yr, ur, dr), Er = Ar[0], Cr = Ar[1];
        fr = mr.replaceRange(Er, Cr, xr);
      } else
        fr = mr.replaceSelection(xr);
      this.view.dispatch(fr.scrollIntoView());
    }, ar.prototype.deleteSelection = function(lr, ur) {
      var dr, fr = this.view.state, gr = fr.tr, mr = fr.doc;
      if (lr && ur) {
        var vr = getMdToEditorPos(mr, lr, ur), yr = vr[0], _r = vr[1];
        dr = gr.deleteRange(yr, _r);
      } else
        dr = gr.deleteSelection();
      this.view.dispatch(dr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(lr, ur) {
      var dr = this.view.state, fr = dr.doc, gr = dr.selection, mr = gr.from, vr = gr.to;
      if (lr && ur) {
        var yr = getMdToEditorPos(fr, lr, ur);
        mr = yr[0], vr = yr[1];
      }
      return fr.textBetween(mr, vr, `
`);
    }, ar.prototype.getSelection = function() {
      var lr = this.view.state.selection, ur = lr.from, dr = lr.to;
      return getEditorToMdPos(this.view.state.tr.doc, ur, dr);
    }, ar.prototype.setMarkdown = function(lr, ur) {
      ur === void 0 && (ur = !0);
      var dr = lr.split(reLineEnding$2), fr = this.view.state, gr = fr.tr, mr = fr.doc, vr = fr.schema, yr = dr.map(function(_r) {
        return createParagraph(vr, createNodesWithWidget(_r, vr));
      });
      this.view.dispatch(gr.replaceWith(0, mr.content.size, yr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.addWidget = function(lr, ur, dr) {
      var fr = this.view.state, gr = fr.tr, mr = fr.doc, vr = fr.selection, yr = dr ? getMdToEditorPos(mr, dr, dr)[0] : vr.to;
      this.view.dispatch(gr.setMeta("widget", { pos: yr, node: lr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(lr, ur, dr) {
      var fr = this.view.state, gr = fr.tr, mr = fr.schema, vr = fr.doc, yr = getMdToEditorPos(vr, lr, ur), _r = createNodesWithWidget(dr, mr);
      this.view.dispatch(gr.replaceWith(yr[0], yr[1], _r));
    }, ar.prototype.getRangeInfoOfNode = function(lr) {
      var ur = this.view.state, dr = ur.doc, fr = ur.selection, gr = lr || getEditorToMdPos(dr, fr.from)[0], mr = this.toastMark.findNodeAtPosition(gr);
      return mr.type === "text" && mr.parent.type !== "paragraph" && (mr = mr.parent), mr.sourcepos[1][1] += 1, { range: mr.sourcepos, type: mr.type };
    }, ar.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(lr) {
        return unwrapWidgetSyntax(lr);
      }).join(`
`);
    }, ar.prototype.getToastMark = function() {
      return this.toastMark;
    }, ar;
  }(EditorBase)
), EVENT_KEY = "_feEventKey";
function safeEvent$2(cr, ar) {
  var lr = cr[EVENT_KEY], ur;
  return lr || (lr = cr[EVENT_KEY] = {}), ur = lr[ar], ur || (ur = lr[ar] = []), ur;
}
var _safeEvent = safeEvent$2, isString$1 = isString_1, forEach$1 = forEach_1, safeEvent$1 = _safeEvent;
function off(cr, ar, lr) {
  if (isString$1(ar)) {
    forEach$1(ar.split(/\s+/g), function(ur) {
      unbindEvent(cr, ur, lr);
    });
    return;
  }
  forEach$1(ar, function(ur, dr) {
    unbindEvent(cr, dr, ur);
  });
}
function unbindEvent(cr, ar, lr) {
  var ur = safeEvent$1(cr, ar), dr;
  lr ? (forEach$1(ur, function(fr, gr) {
    return lr === fr.handler ? (removeHandler(cr, ar, fr.wrappedHandler), dr = gr, !1) : !0;
  }), ur.splice(dr, 1)) : (forEach$1(ur, function(fr) {
    removeHandler(cr, ar, fr.wrappedHandler);
  }), ur.splice(0, ur.length));
}
function removeHandler(cr, ar, lr) {
  "removeEventListener" in cr ? cr.removeEventListener(ar, lr) : "detachEvent" in cr && cr.detachEvent("on" + ar, lr);
}
var off_1 = off, isString = isString_1, forEach = forEach_1, safeEvent = _safeEvent;
function on(cr, ar, lr, ur) {
  if (isString(ar)) {
    forEach(ar.split(/\s+/g), function(dr) {
      bindEvent(cr, dr, lr, ur);
    });
    return;
  }
  forEach(ar, function(dr, fr) {
    bindEvent(cr, fr, dr, lr);
  });
}
function bindEvent(cr, ar, lr, ur) {
  function dr(fr) {
    lr.call(ur || cr, fr || window.event);
  }
  "addEventListener" in cr ? cr.addEventListener(ar, dr) : "attachEvent" in cr && cr.attachEvent("on" + ar, dr), memorizeHandler(cr, ar, lr, dr);
}
function memorizeHandler(cr, ar, lr, ur) {
  var dr = safeEvent(cr, ar), fr = !1;
  forEach(dr, function(gr) {
    return gr.handler === lr ? (fr = !0, !1) : !0;
  }), fr || dr.push({
    handler: lr,
    wrappedHandler: ur
  });
}
var on_1 = on;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(cr, ar) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(lr, ur) {
    lr.__proto__ = ur;
  } || function(lr, ur) {
    for (var dr in ur)
      Object.prototype.hasOwnProperty.call(ur, dr) && (lr[dr] = ur[dr]);
  }, extendStatics(cr, ar);
};
function __extends(cr, ar) {
  if (typeof ar != "function" && ar !== null)
    throw new TypeError("Class extends value " + String(ar) + " is not a constructor or null");
  extendStatics(cr, ar);
  function lr() {
    this.constructor = cr;
  }
  cr.prototype = ar === null ? Object.create(ar) : (lr.prototype = ar.prototype, new lr());
}
var __assign = function() {
  return __assign = Object.assign || function(ar) {
    for (var lr, ur = 1, dr = arguments.length; ur < dr; ur++) {
      lr = arguments[ur];
      for (var fr in lr)
        Object.prototype.hasOwnProperty.call(lr, fr) && (ar[fr] = lr[fr]);
    }
    return ar;
  }, __assign.apply(this, arguments);
};
function __spreadArray(cr, ar, lr) {
  if (lr || arguments.length === 2)
    for (var ur = 0, dr = ar.length, fr; ur < dr; ur++)
      (fr || !(ur in ar)) && (fr || (fr = Array.prototype.slice.call(ar, 0, ur)), fr[ur] = ar[ur]);
  return cr.concat(fr || Array.prototype.slice.call(ar));
}
var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, encodeCache = {};
function getEncodeCache(cr) {
  var ar, lr, ur = encodeCache[cr];
  if (ur)
    return ur;
  for (ur = encodeCache[cr] = [], ar = 0; ar < 128; ar++)
    lr = String.fromCharCode(ar), /^[0-9a-z]$/i.test(lr) ? ur.push(lr) : ur.push("%" + ("0" + ar.toString(16).toUpperCase()).slice(-2));
  for (ar = 0; ar < cr.length; ar++)
    ur[cr.charCodeAt(ar)] = cr[ar];
  return ur;
}
function encode$1(cr, ar, lr) {
  var ur, dr, fr, gr, mr, vr = "";
  for (typeof ar != "string" && (lr = ar, ar = encode$1.defaultChars), typeof lr == "undefined" && (lr = !0), mr = getEncodeCache(ar), ur = 0, dr = cr.length; ur < dr; ur++) {
    if (fr = cr.charCodeAt(ur), lr && fr === 37 && ur + 2 < dr && /^[0-9a-f]{2}$/i.test(cr.slice(ur + 1, ur + 3))) {
      vr += cr.slice(ur, ur + 3), ur += 2;
      continue;
    }
    if (fr < 128) {
      vr += mr[fr];
      continue;
    }
    if (fr >= 55296 && fr <= 57343) {
      if (fr >= 55296 && fr <= 56319 && ur + 1 < dr && (gr = cr.charCodeAt(ur + 1), gr >= 56320 && gr <= 57343)) {
        vr += encodeURIComponent(cr[ur] + cr[ur + 1]), ur++;
        continue;
      }
      vr += "%EF%BF%BD";
      continue;
    }
    vr += encodeURIComponent(cr[ur]);
  }
  return vr;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1, lib = {}, decode = {}, Aacute$1 = "", aacute$1 = "", Abreve = "", abreve = "", ac = "", acd = "", acE = "", Acirc$1 = "", acirc$1 = "", acute$1 = "", Acy = "", acy = "", AElig$1 = "", aelig$1 = "", af = "", Afr = "", afr = "", Agrave$1 = "", agrave$1 = "", alefsym = "", aleph = "", Alpha = "", alpha = "", Amacr = "", amacr = "", amalg = "", amp$2 = "&", AMP$1 = "&", andand = "", And = "", and = "", andd = "", andslope = "", andv = "", ang = "", ange = "", angle = "", angmsdaa = "", angmsdab = "", angmsdac = "", angmsdad = "", angmsdae = "", angmsdaf = "", angmsdag = "", angmsdah = "", angmsd = "", angrt = "", angrtvb = "", angrtvbd = "", angsph = "", angst = "", angzarr = "", Aogon = "", aogon = "", Aopf = "", aopf = "", apacir = "", ap = "", apE = "", ape = "", apid = "", apos$1 = "'", ApplyFunction = "", approx = "", approxeq = "", Aring$1 = "", aring$1 = "", Ascr = "", ascr = "", Assign = "", ast = "*", asymp = "", asympeq = "", Atilde$1 = "", atilde$1 = "", Auml$1 = "", auml$1 = "", awconint = "", awint = "", backcong = "", backepsilon = "", backprime = "", backsim = "", backsimeq = "", Backslash = "", Barv = "", barvee = "", barwed = "", Barwed = "", barwedge = "", bbrk = "", bbrktbrk = "", bcong = "", Bcy = "", bcy = "", bdquo = "", becaus = "", because = "", Because = "", bemptyv = "", bepsi = "", bernou = "", Bernoullis = "", Beta = "", beta = "", beth = "", between = "", Bfr = "", bfr = "", bigcap = "", bigcirc = "", bigcup = "", bigodot = "", bigoplus = "", bigotimes = "", bigsqcup = "", bigstar = "", bigtriangledown = "", bigtriangleup = "", biguplus = "", bigvee = "", bigwedge = "", bkarow = "", blacklozenge = "", blacksquare = "", blacktriangle = "", blacktriangledown = "", blacktriangleleft = "", blacktriangleright = "", blank = "", blk12 = "", blk14 = "", blk34 = "", block$1 = "", bne = "=", bnequiv = "", bNot = "", bnot = "", Bopf = "", bopf = "", bot = "", bottom = "", bowtie = "", boxbox = "", boxdl = "", boxdL = "", boxDl = "", boxDL = "", boxdr = "", boxdR = "", boxDr = "", boxDR = "", boxh = "", boxH = "", boxhd = "", boxHd = "", boxhD = "", boxHD = "", boxhu = "", boxHu = "", boxhU = "", boxHU = "", boxminus = "", boxplus = "", boxtimes = "", boxul = "", boxuL = "", boxUl = "", boxUL = "", boxur = "", boxuR = "", boxUr = "", boxUR = "", boxv = "", boxV = "", boxvh = "", boxvH = "", boxVh = "", boxVH = "", boxvl = "", boxvL = "", boxVl = "", boxVL = "", boxvr = "", boxvR = "", boxVr = "", boxVR = "", bprime = "", breve = "", Breve = "", brvbar$1 = "", bscr = "", Bscr = "", bsemi = "", bsim = "", bsime = "", bsolb = "", bsol = "\\", bsolhsub = "", bull = "", bullet$1 = "", bump = "", bumpE = "", bumpe = "", Bumpeq = "", bumpeq = "", Cacute = "", cacute = "", capand = "", capbrcup = "", capcap = "", cap = "", Cap = "", capcup = "", capdot = "", CapitalDifferentialD = "", caps = "", caret$1 = "", caron = "", Cayleys = "", ccaps = "", Ccaron = "", ccaron = "", Ccedil$1 = "", ccedil$1 = "", Ccirc = "", ccirc = "", Cconint = "", ccups = "", ccupssm = "", Cdot = "", cdot = "", cedil$1 = "", Cedilla = "", cemptyv = "", cent$1 = "", centerdot = "", CenterDot = "", cfr = "", Cfr = "", CHcy = "", chcy = "", check = "", checkmark = "", Chi = "", chi = "", circ = "", circeq = "", circlearrowleft = "", circlearrowright = "", circledast = "", circledcirc = "", circleddash = "", CircleDot = "", circledR = "", circledS = "", CircleMinus = "", CirclePlus = "", CircleTimes = "", cir = "", cirE = "", cire = "", cirfnint = "", cirmid = "", cirscir = "", ClockwiseContourIntegral = "", CloseCurlyDoubleQuote = "", CloseCurlyQuote = "", clubs = "", clubsuit = "", colon = ":", Colon = "", Colone = "", colone = "", coloneq = "", comma = ",", commat = "@", comp = "", compfn = "", complement = "", complexes = "", cong = "", congdot = "", Congruent = "", conint = "", Conint = "", ContourIntegral = "", copf = "", Copf = "", coprod = "", Coproduct = "", copy$1 = "", COPY$1 = "", copysr = "", CounterClockwiseContourIntegral = "", crarr = "", cross = "", Cross = "", Cscr = "", cscr = "", csub = "", csube = "", csup = "", csupe = "", ctdot = "", cudarrl = "", cudarrr = "", cuepr = "", cuesc = "", cularr = "", cularrp = "", cupbrcap = "", cupcap = "", CupCap = "", cup = "", Cup = "", cupcup = "", cupdot = "", cupor = "", cups = "", curarr = "", curarrm = "", curlyeqprec = "", curlyeqsucc = "", curlyvee = "", curlywedge = "", curren$1 = "", curvearrowleft = "", curvearrowright = "", cuvee = "", cuwed = "", cwconint = "", cwint = "", cylcty = "", dagger = "", Dagger = "", daleth = "", darr = "", Darr = "", dArr = "", dash = "", Dashv = "", dashv = "", dbkarow = "", dblac = "", Dcaron = "", dcaron = "", Dcy = "", dcy = "", ddagger = "", ddarr = "", DD = "", dd = "", DDotrahd = "", ddotseq = "", deg$1 = "", Del = "", Delta = "", delta = "", demptyv = "", dfisht = "", Dfr = "", dfr = "", dHar = "", dharl = "", dharr = "", DiacriticalAcute = "", DiacriticalDot = "", DiacriticalDoubleAcute = "", DiacriticalGrave = "`", DiacriticalTilde = "", diam = "", diamond = "", Diamond = "", diamondsuit = "", diams = "", die = "", DifferentialD = "", digamma = "", disin = "", div = "", divide$1 = "", divideontimes = "", divonx = "", DJcy = "", djcy = "", dlcorn = "", dlcrop = "", dollar = "$", Dopf = "", dopf = "", Dot = "", dot = "", DotDot = "", doteq = "", doteqdot = "", DotEqual = "", dotminus = "", dotplus = "", dotsquare = "", doublebarwedge = "", DoubleContourIntegral = "", DoubleDot = "", DoubleDownArrow = "", DoubleLeftArrow = "", DoubleLeftRightArrow = "", DoubleLeftTee = "", DoubleLongLeftArrow = "", DoubleLongLeftRightArrow = "", DoubleLongRightArrow = "", DoubleRightArrow = "", DoubleRightTee = "", DoubleUpArrow = "", DoubleUpDownArrow = "", DoubleVerticalBar = "", DownArrowBar = "", downarrow = "", DownArrow = "", Downarrow = "", DownArrowUpArrow = "", DownBreve = "", downdownarrows = "", downharpoonleft = "", downharpoonright = "", DownLeftRightVector = "", DownLeftTeeVector = "", DownLeftVectorBar = "", DownLeftVector = "", DownRightTeeVector = "", DownRightVectorBar = "", DownRightVector = "", DownTeeArrow = "", DownTee = "", drbkarow = "", drcorn = "", drcrop = "", Dscr = "", dscr = "", DScy = "", dscy = "", dsol = "", Dstrok = "", dstrok = "", dtdot = "", dtri = "", dtrif = "", duarr = "", duhar = "", dwangle = "", DZcy = "", dzcy = "", dzigrarr = "", Eacute$1 = "", eacute$1 = "", easter = "", Ecaron = "", ecaron = "", Ecirc$1 = "", ecirc$1 = "", ecir = "", ecolon = "", Ecy = "", ecy = "", eDDot = "", Edot = "", edot = "", eDot = "", ee = "", efDot = "", Efr = "", efr = "", eg = "", Egrave$1 = "", egrave$1 = "", egs = "", egsdot = "", el = "", Element$1 = "", elinters = "", ell = "", els = "", elsdot = "", Emacr = "", emacr = "", empty = "", emptyset = "", EmptySmallSquare = "", emptyv = "", EmptyVerySmallSquare = "", emsp13 = "", emsp14 = "", emsp = "", ENG = "", eng = "", ensp = "", Eogon = "", eogon = "", Eopf = "", eopf = "", epar = "", eparsl = "", eplus = "", epsi = "", Epsilon = "", epsilon = "", epsiv = "", eqcirc = "", eqcolon = "", eqsim = "", eqslantgtr = "", eqslantless = "", Equal = "", equals = "=", EqualTilde = "", equest = "", Equilibrium = "", equiv = "", equivDD = "", eqvparsl = "", erarr = "", erDot = "", escr = "", Escr = "", esdot = "", Esim = "", esim = "", Eta = "", eta = "", ETH$1 = "", eth$1 = "", Euml$1 = "", euml$1 = "", euro = "", excl = "!", exist = "", Exists = "", expectation = "", exponentiale = "", ExponentialE = "", fallingdotseq = "", Fcy = "", fcy = "", female = "", ffilig = "", fflig = "", ffllig = "", Ffr = "", ffr = "", filig = "", FilledSmallSquare = "", FilledVerySmallSquare = "", fjlig = "fj", flat = "", fllig = "", fltns = "", fnof = "", Fopf = "", fopf = "", forall = "", ForAll = "", fork = "", forkv = "", Fouriertrf = "", fpartint = "", frac12$1 = "", frac13 = "", frac14$1 = "", frac15 = "", frac16 = "", frac18 = "", frac23 = "", frac25 = "", frac34$1 = "", frac35 = "", frac38 = "", frac45 = "", frac56 = "", frac58 = "", frac78 = "", frasl = "", frown = "", fscr = "", Fscr = "", gacute = "", Gamma = "", gamma = "", Gammad = "", gammad = "", gap = "", Gbreve = "", gbreve = "", Gcedil = "", Gcirc = "", gcirc = "", Gcy = "", gcy = "", Gdot = "", gdot = "", ge = "", gE = "", gEl = "", gel = "", geq = "", geqq = "", geqslant = "", gescc = "", ges = "", gesdot = "", gesdoto = "", gesdotol = "", gesl = "", gesles = "", Gfr = "", gfr = "", gg = "", Gg = "", ggg = "", gimel = "", GJcy = "", gjcy = "", gla = "", gl = "", glE = "", glj = "", gnap = "", gnapprox = "", gne = "", gnE = "", gneq = "", gneqq = "", gnsim = "", Gopf = "", gopf = "", grave = "`", GreaterEqual = "", GreaterEqualLess = "", GreaterFullEqual = "", GreaterGreater = "", GreaterLess = "", GreaterSlantEqual = "", GreaterTilde = "", Gscr = "", gscr = "", gsim = "", gsime = "", gsiml = "", gtcc = "", gtcir = "", gt$2 = ">", GT$1 = ">", Gt = "", gtdot = "", gtlPar = "", gtquest = "", gtrapprox = "", gtrarr = "", gtrdot = "", gtreqless = "", gtreqqless = "", gtrless = "", gtrsim = "", gvertneqq = "", gvnE = "", Hacek = "", hairsp = "", half = "", hamilt = "", HARDcy = "", hardcy = "", harrcir = "", harr = "", hArr = "", harrw = "", Hat = "^", hbar = "", Hcirc = "", hcirc = "", hearts = "", heartsuit = "", hellip = "", hercon = "", hfr = "", Hfr = "", HilbertSpace = "", hksearow = "", hkswarow = "", hoarr = "", homtht = "", hookleftarrow = "", hookrightarrow = "", hopf = "", Hopf = "", horbar = "", HorizontalLine = "", hscr = "", Hscr = "", hslash = "", Hstrok = "", hstrok = "", HumpDownHump = "", HumpEqual = "", hybull = "", hyphen = "", Iacute$1 = "", iacute$1 = "", ic = "", Icirc$1 = "", icirc$1 = "", Icy = "", icy = "", Idot = "", IEcy = "", iecy = "", iexcl$1 = "", iff = "", ifr = "", Ifr = "", Igrave$1 = "", igrave$1 = "", ii = "", iiiint = "", iiint = "", iinfin = "", iiota = "", IJlig = "", ijlig = "", Imacr = "", imacr = "", image = "", ImaginaryI = "", imagline = "", imagpart = "", imath = "", Im = "", imof = "", imped = "", Implies = "", incare = "", infin = "", infintie = "", inodot = "", intcal = "", int = "", Int = "", integers = "", Integral = "", intercal = "", Intersection = "", intlarhk = "", intprod = "", InvisibleComma = "", InvisibleTimes = "", IOcy = "", iocy = "", Iogon = "", iogon = "", Iopf = "", iopf = "", Iota = "", iota = "", iprod = "", iquest$1 = "", iscr = "", Iscr = "", isin = "", isindot = "", isinE = "", isins = "", isinsv = "", isinv = "", it = "", Itilde = "", itilde = "", Iukcy = "", iukcy = "", Iuml$1 = "", iuml$1 = "", Jcirc = "", jcirc = "", Jcy = "", jcy = "", Jfr = "", jfr = "", jmath = "", Jopf = "", jopf = "", Jscr = "", jscr = "", Jsercy = "", jsercy = "", Jukcy = "", jukcy = "", Kappa = "", kappa = "", kappav = "", Kcedil = "", kcedil = "", Kcy = "", kcy = "", Kfr = "", kfr = "", kgreen = "", KHcy = "", khcy = "", KJcy = "", kjcy = "", Kopf = "", kopf = "", Kscr = "", kscr = "", lAarr = "", Lacute = "", lacute = "", laemptyv = "", lagran = "", Lambda = "", lambda = "", lang = "", Lang = "", langd = "", langle = "", lap = "", Laplacetrf = "", laquo$1 = "", larrb = "", larrbfs = "", larr = "", Larr = "", lArr = "", larrfs = "", larrhk = "", larrlp = "", larrpl = "", larrsim = "", larrtl = "", latail = "", lAtail = "", lat = "", late = "", lates = "", lbarr = "", lBarr = "", lbbrk = "", lbrace = "{", lbrack = "[", lbrke = "", lbrksld = "", lbrkslu = "", Lcaron = "", lcaron = "", Lcedil = "", lcedil = "", lceil = "", lcub = "{", Lcy = "", lcy = "", ldca = "", ldquo = "", ldquor = "", ldrdhar = "", ldrushar = "", ldsh = "", le = "", lE = "", LeftAngleBracket = "", LeftArrowBar = "", leftarrow = "", LeftArrow = "", Leftarrow = "", LeftArrowRightArrow = "", leftarrowtail = "", LeftCeiling = "", LeftDoubleBracket = "", LeftDownTeeVector = "", LeftDownVectorBar = "", LeftDownVector = "", LeftFloor = "", leftharpoondown = "", leftharpoonup = "", leftleftarrows = "", leftrightarrow = "", LeftRightArrow = "", Leftrightarrow = "", leftrightarrows = "", leftrightharpoons = "", leftrightsquigarrow = "", LeftRightVector = "", LeftTeeArrow = "", LeftTee = "", LeftTeeVector = "", leftthreetimes = "", LeftTriangleBar = "", LeftTriangle = "", LeftTriangleEqual = "", LeftUpDownVector = "", LeftUpTeeVector = "", LeftUpVectorBar = "", LeftUpVector = "", LeftVectorBar = "", LeftVector = "", lEg = "", leg = "", leq = "", leqq = "", leqslant = "", lescc = "", les = "", lesdot = "", lesdoto = "", lesdotor = "", lesg = "", lesges = "", lessapprox = "", lessdot = "", lesseqgtr = "", lesseqqgtr = "", LessEqualGreater = "", LessFullEqual = "", LessGreater = "", lessgtr = "", LessLess = "", lesssim = "", LessSlantEqual = "", LessTilde = "", lfisht = "", lfloor = "", Lfr = "", lfr = "", lg = "", lgE = "", lHar = "", lhard = "", lharu = "", lharul = "", lhblk = "", LJcy = "", ljcy = "", llarr = "", ll = "", Ll = "", llcorner = "", Lleftarrow = "", llhard = "", lltri = "", Lmidot = "", lmidot = "", lmoustache = "", lmoust = "", lnap = "", lnapprox = "", lne = "", lnE = "", lneq = "", lneqq = "", lnsim = "", loang = "", loarr = "", lobrk = "", longleftarrow = "", LongLeftArrow = "", Longleftarrow = "", longleftrightarrow = "", LongLeftRightArrow = "", Longleftrightarrow = "", longmapsto = "", longrightarrow = "", LongRightArrow = "", Longrightarrow = "", looparrowleft = "", looparrowright = "", lopar = "", Lopf = "", lopf = "", loplus = "", lotimes = "", lowast = "", lowbar = "_", LowerLeftArrow = "", LowerRightArrow = "", loz = "", lozenge = "", lozf = "", lpar = "(", lparlt = "", lrarr = "", lrcorner = "", lrhar = "", lrhard = "", lrm = "", lrtri = "", lsaquo = "", lscr = "", Lscr = "", lsh = "", Lsh = "", lsim = "", lsime = "", lsimg = "", lsqb = "[", lsquo = "", lsquor = "", Lstrok = "", lstrok = "", ltcc = "", ltcir = "", lt$2 = "<", LT$1 = "<", Lt = "", ltdot = "", lthree = "", ltimes = "", ltlarr = "", ltquest = "", ltri = "", ltrie = "", ltrif = "", ltrPar = "", lurdshar = "", luruhar = "", lvertneqq = "", lvnE = "", macr$1 = "", male = "", malt = "", maltese = "", map = "", mapsto = "", mapstodown = "", mapstoleft = "", mapstoup = "", marker = "", mcomma = "", Mcy = "", mcy = "", mdash = "", mDDot = "", measuredangle = "", MediumSpace = "", Mellintrf = "", Mfr = "", mfr = "", mho = "", micro$1 = "", midast = "*", midcir = "", mid = "", middot$1 = "", minusb = "", minus = "", minusd = "", minusdu = "", MinusPlus = "", mlcp = "", mldr = "", mnplus = "", models = "", Mopf = "", mopf = "", mp = "", mscr = "", Mscr = "", mstpos = "", Mu = "", mu = "", multimap = "", mumap = "", nabla = "", Nacute = "", nacute = "", nang = "", nap = "", napE = "", napid = "", napos = "", napprox = "", natural = "", naturals = "", natur = "", nbsp$1 = "", nbump = "", nbumpe = "", ncap = "", Ncaron = "", ncaron = "", Ncedil = "", ncedil = "", ncong = "", ncongdot = "", ncup = "", Ncy = "", ncy = "", ndash = "", nearhk = "", nearr = "", neArr = "", nearrow = "", ne = "", nedot = "", NegativeMediumSpace = "", NegativeThickSpace = "", NegativeThinSpace = "", NegativeVeryThinSpace = "", nequiv = "", nesear = "", nesim = "", NestedGreaterGreater = "", NestedLessLess = "", NewLine = `
`, nexist = "", nexists = "", Nfr = "", nfr = "", ngE = "", nge = "", ngeq = "", ngeqq = "", ngeqslant = "", nges = "", nGg = "", ngsim = "", nGt = "", ngt = "", ngtr = "", nGtv = "", nharr = "", nhArr = "", nhpar = "", ni = "", nis = "", nisd = "", niv = "", NJcy = "", njcy = "", nlarr = "", nlArr = "", nldr = "", nlE = "", nle = "", nleftarrow = "", nLeftarrow = "", nleftrightarrow = "", nLeftrightarrow = "", nleq = "", nleqq = "", nleqslant = "", nles = "", nless = "", nLl = "", nlsim = "", nLt = "", nlt = "", nltri = "", nltrie = "", nLtv = "", nmid = "", NoBreak = "", NonBreakingSpace = "", nopf = "", Nopf = "", Not = "", not$1 = "", NotCongruent = "", NotCupCap = "", NotDoubleVerticalBar = "", NotElement = "", NotEqual = "", NotEqualTilde = "", NotExists = "", NotGreater = "", NotGreaterEqual = "", NotGreaterFullEqual = "", NotGreaterGreater = "", NotGreaterLess = "", NotGreaterSlantEqual = "", NotGreaterTilde = "", NotHumpDownHump = "", NotHumpEqual = "", notin = "", notindot = "", notinE = "", notinva = "", notinvb = "", notinvc = "", NotLeftTriangleBar = "", NotLeftTriangle = "", NotLeftTriangleEqual = "", NotLess = "", NotLessEqual = "", NotLessGreater = "", NotLessLess = "", NotLessSlantEqual = "", NotLessTilde = "", NotNestedGreaterGreater = "", NotNestedLessLess = "", notni = "", notniva = "", notnivb = "", notnivc = "", NotPrecedes = "", NotPrecedesEqual = "", NotPrecedesSlantEqual = "", NotReverseElement = "", NotRightTriangleBar = "", NotRightTriangle = "", NotRightTriangleEqual = "", NotSquareSubset = "", NotSquareSubsetEqual = "", NotSquareSuperset = "", NotSquareSupersetEqual = "", NotSubset = "", NotSubsetEqual = "", NotSucceeds = "", NotSucceedsEqual = "", NotSucceedsSlantEqual = "", NotSucceedsTilde = "", NotSuperset = "", NotSupersetEqual = "", NotTilde = "", NotTildeEqual = "", NotTildeFullEqual = "", NotTildeTilde = "", NotVerticalBar = "", nparallel = "", npar = "", nparsl = "", npart = "", npolint = "", npr = "", nprcue = "", nprec = "", npreceq = "", npre = "", nrarrc = "", nrarr = "", nrArr = "", nrarrw = "", nrightarrow = "", nRightarrow = "", nrtri = "", nrtrie = "", nsc = "", nsccue = "", nsce = "", Nscr = "", nscr = "", nshortmid = "", nshortparallel = "", nsim = "", nsime = "", nsimeq = "", nsmid = "", nspar = "", nsqsube = "", nsqsupe = "", nsub = "", nsubE = "", nsube = "", nsubset = "", nsubseteq = "", nsubseteqq = "", nsucc = "", nsucceq = "", nsup = "", nsupE = "", nsupe = "", nsupset = "", nsupseteq = "", nsupseteqq = "", ntgl = "", Ntilde$1 = "", ntilde$1 = "", ntlg = "", ntriangleleft = "", ntrianglelefteq = "", ntriangleright = "", ntrianglerighteq = "", Nu = "", nu = "", num = "#", numero = "", numsp = "", nvap = "", nvdash = "", nvDash = "", nVdash = "", nVDash = "", nvge = "", nvgt = ">", nvHarr = "", nvinfin = "", nvlArr = "", nvle = "", nvlt = "<", nvltrie = "", nvrArr = "", nvrtrie = "", nvsim = "", nwarhk = "", nwarr = "", nwArr = "", nwarrow = "", nwnear = "", Oacute$1 = "", oacute$1 = "", oast = "", Ocirc$1 = "", ocirc$1 = "", ocir = "", Ocy = "", ocy = "", odash = "", Odblac = "", odblac = "", odiv = "", odot = "", odsold = "", OElig = "", oelig = "", ofcir = "", Ofr = "", ofr = "", ogon = "", Ograve$1 = "", ograve$1 = "", ogt = "", ohbar = "", ohm = "", oint = "", olarr = "", olcir = "", olcross = "", oline = "", olt = "", Omacr = "", omacr = "", Omega = "", omega = "", Omicron = "", omicron = "", omid = "", ominus = "", Oopf = "", oopf = "", opar = "", OpenCurlyDoubleQuote = "", OpenCurlyQuote = "", operp = "", oplus = "", orarr = "", Or = "", or = "", ord = "", order = "", orderof = "", ordf$1 = "", ordm$1 = "", origof = "", oror = "", orslope = "", orv = "", oS = "", Oscr = "", oscr = "", Oslash$1 = "", oslash$1 = "", osol = "", Otilde$1 = "", otilde$1 = "", otimesas = "", Otimes = "", otimes = "", Ouml$1 = "", ouml$1 = "", ovbar = "", OverBar = "", OverBrace = "", OverBracket = "", OverParenthesis = "", para$1 = "", parallel = "", par = "", parsim = "", parsl = "", part = "", PartialD = "", Pcy = "", pcy = "", percnt = "%", period = ".", permil = "", perp = "", pertenk = "", Pfr = "", pfr = "", Phi = "", phi = "", phiv = "", phmmat = "", phone = "", Pi = "", pi = "", pitchfork = "", piv = "", planck = "", planckh = "", plankv = "", plusacir = "", plusb = "", pluscir = "", plus = "+", plusdo = "", plusdu = "", pluse = "", PlusMinus = "", plusmn$1 = "", plussim = "", plustwo = "", pm = "", Poincareplane = "", pointint = "", popf = "", Popf = "", pound$1 = "", prap = "", Pr = "", pr = "", prcue = "", precapprox = "", prec = "", preccurlyeq = "", Precedes = "", PrecedesEqual = "", PrecedesSlantEqual = "", PrecedesTilde = "", preceq = "", precnapprox = "", precneqq = "", precnsim = "", pre = "", prE = "", precsim = "", prime = "", Prime = "", primes = "", prnap = "", prnE = "", prnsim = "", prod = "", Product = "", profalar = "", profline = "", profsurf = "", prop = "", Proportional = "", Proportion = "", propto = "", prsim = "", prurel = "", Pscr = "", pscr = "", Psi = "", psi = "", puncsp = "", Qfr = "", qfr = "", qint = "", qopf = "", Qopf = "", qprime = "", Qscr = "", qscr = "", quaternions = "", quatint = "", quest = "?", questeq = "", quot$2 = '"', QUOT$1 = '"', rAarr = "", race = "", Racute = "", racute = "", radic = "", raemptyv = "", rang = "", Rang = "", rangd = "", range = "", rangle = "", raquo$1 = "", rarrap = "", rarrb = "", rarrbfs = "", rarrc = "", rarr = "", Rarr = "", rArr = "", rarrfs = "", rarrhk = "", rarrlp = "", rarrpl = "", rarrsim = "", Rarrtl = "", rarrtl = "", rarrw = "", ratail = "", rAtail = "", ratio = "", rationals = "", rbarr = "", rBarr = "", RBarr = "", rbbrk = "", rbrace = "}", rbrack = "]", rbrke = "", rbrksld = "", rbrkslu = "", Rcaron = "", rcaron = "", Rcedil = "", rcedil = "", rceil = "", rcub = "}", Rcy = "", rcy = "", rdca = "", rdldhar = "", rdquo = "", rdquor = "", rdsh = "", real = "", realine = "", realpart = "", reals = "", Re = "", rect = "", reg$1 = "", REG$1 = "", ReverseElement = "", ReverseEquilibrium = "", ReverseUpEquilibrium = "", rfisht = "", rfloor = "", rfr = "", Rfr = "", rHar = "", rhard = "", rharu = "", rharul = "", Rho = "", rho = "", rhov = "", RightAngleBracket = "", RightArrowBar = "", rightarrow = "", RightArrow = "", Rightarrow = "", RightArrowLeftArrow = "", rightarrowtail = "", RightCeiling = "", RightDoubleBracket = "", RightDownTeeVector = "", RightDownVectorBar = "", RightDownVector = "", RightFloor = "", rightharpoondown = "", rightharpoonup = "", rightleftarrows = "", rightleftharpoons = "", rightrightarrows = "", rightsquigarrow = "", RightTeeArrow = "", RightTee = "", RightTeeVector = "", rightthreetimes = "", RightTriangleBar = "", RightTriangle = "", RightTriangleEqual = "", RightUpDownVector = "", RightUpTeeVector = "", RightUpVectorBar = "", RightUpVector = "", RightVectorBar = "", RightVector = "", ring = "", risingdotseq = "", rlarr = "", rlhar = "", rlm = "", rmoustache = "", rmoust = "", rnmid = "", roang = "", roarr = "", robrk = "", ropar = "", ropf = "", Ropf = "", roplus = "", rotimes = "", RoundImplies = "", rpar = ")", rpargt = "", rppolint = "", rrarr = "", Rrightarrow = "", rsaquo = "", rscr = "", Rscr = "", rsh = "", Rsh = "", rsqb = "]", rsquo = "", rsquor = "", rthree = "", rtimes = "", rtri = "", rtrie = "", rtrif = "", rtriltri = "", RuleDelayed = "", ruluhar = "", rx = "", Sacute = "", sacute = "", sbquo = "", scap = "", Scaron = "", scaron = "", Sc = "", sc = "", sccue = "", sce = "", scE = "", Scedil = "", scedil = "", Scirc = "", scirc = "", scnap = "", scnE = "", scnsim = "", scpolint = "", scsim = "", Scy = "", scy = "", sdotb = "", sdot = "", sdote = "", searhk = "", searr = "", seArr = "", searrow = "", sect$1 = "", semi = ";", seswar = "", setminus = "", setmn = "", sext = "", Sfr = "", sfr = "", sfrown = "", sharp = "", SHCHcy = "", shchcy = "", SHcy = "", shcy = "", ShortDownArrow = "", ShortLeftArrow = "", shortmid = "", shortparallel = "", ShortRightArrow = "", ShortUpArrow = "", shy$1 = "", Sigma = "", sigma = "", sigmaf = "", sigmav = "", sim = "", simdot = "", sime = "", simeq = "", simg = "", simgE = "", siml = "", simlE = "", simne = "", simplus = "", simrarr = "", slarr = "", SmallCircle = "", smallsetminus = "", smashp = "", smeparsl = "", smid = "", smile = "", smt = "", smte = "", smtes = "", SOFTcy = "", softcy = "", solbar = "", solb = "", sol = "/", Sopf = "", sopf = "", spades = "", spadesuit = "", spar = "", sqcap = "", sqcaps = "", sqcup = "", sqcups = "", Sqrt = "", sqsub = "", sqsube = "", sqsubset = "", sqsubseteq = "", sqsup = "", sqsupe = "", sqsupset = "", sqsupseteq = "", square = "", Square = "", SquareIntersection = "", SquareSubset = "", SquareSubsetEqual = "", SquareSuperset = "", SquareSupersetEqual = "", SquareUnion = "", squarf = "", squ = "", squf = "", srarr = "", Sscr = "", sscr = "", ssetmn = "", ssmile = "", sstarf = "", Star = "", star = "", starf = "", straightepsilon = "", straightphi = "", strns = "", sub = "", Sub = "", subdot = "", subE = "", sube = "", subedot = "", submult = "", subnE = "", subne = "", subplus = "", subrarr = "", subset = "", Subset = "", subseteq = "", subseteqq = "", SubsetEqual = "", subsetneq = "", subsetneqq = "", subsim = "", subsub = "", subsup = "", succapprox = "", succ = "", succcurlyeq = "", Succeeds = "", SucceedsEqual = "", SucceedsSlantEqual = "", SucceedsTilde = "", succeq = "", succnapprox = "", succneqq = "", succnsim = "", succsim = "", SuchThat = "", sum = "", Sum = "", sung = "", sup1$1 = "", sup2$1 = "", sup3$1 = "", sup = "", Sup = "", supdot = "", supdsub = "", supE = "", supe = "", supedot = "", Superset = "", SupersetEqual = "", suphsol = "", suphsub = "", suplarr = "", supmult = "", supnE = "", supne = "", supplus = "", supset = "", Supset = "", supseteq = "", supseteqq = "", supsetneq = "", supsetneqq = "", supsim = "", supsub = "", supsup = "", swarhk = "", swarr = "", swArr = "", swarrow = "", swnwar = "", szlig$1 = "", Tab = "	", target = "", Tau = "", tau = "", tbrk = "", Tcaron = "", tcaron = "", Tcedil = "", tcedil = "", Tcy = "", tcy = "", tdot = "", telrec = "", Tfr = "", tfr = "", there4 = "", therefore = "", Therefore = "", Theta = "", theta = "", thetasym = "", thetav = "", thickapprox = "", thicksim = "", ThickSpace = "", ThinSpace = "", thinsp = "", thkap = "", thksim = "", THORN$1 = "", thorn$1 = "", tilde = "", Tilde = "", TildeEqual = "", TildeFullEqual = "", TildeTilde = "", timesbar = "", timesb = "", times$1 = "", timesd = "", tint = "", toea = "", topbot = "", topcir = "", top = "", Topf = "", topf = "", topfork = "", tosa = "", tprime = "", trade = "", TRADE = "", triangle = "", triangledown = "", triangleleft = "", trianglelefteq = "", triangleq = "", triangleright = "", trianglerighteq = "", tridot = "", trie = "", triminus = "", TripleDot = "", triplus = "", trisb = "", tritime = "", trpezium = "", Tscr = "", tscr = "", TScy = "", tscy = "", TSHcy = "", tshcy = "", Tstrok = "", tstrok = "", twixt = "", twoheadleftarrow = "", twoheadrightarrow = "", Uacute$1 = "", uacute$1 = "", uarr = "", Uarr = "", uArr = "", Uarrocir = "", Ubrcy = "", ubrcy = "", Ubreve = "", ubreve = "", Ucirc$1 = "", ucirc$1 = "", Ucy = "", ucy = "", udarr = "", Udblac = "", udblac = "", udhar = "", ufisht = "", Ufr = "", ufr = "", Ugrave$1 = "", ugrave$1 = "", uHar = "", uharl = "", uharr = "", uhblk = "", ulcorn = "", ulcorner = "", ulcrop = "", ultri = "", Umacr = "", umacr = "", uml$1 = "", UnderBar = "_", UnderBrace = "", UnderBracket = "", UnderParenthesis = "", Union = "", UnionPlus = "", Uogon = "", uogon = "", Uopf = "", uopf = "", UpArrowBar = "", uparrow = "", UpArrow = "", Uparrow = "", UpArrowDownArrow = "", updownarrow = "", UpDownArrow = "", Updownarrow = "", UpEquilibrium = "", upharpoonleft = "", upharpoonright = "", uplus = "", UpperLeftArrow = "", UpperRightArrow = "", upsi = "", Upsi = "", upsih = "", Upsilon = "", upsilon = "", UpTeeArrow = "", UpTee = "", upuparrows = "", urcorn = "", urcorner = "", urcrop = "", Uring = "", uring = "", urtri = "", Uscr = "", uscr = "", utdot = "", Utilde = "", utilde = "", utri = "", utrif = "", uuarr = "", Uuml$1 = "", uuml$1 = "", uwangle = "", vangrt = "", varepsilon = "", varkappa = "", varnothing = "", varphi = "", varpi = "", varpropto = "", varr = "", vArr = "", varrho = "", varsigma = "", varsubsetneq = "", varsubsetneqq = "", varsupsetneq = "", varsupsetneqq = "", vartheta = "", vartriangleleft = "", vartriangleright = "", vBar = "", Vbar = "", vBarv = "", Vcy = "", vcy = "", vdash = "", vDash = "", Vdash = "", VDash = "", Vdashl = "", veebar = "", vee = "", Vee = "", veeeq = "", vellip = "", verbar = "|", Verbar = "", vert = "|", Vert = "", VerticalBar = "", VerticalLine = "|", VerticalSeparator = "", VerticalTilde = "", VeryThinSpace = "", Vfr = "", vfr = "", vltri = "", vnsub = "", vnsup = "", Vopf = "", vopf = "", vprop = "", vrtri = "", Vscr = "", vscr = "", vsubnE = "", vsubne = "", vsupnE = "", vsupne = "", Vvdash = "", vzigzag = "", Wcirc = "", wcirc = "", wedbar = "", wedge = "", Wedge = "", wedgeq = "", weierp = "", Wfr = "", wfr = "", Wopf = "", wopf = "", wp = "", wr = "", wreath = "", Wscr = "", wscr = "", xcap = "", xcirc = "", xcup = "", xdtri = "", Xfr = "", xfr = "", xharr = "", xhArr = "", Xi = "", xi = "", xlarr = "", xlArr = "", xmap = "", xnis = "", xodot = "", Xopf = "", xopf = "", xoplus = "", xotime = "", xrarr = "", xrArr = "", Xscr = "", xscr = "", xsqcup = "", xuplus = "", xutri = "", xvee = "", xwedge = "", Yacute$1 = "", yacute$1 = "", YAcy = "", yacy = "", Ycirc = "", ycirc = "", Ycy = "", ycy = "", yen$1 = "", Yfr = "", yfr = "", YIcy = "", yicy = "", Yopf = "", yopf = "", Yscr = "", yscr = "", YUcy = "", yucy = "", yuml$1 = "", Yuml = "", Zacute = "", zacute = "", Zcaron = "", zcaron = "", Zcy = "", zcy = "", Zdot = "", zdot = "", zeetrf = "", ZeroWidthSpace = "", Zeta = "", zeta = "", zfr = "", Zfr = "", ZHcy = "", zhcy = "", zigrarr = "", zopf = "", Zopf = "", Zscr = "", zscr = "", zwj = "", zwnj = "", require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet: bullet$1,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret: caret$1,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  in: "",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  Map: "",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
}, Aacute = "", aacute = "", Acirc = "", acirc = "", acute = "", AElig = "", aelig = "", Agrave = "", agrave = "", amp$1 = "&", AMP = "&", Aring = "", aring = "", Atilde = "", atilde = "", Auml = "", auml = "", brvbar = "", Ccedil = "", ccedil = "", cedil = "", cent = "", copy = "", COPY = "", curren = "", deg = "", divide = "", Eacute = "", eacute = "", Ecirc = "", ecirc = "", Egrave = "", egrave = "", ETH = "", eth = "", Euml = "", euml = "", frac12 = "", frac14 = "", frac34 = "", gt$1 = ">", GT = ">", Iacute = "", iacute = "", Icirc = "", icirc = "", iexcl = "", Igrave = "", igrave = "", iquest = "", Iuml = "", iuml = "", laquo = "", lt$1 = "<", LT = "<", macr = "", micro = "", middot = "", nbsp = "", not = "", Ntilde = "", ntilde = "", Oacute = "", oacute = "", Ocirc = "", ocirc = "", Ograve = "", ograve = "", ordf = "", ordm = "", Oslash = "", oslash = "", Otilde = "", otilde = "", Ouml = "", ouml = "", para = "", plusmn = "", pound = "", quot$1 = '"', QUOT = '"', raquo = "", reg = "", REG = "", sect = "", shy = "", sup1 = "", sup2 = "", sup3 = "", szlig = "", THORN = "", thorn = "", times = "", Uacute = "", uacute = "", Ucirc = "", ucirc = "", Ugrave = "", ugrave = "", uml = "", Uuml = "", uuml = "", Yacute = "", yacute = "", yen = "", yuml = "", require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
}, amp = "&", apos = "'", gt = ">", lt = "<", quot = '"', require$$0$1 = {
  amp,
  apos,
  gt,
  lt,
  quot
}, decode_codepoint = {}, require$$0$2 = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(cr) {
  return cr && cr.__esModule ? cr : { default: cr };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: !0 });
var decode_json_1 = __importDefault$2(require$$0$2), fromCodePoint$2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(cr) {
    var ar = "";
    return cr > 65535 && (cr -= 65536, ar += String.fromCharCode(cr >>> 10 & 1023 | 55296), cr = 56320 | cr & 1023), ar += String.fromCharCode(cr), ar;
  }
);
function decodeCodePoint(cr) {
  return cr >= 55296 && cr <= 57343 || cr > 1114111 ? "" : (cr in decode_json_1.default && (cr = decode_json_1.default[cr]), fromCodePoint$2(cr));
}
decode_codepoint.default = decodeCodePoint;
var __importDefault$1$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(cr) {
  return cr && cr.__esModule ? cr : { default: cr };
};
Object.defineProperty(decode, "__esModule", { value: !0 });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$1$1(require$$1$1), legacy_json_1 = __importDefault$1$1(require$$1), xml_json_1$1 = __importDefault$1$1(require$$0$1), decode_codepoint_1 = __importDefault$1$1(decode_codepoint), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(cr) {
  var ar = getReplacer(cr);
  return function(lr) {
    return String(lr).replace(strictEntityRe, ar);
  };
}
var sorter = function(cr, ar) {
  return cr < ar ? 1 : -1;
};
decode.decodeHTML = function() {
  for (var cr = Object.keys(legacy_json_1.default).sort(sorter), ar = Object.keys(entities_json_1$1.default).sort(sorter), lr = 0, ur = 0; lr < ar.length; lr++)
    cr[ur] === ar[lr] ? (ar[lr] += ";?", ur++) : ar[lr] += ";";
  var dr = new RegExp("&(?:" + ar.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), fr = getReplacer(entities_json_1$1.default);
  function gr(mr) {
    return mr.substr(-1) !== ";" && (mr += ";"), fr(mr);
  }
  return function(mr) {
    return String(mr).replace(dr, gr);
  };
}();
function getReplacer(cr) {
  return function(lr) {
    if (lr.charAt(1) === "#") {
      var ur = lr.charAt(2);
      return ur === "X" || ur === "x" ? decode_codepoint_1.default(parseInt(lr.substr(3), 16)) : decode_codepoint_1.default(parseInt(lr.substr(2), 10));
    }
    return cr[lr.slice(1, -1)] || lr;
  };
}
var encode = {}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(cr) {
  return cr && cr.__esModule ? cr : { default: cr };
};
Object.defineProperty(encode, "__esModule", { value: !0 });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault$3(require$$0$1), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$3(require$$1$1), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(cr) {
  return Object.keys(cr).sort().reduce(function(ar, lr) {
    return ar[cr[lr]] = "&" + lr + ";", ar;
  }, {});
}
function getInverseReplacer(cr) {
  for (var ar = [], lr = [], ur = 0, dr = Object.keys(cr); ur < dr.length; ur++) {
    var fr = dr[ur];
    fr.length === 1 ? ar.push("\\" + fr) : lr.push(fr);
  }
  ar.sort();
  for (var gr = 0; gr < ar.length - 1; gr++) {
    for (var mr = gr; mr < ar.length - 1 && ar[mr].charCodeAt(1) + 1 === ar[mr + 1].charCodeAt(1); )
      mr += 1;
    var vr = 1 + mr - gr;
    vr < 3 || ar.splice(gr, vr, ar[gr] + "-" + ar[mr]);
  }
  return lr.unshift("[" + ar.join("") + "]"), new RegExp(lr.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(cr) {
      return cr.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(cr) {
      return (cr.charCodeAt(0) - 55296) * 1024 + cr.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function singleCharReplacer(cr) {
  return "&#x" + (cr.length > 1 ? getCodePoint(cr) : cr.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(cr, ar) {
  return function(lr) {
    return lr.replace(ar, function(ur) {
      return cr[ur];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
function escape$3(cr) {
  return cr.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape$3;
function escapeUTF8(cr) {
  return cr.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(cr) {
  return function(ar) {
    return ar.replace(reEscapeChars, function(lr) {
      return cr[lr] || singleCharReplacer(lr);
    });
  };
}
(function(cr) {
  Object.defineProperty(cr, "__esModule", { value: !0 }), cr.decodeXMLStrict = cr.decodeHTML5Strict = cr.decodeHTML4Strict = cr.decodeHTML5 = cr.decodeHTML4 = cr.decodeHTMLStrict = cr.decodeHTML = cr.decodeXML = cr.encodeHTML5 = cr.encodeHTML4 = cr.escapeUTF8 = cr.escape = cr.encodeNonAsciiHTML = cr.encodeHTML = cr.encodeXML = cr.encode = cr.decodeStrict = cr.decode = void 0;
  var ar = decode, lr = encode;
  function ur(vr, yr) {
    return (!yr || yr <= 0 ? ar.decodeXML : ar.decodeHTML)(vr);
  }
  cr.decode = ur;
  function dr(vr, yr) {
    return (!yr || yr <= 0 ? ar.decodeXML : ar.decodeHTMLStrict)(vr);
  }
  cr.decodeStrict = dr;
  function fr(vr, yr) {
    return (!yr || yr <= 0 ? lr.encodeXML : lr.encodeHTML)(vr);
  }
  cr.encode = fr;
  var gr = encode;
  Object.defineProperty(cr, "encodeXML", { enumerable: !0, get: function() {
    return gr.encodeXML;
  } }), Object.defineProperty(cr, "encodeHTML", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } }), Object.defineProperty(cr, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return gr.encodeNonAsciiHTML;
  } }), Object.defineProperty(cr, "escape", { enumerable: !0, get: function() {
    return gr.escape;
  } }), Object.defineProperty(cr, "escapeUTF8", { enumerable: !0, get: function() {
    return gr.escapeUTF8;
  } }), Object.defineProperty(cr, "encodeHTML4", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } }), Object.defineProperty(cr, "encodeHTML5", { enumerable: !0, get: function() {
    return gr.encodeHTML;
  } });
  var mr = decode;
  Object.defineProperty(cr, "decodeXML", { enumerable: !0, get: function() {
    return mr.decodeXML;
  } }), Object.defineProperty(cr, "decodeHTML", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(cr, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(cr, "decodeHTML4", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(cr, "decodeHTML5", { enumerable: !0, get: function() {
    return mr.decodeHTML;
  } }), Object.defineProperty(cr, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(cr, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return mr.decodeHTMLStrict;
  } }), Object.defineProperty(cr, "decodeXMLStrict", { enumerable: !0, get: function() {
    return mr.decodeXML;
  } });
})(lib);
var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", C_BACKSLASH$1 = 92, reBackslashOrAmp = /[\\&]/, ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi"), XMLSPECIAL = '[&<>"]', reXmlSpecial = new RegExp(XMLSPECIAL, "g"), unescapeChar = function(cr) {
  return cr.charCodeAt(0) === C_BACKSLASH$1 ? cr.charAt(1) : lib.decodeHTML(cr);
};
function unescapeString(cr) {
  return reBackslashOrAmp.test(cr) ? cr.replace(reEntityOrEscapedChar, unescapeChar) : cr;
}
function normalizeURI(cr) {
  try {
    return encode_1(cr);
  } catch (ar) {
    return cr;
  }
}
function replaceUnsafeChar(cr) {
  switch (cr) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return cr;
  }
}
function escapeXml(cr) {
  return reXmlSpecial.test(cr) ? cr.replace(reXmlSpecial, replaceUnsafeChar) : cr;
}
function repeat(cr, ar) {
  for (var lr = [], ur = 0; ur < ar; ur++)
    lr.push(cr);
  return lr.join("");
}
function isEmpty(cr) {
  return cr ? !/[^ \t]+/.test(cr) : !0;
}
var NodeWalker = (
  /** @class */
  function() {
    function cr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return cr.prototype.next = function() {
      var ar = this.current, lr = this.entering;
      if (ar === null)
        return null;
      var ur = isContainer$1(ar);
      return lr && ur ? ar.firstChild ? (this.current = ar.firstChild, this.entering = !0) : this.entering = !1 : ar === this.root ? this.current = null : ar.next === null ? (this.current = ar.parent, this.entering = !1) : (this.current = ar.next, this.entering = !0), { entering: lr, node: ar };
    }, cr.prototype.resumeAt = function(ar, lr) {
      this.current = ar, this.entering = lr === !0;
    }, cr;
  }()
);
function isContainer$1(cr) {
  switch (cr.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
var lastNodeId = 1, nodeMap = {};
function getNodeById(cr) {
  return nodeMap[cr];
}
function removeNodeById(cr) {
  delete nodeMap[cr];
}
function removeAllNode() {
  nodeMap = {};
}
var Node$1 = (
  /** @class */
  function() {
    function cr(ar, lr) {
      this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, ar === "document" ? this.id = -1 : this.id = lastNodeId++, this.type = ar, this.sourcepos = lr, nodeMap[this.id] = this;
    }
    return cr.prototype.isContainer = function() {
      return isContainer$1(this);
    }, cr.prototype.unlink = function() {
      this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
    }, cr.prototype.replaceWith = function(ar) {
      this.insertBefore(ar), this.unlink();
    }, cr.prototype.insertAfter = function(ar) {
      ar.unlink(), ar.next = this.next, ar.next && (ar.next.prev = ar), ar.prev = this, this.next = ar, this.parent && (ar.parent = this.parent, ar.next || (ar.parent.lastChild = ar));
    }, cr.prototype.insertBefore = function(ar) {
      ar.unlink(), ar.prev = this.prev, ar.prev && (ar.prev.next = ar), ar.next = this, this.prev = ar, ar.parent = this.parent, ar.prev || (ar.parent.firstChild = ar);
    }, cr.prototype.appendChild = function(ar) {
      ar.unlink(), ar.parent = this, this.lastChild ? (this.lastChild.next = ar, ar.prev = this.lastChild, this.lastChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, cr.prototype.prependChild = function(ar) {
      ar.unlink(), ar.parent = this, this.firstChild ? (this.firstChild.prev = ar, ar.next = this.firstChild, this.firstChild = ar) : (this.firstChild = ar, this.lastChild = ar);
    }, cr.prototype.walker = function() {
      return new NodeWalker(this);
    }, cr;
  }()
), BlockNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar(lr, ur) {
      var dr = cr.call(this, lr, ur) || this;
      return dr.open = !0, dr.lineOffsets = null, dr.stringContent = null, dr.lastLineBlank = !1, dr.lastLineChecked = !1, dr.type = lr, dr;
    }
    return ar;
  }(Node$1)
), ListNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.listData = null, lr;
    }
    return ar;
  }(BlockNode)
), HeadingNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.level = 0, lr.headingType = "atx", lr;
    }
    return ar;
  }(BlockNode)
), CodeBlockNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.isFenced = !1, lr.fenceChar = null, lr.fenceLength = 0, lr.fenceOffset = -1, lr.info = null, lr.infoPadding = 0, lr;
    }
    return ar;
  }(BlockNode)
), TableNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.columns = [], lr;
    }
    return ar;
  }(BlockNode)
), TableCellNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.startIdx = 0, lr.endIdx = 0, lr.paddingLeft = 0, lr.paddingRight = 0, lr.ignored = !1, lr;
    }
    return ar;
  }(BlockNode)
), RefDefNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.title = "", lr.dest = "", lr.label = "", lr;
    }
    return ar;
  }(BlockNode)
), CustomBlockNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.syntaxLength = 0, lr.offset = -1, lr.info = "", lr;
    }
    return ar;
  }(BlockNode)
), HtmlBlockNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.htmlBlockType = -1, lr;
    }
    return ar;
  }(BlockNode)
), LinkNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.destination = null, lr.title = null, lr.extendedAutolink = !1, lr;
    }
    return ar;
  }(Node$1)
), CodeNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.tickCount = 0, lr;
    }
    return ar;
  }(Node$1)
), CustomInlineNode = (
  /** @class */
  function(cr) {
    __extends(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.info = "", lr;
    }
    return ar;
  }(Node$1)
);
function createNode$1(cr, ar) {
  switch (cr) {
    case "heading":
      return new HeadingNode(cr, ar);
    case "list":
    case "item":
      return new ListNode(cr, ar);
    case "link":
    case "image":
      return new LinkNode(cr, ar);
    case "codeBlock":
      return new CodeBlockNode(cr, ar);
    case "htmlBlock":
      return new HtmlBlockNode(cr, ar);
    case "table":
      return new TableNode(cr, ar);
    case "tableCell":
      return new TableCellNode(cr, ar);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new BlockNode(cr, ar);
    case "code":
      return new CodeNode(cr, ar);
    case "refDef":
      return new RefDefNode(cr, ar);
    case "customBlock":
      return new CustomBlockNode(cr, ar);
    case "customInline":
      return new CustomInlineNode(cr, ar);
    default:
      return new Node$1(cr, ar);
  }
}
function isCodeBlock(cr) {
  return cr.type === "codeBlock";
}
function isHtmlBlock(cr) {
  return cr.type === "htmlBlock";
}
function isHeading(cr) {
  return cr.type === "heading";
}
function isList(cr) {
  return cr.type === "list";
}
function isTable(cr) {
  return cr.type === "table";
}
function isRefDef(cr) {
  return cr.type === "refDef";
}
function isCustomBlock(cr) {
  return cr.type === "customBlock";
}
function isCustomInline(cr) {
  return cr.type === "customInline";
}
function text$1(cr, ar) {
  var lr = createNode$1("text", ar);
  return lr.literal = cr, lr;
}
var TAGNAME = "[A-Za-z][A-Za-z0-9-]*", ATTRIBUTENAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*", UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+", SINGLEQUOTEDVALUE = "'[^']*'", DOUBLEQUOTEDVALUE = '"[^"]*"', ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")", ATTRIBUTEVALUESPEC = "(?:\\s*=\\s*" + ATTRIBUTEVALUE + ")", ATTRIBUTE = "(?:\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)", OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*\\s*/?>", CLOSETAG = "</" + TAGNAME + "\\s*[>]", HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", PROCESSINGINSTRUCTION = "[<][?].*?[?][>]", DECLARATION = "<![A-Z]+\\s+[^>]*>", CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")", reHtmlTag = new RegExp("^" + HTMLTAG, "i");
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var fromCodePoint;
if (String.fromCodePoint)
  fromCodePoint = function(cr) {
    try {
      return String.fromCodePoint(cr);
    } catch (ar) {
      if (ar instanceof RangeError)
        return String.fromCharCode(65533);
      throw ar;
    }
  };
else {
  var stringFromCharCode_1 = String.fromCharCode, floor_1 = Math.floor;
  fromCodePoint = function() {
    for (var cr = [], ar = 0; ar < arguments.length; ar++)
      cr[ar] = arguments[ar];
    var lr = 16384, ur = [], dr, fr, gr = -1, mr = cr.length;
    if (!mr)
      return "";
    for (var vr = ""; ++gr < mr; ) {
      var yr = Number(cr[gr]);
      if (!isFinite(yr) || // `NaN`, `+Infinity`, or `-Infinity`
      yr < 0 || // not a valid Unicode code point
      yr > 1114111 || // not a valid Unicode code point
      floor_1(yr) !== yr)
        return String.fromCharCode(65533);
      yr <= 65535 ? ur.push(yr) : (yr -= 65536, dr = (yr >> 10) + 55296, fr = yr % 1024 + 56320, ur.push(dr, fr)), (gr + 1 === mr || ur.length > lr) && (vr += stringFromCharCode_1.apply(void 0, ur), ur.length = 0);
    }
    return vr;
  };
}
var fromCodePoint$1 = fromCodePoint, DOMAIN = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", PATH = "[^<\\s]*[^<?!.,:*_?~\\s]", EMAIL = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function trimUnmatchedTrailingParens(cr) {
  var ar = /\)+$/.exec(cr);
  if (ar) {
    for (var lr = 0, ur = 0, dr = cr; ur < dr.length; ur++) {
      var fr = dr[ur];
      fr === "(" ? lr < 0 ? lr = 1 : lr += 1 : fr === ")" && (lr -= 1);
    }
    if (lr < 0) {
      var gr = Math.min(-lr, ar[0].length);
      return cr.substring(0, cr.length - gr);
    }
  }
  return cr;
}
function trimTrailingEntity(cr) {
  return cr.replace(/&[A-Za-z0-9]+;$/, "");
}
function parseEmailLink(cr) {
  for (var ar = new RegExp(EMAIL, "g"), lr = [], ur; ur = ar.exec(cr); ) {
    var dr = ur[0];
    /[_-]+$/.test(dr) || lr.push({
      text: dr,
      range: [ur.index, ur.index + dr.length - 1],
      url: "mailto:" + dr
    });
  }
  return lr;
}
function parseUrlLink(cr) {
  for (var ar = new RegExp("(www|https?://)." + DOMAIN + PATH, "g"), lr = [], ur; ur = ar.exec(cr); ) {
    var dr = trimTrailingEntity(trimUnmatchedTrailingParens(ur[0])), fr = ur[1] === "www" ? "http://" : "";
    lr.push({
      text: dr,
      range: [ur.index, ur.index + dr.length - 1],
      url: "" + fr + dr
    });
  }
  return lr;
}
function baseAutolinkParser(cr) {
  return __spreadArray(__spreadArray([], parseUrlLink(cr)), parseEmailLink(cr)).sort(function(ar, lr) {
    return ar.range[0] - lr.range[0];
  });
}
function convertExtAutoLinks(cr, ar) {
  typeof ar == "boolean" && (ar = baseAutolinkParser);
  for (var lr, ur = function() {
    var dr = lr.entering, fr = lr.node;
    if (dr && fr.type === "text" && fr.parent.type !== "link") {
      var gr = fr.literal, mr = ar(gr);
      if (!mr || !mr.length)
        return "continue";
      for (var vr = 0, yr = fr.sourcepos[0], _r = yr[0], kr = yr[1], xr = function(Dr, Hr) {
        return [
          [_r, kr + Dr],
          [_r, kr + Hr]
        ];
      }, Ar = [], Er = 0, Cr = mr; Er < Cr.length; Er++) {
        var Tr = Cr[Er], Sr = Tr.range, Lr = Tr.url, Ir = Tr.text;
        Sr[0] > vr && Ar.push(text$1(gr.substring(vr, Sr[0]), xr(vr, Sr[0] - 1)));
        var Nr = createNode$1("link", xr.apply(void 0, Sr));
        Nr.appendChild(text$1(Ir, xr.apply(void 0, Sr))), Nr.destination = Lr, Nr.extendedAutolink = !0, Ar.push(Nr), vr = Sr[1] + 1;
      }
      vr < gr.length && Ar.push(text$1(gr.substring(vr), xr(vr, gr.length - 1)));
      for (var Rr = 0, Mr = Ar; Rr < Mr.length; Rr++) {
        var Br = Mr[Rr];
        fr.insertBefore(Br);
      }
      fr.unlink();
    }
  }; lr = cr.next(); )
    ur();
}
function last(cr) {
  return cr[cr.length - 1];
}
function normalizeReference(cr) {
  return cr.slice(1, cr.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function iterateObject(cr, ar) {
  Object.keys(cr).forEach(function(lr) {
    ar(lr, cr[lr]);
  });
}
function omit(cr) {
  for (var ar = [], lr = 1; lr < arguments.length; lr++)
    ar[lr - 1] = arguments[lr];
  var ur = __assign({}, cr);
  return ar.forEach(function(dr) {
    delete ur[dr];
  }), ur;
}
function isEmptyObj(cr) {
  return !Object.keys(cr).length;
}
function clearObj(cr) {
  Object.keys(cr).forEach(function(ar) {
    delete cr[ar];
  });
}
var C_NEWLINE = 10, C_ASTERISK = 42, C_UNDERSCORE = 95, C_BACKTICK = 96, C_OPEN_BRACKET$1 = 91, C_CLOSE_BRACKET = 93, C_TILDE = 126, C_LESSTHAN$1 = 60, C_BANG = 33, C_BACKSLASH = 92, C_AMPERSAND = 38, C_OPEN_PAREN = 40, C_CLOSE_PAREN = 41, C_COLON = 58, C_SINGLEQUOTE = 39, C_DOUBLEQUOTE = 34, C_DOLLAR = 36, ESCAPED_CHAR = "\\\\" + ESCAPABLE, rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), reLinkTitle = new RegExp('^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"|' + ("'(" + ESCAPED_CHAR + "|[^'\\x00])*'") + "|" + ("\\((" + ESCAPED_CHAR + "|[^()\\x00])*\\))")), reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, reEscapable = new RegExp("^" + ESCAPABLE), reEntityHere = new RegExp("^" + ENTITY, "i"), reTicks = /`+/, reTicksHere = /^`+/, reEllipses = /\.\.\./g, reDash = /--+/g, reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, reSpnl = /^ *(?:\n *)?/, reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/, reUnicodeWhitespaceChar = /^\s/, reFinalSpace = / *$/, reInitialSpace = /^ */, reSpaceAtEndOfLine = /^ *(?:\n|$)/, reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, reMain = /^[^\n`\[\]\\!<&*_'"~$]+/m, InlineParser = (
  /** @class */
  function() {
    function cr(ar) {
      this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = ar;
    }
    return cr.prototype.sourcepos = function(ar, lr) {
      var ur = this.linePosOffset + this.lineOffsets[this.lineIdx], dr = this.lineStartNum + this.lineIdx, fr = [dr, ar + ur];
      return typeof lr == "number" ? [fr, [dr, lr + ur]] : fr;
    }, cr.prototype.nextLine = function() {
      this.lineIdx += 1, this.linePosOffset = -this.pos;
    }, cr.prototype.match = function(ar) {
      var lr = ar.exec(this.subject.slice(this.pos));
      return lr === null ? null : (this.pos += lr.index + lr[0].length, lr[0]);
    }, cr.prototype.peek = function() {
      return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
    }, cr.prototype.spnl = function() {
      return this.match(reSpnl), !0;
    }, cr.prototype.parseBackticks = function(ar) {
      var lr = this.pos + 1, ur = this.match(reTicksHere);
      if (ur === null)
        return !1;
      for (var dr = this.pos, fr; (fr = this.match(reTicks)) !== null; )
        if (fr === ur) {
          var gr = this.subject.slice(dr, this.pos - ur.length), mr = this.sourcepos(lr, this.pos), vr = gr.split(`
`);
          if (vr.length > 1) {
            var yr = last(vr);
            this.lineIdx += vr.length - 1, this.linePosOffset = -(this.pos - yr.length - ur.length), mr[1] = this.sourcepos(this.pos), gr = vr.join(" ");
          }
          var _r = createNode$1("code", mr);
          return gr.length > 0 && gr.match(/[^ ]/) !== null && gr[0] == " " && gr[gr.length - 1] == " " ? _r.literal = gr.slice(1, gr.length - 1) : _r.literal = gr, _r.tickCount = ur.length, ar.appendChild(_r), !0;
        }
      return this.pos = dr, ar.appendChild(text$1(ur, this.sourcepos(lr, this.pos - 1))), !0;
    }, cr.prototype.parseBackslash = function(ar) {
      var lr = this.subject, ur;
      this.pos += 1;
      var dr = this.pos;
      return this.peek() === C_NEWLINE ? (this.pos += 1, ur = createNode$1("linebreak", this.sourcepos(this.pos - 1, this.pos)), ar.appendChild(ur), this.nextLine()) : reEscapable.test(lr.charAt(this.pos)) ? (ar.appendChild(text$1(lr.charAt(this.pos), this.sourcepos(dr, this.pos))), this.pos += 1) : ar.appendChild(text$1("\\", this.sourcepos(dr, dr))), !0;
    }, cr.prototype.parseAutolink = function(ar) {
      var lr, ur, dr, fr = this.pos + 1;
      return (lr = this.match(reEmailAutolink)) ? (ur = lr.slice(1, lr.length - 1), dr = createNode$1("link", this.sourcepos(fr, this.pos)), dr.destination = normalizeURI("mailto:" + ur), dr.title = "", dr.appendChild(text$1(ur, this.sourcepos(fr + 1, this.pos - 1))), ar.appendChild(dr), !0) : (lr = this.match(reAutolink)) ? (ur = lr.slice(1, lr.length - 1), dr = createNode$1("link", this.sourcepos(fr, this.pos)), dr.destination = normalizeURI(ur), dr.title = "", dr.appendChild(text$1(ur, this.sourcepos(fr + 1, this.pos - 1))), ar.appendChild(dr), !0) : !1;
    }, cr.prototype.parseHtmlTag = function(ar) {
      var lr = this.pos + 1, ur = this.match(reHtmlTag);
      if (ur === null)
        return !1;
      var dr = createNode$1("htmlInline", this.sourcepos(lr, this.pos));
      return dr.literal = ur, ar.appendChild(dr), !0;
    }, cr.prototype.scanDelims = function(ar) {
      var lr = 0, ur = this.pos;
      if (ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE)
        lr++, this.pos++;
      else
        for (; this.peek() === ar; )
          lr++, this.pos++;
      if (lr === 0 || lr < 2 && (ar === C_TILDE || ar === C_DOLLAR))
        return this.pos = ur, null;
      var dr = ur === 0 ? `
` : this.subject.charAt(ur - 1), fr = this.peek(), gr;
      fr === -1 ? gr = `
` : gr = fromCodePoint$1(fr);
      var mr = reUnicodeWhitespaceChar.test(gr), vr = rePunctuation.test(gr), yr = reUnicodeWhitespaceChar.test(dr), _r = rePunctuation.test(dr), kr = !mr && (!vr || yr || _r), xr = !yr && (!_r || mr || vr), Ar, Er;
      return ar === C_UNDERSCORE ? (Ar = kr && (!xr || _r), Er = xr && (!kr || vr)) : ar === C_SINGLEQUOTE || ar === C_DOUBLEQUOTE ? (Ar = kr && !xr, Er = xr) : ar === C_DOLLAR ? (Ar = !mr, Er = !yr) : (Ar = kr, Er = xr), this.pos = ur, { numdelims: lr, canOpen: Ar, canClose: Er };
    }, cr.prototype.handleDelim = function(ar, lr) {
      var ur = this.scanDelims(ar);
      if (!ur)
        return !1;
      var dr = ur.numdelims, fr = this.pos + 1, gr;
      this.pos += dr, ar === C_SINGLEQUOTE ? gr = "" : ar === C_DOUBLEQUOTE ? gr = "" : gr = this.subject.slice(fr - 1, this.pos);
      var mr = text$1(gr, this.sourcepos(fr, this.pos));
      return lr.appendChild(mr), (ur.canOpen || ur.canClose) && (this.options.smart || ar !== C_SINGLEQUOTE && ar !== C_DOUBLEQUOTE) && (this.delimiters = {
        cc: ar,
        numdelims: dr,
        origdelims: dr,
        node: mr,
        previous: this.delimiters,
        next: null,
        canOpen: ur.canOpen,
        canClose: ur.canClose
      }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
    }, cr.prototype.removeDelimiter = function(ar) {
      ar.previous !== null && (ar.previous.next = ar.next), ar.next === null ? this.delimiters = ar.previous : ar.next.previous = ar.previous;
    }, cr.prototype.removeDelimitersBetween = function(ar, lr) {
      ar.next !== lr && (ar.next = lr, lr.previous = ar);
    }, cr.prototype.processEmphasis = function(ar) {
      var lr, ur, dr, fr, gr, mr, vr, yr = !1, _r = (lr = {}, lr[C_UNDERSCORE] = [ar, ar, ar], lr[C_ASTERISK] = [ar, ar, ar], lr[C_SINGLEQUOTE] = [ar], lr[C_DOUBLEQUOTE] = [ar], lr[C_TILDE] = [ar], lr[C_DOLLAR] = [ar], lr);
      for (dr = this.delimiters; dr !== null && dr.previous !== ar; )
        dr = dr.previous;
      for (; dr !== null; ) {
        var kr = dr.cc, xr = kr === C_UNDERSCORE || kr === C_ASTERISK;
        if (!dr.canClose)
          dr = dr.next;
        else {
          for (ur = dr.previous, vr = !1; ur !== null && ur !== ar && ur !== _r[kr][xr ? dr.origdelims % 3 : 0]; ) {
            if (yr = xr && (dr.canOpen || ur.canClose) && dr.origdelims % 3 !== 0 && (ur.origdelims + dr.origdelims) % 3 === 0, ur.cc === dr.cc && ur.canOpen && !yr) {
              vr = !0;
              break;
            }
            ur = ur.previous;
          }
          if (fr = dr, xr || kr === C_TILDE || kr === C_DOLLAR) {
            if (!vr)
              dr = dr.next;
            else if (ur) {
              var Ar = dr.numdelims >= 2 && ur.numdelims >= 2 ? 2 : 1, Er = xr ? 0 : 1;
              gr = ur.node, mr = dr.node;
              var Cr = xr ? Ar === 1 ? "emph" : "strong" : "strike";
              kr === C_DOLLAR && (Cr = "customInline");
              var Tr = createNode$1(Cr), Sr = gr.sourcepos[1], Lr = mr.sourcepos[0];
              Tr.sourcepos = [
                [Sr[0], Sr[1] - Ar + 1],
                [Lr[0], Lr[1] + Ar - 1]
              ], gr.sourcepos[1][1] -= Ar, mr.sourcepos[0][1] += Ar, gr.literal = gr.literal.slice(Ar), mr.literal = mr.literal.slice(Ar), ur.numdelims -= Ar, dr.numdelims -= Ar;
              for (var Ir = gr.next, Nr = void 0; Ir && Ir !== mr; )
                Nr = Ir.next, Ir.unlink(), Tr.appendChild(Ir), Ir = Nr;
              if (kr === C_DOLLAR) {
                var Rr = Tr.firstChild, Mr = Rr.literal || "", Br = Mr.split(/\s/)[0];
                Tr.info = Br, Mr.length <= Br.length ? Rr.unlink() : (Rr.sourcepos[0][1] += Br.length, Rr.literal = Mr.replace(Br + " ", ""));
              }
              if (gr.insertAfter(Tr), this.removeDelimitersBetween(ur, dr), ur.numdelims <= Er && (ur.numdelims === 0 && gr.unlink(), this.removeDelimiter(ur)), dr.numdelims <= Er) {
                dr.numdelims === 0 && mr.unlink();
                var Dr = dr.next;
                this.removeDelimiter(dr), dr = Dr;
              }
            }
          } else
            kr === C_SINGLEQUOTE ? (dr.node.literal = "", vr && (ur.node.literal = ""), dr = dr.next) : kr === C_DOUBLEQUOTE && (dr.node.literal = "", vr && (ur.node.literal = ""), dr = dr.next);
          vr || (_r[kr][xr ? fr.origdelims % 3 : 0] = fr.previous, fr.canOpen || this.removeDelimiter(fr));
        }
      }
      for (; this.delimiters !== null && this.delimiters !== ar; )
        this.removeDelimiter(this.delimiters);
    }, cr.prototype.parseLinkTitle = function() {
      var ar = this.match(reLinkTitle);
      return ar === null ? null : unescapeString(ar.substr(1, ar.length - 2));
    }, cr.prototype.parseLinkDestination = function() {
      var ar = this.match(reLinkDestinationBraces);
      if (ar === null) {
        if (this.peek() === C_LESSTHAN$1)
          return null;
        for (var lr = this.pos, ur = 0, dr = void 0; (dr = this.peek()) !== -1; )
          if (dr === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1)))
            this.pos += 1, this.peek() !== -1 && (this.pos += 1);
          else if (dr === C_OPEN_PAREN)
            this.pos += 1, ur += 1;
          else if (dr === C_CLOSE_PAREN) {
            if (ur < 1)
              break;
            this.pos += 1, ur -= 1;
          } else {
            if (reWhitespaceChar.exec(fromCodePoint$1(dr)) !== null)
              break;
            this.pos += 1;
          }
        return this.pos === lr && dr !== C_CLOSE_PAREN || ur !== 0 ? null : (ar = this.subject.substr(lr, this.pos - lr), normalizeURI(unescapeString(ar)));
      }
      return normalizeURI(unescapeString(ar.substr(1, ar.length - 2)));
    }, cr.prototype.parseLinkLabel = function() {
      var ar = this.match(reLinkLabel);
      return ar === null || ar.length > 1001 ? 0 : ar.length;
    }, cr.prototype.parseOpenBracket = function(ar) {
      var lr = this.pos;
      this.pos += 1;
      var ur = text$1("[", this.sourcepos(this.pos, this.pos));
      return ar.appendChild(ur), this.addBracket(ur, lr, !1), !0;
    }, cr.prototype.parseBang = function(ar) {
      var lr = this.pos;
      if (this.pos += 1, this.peek() === C_OPEN_BRACKET$1) {
        this.pos += 1;
        var ur = text$1("![", this.sourcepos(this.pos - 1, this.pos));
        ar.appendChild(ur), this.addBracket(ur, lr + 1, !0);
      } else {
        var ur = text$1("!", this.sourcepos(this.pos, this.pos));
        ar.appendChild(ur);
      }
      return !0;
    }, cr.prototype.parseCloseBracket = function(ar) {
      var lr = null, ur = null, dr = !1;
      this.pos += 1;
      var fr = this.pos, gr = this.brackets;
      if (gr === null)
        return ar.appendChild(text$1("]", this.sourcepos(fr, fr))), !0;
      if (!gr.active)
        return ar.appendChild(text$1("]", this.sourcepos(fr, fr))), this.removeBracket(), !0;
      var mr = gr.image, vr = this.pos;
      this.peek() === C_OPEN_PAREN && (this.pos++, this.spnl() && (lr = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
      (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) && (ur = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === C_CLOSE_PAREN ? (this.pos += 1, dr = !0) : this.pos = vr);
      var yr = "";
      if (!dr) {
        var _r = this.pos, kr = this.parseLinkLabel();
        if (kr > 2 ? yr = this.subject.slice(_r, _r + kr) : gr.bracketAfter || (yr = this.subject.slice(gr.index, fr)), kr === 0 && (this.pos = vr), yr) {
          yr = normalizeReference(yr);
          var xr = this.refMap[yr];
          xr && (lr = xr.destination, ur = xr.title, dr = !0);
        }
      }
      if (dr) {
        var Ar = createNode$1(mr ? "image" : "link");
        Ar.destination = lr, Ar.title = ur || "", Ar.sourcepos = [gr.startpos, this.sourcepos(this.pos)];
        for (var Er = gr.node.next, Cr = void 0; Er; )
          Cr = Er.next, Er.unlink(), Ar.appendChild(Er), Er = Cr;
        if (ar.appendChild(Ar), this.processEmphasis(gr.previousDelimiter), this.removeBracket(), gr.node.unlink(), !mr)
          for (gr = this.brackets; gr !== null; )
            gr.image || (gr.active = !1), gr = gr.previous;
        return this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: yr }), !0;
      }
      return this.removeBracket(), this.pos = fr, ar.appendChild(text$1("]", this.sourcepos(fr, fr))), this.options.referenceDefinition && (this.refLinkCandidateMap[ar.id] = { node: ar, refLabel: yr }), !0;
    }, cr.prototype.addBracket = function(ar, lr, ur) {
      this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
        node: ar,
        startpos: this.sourcepos(lr + (ur ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: lr,
        image: ur,
        active: !0
      };
    }, cr.prototype.removeBracket = function() {
      this.brackets && (this.brackets = this.brackets.previous);
    }, cr.prototype.parseEntity = function(ar) {
      var lr, ur = this.pos + 1;
      return (lr = this.match(reEntityHere)) ? (ar.appendChild(text$1(lib.decodeHTML(lr), this.sourcepos(ur, this.pos))), !0) : !1;
    }, cr.prototype.parseString = function(ar) {
      var lr, ur = this.pos + 1;
      if (lr = this.match(reMain)) {
        if (this.options.smart) {
          var dr = lr.replace(reEllipses, "").replace(reDash, function(gr) {
            var mr = 0, vr = 0;
            return gr.length % 3 === 0 ? vr = gr.length / 3 : gr.length % 2 === 0 ? mr = gr.length / 2 : gr.length % 3 === 2 ? (mr = 1, vr = (gr.length - 2) / 3) : (mr = 2, vr = (gr.length - 4) / 3), repeat("", vr) + repeat("", mr);
          });
          ar.appendChild(text$1(dr, this.sourcepos(ur, this.pos)));
        } else {
          var fr = text$1(lr, this.sourcepos(ur, this.pos));
          ar.appendChild(fr);
        }
        return !0;
      }
      return !1;
    }, cr.prototype.parseNewline = function(ar) {
      this.pos += 1;
      var lr = ar.lastChild;
      if (lr && lr.type === "text" && lr.literal[lr.literal.length - 1] === " ") {
        var ur = lr.literal[lr.literal.length - 2] === " ", dr = lr.literal.length;
        lr.literal = lr.literal.replace(reFinalSpace, "");
        var fr = dr - lr.literal.length;
        lr.sourcepos[1][1] -= fr, ar.appendChild(createNode$1(ur ? "linebreak" : "softbreak", this.sourcepos(this.pos - fr, this.pos)));
      } else
        ar.appendChild(createNode$1("softbreak", this.sourcepos(this.pos, this.pos)));
      return this.nextLine(), this.match(reInitialSpace), !0;
    }, cr.prototype.parseReference = function(ar, lr) {
      if (!this.options.referenceDefinition)
        return 0;
      this.subject = ar.stringContent, this.pos = 0;
      var ur = null, dr = this.pos, fr = this.parseLinkLabel();
      if (fr === 0)
        return 0;
      var gr = this.subject.substr(0, fr);
      if (this.peek() === C_COLON)
        this.pos++;
      else
        return this.pos = dr, 0;
      this.spnl();
      var mr = this.parseLinkDestination();
      if (mr === null)
        return this.pos = dr, 0;
      var vr = this.pos;
      this.spnl(), this.pos !== vr && (ur = this.parseLinkTitle()), ur === null && (ur = "", this.pos = vr);
      var yr = !0;
      if (this.match(reSpaceAtEndOfLine) === null && (ur === "" ? yr = !1 : (ur = "", this.pos = vr, yr = this.match(reSpaceAtEndOfLine) !== null)), !yr)
        return this.pos = dr, 0;
      var _r = normalizeReference(gr);
      if (_r === "")
        return this.pos = dr, 0;
      var kr = this.getReferenceDefSourcepos(ar);
      ar.sourcepos[0][0] = kr[1][0] + 1;
      var xr = createNode$1("refDef", kr);
      return xr.title = ur, xr.dest = mr, xr.label = _r, ar.insertBefore(xr), lr[_r] ? this.refDefCandidateMap[xr.id] = xr : lr[_r] = createRefDefState(xr), this.pos - dr;
    }, cr.prototype.mergeTextNodes = function(ar) {
      for (var lr, ur = []; lr = ar.next(); ) {
        var dr = lr.entering, fr = lr.node;
        if (dr && fr.type === "text")
          ur.push(fr);
        else if (ur.length === 1)
          ur = [];
        else if (ur.length > 1) {
          var gr = ur[0], mr = ur[ur.length - 1];
          gr.sourcepos && mr.sourcepos && (gr.sourcepos[1] = mr.sourcepos[1]), gr.next = mr.next, gr.next && (gr.next.prev = gr);
          for (var vr = 1; vr < ur.length; vr += 1)
            gr.literal += ur[vr].literal, ur[vr].unlink();
          ur = [];
        }
      }
    }, cr.prototype.getReferenceDefSourcepos = function(ar) {
      for (var lr = ar.stringContent.split(/\n|\r\n/), ur = !1, dr = 0, fr = { line: 0, ch: 0 }, gr = 0; gr < lr.length; gr += 1) {
        var mr = lr[gr];
        if (reWhitespaceChar.test(mr))
          break;
        if (/\:/.test(mr) && dr === 0) {
          if (ur)
            break;
          var vr = mr.indexOf(":") === mr.length - 1 ? gr + 1 : gr;
          fr = { line: vr, ch: lr[vr].length }, ur = !0;
        }
        var yr = mr.match(/'|"/g);
        if (yr && (dr += yr.length), dr === 2) {
          fr = { line: gr, ch: mr.length };
          break;
        }
      }
      return [
        [ar.sourcepos[0][0], ar.sourcepos[0][1]],
        [ar.sourcepos[0][0] + fr.line, fr.ch]
      ];
    }, cr.prototype.parseInline = function(ar) {
      var lr, ur = !1, dr = this.peek();
      if (dr === -1)
        return !1;
      switch (dr) {
        case C_NEWLINE:
          ur = this.parseNewline(ar);
          break;
        case C_BACKSLASH:
          ur = this.parseBackslash(ar);
          break;
        case C_BACKTICK:
          ur = this.parseBackticks(ar);
          break;
        case C_ASTERISK:
        case C_UNDERSCORE:
        case C_TILDE:
        case C_DOLLAR:
          ur = this.handleDelim(dr, ar);
          break;
        case C_SINGLEQUOTE:
        case C_DOUBLEQUOTE:
          ur = !!(!((lr = this.options) === null || lr === void 0) && lr.smart) && this.handleDelim(dr, ar);
          break;
        case C_OPEN_BRACKET$1:
          ur = this.parseOpenBracket(ar);
          break;
        case C_BANG:
          ur = this.parseBang(ar);
          break;
        case C_CLOSE_BRACKET:
          ur = this.parseCloseBracket(ar);
          break;
        case C_LESSTHAN$1:
          ur = this.parseAutolink(ar) || this.parseHtmlTag(ar);
          break;
        case C_AMPERSAND:
          ar.disabledEntityParse || (ur = this.parseEntity(ar));
          break;
        default:
          ur = this.parseString(ar);
          break;
      }
      return ur || (this.pos += 1, ar.appendChild(text$1(fromCodePoint$1(dr), this.sourcepos(this.pos, this.pos + 1)))), !0;
    }, cr.prototype.parse = function(ar) {
      for (this.subject = ar.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = ar.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = ar.sourcepos[0][0], isHeading(ar) && (this.lineOffsets[0] += ar.level + 1); this.parseInline(ar); )
        ;
      ar.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(ar.walker());
      var lr = this.options, ur = lr.extendedAutolinks, dr = lr.customParser;
      if (ur && convertExtAutoLinks(ar.walker(), ur), dr && ar.firstChild)
        for (var fr, gr = ar.firstChild.walker(); fr = gr.next(); ) {
          var mr = fr.node, vr = fr.entering;
          dr[mr.type] && dr[mr.type](mr, { entering: vr, options: this.options });
        }
    }, cr;
  }()
), reTaskListItemMarker = /^\[([ \txX])\][ \t]+/;
function taskListItemFinalize(cr, ar) {
  if (ar.firstChild && ar.firstChild.type === "paragraph") {
    var lr = ar.firstChild, ur = lr.stringContent.match(reTaskListItemMarker);
    if (ur) {
      var dr = ur[0].length;
      lr.stringContent = lr.stringContent.substring(dr - 1), lr.sourcepos[0][1] += dr, lr.lineOffsets[0] += dr, ar.listData.task = !0, ar.listData.checked = /[xX]/.test(ur[1]);
    }
  }
}
var table = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr === "tableHead" || cr === "tableBody";
  },
  acceptsLines: !1
}, tableBody$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr === "tableRow";
  },
  acceptsLines: !1
}, tableHead$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr === "tableRow" || cr === "tableDelimRow";
  },
  acceptsLines: !1
}, tableDelimRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr === "tableDelimCell";
  },
  acceptsLines: !1
}, tableDelimCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, tableRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr === "tableCell";
  },
  acceptsLines: !1
}, tableCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, CODE_INDENT = 4, C_TAB = 9, C_GREATERTHAN = 62, C_LESSTHAN = 60, C_SPACE = 32, C_OPEN_BRACKET = 91, reNonSpace = /[^ \t\f\v\r\n]/, reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
function endsWithBlankLine(cr) {
  for (var ar = cr; ar; ) {
    if (ar.lastLineBlank)
      return !0;
    var lr = ar.type;
    if (!ar.lastLineChecked && (lr === "list" || lr === "item"))
      ar.lastLineChecked = !0, ar = ar.lastChild;
    else {
      ar.lastLineChecked = !0;
      break;
    }
  }
  return !1;
}
function peek(cr, ar) {
  return ar < cr.length ? cr.charCodeAt(ar) : -1;
}
function isBlank(cr) {
  return !reNonSpace.test(cr);
}
function isSpaceOrTab(cr) {
  return cr === C_SPACE || cr === C_TAB;
}
var reClosingCustomBlock = /^\$\$$/, customBlock$1 = {
  continue: function(cr, ar) {
    var lr = cr.currentLine, ur = lr.match(reClosingCustomBlock);
    if (ur)
      return cr.lastLineLength = ur[0].length, cr.finalize(ar, cr.lineNumber), 2;
    for (var dr = ar.offset; dr > 0 && isSpaceOrTab(peek(lr, cr.offset)); )
      cr.advanceOffset(1, !0), dr--;
    return 0;
  },
  finalize: function(cr, ar) {
    if (ar.stringContent !== null) {
      var lr = ar.stringContent, ur = lr.indexOf(`
`), dr = lr.slice(0, ur), fr = lr.slice(ur + 1), gr = dr.match(/^(\s*)(.*)/);
      ar.info = unescapeString(gr[2].trim()), ar.literal = fr, ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, noop = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, document$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr !== "item";
  },
  acceptsLines: !1
}, list$1 = {
  continue: function() {
    return 0;
  },
  finalize: function(cr, ar) {
    for (var lr = ar.firstChild; lr; ) {
      if (endsWithBlankLine(lr) && lr.next) {
        ar.listData.tight = !1;
        break;
      }
      for (var ur = lr.firstChild; ur; ) {
        if (endsWithBlankLine(ur) && (lr.next || ur.next)) {
          ar.listData.tight = !1;
          break;
        }
        ur = ur.next;
      }
      lr = lr.next;
    }
  },
  canContain: function(cr) {
    return cr === "item";
  },
  acceptsLines: !1
}, blockQuote$1 = {
  continue: function(cr) {
    var ar = cr.currentLine;
    if (!cr.indented && peek(ar, cr.nextNonspace) === C_GREATERTHAN)
      cr.advanceNextNonspace(), cr.advanceOffset(1, !1), isSpaceOrTab(peek(ar, cr.offset)) && cr.advanceOffset(1, !0);
    else
      return 1;
    return 0;
  },
  finalize: function() {
  },
  canContain: function(cr) {
    return cr !== "item";
  },
  acceptsLines: !1
}, item = {
  continue: function(cr, ar) {
    if (cr.blank) {
      if (ar.firstChild === null)
        return 1;
      cr.advanceNextNonspace();
    } else if (cr.indent >= ar.listData.markerOffset + ar.listData.padding)
      cr.advanceOffset(ar.listData.markerOffset + ar.listData.padding, !0);
    else
      return 1;
    return 0;
  },
  finalize: taskListItemFinalize,
  canContain: function(cr) {
    return cr !== "item";
  },
  acceptsLines: !1
}, heading$2 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, thematicBreak$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, codeBlock = {
  continue: function(cr, ar) {
    var lr = cr.currentLine, ur = cr.indent;
    if (ar.isFenced) {
      var dr = ur <= 3 && lr.charAt(cr.nextNonspace) === ar.fenceChar && lr.slice(cr.nextNonspace).match(reClosingCodeFence);
      if (dr && dr[0].length >= ar.fenceLength)
        return cr.lastLineLength = cr.offset + ur + dr[0].length, cr.finalize(ar, cr.lineNumber), 2;
      for (var fr = ar.fenceOffset; fr > 0 && isSpaceOrTab(peek(lr, cr.offset)); )
        cr.advanceOffset(1, !0), fr--;
    } else if (ur >= CODE_INDENT)
      cr.advanceOffset(CODE_INDENT, !0);
    else if (cr.blank)
      cr.advanceNextNonspace();
    else
      return 1;
    return 0;
  },
  finalize: function(cr, ar) {
    var lr;
    if (ar.stringContent !== null) {
      if (ar.isFenced) {
        var ur = ar.stringContent, dr = ur.indexOf(`
`), fr = ur.slice(0, dr), gr = ur.slice(dr + 1), mr = fr.match(/^(\s*)(.*)/);
        ar.infoPadding = mr[1].length, ar.info = unescapeString(mr[2].trim()), ar.literal = gr;
      } else
        ar.literal = (lr = ar.stringContent) === null || lr === void 0 ? void 0 : lr.replace(/(\n *)+$/, `
`);
      ar.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, htmlBlock$1 = {
  continue: function(cr, ar) {
    return cr.blank && (ar.htmlBlockType === 6 || ar.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(cr, ar) {
    var lr;
    ar.literal = ((lr = ar.stringContent) === null || lr === void 0 ? void 0 : lr.replace(/(\n *)+$/, "")) || null, ar.stringContent = null;
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, paragraph$1 = {
  continue: function(cr) {
    return cr.blank ? 1 : 0;
  },
  finalize: function(cr, ar) {
    if (ar.stringContent !== null) {
      for (var lr, ur = !1; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (lr = cr.inlineParser.parseReference(ar, cr.refMap)); )
        ar.stringContent = ar.stringContent.slice(lr), ur = !0;
      ur && isBlank(ar.stringContent) && ar.unlink();
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, refDef = noop, frontMatter$2 = noop, blockHandlers = {
  document: document$1,
  list: list$1,
  blockQuote: blockQuote$1,
  item,
  heading: heading$2,
  thematicBreak: thematicBreak$1,
  codeBlock,
  htmlBlock: htmlBlock$1,
  paragraph: paragraph$1,
  table,
  tableBody: tableBody$1,
  tableHead: tableHead$1,
  tableRow,
  tableCell,
  tableDelimRow,
  tableDelimCell,
  refDef,
  customBlock: customBlock$1,
  frontMatter: frontMatter$2
};
function parseRowContent(cr) {
  for (var ar = 0, lr = 0, ur = [], dr = 0; dr < cr.length; dr += 1)
    if (cr[dr] === "|" && cr[dr - 1] !== "\\") {
      var fr = cr.substring(ar, dr);
      ar === 0 && isEmpty(fr) ? lr = dr + 1 : ur.push(fr), ar = dr + 1;
    }
  if (ar < cr.length) {
    var fr = cr.substring(ar, cr.length);
    isEmpty(fr) || ur.push(fr);
  }
  return [lr, ur];
}
function generateTableCells(cr, ar, lr, ur) {
  for (var dr = [], fr = 0, gr = ar; fr < gr.length; fr++) {
    var mr = gr[fr], vr = mr.match(/^[ \t]+/), yr = vr ? vr[0].length : 0, _r = void 0, kr = void 0;
    if (yr === mr.length)
      yr = 0, _r = 0, kr = "";
    else {
      var xr = mr.match(/[ \t]+$/);
      _r = xr ? xr[0].length : 0, kr = mr.slice(yr, mr.length - _r);
    }
    var Ar = ur + yr, Er = createNode$1(cr, [
      [lr, ur],
      [lr, ur + mr.length - 1]
    ]);
    Er.stringContent = kr.replace(/\\\|/g, "|"), Er.startIdx = dr.length, Er.endIdx = dr.length, Er.lineOffsets = [Ar - 1], Er.paddingLeft = yr, Er.paddingRight = _r, dr.push(Er), ur += mr.length + 1;
  }
  return dr;
}
function getColumnFromDelimCell(cr) {
  var ar = null, lr = cr.stringContent, ur = lr[0], dr = lr[lr.length - 1];
  return dr === ":" ? ar = ur === ":" ? "center" : "right" : ur === ":" && (ar = "left"), { align: ar };
}
var tableHead = function(cr, ar) {
  var lr = ar.stringContent;
  if (ar.type === "paragraph" && !cr.indented && !cr.blank) {
    var ur = lr.length - 1, dr = lr.lastIndexOf(`
`, ur - 1) + 1, fr = lr.slice(dr, ur), gr = cr.currentLine.slice(cr.nextNonspace), mr = parseRowContent(fr), vr = mr[0], yr = mr[1], _r = parseRowContent(gr), kr = _r[0], xr = _r[1], Ar = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !yr.length || !xr.length || xr.some(function(Dr) {
        return !Ar.test(Dr);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      xr.length === 1 && gr.indexOf("|") !== 0
    )
      return 0;
    var Er = ar.lineOffsets, Cr = cr.lineNumber - 1, Tr = last(Er) + 1, Sr = createNode$1("table", [
      [Cr, Tr],
      [cr.lineNumber, cr.offset]
    ]);
    if (Sr.columns = xr.map(function() {
      return { align: null };
    }), ar.insertAfter(Sr), Er.length === 1)
      ar.unlink();
    else {
      ar.stringContent = lr.slice(0, dr);
      var Lr = lr.lastIndexOf(`
`, dr - 2) + 1, Ir = dr - Lr - 1;
      cr.lastLineLength = Er[Er.length - 2] + Ir, cr.finalize(ar, Cr - 1);
    }
    cr.advanceOffset(cr.currentLine.length - cr.offset, !1);
    var Nr = createNode$1("tableHead", [
      [Cr, Tr],
      [cr.lineNumber, cr.offset]
    ]);
    Sr.appendChild(Nr);
    var Rr = createNode$1("tableRow", [
      [Cr, Tr],
      [Cr, Tr + fr.length - 1]
    ]), Mr = createNode$1("tableDelimRow", [
      [cr.lineNumber, cr.nextNonspace + 1],
      [cr.lineNumber, cr.offset]
    ]);
    Nr.appendChild(Rr), Nr.appendChild(Mr), generateTableCells("tableCell", yr, Cr, Tr + vr).forEach(function(Dr) {
      Rr.appendChild(Dr);
    });
    var Br = generateTableCells("tableDelimCell", xr, cr.lineNumber, cr.nextNonspace + 1 + kr);
    return Br.forEach(function(Dr) {
      Mr.appendChild(Dr);
    }), Sr.columns = Br.map(getColumnFromDelimCell), cr.tip = Sr, 2;
  }
  return 0;
}, tableBody = function(cr, ar) {
  if (ar.type !== "table" && ar.type !== "tableBody" || !cr.blank && cr.currentLine.indexOf("|") === -1)
    return 0;
  if (cr.advanceOffset(cr.currentLine.length - cr.offset, !1), cr.blank) {
    var lr = ar;
    return ar.type === "tableBody" && (lr = ar.parent, cr.finalize(ar, cr.lineNumber - 1)), cr.finalize(lr, cr.lineNumber - 1), 0;
  }
  var ur = ar;
  ar.type === "table" && (ur = cr.addChild("tableBody", cr.nextNonspace), ur.stringContent = null);
  var dr = createNode$1("tableRow", [
    [cr.lineNumber, cr.nextNonspace + 1],
    [cr.lineNumber, cr.currentLine.length]
  ]);
  ur.appendChild(dr);
  var fr = ur.parent, gr = cr.currentLine.slice(cr.nextNonspace), mr = parseRowContent(gr), vr = mr[0], yr = mr[1];
  return generateTableCells("tableCell", yr, cr.lineNumber, cr.nextNonspace + 1 + vr).forEach(function(_r, kr) {
    kr >= fr.columns.length && (_r.ignored = !0), dr.appendChild(_r);
  }), 2;
}, reCustomBlock = /^(\$\$)(\s*[a-zA-Z])+/, reCanBeCustomInline = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, customBlock = function(cr) {
  var ar;
  if (!cr.indented && !reCanBeCustomInline.test(cr.currentLine) && (ar = cr.currentLine.match(reCustomBlock))) {
    var lr = ar[1].length;
    cr.closeUnmatchedBlocks();
    var ur = cr.addChild("customBlock", cr.nextNonspace);
    return ur.syntaxLength = lr, ur.offset = cr.indent, cr.advanceNextNonspace(), cr.advanceOffset(lr, !1), 2;
  }
  return 0;
}, reCodeFence = /^`{3,}(?!.*`)|^~{3,}/, reHtmlBlockOpen = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", "i")
], reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/, reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/, reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, reBulletListMarker = /^[*+-]/, reOrderedListMarker = /^(\d{1,9})([.)])/;
function parseListMarker(cr, ar) {
  var lr = cr.currentLine.slice(cr.nextNonspace), ur, dr, fr = {
    type: "bullet",
    tight: !0,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: cr.indent,
    // GFM: Task List Item
    task: !1,
    checked: !1
  };
  if (cr.indent >= 4)
    return null;
  if (ur = lr.match(reBulletListMarker))
    fr.type = "bullet", fr.bulletChar = ur[0][0];
  else if ((ur = lr.match(reOrderedListMarker)) && (ar.type !== "paragraph" || ur[1] === "1"))
    fr.type = "ordered", fr.start = parseInt(ur[1], 10), fr.delimiter = ur[2];
  else
    return null;
  if (dr = peek(cr.currentLine, cr.nextNonspace + ur[0].length), !(dr === -1 || dr === C_TAB || dr === C_SPACE) || ar.type === "paragraph" && !cr.currentLine.slice(cr.nextNonspace + ur[0].length).match(reNonSpace))
    return null;
  cr.advanceNextNonspace(), cr.advanceOffset(ur[0].length, !0);
  var gr = cr.column, mr = cr.offset;
  do
    cr.advanceOffset(1, !0), dr = peek(cr.currentLine, cr.offset);
  while (cr.column - gr < 5 && isSpaceOrTab(dr));
  var vr = peek(cr.currentLine, cr.offset) === -1, yr = cr.column - gr;
  return yr >= 5 || yr < 1 || vr ? (fr.padding = ur[0].length + 1, cr.column = gr, cr.offset = mr, isSpaceOrTab(peek(cr.currentLine, cr.offset)) && cr.advanceOffset(1, !0)) : fr.padding = ur[0].length + yr, fr;
}
function listsMatch(cr, ar) {
  return cr.type === ar.type && cr.delimiter === ar.delimiter && cr.bulletChar === ar.bulletChar;
}
function isDisallowedDeepHeading(cr, ar) {
  return cr.options.disallowDeepHeading && (ar.type === "blockQuote" || ar.type === "item");
}
var blockQuote = function(cr) {
  return !cr.indented && peek(cr.currentLine, cr.nextNonspace) === C_GREATERTHAN ? (cr.advanceNextNonspace(), cr.advanceOffset(1, !1), isSpaceOrTab(peek(cr.currentLine, cr.offset)) && cr.advanceOffset(1, !0), cr.closeUnmatchedBlocks(), cr.addChild("blockQuote", cr.nextNonspace), 1) : 0;
}, atxHeading = function(cr, ar) {
  var lr;
  if (!cr.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(cr, ar) && (lr = cr.currentLine.slice(cr.nextNonspace).match(reATXHeadingMarker))) {
    cr.advanceNextNonspace(), cr.advanceOffset(lr[0].length, !1), cr.closeUnmatchedBlocks();
    var ur = cr.addChild("heading", cr.nextNonspace);
    return ur.level = lr[0].trim().length, ur.headingType = "atx", ur.stringContent = cr.currentLine.slice(cr.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), cr.advanceOffset(cr.currentLine.length - cr.offset), 2;
  }
  return 0;
}, fencedCodeBlock = function(cr) {
  var ar;
  if (!cr.indented && (ar = cr.currentLine.slice(cr.nextNonspace).match(reCodeFence))) {
    var lr = ar[0].length;
    cr.closeUnmatchedBlocks();
    var ur = cr.addChild("codeBlock", cr.nextNonspace);
    return ur.isFenced = !0, ur.fenceLength = lr, ur.fenceChar = ar[0][0], ur.fenceOffset = cr.indent, cr.advanceNextNonspace(), cr.advanceOffset(lr, !1), 2;
  }
  return 0;
}, htmlBlock = function(cr, ar) {
  if (!cr.indented && peek(cr.currentLine, cr.nextNonspace) === C_LESSTHAN) {
    var lr = cr.currentLine.slice(cr.nextNonspace), ur = cr.options.disallowedHtmlBlockTags, dr = void 0;
    for (dr = 1; dr <= 7; dr++) {
      var fr = lr.match(reHtmlBlockOpen[dr]);
      if (fr) {
        if (dr === 7) {
          if (ar.type === "paragraph")
            return 0;
          if (ur.length > 0) {
            var gr = new RegExp("</?(?:" + ur.join("|") + ")", "i");
            if (gr.test(fr[0]))
              return 0;
          }
        }
        cr.closeUnmatchedBlocks();
        var mr = cr.addChild("htmlBlock", cr.offset);
        return mr.htmlBlockType = dr, 2;
      }
    }
  }
  return 0;
}, seTextHeading = function(cr, ar) {
  var lr;
  if (ar.stringContent !== null && !cr.indented && ar.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(cr, ar.parent) && (lr = cr.currentLine.slice(cr.nextNonspace).match(reSetextHeadingLine))) {
    cr.closeUnmatchedBlocks();
    for (var ur = void 0; peek(ar.stringContent, 0) === C_OPEN_BRACKET && (ur = cr.inlineParser.parseReference(ar, cr.refMap)); )
      ar.stringContent = ar.stringContent.slice(ur);
    if (ar.stringContent.length > 0) {
      var dr = createNode$1("heading", ar.sourcepos);
      return dr.level = lr[0][0] === "=" ? 1 : 2, dr.headingType = "setext", dr.stringContent = ar.stringContent, ar.insertAfter(dr), ar.unlink(), cr.tip = dr, cr.advanceOffset(cr.currentLine.length - cr.offset, !1), 2;
    }
    return 0;
  }
  return 0;
}, thematicBreak = function(cr) {
  return !cr.indented && reThematicBreak.test(cr.currentLine.slice(cr.nextNonspace)) ? (cr.closeUnmatchedBlocks(), cr.addChild("thematicBreak", cr.nextNonspace), cr.advanceOffset(cr.currentLine.length - cr.offset, !1), 2) : 0;
}, listItem = function(cr, ar) {
  var lr, ur = ar;
  return (!cr.indented || ar.type === "list") && (lr = parseListMarker(cr, ur)) ? (cr.closeUnmatchedBlocks(), (cr.tip.type !== "list" || !listsMatch(ur.listData, lr)) && (ur = cr.addChild("list", cr.nextNonspace), ur.listData = lr), ur = cr.addChild("item", cr.nextNonspace), ur.listData = lr, 1) : 0;
}, indentedCodeBlock = function(cr) {
  return cr.indented && cr.tip.type !== "paragraph" && !cr.blank ? (cr.advanceOffset(CODE_INDENT, !0), cr.closeUnmatchedBlocks(), cr.addChild("codeBlock", cr.offset), 2) : 0;
}, blockStarts = [
  blockQuote,
  atxHeading,
  fencedCodeBlock,
  htmlBlock,
  seTextHeading,
  thematicBreak,
  listItem,
  indentedCodeBlock,
  tableHead,
  tableBody,
  customBlock
], reFrontMatter = /^(-{3}|\+{3}|;{3})$/, frontMatter$1 = function(cr, ar) {
  var lr = cr.currentLine, ur = cr.lineNumber, dr = cr.indented;
  if (ur === 1 && !dr && ar.type === "document" && reFrontMatter.test(lr)) {
    cr.closeUnmatchedBlocks();
    var fr = cr.addChild("frontMatter", cr.nextNonspace);
    return fr.stringContent = lr, cr.advanceNextNonspace(), cr.advanceOffset(lr.length, !1), 2;
  }
  return 0;
}, frontMatter = {
  continue: function(cr, ar) {
    var lr = cr.currentLine, ur = lr.match(reFrontMatter);
    return ar.type === "frontMatter" && ur ? (ar.stringContent += lr, cr.lastLineLength = ur[0].length, cr.finalize(ar, cr.lineNumber), 2) : 0;
  },
  finalize: function(cr, ar) {
    ar.stringContent !== null && (ar.literal = ar.stringContent, ar.stringContent = null);
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, reHtmlBlockClose = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
], reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/, reLineEnding$1 = /\r\n|\n|\r/;
function document$2() {
  return createNode$1("document", [
    [1, 1],
    [0, 0]
  ]);
}
var defaultOptions$1 = {
  smart: !1,
  tagFilter: !1,
  extendedAutolinks: !1,
  disallowedHtmlBlockTags: [],
  referenceDefinition: !1,
  disallowDeepHeading: !1,
  customParser: null,
  frontMatter: !1
}, Parser = (
  /** @class */
  function() {
    function cr(ar) {
      this.options = __assign(__assign({}, defaultOptions$1), ar), this.doc = document$2(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (blockHandlers.frontMatter = frontMatter, blockStarts.unshift(frontMatter$1)), this.inlineParser = new InlineParser(this.options);
    }
    return cr.prototype.advanceOffset = function(ar, lr) {
      lr === void 0 && (lr = !1);
      for (var ur = this.currentLine, dr, fr, gr; ar > 0 && (gr = ur[this.offset]); )
        gr === "	" ? (dr = 4 - this.column % 4, lr ? (this.partiallyConsumedTab = dr > ar, fr = dr > ar ? ar : dr, this.column += fr, this.offset += this.partiallyConsumedTab ? 0 : 1, ar -= fr) : (this.partiallyConsumedTab = !1, this.column += dr, this.offset += 1, ar -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, ar -= 1);
    }, cr.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
    }, cr.prototype.findNextNonspace = function() {
      for (var ar = this.currentLine, lr = this.offset, ur = this.column, dr; (dr = ar.charAt(lr)) !== ""; )
        if (dr === " ")
          lr++, ur++;
        else if (dr === "	")
          lr++, ur += 4 - ur % 4;
        else
          break;
      this.blank = dr === `
` || dr === "\r" || dr === "", this.nextNonspace = lr, this.nextNonspaceColumn = ur, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= CODE_INDENT;
    }, cr.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var ar = 4 - this.column % 4;
        this.tip.stringContent += repeat(" ", ar);
      }
      this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
    }, cr.prototype.addChild = function(ar, lr) {
      for (; !blockHandlers[this.tip.type].canContain(ar); )
        this.finalize(this.tip, this.lineNumber - 1);
      var ur = lr + 1, dr = createNode$1(ar, [
        [this.lineNumber, ur],
        [0, 0]
      ]);
      return dr.stringContent = "", this.tip.appendChild(dr), this.tip = dr, dr;
    }, cr.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        for (; this.oldtip !== this.lastMatchedContainer; ) {
          var ar = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = ar;
        }
        this.allClosed = !0;
      }
    }, cr.prototype.finalize = function(ar, lr) {
      var ur = ar.parent;
      ar.open = !1, ar.sourcepos[1] = [lr, this.lastLineLength], blockHandlers[ar.type].finalize(this, ar), this.tip = ur;
    }, cr.prototype.processInlines = function(ar) {
      var lr, ur = this.options.customParser, dr = ar.walker();
      for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; lr = dr.next(); ) {
        var fr = lr.node, gr = lr.entering, mr = fr.type;
        ur && ur[mr] && ur[mr](fr, { entering: gr, options: this.options }), !gr && (mr === "paragraph" || mr === "heading" || mr === "tableCell" && !fr.ignored) && this.inlineParser.parse(fr);
      }
    }, cr.prototype.incorporateLine = function(ar) {
      var lr = this.doc;
      this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, ar.indexOf("\0") !== -1 && (ar = ar.replace(/\0/g, "")), this.currentLine = ar;
      for (var ur = !0, dr; (dr = lr.lastChild) && dr.open; ) {
        switch (lr = dr, this.findNextNonspace(), blockHandlers[lr.type].continue(this, lr)) {
          case 0:
            break;
          case 1:
            ur = !1;
            break;
          case 2:
            this.lastLineLength = ar.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!ur) {
          lr = lr.parent;
          break;
        }
      }
      this.allClosed = lr === this.oldtip, this.lastMatchedContainer = lr;
      for (var fr = lr.type !== "paragraph" && blockHandlers[lr.type].acceptsLines, gr = blockStarts.length; !fr; ) {
        if (this.findNextNonspace(), lr.type !== "table" && lr.type !== "tableBody" && lr.type !== "paragraph" && !this.indented && !reMaybeSpecial.test(ar.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        for (var mr = 0; mr < gr; ) {
          var vr = blockStarts[mr](this, lr);
          if (vr === 1) {
            lr = this.tip;
            break;
          } else if (vr === 2) {
            lr = this.tip, fr = !0;
            break;
          } else
            mr++;
        }
        if (mr === gr) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
        this.addLine();
      else {
        this.closeUnmatchedBlocks(), this.blank && lr.lastChild && (lr.lastChild.lastLineBlank = !0);
        for (var yr = lr.type, _r = this.blank && !(yr === "blockQuote" || isCodeBlock(lr) && lr.isFenced || yr === "item" && !lr.firstChild && lr.sourcepos[0][0] === this.lineNumber), kr = lr; kr; )
          kr.lastLineBlank = _r, kr = kr.parent;
        blockHandlers[yr].acceptsLines ? (this.addLine(), isHtmlBlock(lr) && lr.htmlBlockType >= 1 && lr.htmlBlockType <= 5 && reHtmlBlockClose[lr.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = ar.length, this.finalize(lr, this.lineNumber))) : this.offset < ar.length && !this.blank && (lr = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
      }
      this.lastLineLength = ar.length;
    }, cr.prototype.parse = function(ar, lr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      var ur = ar.split(reLineEnding$1), dr = ur.length;
      this.lines = lr || ur, this.options.referenceDefinition && this.clearRefMaps(), ar.charCodeAt(ar.length - 1) === C_NEWLINE && (dr -= 1);
      for (var fr = 0; fr < dr; fr++)
        this.incorporateLine(ur[fr]);
      for (; this.tip; )
        this.finalize(this.tip, dr);
      return this.processInlines(this.doc), this.doc;
    }, cr.prototype.partialParseStart = function(ar, lr) {
      this.doc = document$2(), this.tip = this.doc, this.lineNumber = ar - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      for (var ur = lr.length, dr = 0; dr < ur; dr++)
        this.incorporateLine(lr[dr]);
      return this.doc;
    }, cr.prototype.partialParseExtends = function(ar) {
      for (var lr = 0; lr < ar.length; lr++)
        this.incorporateLine(ar[lr]);
    }, cr.prototype.partialParseFinish = function() {
      for (; this.tip; )
        this.finalize(this.tip, this.lineNumber);
      this.processInlines(this.doc);
    }, cr.prototype.setRefMaps = function(ar, lr, ur) {
      this.refMap = ar, this.refLinkCandidateMap = lr, this.refDefCandidateMap = ur;
    }, cr.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        clearObj(ar);
      });
    }, cr;
  }()
);
function comparePos(cr, ar) {
  return cr[0] < ar[0] ? 1 : cr[0] > ar[0] ? -1 : cr[1] < ar[1] ? 1 : cr[1] > ar[1] ? -1 : 0;
}
function compareRangeAndPos(cr, ar) {
  var lr = cr[0], ur = cr[1];
  return comparePos(ur, ar) === 1 ? 1 : comparePos(lr, ar) === -1 ? -1 : 0;
}
function removeNextUntil(cr, ar) {
  if (!(cr.parent !== ar.parent || cr === ar)) {
    for (var lr = cr.next; lr && lr !== ar; ) {
      for (var ur = lr.next, dr = 0, fr = ["parent", "prev", "next"]; dr < fr.length; dr++) {
        var gr = fr[dr];
        lr[gr] && (removeNodeById(lr[gr].id), lr[gr] = null);
      }
      lr = ur;
    }
    cr.next = ar.next, ar.next ? ar.next.prev = cr : cr.parent.lastChild = cr;
  }
}
function getChildNodes(cr) {
  for (var ar = [], lr = cr.firstChild; lr; )
    ar.push(lr), lr = lr.next;
  return ar;
}
function insertNodesBefore(cr, ar) {
  for (var lr = 0, ur = ar; lr < ur.length; lr++) {
    var dr = ur[lr];
    cr.insertBefore(dr);
  }
}
function prependChildNodes(cr, ar) {
  for (var lr = ar.length - 1; lr >= 0; lr -= 1)
    cr.prependChild(ar[lr]);
}
function updateNextLineNumbers(cr, ar) {
  if (!(!cr || !cr.parent || ar === 0)) {
    var lr = cr.parent.walker();
    lr.resumeAt(cr, !0);
    for (var ur; ur = lr.next(); ) {
      var dr = ur.node, fr = ur.entering;
      fr && (dr.sourcepos[0][0] += ar, dr.sourcepos[1][0] += ar);
    }
  }
}
function compareRangeAndLine(cr, ar) {
  var lr = cr[0], ur = cr[1];
  return ur[0] < ar ? 1 : lr[0] > ar ? -1 : 0;
}
function findChildNodeAtLine(cr, ar) {
  for (var lr = cr.firstChild; lr; ) {
    var ur = compareRangeAndLine(lr.sourcepos, ar);
    if (ur === 0)
      return lr;
    if (ur === -1)
      return lr.prev || lr;
    lr = lr.next;
  }
  return cr.lastChild;
}
function lastLeafNode(cr) {
  for (; cr.lastChild; )
    cr = cr.lastChild;
  return cr;
}
function sameLineTopAncestor(cr) {
  for (; cr.parent && cr.parent.type !== "document" && cr.parent.sourcepos[0][0] === cr.sourcepos[0][0]; )
    cr = cr.parent;
  return cr;
}
function findFirstNodeAtLine(cr, ar) {
  for (var lr = cr.firstChild, ur = null; lr; ) {
    var dr = compareRangeAndLine(lr.sourcepos, ar);
    if (dr === 0) {
      if (lr.sourcepos[0][0] === ar || !lr.firstChild)
        return lr;
      ur = lr, lr = lr.firstChild;
    } else {
      if (dr === -1)
        break;
      ur = lr, lr = lr.next;
    }
  }
  return ur ? sameLineTopAncestor(lastLeafNode(ur)) : null;
}
function findNodeAtPosition(cr, ar) {
  for (var lr = cr, ur = null; lr; ) {
    var dr = compareRangeAndPos(lr.sourcepos, ar);
    if (dr === 0)
      if (lr.firstChild)
        ur = lr, lr = lr.firstChild;
      else
        return lr;
    else {
      if (dr === -1)
        return ur;
      if (lr.next)
        lr = lr.next;
      else
        return ur;
    }
  }
  return lr;
}
function findNodeById(cr) {
  return getNodeById(cr) || null;
}
function invokeNextUntil(cr, ar, lr) {
  if (lr === void 0 && (lr = null), ar)
    for (var ur = ar.walker(); ar && ar !== lr; ) {
      cr(ar);
      var dr = ur.next();
      if (dr)
        ar = dr.node;
      else
        break;
    }
}
function isUnlinked(cr) {
  var ar = findNodeById(cr);
  if (!ar)
    return !0;
  for (; ar && ar.type !== "document"; ) {
    if (!ar.parent && !ar.prev && !ar.next)
      return !0;
    ar = ar.parent;
  }
  return !1;
}
var reLineEnding = /\r\n|\n|\r/;
function canBeContinuedListItem(cr) {
  var ar = cr.match(/^[ \t]+/);
  if (ar && (ar[0].length >= 2 || /\t/.test(ar[0])))
    return !0;
  var lr = ar ? cr.slice(ar.length) : cr;
  return reBulletListMarker.test(lr) || reOrderedListMarker.test(lr);
}
function canBeContinuedTableBody(cr) {
  return !isBlank(cr) && cr.indexOf("|") !== -1;
}
function createRefDefState(cr) {
  var ar = cr.id, lr = cr.title, ur = cr.sourcepos, dr = cr.dest;
  return {
    id: ar,
    title: lr,
    sourcepos: ur,
    unlinked: !1,
    destination: dr
  };
}
var ToastMark = (
  /** @class */
  function() {
    function cr(ar, lr) {
      this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(lr != null && lr.referenceDefinition), this.parser = new Parser(lr), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, ar = ar || "", this.lineTexts = ar.split(reLineEnding), this.root = this.parser.parse(ar, this.lineTexts);
    }
    return cr.prototype.updateLineTexts = function(ar, lr, ur) {
      var dr, fr = ar[0], gr = ar[1], mr = lr[0], vr = lr[1], yr = ur.split(reLineEnding), _r = yr.length, kr = this.lineTexts[fr - 1], xr = this.lineTexts[mr - 1];
      yr[0] = kr.slice(0, gr - 1) + yr[0], yr[_r - 1] = yr[_r - 1] + xr.slice(vr - 1);
      var Ar = mr - fr + 1;
      return (dr = this.lineTexts).splice.apply(dr, __spreadArray([fr - 1, Ar], yr)), _r - Ar;
    }, cr.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = !0, this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
      for (var ar = this.lineTexts, lr = ar.length - 1; ar[lr] === ""; )
        lr -= 1;
      ar.length - 2 > lr && (lr += 1), this.root.sourcepos[1] = [lr + 1, ar[lr].length];
    }, cr.prototype.replaceRangeNodes = function(ar, lr, ur) {
      ar ? (insertNodesBefore(ar, ur), removeNextUntil(ar, lr), [ar.id, lr.id].forEach(function(dr) {
        return removeNodeById(dr);
      }), ar.unlink()) : lr ? (insertNodesBefore(lr, ur), removeNodeById(lr.id), lr.unlink()) : prependChildNodes(this.root, ur);
    }, cr.prototype.getNodeRange = function(ar, lr) {
      var ur = findChildNodeAtLine(this.root, ar[0]), dr = findChildNodeAtLine(this.root, lr[0]);
      return dr && dr.next && lr[0] + 1 === dr.next.sourcepos[0][0] && (dr = dr.next), [ur, dr];
    }, cr.prototype.trigger = function(ar, lr) {
      this.eventHandlerMap[ar].forEach(function(ur) {
        ur(lr);
      });
    }, cr.prototype.extendEndLine = function(ar) {
      for (; this.lineTexts[ar] === ""; )
        ar += 1;
      return ar;
    }, cr.prototype.parseRange = function(ar, lr, ur, dr) {
      ar && ar.prev && (isList(ar.prev) && canBeContinuedListItem(this.lineTexts[ur - 1]) || isTable(ar.prev) && canBeContinuedTableBody(this.lineTexts[ur - 1])) && (ar = ar.prev, ur = ar.sourcepos[0][0]);
      for (var fr = this.lineTexts.slice(ur - 1, dr), gr = this.parser.partialParseStart(ur, fr), mr = lr ? lr.next : this.root.firstChild, vr = gr.lastChild, yr = vr && isCodeBlock(vr) && vr.open, _r = vr && isCustomBlock(vr) && vr.open, kr = vr && isList(vr); (yr || _r) && mr || kr && mr && (mr.type === "list" || mr.sourcepos[0][1] >= 2); ) {
        var xr = this.extendEndLine(mr.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(dr, xr)), ar || (ar = lr), lr = mr, dr = xr, mr = mr.next;
      }
      this.parser.partialParseFinish();
      var Ar = getChildNodes(gr);
      return { newNodes: Ar, extStartNode: ar, extEndNode: lr };
    }, cr.prototype.getRemovedNodeRange = function(ar, lr) {
      return !ar || ar && isRefDef(ar) || lr && isRefDef(lr) ? null : {
        id: [ar.id, lr.id],
        line: [ar.sourcepos[0][0] - 1, lr.sourcepos[1][0] - 1]
      };
    }, cr.prototype.markDeletedRefMap = function(ar, lr) {
      var ur = this;
      if (!isEmptyObj(this.refMap)) {
        var dr = function(fr) {
          if (isRefDef(fr)) {
            var gr = ur.refMap[fr.label];
            gr && fr.id === gr.id && (gr.unlinked = !0);
          }
        };
        ar && invokeNextUntil(dr, ar.parent, lr), lr && invokeNextUntil(dr, lr);
      }
    }, cr.prototype.replaceWithNewRefDefState = function(ar) {
      var lr = this;
      if (!isEmptyObj(this.refMap)) {
        var ur = function(dr) {
          if (isRefDef(dr)) {
            var fr = dr.label, gr = lr.refMap[fr];
            (!gr || gr.unlinked) && (lr.refMap[fr] = createRefDefState(dr));
          }
        };
        ar.forEach(function(dr) {
          invokeNextUntil(ur, dr);
        });
      }
    }, cr.prototype.replaceWithRefDefCandidate = function() {
      var ar = this;
      isEmptyObj(this.refDefCandidateMap) || iterateObject(this.refDefCandidateMap, function(lr, ur) {
        var dr = ur.label, fr = ur.sourcepos, gr = ar.refMap[dr];
        (!gr || gr.unlinked || gr.sourcepos[0][0] > fr[0][0]) && (ar.refMap[dr] = createRefDefState(ur));
      });
    }, cr.prototype.getRangeWithRefDef = function(ar, lr, ur, dr, fr) {
      if (this.referenceDefinition && !isEmptyObj(this.refMap)) {
        var gr = findChildNodeAtLine(this.root, ar - 1), mr = findChildNodeAtLine(this.root, lr + 1);
        gr && isRefDef(gr) && gr !== ur && gr !== dr && (ur = gr, ar = ur.sourcepos[0][0]), mr && isRefDef(mr) && mr !== ur && mr !== dr && (dr = mr, lr = this.extendEndLine(dr.sourcepos[1][0] + fr));
      }
      return [ur, dr, ar, lr];
    }, cr.prototype.parse = function(ar, lr, ur) {
      ur === void 0 && (ur = 0);
      var dr = this.getNodeRange(ar, lr), fr = dr[0], gr = dr[1], mr = fr ? Math.min(fr.sourcepos[0][0], ar[0]) : ar[0], vr = this.extendEndLine((gr ? Math.max(gr.sourcepos[1][0], lr[0]) : lr[0]) + ur), yr = this.parseRange.apply(this, this.getRangeWithRefDef(mr, vr, fr, gr, ur)), _r = yr.newNodes, kr = yr.extStartNode, xr = yr.extEndNode, Ar = this.getRemovedNodeRange(kr, xr), Er = xr ? xr.next : this.root.firstChild;
      return this.referenceDefinition ? (this.markDeletedRefMap(kr, xr), this.replaceRangeNodes(kr, xr, _r), this.replaceWithNewRefDefState(_r)) : this.replaceRangeNodes(kr, xr, _r), { nodes: _r, removedNodeRange: Ar, nextNode: Er };
    }, cr.prototype.parseRefLink = function() {
      var ar = this, lr = [];
      return isEmptyObj(this.refMap) || iterateObject(this.refMap, function(ur, dr) {
        dr.unlinked && delete ar.refMap[ur], iterateObject(ar.refLinkCandidateMap, function(fr, gr) {
          var mr = gr.node, vr = gr.refLabel;
          vr === ur && lr.push(ar.parse(mr.sourcepos[0], mr.sourcepos[1]));
        });
      }), lr;
    }, cr.prototype.removeUnlinkedCandidate = function() {
      isEmptyObj(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(ar) {
        iterateObject(ar, function(lr) {
          isUnlinked(lr) && delete ar[lr];
        });
      });
    }, cr.prototype.editMarkdown = function(ar, lr, ur) {
      var dr = this.updateLineTexts(ar, lr, ur), fr = this.parse(ar, lr, dr), gr = omit(fr, "nextNode");
      updateNextLineNumbers(fr.nextNode, dr), this.updateRootNodeState();
      var mr = [gr];
      return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), mr = mr.concat(this.parseRefLink())), this.trigger("change", mr), mr;
    }, cr.prototype.getLineTexts = function() {
      return this.lineTexts;
    }, cr.prototype.getRootNode = function() {
      return this.root;
    }, cr.prototype.findNodeAtPosition = function(ar) {
      var lr = findNodeAtPosition(this.root, ar);
      return !lr || lr === this.root ? null : lr;
    }, cr.prototype.findFirstNodeAtLine = function(ar) {
      return findFirstNodeAtLine(this.root, ar);
    }, cr.prototype.on = function(ar, lr) {
      this.eventHandlerMap[ar].push(lr);
    }, cr.prototype.off = function(ar, lr) {
      var ur = this.eventHandlerMap[ar], dr = ur.indexOf(lr);
      ur.splice(dr, 1);
    }, cr.prototype.findNodeById = function(ar) {
      return findNodeById(ar);
    }, cr.prototype.removeAllNode = function() {
      removeAllNode();
    }, cr;
  }()
), disallowedTags = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
], reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join("|") + ")[^>]*>)", "ig");
function filterDisallowedTags(cr) {
  return reDisallowedTag.test(cr) ? cr.replace(reDisallowedTag, function(ar, lr) {
    return "&lt;" + lr;
  }) : cr;
}
var baseConvertors$1 = {
  heading: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "h" + cr.level,
      outerNewLine: !0
    };
  },
  text: function(cr) {
    return {
      type: "text",
      content: cr.literal
    };
  },
  softbreak: function(cr, ar) {
    var lr = ar.options;
    return {
      type: "html",
      content: lr.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: `<br />
`
    };
  },
  emph: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(cr, ar) {
    var lr, ur = ar.entering, dr = (lr = cr.parent) === null || lr === void 0 ? void 0 : lr.parent;
    return dr && dr.type === "list" && dr.listData.tight ? null : {
      type: ur ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: !0
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: !0,
      selfClose: !0
    };
  },
  blockQuote: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: !0,
      innerNewLine: !0
    };
  },
  list: function(cr, ar) {
    var lr = ar.entering, ur = cr.listData, dr = ur.type, fr = ur.start, gr = dr === "bullet" ? "ul" : "ol", mr = {};
    return gr === "ol" && fr !== null && fr !== 1 && (mr.start = fr.toString()), {
      type: lr ? "openTag" : "closeTag",
      tagName: gr,
      attributes: mr,
      outerNewLine: !0
    };
  },
  item: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  htmlInline: function(cr, ar) {
    var lr = ar.options, ur = lr.tagFilter ? filterDisallowedTags(cr.literal) : cr.literal;
    return { type: "html", content: ur };
  },
  htmlBlock: function(cr, ar) {
    var lr = ar.options, ur = lr.tagFilter ? filterDisallowedTags(cr.literal) : cr.literal;
    return lr.nodeId ? [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "html", content: ur },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ] : { type: "html", content: ur, outerNewLine: !0 };
  },
  code: function(cr) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(cr) {
    var ar = cr.info, lr = ar ? ar.split(/\s+/) : [], ur = [];
    return lr.length > 0 && lr[0].length > 0 && ur.push("language-" + escapeXml(lr[0])), [
      { type: "openTag", tagName: "pre", outerNewLine: !0 },
      { type: "openTag", tagName: "code", classNames: ur },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: !0 }
    ];
  },
  link: function(cr, ar) {
    var lr = ar.entering;
    if (lr) {
      var ur = cr, dr = ur.title, fr = ur.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: __assign({ href: escapeXml(fr) }, dr && { title: escapeXml(dr) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(cr, ar) {
    var lr = ar.getChildrenText, ur = ar.skipChildren, dr = cr, fr = dr.title, gr = dr.destination;
    return ur(), {
      type: "openTag",
      tagName: "img",
      selfClose: !0,
      attributes: __assign({ src: escapeXml(gr), alt: lr(cr) }, fr && { title: escapeXml(fr) })
    };
  },
  customBlock: function(cr, ar, lr) {
    var ur = cr.info.trim().toLowerCase(), dr = lr[ur];
    if (dr)
      try {
        return dr(cr, ar);
      } catch (fr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + ur + " block node was parsed in markdown renderer: " + fr);
      }
    return [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  frontMatter: function(cr) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: !0,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  customInline: function(cr, ar, lr) {
    var ur = cr, dr = ur.info, fr = ur.firstChild, gr = dr.trim().toLowerCase(), mr = lr[gr], vr = ar.entering;
    if (mr)
      try {
        return mr(cr, ar);
      } catch (yr) {
        console.warn("[@toast-ui/editor] - The error occurred when " + gr + " inline node was parsed in markdown renderer: " + yr);
      }
    return vr ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + dr + (fr ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
}, gfmConvertors = {
  strike: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(cr, ar) {
    var lr = ar.entering, ur = cr.listData, dr = ur.checked, fr = ur.task;
    if (lr) {
      var gr = {
        type: "openTag",
        tagName: "li",
        outerNewLine: !0
      };
      return fr ? [
        gr,
        {
          type: "openTag",
          tagName: "input",
          selfClose: !0,
          attributes: __assign(__assign({}, dr && { checked: "" }), { disabled: "", type: "checkbox" })
        },
        {
          type: "text",
          content: " "
        }
      ] : gr;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  table: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: !0
    };
  },
  tableHead: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: !0
    };
  },
  tableBody: function(cr, ar) {
    var lr = ar.entering;
    return {
      type: lr ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: !0
    };
  },
  tableRow: function(cr, ar) {
    var lr = ar.entering;
    if (lr)
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: !0
      };
    var ur = [];
    if (cr.lastChild)
      for (var dr = cr.parent.parent.columns.length, fr = cr.lastChild.endIdx, gr = fr + 1; gr < dr; gr += 1)
        ur.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: !0
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: !0
        });
    return ur.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: !0
    }), ur;
  },
  tableCell: function(cr, ar) {
    var lr = ar.entering;
    if (cr.ignored)
      return {
        type: "text",
        content: ""
      };
    var ur = cr.parent.parent, dr = ur.type === "tableHead" ? "th" : "td", fr = ur.parent, gr = fr.columns[cr.startIdx], mr = gr != null && gr.align ? { align: gr.align } : null;
    return lr ? __assign({ type: "openTag", tagName: dr, outerNewLine: !0 }, mr && { attributes: mr }) : {
      type: "closeTag",
      tagName: dr,
      outerNewLine: !0
    };
  }
}, defaultOptions = {
  softbreak: `
`,
  gfm: !1,
  tagFilter: !1,
  nodeId: !1
};
function getChildrenText(cr) {
  for (var ar = [], lr = cr.walker(), ur = null; ur = lr.next(); ) {
    var dr = ur.node;
    dr.type === "text" && ar.push(dr.literal);
  }
  return ar.join("");
}
var Renderer = (
  /** @class */
  function() {
    function cr(ar) {
      this.buffer = [], this.options = __assign(__assign({}, defaultOptions), ar), this.convertors = this.createConvertors(), delete this.options.convertors;
    }
    return cr.prototype.createConvertors = function() {
      var ar = __assign({}, baseConvertors$1);
      if (this.options.gfm && (ar = __assign(__assign({}, ar), gfmConvertors)), this.options.convertors) {
        var lr = this.options.convertors, ur = Object.keys(lr), dr = __assign(__assign({}, baseConvertors$1), gfmConvertors);
        ur.forEach(function(fr) {
          var gr = ar[fr], mr = lr[fr], vr = Object.keys(dr).indexOf(fr) === -1 ? fr.toLowerCase() : fr;
          gr ? ar[vr] = function(yr, _r, kr) {
            return _r.origin = function() {
              return gr(yr, _r, kr);
            }, mr(yr, _r);
          } : ar[vr] = mr;
        });
      }
      return ar;
    }, cr.prototype.getConvertors = function() {
      return this.convertors;
    }, cr.prototype.getOptions = function() {
      return this.options;
    }, cr.prototype.render = function(ar) {
      var lr = this;
      this.buffer = [];
      for (var ur = ar.walker(), dr = null, fr = function() {
        var mr = dr.node, vr = dr.entering, yr = gr.convertors[mr.type];
        if (!yr)
          return "continue";
        var _r = !1, kr = {
          entering: vr,
          leaf: !isContainer$1(mr),
          options: gr.options,
          getChildrenText,
          skipChildren: function() {
            _r = !0;
          }
        }, xr = isCustomBlock(mr) || isCustomInline(mr) ? yr(mr, kr, gr.convertors) : yr(mr, kr);
        if (xr) {
          var Ar = Array.isArray(xr) ? xr : [xr];
          Ar.forEach(function(Er, Cr) {
            Er.type === "openTag" && lr.options.nodeId && Cr === 0 && (Er.attributes || (Er.attributes = {}), Er.attributes["data-nodeid"] = String(mr.id)), lr.renderHTMLNode(Er);
          }), _r && (ur.resumeAt(mr, !1), ur.next());
        }
      }, gr = this; dr = ur.next(); )
        fr();
      return this.addNewLine(), this.buffer.join("");
    }, cr.prototype.renderHTMLNode = function(ar) {
      switch (ar.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(ar);
          break;
        case "text":
          this.renderTextNode(ar);
          break;
        case "html":
          this.renderRawHtmlNode(ar);
          break;
      }
    }, cr.prototype.generateOpenTagString = function(ar) {
      var lr = this, ur = ar.tagName, dr = ar.classNames, fr = ar.attributes;
      this.buffer.push("<" + ur), dr && dr.length > 0 && this.buffer.push(' class="' + dr.join(" ") + '"'), fr && Object.keys(fr).forEach(function(gr) {
        var mr = fr[gr];
        lr.buffer.push(" " + gr + '="' + mr + '"');
      }), ar.selfClose && this.buffer.push(" /"), this.buffer.push(">");
    }, cr.prototype.generateCloseTagString = function(ar) {
      var lr = ar.tagName;
      this.buffer.push("</" + lr + ">");
    }, cr.prototype.addNewLine = function() {
      this.buffer.length && last(last(this.buffer)) !== `
` && this.buffer.push(`
`);
    }, cr.prototype.addOuterNewLine = function(ar) {
      ar.outerNewLine && this.addNewLine();
    }, cr.prototype.addInnerNewLine = function(ar) {
      ar.innerNewLine && this.addNewLine();
    }, cr.prototype.renderTextNode = function(ar) {
      this.buffer.push(escapeXml(ar.content));
    }, cr.prototype.renderRawHtmlNode = function(ar) {
      this.addOuterNewLine(ar), this.buffer.push(ar.content), this.addOuterNewLine(ar);
    }, cr.prototype.renderElementNode = function(ar) {
      ar.type === "openTag" ? (this.addOuterNewLine(ar), this.generateOpenTagString(ar), ar.selfClose ? this.addOuterNewLine(ar) : this.addInnerNewLine(ar)) : (this.addInnerNewLine(ar), this.generateCloseTagString(ar), this.addOuterNewLine(ar));
    }, cr;
  }()
);
/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
function _toConsumableArray(cr) {
  if (Array.isArray(cr)) {
    for (var ar = 0, lr = Array(cr.length); ar < cr.length; ar++)
      lr[ar] = cr[ar];
    return lr;
  } else
    return Array.from(cr);
}
var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf$1 = Object.setPrototypeOf, isFrozen$1 = Object.isFrozen, getPrototypeOf$1 = Object.getPrototypeOf, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, freeze$1 = Object.freeze, seal$1 = Object.seal, create$1 = Object.create, _ref = typeof Reflect != "undefined" && Reflect, apply$1 = _ref.apply, construct$1 = _ref.construct;
apply$1 || (apply$1 = function(ar, lr, ur) {
  return ar.apply(lr, ur);
});
freeze$1 || (freeze$1 = function(ar) {
  return ar;
});
seal$1 || (seal$1 = function(ar) {
  return ar;
});
construct$1 || (construct$1 = function(ar, lr) {
  return new (Function.prototype.bind.apply(ar, [null].concat(_toConsumableArray(lr))))();
});
var arrayForEach$1 = unapply$1(Array.prototype.forEach), arrayPop$1 = unapply$1(Array.prototype.pop), arrayPush$1 = unapply$1(Array.prototype.push), stringToLowerCase$1 = unapply$1(String.prototype.toLowerCase), stringMatch$1 = unapply$1(String.prototype.match), stringReplace$1 = unapply$1(String.prototype.replace), stringIndexOf$1 = unapply$1(String.prototype.indexOf), stringTrim$1 = unapply$1(String.prototype.trim), regExpTest$1 = unapply$1(RegExp.prototype.test), typeErrorCreate$1 = unconstruct$1(TypeError);
function unapply$1(cr) {
  return function(ar) {
    for (var lr = arguments.length, ur = Array(lr > 1 ? lr - 1 : 0), dr = 1; dr < lr; dr++)
      ur[dr - 1] = arguments[dr];
    return apply$1(cr, ar, ur);
  };
}
function unconstruct$1(cr) {
  return function() {
    for (var ar = arguments.length, lr = Array(ar), ur = 0; ur < ar; ur++)
      lr[ur] = arguments[ur];
    return construct$1(cr, lr);
  };
}
function addToSet$1(cr, ar) {
  setPrototypeOf$1 && setPrototypeOf$1(cr, null);
  for (var lr = ar.length; lr--; ) {
    var ur = ar[lr];
    if (typeof ur == "string") {
      var dr = stringToLowerCase$1(ur);
      dr !== ur && (isFrozen$1(ar) || (ar[lr] = dr), ur = dr);
    }
    cr[ur] = !0;
  }
  return cr;
}
function clone$1(cr) {
  var ar = create$1(null), lr = void 0;
  for (lr in cr)
    apply$1(hasOwnProperty, cr, [lr]) && (ar[lr] = cr[lr]);
  return ar;
}
function lookupGetter$1(cr, ar) {
  for (; cr !== null; ) {
    var lr = getOwnPropertyDescriptor$1(cr, ar);
    if (lr) {
      if (lr.get)
        return unapply$1(lr.get);
      if (typeof lr.value == "function")
        return unapply$1(lr.value);
    }
    cr = getPrototypeOf$1(cr);
  }
  function ur(dr) {
    return console.warn("fallback value for", dr), null;
  }
  return ur;
}
var html$2$1 = freeze$1(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$2 = freeze$1(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters$1 = freeze$1(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed$1 = freeze$1(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$2 = freeze$1(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), mathMlDisallowed$1 = freeze$1(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$2 = freeze$1(["#text"]), html$1$1 = freeze$1(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg$1$1 = freeze$1(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl$1$1 = freeze$1(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml$1 = freeze$1(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR$1 = seal$1(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ERB_EXPR$1 = seal$1(/<%[\s\S]*|[\s\S]*%>/gm), DATA_ATTR$1 = seal$1(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR$1 = seal$1(/^aria-[\-\w]+$/), IS_ALLOWED_URI$1 = seal$1(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA$1 = seal$1(/^(?:\w+script|data):/i), ATTR_WHITESPACE$1 = seal$1(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(cr) {
  return typeof cr;
} : function(cr) {
  return cr && typeof Symbol == "function" && cr.constructor === Symbol && cr !== Symbol.prototype ? "symbol" : typeof cr;
};
function _toConsumableArray$1(cr) {
  if (Array.isArray(cr)) {
    for (var ar = 0, lr = Array(cr.length); ar < cr.length; ar++)
      lr[ar] = cr[ar];
    return lr;
  } else
    return Array.from(cr);
}
var getGlobal$1 = function cr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy$1 = function cr(ar, lr) {
  if ((typeof ar == "undefined" ? "undefined" : _typeof(ar)) !== "object" || typeof ar.createPolicy != "function")
    return null;
  var ur = null, dr = "data-tt-policy-suffix";
  lr.currentScript && lr.currentScript.hasAttribute(dr) && (ur = lr.currentScript.getAttribute(dr));
  var fr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(fr, {
      createHTML: function(mr) {
        return mr;
      }
    });
  } catch (gr) {
    return console.warn("TrustedTypes policy " + fr + " could not be created."), null;
  }
};
function createDOMPurify$1() {
  var cr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal$1(), ar = function(ri) {
    return createDOMPurify$1(ri);
  };
  if (ar.version = "2.3.3", ar.removed = [], !cr || !cr.document || cr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  var lr = cr.document, ur = cr.document, dr = cr.DocumentFragment, fr = cr.HTMLTemplateElement, gr = cr.Node, mr = cr.Element, vr = cr.NodeFilter, yr = cr.NamedNodeMap, _r = yr === void 0 ? cr.NamedNodeMap || cr.MozNamedAttrMap : yr, kr = cr.Text, xr = cr.Comment, Ar = cr.DOMParser, Er = cr.trustedTypes, Cr = mr.prototype, Tr = lookupGetter$1(Cr, "cloneNode"), Sr = lookupGetter$1(Cr, "nextSibling"), Lr = lookupGetter$1(Cr, "childNodes"), Ir = lookupGetter$1(Cr, "parentNode");
  if (typeof fr == "function") {
    var Nr = ur.createElement("template");
    Nr.content && Nr.content.ownerDocument && (ur = Nr.content.ownerDocument);
  }
  var Rr = _createTrustedTypesPolicy$1(Er, lr), Mr = Rr && Hi ? Rr.createHTML("") : "", Br = ur, Dr = Br.implementation, Hr = Br.createNodeIterator, Fr = Br.createDocumentFragment, zr = Br.getElementsByTagName, Ur = lr.importNode, jr = {};
  try {
    jr = clone$1(ur).documentMode ? ur.documentMode : {};
  } catch (Ni) {
  }
  var Yr = {};
  ar.isSupported = typeof Ir == "function" && Dr && typeof Dr.createHTMLDocument != "undefined" && jr !== 9;
  var qr = MUSTACHE_EXPR$1, Wr = ERB_EXPR$1, Jr = DATA_ATTR$1, Gr = ARIA_ATTR$1, Vr = IS_SCRIPT_OR_DATA$1, Qr = ATTR_WHITESPACE$1, $r = IS_ALLOWED_URI$1, Xr = null, si = addToSet$1({}, [].concat(_toConsumableArray$1(html$2$1), _toConsumableArray$1(svg$2), _toConsumableArray$1(svgFilters$1), _toConsumableArray$1(mathMl$2), _toConsumableArray$1(text$2))), Zr = null, li = addToSet$1({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1$1), _toConsumableArray$1(mathMl$1$1), _toConsumableArray$1(xml$1))), Ei = null, ki = null, Di = !0, hi = !0, Ti = !1, fi = !1, Mi = !1, oi = !1, Ri = !1, qi = !1, zi = !1, to = !0, Hi = !1, _i = !0, Ai = !0, ui = !1, ji = {}, ai = null, Li = addToSet$1({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), $i = null, Wi = addToSet$1({}, ["audio", "video", "img", "source", "image", "track"]), io = null, ro = addToSet$1({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mi = "http://www.w3.org/1998/Math/MathML", di = "http://www.w3.org/2000/svg", yi = "http://www.w3.org/1999/xhtml", Bi = yi, Ii = !1, Fi = void 0, eo = ["application/xhtml+xml", "text/html"], Ui = "text/html", Vi = void 0, Gi = null, bi = ur.createElement("form"), Ji = function(ri) {
    Gi && Gi === ri || ((!ri || (typeof ri == "undefined" ? "undefined" : _typeof(ri)) !== "object") && (ri = {}), ri = clone$1(ri), Xr = "ALLOWED_TAGS" in ri ? addToSet$1({}, ri.ALLOWED_TAGS) : si, Zr = "ALLOWED_ATTR" in ri ? addToSet$1({}, ri.ALLOWED_ATTR) : li, io = "ADD_URI_SAFE_ATTR" in ri ? addToSet$1(clone$1(ro), ri.ADD_URI_SAFE_ATTR) : ro, $i = "ADD_DATA_URI_TAGS" in ri ? addToSet$1(clone$1(Wi), ri.ADD_DATA_URI_TAGS) : Wi, ai = "FORBID_CONTENTS" in ri ? addToSet$1({}, ri.FORBID_CONTENTS) : Li, Ei = "FORBID_TAGS" in ri ? addToSet$1({}, ri.FORBID_TAGS) : {}, ki = "FORBID_ATTR" in ri ? addToSet$1({}, ri.FORBID_ATTR) : {}, ji = "USE_PROFILES" in ri ? ri.USE_PROFILES : !1, Di = ri.ALLOW_ARIA_ATTR !== !1, hi = ri.ALLOW_DATA_ATTR !== !1, Ti = ri.ALLOW_UNKNOWN_PROTOCOLS || !1, fi = ri.SAFE_FOR_TEMPLATES || !1, Mi = ri.WHOLE_DOCUMENT || !1, qi = ri.RETURN_DOM || !1, zi = ri.RETURN_DOM_FRAGMENT || !1, to = ri.RETURN_DOM_IMPORT !== !1, Hi = ri.RETURN_TRUSTED_TYPE || !1, Ri = ri.FORCE_BODY || !1, _i = ri.SANITIZE_DOM !== !1, Ai = ri.KEEP_CONTENT !== !1, ui = ri.IN_PLACE || !1, $r = ri.ALLOWED_URI_REGEXP || $r, Bi = ri.NAMESPACE || yi, Fi = // eslint-disable-next-line unicorn/prefer-includes
    eo.indexOf(ri.PARSER_MEDIA_TYPE) === -1 ? Fi = Ui : Fi = ri.PARSER_MEDIA_TYPE, Vi = Fi === "application/xhtml+xml" ? function(vi) {
      return vi;
    } : stringToLowerCase$1, fi && (hi = !1), zi && (qi = !0), ji && (Xr = addToSet$1({}, [].concat(_toConsumableArray$1(text$2))), Zr = [], ji.html === !0 && (addToSet$1(Xr, html$2$1), addToSet$1(Zr, html$1$1)), ji.svg === !0 && (addToSet$1(Xr, svg$2), addToSet$1(Zr, svg$1$1), addToSet$1(Zr, xml$1)), ji.svgFilters === !0 && (addToSet$1(Xr, svgFilters$1), addToSet$1(Zr, svg$1$1), addToSet$1(Zr, xml$1)), ji.mathMl === !0 && (addToSet$1(Xr, mathMl$2), addToSet$1(Zr, mathMl$1$1), addToSet$1(Zr, xml$1))), ri.ADD_TAGS && (Xr === si && (Xr = clone$1(Xr)), addToSet$1(Xr, ri.ADD_TAGS)), ri.ADD_ATTR && (Zr === li && (Zr = clone$1(Zr)), addToSet$1(Zr, ri.ADD_ATTR)), ri.ADD_URI_SAFE_ATTR && addToSet$1(io, ri.ADD_URI_SAFE_ATTR), ri.FORBID_CONTENTS && (ai === Li && (ai = clone$1(ai)), addToSet$1(ai, ri.FORBID_CONTENTS)), Ai && (Xr["#text"] = !0), Mi && addToSet$1(Xr, ["html", "head", "body"]), Xr.table && (addToSet$1(Xr, ["tbody"]), delete Ei.tbody), freeze$1 && freeze$1(ri), Gi = ri);
  }, oo = addToSet$1({}, ["mi", "mo", "mn", "ms", "mtext"]), ci = addToSet$1({}, ["foreignobject", "desc", "title", "annotation-xml"]), wi = addToSet$1({}, svg$2);
  addToSet$1(wi, svgFilters$1), addToSet$1(wi, svgDisallowed$1);
  var Qi = addToSet$1({}, mathMl$2);
  addToSet$1(Qi, mathMlDisallowed$1);
  var ao = function(ri) {
    var vi = Ir(ri);
    (!vi || !vi.tagName) && (vi = {
      namespaceURI: yi,
      tagName: "template"
    });
    var Oi = stringToLowerCase$1(ri.tagName), Yi = stringToLowerCase$1(vi.tagName);
    if (ri.namespaceURI === di)
      return vi.namespaceURI === yi ? Oi === "svg" : vi.namespaceURI === mi ? Oi === "svg" && (Yi === "annotation-xml" || oo[Yi]) : !!wi[Oi];
    if (ri.namespaceURI === mi)
      return vi.namespaceURI === yi ? Oi === "math" : vi.namespaceURI === di ? Oi === "math" && ci[Yi] : !!Qi[Oi];
    if (ri.namespaceURI === yi) {
      if (vi.namespaceURI === di && !ci[Yi] || vi.namespaceURI === mi && !oo[Yi])
        return !1;
      var Ci = addToSet$1({}, ["title", "style", "font", "a", "script"]);
      return !Qi[Oi] && (Ci[Oi] || !wi[Oi]);
    }
    return !1;
  }, co = function(ri) {
    arrayPush$1(ar.removed, { element: ri });
    try {
      ri.parentNode.removeChild(ri);
    } catch (vi) {
      try {
        ri.outerHTML = Mr;
      } catch (Oi) {
        ri.remove();
      }
    }
  }, bo = function(ri, vi) {
    try {
      arrayPush$1(ar.removed, {
        attribute: vi.getAttributeNode(ri),
        from: vi
      });
    } catch (Oi) {
      arrayPush$1(ar.removed, {
        attribute: null,
        from: vi
      });
    }
    if (vi.removeAttribute(ri), ri === "is" && !Zr[ri])
      if (qi || zi)
        try {
          co(vi);
        } catch (Oi) {
        }
      else
        try {
          vi.setAttribute(ri, "");
        } catch (Oi) {
        }
  }, _o = function(ri) {
    var vi = void 0, Oi = void 0;
    if (Ri)
      ri = "<remove></remove>" + ri;
    else {
      var Yi = stringMatch$1(ri, /^[\r\n\t ]+/);
      Oi = Yi && Yi[0];
    }
    Fi === "application/xhtml+xml" && (ri = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ri + "</body></html>");
    var Ci = Rr ? Rr.createHTML(ri) : ri;
    if (Bi === yi)
      try {
        vi = new Ar().parseFromString(Ci, Fi);
      } catch (gi) {
      }
    if (!vi || !vi.documentElement) {
      vi = Dr.createDocument(Bi, "template", null);
      try {
        vi.documentElement.innerHTML = Ii ? "" : Ci;
      } catch (gi) {
      }
    }
    var ei = vi.body || vi.documentElement;
    return ri && Oi && ei.insertBefore(ur.createTextNode(Oi), ei.childNodes[0] || null), Bi === yi ? zr.call(vi, Mi ? "html" : "body")[0] : Mi ? vi.documentElement : ei;
  }, ko = function(ri) {
    return Hr.call(ri.ownerDocument || ri, ri, vr.SHOW_ELEMENT | vr.SHOW_COMMENT | vr.SHOW_TEXT, null, !1);
  }, vo = function(ri) {
    return ri instanceof kr || ri instanceof xr ? !1 : typeof ri.nodeName != "string" || typeof ri.textContent != "string" || typeof ri.removeChild != "function" || !(ri.attributes instanceof _r) || typeof ri.removeAttribute != "function" || typeof ri.setAttribute != "function" || typeof ri.namespaceURI != "string" || typeof ri.insertBefore != "function";
  }, yo = function(ri) {
    return (typeof gr == "undefined" ? "undefined" : _typeof(gr)) === "object" ? ri instanceof gr : ri && (typeof ri == "undefined" ? "undefined" : _typeof(ri)) === "object" && typeof ri.nodeType == "number" && typeof ri.nodeName == "string";
  }, fo = function(ri, vi, Oi) {
    Yr[ri] && arrayForEach$1(Yr[ri], function(Yi) {
      Yi.call(ar, vi, Oi, Gi);
    });
  }, To = function(ri) {
    var vi = void 0;
    if (fo("beforeSanitizeElements", ri, null), vo(ri) || stringMatch$1(ri.nodeName, /[\u0080-\uFFFF]/))
      return co(ri), !0;
    var Oi = Vi(ri.nodeName);
    if (fo("uponSanitizeElement", ri, {
      tagName: Oi,
      allowedTags: Xr
    }), !yo(ri.firstElementChild) && (!yo(ri.content) || !yo(ri.content.firstElementChild)) && regExpTest$1(/<[/\w]/g, ri.innerHTML) && regExpTest$1(/<[/\w]/g, ri.textContent) || Oi === "select" && regExpTest$1(/<template/i, ri.innerHTML))
      return co(ri), !0;
    if (!Xr[Oi] || Ei[Oi]) {
      if (Ai && !ai[Oi]) {
        var Yi = Ir(ri) || ri.parentNode, Ci = Lr(ri) || ri.childNodes;
        if (Ci && Yi)
          for (var ei = Ci.length, gi = ei - 1; gi >= 0; --gi)
            Yi.insertBefore(Tr(Ci[gi], !0), Sr(ri));
      }
      return co(ri), !0;
    }
    return ri instanceof mr && !ao(ri) || (Oi === "noscript" || Oi === "noembed") && regExpTest$1(/<\/no(script|embed)/i, ri.innerHTML) ? (co(ri), !0) : (fi && ri.nodeType === 3 && (vi = ri.textContent, vi = stringReplace$1(vi, qr, " "), vi = stringReplace$1(vi, Wr, " "), ri.textContent !== vi && (arrayPush$1(ar.removed, { element: ri.cloneNode() }), ri.textContent = vi)), fo("afterSanitizeElements", ri, null), !1);
  }, Io = function(ri, vi, Oi) {
    if (_i && (vi === "id" || vi === "name") && (Oi in ur || Oi in bi))
      return !1;
    if (!(hi && !ki[vi] && regExpTest$1(Jr, vi))) {
      if (!(Di && regExpTest$1(Gr, vi))) {
        if (!Zr[vi] || ki[vi])
          return !1;
        if (!io[vi]) {
          if (!regExpTest$1($r, stringReplace$1(Oi, Qr, ""))) {
            if (!((vi === "src" || vi === "xlink:href" || vi === "href") && ri !== "script" && stringIndexOf$1(Oi, "data:") === 0 && $i[ri])) {
              if (!(Ti && !regExpTest$1(Vr, stringReplace$1(Oi, Qr, "")))) {
                if (Oi)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, So = function(ri) {
    var vi = void 0, Oi = void 0, Yi = void 0, Ci = void 0;
    fo("beforeSanitizeAttributes", ri, null);
    var ei = ri.attributes;
    if (ei) {
      var gi = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Zr
      };
      for (Ci = ei.length; Ci--; ) {
        vi = ei[Ci];
        var Si = vi, Zi = Si.name, lo = Si.namespaceURI;
        if (Oi = stringTrim$1(vi.value), Yi = Vi(Zi), gi.attrName = Yi, gi.attrValue = Oi, gi.keepAttr = !0, gi.forceKeepAttr = void 0, fo("uponSanitizeAttribute", ri, gi), Oi = gi.attrValue, !gi.forceKeepAttr && (bo(Zi, ri), !!gi.keepAttr)) {
          if (regExpTest$1(/\/>/i, Oi)) {
            bo(Zi, ri);
            continue;
          }
          fi && (Oi = stringReplace$1(Oi, qr, " "), Oi = stringReplace$1(Oi, Wr, " "));
          var uo = Vi(ri.nodeName);
          if (Io(uo, Yi, Oi))
            try {
              lo ? ri.setAttributeNS(lo, Zi, Oi) : ri.setAttribute(Zi, Oi), arrayPop$1(ar.removed);
            } catch (ho) {
            }
        }
      }
      fo("afterSanitizeAttributes", ri, null);
    }
  }, po = function Ni(ri) {
    var vi = void 0, Oi = ko(ri);
    for (fo("beforeSanitizeShadowDOM", ri, null); vi = Oi.nextNode(); )
      fo("uponSanitizeShadowNode", vi, null), !To(vi) && (vi.content instanceof dr && Ni(vi.content), So(vi));
    fo("afterSanitizeShadowDOM", ri, null);
  };
  return ar.sanitize = function(Ni, ri) {
    var vi = void 0, Oi = void 0, Yi = void 0, Ci = void 0, ei = void 0;
    if (Ii = !Ni, Ii && (Ni = "<!-->"), typeof Ni != "string" && !yo(Ni)) {
      if (typeof Ni.toString != "function")
        throw typeErrorCreate$1("toString is not a function");
      if (Ni = Ni.toString(), typeof Ni != "string")
        throw typeErrorCreate$1("dirty is not a string, aborting");
    }
    if (!ar.isSupported) {
      if (_typeof(cr.toStaticHTML) === "object" || typeof cr.toStaticHTML == "function") {
        if (typeof Ni == "string")
          return cr.toStaticHTML(Ni);
        if (yo(Ni))
          return cr.toStaticHTML(Ni.outerHTML);
      }
      return Ni;
    }
    if (oi || Ji(ri), ar.removed = [], typeof Ni == "string" && (ui = !1), !ui)
      if (Ni instanceof gr)
        vi = _o("<!---->"), Oi = vi.ownerDocument.importNode(Ni, !0), Oi.nodeType === 1 && Oi.nodeName === "BODY" || Oi.nodeName === "HTML" ? vi = Oi : vi.appendChild(Oi);
      else {
        if (!qi && !fi && !Mi && // eslint-disable-next-line unicorn/prefer-includes
        Ni.indexOf("<") === -1)
          return Rr && Hi ? Rr.createHTML(Ni) : Ni;
        if (vi = _o(Ni), !vi)
          return qi ? null : Mr;
      }
    vi && Ri && co(vi.firstChild);
    for (var gi = ko(ui ? Ni : vi); Yi = gi.nextNode(); )
      Yi.nodeType === 3 && Yi === Ci || To(Yi) || (Yi.content instanceof dr && po(Yi.content), So(Yi), Ci = Yi);
    if (Ci = null, ui)
      return Ni;
    if (qi) {
      if (zi)
        for (ei = Fr.call(vi.ownerDocument); vi.firstChild; )
          ei.appendChild(vi.firstChild);
      else
        ei = vi;
      return to && (ei = Ur.call(lr, ei, !0)), ei;
    }
    var Si = Mi ? vi.outerHTML : vi.innerHTML;
    return fi && (Si = stringReplace$1(Si, qr, " "), Si = stringReplace$1(Si, Wr, " ")), Rr && Hi ? Rr.createHTML(Si) : Si;
  }, ar.setConfig = function(Ni) {
    Ji(Ni), oi = !0;
  }, ar.clearConfig = function() {
    Gi = null, oi = !1;
  }, ar.isValidAttribute = function(Ni, ri, vi) {
    Gi || Ji({});
    var Oi = Vi(Ni), Yi = Vi(ri);
    return Io(Oi, Yi, vi);
  }, ar.addHook = function(Ni, ri) {
    typeof ri == "function" && (Yr[Ni] = Yr[Ni] || [], arrayPush$1(Yr[Ni], ri));
  }, ar.removeHook = function(Ni) {
    Yr[Ni] && arrayPop$1(Yr[Ni]);
  }, ar.removeHooks = function(Ni) {
    Yr[Ni] && (Yr[Ni] = []);
  }, ar.removeAllHooks = function() {
    Yr = {};
  }, ar;
}
var purify$1 = createDOMPurify$1(), CAN_BE_WHITE_TAG_LIST = ["iframe", "embed"], whiteTagList = [];
function registerTagWhitelistIfPossible(cr) {
  includes(CAN_BE_WHITE_TAG_LIST, cr) && whiteTagList.push(cr.toLowerCase());
}
function sanitizeHTML(cr, ar) {
  return purify$1.sanitize(cr, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, ar));
}
function getChildrenHTML(cr, ar) {
  return cr.literal.replace(new RegExp("(<\\s*" + ar + "[^>]*>)|(</" + ar + "\\s*[>])", "ig"), "").trim();
}
function getHTMLAttrsByHTMLString(cr) {
  cr = cr.match(reHTMLTag)[0];
  var ar = cr.match(new RegExp(ATTRIBUTE$1, "g"));
  return ar ? ar.reduce(function(lr, ur) {
    var dr = ur.trim().split("="), fr = dr[0], gr = dr.slice(1);
    return gr.length && (lr[fr] = gr.join("=").replace(/'|"/g, "").trim()), lr;
  }, {}) : {};
}
function getHTMLAttrs(cr) {
  return toArray_1(cr.attributes).reduce(function(ar, lr) {
    return ar[lr.nodeName] = lr.nodeValue, ar;
  }, {});
}
function sanitizeDOM(cr, ar, lr, ur) {
  var dr = ur.getToDOMNode(ar)(cr), fr = lr(dr.outerHTML), gr = document.createElement("div");
  gr.innerHTML = fr, dr = gr.firstChild;
  var mr = getHTMLAttrs(dr);
  return { dom: dr, htmlAttrs: mr };
}
var schemaFactory = {
  htmlBlock: function(cr, ar, lr) {
    return {
      atom: !0,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: !0 }
      },
      parseDOM: [
        {
          tag: cr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur),
              childrenHTML: ur.innerHTML
            };
          }
        }
      ],
      toDOM: function(ur) {
        var dr = sanitizeDOM(ur, cr, ar, lr), fr = dr.dom, gr = dr.htmlAttrs;
        return gr.class = gr.class ? gr.class + " html-block" : "html-block", __spreadArray$1([cr, gr], toArray_1(fr.childNodes));
      }
    };
  },
  htmlInline: function(cr, ar, lr) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: !0 }
      },
      parseDOM: [
        {
          tag: cr,
          getAttrs: function(ur) {
            return {
              htmlAttrs: getHTMLAttrs(ur)
            };
          }
        }
      ],
      toDOM: function(ur) {
        var dr = sanitizeDOM(ur, cr, ar, lr).htmlAttrs;
        return [cr, dr, 0];
      }
    };
  }
};
function createHTMLSchemaMap(cr, ar, lr) {
  var ur = { nodes: {}, marks: {} };
  return ["htmlBlock", "htmlInline"].forEach(function(dr) {
    cr[dr] && Object.keys(cr[dr]).forEach(function(fr) {
      var gr = dr === "htmlBlock" ? "nodes" : "marks";
      registerTagWhitelistIfPossible(fr), ur[gr][fr] = schemaFactory[dr](fr, ar, lr);
    });
  }), ur;
}
var reCloseTag = /^\s*<\s*\//, baseConvertors = {
  paragraph: function(cr, ar) {
    var lr = ar.entering, ur = ar.origin, dr = ar.options;
    return dr.nodeId ? {
      type: lr ? "openTag" : "closeTag",
      outerNewLine: !0,
      tagName: "p"
    } : ur();
  },
  softbreak: function(cr) {
    var ar = cr.prev && cr.prev.type === "htmlInline", lr = ar && /<br ?\/?>/.test(cr.prev.literal), ur = lr ? `
` : `<br>
`;
    return { type: "html", content: ur };
  },
  item: function(cr, ar) {
    var lr = ar.entering;
    if (lr) {
      var ur = {}, dr = [];
      return cr.listData.task && (ur["data-task"] = "", dr.push("task-list-item"), cr.listData.checked && (dr.push("checked"), ur["data-task-checked"] = "")), {
        type: "openTag",
        tagName: "li",
        classNames: dr,
        attributes: ur,
        outerNewLine: !0
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  code: function(cr) {
    var ar = { "data-backticks": String(cr.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes: ar },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(cr) {
    var ar = cr, lr = ar.fenceLength, ur = ar.info, dr = ur ? ur.split(/\s+/) : [], fr = [], gr = {};
    if (lr > 3 && (gr["data-backticks"] = lr), dr.length > 0 && dr[0].length > 0) {
      var mr = dr[0];
      fr.push("lang-" + mr), gr["data-language"] = mr;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: fr },
      { type: "openTag", tagName: "code", attributes: gr },
      { type: "text", content: cr.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(cr, ar) {
    var lr = ar.origin, ur = ar.entering, dr = ar.skipChildren, fr = cr.info;
    if (fr.indexOf("widget") !== -1 && ur) {
      dr();
      var gr = getWidgetContent(cr), mr = widgetToDOM(fr, gr).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: mr },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return lr();
  }
};
function getHTMLRenderConvertors(cr, ar) {
  var lr = __assign$1({}, baseConvertors);
  return cr && (lr.link = function(ur, dr) {
    var fr = dr.entering, gr = dr.origin, mr = gr();
    return fr && (mr.attributes = __assign$1(__assign$1({}, mr.attributes), cr)), mr;
  }), ar && Object.keys(ar).forEach(function(ur) {
    var dr = lr[ur], fr = ar[ur];
    dr && isFunction_1(fr) ? lr[ur] = function(gr, mr) {
      var vr = __assign$1({}, mr);
      return vr.origin = function() {
        return dr(gr, mr);
      }, fr(gr, vr);
    } : includes(["htmlBlock", "htmlInline"], ur) && !isFunction_1(fr) ? lr[ur] = function(gr, mr) {
      var vr = gr.literal.match(reHTMLTag);
      if (vr) {
        var yr = vr[0], _r = vr[1], kr = vr[3], xr = (_r || kr).toLowerCase(), Ar = fr[xr], Er = getChildrenHTML(gr, xr);
        if (Ar) {
          var Cr = __assign$1({}, gr);
          return Cr.attrs = getHTMLAttrsByHTMLString(yr), Cr.childrenHTML = Er, Cr.type = xr, mr.entering = !reCloseTag.test(gr.literal), Ar(Cr, mr);
        }
      }
      return mr.origin();
    } : lr[ur] = fr;
  }), lr;
}
var nestableTypes = ["list", "item", "blockQuote"], nestableTagNames = ["UL", "OL", "BLOCKQUOTE"];
function isBlankLine(cr, ar) {
  var lr, ur = cr.child(ar);
  return !ur.childCount || ur.childCount === 1 && !(!((lr = ur.firstChild.text) === null || lr === void 0) && lr.trim());
}
function getEditorRangeHeightInfo(cr, ar, lr) {
  var ur = getMdStartLine(ar) - 1, dr = getMdEndLine(ar) - 1, fr = lr[ur].getBoundingClientRect(), gr = lr[dr].offsetTop - lr[ur].offsetTop + lr[dr].clientHeight;
  return {
    height: gr <= 0 ? lr[ur].clientHeight : gr + getBlankLinesHeight(cr, lr, Math.min(dr + 1, cr.childCount - 1)),
    rect: fr
  };
}
function getBlankLinesHeight(cr, ar, lr) {
  for (var ur = cr.childCount - 1, dr = 0; lr <= ur && isBlankLine(cr, lr); )
    dr += ar[lr].clientHeight, lr += 1;
  return dr;
}
function findAncestorHavingId(cr, ar) {
  for (; !cr.getAttribute("data-nodeid") && cr.parentElement !== ar; )
    cr = cr.parentElement;
  return cr;
}
function getTotalOffsetTop(cr, ar) {
  for (var lr = 0; cr && cr !== ar && (includes(nestableTagNames, cr.tagName) || (lr += cr.offsetTop), cr.offsetParent !== ar.offsetParent); )
    cr = cr.parentElement;
  return lr;
}
function findAdjacentElementToScrollTop(cr, ar) {
  for (var lr = ar, ur = null; lr; ) {
    var dr = lr.firstElementChild;
    if (!dr)
      break;
    var fr = findLastSiblingElementToScrollTop(dr, cr, getTotalOffsetTop(lr, ar));
    ur = lr, lr = fr;
  }
  var gr = lr || ur;
  return gr === ar ? null : gr;
}
function findLastSiblingElementToScrollTop(cr, ar, lr) {
  return cr && ar > lr + cr.offsetTop ? findLastSiblingElementToScrollTop(cr.nextElementSibling, ar, lr) || cr : null;
}
function getAdditionalPos(cr, ar, lr, ur) {
  var dr = Math.min((cr - ar) / lr, 1);
  return dr * ur;
}
function getParentNodeObj(cr, ar) {
  for (var lr = cr.querySelector('[data-nodeid="' + ar.id + '"]'); !lr || isStyledInlineNode(ar); )
    ar = ar.parent, lr = cr.querySelector('[data-nodeid="' + ar.id + '"]');
  return getNonNestableNodeObj({ mdNode: ar, el: lr });
}
function getNonNestableNodeObj(cr) {
  for (var ar = cr.mdNode, lr = cr.el; (includes(nestableTypes, ar.type) || ar.type === "table") && ar.firstChild; )
    ar = ar.firstChild, lr = lr.firstElementChild;
  return { mdNode: ar, el: lr };
}
var offsetInfoMap = {};
function setHeight(cr, ar) {
  offsetInfoMap[cr] = offsetInfoMap[cr] || {}, offsetInfoMap[cr].height = ar;
}
function setOffsetTop(cr, ar) {
  offsetInfoMap[cr] = offsetInfoMap[cr] || {}, offsetInfoMap[cr].offsetTop = ar;
}
function getHeight(cr) {
  return offsetInfoMap[cr] && offsetInfoMap[cr].height;
}
function getOffsetTop(cr) {
  return offsetInfoMap[cr] && offsetInfoMap[cr].offsetTop;
}
function removeOffsetInfoByNode(cr) {
  cr && (delete offsetInfoMap[Number(cr.getAttribute("data-nodeid"))], toArray_1(cr.children).forEach(function(ar) {
    removeOffsetInfoByNode(ar);
  }));
}
function getAndSaveOffsetInfo(cr, ar, lr) {
  var ur = getHeight(lr), dr = getOffsetTop(lr), fr = ur || cr.clientHeight, gr = dr || getTotalOffsetTop(cr, ar) || cr.offsetTop;
  return ur || setHeight(lr, fr), dr || setOffsetTop(lr, gr), { nodeHeight: fr, offsetTop: gr };
}
var CLASS_HIGHLIGHT = cls("md-preview-highlight");
function findTableCell(cr, ar) {
  for (var lr = cr.firstChild; lr && lr.next && !(getMdStartCh(lr.next) > ar + 1); )
    lr = lr.next;
  return lr;
}
var MarkdownPreview = (
  /** @class */
  function() {
    function cr(ar, lr) {
      var ur = document.createElement("div");
      this.el = ur, this.eventEmitter = ar, this.isViewer = !!lr.isViewer, this.el.className = cls("md-preview");
      var dr = lr.linkAttributes, fr = lr.customHTMLRenderer, gr = lr.sanitizer, mr = lr.highlight, vr = mr === void 0 ? !1 : mr;
      this.renderer = new Renderer({
        gfm: !0,
        nodeId: !0,
        convertors: getHTMLRenderConvertors(dr, fr)
      }), this.cursorNodeId = null, this.sanitizer = gr, this.initEvent(vr), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
    }
    return cr.prototype.initContentSection = function() {
      this.previewContent = createElementWith('<div class="' + cls("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
    }, cr.prototype.toggleActive = function(ar) {
      toggleClass(this.el, "active", ar);
    }, cr.prototype.initEvent = function(ar) {
      var lr = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (ar && (this.eventEmitter.listen("changeToolbarState", function(ur) {
        var dr = ur.mdNode, fr = ur.cursorPos;
        lr.updateCursorNode(dr, fr);
      }), this.eventEmitter.listen("blur", function() {
        lr.removeHighlight();
      })), on_1(this.el, "scroll", function(ur) {
        lr.eventEmitter.emit("scroll", "preview", findAdjacentElementToScrollTop(ur.target.scrollTop, lr.previewContent));
      }), this.eventEmitter.listen("changePreviewTabPreview", function() {
        return lr.toggleActive(!0);
      }), this.eventEmitter.listen("changePreviewTabWrite", function() {
        return lr.toggleActive(!1);
      }));
    }, cr.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var ar = this.getElementByNodeId(this.cursorNodeId);
        ar && removeClass_1(ar, CLASS_HIGHLIGHT);
      }
    }, cr.prototype.updateCursorNode = function(ar, lr) {
      ar && (ar = findClosestNode(ar, function(gr) {
        return !isInlineNode$1(gr);
      }), ar.type === "tableRow" ? ar = findTableCell(ar, lr[1]) : ar.type === "tableBody" && (ar = null));
      var ur = ar ? ar.id : null;
      if (this.cursorNodeId !== ur) {
        var dr = this.getElementByNodeId(this.cursorNodeId), fr = this.getElementByNodeId(ur);
        dr && removeClass_1(dr, CLASS_HIGHLIGHT), fr && addClass_1(fr, CLASS_HIGHLIGHT), this.cursorNodeId = ur;
      }
    }, cr.prototype.getElementByNodeId = function(ar) {
      return ar ? this.previewContent.querySelector('[data-nodeid="' + ar + '"]') : null;
    }, cr.prototype.update = function(ar) {
      var lr = this;
      ar.forEach(function(ur) {
        return lr.replaceRangeNodes(ur);
      }), this.eventEmitter.emit("afterPreviewRender", this);
    }, cr.prototype.replaceRangeNodes = function(ar) {
      var lr = this, ur = ar.nodes, dr = ar.removedNodeRange, fr = this.previewContent, gr = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(ur.map(function(Er) {
        return lr.renderer.render(Er);
      }).join("")));
      if (!dr)
        fr.insertAdjacentHTML("afterbegin", gr);
      else {
        var mr = dr.id, vr = mr[0], yr = mr[1], _r = this.getElementByNodeId(vr), kr = this.getElementByNodeId(yr);
        if (_r) {
          _r.insertAdjacentHTML("beforebegin", gr);
          for (var xr = _r; xr && xr !== kr; ) {
            var Ar = xr.nextElementSibling;
            removeNode$1(xr), removeOffsetInfoByNode(xr), xr = Ar;
          }
          xr != null && xr.parentNode && (removeNode$1(xr), removeOffsetInfoByNode(xr));
        }
      }
    }, cr.prototype.getRenderer = function() {
      return this.renderer;
    }, cr.prototype.destroy = function() {
      off_1(this.el, "scroll"), this.el = null;
    }, cr.prototype.getElement = function() {
      return this.el;
    }, cr.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.previewContent.innerHTML);
    }, cr.prototype.setHTML = function(ar) {
      this.previewContent.innerHTML = ar;
    }, cr.prototype.setHeight = function(ar) {
      css_1(this.el, { height: ar + "px" });
    }, cr.prototype.setMinHeight = function(ar) {
      css_1(this.el, { minHeight: ar + "px" });
    }, cr;
  }()
);
function findNodeBy(cr, ar) {
  for (var lr = cr.depth; lr; ) {
    var ur = cr.node(lr);
    if (ar(ur, lr))
      return {
        node: ur,
        depth: lr,
        offset: lr > 0 ? cr.before(lr) : 0
      };
    lr -= 1;
  }
  return null;
}
function isInListNode(cr) {
  return !!findNodeBy(cr, function(ar) {
    var lr = ar.type;
    return lr.name === "listItem" || lr.name === "bulletList" || lr.name === "orderedList";
  });
}
function isInTableNode(cr) {
  return !!findNodeBy(cr, function(ar) {
    var lr = ar.type;
    return lr.name === "tableHeadCell" || lr.name === "tableBodyCell";
  });
}
function findListItem(cr) {
  return findNodeBy(cr, function(ar) {
    var lr = ar.type;
    return lr.name === "listItem";
  });
}
function createDOMInfoParsedRawHTML(cr) {
  return {
    tag: cr,
    getAttrs: function(ar) {
      var lr = ar.getAttribute("data-raw-html");
      return __assign$1({}, lr && { rawHTML: lr });
    }
  };
}
function createCellAttrs(cr) {
  return Object.keys(cr).reduce(function(ar, lr) {
    return lr !== "rawHTML" && cr[lr] && (lr = lr === "className" ? "class" : lr, ar[lr] = cr[lr]), ar;
  }, {});
}
function createParsedCellDOM(cr) {
  return {
    tag: cr,
    getAttrs: function(ar) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(lr, ur) {
        var dr = ur === "rawHTML" ? "data-raw-html" : ur, fr = ar.getAttribute(dr);
        return fr && (lr[ur] = includes(["rawHTML", "extended"], ur) ? fr : Number(fr)), lr;
      }, {});
    }
  };
}
function getDefaultCustomAttrs() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function getCustomAttrs(cr) {
  var ar = cr.htmlAttrs, lr = cr.classNames;
  return __assign$1(__assign$1({}, ar), { class: lr ? lr.join(" ") : null });
}
function findWrappingOutside(cr, ar) {
  var lr = cr.parent, ur = cr.startIndex, dr = cr.endIndex, fr = lr.contentMatchAt(ur).findWrapping(ar);
  if (fr) {
    var gr = fr.length ? fr[0] : ar;
    return lr.canReplaceWith(ur, dr, gr) ? fr : null;
  }
  return null;
}
function findWrappingInside(cr, ar) {
  var lr = cr.parent, ur = cr.startIndex, dr = cr.endIndex, fr = lr.child(ur), gr = ar.contentMatch.findWrapping(fr.type);
  if (gr) {
    for (var mr = gr.length ? gr[gr.length - 1] : ar, vr = mr.contentMatch, yr = ur; vr && yr < dr; yr += 1)
      vr = vr.matchType(lr.child(yr).type);
    if (vr && vr.validEnd)
      return gr;
  }
  return null;
}
function findWrappers(cr, ar, lr, ur) {
  var dr = findWrappingOutside(cr, lr), fr = findWrappingInside(ar, lr);
  if (dr && fr) {
    var gr = dr.map(function(vr) {
      return { type: vr };
    }), mr = fr.map(function(vr) {
      return { type: vr, attrs: ur };
    });
    return gr.concat({ type: lr }).concat(mr);
  }
  return null;
}
function wrapInList(cr, ar, lr, ur, dr) {
  for (var fr = ar.start, gr = ar.end, mr = ar.startIndex, vr = ar.endIndex, yr = ar.parent, _r = Fragment.empty, kr = lr.length - 1; kr >= 0; kr -= 1)
    _r = Fragment.from(lr[kr].type.create(lr[kr].attrs, _r));
  cr.step(new ReplaceAroundStep(fr - (ur ? 2 : 0), gr, fr, gr, new Slice(_r, 0, 0), lr.length, !0));
  for (var xr = 0, kr = 0; kr < lr.length; kr += 1)
    if (lr[kr].type === dr) {
      xr = kr + 1;
      break;
    }
  for (var Ar = lr.length - xr, Er = fr + lr.length - (ur ? 2 : 0), kr = mr, Cr = vr; kr < Cr; kr += 1) {
    var Tr = kr === mr;
    !Tr && canSplit(cr.doc, Er, Ar) && (cr.split(Er, Ar), Er += Ar * 2), Er += yr.child(kr).nodeSize;
  }
  return cr;
}
function changeToList(cr, ar, lr, ur) {
  var dr = ar.$from, fr = ar.$to, gr = ar.depth, mr = ar, vr = !1;
  if (gr >= 2 && dr.node(gr - 1).type.compatibleContent(lr) && ar.startIndex === 0 && dr.index(gr - 1)) {
    var yr = cr.doc.resolve(ar.start - 2);
    mr = new NodeRange(yr, yr, gr), ar.endIndex < ar.parent.childCount && (ar = new NodeRange(dr, cr.doc.resolve(fr.end(gr)), gr)), vr = !0;
  }
  var _r = findWrappers(mr, ar, lr, ur);
  return _r ? wrapInList(cr, ar, _r, vr, lr) : cr;
}
function getBeforeLineListItem(cr, ar) {
  for (var lr = cr.resolve(ar); lr.node().type.name !== "paragraph"; )
    ar -= 2, lr = cr.resolve(ar);
  return findListItem(lr);
}
function toggleTaskListItems(cr, ar) {
  var lr = ar.$from, ur = ar.$to, dr = findListItem(lr), fr = findListItem(ur);
  if (dr && fr)
    for (; fr; ) {
      var gr = fr.offset, mr = fr.node, vr = { task: !mr.attrs.task, checked: !1 };
      if (cr.setNodeMarkup(gr, null, vr), gr === dr.offset)
        break;
      fr = getBeforeLineListItem(cr.doc, gr);
    }
  return cr;
}
function changeListType(cr, ar, lr) {
  var ur = ar.$from, dr = ar.$to, fr = findListItem(ur), gr = findListItem(dr);
  if (fr && gr)
    for (; gr; ) {
      var mr = gr.offset, vr = gr.node, yr = gr.depth;
      vr.attrs.task && cr.setNodeMarkup(mr, null, { task: !1, checked: !1 });
      var _r = cr.doc.resolve(mr);
      if (_r.parent.type !== lr) {
        var kr = _r.before(yr - 1);
        cr.setNodeMarkup(kr, lr);
      }
      if (mr === fr.offset)
        break;
      gr = getBeforeLineListItem(cr.doc, mr);
    }
  return cr;
}
function changeList(cr) {
  return function(ar, lr) {
    var ur = ar.selection, dr = ar.tr, fr = ur.$from, gr = ur.$to, mr = fr.blockRange(gr);
    if (mr) {
      var vr = isInListNode(fr) ? changeListType(dr, mr, cr) : changeToList(dr, mr, cr);
      return lr(vr), !0;
    }
    return !1;
  };
}
function toggleTask() {
  return function(cr, ar) {
    var lr = cr.selection, ur = cr.tr, dr = cr.schema, fr = lr.$from, gr = lr.$to, mr = fr.blockRange(gr);
    if (mr) {
      var vr = isInListNode(fr) ? toggleTaskListItems(ur, mr) : changeToList(ur, mr, dr.nodes.bulletList, { task: !0 });
      return ar(vr), !0;
    }
    return !1;
  };
}
function sinkListItem(cr) {
  return function(ar, lr) {
    var ur = ar.tr, dr = ar.selection, fr = dr.$from, gr = dr.$to, mr = fr.blockRange(gr, function(Cr) {
      var Tr = Cr.childCount, Sr = Cr.firstChild;
      return !!Tr && Sr.type === cr;
    });
    if (mr && mr.startIndex > 0) {
      var vr = mr.parent, yr = vr.child(mr.startIndex - 1);
      if (yr.type !== cr)
        return !1;
      var _r = yr.lastChild && yr.lastChild.type === vr.type, kr = _r ? Fragment.from(cr.create()) : null, xr = new Slice(Fragment.from(cr.create(null, Fragment.from(vr.type.create(null, kr)))), _r ? 3 : 1, 0), Ar = mr.start, Er = mr.end;
      return ur.step(new ReplaceAroundStep(Ar - (_r ? 3 : 1), Er, Ar, Er, xr, 1, !0)), lr(ur), !0;
    }
    return !1;
  };
}
function liftToOuterList(cr, ar, lr) {
  var ur = ar.$from, dr = ar.$to, fr = ar.end, gr = ar.depth, mr = ar.parent, vr = dr.end(gr);
  return fr < vr && (cr.step(new ReplaceAroundStep(fr - 1, vr, fr, vr, new Slice(Fragment.from(lr.create(null, mr.copy())), 1, 0), 1, !0)), ar = new NodeRange(cr.doc.resolve(ur.pos), cr.doc.resolve(vr), gr)), cr.lift(ar, liftTarget(ar)), cr;
}
function liftOutOfList(cr, ar) {
  for (var lr = ar.parent, ur = ar.end, dr = ar.endIndex - 1, fr = ar.startIndex; dr > fr; dr -= 1)
    ur -= lr.child(dr).nodeSize, cr.delete(ur - 1, ur + 1);
  var gr = cr.doc.resolve(ar.start), mr = gr.nodeAfter, vr = ar.startIndex === 0, yr = ar.endIndex === lr.childCount, _r = gr.node(-1), kr = gr.index(-1), xr = _r.canReplace(kr + (vr ? 0 : 1), kr + 1, mr == null ? void 0 : mr.content.append(yr ? Fragment.empty : Fragment.from(lr)));
  if (mr && xr) {
    var Ar = gr.pos, Er = Ar + mr.nodeSize;
    cr.step(new ReplaceAroundStep(Ar - (vr ? 1 : 0), Er + (yr ? 1 : 0), Ar + 1, Er - 1, new Slice((vr ? Fragment.empty : Fragment.from(lr.copy(Fragment.empty))).append(yr ? Fragment.empty : Fragment.from(lr.copy(Fragment.empty))), vr ? 0 : 1, yr ? 0 : 1), vr ? 0 : 1));
  }
  return cr;
}
function liftListItem(cr) {
  return function(ar, lr) {
    var ur = ar.tr, dr = ar.selection, fr = dr.$from, gr = dr.$to, mr = fr.blockRange(gr, function(_r) {
      var kr = _r.childCount, xr = _r.firstChild;
      return !!kr && xr.type === cr;
    });
    if (mr) {
      var vr = fr.node(mr.depth - 1).type === cr, yr = vr ? liftToOuterList(ur, mr, cr) : liftOutOfList(ur, mr);
      return lr(yr), !0;
    }
    return !1;
  };
}
function splitListItem(cr) {
  return function(ar, lr) {
    var ur = ar.tr, dr = ar.selection, fr = dr.$from, gr = dr.$to;
    if (fr.depth < 2 || !fr.sameParent(gr))
      return !1;
    var mr = fr.node(-1);
    if (mr.type !== cr)
      return !1;
    if (fr.parent.content.size === 0 && fr.node(-1).childCount === fr.indexAfter(-1)) {
      if (fr.depth === 2 || fr.node(-3).type !== cr || fr.index(-2) !== fr.node(-2).childCount - 1)
        return !1;
      for (var vr = fr.index(-1) > 0, yr = Fragment.empty, _r = fr.depth - (vr ? 1 : 2); _r >= fr.depth - 3; _r -= 1)
        yr = Fragment.from(fr.node(_r).copy(yr));
      return yr = yr.append(Fragment.from(cr.createAndFill())), ur.replace(vr ? fr.before() : fr.before(-1), fr.after(-3), new Slice(yr, vr ? 3 : 2, 2)), ur.setSelection(Selection.near(ur.doc.resolve(fr.pos + (vr ? 3 : 2)))), lr(ur), !0;
    }
    var kr = gr.pos === fr.end() ? mr.contentMatchAt(0).defaultType : null, xr = kr && [null, { type: kr }];
    return ur.delete(fr.pos, gr.pos), canSplit(ur.doc, fr.pos, 2, xr) ? (ur.split(fr.pos, 2, xr), lr(ur), !0) : !1;
  };
}
function indent() {
  return function() {
    return function(cr, ar) {
      var lr = cr.selection, ur = cr.schema, dr = lr.$from, fr = lr.$to, gr = dr.blockRange(fr);
      return gr && isInListNode(dr) ? sinkListItem(ur.nodes.listItem)(cr, ar) : !1;
    };
  };
}
function outdent() {
  return function() {
    return function(cr, ar) {
      var lr = cr.selection, ur = cr.schema, dr = lr.$from, fr = lr.$to, gr = dr.blockRange(fr);
      return gr && isInListNode(dr) ? liftListItem(ur.nodes.listItem)(cr, ar) : !1;
    };
  };
}
function getWwCommands() {
  return {
    indent: indent(),
    outdent: outdent()
  };
}
var cache = /* @__PURE__ */ new Map(), TableOffsetMap = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      this.table = ar, this.tableRows = lr, this.tableStartPos = ur, this.rowInfo = dr;
    }
    return cr.create = function(ar) {
      var lr = findNodeBy(ar, function(Er) {
        var Cr = Er.type;
        return Cr.name === "table";
      });
      if (lr) {
        var ur = lr.node, dr = lr.depth, fr = lr.offset, gr = cache.get(ur);
        if ((gr == null ? void 0 : gr.tableStartPos) === fr + 1)
          return gr;
        var mr = [], vr = ar.start(dr), yr = ur.child(0), _r = ur.child(1), kr = createOffsetMap(yr, vr), xr = createOffsetMap(_r, vr + yr.nodeSize);
        yr.forEach(function(Er) {
          return mr.push(Er);
        }), _r.forEach(function(Er) {
          return mr.push(Er);
        });
        var Ar = new cr(ur, mr, vr, kr.concat(xr));
        return cache.set(ur, Ar), Ar;
      }
      return null;
    }, Object.defineProperty(cr.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(cr.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(cr.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(cr.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: !1,
      configurable: !0
    }), cr.prototype.getCellInfo = function(ar, lr) {
      return this.rowInfo[ar][lr];
    }, cr.prototype.posAt = function(ar, lr) {
      for (var ur = 0, dr = this.tableStartPos; ; ur += 1) {
        var fr = dr + this.tableRows[ur].nodeSize;
        if (ur === ar) {
          for (var gr = lr; gr < this.totalColumnCount && this.rowInfo[ur][gr].offset < dr; )
            gr += 1;
          return gr === this.totalColumnCount ? fr : this.rowInfo[ur][gr].offset;
        }
        dr = fr;
      }
    }, cr.prototype.getNodeAndPos = function(ar, lr) {
      var ur = this.rowInfo[ar][lr];
      return {
        node: this.table.nodeAt(ur.offset - this.tableStartOffset),
        pos: ur.offset
      };
    }, cr.prototype.extendedRowspan = function(ar, lr) {
      return !1;
    }, cr.prototype.extendedColspan = function(ar, lr) {
      return !1;
    }, cr.prototype.getRowspanCount = function(ar, lr) {
      return 0;
    }, cr.prototype.getColspanCount = function(ar, lr) {
      return 0;
    }, cr.prototype.decreaseColspanCount = function(ar, lr) {
      return 0;
    }, cr.prototype.decreaseRowspanCount = function(ar, lr) {
      return 0;
    }, cr.prototype.getColspanStartInfo = function(ar, lr) {
      return null;
    }, cr.prototype.getRowspanStartInfo = function(ar, lr) {
      return null;
    }, cr.prototype.getCellStartOffset = function(ar, lr) {
      var ur = this.rowInfo[ar][lr].offset;
      return this.extendedRowspan(ar, lr) ? this.posAt(ar, lr) : ur;
    }, cr.prototype.getCellEndOffset = function(ar, lr) {
      var ur = this.rowInfo[ar][lr], dr = ur.offset, fr = ur.nodeSize;
      return this.extendedRowspan(ar, lr) ? this.posAt(ar, lr) : dr + fr;
    }, cr.prototype.getCellIndex = function(ar) {
      for (var lr = 0; lr < this.totalRowCount; lr += 1)
        for (var ur = this.rowInfo[lr], dr = 0; dr < this.totalColumnCount; dr += 1)
          if (ur[dr].offset + 1 > ar.pos)
            return [lr, dr];
      return [0, 0];
    }, cr.prototype.getRectOffsets = function(ar, lr) {
      var ur, dr, fr;
      lr === void 0 && (lr = ar), ar.pos > lr.pos && (ur = [lr, ar], ar = ur[0], lr = ur[1]);
      var gr = this.getCellIndex(ar), mr = gr[0], vr = gr[1], yr = this.getCellIndex(lr), _r = yr[0], kr = yr[1];
      return dr = getSortedNumPair(mr, _r), mr = dr[0], _r = dr[1], fr = getSortedNumPair(vr, kr), vr = fr[0], kr = fr[1], this.getSpannedOffsets({ startRowIdx: mr, startColIdx: vr, endRowIdx: _r, endColIdx: kr });
    }, cr.prototype.getSpannedOffsets = function(ar) {
      return ar;
    }, cr;
  }()
), createOffsetMap = function(cr, ar) {
  var lr = [];
  return cr.forEach(function(ur, dr) {
    var fr = { rowspanMap: {}, colspanMap: {}, length: 0 };
    ur.forEach(function(gr, mr) {
      for (var vr = gr.nodeSize, yr = 0; fr[yr]; )
        yr += 1;
      fr[yr] = {
        // 2 is the sum of the front and back positions of the tag
        offset: ar + dr + mr + 2,
        nodeSize: vr
      }, fr.length += 1;
    }), lr.push(fr);
  }), lr;
};
function mixinTableOffsetMapPrototype(cr, ar) {
  return assign(TableOffsetMap.prototype, cr), createOffsetMap = ar, TableOffsetMap;
}
function getSelectionRanges(cr, ar, lr) {
  for (var ur = lr.startRowIdx, dr = lr.startColIdx, fr = lr.endRowIdx, gr = lr.endColIdx, mr = [], vr = ur; vr <= fr; vr += 1)
    for (var yr = dr; yr <= gr; yr += 1) {
      var _r = ar.getCellInfo(vr, yr), kr = _r.offset, xr = _r.nodeSize;
      mr.push(new SelectionRange(cr.resolve(kr + 1), cr.resolve(kr + xr - 1)));
    }
  return mr;
}
function createTableFragment(cr, ar) {
  var lr = [];
  return cr.childCount && lr.push(cr), ar.childCount && lr.push(ar), Fragment.from(lr);
}
var CellSelection = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr, ur) {
      ur === void 0 && (ur = lr);
      var dr = this, fr = lr.node(0), gr = TableOffsetMap.create(lr), mr = gr.getRectOffsets(lr, ur), vr = getSelectionRanges(fr, gr, mr);
      return dr = cr.call(this, vr[0].$from, vr[0].$to, vr) || this, dr.startCell = lr, dr.endCell = ur, dr.offsetMap = gr, dr.isCellSelection = !0, dr.visible = !1, dr;
    }
    return ar.prototype.map = function(lr, ur) {
      var dr = this.startCell.pos, fr = this.endCell.pos, gr = lr.resolve(ur.map(dr)), mr = lr.resolve(ur.map(fr)), vr = TableOffsetMap.create(gr);
      if (this.offsetMap.totalColumnCount > vr.totalColumnCount || this.offsetMap.totalRowCount > vr.totalRowCount) {
        var yr = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 }, _r = yr[mr.parent.type.name], kr = mr.end(mr.depth - _r), xr = Math.min(kr - 4, mr.pos);
        return TextSelection.create(lr, xr);
      }
      return new ar(gr, mr);
    }, ar.prototype.eq = function(lr) {
      return lr instanceof ar && lr.startCell.pos === this.startCell.pos && lr.endCell.pos === this.endCell.pos;
    }, ar.prototype.content = function() {
      for (var lr = this.startCell.node(-2), ur = this.startCell.start(-2), dr = lr.child(1).firstChild, fr = lr.child(0).type.create(), gr = lr.child(1).type.create(), mr = TableOffsetMap.create(this.startCell), vr = mr.getRectOffsets(this.startCell, this.endCell), yr = vr.startRowIdx, _r = vr.startColIdx, kr = vr.endRowIdx, xr = vr.endColIdx, Ar = !1, Er = yr; Er <= kr; Er += 1) {
        for (var Cr = [], Tr = _r; Tr <= xr; Tr += 1) {
          var Sr = mr.getCellInfo(Er, Tr).offset, Lr = lr.nodeAt(Sr - ur);
          Lr && (Ar = Lr.type.name === "tableHeadCell", mr.extendedRowspan(Er, Tr) || mr.extendedColspan(Er, Tr) ? Cr.push(Lr.type.create({ extended: !0 })) : Cr.push(Lr.copy(Lr.content)));
        }
        var Ir = dr.copy(Fragment.from(Cr)), Nr = Ar ? fr : gr;
        Nr.content = Nr.content.append(Fragment.from(Ir));
      }
      return new Slice(createTableFragment(fr, gr), 1, 1);
    }, ar.prototype.toJSON = function() {
      return JSON.stringify(this);
    }, ar;
  }(Selection)
);
function createTableHeadRow(cr, ar, lr) {
  for (var ur = ar.nodes, dr = ur.tableRow, fr = ur.tableHeadCell, gr = ur.paragraph, mr = [], vr = 0; vr < cr; vr += 1) {
    var yr = lr && lr[vr], _r = gr.create(null, yr ? ar.text(yr) : []);
    mr.push(fr.create(null, _r));
  }
  return [dr.create(null, mr)];
}
function createTableBodyRows(cr, ar, lr, ur) {
  for (var dr = lr.nodes, fr = dr.tableRow, gr = dr.tableBodyCell, mr = dr.paragraph, vr = [], yr = 0; yr < cr; yr += 1) {
    for (var _r = [], kr = 0; kr < ar; kr += 1) {
      var xr = ur && ur[yr * ar + kr], Ar = mr.create(null, xr ? lr.text(xr) : []);
      _r.push(gr.create(null, Ar));
    }
    vr.push(fr.create(null, _r));
  }
  return vr;
}
function createDummyCells(cr, ar, lr, ur) {
  ur === void 0 && (ur = null);
  for (var dr = lr.nodes, fr = dr.tableHeadCell, gr = dr.tableBodyCell, mr = dr.paragraph, vr = ar === 0 ? fr : gr, yr = [], _r = 0; _r < cr; _r += 1)
    yr.push(vr.create(ur, mr.create()));
  return yr;
}
function findCellElement(cr, ar) {
  for (; cr && cr !== ar; ) {
    if (cr.nodeName === "TD" || cr.nodeName === "TH")
      return cr;
    cr = cr.parentNode;
  }
  return null;
}
function findCell(cr) {
  return findNodeBy(cr, function(ar) {
    var lr = ar.type;
    return lr.name === "tableHeadCell" || lr.name === "tableBodyCell";
  });
}
function getResolvedSelection(cr) {
  if (cr instanceof TextSelection) {
    var ar = cr.$anchor, lr = findCell(ar);
    if (lr) {
      var ur = ar.node(0).resolve(ar.before(lr.depth));
      return { anchor: ur, head: ur };
    }
  }
  var dr = cr, fr = dr.startCell, gr = dr.endCell;
  return { anchor: fr, head: gr };
}
function getTableContentFromSlice(cr) {
  var ar;
  if (cr.size) {
    var lr = cr.content, ur = cr.openStart, dr = cr.openEnd;
    if (lr.childCount !== 1)
      return null;
    for (; lr.childCount === 1 && (ur > 0 && dr > 0 || ((ar = lr.firstChild) === null || ar === void 0 ? void 0 : ar.type.name) === "table"); )
      ur -= 1, dr -= 1, lr = lr.firstChild.content;
    if (lr.firstChild.type.name === "tableHead" || lr.firstChild.type.name === "tableBody")
      return lr;
  }
  return null;
}
function getRowAndColumnCount(cr) {
  var ar = cr.startRowIdx, lr = cr.startColIdx, ur = cr.endRowIdx, dr = cr.endColIdx, fr = ur - ar + 1, gr = dr - lr + 1;
  return { rowCount: fr, columnCount: gr };
}
function setAttrs(cr, ar) {
  return __assign$1(__assign$1({}, cr.attrs), ar);
}
var pluginKey = new PluginKey("cellSelection"), MOUSE_RIGHT_BUTTON = 2, TableSelection = (
  /** @class */
  function() {
    function cr(ar) {
      this.view = ar, this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      }, this.startCellPos = null, this.init();
    }
    return cr.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    }, cr.prototype.handleMousedown = function(ar) {
      var lr = findCellElement(ar.target, this.view.dom);
      if (ar.button === MOUSE_RIGHT_BUTTON) {
        ar.preventDefault();
        return;
      }
      if (lr) {
        var ur = this.getCellPos(ar);
        ur && (this.startCellPos = ur), this.bindEvent();
      }
    }, cr.prototype.handleMousemove = function(ar) {
      var lr = pluginKey.getState(this.view.state), ur = this.getCellPos(ar), dr = this.startCellPos, fr;
      lr ? fr = this.view.state.doc.resolve(lr) : dr !== ur && (fr = dr), fr && dr && ur && this.setCellSelection(dr, ur);
    }, cr.prototype.handleMouseup = function() {
      this.startCellPos = null, this.unbindEvent(), pluginKey.getState(this.view.state) !== null && this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));
    }, cr.prototype.bindEvent = function() {
      var ar = this.view.dom;
      ar.addEventListener("mousemove", this.handlers.mousemove), ar.addEventListener("mouseup", this.handlers.mouseup);
    }, cr.prototype.unbindEvent = function() {
      var ar = this.view.dom;
      ar.removeEventListener("mousemove", this.handlers.mousemove), ar.removeEventListener("mouseup", this.handlers.mouseup);
    }, cr.prototype.getCellPos = function(ar) {
      var lr = ar.clientX, ur = ar.clientY, dr = this.view.posAtCoords({ left: lr, top: ur });
      if (dr) {
        var fr = this.view.state.doc, gr = fr.resolve(dr.pos), mr = findCell(gr);
        if (mr) {
          var vr = gr.before(mr.depth);
          return fr.resolve(vr);
        }
      }
      return null;
    }, cr.prototype.setCellSelection = function(ar, lr) {
      var ur = this.view.state, dr = ur.selection, fr = ur.tr, gr = pluginKey.getState(this.view.state) === null, mr = new CellSelection(ar, lr);
      if (gr || !dr.eq(mr)) {
        var vr = fr.setSelection(mr);
        gr && vr.setMeta(pluginKey, lr.pos), this.view.dispatch(vr);
      }
    }, cr.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    }, cr;
  }()
), SELECTED_CELL_CLASS_NAME = cls("cell-selected");
function drawCellSelection(cr) {
  var ar = cr.selection, lr = cr.doc;
  if (ar instanceof CellSelection) {
    var ur = [], dr = ar.ranges;
    return dr.forEach(function(fr) {
      var gr = fr.$from, mr = fr.$to;
      ur.push(Decoration.node(gr.pos - 1, mr.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));
    }), DecorationSet.create(lr, ur);
  }
  return null;
}
function tableSelection() {
  return new Plugin({
    key: pluginKey,
    state: {
      init: function() {
        return null;
      },
      apply: function(cr, ar) {
        var lr = cr.getMeta(pluginKey);
        if (lr)
          return lr === -1 ? null : lr;
        if (isNull_1(ar) || !cr.docChanged)
          return ar;
        var ur = cr.mapping.mapResult(ar), dr = ur.deleted, fr = ur.pos;
        return dr ? null : fr;
      }
    },
    props: {
      decorations: drawCellSelection,
      createSelectionBetween: function(cr) {
        var ar = cr.state;
        return isNull_1(pluginKey.getState(ar)) ? null : ar.selection;
      }
    },
    view: function(cr) {
      return new TableSelection(cr);
    }
  });
}
var Map$1 = (
  /** @class */
  function() {
    function cr() {
      this.keys = [], this.values = [];
    }
    return cr.prototype.getKeyIndex = function(ar) {
      return inArray_1(ar, this.keys);
    }, cr.prototype.get = function(ar) {
      return this.values[this.getKeyIndex(ar)];
    }, cr.prototype.set = function(ar, lr) {
      var ur = this.getKeyIndex(ar);
      return ur > -1 ? this.values[ur] = lr : (this.keys.push(ar), this.values.push(lr)), this;
    }, cr.prototype.has = function(ar) {
      return this.getKeyIndex(ar) > -1;
    }, cr.prototype.delete = function(ar) {
      var lr = this.getKeyIndex(ar);
      return lr > -1 ? (this.keys.splice(lr, 1), this.values.splice(lr, 1), !0) : !1;
    }, cr.prototype.forEach = function(ar, lr) {
      var ur = this;
      lr === void 0 && (lr = this), this.values.forEach(function(dr, fr) {
        dr && ur.keys[fr] && ar.call(lr, dr, ur.keys[fr], ur);
      });
    }, cr.prototype.clear = function() {
      this.keys = [], this.values = [];
    }, cr;
  }()
), DEFAULT_CODE = "en-US", I18n = (
  /** @class */
  function() {
    function cr() {
      this.code = DEFAULT_CODE, this.langs = new Map$1();
    }
    return cr.prototype.setCode = function(ar) {
      this.code = ar || DEFAULT_CODE;
    }, cr.prototype.setLanguage = function(ar, lr) {
      var ur = this;
      ar = [].concat(ar), ar.forEach(function(dr) {
        if (!ur.langs.has(dr))
          ur.langs.set(dr, lr);
        else {
          var fr = ur.langs.get(dr);
          ur.langs.set(dr, extend_1(fr, lr));
        }
      });
    }, cr.prototype.get = function(ar, lr) {
      lr || (lr = this.code);
      var ur = this.langs.get(lr);
      ur || (ur = this.langs.get(DEFAULT_CODE));
      var dr = ur[ar];
      if (!dr)
        throw new Error('There is no text key "' + ar + '" in ' + lr);
      return dr;
    }, cr;
  }()
), i18n = new I18n(), contextMenuGroups = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: !0,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: !0,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function getContextMenuGroups(cr, ar) {
  return contextMenuGroups.map(function(lr) {
    return lr.map(function(ur) {
      var dr = ur.action, fr = ur.command, gr = ur.payload, mr = ur.disableInThead, vr = ur.className;
      return {
        label: i18n.get(dr),
        onClick: function() {
          cr.emit("command", fr, gr);
        },
        disabled: ar && !!mr,
        className: vr
      };
    });
  }).concat();
}
function tableContextMenu(cr) {
  return new Plugin({
    props: {
      handleDOMEvents: {
        contextmenu: function(ar, lr) {
          var ur = findCellElement(lr.target, ar.dom);
          if (ur) {
            lr.preventDefault();
            var dr = lr, fr = dr.clientX, gr = dr.clientY, mr = ar.dom.parentNode.getBoundingClientRect(), vr = mr.left, yr = mr.top, _r = ur.nodeName === "TH";
            return cr.emit("contextmenu", {
              pos: { left: fr - vr + 10 + "px", top: gr - yr + 30 + "px" },
              menuGroups: getContextMenuGroups(cr, _r),
              tableCell: ur
            }), !0;
          }
          return !1;
        }
      }
    }
  });
}
function task() {
  return new Plugin({
    props: {
      handleDOMEvents: {
        mousedown: function(cr, ar) {
          var lr = ar, ur = lr.clientX, dr = lr.clientY, fr = cr.posAtCoords({ left: ur, top: dr });
          if (fr) {
            var gr = cr.state, mr = gr.doc, vr = gr.tr, yr = mr.resolve(fr.pos), _r = findListItem(yr), kr = ar.target, xr = getComputedStyle(kr, ":before"), Ar = ar, Er = Ar.offsetX, Cr = Ar.offsetY;
            if (!_r || !isPositionInBox(xr, Er, Cr))
              return !1;
            ar.preventDefault();
            var Tr = yr.before(_r.depth), Sr = _r.node.attrs;
            return vr.setNodeMarkup(Tr, null, __assign$1(__assign$1({}, Sr), { checked: !Sr.checked })), cr.dispatch(vr), !0;
          }
          return !1;
        }
      }
    }
  });
}
var EXCEPT_TYPES = ["image", "link", "customBlock", "frontMatter"], MARK_TYPES = ["strong", "strike", "emph", "code"], LIST_TYPES = ["bulletList", "orderedList", "taskList"];
function getToolbarStateType(cr, ar) {
  var lr = cr.type.name;
  return lr === "listItem" ? cr.attrs.task ? "taskList" : ar.type.name : lr.indexOf("table") !== -1 ? "table" : lr;
}
function setListNodeToolbarState(cr, ar) {
  ar[cr] = { active: !0 }, LIST_TYPES.filter(function(lr) {
    return lr !== cr;
  }).forEach(function(lr) {
    ar[lr] && delete ar[lr];
  });
}
function setMarkTypeStates(cr, ar, lr, ur) {
  MARK_TYPES.forEach(function(dr) {
    var fr = lr.marks[dr], gr = cr.marksAcross(ar) || [], mr = !!fr.isInSet(gr);
    mr && (ur[dr] = { active: !0 });
  });
}
function getToolbarState(cr, ar, lr) {
  var ur = cr.$from, dr = cr.$to, fr = cr.from, gr = cr.to, mr = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  };
  return ar.nodesBetween(fr, gr, function(vr, yr, _r) {
    var kr = getToolbarStateType(vr, _r);
    includes(EXCEPT_TYPES, kr) || (includes(LIST_TYPES, kr) ? (setListNodeToolbarState(kr, mr), mr.indent.disabled = !1, mr.outdent.disabled = !1) : kr === "paragraph" || kr === "text" ? setMarkTypeStates(ur, dr, lr, mr) : mr[kr] = { active: !0 });
  }), mr;
}
function toolbarStateHighlight(cr) {
  return new Plugin({
    view: function() {
      return {
        update: function(ar) {
          var lr = ar.state, ur = lr.selection, dr = lr.doc, fr = lr.schema;
          cr.emit("changeToolbarState", {
            toolbarState: getToolbarState(ur, dr, fr)
          });
        }
      };
    }
  });
}
var CustomBlockView = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      var fr = this;
      this.openEditor = function() {
        if (fr.innerEditorView)
          throw new Error("The editor is already opened.");
        fr.dom.draggable = !1, fr.wrapper.style.display = "none", fr.innerViewContainer.style.display = "block", fr.innerEditorView = new EditorView(fr.innerViewContainer, {
          state: EditorState.create({
            doc: fr.node,
            plugins: [
              keymap({
                "Mod-z": function() {
                  return undo(fr.innerEditorView.state, fr.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return redo(fr.innerEditorView.state, fr.innerEditorView.dispatch);
                },
                Tab: function(gr, mr) {
                  return mr(gr.tr.insertText("	")), !0;
                },
                Enter: newlineInCode,
                Escape: function() {
                  return fr.cancelEditing(), !0;
                },
                "Ctrl-Enter": function() {
                  return fr.saveAndFinishEditing(), !0;
                }
              }),
              history()
            ]
          }),
          dispatchTransaction: function(gr) {
            return fr.dispatchInner(gr);
          },
          handleDOMEvents: {
            mousedown: function() {
              return fr.editorView.hasFocus() && fr.innerEditorView.focus(), !0;
            },
            blur: function() {
              return fr.saveAndFinishEditing(), !0;
            }
          }
        }), fr.innerEditorView.focus();
      }, this.node = ar, this.editorView = lr, this.getPos = ur, this.toDOMAdaptor = dr, this.innerEditorView = null, this.canceled = !1, this.dom = document.createElement("div"), this.dom.className = cls("custom-block"), this.wrapper = document.createElement("div"), this.wrapper.className = cls("custom-block-view"), this.createInnerViewContainer(), this.renderCustomBlock(), this.dom.appendChild(this.innerViewContainer), this.dom.appendChild(this.wrapper);
    }
    return cr.prototype.renderToolArea = function() {
      var ar = this, lr = document.createElement("div"), ur = document.createElement("span"), dr = document.createElement("button");
      lr.className = "tool", ur.textContent = this.node.attrs.info, ur.className = "info", dr.type = "button", dr.addEventListener("click", function() {
        return ar.openEditor();
      }), lr.appendChild(ur), lr.appendChild(dr), this.wrapper.appendChild(lr);
    }, cr.prototype.renderCustomBlock = function() {
      var ar = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (ar) {
        for (var lr = ar(this.node); this.wrapper.hasChildNodes(); )
          this.wrapper.removeChild(this.wrapper.lastChild);
        lr && this.wrapper.appendChild(lr), this.renderToolArea();
      }
    }, cr.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div"), this.innerViewContainer.className = cls("custom-block-editor"), this.innerViewContainer.style.display = "none";
    }, cr.prototype.closeEditor = function() {
      this.innerEditorView && (this.innerEditorView.destroy(), this.innerEditorView = null, this.innerViewContainer.style.display = "none"), this.wrapper.style.display = "block";
    }, cr.prototype.saveAndFinishEditing = function() {
      var ar = this.editorView.state.selection.to, lr = this.editorView.state;
      this.editorView.dispatch(lr.tr.setSelection(createTextSelection(lr.tr, ar))), this.editorView.focus(), this.renderCustomBlock(), this.closeEditor();
    }, cr.prototype.cancelEditing = function() {
      var ar = undoDepth(this.innerEditorView.state);
      for (this.canceled = !0; ar--; )
        undo(this.innerEditorView.state, this.innerEditorView.dispatch), undo(this.editorView.state, this.editorView.dispatch);
      this.canceled = !1;
      var lr = this.editorView.state.selection.to, ur = this.editorView.state;
      this.editorView.dispatch(ur.tr.setSelection(TextSelection.create(ur.doc, lr))), this.editorView.focus(), this.closeEditor();
    }, cr.prototype.dispatchInner = function(ar) {
      var lr = this.innerEditorView.state.applyTransaction(ar), ur = lr.state, dr = lr.transactions;
      if (this.innerEditorView.updateState(ur), !this.canceled && isFunction_1(this.getPos)) {
        for (var fr = this.editorView.state.tr, gr = StepMap.offset(this.getPos() + 1), mr = 0; mr < dr.length; mr += 1)
          for (var vr = dr[mr].steps, yr = 0; yr < vr.length; yr += 1)
            fr.step(vr[yr].map(gr));
        fr.docChanged && this.editorView.dispatch(fr);
      }
    }, cr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, this.innerEditorView || this.renderCustomBlock(), !0) : !1;
    }, cr.prototype.stopEvent = function(ar) {
      return !!this.innerEditorView && !!ar.target && this.innerEditorView.dom.contains(ar.target);
    }, cr.prototype.ignoreMutation = function() {
      return !0;
    }, cr.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor();
    }, cr;
  }()
), IMAGE_LINK_CLASS_NAME = "image-link", ImageView = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      var fr = this, gr;
      this.handleMousedown = function(mr) {
        mr.preventDefault();
        var vr = mr.target, yr = mr.offsetX, _r = mr.offsetY;
        if (fr.imageLink && isFunction_1(fr.getPos) && hasClass_1(vr, IMAGE_LINK_CLASS_NAME)) {
          var kr = getComputedStyle(vr, ":before");
          if (mr.stopPropagation(), isPositionInBox(kr, yr, _r)) {
            var xr = fr.view.state.tr, Ar = fr.getPos();
            xr.setSelection(createTextSelection(xr, Ar, Ar + 1)), fr.view.dispatch(xr), fr.eventEmitter.emit("openPopup", "link", fr.imageLink.attrs);
          }
        }
      }, this.node = ar, this.view = lr, this.getPos = ur, this.eventEmitter = dr, this.imageLink = (gr = ar.marks.filter(function(mr) {
        var vr = mr.type;
        return vr.name === "link";
      })[0]) !== null && gr !== void 0 ? gr : null, this.dom = this.createElement(), this.bindEvent();
    }
    return cr.prototype.createElement = function() {
      var ar = this.createImageElement(this.node);
      if (this.imageLink) {
        var lr = document.createElement("span");
        return lr.className = IMAGE_LINK_CLASS_NAME, lr.appendChild(ar), lr;
      }
      return ar;
    }, cr.prototype.createImageElement = function(ar) {
      var lr = document.createElement("img"), ur = ar.attrs, dr = ur.imageUrl, fr = ur.altText, gr = getCustomAttrs(ar.attrs);
      return lr.src = dr, fr && (lr.alt = fr), setAttributes(gr, lr), lr;
    }, cr.prototype.bindEvent = function() {
      this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown);
    }, cr.prototype.stopEvent = function() {
      return !0;
    }, cr.prototype.destroy = function() {
      this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown);
    }, cr;
  }()
), WRAPPER_CLASS_NAME = "toastui-editor-ww-code-block", CODE_BLOCK_LANG_CLASS_NAME = "toastui-editor-ww-code-block-language", CodeBlockView = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      var fr = this;
      this.contentDOM = null, this.input = null, this.timer = null, this.handleMousedown = function(gr) {
        var mr = gr.target, vr = getComputedStyle(mr, ":after");
        if (vr.backgroundImage !== "none" && isFunction_1(fr.getPos)) {
          var yr = fr.view.coordsAtPos(fr.getPos()), _r = yr.top, kr = yr.right;
          fr.createLanguageEditor({ top: _r, right: kr });
        }
      }, this.handleKeydown = function(gr) {
        gr.key === "Enter" && fr.input && (gr.preventDefault(), fr.changeLanguage());
      }, this.node = ar, this.view = lr, this.getPos = ur, this.eventEmitter = dr, this.createElement(), this.bindDOMEvent(), this.bindEvent();
    }
    return cr.prototype.createElement = function() {
      var ar = this.node.attrs.language, lr = document.createElement("div");
      lr.setAttribute("data-language", ar || "text"), lr.className = WRAPPER_CLASS_NAME;
      var ur = this.createCodeBlockElement(), dr = ur.firstChild;
      lr.appendChild(ur), this.dom = lr, this.contentDOM = dr;
    }, cr.prototype.createCodeBlockElement = function() {
      var ar = document.createElement("pre"), lr = document.createElement("code"), ur = this.node.attrs.language, dr = getCustomAttrs(this.node.attrs);
      return ur && lr.setAttribute("data-language", ur), setAttributes(dr, ar), ar.appendChild(lr), ar;
    }, cr.prototype.createLanguageEditor = function(ar) {
      var lr = this, ur = ar.top, dr = ar.right, fr = document.createElement("span");
      fr.className = CODE_BLOCK_LANG_CLASS_NAME;
      var gr = document.createElement("input");
      gr.type = "text", gr.value = this.node.attrs.language, fr.appendChild(gr), this.view.dom.parentElement.appendChild(fr);
      var mr = fr.clientWidth;
      css_1(fr, {
        top: ur + 10 + "px",
        left: dr - mr - 10 + "px",
        width: mr + "px"
      }), this.input = gr, this.input.addEventListener("blur", function() {
        return lr.changeLanguage();
      }), this.input.addEventListener("keydown", this.handleKeydown), this.clearTimer(), this.timer = setTimeout(function() {
        lr.input.focus();
      });
    }, cr.prototype.bindDOMEvent = function() {
      this.dom && this.dom.addEventListener("click", this.handleMousedown);
    }, cr.prototype.bindEvent = function() {
      var ar = this;
      this.eventEmitter.listen("scroll", function() {
        ar.input && ar.reset();
      });
    }, cr.prototype.changeLanguage = function() {
      if (this.input && isFunction_1(this.getPos)) {
        var ar = this.input.value;
        this.reset();
        var lr = this.getPos(), ur = this.view.state.tr;
        ur.setNodeMarkup(lr, null, { language: ar }), this.view.dispatch(ur);
      }
    }, cr.prototype.reset = function() {
      var ar;
      if (!((ar = this.input) === null || ar === void 0) && ar.parentElement) {
        var lr = this.input.parentElement;
        this.input = null, removeNode$1(lr);
      }
    }, cr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, cr.prototype.stopEvent = function() {
      return !0;
    }, cr.prototype.update = function(ar) {
      return ar.sameMarkup(this.node) ? (this.node = ar, !0) : !1;
    }, cr.prototype.destroy = function() {
      this.reset(), this.clearTimer(), this.dom && this.dom.removeEventListener("click", this.handleMousedown);
    }, cr;
  }()
), reMSOListClassName = /MsoListParagraph/, reMSOStylePrefix = /style=(.|\n)*mso-/, reMSOListStyle = /mso-list:(.*)/, reMSOTagName = /O:P/, reMSOListBullet = /^(n|u|l)/, MSO_CLASS_NAME_LIST_PARA = "p.MsoListParagraph";
function isFromMso(cr) {
  return reMSOStylePrefix.test(cr);
}
function getListItemContents(cr) {
  for (var ar = [], lr = document.createTreeWalker(cr, 1, null, !1); lr.nextNode(); ) {
    var ur = lr.currentNode;
    if (isElemNode(ur)) {
      var dr = ur, fr = dr.outerHTML, gr = dr.textContent, mr = reMSOStylePrefix.test(fr), vr = reMSOListStyle.test(fr);
      mr && !vr && gr ? ar.push([ur, !0]) : (reMSOTagName.test(ur.nodeName) || mr && !gr || vr) && ar.push([ur, !1]);
    }
  }
  return ar.forEach(function(yr) {
    var _r = yr[0], kr = yr[1];
    kr ? unwrapNode(_r) : removeNode$1(_r);
  }), cr.innerHTML.trim();
}
function createListItemDataFromParagraph(cr, ar) {
  var lr = cr.getAttribute("style");
  if (lr) {
    var ur = lr.match(reMSOListStyle), dr = ur[1], fr = dr.trim().split(" "), gr = fr[1], mr = parseInt(gr.replace("level", ""), 10), vr = reMSOListBullet.test(cr.textContent || "");
    return {
      id: ar,
      level: mr,
      prev: null,
      parent: null,
      children: [],
      unordered: vr,
      contents: getListItemContents(cr)
    };
  }
  return null;
}
function addListItemDetailData(cr, ar) {
  if (ar.level < cr.level)
    ar.children.push(cr), cr.parent = ar;
  else {
    for (; ar && ar.level !== cr.level; )
      ar = ar.parent;
    ar && (cr.prev = ar, cr.parent = ar.parent, cr.parent && cr.parent.children.push(cr));
  }
}
function createListData(cr) {
  var ar = [];
  return cr.forEach(function(lr, ur) {
    var dr = ar[ur - 1], fr = createListItemDataFromParagraph(lr, ur);
    fr && (dr && addListItemDetailData(fr, dr), ar.push(fr));
  }), ar;
}
function makeList(cr) {
  var ar = cr[0].unordered ? "ul" : "ol", lr = document.createElement(ar);
  return cr.forEach(function(ur) {
    var dr = ur.children, fr = ur.contents, gr = document.createElement("li");
    gr.innerHTML = fr, lr.appendChild(gr), dr.length && lr.appendChild(makeList(dr));
  }), lr;
}
function makeListFromParagraphs(cr) {
  var ar = createListData(cr), lr = ar.filter(function(ur) {
    var dr = ur.parent;
    return !dr;
  });
  return makeList(lr);
}
function isMsoListParagraphEnd(cr) {
  for (; cr && !isElemNode(cr); )
    cr = cr.nextSibling;
  return cr ? !reMSOListClassName.test(cr.className) : !0;
}
function convertMsoParagraphsToList(cr) {
  var ar = document.createElement("div");
  ar.innerHTML = cr;
  var lr = [], ur = findNodes(ar, MSO_CLASS_NAME_LIST_PARA);
  ur.forEach(function(fr) {
    var gr = isMsoListParagraphEnd(fr.nextSibling);
    if (lr.push(fr), gr) {
      var mr = makeListFromParagraphs(lr), vr = fr.nextSibling;
      vr ? insertBeforeNode(mr, vr) : appendNodes(ar, mr), lr = [];
    }
    removeNode$1(fr);
  });
  var dr = ur.length ? "<p></p>" : "";
  return "" + dr + ar.innerHTML;
}
var START_FRAGMENT_COMMENT = "<!--StartFragment-->", END_FRAGMENT_COMMENT = "<!--EndFragment-->";
function getContentBetweenFragmentComments(cr) {
  var ar = cr.indexOf(START_FRAGMENT_COMMENT), lr = cr.lastIndexOf(END_FRAGMENT_COMMENT);
  return ar > -1 && lr > -1 && (cr = cr.slice(ar + START_FRAGMENT_COMMENT.length, lr)), cr.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);
}
function convertMsoTableToCompletedTable(cr) {
  return /<\/td>((?!<\/tr>)[\s\S])*$/i.test(cr) && (cr = "<tr>" + cr + "</tr>"), /<\/tr>((?!<\/table>)[\s\S])*$/i.test(cr) && (cr = "<table>" + cr + "</table>"), cr;
}
function changePastedHTML(cr) {
  return cr = getContentBetweenFragmentComments(cr), cr = convertMsoTableToCompletedTable(cr), isFromMso(cr) && (cr = convertMsoParagraphsToList(cr)), cr;
}
function getMaxColumnCount(cr) {
  var ar = cr.reduce(function(lr, ur) {
    return lr.childCount > ur.childCount ? lr : ur;
  });
  return ar.childCount;
}
function createCells(cr, ar, lr) {
  for (var ur = [], dr = cr.childCount, fr = 0; fr < dr; fr += 1)
    if (!cr.child(fr).attrs.extended) {
      var gr = fr < dr ? lr.create(cr.child(fr).attrs, cr.child(fr).content) : lr.createAndFill();
      ur.push(gr);
    }
  return ur;
}
function copyTableHeadRow(cr, ar, lr) {
  var ur = lr.nodes, dr = ur.tableRow, fr = ur.tableHeadCell, gr = createCells(cr, ar, fr);
  return dr.create(null, gr);
}
function copyTableBodyRow(cr, ar, lr) {
  var ur = lr.nodes, dr = ur.tableRow, fr = ur.tableBodyCell, gr = createCells(cr, ar, fr);
  return dr.create(null, gr);
}
function creatTableBodyDummyRow(cr, ar) {
  for (var lr = ar.nodes, ur = lr.tableRow, dr = lr.tableBodyCell, fr = [], gr = 0; gr < cr; gr += 1) {
    var mr = dr.createAndFill();
    fr.push(mr);
  }
  return ur.create({ dummyRowForPasting: !0 }, fr);
}
function createRowsFromPastingTable(cr) {
  var ar = [], lr = [];
  if (cr.firstChild.type.name === "tableHead") {
    var ur = cr.firstChild;
    ur.forEach(function(fr) {
      return ar.push(fr);
    });
  }
  if (cr.lastChild.type.name === "tableBody") {
    var dr = cr.lastChild;
    dr.forEach(function(fr) {
      return lr.push(fr);
    });
  }
  return __spreadArray$1(__spreadArray$1([], ar), lr);
}
function createTableHead(cr, ar, lr) {
  var ur = copyTableHeadRow(cr, ar, lr);
  return lr.nodes.tableHead.create(null, ur);
}
function createTableBody(cr, ar, lr) {
  var ur = cr.map(function(fr) {
    return copyTableBodyRow(fr, ar, lr);
  });
  if (!cr.length) {
    var dr = creatTableBodyDummyRow(ar, lr);
    ur.push(dr);
  }
  return lr.nodes.tableBody.create(null, ur);
}
function createTableFromPastingTable(cr, ar, lr, ur) {
  var dr = getMaxColumnCount(cr);
  if (lr && ur)
    return ar.nodes.table.create(null, [createTableBody(cr, dr, ar)]);
  var fr = cr[0], gr = cr.slice(1), mr = [createTableHead(fr, dr, ar)];
  return gr.length && mr.push(createTableBody(gr, dr, ar)), ar.nodes.table.create(null, mr);
}
function changePastedSlice(cr, ar, lr) {
  var ur = [], dr = cr.content, fr = cr.openStart, gr = cr.openEnd;
  return dr.forEach(function(mr) {
    if (mr.type.name === "table") {
      var vr = getTableContentFromSlice(new Slice(Fragment.from(mr), 0, 0));
      if (vr) {
        var yr = createRowsFromPastingTable(vr), _r = vr.firstChild.type.name === "tableBody", kr = createTableFromPastingTable(yr, ar, _r, lr);
        ur.push(kr);
      }
    } else
      ur.push(mr);
  }), new Slice(Fragment.from(ur), fr, gr);
}
var DUMMY_CELL_SIZE = 4, TR_NODES_SIZE = 2;
function getDummyCellSize(cr) {
  return cr * DUMMY_CELL_SIZE;
}
function createPastingCells(cr, ar, lr) {
  var ur = [], dr = createRowsFromPastingTable(cr), fr = dr[0].childCount, gr = dr.length, mr = ar.startRowIdx === 0, vr = dr.slice(0, gr);
  if (mr) {
    var yr = vr.shift();
    if (yr) {
      var _r = copyTableHeadRow(yr, fr, lr).content;
      ur.push(_r);
    }
  }
  return vr.forEach(function(kr) {
    if (!kr.attrs.dummyRowForPasting) {
      var xr = copyTableBodyRow(kr, fr, lr).content;
      ur.push(xr);
    }
  }), ur;
}
function getPastingRangeInfo(cr, ar, lr) {
  for (var ur = ar.startRowIdx, dr = ar.startColIdx, fr = lr.length, gr = 0, mr = function(Ar) {
    var Er = lr[Ar].childCount;
    lr[Ar].forEach(function(Cr) {
      var Tr = Cr.attrs, Sr = Tr.colspan;
      Sr > 1 && (Er += Sr - 1);
    }), gr = Math.max(gr, Er);
  }, vr = 0; vr < fr; vr += 1)
    mr(vr);
  var yr = ur + fr - 1, _r = dr + gr - 1, kr = Math.max(yr + 1 - cr.totalRowCount, 0), xr = Math.max(_r + 1 - cr.totalColumnCount, 0);
  return {
    startRowIdx: ur,
    startColIdx: dr,
    endRowIdx: yr,
    endColIdx: _r,
    addedRowCount: kr,
    addedColumnCount: xr
  };
}
function addReplacedOffsets(cr, ar) {
  for (var lr = cr.startRowIdx, ur = cr.startColIdx, dr = cr.endRowIdx, fr = cr.endColIdx, gr = cr.addedRowCount, mr = cr.addedColumnCount, vr = lr; vr <= dr - gr; vr += 1)
    ar.push({
      rowIdx: vr,
      startColIdx: ur,
      endColIdx: fr - mr
    });
}
function expandColumns(cr, ar, lr, ur, dr) {
  for (var fr = ur.startRowIdx, gr = ur.startColIdx, mr = ur.endRowIdx, vr = ur.endColIdx, yr = ur.addedRowCount, _r = ur.addedColumnCount, kr = lr.totalRowCount, xr = 0, Ar = 0; Ar < kr; Ar += 1) {
    var Er = lr.getCellInfo(Ar, vr - _r), Cr = Er.offset, Tr = Er.nodeSize, Sr = cr.mapping.map(Cr + Tr), Lr = createDummyCells(_r, Ar, ar);
    if (cr.insert(Sr, Lr), Ar >= fr && Ar <= mr - yr) {
      var Ir = lr.getCellInfo(Ar, vr - _r), Nr = cr.mapping.map(Ir.offset), Rr = Sr + getDummyCellSize(_r);
      dr[xr] = {
        rowIdx: Ar,
        startColIdx: gr,
        endColIdx: vr,
        dummyOffsets: [Nr, Rr]
      }, xr += 1;
    }
  }
}
function expandRows(cr, ar, lr, ur, dr) {
  var fr = ur.addedRowCount, gr = ur.addedColumnCount, mr = ur.startColIdx, vr = ur.endColIdx, yr = cr.mapping.maps.length, _r = lr.tableEndOffset - 2, kr = createTableBodyRows(fr, lr.totalColumnCount + gr, ar), xr = _r;
  cr.insert(cr.mapping.slice(yr).map(xr), kr);
  for (var Ar = 0; Ar < fr; Ar += 1) {
    var Er = xr + getDummyCellSize(mr) + 1, Cr = xr + getDummyCellSize(vr + 1) + 1, Tr = xr + getDummyCellSize(lr.totalColumnCount + gr) + TR_NODES_SIZE;
    dr.push({
      rowIdx: Ar + lr.totalRowCount,
      startColIdx: mr,
      endColIdx: vr,
      dummyOffsets: [Er, Cr]
    }), xr = Tr;
  }
}
function replaceCells(cr, ar, lr, ur) {
  var dr = cr.mapping.maps.length;
  lr.forEach(function(fr, gr) {
    var mr = fr.rowIdx, vr = fr.startColIdx, yr = fr.endColIdx, _r = fr.dummyOffsets, kr = cr.mapping.slice(dr), xr = new Slice(ar[gr], 0, 0), Ar = _r ? _r[0] : ur.getCellStartOffset(mr, vr), Er = _r ? _r[1] : ur.getCellEndOffset(mr, yr);
    cr.replace(kr.map(Ar), kr.map(Er), xr);
  });
}
function pasteToTable(cr, ar) {
  var lr = cr.state, ur = lr.selection, dr = lr.schema, fr = lr.tr, gr = getResolvedSelection(ur), mr = gr.anchor, vr = gr.head;
  if (mr && vr) {
    var yr = getTableContentFromSlice(ar);
    if (!yr)
      return !1;
    var _r = TableOffsetMap.create(mr), kr = _r.getRectOffsets(mr, vr), xr = createPastingCells(yr, kr, dr), Ar = getPastingRangeInfo(_r, kr, xr), Er = [];
    return canMerge(_r, Ar) && (addReplacedOffsets(Ar, Er), Ar.addedColumnCount && expandColumns(fr, dr, _r, Ar, Er), Ar.addedRowCount && expandRows(fr, dr, _r, Ar, Er), replaceCells(fr, xr, Er, _r), cr.dispatch(fr), setSelection(cr, Er, _r.getCellInfo(0, 0).offset)), !0;
  }
  return !1;
}
function setSelection(cr, ar, lr) {
  var ur = cr.state, dr = ur.tr, fr = ur.doc, gr = TableOffsetMap.create(fr.resolve(lr)), mr = ar[0], vr = mr.rowIdx, yr = mr.startColIdx, _r = last$1(ar), kr = _r.rowIdx, xr = _r.endColIdx, Ar = gr.getCellInfo(vr, yr).offset, Er = gr.getCellInfo(kr, xr).offset;
  cr.dispatch(dr.setSelection(new CellSelection(fr.resolve(Ar), fr.resolve(Er))));
}
function canMerge(cr, ar) {
  var lr = cr.getSpannedOffsets(ar), ur = getRowAndColumnCount(lr), dr = ur.rowCount, fr = ur.columnCount, gr = getRowAndColumnCount(ar), mr = gr.rowCount, vr = gr.columnCount;
  return dr === mr && fr === vr;
}
var Doc = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Paragraph = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: __assign$1({}, getDefaultCustomAttrs()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["p", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), reSoftTabLen = /\s{1,4}$/, Text = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addSpaces = function() {
      return function(lr, ur) {
        var dr = lr.selection, fr = lr.tr, gr = dr.$from, mr = dr.$to, vr = gr.blockRange(mr);
        return vr && !isInListNode(gr) && !isInTableNode(gr) ? (ur(fr.insertText("    ", gr.pos, mr.pos)), !0) : !1;
      };
    }, ar.prototype.removeSpaces = function() {
      return function(lr, ur) {
        var dr = lr.selection, fr = lr.tr, gr = dr.$from, mr = dr.$to, vr = dr.from, yr = gr.blockRange(mr);
        if (yr && !isInListNode(gr) && !isInTableNode(gr)) {
          var _r = gr.nodeBefore;
          if (_r && _r.isText) {
            var kr = _r.text, xr = kr.replace(reSoftTabLen, ""), Ar = kr.length - xr.length;
            return ur(fr.delete(vr - Ar, vr)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    }, ar;
  }(Node$2)
), Heading = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var lr = this.levels.map(function(ur) {
          return {
            tag: "h" + ur,
            getAttrs: function(dr) {
              var fr = dr.getAttribute("data-raw-html");
              return __assign$1({ level: ur }, fr && { rawHTML: fr });
            }
          };
        });
        return {
          attrs: __assign$1({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "inline*",
          group: "block",
          defining: !0,
          parseDOM: lr,
          toDOM: function(ur) {
            var dr = ur.attrs;
            return ["h" + dr.level, getCustomAttrs(dr), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(lr) {
        return function(ur, dr) {
          var fr = ur.schema.nodes[lr.level ? "heading" : "paragraph"];
          return setBlockType(fr, lr)(ur, dr);
        };
      };
    }, ar;
  }(Node$2)
), CodeBlock = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          code: !0,
          defining: !0,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(lr) {
                var ur = lr.getAttribute("data-raw-html"), dr = lr.firstElementChild;
                return __assign$1({ language: (dr == null ? void 0 : dr.getAttribute("data-language")) || null }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return [
              ur.rawHTML || "pre",
              ["code", __assign$1({ "data-language": ur.language }, getCustomAttrs(ur)), 0]
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          return setBlockType(lr.schema.nodes.codeBlock)(lr, ur);
        };
      };
    }, ar.prototype.moveCursor = function(lr) {
      var ur = this;
      return function(dr, fr) {
        var gr = dr.tr, mr = dr.doc, vr = dr.schema, yr = dr.selection.$from, _r = ur.context.view;
        if (_r.endOfTextblock(lr) && yr.node().type.name === "codeBlock") {
          var kr = yr.parent.textContent.split(`
`), xr = lr === "up" ? yr.start() : yr.end(), Ar = lr === "up" ? [xr, kr[0].length + xr] : [xr - last$1(kr).length, xr], Er = mr.resolve(lr === "up" ? yr.before() : yr.after()), Cr = lr === "up" ? Er.nodeBefore : Er.nodeAfter;
          if (between$1(yr.pos, Ar[0], Ar[1]) && !Cr) {
            var Tr = addParagraph(gr, Er, vr);
            if (Tr)
              return fr(Tr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "Shift-Mod-p": lr,
        "Shift-Mod-P": lr,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    }, ar;
  }(Node$2)
), BulletList = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("ul")],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["ul", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.changeList = function() {
      return function(lr, ur) {
        return changeList(lr.schema.nodes.bulletList)(lr, ur);
      };
    }, ar.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: toggleTask
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.changeList(), ur = getWwCommands(), dr = ur.indent, fr = ur.outdent;
      return {
        "Mod-u": lr,
        "Mod-U": lr,
        Tab: dr(),
        "Shift-Tab": fr()
      };
    }, ar;
  }(Node$2)
), OrderedList = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(lr) {
                var ur = lr.getAttribute("start"), dr = lr.getAttribute("data-raw-html");
                return __assign$1({ order: lr.hasAttribute("start") ? Number(ur) : 1 }, dr && { rawHTML: dr });
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return [
              ur.rawHTML || "ol",
              __assign$1({ start: ur.order === 1 ? null : ur.order }, getCustomAttrs(ur)),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          return changeList(lr.schema.nodes.orderedList)(lr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()(), ur = getWwCommands(), dr = ur.indent, fr = ur.outdent;
      return {
        "Mod-o": lr,
        "Mod-O": lr,
        Tab: dr(),
        "Shift-Tab": fr()
      };
    }, ar;
  }(Node$2)
), ListItem = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: !1,
          attrs: {
            task: { default: !1 },
            checked: { default: !1 },
            rawHTML: { default: null }
          },
          defining: !0,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(lr) {
                var ur = lr.getAttribute("data-raw-html");
                return __assign$1({ task: lr.hasAttribute("data-task"), checked: lr.hasAttribute("data-task-checked") }, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs, dr = ur.task, fr = ur.checked;
            if (!dr)
              return [ur.rawHTML || "li", 0];
            var gr = ["task-list-item"];
            return fr && gr.push("checked"), [
              ur.rawHTML || "li",
              __assign$1({ class: gr.join(" "), "data-task": dr }, fr && { "data-task-checked": fr }),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.liftToPrevListItem = function() {
      return function(lr, ur) {
        var dr = lr.selection, fr = lr.tr, gr = lr.schema, mr = dr.$from, vr = dr.empty, yr = gr.nodes.listItem, _r = mr.parent, kr = mr.node(-1);
        if (vr && !_r.childCount && kr.type === yr) {
          if (mr.index(-2) >= 1)
            return fr.delete(mr.start(-1) - 1, mr.end(-1)), ur(fr), !0;
          var xr = mr.node(-3);
          if (xr.type === yr)
            return fr.delete(mr.start(-2) - 1, mr.end(-1)), ur(fr), !0;
        }
        return !1;
      };
    }, ar.prototype.keymaps = function() {
      var lr = function(ur, dr) {
        return splitListItem(ur.schema.nodes.listItem)(ur, dr);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: lr
      };
    }, ar;
  }(Node$2)
), BlockQuote = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "block+",
          group: "block",
          parseDOM: [createDOMInfoParsedRawHTML("blockquote")],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["blockquote", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          return wrapIn(lr.schema.nodes.blockQuote)(lr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "Alt-q": lr,
        "Alt-Q": lr
      };
    }, ar;
  }(Node$2)
), cellOffsetFnMap = {
  left: getLeftCellOffset,
  right: getRightCellOffset,
  up: getUpCellOffset,
  down: getDownCellOffset
};
function isInFirstListItem(cr, ar, lr) {
  var ur = lr[0], dr = lr[1], fr = ar.resolve(cr.before(ur - 1));
  return dr === ur && !fr.nodeBefore;
}
function isInLastListItem(cr) {
  for (var ar, lr = cr.depth, ur; lr && (ur = cr.node(lr), ur.type.name !== "tableBodyCell"); ) {
    if (ur.type.name === "listItem") {
      var dr = cr.node(lr - 1), fr = dr.lastChild === ur, gr = ((ar = ur.lastChild) === null || ar === void 0 ? void 0 : ar.type.name) !== "paragraph";
      return fr ? !gr : !1;
    }
    lr -= 1;
  }
  return !1;
}
function canMoveToBeforeCell(cr, ar, lr, ur, dr) {
  var fr = ar[0], gr = ar[1], mr = ar[2];
  if (cr === "left" || cr === "up") {
    if (dr && !isInFirstListItem(lr, ur, [fr, gr]))
      return !1;
    var vr = lr.before(mr), yr = ur.resolve(vr).nodeBefore;
    if (yr)
      return !1;
  }
  return !0;
}
function canMoveToAfterCell(cr, ar, lr, ur, dr) {
  if (cr === "right" || cr === "down") {
    if (dr && !isInLastListItem(lr))
      return !1;
    var fr = lr.after(ar), gr = ur.resolve(fr).nodeAfter;
    if (gr)
      return !1;
  }
  return !0;
}
function canMoveBetweenCells(cr, ar, lr, ur) {
  var dr = ar[0], fr = ar[1], gr = dr + 3, mr = fr >= gr, vr = mr ? dr + 1 : fr, yr = canMoveToBeforeCell(cr, [fr, gr, vr], lr, ur, mr), _r = canMoveToAfterCell(cr, vr, lr, ur, mr);
  return yr && _r;
}
function canBeOutOfTable(cr, ar, lr) {
  var ur = lr[0], dr = lr[1], fr = ar.getRowspanStartInfo(ur, dr), gr = cr === "up" && ur === 0, mr = cr === "down" && ((fr == null ? void 0 : fr.count) > 1 ? ur + fr.count - 1 : ur) === ar.totalRowCount - 1;
  return gr || mr;
}
function addParagraphBeforeTable(cr, ar, lr) {
  var ur = cr.doc.resolve(ar.tableStartOffset - 1);
  return ur.nodeBefore ? cr.setSelection(Selection.near(ur, -1)) : addParagraph(cr, ur, lr);
}
function addParagraphAfterTable(cr, ar, lr, ur) {
  ur === void 0 && (ur = !1);
  var dr = cr.doc.resolve(ar.tableEndOffset);
  return ur || !dr.nodeAfter ? addParagraph(cr, dr, lr) : cr.setSelection(Selection.near(dr, 1));
}
function getRightCellOffset(cr, ar) {
  var lr = cr[0], ur = cr[1], dr = ar.totalRowCount, fr = ar.totalColumnCount, gr = ur === fr - 1, mr = lr === dr - 1 && gr;
  if (!mr) {
    var vr = ur + 1, yr = ar.getColspanStartInfo(lr, ur);
    (yr == null ? void 0 : yr.count) > 1 && (vr += yr.count - 1), (gr || vr === fr) && (lr += 1, vr = 0);
    var _r = ar.getCellInfo(lr, vr).offset;
    return _r + 2;
  }
  return null;
}
function getLeftCellOffset(cr, ar) {
  var lr = cr[0], ur = cr[1], dr = ar.totalColumnCount, fr = ur === 0, gr = lr === 0 && fr;
  if (!gr) {
    ur -= 1, fr && (lr -= 1, ur = dr - 1);
    var mr = ar.getCellInfo(lr, ur), vr = mr.offset, yr = mr.nodeSize;
    return vr + yr - 2;
  }
  return null;
}
function getUpCellOffset(cr, ar) {
  var lr = cr[0], ur = cr[1];
  if (lr > 0) {
    var dr = ar.getCellInfo(lr - 1, ur), fr = dr.offset, gr = dr.nodeSize;
    return fr + gr - 2;
  }
  return null;
}
function getDownCellOffset(cr, ar) {
  var lr = cr[0], ur = cr[1], dr = ar.totalRowCount;
  if (lr < dr - 1) {
    var fr = lr + 1, gr = ar.getRowspanStartInfo(lr, ur);
    (gr == null ? void 0 : gr.count) > 1 && (fr += gr.count - 1);
    var mr = ar.getCellInfo(fr, ur).offset;
    return mr + 2;
  }
  return null;
}
function moveToCell(cr, ar, lr, ur) {
  var dr = cellOffsetFnMap[cr], fr = dr(lr, ur);
  if (fr) {
    var gr = cr === "right" || cr === "down" ? 1 : -1;
    return ar.setSelection(Selection.near(ar.doc.resolve(fr), gr));
  }
  return null;
}
function canSelectTableNode(cr, ar, lr) {
  var ur = lr[0], dr = lr[1];
  if (cr === "up" || cr === "down")
    return !1;
  var fr = ar.tableStartOffset, gr = ar.tableEndOffset, mr = ar.getCellInfo(ur, dr), vr = mr.offset, yr = mr.nodeSize, _r = cr === "left" ? fr : gr, kr = cr === "left" ? vr - 2 : vr + yr + 3;
  return _r === kr;
}
function selectNode(cr, ar, lr) {
  var ur = cr.doc.resolve(ar.before(lr - 3));
  return cr.setSelection(new NodeSelection(ur));
}
function getTargetRowInfo(cr, ar, lr) {
  var ur, dr, fr;
  return cr === "up" ? (ur = lr.startRowIdx, dr = 0, fr = -1) : (ur = lr.endRowIdx, dr = ar.totalColumnCount - 1, fr = ar.getCellInfo(ur, dr).nodeSize + 1), { targetRowIdx: ur, insertColIdx: dr, nodeSize: fr };
}
function getRowRanges(cr, ar, lr) {
  var ur = cr.getCellInfo(ar, 0).offset, dr = cr.getCellInfo(ar, lr - 1), fr = dr.offset, gr = dr.nodeSize;
  return { from: ur, to: fr + gr };
}
var Table = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("table")],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["table", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addTable = function() {
      return function(lr) {
        return lr === void 0 && (lr = { rowCount: 2, columnCount: 1, data: [] }), function(ur, dr) {
          var fr = lr.rowCount, gr = lr.columnCount, mr = lr.data, vr = ur.schema, yr = ur.selection, _r = ur.tr, kr = yr.from, xr = yr.to, Ar = yr.$from, Er = kr === xr;
          if (Er && !isInTableNode(Ar)) {
            var Cr = vr.nodes, Tr = Cr.tableHead, Sr = Cr.tableBody, Lr = mr == null ? void 0 : mr.slice(0, gr), Ir = mr == null ? void 0 : mr.slice(gr, mr.length), Nr = createTableHeadRow(gr, vr, Lr), Rr = createTableBodyRows(fr - 1, gr, vr, Ir), Mr = vr.nodes.table.create(null, [
              Tr.create(null, Nr),
              Sr.create(null, Rr)
            ]);
            return dr(_r.replaceSelectionWith(Mr)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeTable = function() {
      return function() {
        return function(lr, ur) {
          var dr = lr.selection, fr = lr.tr, gr = TableOffsetMap.create(dr.$anchor);
          if (gr) {
            var mr = gr.tableStartOffset, vr = gr.tableEndOffset, yr = mr - 1, _r = createTextSelection(fr.delete(yr, vr), yr);
            return ur(fr.setSelection(_r)), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addColumn = function(lr) {
      return function() {
        return function(ur, dr) {
          var fr = ur.selection, gr = ur.tr, mr = ur.schema, vr = getResolvedSelection(fr), yr = vr.anchor, _r = vr.head;
          if (yr && _r) {
            for (var kr = TableOffsetMap.create(yr), xr = kr.getRectOffsets(yr, _r), Ar = lr === "left" ? xr.startColIdx : xr.endColIdx + 1, Er = getRowAndColumnCount(xr).columnCount, Cr = kr.totalRowCount, Tr = 0; Tr < Cr; Tr += 1) {
              var Sr = createDummyCells(Er, Tr, mr);
              gr.insert(gr.mapping.map(kr.posAt(Tr, Ar)), Sr);
            }
            return dr(gr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.removeColumn = function() {
      return function() {
        return function(lr, ur) {
          var dr = lr.selection, fr = lr.tr, gr = getResolvedSelection(dr), mr = gr.anchor, vr = gr.head;
          if (mr && vr) {
            var yr = TableOffsetMap.create(mr), _r = yr.getRectOffsets(mr, vr), kr = yr.totalColumnCount, xr = yr.totalRowCount, Ar = getRowAndColumnCount(_r).columnCount, Er = Ar === kr;
            if (Er)
              return !1;
            for (var Cr = _r.startColIdx, Tr = _r.endColIdx, Sr = fr.mapping.maps.length, Lr = 0; Lr < xr; Lr += 1)
              for (var Ir = Tr; Ir >= Cr; Ir -= 1) {
                var Nr = yr.getCellInfo(Lr, Ir), Rr = Nr.offset, Mr = Nr.nodeSize, Br = fr.mapping.slice(Sr).map(Rr), Dr = Br + Mr;
                fr.delete(Br, Dr);
              }
            return ur(fr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.addRow = function(lr) {
      return function() {
        return function(ur, dr) {
          var fr = ur.selection, gr = ur.schema, mr = ur.tr, vr = getResolvedSelection(fr), yr = vr.anchor, _r = vr.head;
          if (yr && _r) {
            var kr = TableOffsetMap.create(yr), xr = kr.totalColumnCount, Ar = kr.getRectOffsets(yr, _r), Er = getRowAndColumnCount(Ar).rowCount, Cr = getTargetRowInfo(lr, kr, Ar), Tr = Cr.targetRowIdx, Sr = Cr.insertColIdx, Lr = Cr.nodeSize, Ir = Tr === 0;
            if (!Ir) {
              for (var Nr = [], Rr = mr.mapping.map(kr.posAt(Tr, Sr)) + Lr, Mr = [], Br = 0; Br < xr; Br += 1)
                Mr = Mr.concat(createDummyCells(1, Tr, gr));
              for (var Dr = 0; Dr < Er; Dr += 1)
                Nr.push(gr.nodes.tableRow.create(null, Mr));
              return dr(mr.insert(Rr, Nr)), !0;
            }
          }
          return !1;
        };
      };
    }, ar.prototype.removeRow = function() {
      return function() {
        return function(lr, ur) {
          var dr = lr.selection, fr = lr.tr, gr = getResolvedSelection(dr), mr = gr.anchor, vr = gr.head;
          if (mr && vr) {
            var yr = TableOffsetMap.create(mr), _r = yr.totalRowCount, kr = yr.totalColumnCount, xr = yr.getRectOffsets(mr, vr), Ar = getRowAndColumnCount(xr).rowCount, Er = xr.startRowIdx, Cr = xr.endRowIdx, Tr = Er === 0, Sr = Ar === _r - 1;
            if (Sr || Tr)
              return !1;
            for (var Lr = Cr; Lr >= Er; Lr -= 1) {
              var Ir = getRowRanges(yr, Lr, kr), Nr = Ir.from, Rr = Ir.to;
              fr.delete(Nr - 1, Rr + 1);
            }
            return ur(fr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.alignColumn = function() {
      return function(lr) {
        return lr === void 0 && (lr = { align: "center" }), function(ur, dr) {
          var fr = lr.align, gr = ur.selection, mr = ur.tr, vr = getResolvedSelection(gr), yr = vr.anchor, _r = vr.head;
          if (yr && _r) {
            for (var kr = TableOffsetMap.create(yr), xr = kr.totalRowCount, Ar = kr.getRectOffsets(yr, _r), Er = Ar.startColIdx, Cr = Ar.endColIdx, Tr = 0; Tr < xr; Tr += 1)
              for (var Sr = Er; Sr <= Cr; Sr += 1)
                if (!kr.extendedRowspan(Tr, Sr) && !kr.extendedColspan(Tr, Sr)) {
                  var Lr = kr.getNodeAndPos(Tr, Sr), Ir = Lr.node, Nr = Lr.pos, Rr = setAttrs(Ir, { align: fr });
                  mr.setNodeMarkup(Nr, null, Rr);
                }
            return dr(mr), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.moveToCell = function(lr) {
      return function(ur, dr) {
        var fr = ur.selection, gr = ur.tr, mr = ur.schema, vr = getResolvedSelection(fr), yr = vr.anchor, _r = vr.head;
        if (yr && _r) {
          var kr = TableOffsetMap.create(yr), xr = kr.getCellIndex(yr), Ar = void 0;
          if (canBeOutOfTable(lr, kr, xr) ? Ar = addParagraphAfterTable(gr, kr, mr) : Ar = moveToCell(lr, gr, xr, kr), Ar)
            return dr(Ar), !0;
        }
        return !1;
      };
    }, ar.prototype.moveInCell = function(lr) {
      var ur = this;
      return function(dr, fr) {
        var gr = dr.selection, mr = dr.tr, vr = dr.doc, yr = dr.schema, _r = gr.$from, kr = ur.context.view;
        if (!kr.endOfTextblock(lr))
          return !1;
        var xr = findNodeBy(_r, function(Ir) {
          var Nr = Ir.type;
          return Nr.name === "tableHeadCell" || Nr.name === "tableBodyCell";
        });
        if (xr) {
          var Ar = findNodeBy(_r, function(Ir) {
            var Nr = Ir.type;
            return Nr.name === "paragraph";
          }), Er = xr.depth;
          if (Ar && canMoveBetweenCells(lr, [Er, Ar.depth], _r, vr)) {
            var Cr = getResolvedSelection(gr).anchor, Tr = TableOffsetMap.create(Cr), Sr = Tr.getCellIndex(Cr), Lr = void 0;
            if (canSelectTableNode(lr, Tr, Sr) ? Lr = selectNode(mr, _r, Er) : canBeOutOfTable(lr, Tr, Sr) ? lr === "up" ? Lr = addParagraphBeforeTable(mr, Tr, yr) : lr === "down" && (Lr = addParagraphAfterTable(mr, Tr, yr)) : Lr = moveToCell(lr, mr, Sr, Tr), Lr)
              return fr(Lr), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.deleteCells = function() {
      return function(lr, ur) {
        var dr = lr.schema, fr = lr.selection, gr = lr.tr, mr = getResolvedSelection(fr), vr = mr.anchor, yr = mr.head, _r = fr instanceof TextSelection;
        if (vr && yr && !_r) {
          for (var kr = TableOffsetMap.create(vr), xr = kr.getRectOffsets(vr, yr), Ar = xr.startRowIdx, Er = xr.startColIdx, Cr = xr.endRowIdx, Tr = xr.endColIdx, Sr = Ar; Sr <= Cr; Sr += 1)
            for (var Lr = Er; Lr <= Tr; Lr += 1)
              if (!kr.extendedRowspan(Sr, Lr) && !kr.extendedColspan(Sr, Lr)) {
                var Ir = kr.getNodeAndPos(Sr, Lr), Nr = Ir.node, Rr = Ir.pos, Mr = createDummyCells(1, Sr, dr, Nr.attrs);
                gr.replaceWith(gr.mapping.map(Rr), gr.mapping.map(Rr + Nr.nodeSize), Mr);
              }
          return ur(gr), !0;
        }
        return !1;
      };
    }, ar.prototype.exitTable = function() {
      return function(lr, ur) {
        var dr = lr.selection, fr = lr.tr, gr = lr.schema, mr = dr.$from, vr = findNodeBy(mr, function(xr) {
          var Ar = xr.type;
          return Ar.name === "tableHeadCell" || Ar.name === "tableBodyCell";
        });
        if (vr) {
          var yr = findNodeBy(mr, function(xr) {
            var Ar = xr.type;
            return Ar.name === "paragraph";
          });
          if (yr) {
            var _r = getResolvedSelection(dr).anchor, kr = TableOffsetMap.create(_r);
            return ur(addParagraphAfterTable(fr, kr, gr, !0)), !0;
          }
        }
        return !1;
      };
    }, ar.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: lr,
        "Mod-Backspace": lr,
        Delete: lr,
        "Mod-Delete": lr,
        "Mod-Enter": this.exitTable()
      };
    }, ar;
  }(Node$2)
), TableHead = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("thead")],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["thead", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(lr) {
                var ur = lr.querySelectorAll("tr"), dr = ur[0].children.length, fr = lr.getAttribute("data-raw-html");
                return dr ? __assign$1({}, fr && { rawHTML: fr }) : !1;
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["tbody", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableRow = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(lr) {
                var ur = lr.children.length, dr = lr.getAttribute("data-raw-html");
                return ur ? __assign$1({}, dr && { rawHTML: dr }) : !1;
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["tr", getCustomAttrs(ur), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableHeadCell = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),
          isolating: !0,
          parseDOM: [createParsedCellDOM("th")],
          toDOM: function(lr) {
            var ur = lr.attrs, dr = createCellAttrs(ur);
            return ["th", __assign$1(__assign$1({}, dr), getCustomAttrs(ur)), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), TableBodyCell = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: !0,
          parseDOM: [createParsedCellDOM("td")],
          toDOM: function(lr) {
            var ur = lr.attrs, dr = createCellAttrs(ur);
            return ["td", dr, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar;
  }(Node$2)
), Image = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          inline: !0,
          attrs: __assign$1({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "inline",
          selectable: !1,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(lr) {
                var ur = sanitizeHTML(lr, { RETURN_DOM_FRAGMENT: !0 }).firstChild, dr = ur.getAttribute("src") || "", fr = ur.getAttribute("data-raw-html"), gr = ur.getAttribute("alt");
                return __assign$1({
                  imageUrl: dr,
                  altText: gr
                }, fr && { rawHTML: fr });
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return [
              ur.rawHTML || "img",
              __assign$1(__assign$1({ src: escapeXml$1(ur.imageUrl) }, ur.altText && { alt: ur.altText }), getCustomAttrs(ur))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addImage = function() {
      return function(lr) {
        return function(ur, dr) {
          var fr = ur.schema, gr = ur.tr, mr = lr, vr = mr.imageUrl, yr = mr.altText;
          if (!vr)
            return !1;
          var _r = fr.nodes.image.createAndFill(__assign$1({ imageUrl: vr }, yr && { altText: yr }));
          return dr(gr.replaceSelectionWith(_r).scrollIntoView()), !0;
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    }, ar;
  }(Node$2)
), ROOT_BLOCK_DEPTH = 1, ThematicBreak = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: !1,
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["div", getCustomAttrs(ur), [ur.rawHTML || "hr"]];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.hr = function() {
      var lr = this;
      return function() {
        return function(ur, dr) {
          var fr, gr = ur.selection, mr = gr.$from, vr = gr.$to;
          if (mr === vr) {
            var yr = ur.doc, _r = ur.schema.nodes, kr = _r.thematicBreak, xr = _r.paragraph, Ar = [kr.create()], Er = mr.node(ROOT_BLOCK_DEPTH), Cr = yr.child(yr.childCount - 1) === Er, Tr = yr.resolve(mr.after(ROOT_BLOCK_DEPTH)), Sr = ((fr = mr.nodeAfter) === null || fr === void 0 ? void 0 : fr.type.name) === lr.name;
            return (Cr || Sr) && Ar.push(xr.create()), dr(ur.tr.insert(Tr.pos, Ar).scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.commands = function() {
      return { hr: this.hr() };
    }, ar.prototype.keymaps = function() {
      var lr = this.hr()();
      return {
        "Mod-l": lr,
        "Mod-L": lr
      };
    }, ar;
  }(Node$2)
), Strong = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var lr = ["b", "strong"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(dr) {
              var fr = dr.getAttribute("data-raw-html");
              return __assign$1({}, fr && { rawHTML: fr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: lr,
          toDOM: function(ur) {
            var dr = ur.attrs;
            return [dr.rawHTML || "strong", getCustomAttrs(dr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.bold = function() {
      return function() {
        return function(lr, ur) {
          return toggleMark$1(lr.schema.marks.strong)(lr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { bold: this.bold() };
    }, ar.prototype.keymaps = function() {
      var lr = this.bold()();
      return {
        "Mod-b": lr,
        "Mod-B": lr
      };
    }, ar;
  }(Mark)
), Emph = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var lr = ["i", "em"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(dr) {
              var fr = dr.getAttribute("data-raw-html");
              return __assign$1({}, fr && { rawHTML: fr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: lr,
          toDOM: function(ur) {
            var dr = ur.attrs;
            return [dr.rawHTML || "em", getCustomAttrs(dr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.italic = function() {
      return function() {
        return function(lr, ur) {
          return toggleMark$1(lr.schema.marks.emph)(lr, ur);
        };
      };
    }, ar.prototype.commands = function() {
      return { italic: this.italic() };
    }, ar.prototype.keymaps = function() {
      var lr = this.italic()();
      return {
        "Mod-i": lr,
        "Mod-I": lr
      };
    }, ar;
  }(Mark)
), Strike = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var lr = ["s", "del"].map(function(ur) {
          return {
            tag: ur,
            getAttrs: function(dr) {
              var fr = dr.getAttribute("data-raw-html");
              return __assign$1({}, fr && { rawHTML: fr });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: lr,
          toDOM: function(ur) {
            var dr = ur.attrs;
            return [dr.rawHTML || "del", getCustomAttrs(dr)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          return toggleMark$1(lr.schema.marks.strike)(lr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "Mod-s": lr,
        "Mod-S": lr
      };
    }, ar;
  }(Mark)
), Link = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this) || this;
      return ur.linkAttributes = lr, ur;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        var lr = this;
        return {
          attrs: __assign$1({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          inclusive: !1,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(ur) {
                var dr = sanitizeHTML(ur, { RETURN_DOM_FRAGMENT: !0 }).firstChild, fr = dr.getAttribute("href") || "", gr = dr.getAttribute("title") || "", mr = dr.getAttribute("data-raw-html");
                return __assign$1({ linkUrl: fr, title: gr }, mr && { rawHTML: mr });
              }
            }
          ],
          toDOM: function(ur) {
            var dr = ur.attrs;
            return [
              dr.rawHTML || "a",
              __assign$1(__assign$1({ href: escapeXml$1(dr.linkUrl) }, lr.linkAttributes), getCustomAttrs(dr))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.addLink = function() {
      return function(lr) {
        return function(ur, dr) {
          var fr = lr, gr = fr.linkUrl, mr = fr.linkText, vr = mr === void 0 ? "" : mr, yr = ur.schema, _r = ur.tr, kr = ur.selection, xr = kr.empty, Ar = kr.from, Er = kr.to;
          if (Ar && Er && gr) {
            var Cr = { linkUrl: gr }, Tr = yr.mark("link", Cr);
            if (xr && vr) {
              var Sr = createTextNode$1(yr, vr, Tr);
              _r.replaceRangeWith(Ar, Er, Sr);
            } else
              _r.addMark(Ar, Er, Tr);
            return dr(_r.scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, ar.prototype.toggleLink = function() {
      return function(lr) {
        return function(ur, dr) {
          return toggleMark$1(ur.schema.marks.link, lr)(ur, dr);
        };
      };
    }, ar.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    }, ar;
  }(Mark)
), Code = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(lr) {
                var ur = lr.getAttribute("data-raw-html");
                return __assign$1({}, ur && { rawHTML: ur });
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return [ur.rawHTML || "code", getCustomAttrs(ur)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur) {
          return toggleMark$1(lr.schema.marks.code)(lr, ur);
        };
      };
    }, ar.prototype.keymaps = function() {
      var lr = this.commands()();
      return {
        "Shift-Mod-c": lr,
        "Shift-Mod-C": lr
      };
    }, ar;
  }(Mark)
), CustomBlock = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: !0,
          code: !0,
          defining: !0,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(lr) {
                var ur = lr.getAttribute("data-custom-info");
                return { info: ur };
              }
            }
          ],
          toDOM: function(lr) {
            var ur = lr.attrs;
            return ["div", { "data-custom-info": ur.info || null }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function(lr) {
        return function(ur, dr) {
          return lr != null && lr.info ? setBlockType(ur.schema.nodes.customBlock, lr)(ur, dr) : !1;
        };
      };
    }, ar;
  }(Node$2)
), FrontMatter = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur, dr) {
          var fr = lr.selection.$from;
          return dr.endOfTextblock("down") && fr.node().type.name === "frontMatter" ? exitCode(lr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
), HTMLComment = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return Object.defineProperty(ar.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ar.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), ar.prototype.commands = function() {
      return function() {
        return function(lr, ur, dr) {
          var fr = lr.selection.$from;
          return dr.endOfTextblock("down") && fr.node().type.name === "htmlComment" ? exitCode(lr, ur) : !1;
        };
      };
    }, ar.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, ar;
  }(Node$2)
);
function createSpecs(cr) {
  return new SpecManager([
    new Doc(),
    new Paragraph(),
    new Text(),
    new Heading(),
    new CodeBlock(),
    new BulletList(),
    new OrderedList(),
    new ListItem(),
    new BlockQuote(),
    new Table(),
    new TableHead(),
    new TableBody(),
    new TableRow(),
    new TableHeadCell(),
    new TableBodyCell(),
    new Image(),
    new ThematicBreak(),
    new Strong(),
    new Emph(),
    new Strike(),
    new Link(cr),
    new Code(),
    new CustomBlock(),
    new FrontMatter(),
    new Widget(),
    new HTMLComment()
  ]);
}
var CONTENTS_CLASS_NAME = cls("contents"), WysiwygEditor = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr, ur) {
      var dr = cr.call(this, lr) || this, fr = ur.toDOMAdaptor, gr = ur.htmlSchemaMap, mr = gr === void 0 ? {} : gr, vr = ur.linkAttributes, yr = vr === void 0 ? {} : vr, _r = ur.useCommandShortcut, kr = _r === void 0 ? !0 : _r, xr = ur.wwPlugins, Ar = xr === void 0 ? [] : xr, Er = ur.wwNodeViews, Cr = Er === void 0 ? {} : Er;
      return dr.editorType = "wysiwyg", dr.el.classList.add("ww-mode"), dr.toDOMAdaptor = fr, dr.linkAttributes = yr, dr.extraPlugins = Ar, dr.pluginNodeViews = Cr, dr.specs = dr.createSpecs(), dr.schema = dr.createSchema(mr), dr.context = dr.createContext(), dr.keymaps = dr.createKeymaps(kr), dr.view = dr.createView(), dr.commands = dr.createCommands(), dr.specs.setContext(__assign$1(__assign$1({}, dr.context), { view: dr.view })), dr.initEvent(), dr;
    }
    return ar.prototype.createSpecs = function() {
      return createSpecs(this.linkAttributes);
    }, ar.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, ar.prototype.createSchema = function(lr) {
      return new Schema({
        nodes: __assign$1(__assign$1({}, this.specs.nodes), lr.nodes),
        marks: __assign$1(__assign$1({}, this.specs.marks), lr.marks)
      });
    }, ar.prototype.createPlugins = function() {
      return __spreadArray$1([
        tableSelection(),
        tableContextMenu(this.eventEmitter),
        task(),
        toolbarStateHighlight(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, ar.prototype.createPluginNodeViews = function() {
      var lr = this, ur = lr.eventEmitter, dr = lr.pluginNodeViews, fr = {};
      return dr && Object.keys(dr).forEach(function(gr) {
        fr[gr] = function(mr, vr, yr) {
          return dr[gr](mr, vr, yr, ur);
        };
      }), fr;
    }, ar.prototype.createView = function() {
      var lr = this, ur = this, dr = ur.toDOMAdaptor, fr = ur.eventEmitter;
      return new EditorView(this.el, {
        state: this.createState(),
        attributes: {
          class: CONTENTS_CLASS_NAME
        },
        nodeViews: __assign$1({
          customBlock: function(gr, mr, vr) {
            return new CustomBlockView(gr, mr, vr, dr);
          },
          image: function(gr, mr, vr) {
            return new ImageView(gr, mr, vr, fr);
          },
          codeBlock: function(gr, mr, vr) {
            return new CodeBlockView(gr, mr, vr, fr);
          },
          widget: widgetNodeView
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(gr) {
          var mr = lr.view.state.applyTransaction(gr).state;
          lr.view.updateState(mr), lr.emitChangeEvent(gr.scrollIntoView()), lr.eventEmitter.emit("setFocusedNode", mr.selection.$from.node(1));
        },
        transformPastedHTML: changePastedHTML,
        transformPasted: function(gr) {
          return changePastedSlice(gr, lr.schema, isInTableNode(lr.view.state.selection.$from));
        },
        handlePaste: function(gr, mr, vr) {
          return pasteToTable(gr, vr);
        },
        handleKeyDown: function(gr, mr) {
          return lr.eventEmitter.emit("keydown", lr.editorType, mr), !1;
        },
        handleDOMEvents: {
          paste: function(gr, mr) {
            var vr = mr.clipboardData || window.clipboardData, yr = vr == null ? void 0 : vr.items;
            if (yr) {
              var _r = toArray_1(yr).some(function(xr) {
                return xr.kind === "string" && xr.type === "text/rtf";
              });
              if (!_r) {
                var kr = pasteImageOnly(yr);
                kr && (mr.preventDefault(), emitImageBlobHook(lr.eventEmitter, kr, mr.type));
              }
            }
            return !1;
          },
          keyup: function(gr, mr) {
            return lr.eventEmitter.emit("keyup", lr.editorType, mr), !1;
          },
          scroll: function() {
            return lr.eventEmitter.emit("scroll", "editor"), !0;
          }
        }
      });
    }, ar.prototype.createCommands = function() {
      return this.specs.commands(this.view, getWwCommands());
    }, ar.prototype.getHTML = function() {
      return removeProseMirrorHackNodes(this.view.dom.innerHTML);
    }, ar.prototype.getModel = function() {
      return this.view.state.doc;
    }, ar.prototype.getSelection = function() {
      var lr = this.view.state.selection, ur = lr.from, dr = lr.to;
      return [ur, dr];
    }, ar.prototype.getSchema = function() {
      return this.view.state.schema;
    }, ar.prototype.replaceSelection = function(lr, ur, dr) {
      var fr = this.view.state, gr = fr.schema, mr = fr.tr, vr = lr.split(`
`), yr = vr.map(function(xr) {
        return createParagraph(gr, createNodesWithWidget(xr, gr));
      }), _r = new Slice(Fragment.from(yr), 1, 1), kr = isNumber_1(ur) && isNumber_1(dr) ? mr.replaceRange(ur, dr, _r) : mr.replaceSelection(_r);
      this.view.dispatch(kr), this.focus();
    }, ar.prototype.deleteSelection = function(lr, ur) {
      var dr = this.view.state.tr, fr = isNumber_1(lr) && isNumber_1(ur) ? dr.deleteRange(lr, ur) : dr.deleteSelection();
      this.view.dispatch(fr.scrollIntoView());
    }, ar.prototype.getSelectedText = function(lr, ur) {
      var dr = this.view.state, fr = dr.doc, gr = dr.selection, mr = gr.from, vr = gr.to;
      return isNumber_1(lr) && isNumber_1(ur) && (mr = lr, vr = ur), fr.textBetween(mr, vr, `
`);
    }, ar.prototype.setModel = function(lr, ur) {
      ur === void 0 && (ur = !1);
      var dr = this.view.state, fr = dr.tr, gr = dr.doc;
      this.view.dispatch(fr.replaceWith(0, gr.content.size, lr)), ur && this.moveCursorToEnd(!0);
    }, ar.prototype.setSelection = function(lr, ur) {
      ur === void 0 && (ur = lr);
      var dr = this.view.state.tr, fr = createTextSelection(dr, lr, ur);
      this.view.dispatch(dr.setSelection(fr).scrollIntoView());
    }, ar.prototype.addWidget = function(lr, ur, dr) {
      var fr = this.view, gr = fr.dispatch, mr = fr.state;
      gr(mr.tr.setMeta("widget", { pos: dr != null ? dr : mr.selection.to, node: lr, style: ur }));
    }, ar.prototype.replaceWithWidget = function(lr, ur, dr) {
      var fr = this.view.state, gr = fr.tr, mr = fr.schema, vr = createNodesWithWidget(dr, mr);
      this.view.dispatch(gr.replaceWith(lr, ur, vr));
    }, ar.prototype.getRangeInfoOfNode = function(lr) {
      var ur = this.view.state, dr = ur.doc, fr = ur.selection, gr = lr ? dr.resolve(lr) : fr.$from, mr = gr.marks(), vr = gr.node(), yr = gr.start(), _r = gr.end(), kr = vr.type.name;
      if (mr.length || kr === "paragraph") {
        var xr = mr[mr.length - 1], Ar = function(Er) {
          return Er.length ? includes(Er, xr) : !0;
        };
        kr = xr ? xr.type.name : "text", vr.forEach(function(Er, Cr) {
          var Tr = Er.isText, Sr = Er.nodeSize, Lr = Er.marks, Ir = gr.pos - yr;
          Tr && Cr <= Ir && Cr + Sr >= Ir && Ar(Lr) && (yr = yr + Cr, _r = yr + Sr);
        });
      }
      return { range: [yr, _r], type: kr };
    }, ar;
  }(EditorBase)
), isUndefined = isUndefined_1, isNull = isNull_1;
function isExisty$1(cr) {
  return !isUndefined(cr) && !isNull(cr);
}
var isExisty_1 = isExisty$1, isExisty = isExisty_1;
function isTruthy$1(cr) {
  return isExisty(cr) && cr !== !1;
}
var isTruthy_1 = isTruthy$1, isTruthy = isTruthy_1;
function isFalsy(cr) {
  return !isTruthy(cr);
}
var isFalsy_1 = isFalsy, eventTypeList = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
], EventEmitter = (
  /** @class */
  function() {
    function cr() {
      var ar = this;
      this.events = new Map$1(), this.eventTypes = eventTypeList.reduce(function(lr, ur) {
        return __assign$1(__assign$1({}, lr), { type: ur });
      }, {}), this.hold = !1, eventTypeList.forEach(function(lr) {
        ar.addEventType(lr);
      });
    }
    return cr.prototype.listen = function(ar, lr) {
      var ur = this.getTypeInfo(ar), dr = this.events.get(ur.type) || [];
      if (!this.hasEventType(ur.type))
        throw new Error("There is no event type " + ur.type);
      ur.namespace && (lr.namespace = ur.namespace), dr.push(lr), this.events.set(ur.type, dr);
    }, cr.prototype.emit = function(ar) {
      for (var lr = [], ur = 1; ur < arguments.length; ur++)
        lr[ur - 1] = arguments[ur];
      var dr = this.getTypeInfo(ar), fr = this.events.get(dr.type), gr = [];
      return !this.hold && fr && fr.forEach(function(mr) {
        var vr = mr.apply(void 0, lr);
        isUndefined_1(vr) || gr.push(vr);
      }), gr;
    }, cr.prototype.emitReduce = function(ar, lr) {
      for (var ur = [], dr = 2; dr < arguments.length; dr++)
        ur[dr - 2] = arguments[dr];
      var fr = this.events.get(ar);
      return !this.hold && fr && fr.forEach(function(gr) {
        var mr = gr.apply(void 0, __spreadArray$1([lr], ur));
        isFalsy_1(mr) || (lr = mr);
      }), lr;
    }, cr.prototype.getTypeInfo = function(ar) {
      var lr = ar.split(".");
      return {
        type: lr[0],
        namespace: lr[1]
      };
    }, cr.prototype.hasEventType = function(ar) {
      return !isUndefined_1(this.eventTypes[this.getTypeInfo(ar).type]);
    }, cr.prototype.addEventType = function(ar) {
      if (this.hasEventType(ar))
        throw new Error("There is already have event type " + ar);
      this.eventTypes[ar] = ar;
    }, cr.prototype.removeEventHandler = function(ar, lr) {
      var ur = this, dr = this.getTypeInfo(ar), fr = dr.type, gr = dr.namespace;
      fr && lr ? this.removeEventHandlerWithHandler(fr, lr) : fr && !gr ? this.events.delete(fr) : !fr && gr ? this.events.forEach(function(mr, vr) {
        ur.removeEventHandlerWithTypeInfo(vr, gr);
      }) : fr && gr && this.removeEventHandlerWithTypeInfo(fr, gr);
    }, cr.prototype.removeEventHandlerWithHandler = function(ar, lr) {
      var ur = this.events.get(ar);
      if (ur) {
        var dr = ur.indexOf(lr);
        ur.indexOf(lr) >= 0 && ur.splice(dr, 1);
      }
    }, cr.prototype.removeEventHandlerWithTypeInfo = function(ar, lr) {
      var ur = [], dr = this.events.get(ar);
      dr && (dr.map(function(fr) {
        return fr.namespace !== lr && ur.push(fr), null;
      }), this.events.set(ar, ur));
    }, cr.prototype.getEvents = function() {
      return this.events;
    }, cr.prototype.holdEventInvoke = function(ar) {
      this.hold = !0, ar(), this.hold = !1;
    }, cr;
  }()
), CommandManager = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      this.eventEmitter = ar, this.mdCommands = lr, this.wwCommands = ur, this.getEditorType = dr, this.initEvent();
    }
    return cr.prototype.initEvent = function() {
      var ar = this;
      this.eventEmitter.listen("command", function(lr, ur) {
        ar.exec(lr, ur);
      });
    }, cr.prototype.addCommand = function(ar, lr, ur) {
      ar === "markdown" ? this.mdCommands[lr] = ur : this.wwCommands[lr] = ur;
    }, cr.prototype.deleteCommand = function(ar, lr) {
      ar === "markdown" ? delete this.mdCommands[lr] : delete this.wwCommands[lr];
    }, cr.prototype.exec = function(ar, lr) {
      var ur = this.getEditorType();
      ur === "markdown" ? this.mdCommands[ar](lr) : this.wwCommands[ar](lr);
    }, cr;
  }()
);
function getTextWithoutTrailingNewline(cr) {
  return cr[cr.length - 1] === `
` ? cr.slice(0, cr.length - 1) : cr;
}
function isCustomHTMLInlineNode(cr, ar) {
  var lr = cr.schema, ur = ar.literal, dr = ur.match(reHTMLTag);
  if (dr) {
    var fr = dr[1], gr = dr[3], mr = (fr || gr).toLowerCase();
    return ar.type === "htmlInline" && !!(lr.marks[mr] || lr.nodes[mr]);
  }
  return !1;
}
function isInlineNode(cr) {
  var ar = cr.type;
  return includes(["text", "strong", "emph", "strike", "image", "link", "code"], ar);
}
function isSoftbreak(cr) {
  return (cr == null ? void 0 : cr.type) === "softbreak";
}
function isListNode(cr) {
  var ar = cr.type, lr = cr.literal, ur = ar === "htmlInline" && lr.match(reHTMLTag);
  if (ur) {
    var dr = ur[1], fr = ur[3], gr = dr || fr;
    if (gr)
      return includes(["ul", "ol", "li"], gr.toLowerCase());
  }
  return !1;
}
function getListItemAttrs(cr) {
  var ar = cr.literal, lr = /data-task/.test(ar), ur = /data-task-checked/.test(ar);
  return { task: lr, checked: ur };
}
function getMatchedAttributeValue(cr) {
  for (var ar = [], lr = 1; lr < arguments.length; lr++)
    ar[lr - 1] = arguments[lr];
  var ur = document.createElement("div");
  ur.innerHTML = sanitizeHTML(cr);
  var dr = ur.firstChild;
  return ar.map(function(fr) {
    return dr.getAttribute(fr) || "";
  });
}
function createConvertors(cr) {
  var ar = {};
  return Object.keys(cr).forEach(function(lr) {
    var ur = lr.split(", ");
    ur.forEach(function(dr) {
      var fr = dr.toLowerCase();
      ar[fr] = cr[lr];
    });
  }), ar;
}
var convertors = {
  "b, strong": function(cr, ar, lr) {
    var ur = cr.schema.marks.strong;
    lr ? cr.openMark(ur.create({ rawHTML: lr })) : cr.closeMark(ur);
  },
  "i, em": function(cr, ar, lr) {
    var ur = cr.schema.marks.emph;
    lr ? cr.openMark(ur.create({ rawHTML: lr })) : cr.closeMark(ur);
  },
  "s, del": function(cr, ar, lr) {
    var ur = cr.schema.marks.strike;
    lr ? cr.openMark(ur.create({ rawHTML: lr })) : cr.closeMark(ur);
  },
  code: function(cr, ar, lr) {
    var ur = cr.schema.marks.code;
    lr ? cr.openMark(ur.create({ rawHTML: lr })) : cr.closeMark(ur);
  },
  a: function(cr, ar, lr) {
    var ur = ar.literal, dr = cr.schema.marks.link;
    if (lr) {
      var fr = getMatchedAttributeValue(ur, "href")[0];
      cr.openMark(dr.create({
        linkUrl: fr,
        rawHTML: lr
      }));
    } else
      cr.closeMark(dr);
  },
  img: function(cr, ar, lr) {
    var ur = ar.literal;
    if (lr) {
      var dr = getMatchedAttributeValue(ur, "src", "alt"), fr = dr[0], gr = dr[1], mr = cr.schema.nodes.image;
      cr.addNode(mr, __assign$1({ rawHTML: lr, imageUrl: fr }, gr && { altText: gr }));
    }
  },
  hr: function(cr, ar, lr) {
    cr.addNode(cr.schema.nodes.thematicBreak, { rawHTML: lr });
  },
  br: function(cr, ar) {
    var lr = cr.schema.nodes.paragraph, ur = ar.parent, dr = ar.prev, fr = ar.next;
    (ur == null ? void 0 : ur.type) === "paragraph" ? (isSoftbreak(dr) && cr.openNode(lr), isSoftbreak(fr) ? cr.closeNode() : fr && (cr.closeNode(), cr.openNode(lr))) : (ur == null ? void 0 : ur.type) === "tableCell" && (dr && (isInlineNode(dr) || isCustomHTMLInlineNode(cr, dr)) && cr.closeNode(), fr && (isInlineNode(fr) || isCustomHTMLInlineNode(cr, fr)) && cr.openNode(lr));
  },
  pre: function(cr, ar, lr) {
    var ur, dr, fr = document.createElement("div");
    fr.innerHTML = ar.literal;
    var gr = (dr = (ur = fr.firstChild) === null || ur === void 0 ? void 0 : ur.firstChild) === null || dr === void 0 ? void 0 : dr.textContent;
    cr.openNode(cr.schema.nodes.codeBlock, { rawHTML: lr }), cr.addText(getTextWithoutTrailingNewline(gr)), cr.closeNode();
  },
  "ul, ol": function(cr, ar, lr) {
    if (ar.parent.type === "tableCell") {
      var ur = cr.schema.nodes, dr = ur.bulletList, fr = ur.orderedList, gr = ur.paragraph, mr = lr === "ul" ? dr : fr;
      lr ? (ar.prev && !isListNode(ar.prev) && cr.closeNode(), cr.openNode(mr, { rawHTML: lr })) : (cr.closeNode(), ar.next && !isListNode(ar.next) && cr.openNode(gr));
    }
  },
  li: function(cr, ar, lr) {
    var ur;
    if (((ur = ar.parent) === null || ur === void 0 ? void 0 : ur.type) === "tableCell") {
      var dr = cr.schema.nodes, fr = dr.listItem, gr = dr.paragraph;
      if (lr) {
        var mr = getListItemAttrs(ar);
        ar.prev && !isListNode(ar.prev) && cr.closeNode(), cr.openNode(fr, __assign$1({ rawHTML: lr }, mr)), ar.next && !isListNode(ar.next) && cr.openNode(gr);
      } else
        ar.prev && !isListNode(ar.prev) && cr.closeNode(), cr.closeNode();
    }
  }
}, htmlToWwConvertors = createConvertors(convertors);
function isBRTag(cr) {
  return cr.type === "htmlInline" && reBR.test(cr.literal);
}
function addRawHTMLAttributeToDOM(cr) {
  toArray_1(cr.childNodes).forEach(function(ar) {
    if (isElemNode(ar)) {
      var lr = ar.nodeName.toLowerCase();
      ar.setAttribute("data-raw-html", lr), ar.childNodes && addRawHTMLAttributeToDOM(ar);
    }
  });
}
var toWwConvertors = {
  text: function(cr, ar) {
    cr.addText(ar.literal || "");
  },
  paragraph: function(cr, ar, lr, ur) {
    var dr, fr = lr.entering;
    if (fr) {
      var gr = cr.schema.nodes.paragraph;
      ((dr = ar.prev) === null || dr === void 0 ? void 0 : dr.type) === "paragraph" && (cr.openNode(gr, ur), cr.closeNode()), cr.openNode(gr, ur);
    } else
      cr.closeNode();
  },
  heading: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    if (dr) {
      var fr = ar, gr = fr.level, mr = fr.headingType;
      cr.openNode(cr.schema.nodes.heading, __assign$1({ level: gr, headingType: mr }, ur));
    } else
      cr.closeNode();
  },
  codeBlock: function(cr, ar, lr) {
    var ur = cr.schema.nodes.codeBlock, dr = ar, fr = dr.info, gr = dr.literal;
    cr.openNode(ur, __assign$1({ language: fr }, lr)), cr.addText(getTextWithoutTrailingNewline(gr || "")), cr.closeNode();
  },
  list: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    if (dr) {
      var fr = cr.schema.nodes, gr = fr.bulletList, mr = fr.orderedList, vr = ar.listData, yr = vr.type, _r = vr.start;
      yr === "bullet" ? cr.openNode(gr, ur) : cr.openNode(mr, __assign$1({ order: _r }, ur));
    } else
      cr.closeNode();
  },
  item: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = cr.schema.nodes.listItem, gr = ar.listData, mr = gr.task, vr = gr.checked;
    if (dr) {
      var yr = __assign$1(__assign$1(__assign$1({}, mr && { task: mr }), vr && { checked: vr }), ur);
      cr.openNode(fr, yr);
    } else
      cr.closeNode();
  },
  blockQuote: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    dr ? cr.openNode(cr.schema.nodes.blockQuote, ur) : cr.closeNode();
  },
  image: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = lr.skipChildren, gr = cr.schema.nodes.image, mr = ar, vr = mr.destination, yr = mr.firstChild;
    dr && fr && fr(), cr.addNode(gr, __assign$1(__assign$1({ imageUrl: vr }, yr && { altText: yr.literal }), ur));
  },
  thematicBreak: function(cr, ar, lr, ur) {
    cr.addNode(cr.schema.nodes.thematicBreak, ur);
  },
  strong: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = cr.schema.marks.strong;
    dr ? cr.openMark(fr.create(ur)) : cr.closeMark(fr);
  },
  emph: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = cr.schema.marks.emph;
    dr ? cr.openMark(fr.create(ur)) : cr.closeMark(fr);
  },
  link: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = cr.schema.marks.link, gr = ar, mr = gr.destination, vr = gr.title;
    if (dr) {
      var yr = __assign$1({ linkUrl: mr, title: vr }, ur);
      cr.openMark(fr.create(yr));
    } else
      cr.closeMark(fr);
  },
  softbreak: function(cr, ar) {
    if (ar.parent.type === "paragraph") {
      var lr = ar.prev, ur = ar.next;
      lr && !isBRTag(lr) && cr.closeNode(), ur && !isBRTag(ur) && cr.openNode(cr.schema.nodes.paragraph);
    }
  },
  // GFM specifications node
  table: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    dr ? cr.openNode(cr.schema.nodes.table, ur) : cr.closeNode();
  },
  tableHead: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    dr ? cr.openNode(cr.schema.nodes.tableHead, ur) : cr.closeNode();
  },
  tableBody: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    dr ? cr.openNode(cr.schema.nodes.tableBody, ur) : cr.closeNode();
  },
  tableRow: function(cr, ar, lr, ur) {
    var dr = lr.entering;
    dr ? cr.openNode(cr.schema.nodes.tableRow, ur) : cr.closeNode();
  },
  tableCell: function(cr, ar, lr) {
    var ur = lr.entering;
    if (!ar.ignored) {
      var dr = function(Er) {
        return Er && (isInlineNode(Er) || isCustomHTMLInlineNode(cr, Er));
      };
      if (ur) {
        var fr = cr.schema.nodes, gr = fr.tableHeadCell, mr = fr.tableBodyCell, vr = fr.paragraph, yr = ar.parent.parent, _r = yr.type === "tableHead" ? gr : mr, kr = yr.parent, xr = (kr.columns[ar.startIdx] || {}).align, Ar = __assign$1({}, ar.attrs);
        xr && (Ar.align = xr), cr.openNode(_r, Ar), dr(ar.firstChild) && cr.openNode(vr);
      } else
        dr(ar.lastChild) && cr.closeNode(), cr.closeNode();
    }
  },
  strike: function(cr, ar, lr, ur) {
    var dr = lr.entering, fr = cr.schema.marks.strike;
    dr ? cr.openMark(fr.create(ur)) : cr.closeMark(fr);
  },
  code: function(cr, ar, lr, ur) {
    var dr = cr.schema.marks.code;
    cr.openMark(dr.create(ur)), cr.addText(getTextWithoutTrailingNewline(ar.literal || "")), cr.closeMark(dr);
  },
  customBlock: function(cr, ar) {
    var lr = cr.schema.nodes, ur = lr.customBlock, dr = lr.paragraph, fr = ar, gr = fr.info, mr = fr.literal;
    cr.openNode(ur, { info: gr }), cr.addText(getTextWithoutTrailingNewline(mr || "")), cr.closeNode(), ar.next || (cr.openNode(dr), cr.closeNode());
  },
  frontMatter: function(cr, ar) {
    cr.openNode(cr.schema.nodes.frontMatter), cr.addText(ar.literal), cr.closeNode();
  },
  htmlInline: function(cr, ar) {
    var lr = ar.literal, ur = lr.match(reHTMLTag), dr = ur[1], fr = ur[3], gr = (dr || fr).toLowerCase(), mr = cr.schema.marks[gr], vr = sanitizeHTML(lr);
    if (mr != null && mr.spec.attrs.htmlInline)
      if (dr) {
        var yr = getHTMLAttrsByHTMLString(vr);
        cr.openMark(mr.create({ htmlAttrs: yr }));
      } else
        cr.closeMark(mr);
    else {
      var _r = htmlToWwConvertors[gr];
      _r && _r(cr, ar, dr);
    }
  },
  htmlBlock: function(cr, ar) {
    var lr = ar.literal, ur = document.createElement("div"), dr = reHTMLComment.test(lr);
    if (dr)
      cr.openNode(cr.schema.nodes.htmlComment), cr.addText(ar.literal), cr.closeNode();
    else {
      var fr = lr.match(reHTMLTag), gr = fr[1], mr = fr[3], vr = (gr || mr).toLowerCase(), yr = cr.schema.nodes[vr], _r = sanitizeHTML(lr);
      if (yr != null && yr.spec.attrs.htmlBlock) {
        var kr = getHTMLAttrsByHTMLString(_r), xr = getChildrenHTML(ar, vr);
        cr.addNode(yr, { htmlAttrs: kr, childrenHTML: xr });
      } else
        ur.innerHTML = _r, addRawHTMLAttributeToDOM(ur), cr.convertByDOMParser(ur);
    }
  },
  customInline: function(cr, ar, lr) {
    var ur = lr.entering, dr = lr.skipChildren, fr = ar, gr = fr.info, mr = fr.firstChild, vr = cr.schema;
    if (gr.indexOf("widget") !== -1 && ur) {
      var yr = getWidgetContent(ar);
      dr(), cr.addNode(vr.nodes.widget, { info: gr }, [
        vr.text(createWidgetContent(gr, yr))
      ]);
    } else {
      var _r = "$$";
      ur && (_r += mr ? gr + " " : gr), cr.addText(_r);
    }
  }
};
function createWwConvertors(cr) {
  var ar = Object.keys(cr), lr = __assign$1({}, toWwConvertors), ur = new Renderer({
    gfm: !0,
    nodeId: !0,
    convertors: cr
  }), dr = ur.getConvertors();
  return ar.forEach(function(fr) {
    var gr = toWwConvertors[fr];
    gr && !includes(["htmlBlock", "htmlInline"], fr) && (lr[fr] = function(mr, vr, yr) {
      yr.origin = function() {
        return dr[fr](vr, yr, dr);
      };
      var _r = cr[fr](vr, yr), kr;
      if (_r) {
        var xr = Array.isArray(_r) ? _r[0] : _r, Ar = xr.attributes, Er = xr.classNames;
        kr = { htmlAttrs: Ar, classNames: Er };
      }
      gr(mr, vr, yr, kr);
    });
  }), lr;
}
function mergeMarkText(cr, ar) {
  return cr.isText && ar.isText && Mark$1.sameSet(cr.marks, ar.marks) ? cr.withText(cr.text + ar.text) : !1;
}
var ToWwConvertorState = (
  /** @class */
  function() {
    function cr(ar, lr) {
      this.schema = ar, this.convertors = lr, this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }], this.marks = Mark$1.none;
    }
    return cr.prototype.top = function() {
      return last$1(this.stack);
    }, cr.prototype.push = function(ar) {
      this.stack.length && this.top().content.push(ar);
    }, cr.prototype.addText = function(ar) {
      if (ar) {
        var lr = this.top().content, ur = last$1(lr), dr = this.schema.text(ar, this.marks), fr = ur && mergeMarkText(ur, dr);
        fr ? lr[lr.length - 1] = fr : lr.push(dr);
      }
    }, cr.prototype.openMark = function(ar) {
      this.marks = ar.addToSet(this.marks);
    }, cr.prototype.closeMark = function(ar) {
      this.marks = ar.removeFromSet(this.marks);
    }, cr.prototype.addNode = function(ar, lr, ur) {
      var dr = ar.createAndFill(lr, ur, this.marks);
      return dr ? (this.push(dr), dr) : null;
    }, cr.prototype.openNode = function(ar, lr) {
      this.stack.push({ type: ar, attrs: lr, content: [] });
    }, cr.prototype.closeNode = function() {
      this.marks.length && (this.marks = Mark$1.none);
      var ar = this.stack.pop(), lr = ar.type, ur = ar.attrs, dr = ar.content;
      return this.addNode(lr, ur, dr);
    }, cr.prototype.convertByDOMParser = function(ar) {
      var lr = this, ur = DOMParser.fromSchema(this.schema).parse(ar);
      ur.content.forEach(function(dr) {
        return lr.push(dr);
      });
    }, cr.prototype.closeUnmatchedHTMLInline = function(ar, lr) {
      var ur;
      if (!lr && ar.type !== "htmlInline")
        for (var dr = this.stack.length - 1, fr = dr; fr >= 0; fr -= 1) {
          var gr = this.stack[fr];
          if (!((ur = gr.attrs) === null || ur === void 0) && ur.rawHTML)
            gr.content.length ? this.closeNode() : this.stack.pop();
          else
            break;
        }
    }, cr.prototype.convert = function(ar, lr) {
      for (var ur = ar.walker(), dr = ur.next(), fr = function() {
        var mr = dr.node, vr = dr.entering, yr = gr.convertors[mr.type], _r = !1;
        if (yr) {
          var kr = {
            entering: vr,
            leaf: !isContainer$2(mr),
            getChildrenText: getChildrenText$1,
            options: { gfm: !0, nodeId: !1, tagFilter: !1, softbreak: `
` },
            skipChildren: function() {
              _r = !0;
            }
          };
          if (gr.closeUnmatchedHTMLInline(mr, vr), yr(gr, mr, kr), (lr == null ? void 0 : lr.node) === mr) {
            var xr = gr.stack.reduce(function(Ar, Er) {
              return Ar + Er.content.reduce(function(Cr, Tr) {
                return Cr + Tr.nodeSize;
              }, 0);
            }, 0) + 1;
            lr.setMappedPos(xr);
          }
        }
        _r && (ur.resumeAt(mr, !1), ur.next()), dr = ur.next();
      }, gr = this; dr; )
        fr();
    }, cr.prototype.convertNode = function(ar, lr) {
      return this.convert(ar, lr), this.stack.length ? this.closeNode() : null;
    }, cr;
  }()
);
function convertToRawHTMLHavingInlines(cr, ar, lr) {
  var ur = lr[0], dr = lr[1];
  cr.write(ur), cr.convertInline(ar), cr.write(dr);
}
function convertToRawHTMLHavingBlocks(cr, ar, lr) {
  var ur = ar.node, dr = ar.parent, fr = lr[0], gr = lr[1];
  cr.stopNewline = !0, cr.write(fr), cr.convertNode(ur), cr.write(gr), (dr == null ? void 0 : dr.type.name) === "doc" && (cr.closeBlock(ur), cr.stopNewline = !1);
}
function createTableHeadDelim(cr, ar) {
  var lr = cr.length, ur = "", dr = "";
  return ar === "left" ? (ur = ":", lr -= 1) : ar === "right" ? (dr = ":", lr -= 1) : ar === "center" && (ur = ":", dr = ":", lr -= 2), "" + ur + repeat$1("-", Math.max(lr, 3)) + dr;
}
var nodeTypeWriters = {
  text: function(cr, ar) {
    var lr, ur = ar.node, dr = (lr = ur.text) !== null && lr !== void 0 ? lr : "";
    (ur.marks || []).some(function(fr) {
      return fr.type.name === "link";
    }) ? cr.text(escapeTextForLink(dr), !1) : cr.text(dr);
  },
  paragraph: function(cr, ar) {
    var lr = ar.node, ur = ar.parent, dr = ar.index, fr = dr === void 0 ? 0 : dr;
    if (cr.stopNewline)
      cr.convertInline(lr);
    else {
      var gr = fr === 0, mr = !gr && ur.child(fr - 1), vr = mr && mr.childCount === 0, yr = fr < ur.childCount - 1 && ur.child(fr + 1), _r = yr && yr.type.name === "paragraph", kr = lr.childCount === 0;
      if (kr && vr)
        cr.write(`<br>
`);
      else if (kr && !vr && !gr) {
        if ((ur == null ? void 0 : ur.type.name) === "listItem") {
          var xr = cr.getDelim();
          cr.setDelim(""), cr.write("<br>"), cr.setDelim(xr);
        }
        cr.write(`
`);
      } else
        cr.convertInline(lr), _r ? cr.write(`
`) : cr.closeBlock(lr);
    }
  },
  heading: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = ur.attrs.headingType;
    fr === "atx" ? (cr.write(dr + " "), cr.convertInline(ur), cr.closeBlock(ur)) : (cr.convertInline(ur), cr.ensureNewLine(), cr.write(dr), cr.closeBlock(ur));
  },
  codeBlock: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = lr.text, gr = dr, mr = gr[0], vr = gr[1];
    cr.write(mr), cr.ensureNewLine(), cr.text(fr, !1), cr.ensureNewLine(), cr.write(vr), cr.closeBlock(ur);
  },
  blockQuote: function(cr, ar, lr) {
    var ur = ar.node, dr = ar.parent, fr = lr.delim;
    (dr == null ? void 0 : dr.type.name) === ur.type.name && cr.flushClose(1), cr.wrapBlock(fr, null, ur, function() {
      return cr.convertNode(ur);
    });
  },
  bulletList: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim;
    cr.convertList(ur, repeat$1(" ", 4), function() {
      return dr + " ";
    });
  },
  orderedList: function(cr, ar) {
    var lr = ar.node, ur = lr.attrs.order || 1;
    cr.convertList(lr, repeat$1(" ", 4), function(dr) {
      var fr = String(ur + dr);
      return fr + ". ";
    });
  },
  listItem: function(cr, ar) {
    var lr = ar.node, ur = lr.attrs, dr = ur.task, fr = ur.checked;
    dr && cr.write("[" + (fr ? "x" : " ") + "] "), cr.convertNode(lr);
  },
  image: function(cr, ar, lr) {
    var ur = lr.attrs;
    cr.write("![" + (ur == null ? void 0 : ur.altText) + "](" + (ur == null ? void 0 : ur.imageUrl) + ")");
  },
  thematicBreak: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim;
    cr.write(dr), cr.closeBlock(ur);
  },
  table: function(cr, ar) {
    var lr = ar.node;
    cr.convertNode(lr), cr.closeBlock(lr);
  },
  tableHead: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = ur.firstChild;
    cr.convertNode(ur);
    var gr = dr != null ? dr : "";
    !dr && fr && fr.forEach(function(mr) {
      var vr = mr.textContent, yr = mr.attrs, _r = createTableHeadDelim(vr, yr.align);
      gr += "| " + _r + " ";
    }), cr.write(gr + "|"), cr.ensureNewLine();
  },
  tableBody: function(cr, ar) {
    var lr = ar.node;
    cr.convertNode(lr);
  },
  tableRow: function(cr, ar) {
    var lr = ar.node;
    cr.convertNode(lr), cr.write("|"), cr.ensureNewLine();
  },
  tableHeadCell: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = dr === void 0 ? "| " : dr;
    cr.write(fr), cr.convertTableCell(ur), cr.write(" ");
  },
  tableBodyCell: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = dr === void 0 ? "| " : dr;
    cr.write(fr), cr.convertTableCell(ur), cr.write(" ");
  },
  customBlock: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.delim, fr = lr.text, gr = dr, mr = gr[0], vr = gr[1];
    cr.write(mr), cr.ensureNewLine(), cr.text(fr, !1), cr.ensureNewLine(), cr.write(vr), cr.closeBlock(ur);
  },
  frontMatter: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.text;
    cr.text(dr, !1), cr.closeBlock(ur);
  },
  widget: function(cr, ar, lr) {
    var ur = lr.text;
    cr.write(ur);
  },
  html: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.text;
    cr.write(dr), ur.attrs.htmlBlock && cr.closeBlock(ur);
  },
  htmlComment: function(cr, ar, lr) {
    var ur = ar.node, dr = lr.text;
    cr.write(dr), cr.closeBlock(ur);
  }
};
function write(cr, ar) {
  var lr = ar.state, ur = ar.nodeInfo, dr = ar.params, fr = dr.rawHTML;
  fr ? inArray_1(cr, ["heading", "codeBlock"]) > -1 ? convertToRawHTMLHavingInlines(lr, ur.node, fr) : inArray_1(cr, ["image", "thematicBreak"]) > -1 ? lr.write(fr) : convertToRawHTMLHavingBlocks(lr, ur, fr) : nodeTypeWriters[cr](lr, ur, dr);
}
function addBackticks(cr, ar) {
  var lr = cr.text, ur = /`+/g, dr = 0;
  if (cr.isText && lr)
    for (var fr = ur.exec(lr); fr; )
      dr = Math.max(dr, fr[0].length), fr = ur.exec(lr);
  for (var gr = dr > 0 && ar > 0 ? " `" : "`", mr = 0; mr < dr; mr += 1)
    gr += "`";
  return dr > 0 && ar < 0 && (gr += " "), gr;
}
function getPairRawHTML(cr) {
  return cr ? ["<" + cr + ">", "</" + cr + ">"] : null;
}
function getOpenRawHTML(cr) {
  return cr ? "<" + cr + ">" : null;
}
function getCloseRawHTML(cr) {
  return cr ? "</" + cr + ">" : null;
}
var toMdConvertors = {
  heading: function(cr) {
    var ar = cr.node, lr = ar.attrs, ur = lr.level, dr = repeat$1("#", ur);
    return lr.headingType === "setext" && (dr = ur === 1 ? "===" : "---"), {
      delim: dr,
      rawHTML: getPairRawHTML(lr.rawHTML)
    };
  },
  codeBlock: function(cr) {
    var ar = cr.node, lr = ar, ur = lr.attrs, dr = lr.textContent;
    return {
      delim: ["```" + (ur.language || ""), "```"],
      rawHTML: getPairRawHTML(ur.rawHTML),
      text: dr
    };
  },
  blockQuote: function(cr) {
    var ar = cr.node;
    return {
      delim: "> ",
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  bulletList: function(cr, ar) {
    var lr = cr.node, ur = ar.inTable, dr = lr.attrs.rawHTML;
    return ur && (dr = dr || "ul"), {
      delim: "*",
      rawHTML: getPairRawHTML(dr)
    };
  },
  orderedList: function(cr, ar) {
    var lr = cr.node, ur = ar.inTable, dr = lr.attrs.rawHTML;
    return ur && (dr = dr || "ol"), {
      rawHTML: getPairRawHTML(dr)
    };
  },
  listItem: function(cr, ar) {
    var lr = cr.node, ur = ar.inTable, dr = lr.attrs, fr = dr.task, gr = dr.checked, mr = lr.attrs.rawHTML;
    ur && (mr = mr || "li");
    var vr = fr ? ' class="task-list-item' + (gr ? " checked" : "") + '"' : "", yr = fr ? " data-task" + (gr ? " data-task-checked" : "") : "";
    return {
      rawHTML: mr ? ["<" + mr + vr + yr + ">", "</" + mr + ">"] : null
    };
  },
  table: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHead: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBody: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableRow: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableHeadCell: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  tableBodyCell: function(cr) {
    var ar = cr.node;
    return {
      rawHTML: getPairRawHTML(ar.attrs.rawHTML)
    };
  },
  image: function(cr) {
    var ar = cr.node, lr = ar.attrs, ur = lr.rawHTML, dr = lr.altText, fr = lr.imageUrl.replace(/&amp;/g, "&"), gr = dr ? ' alt="' + escapeXml$1(dr) + '"' : "";
    return {
      rawHTML: ur ? "<" + ur + ' src="' + escapeXml$1(fr) + '"' + gr + ">" : null,
      attrs: {
        altText: escapeTextForLink(dr || ""),
        imageUrl: fr
      }
    };
  },
  thematicBreak: function(cr) {
    var ar = cr.node;
    return {
      delim: "***",
      rawHTML: getOpenRawHTML(ar.attrs.rawHTML)
    };
  },
  customBlock: function(cr) {
    var ar = cr.node, lr = ar, ur = lr.attrs, dr = lr.textContent;
    return {
      delim: ["$$" + ur.info, "$$"],
      text: dr
    };
  },
  frontMatter: function(cr) {
    var ar = cr.node;
    return {
      text: ar.textContent
    };
  },
  widget: function(cr) {
    var ar = cr.node;
    return {
      text: ar.textContent
    };
  },
  strong: function(cr, ar) {
    var lr = cr.node, ur = ar.entering, dr = lr.attrs.rawHTML;
    return {
      delim: "**",
      rawHTML: ur ? getOpenRawHTML(dr) : getCloseRawHTML(dr)
    };
  },
  emph: function(cr, ar) {
    var lr = cr.node, ur = ar.entering, dr = lr.attrs.rawHTML;
    return {
      delim: "*",
      rawHTML: ur ? getOpenRawHTML(dr) : getCloseRawHTML(dr)
    };
  },
  strike: function(cr, ar) {
    var lr = cr.node, ur = ar.entering, dr = lr.attrs.rawHTML;
    return {
      delim: "~~",
      rawHTML: ur ? getOpenRawHTML(dr) : getCloseRawHTML(dr)
    };
  },
  link: function(cr, ar) {
    var lr = cr.node, ur = ar.entering, dr = lr.attrs, fr = dr.title, gr = dr.rawHTML, mr = dr.linkUrl.replace(/&amp;/g, "&"), vr = fr ? ' title="' + escapeXml$1(fr) + '"' : "";
    return ur ? {
      delim: "[",
      rawHTML: gr ? "<" + gr + ' href="' + escapeXml$1(mr) + '"' + vr + ">" : null
    } : {
      delim: "](" + mr + (fr ? " " + quote(escapeTextForLink(fr)) : "") + ")",
      rawHTML: getCloseRawHTML(gr)
    };
  },
  code: function(cr, ar) {
    var lr = cr.node, ur = cr.parent, dr = cr.index, fr = dr === void 0 ? 0 : dr, gr = ar.entering, mr = gr ? addBackticks(ur.child(fr), -1) : addBackticks(ur.child(fr - 1), 1), vr = gr ? getOpenRawHTML(lr.attrs.rawHTML) : getCloseRawHTML(lr.attrs.rawHTML);
    return {
      delim: mr,
      rawHTML: vr
    };
  },
  htmlComment: function(cr) {
    var ar = cr.node;
    return {
      text: ar.textContent
    };
  },
  // html inline node, html block node
  html: function(cr, ar) {
    var lr = cr.node, ur = ar.entering, dr = lr.type.name, fr = lr.attrs.htmlAttrs, gr = "<" + dr, mr = "</" + dr + ">";
    return Object.keys(fr).forEach(function(vr) {
      gr += " " + vr + '="' + fr[vr].replace(/"/g, "'") + '"';
    }), gr += ">", lr.attrs.htmlInline ? {
      rawHTML: ur ? gr : mr
    } : {
      text: "" + gr + lr.attrs.childrenHTML + mr
    };
  }
}, markTypeOptions = {
  strong: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  emph: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  strike: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  code: {
    escape: !1
  },
  link: null,
  html: null
};
function createNodeTypeConvertors(cr) {
  var ar = {}, lr = Object.keys(nodeTypeWriters);
  return lr.forEach(function(ur) {
    ar[ur] = function(dr, fr) {
      var gr = nodeTypeWriters[ur];
      if (gr) {
        var mr = cr[ur], vr = mr ? mr(fr, {
          inTable: dr.inTable
        }) : {};
        write(ur, { state: dr, nodeInfo: fr, params: vr });
      }
    };
  }), ar;
}
function createMarkTypeConvertors(cr) {
  var ar = {}, lr = Object.keys(markTypeOptions);
  return lr.forEach(function(ur) {
    ar[ur] = function(dr, fr) {
      var gr = markTypeOptions[ur], mr = cr[ur], vr = mr && dr && !isUndefined_1(fr), yr = vr ? mr(dr, { entering: fr }) : {};
      return __assign$1(__assign$1({}, yr), gr);
    };
  }), ar;
}
function createMdConvertors(cr) {
  var ar = Object.keys(cr);
  ar.forEach(function(dr) {
    var fr = toMdConvertors[dr], gr = cr[dr];
    fr ? toMdConvertors[dr] = function(mr, vr) {
      return vr.origin = function() {
        return fr(mr, vr);
      }, gr(mr, vr);
    } : toMdConvertors[dr] = gr, delete cr[dr];
  });
  var lr = createNodeTypeConvertors(toMdConvertors), ur = createMarkTypeConvertors(toMdConvertors);
  return {
    nodeTypeConvertors: lr,
    markTypeConvertors: ur
  };
}
var ToMdConvertorState = (
  /** @class */
  function() {
    function cr(ar) {
      var lr = ar.nodeTypeConvertors, ur = ar.markTypeConvertors;
      this.nodeTypeConvertors = lr, this.markTypeConvertors = ur, this.delim = "", this.result = "", this.closed = !1, this.tightList = !1, this.stopNewline = !1, this.inTable = !1;
    }
    return cr.prototype.getMarkConvertor = function(ar) {
      var lr = ar.attrs.htmlInline ? "html" : ar.type.name;
      return this.markTypeConvertors[lr];
    }, cr.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    }, cr.prototype.markText = function(ar, lr, ur, dr) {
      var fr = this.getMarkConvertor(ar);
      if (fr) {
        var gr = fr({ node: ar, parent: ur, index: dr }, lr), mr = gr.delim, vr = gr.rawHTML;
        return vr || mr;
      }
      return "";
    }, cr.prototype.setDelim = function(ar) {
      this.delim = ar;
    }, cr.prototype.getDelim = function() {
      return this.delim;
    }, cr.prototype.flushClose = function(ar) {
      if (!this.stopNewline && this.closed) {
        if (this.isInBlank() || (this.result += `
`), ar || (ar = 2), ar > 1) {
          var lr = this.delim, ur = /\s+$/.exec(lr);
          ur && (lr = lr.slice(0, lr.length - ur[0].length));
          for (var dr = 1; dr < ar; dr += 1)
            this.result += lr + `
`;
        }
        this.closed = !1;
      }
    }, cr.prototype.wrapBlock = function(ar, lr, ur, dr) {
      var fr = this.getDelim();
      this.write(lr || ar), this.setDelim(this.getDelim() + ar), dr(), this.setDelim(fr), this.closeBlock(ur);
    }, cr.prototype.ensureNewLine = function() {
      this.isInBlank() || (this.result += `
`);
    }, cr.prototype.write = function(ar) {
      ar === void 0 && (ar = ""), this.flushClose(), this.delim && this.isInBlank() && (this.result += this.delim), ar && (this.result += ar);
    }, cr.prototype.closeBlock = function(ar) {
      this.closed = ar;
    }, cr.prototype.text = function(ar, lr) {
      lr === void 0 && (lr = !0);
      for (var ur = ar.split(`
`), dr = 0; dr < ur.length; dr += 1)
        this.write(), this.result += lr ? escape$1$1(ur[dr]) : ur[dr], dr !== ur.length - 1 && (this.result += `
`);
    }, cr.prototype.convertBlock = function(ar, lr, ur) {
      var dr = ar.type.name, fr = this.nodeTypeConvertors[dr], gr = { node: ar, parent: lr, index: ur };
      ar.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, gr) : fr && fr(this, gr);
    }, cr.prototype.convertInline = function(ar) {
      var lr = this, ur = [], dr = "", fr = function(gr, mr, vr) {
        var yr = gr ? gr.marks : [], _r = dr;
        dr = "";
        var kr = gr && gr.isText && yr.some(function(Fr) {
          var zr = lr.getMarkConvertor(Fr), Ur = zr && zr();
          return Ur && Ur.removedEnclosingWhitespace;
        });
        if (kr && gr && gr.text) {
          var xr = /^(\s*)(.*?)(\s*)$/m.exec(gr.text), Ar = xr[1], Er = xr[2], Cr = xr[3];
          _r += Ar, dr = Cr, (Ar || Cr) && (gr = Er ? gr.withText(Er) : null, gr || (yr = ur));
        }
        for (var Tr = yr.length && last$1(yr), Sr = Tr && lr.getMarkConvertor(Tr), Lr = Sr && Sr(), Ir = Lr && Lr.escape === !1, Nr = yr.length - (Ir ? 1 : 0), Rr = 0; Rr < Nr; Rr += 1) {
          var Er = yr[Rr];
          if (Lr && !Lr.mixable)
            break;
          for (var Mr = 0; Mr < ur.length; Mr += 1) {
            var Br = ur[Mr];
            if (Lr && !Lr.mixable)
              break;
            if (Er.eq(Br)) {
              Rr > Mr ? yr = yr.slice(0, Mr).concat(Er).concat(yr.slice(Mr, Rr)).concat(yr.slice(Rr + 1, Nr)) : Mr > Rr && (yr = yr.slice(0, Rr).concat(yr.slice(Rr + 1, Mr)).concat(Er).concat(yr.slice(Mr, Nr)));
              break;
            }
          }
        }
        for (var Dr = 0; Dr < Math.min(ur.length, Nr) && yr[Dr].eq(ur[Dr]); )
          Dr += 1;
        for (; Dr < ur.length; ) {
          var Hr = ur.pop();
          Hr && lr.text(lr.markText(Hr, !1, ar, vr), !1);
        }
        if (_r && lr.text(_r), gr) {
          for (; ur.length < Nr; ) {
            var Er = yr[ur.length];
            ur.push(Er), lr.text(lr.markText(Er, !0, ar, vr), !1);
          }
          Ir && gr.isText ? lr.text(lr.markText(Tr, !0, ar, vr) + gr.text + lr.markText(Tr, !1, ar, vr + 1), !1) : lr.convertBlock(gr, ar, vr);
        }
      };
      ar.forEach(fr), fr(null, null, ar.childCount);
    }, cr.prototype.convertList = function(ar, lr, ur) {
      var dr = this, fr;
      this.closed && this.closed.type === ar.type ? this.flushClose(3) : this.tightList && this.flushClose(1);
      var gr = (fr = ar.attrs.tight) !== null && fr !== void 0 ? fr : !0, mr = this.tightList;
      this.tightList = gr, ar.forEach(function(vr, yr, _r) {
        _r && gr && dr.flushClose(1), dr.wrapBlock(lr, ur(_r), ar, function() {
          return dr.convertBlock(vr, ar, _r);
        });
      }), this.tightList = mr;
    }, cr.prototype.convertTableCell = function(ar) {
      var lr = this;
      this.stopNewline = !0, this.inTable = !0, ar.forEach(function(ur, dr, fr) {
        if (includes(["bulletList", "orderedList"], ur.type.name))
          lr.convertBlock(ur, ar, fr), lr.closed = !1;
        else if (lr.convertInline(ur), fr < ar.childCount - 1) {
          var gr = ar.child(fr + 1);
          gr.type.name === "paragraph" && lr.write("<br>");
        }
      }), this.stopNewline = !1, this.inTable = !1;
    }, cr.prototype.convertNode = function(ar, lr) {
      var ur = this;
      return ar.forEach(function(dr, fr, gr) {
        if (ur.convertBlock(dr, ar, gr), (lr == null ? void 0 : lr.node) === dr) {
          var mr = ur.result.split(`
`);
          lr.setMappedPos([mr.length, last$1(mr).length + 1]);
        }
      }), this.result;
    }, cr;
  }()
), Convertor = (
  /** @class */
  function() {
    function cr(ar, lr, ur, dr) {
      var fr = this;
      this.setMappedPos = function(gr) {
        fr.mappedPosWhenConverting = gr;
      }, this.schema = ar, this.eventEmitter = dr, this.focusedNode = null, this.mappedPosWhenConverting = null, this.toWwConvertors = createWwConvertors(ur), this.toMdConvertors = createMdConvertors(lr || {}), this.eventEmitter.listen("setFocusedNode", function(gr) {
        return fr.focusedNode = gr;
      });
    }
    return cr.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    }, cr.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    }, cr.prototype.toWysiwygModel = function(ar) {
      var lr = new ToWwConvertorState(this.schema, this.toWwConvertors);
      return lr.convertNode(ar, this.getInfoForPosSync());
    }, cr.prototype.toMarkdownText = function(ar) {
      var lr = new ToMdConvertorState(this.toMdConvertors), ur = lr.convertNode(ar, this.getInfoForPosSync());
      return ur = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", ur), ur;
    }, cr;
  }()
);
function execPlugin(cr) {
  var ar = cr.plugin, lr = cr.eventEmitter, ur = cr.usageStatistics, dr = cr.instance, fr = { Plugin, PluginKey, Selection, TextSelection }, gr = { Decoration, DecorationSet }, mr = { Fragment }, vr = { InputRule, inputRules, undoInputRule }, yr = { keymap }, _r = {
    eventEmitter: lr,
    usageStatistics: ur,
    instance: dr,
    pmState: fr,
    pmView: gr,
    pmModel: mr,
    pmRules: vr,
    pmKeymap: yr,
    i18n
  };
  if (isArray_1(ar)) {
    var kr = ar[0], xr = ar[1], Ar = xr === void 0 ? {} : xr;
    return kr(_r, Ar);
  }
  return ar(_r);
}
function getPluginInfo(cr) {
  var ar = cr.plugins, lr = cr.eventEmitter, ur = cr.usageStatistics, dr = cr.instance;
  return lr.listen("mixinTableOffsetMapPrototype", mixinTableOffsetMapPrototype), (ar != null ? ar : []).reduce(function(fr, gr) {
    var mr = execPlugin({
      plugin: gr,
      eventEmitter: lr,
      usageStatistics: ur,
      instance: dr
    });
    if (!mr)
      throw new Error("The return value of the executed plugin is empty.");
    var vr = mr.markdownParsers, yr = mr.toHTMLRenderers, _r = mr.toMarkdownRenderers, kr = mr.markdownPlugins, xr = mr.wysiwygPlugins, Ar = mr.wysiwygNodeViews, Er = mr.markdownCommands, Cr = mr.wysiwygCommands, Tr = mr.toolbarItems;
    return yr && (fr.toHTMLRenderers = deepMergedCopy(fr.toHTMLRenderers, yr)), _r && (fr.toMarkdownRenderers = deepMergedCopy(fr.toMarkdownRenderers, _r)), kr && (fr.mdPlugins = fr.mdPlugins.concat(kr)), xr && (fr.wwPlugins = fr.wwPlugins.concat(xr)), Ar && (fr.wwNodeViews = __assign$1(__assign$1({}, fr.wwNodeViews), Ar)), Er && (fr.mdCommands = __assign$1(__assign$1({}, fr.mdCommands), Er)), Cr && (fr.wwCommands = __assign$1(__assign$1({}, fr.wwCommands), Cr)), Tr && (fr.toolbarItems = fr.toolbarItems.concat(Tr)), vr && (fr.markdownParsers = __assign$1(__assign$1({}, fr.markdownParsers), vr)), fr;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var TASK_ATTR_NAME = "data-task", DISABLED_TASK_ATTR_NAME = "data-task-disabled", TASK_CHECKED_CLASS_NAME = "checked";
function registerHTMLTagToWhitelist(cr) {
  ["htmlBlock", "htmlInline"].forEach(function(ar) {
    cr[ar] && Object.keys(cr[ar]).forEach(function(lr) {
      return registerTagWhitelistIfPossible(lr);
    });
  });
}
var ToastUIEditorViewer = (
  /** @class */
  function() {
    function cr(ar) {
      var lr = this;
      this.options = extend_1({
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        usageStatistics: !0,
        theme: "light"
      }, ar), this.eventEmitter = new EventEmitter();
      var ur = sanitizeLinkAttribute(this.options.linkAttributes), dr = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      }) || {}, fr = dr.toHTMLRenderers, gr = dr.markdownParsers, mr = this.options, vr = mr.customHTMLRenderer, yr = mr.extendedAutolinks, _r = mr.referenceDefinition, kr = mr.frontMatter, xr = mr.customHTMLSanitizer, Ar = {
        linkAttributes: ur,
        customHTMLRenderer: __assign$1(__assign$1({}, fr), vr),
        extendedAutolinks: yr,
        referenceDefinition: _r,
        frontMatter: kr,
        sanitizer: xr || sanitizeHTML
      };
      registerHTMLTagToWhitelist(Ar.customHTMLRenderer), this.options.events && forEachOwnProperties_1(this.options.events, function(Ir, Nr) {
        lr.on(Nr, Ir);
      });
      var Er = this.options, Cr = Er.el, Tr = Er.initialValue, Sr = Er.theme, Lr = Cr.innerHTML;
      Sr !== "light" && Cr.classList.add(cls(Sr)), Cr.innerHTML = "", this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: yr,
        referenceDefinition: _r,
        disallowDeepHeading: !0,
        frontMatter: kr,
        customParser: gr
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, Ar), { isViewer: !0 })), on_1(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), Tr ? this.setMarkdown(Tr) : Lr && this.preview.setHTML(Lr), Cr.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
    }
    return cr.prototype.toggleTask = function(ar) {
      var lr = ar.target, ur = getComputedStyle(lr, ":before");
      !lr.hasAttribute(DISABLED_TASK_ATTR_NAME) && lr.hasAttribute(TASK_ATTR_NAME) && isPositionInBox(ur, ar.offsetX, ar.offsetY) && (toggleClass(lr, TASK_CHECKED_CLASS_NAME), this.eventEmitter.emit("change", {
        source: "viewer",
        date: ar
      }));
    }, cr.prototype.setMarkdown = function(ar) {
      var lr = this.toastMark.getLineTexts(), ur = lr.length, dr = last$1(lr), fr = [ur, dr.length + 1], gr = this.toastMark.editMarkdown([1, 1], fr, ar || "");
      this.eventEmitter.emit("updatePreview", gr);
    }, cr.prototype.on = function(ar, lr) {
      this.eventEmitter.listen(ar, lr);
    }, cr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, cr.prototype.addHook = function(ar, lr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, lr);
    }, cr.prototype.destroy = function() {
      off_1(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
    }, cr.prototype.isViewer = function() {
      return !0;
    }, cr.prototype.isMarkdownMode = function() {
      return !1;
    }, cr.prototype.isWysiwygMode = function() {
      return !1;
    }, cr;
  }()
);
function isPmNode(cr) {
  return cr instanceof Node$3;
}
function isContainer(cr) {
  var ar = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return includes(ar, cr);
}
function createMdLikeNode(cr) {
  var ar = cr.attrs, lr = cr.type, ur = lr.name, dr = {
    type: ur,
    wysiwygNode: !0,
    literal: !isContainer(ur) && isPmNode(cr) ? cr.textContent : null
  }, fr = {
    heading: { level: ar.level },
    link: { destination: ar.linkUrl, title: ar.title },
    image: { destination: ar.imageUrl },
    codeBlock: { info: ar.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: ar.order } },
    listItem: { type: "item", listData: { task: ar.task, checked: ar.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: ar.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: ar.align },
    customBlock: { info: ar.info }
  }, gr = fr[ur], mr = __assign$1(__assign$1({}, dr), gr), vr = cr.attrs, yr = vr.htmlAttrs, _r = vr.childrenHTML;
  return yr ? __assign$1(__assign$1({}, mr), { attrs: yr, childrenHTML: _r }) : mr;
}
var tokenToDOMNode = {
  openTag: function(cr, ar) {
    var lr = cr, ur = lr.tagName, dr = lr.classNames, fr = lr.attributes, gr = document.createElement(ur), mr = {};
    dr && (gr.className = dr.join(" ")), fr && (mr = __assign$1(__assign$1({}, mr), fr)), setAttributes(mr, gr), ar.push(gr);
  },
  closeTag: function(cr, ar) {
    if (ar.length > 1) {
      var lr = ar.pop();
      last$1(ar).appendChild(lr);
    }
  },
  html: function(cr, ar) {
    last$1(ar).insertAdjacentHTML("beforeend", cr.content);
  },
  text: function(cr, ar) {
    var lr = document.createTextNode(cr.content);
    last$1(ar).appendChild(lr);
  }
}, WwToDOMAdaptor = (
  /** @class */
  function() {
    function cr(ar, lr) {
      var ur = getHTMLRenderConvertors(ar, lr), dr = __assign$1(__assign$1({}, lr.htmlBlock), lr.htmlInline);
      this.customConvertorKeys = Object.keys(lr).concat(Object.keys(dr)), this.renderer = new Renderer({
        gfm: !0,
        convertors: __assign$1(__assign$1({}, ur), dr)
      }), this.convertors = this.renderer.getConvertors();
    }
    return cr.prototype.generateTokens = function(ar) {
      var lr = createMdLikeNode(ar), ur = {
        entering: !0,
        leaf: isPmNode(ar) ? ar.isLeaf : !1,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return isPmNode(ar) ? ar.textContent : "";
        },
        skipChildren: function() {
          return !1;
        }
      }, dr = this.convertors[ar.type.name], fr = dr(lr, ur, this.convertors), gr = isArray_1(fr) ? fr : [fr];
      return (isContainer(ar.type.name) || ar.attrs.htmlInline) && (ur.entering = !1, gr.push({ type: "text", content: isPmNode(ar) ? ar.textContent : "" }), gr = gr.concat(dr(lr, ur, this.convertors))), gr;
    }, cr.prototype.toDOMNode = function(ar) {
      var lr = this.generateTokens(ar), ur = [];
      return lr.forEach(function(dr) {
        return tokenToDOMNode[dr.type](dr, ur);
      }), ur[0];
    }, cr.prototype.getToDOMNode = function(ar) {
      return includes(this.customConvertorKeys, ar) ? this.toDOMNode.bind(this) : null;
    }, cr;
  }()
), ANIMATION_TIME = 100, SCROLL_BLOCKING_RESET_DELAY = 15, currentTimeoutId = null, releaseTimer = null;
function run(cr, ar) {
  var lr = ar.syncScrollTop, ur = ar.releaseEventBlock;
  releaseTimer && clearTimeout(releaseTimer), lr(cr), releaseTimer = setTimeout(function() {
    ur();
  }, SCROLL_BLOCKING_RESET_DELAY);
}
function animate(cr, ar, lr) {
  var ur = ar - cr, dr = Date.now(), fr = function() {
    var gr = Date.now(), mr = (gr - dr) / ANIMATION_TIME, vr;
    currentTimeoutId && clearTimeout(currentTimeoutId), mr < 1 ? (vr = cr + ur * Math.cos((1 - mr) * Math.PI / 2), run(Math.ceil(vr), lr), currentTimeoutId = setTimeout(fr, 1)) : (run(ar, lr), currentTimeoutId = null);
  };
  fr();
}
var EDITOR_BOTTOM_PADDING = 18, ScrollSync = (
  /** @class */
  function() {
    function cr(ar, lr, ur) {
      this.latestEditorScrollTop = null, this.latestPreviewScrollTop = null, this.blockedScroll = null, this.active = !0, this.timer = null;
      var dr = lr.previewContent, fr = lr.el;
      this.previewRoot = dr, this.previewEl = fr, this.mdEditor = ar, this.editorView = ar.view, this.toastMark = ar.getToastMark(), this.eventEmitter = ur, this.addScrollSyncEvent();
    }
    return cr.prototype.addScrollSyncEvent = function() {
      var ar = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        ar.clearTimer(), ar.timer = setTimeout(function() {
          ar.syncPreviewScrollTop(!0);
        }, 200);
      }), this.eventEmitter.listen("scroll", function(lr, ur) {
        ar.active && (lr === "editor" && ar.blockedScroll !== "editor" ? ar.syncPreviewScrollTop() : lr === "preview" && ar.blockedScroll !== "preview" && ar.syncEditorScrollTop(ur));
      }), this.eventEmitter.listen("toggleScrollSync", function(lr) {
        ar.active = lr;
      });
    }, cr.prototype.getMdNodeAtPos = function(ar, lr) {
      var ur = ar.content.findIndex(lr.pos), dr = ur.index;
      return this.toastMark.findFirstNodeAtLine(dr + 1);
    }, cr.prototype.getScrollTopByCaretPos = function() {
      var ar = this.mdEditor.getSelection(), lr = this.toastMark.findFirstNodeAtLine(ar[0][0]), ur = this.previewEl.clientHeight, dr = getParentNodeObj(this.previewRoot, lr).el, fr = getTotalOffsetTop(dr, this.previewRoot) || dr.offsetTop, gr = dr.clientHeight, mr = fr + gr - ur * 0.5;
      this.latestEditorScrollTop = null;
      var vr = dr.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return vr < ur ? null : mr;
    }, cr.prototype.syncPreviewScrollTop = function(ar) {
      ar === void 0 && (ar = !1);
      var lr = this, ur = lr.editorView, dr = lr.previewEl, fr = lr.previewRoot, gr = ur.dom.getBoundingClientRect(), mr = gr.left, vr = gr.top, yr = ur.posAtCoords({ left: mr, top: vr }), _r = ur.state.doc, kr = this.getMdNodeAtPos(_r, yr);
      if (!(!kr || isHTMLNode(kr))) {
        var xr = dr.scrollTop, Ar = ur.dom, Er = Ar.scrollTop, Cr = Ar.scrollHeight, Tr = Ar.clientHeight, Sr = Ar.children, Lr = Cr - Er <= Tr + EDITOR_BOTTOM_PADDING, Ir = Lr ? dr.scrollHeight : 0;
        if (Er && !Lr) {
          if (ar) {
            var Nr = this.getScrollTopByCaretPos();
            if (!Nr)
              return;
            Ir = Nr;
          } else {
            var Rr = getParentNodeObj(this.previewRoot, kr), Mr = Rr.el, Br = Rr.mdNode, Dr = getEditorRangeHeightInfo(_r, Br, Sr), Hr = Dr.height, Fr = Dr.rect, zr = getTotalOffsetTop(Mr, fr) || Mr.offsetTop, Ur = Mr.clientHeight, jr = vr > Fr.top ? Math.min((vr - Fr.top) / Hr, 1) : 0;
            Ir = zr + Ur * jr;
          }
          Ir = this.getResolvedScrollTop("editor", Er, Ir, xr), this.latestEditorScrollTop = Er;
        }
        Ir !== xr && this.run("editor", Ir, xr);
      }
    }, cr.prototype.syncEditorScrollTop = function(ar) {
      var lr = this, ur = lr.toastMark, dr = lr.editorView, fr = lr.previewRoot, gr = lr.previewEl, mr = dr.dom, vr = dr.state, yr = gr.scrollTop, _r = gr.clientHeight, kr = gr.scrollHeight, xr = kr - yr <= _r, Ar = mr.scrollTop, Er = xr ? mr.scrollHeight : 0;
      if (yr && ar && !xr) {
        if (ar = findAncestorHavingId(ar, fr), !ar.getAttribute("data-nodeid"))
          return;
        var Cr = mr.children, Tr = Number(ar.getAttribute("data-nodeid")), Sr = getParentNodeObj(this.previewRoot, ur.findNodeById(Tr)), Lr = Sr.mdNode, Ir = Sr.el, Nr = getMdStartLine(Lr);
        Er = Cr[Nr - 1].offsetTop;
        var Rr = getEditorRangeHeightInfo(vr.doc, Lr, Cr).height, Mr = getAndSaveOffsetInfo(Ir, fr, Tr), Br = Mr.nodeHeight, Dr = Mr.offsetTop;
        Er += getAdditionalPos(yr, Dr, Br, Rr), Er = this.getResolvedScrollTop("preview", yr, Er, Ar), this.latestPreviewScrollTop = yr;
      }
      Er !== Ar && this.run("preview", Er, Ar);
    }, cr.prototype.getResolvedScrollTop = function(ar, lr, ur, dr) {
      var fr = ar === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      return fr === null ? ur : fr < lr ? Math.max(ur, dr) : Math.min(ur, dr);
    }, cr.prototype.run = function(ar, lr, ur) {
      var dr = this, fr;
      ar === "editor" ? (fr = this.previewEl, this.blockedScroll = "preview") : (fr = this.editorView.dom, this.blockedScroll = "editor");
      var gr = {
        syncScrollTop: function(mr) {
          return fr.scrollTop = mr;
        },
        releaseEventBlock: function() {
          return dr.blockedScroll = null;
        }
      };
      animate(ur, lr, gr);
    }, cr.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, cr.prototype.destroy = function() {
      this.clearTimer(), this.eventEmitter.removeEventHandler("scroll"), this.eventEmitter.removeEventHandler("afterPreviewRender");
    }, cr;
  }()
), queryMap = {
  getPopupInitialValues: function(cr, ar) {
    var lr = ar.popupName;
    return lr === "link" ? { linkText: cr.getSelectedText() } : {};
  }
};
function buildQuery(cr) {
  cr.eventEmitter.listen("query", function(ar, lr) {
    return queryMap[ar](cr, lr);
  });
}
var ToastUIEditorCore = (
  /** @class */
  function() {
    function cr(ar) {
      var lr = this;
      this.initialHTML = ar.el.innerHTML, ar.el.innerHTML = "", this.options = extend_1({
        previewStyle: "tab",
        previewHighlight: !0,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: !0,
        usageStatistics: !0,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: !1,
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        widgetRules: [],
        theme: "light",
        autofocus: !0
      }, ar);
      var ur = this.options, dr = ur.customHTMLRenderer, fr = ur.extendedAutolinks, gr = ur.referenceDefinition, mr = ur.frontMatter, vr = ur.customMarkdownRenderer, yr = ur.useCommandShortcut, _r = ur.initialEditType, kr = ur.widgetRules, xr = ur.customHTMLSanitizer;
      this.mode = _r || "markdown", this.mdPreviewStyle = this.options.previewStyle, this.i18n = i18n, this.i18n.setCode(this.options.language), this.eventEmitter = new EventEmitter(), setWidgetRules(kr);
      var Ar = sanitizeLinkAttribute(this.options.linkAttributes);
      this.pluginInfo = getPluginInfo({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      });
      var Er = this.pluginInfo, Cr = Er.toHTMLRenderers, Tr = Er.toMarkdownRenderers, Sr = Er.mdPlugins, Lr = Er.wwPlugins, Ir = Er.wwNodeViews, Nr = Er.mdCommands, Rr = Er.wwCommands, Mr = Er.markdownParsers, Br = {
        linkAttributes: Ar,
        customHTMLRenderer: deepMergedCopy(Cr, dr),
        extendedAutolinks: fr,
        referenceDefinition: gr,
        frontMatter: mr,
        sanitizer: xr || sanitizeHTML
      }, Dr = new WwToDOMAdaptor(Ar, Br.customHTMLRenderer), Hr = createHTMLSchemaMap(Br.customHTMLRenderer, Br.sanitizer, Dr);
      this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: fr,
        referenceDefinition: gr,
        disallowDeepHeading: !0,
        frontMatter: mr,
        customParser: Mr
      }), this.mdEditor = new MdEditor(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut: yr,
        mdPlugins: Sr
      }), this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, Br), { isViewer: !1, highlight: this.options.previewHighlight })), this.wwEditor = new WysiwygEditor(this.eventEmitter, {
        toDOMAdaptor: Dr,
        useCommandShortcut: yr,
        htmlSchemaMap: Hr,
        linkAttributes: Ar,
        wwPlugins: Lr,
        wwNodeViews: Ir
      }), this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, Tr), vr), getHTMLRenderConvertors(Ar, Br.customHTMLRenderer), this.eventEmitter), this.setMinHeight(this.options.minHeight), this.setHeight(this.options.height), this.setMarkdown(this.options.initialValue, !1), this.options.placeholder && this.setPlaceholder(this.options.placeholder), this.options.initialValue || this.setHTML(this.initialHTML, !1), this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return lr.mode;
      }), this.options.usageStatistics && sendHostName(), this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter), this.addInitEvent(), this.addInitCommand(Nr, Rr), buildQuery(this), this.options.hooks && forEachOwnProperties_1(this.options.hooks, function(Fr, zr) {
        return lr.addHook(zr, Fr);
      }), this.options.events && forEachOwnProperties_1(this.options.events, function(Fr, zr) {
        return lr.on(zr, Fr);
      }), this.eventEmitter.emit("load", this), this.moveCursorToStart(this.options.autofocus);
    }
    return cr.prototype.addInitEvent = function() {
      var ar = this;
      this.on("needChangeMode", this.changeMode.bind(this)), this.on("loadUI", function() {
        if (ar.height !== "auto") {
          var lr = Math.min(parseInt(ar.minHeight, 10), parseInt(ar.height, 10) - 75) + "px";
          ar.setMinHeight(lr);
        }
      }), addDefaultImageBlobHook(this.eventEmitter);
    }, cr.prototype.addInitCommand = function(ar, lr) {
      var ur = this, dr = function(fr, gr) {
        Object.keys(gr).forEach(function(mr) {
          ur.addCommand(fr, mr, gr[mr]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(fr) {
        return ur.eventEmitter.emit("toggleScrollSync", fr.active), !0;
      }), dr("markdown", ar), dr("wysiwyg", lr);
    }, cr.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    }, cr.factory = function(ar) {
      return ar.viewer ? new ToastUIEditorViewer(ar) : new cr(ar);
    }, cr.setLanguage = function(ar, lr) {
      i18n.setLanguage(ar, lr);
    }, cr.prototype.changePreviewStyle = function(ar) {
      this.mdPreviewStyle !== ar && (this.mdPreviewStyle = ar, this.eventEmitter.emit("changePreviewStyle", ar));
    }, cr.prototype.exec = function(ar, lr) {
      this.commandManager.exec(ar, lr);
    }, cr.prototype.addCommand = function(ar, lr, ur) {
      var dr = this, fr = function(gr) {
        gr === void 0 && (gr = {});
        var mr = (ar === "markdown" ? dr.mdEditor : dr.wwEditor).view;
        ur(gr, mr.state, mr.dispatch, mr);
      };
      this.commandManager.addCommand(ar, lr, fr);
    }, cr.prototype.on = function(ar, lr) {
      this.eventEmitter.listen(ar, lr);
    }, cr.prototype.off = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, cr.prototype.addHook = function(ar, lr) {
      this.eventEmitter.removeEventHandler(ar), this.eventEmitter.listen(ar, lr);
    }, cr.prototype.removeHook = function(ar) {
      this.eventEmitter.removeEventHandler(ar);
    }, cr.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    }, cr.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    }, cr.prototype.moveCursorToEnd = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToEnd(ar);
    }, cr.prototype.moveCursorToStart = function(ar) {
      ar === void 0 && (ar = !0), this.getCurrentModeEditor().moveCursorToStart(ar);
    }, cr.prototype.setMarkdown = function(ar, lr) {
      if (ar === void 0 && (ar = ""), lr === void 0 && (lr = !0), this.mdEditor.setMarkdown(ar, lr), this.isWysiwygMode()) {
        var ur = this.toastMark.getRootNode(), dr = this.convertor.toWysiwygModel(ur);
        this.wwEditor.setModel(dr, lr);
      }
    }, cr.prototype.setHTML = function(ar, lr) {
      ar === void 0 && (ar = ""), lr === void 0 && (lr = !0);
      var ur = document.createElement("div");
      ur.innerHTML = replaceBRWithEmptyBlock(ar);
      var dr = DOMParser.fromSchema(this.wwEditor.schema).parse(ur);
      this.isMarkdownMode() ? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(dr), lr) : this.wwEditor.setModel(dr, lr);
    }, cr.prototype.getMarkdown = function() {
      return this.isMarkdownMode() ? this.mdEditor.getMarkdown() : this.convertor.toMarkdownText(this.wwEditor.getModel());
    }, cr.prototype.getHTML = function() {
      var ar = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (ar.isMarkdownMode()) {
          var dr = ar.toastMark.getRootNode(), fr = ar.convertor.toWysiwygModel(dr);
          ar.wwEditor.setModel(fr);
        }
      });
      var lr = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);
      if (this.placeholder) {
        var ur = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return lr.replace(ur, "");
      }
      return lr;
    }, cr.prototype.insertText = function(ar) {
      this.getCurrentModeEditor().replaceSelection(ar);
    }, cr.prototype.setSelection = function(ar, lr) {
      this.getCurrentModeEditor().setSelection(ar, lr);
    }, cr.prototype.replaceSelection = function(ar, lr, ur) {
      this.getCurrentModeEditor().replaceSelection(ar, lr, ur);
    }, cr.prototype.deleteSelection = function(ar, lr) {
      this.getCurrentModeEditor().deleteSelection(ar, lr);
    }, cr.prototype.getSelectedText = function(ar, lr) {
      return this.getCurrentModeEditor().getSelectedText(ar, lr);
    }, cr.prototype.getRangeInfoOfNode = function(ar) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(ar);
    }, cr.prototype.addWidget = function(ar, lr, ur) {
      this.getCurrentModeEditor().addWidget(ar, lr, ur);
    }, cr.prototype.replaceWithWidget = function(ar, lr, ur) {
      this.getCurrentModeEditor().replaceWithWidget(ar, lr, ur);
    }, cr.prototype.setHeight = function(ar) {
      var lr = this.options.el;
      isString_1(ar) && (ar === "auto" ? addClass_1(lr, "auto-height") : removeClass_1(lr, "auto-height"), this.setMinHeight(this.getMinHeight())), css_1(lr, { height: ar }), this.height = ar;
    }, cr.prototype.getHeight = function() {
      return this.height;
    }, cr.prototype.setMinHeight = function(ar) {
      if (ar !== this.minHeight) {
        var lr = this.height || this.options.height;
        lr !== "auto" && this.options.el.querySelector("." + cls("main")) && (ar = Math.min(parseInt(ar, 10), parseInt(lr, 10) - 75) + "px");
        var ur = parseInt(ar, 10);
        this.minHeight = ar, this.wwEditor.setMinHeight(ur), this.mdEditor.setMinHeight(ur), this.preview.setMinHeight(ur);
      }
    }, cr.prototype.getMinHeight = function() {
      return this.minHeight;
    }, cr.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    }, cr.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    }, cr.prototype.isViewer = function() {
      return !1;
    }, cr.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    }, cr.prototype.changeMode = function(ar, lr) {
      if (this.mode !== ar) {
        if (this.mode = ar, this.isWysiwygMode()) {
          var ur = this.toastMark.getRootNode(), dr = this.convertor.toWysiwygModel(ur);
          this.wwEditor.setModel(dr);
        } else {
          var dr = this.wwEditor.getModel();
          this.mdEditor.setMarkdown(this.convertor.toMarkdownText(dr), !lr);
        }
        if (this.eventEmitter.emit("removePopupWidget"), this.eventEmitter.emit("changeMode", ar), !lr) {
          var fr = this.convertor.getMappedPos();
          this.focus(), this.isWysiwygMode() && isNumber_1(fr) ? this.wwEditor.setSelection(fr) : Array.isArray(fr) && this.mdEditor.setSelection(fr);
        }
      }
    }, cr.prototype.destroy = function() {
      var ar = this;
      this.wwEditor.destroy(), this.mdEditor.destroy(), this.preview.destroy(), this.scrollSync.destroy(), this.eventEmitter.emit("destroy"), this.eventEmitter.getEvents().forEach(function(lr, ur) {
        return ar.off(ur);
      });
    }, cr.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    }, cr.prototype.show = function() {
      this.eventEmitter.emit("show");
    }, cr.prototype.setScrollTop = function(ar) {
      this.getCurrentModeEditor().setScrollTop(ar);
    }, cr.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    }, cr.prototype.reset = function() {
      this.wwEditor.setModel([]), this.mdEditor.setMarkdown("");
    }, cr.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    }, cr.prototype.setPlaceholder = function(ar) {
      this.placeholder = ar, this.mdEditor.setPlaceholder(ar), this.wwEditor.setPlaceholder(ar);
    }, cr.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    }, cr.prototype.convertPosToMatchEditorMode = function(ar, lr, ur) {
      var dr, fr;
      lr === void 0 && (lr = ar), ur === void 0 && (ur = this.mode);
      var gr = this.mdEditor.view.state.doc, mr = Array.isArray(ar), vr = Array.isArray(lr), yr = ar, _r = lr;
      if (mr !== vr)
        throw new Error("Types of arguments must be same");
      return ur === "markdown" && !mr && !vr ? (dr = getEditorToMdPos(gr, ar, lr), yr = dr[0], _r = dr[1]) : ur === "wysiwyg" && mr && vr && (fr = getMdToEditorPos(gr, ar, lr), yr = fr[0], _r = fr[1]), [yr, _r];
    }, cr;
  }()
);
function html$1$2(cr) {
  for (var ar, lr, ur = arguments, dr = 1, fr = "", gr = "", mr = [0], vr = function(_r) {
    dr === 1 && (_r || (fr = fr.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? mr.push(_r ? ur[_r] : fr) : dr === 3 && (_r || fr) ? (mr[1] = _r ? ur[_r] : fr, dr = 2) : dr === 2 && fr === "..." && _r ? mr[2] = assign(mr[2] || {}, ur[_r]) : dr === 2 && fr && !_r ? (mr[2] = mr[2] || {})[fr] = !0 : dr >= 5 && (dr === 5 ? ((mr[2] = mr[2] || {})[lr] = _r ? fr ? fr + ur[_r] : ur[_r] : fr, dr = 6) : (_r || fr) && (mr[2][lr] += _r ? fr + ur[_r] : fr)), fr = "";
  }, yr = 0; yr < cr.length; yr++) {
    yr && (dr === 1 && vr(), vr(yr));
    for (let _r = 0; _r < cr[yr].length; _r++)
      ar = cr[yr][_r], dr === 1 ? ar === "<" ? (vr(), mr = [mr, "", null], dr = 3) : fr += ar : dr === 4 ? fr === "--" && ar === ">" ? (dr = 1, fr = "") : fr = ar + fr[0] : gr ? ar === gr ? gr = "" : fr += ar : ar === '"' || ar === "'" ? gr = ar : ar === ">" ? (vr(), dr = 1) : dr && (ar === "=" ? (dr = 5, lr = fr, fr = "") : ar === "/" && (dr < 5 || cr[yr][_r + 1] === ">") ? (vr(), dr === 3 && (mr = mr[0]), dr = mr, (mr = mr[0]).push(this.apply(null, dr.slice(1))), dr = 0) : ar === " " || ar === "	" || ar === `
` || ar === "\r" ? (vr(), dr = 2) : fr += ar), dr === 3 && fr === "!--" && (dr = 4, mr = mr[0]);
  }
  return vr(), mr.length > 2 ? mr.slice(1) : mr[1];
}
function isBoolean(cr) {
  return typeof cr == "boolean" || cr instanceof Boolean;
}
var isBoolean_1 = isBoolean, VNodeWalker = (
  /** @class */
  function() {
    function cr(ar) {
      this.current = ar, this.root = ar, this.entering = !0;
    }
    return cr.prototype.walk = function() {
      var ar = this, lr = ar.entering, ur = ar.current;
      return ur ? (lr ? ur.firstChild ? (this.current = ur.firstChild, this.entering = !0) : this.entering = !1 : ur === this.root ? this.current = null : ur.next ? (this.current = ur.next, this.entering = !0) : (this.current = ur.parent, this.entering = !1), { vnode: ur, entering: lr }) : null;
    }, cr;
  }()
), VNode = (
  /** @class */
  function() {
    function cr(ar, lr, ur) {
      this.parent = null, this.old = null, this.firstChild = null, this.next = null, this.skip = !1, this.type = ar, this.props = lr, this.children = ur, this.props.children = ur, lr.ref && (this.ref = lr.ref, delete lr.ref), lr.key && (this.key = lr.key, delete lr.key);
    }
    return cr.prototype.walker = function() {
      return new VNodeWalker(this);
    }, cr.removalNodes = [], cr;
  }()
);
function createTextNode(cr) {
  return new VNode("TEXT_NODE", { nodeValue: cr }, []);
}
function excludeUnnecessaryChild(cr, ar) {
  var lr = cr;
  isBoolean_1(cr) || cr == null ? lr = null : (isString_1(cr) || isNumber_1(cr)) && (lr = createTextNode(String(cr))), lr && ar.push(lr);
}
function h(cr, ar) {
  for (var lr = [], ur = 2; ur < arguments.length; ur++)
    lr[ur - 2] = arguments[ur];
  var dr = [];
  return lr.forEach(function(fr) {
    Array.isArray(fr) ? fr.forEach(function(gr) {
      excludeUnnecessaryChild(gr, dr);
    }) : excludeUnnecessaryChild(fr, dr);
  }), new VNode(cr, ar || {}, dr);
}
var html$3 = html$1$2.bind(h);
function isObject(cr) {
  return cr === Object(cr);
}
var isObject_1 = isObject;
function createNode(cr) {
  var ar;
  return cr.type === "TEXT_NODE" ? ar = document.createTextNode(cr.props.nodeValue) : (ar = document.createElement(cr.type), setProps(ar, {}, cr.props)), ar;
}
function removeNode(cr, ar) {
  cr.node ? ar.removeChild(cr.node) : removeNode(cr.firstChild, ar);
}
function innerDiff(cr, ar, lr) {
  Object.keys(ar).forEach(function(ur) {
    if (/^on/.test(ur)) {
      if (!lr[ur] || ar[ur] !== lr[ur]) {
        var dr = ur.slice(2).toLowerCase();
        cr.removeEventListener(dr, ar[ur]);
      }
    } else
      ur !== "children" && !lr[ur] && !isTextNode(cr) && cr.removeAttribute(ur);
  }), setProps(cr, ar, lr, function(ur) {
    return !shallowEqual(ar[ur], lr[ur]);
  });
}
var reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setProps(cr, ar, lr, ur) {
  Object.keys(lr).forEach(function(dr) {
    if (!ur || ur(dr))
      if (/^on/.test(dr)) {
        var fr = dr.slice(2).toLowerCase();
        cr.addEventListener(fr, lr[dr]);
      } else
        dr === "nodeValue" ? cr[dr] = lr[dr] : dr === "style" && isObject_1(lr[dr]) ? setStyleProps(cr, ar[dr], lr[dr]) : dr !== "children" && (lr[dr] === !1 ? cr.removeAttribute(dr) : cr.setAttribute(dr, lr[dr]));
  });
}
function setStyleProps(cr, ar, lr) {
  ar && Object.keys(ar).forEach(function(ur) {
    cr.style[ur] = "";
  }), Object.keys(lr).forEach(function(ur) {
    var dr = lr[ur];
    cr.style[ur] = isNumber_1(dr) && !reNonDimension.test(ur) ? dr + "px" : dr;
  });
}
function commit(cr) {
  if (VNode.removalNodes.forEach(function(fr) {
    return diff(fr);
  }), cr) {
    for (var ar = void 0, lr = cr.walker(); ar = lr.walk(); )
      if (cr = ar.vnode, ar.entering)
        diff(cr);
      else if (isFunction_1(cr.type)) {
        var ur = cr.component;
        if (!cr.old && ur.mounted && ur.mounted(), cr.old && ur.updated) {
          var dr = ur.prevProps || {};
          ur.updated(dr);
        }
      }
  }
}
function getParentNode(cr) {
  for (var ar = cr.parent; !ar.node; )
    ar = ar.parent;
  return ar.node;
}
function diff(cr) {
  if (!(!cr || !cr.parent)) {
    if (cr.node) {
      var ar = getParentNode(cr);
      cr.effect === "A" ? ar.appendChild(cr.node) : cr.effect === "U" && innerDiff(cr.node, cr.old.props, cr.props);
    }
    if (cr.effect === "D") {
      for (var lr = void 0, ur = cr.walker(); lr = ur.walk(); )
        if (cr = lr.vnode, !lr.entering)
          if (isFunction_1(cr.type)) {
            var dr = cr.component;
            dr.beforeDestroy && dr.beforeDestroy();
          } else {
            var ar = getParentNode(cr);
            removeNode(cr, ar);
          }
    }
    cr.ref && (cr.component ? cr.ref(cr.component) : cr.node && cr.ref(cr.node));
  }
}
function createComponent(cr, ar) {
  var lr = ar.props, ur = ar.component;
  return ur ? (ur.prevProps = ur.props, ur.props = ar.props, ur) : new cr(lr);
}
function buildVNode(cr) {
  for (var ar = cr; cr && !cr.skip; ) {
    if (isFunction_1(cr.type)) {
      var lr = createComponent(cr.type, cr);
      lr.vnode = cr, cr.component = lr, cr.props.children = cr.children = [lr.render()], buildChildrenVNode(cr);
    } else
      cr.node || (cr.node = createNode(cr)), buildChildrenVNode(cr);
    if (cr.firstChild)
      cr = cr.firstChild;
    else {
      for (; cr && cr.parent && !cr.next && (cr = cr.parent, cr !== ar); )
        ;
      cr = cr.next;
    }
  }
}
function isSameType(cr, ar) {
  return cr && ar && ar.type === cr.type && (!ar.key || ar.key === cr.key);
}
function buildChildrenVNode(cr) {
  var ar = cr.children, lr = cr.old ? cr.old.firstChild : null, ur = null;
  ar.forEach(function(fr, gr) {
    var mr = isSameType(lr, fr);
    mr && (fr.old = lr, fr.parent = cr, fr.node = lr.node, fr.component = lr.component, fr.effect = "U"), fr && !mr && (fr.old = null, fr.parent = cr, fr.node = null, fr.effect = "A"), lr && !mr && (VNode.removalNodes.push(lr), lr.effect = "D"), lr && (lr = lr.next), gr === 0 ? cr.firstChild = fr : fr && (ur.next = fr), ur = fr;
  });
  var dr = last$1(ar);
  if (!ar.length)
    for (; lr; )
      VNode.removalNodes.push(lr), lr.effect = "D", lr = lr.next;
  for (; lr && dr; )
    lr && dr.old !== lr && (VNode.removalNodes.push(lr), lr.effect = "D", lr = lr.next);
}
function destroy(cr) {
  cr.effect = "D", VNode.removalNodes = [cr], commit(), VNode.removalNodes = [];
}
function rerender(cr) {
  var ar = cr.vnode;
  ar.effect = "U", ar.old = ar, ar.next && (ar.next.skip = !0), VNode.removalNodes = [], buildVNode(ar), commit(ar), ar.next && (ar.next.skip = !1);
}
function render(cr, ar) {
  var lr = new VNode(cr.tagName.toLowerCase(), {}, [ar]);
  return lr.node = cr, VNode.removalNodes = [], buildVNode(lr), commit(lr), function() {
    return destroy(lr.firstChild);
  };
}
var Component = (
  /** @class */
  function() {
    function cr(ar) {
      this.props = ar, this.state = {}, this.refs = {};
    }
    return cr.prototype.setState = function(ar) {
      var lr = __assign$1(__assign$1({}, this.state), ar);
      shallowEqual(this.state, lr) || (this.state = lr, rerender(this));
    }, cr;
  }()
), Switch = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.state = {
        hide: !1
      }, ur;
    }
    return ar.prototype.show = function() {
      this.setState({ hide: !1 });
    }, ar.prototype.hide = function() {
      this.setState({ hide: !0 });
    }, ar.prototype.render = function() {
      var lr = this.props, ur = lr.editorType, dr = lr.eventEmitter;
      return html$3(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([`
      <div class="`, '" style="display: ', `">
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style="display: ',
        `">
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("mode-switch"), this.state.hide ? "none" : "block", ur === "markdown" ? " active" : "", function() {
        dr.emit("needChangeMode", "markdown");
      }, i18n.get("Markdown"), ur === "wysiwyg" ? " active" : "", function() {
        dr.emit("needChangeMode", "wysiwyg");
      }, i18n.get("WYSIWYG"));
    }, ar;
  }(Component)
), templateObject_1$h;
function debounce$1(cr, ar) {
  var lr, ur;
  ar = ar || 0;
  function dr() {
    ur = Array.prototype.slice.call(arguments), window.clearTimeout(lr), lr = window.setTimeout(function() {
      cr.apply(null, ur);
    }, ar);
  }
  return dr;
}
var debounce_1 = debounce$1, debounce = debounce_1;
function throttle$1(cr, ar) {
  var lr, ur = !0, dr = function(_r) {
    cr.apply(null, _r), lr = null;
  }, fr, gr, mr;
  ar = ar || 0, fr = debounce(dr, ar);
  function vr() {
    if (mr = Array.prototype.slice.call(arguments), ur) {
      dr(mr), ur = !1;
      return;
    }
    gr = Number(/* @__PURE__ */ new Date()), lr = lr || gr, fr(mr), gr - lr >= ar && dr(mr);
  }
  function yr() {
    ur = !0, lr = null;
  }
  return vr.reset = yr, vr;
}
var throttle_1 = throttle$1, MapShim = function() {
  if (typeof Map != "undefined")
    return Map;
  function cr(ar, lr) {
    var ur = -1;
    return ar.some(function(dr, fr) {
      return dr[0] === lr ? (ur = fr, !0) : !1;
    }), ur;
  }
  return (
    /** @class */
    function() {
      function ar() {
        this.__entries__ = [];
      }
      return Object.defineProperty(ar.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), ar.prototype.get = function(lr) {
        var ur = cr(this.__entries__, lr), dr = this.__entries__[ur];
        return dr && dr[1];
      }, ar.prototype.set = function(lr, ur) {
        var dr = cr(this.__entries__, lr);
        ~dr ? this.__entries__[dr][1] = ur : this.__entries__.push([lr, ur]);
      }, ar.prototype.delete = function(lr) {
        var ur = this.__entries__, dr = cr(ur, lr);
        ~dr && ur.splice(dr, 1);
      }, ar.prototype.has = function(lr) {
        return !!~cr(this.__entries__, lr);
      }, ar.prototype.clear = function() {
        this.__entries__.splice(0);
      }, ar.prototype.forEach = function(lr, ur) {
        ur === void 0 && (ur = null);
        for (var dr = 0, fr = this.__entries__; dr < fr.length; dr++) {
          var gr = fr[dr];
          lr.call(ur, gr[1], gr[0]);
        }
      }, ar;
    }()
  );
}(), isBrowser = typeof window != "undefined" && typeof document != "undefined" && window.document === document, global$1 = function() {
  return typeof global != "undefined" && global.Math === Math ? global : typeof self != "undefined" && self.Math === Math ? self : typeof window != "undefined" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(cr) {
    return setTimeout(function() {
      return cr(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle(cr, ar) {
  var lr = !1, ur = !1, dr = 0;
  function fr() {
    lr && (lr = !1, cr()), ur && mr();
  }
  function gr() {
    requestAnimationFrame$1(fr);
  }
  function mr() {
    var vr = Date.now();
    if (lr) {
      if (vr - dr < trailingTimeout)
        return;
      ur = !0;
    } else
      lr = !0, ur = !1, setTimeout(gr, ar);
    dr = vr;
  }
  return mr;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver != "undefined", ResizeObserverController = (
  /** @class */
  function() {
    function cr() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    return cr.prototype.addObserver = function(ar) {
      ~this.observers_.indexOf(ar) || this.observers_.push(ar), this.connected_ || this.connect_();
    }, cr.prototype.removeObserver = function(ar) {
      var lr = this.observers_, ur = lr.indexOf(ar);
      ~ur && lr.splice(ur, 1), !lr.length && this.connected_ && this.disconnect_();
    }, cr.prototype.refresh = function() {
      var ar = this.updateObservers_();
      ar && this.refresh();
    }, cr.prototype.updateObservers_ = function() {
      var ar = this.observers_.filter(function(lr) {
        return lr.gatherActive(), lr.hasActive();
      });
      return ar.forEach(function(lr) {
        return lr.broadcastActive();
      }), ar.length > 0;
    }, cr.prototype.connect_ = function() {
      !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, cr.prototype.disconnect_ = function() {
      !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, cr.prototype.onTransitionEnd_ = function(ar) {
      var lr = ar.propertyName, ur = lr === void 0 ? "" : lr, dr = transitionKeys.some(function(fr) {
        return !!~ur.indexOf(fr);
      });
      dr && this.refresh();
    }, cr.getInstance = function() {
      return this.instance_ || (this.instance_ = new cr()), this.instance_;
    }, cr.instance_ = null, cr;
  }()
), defineConfigurable = function(cr, ar) {
  for (var lr = 0, ur = Object.keys(ar); lr < ur.length; lr++) {
    var dr = ur[lr];
    Object.defineProperty(cr, dr, {
      value: ar[dr],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return cr;
}, getWindowOf = function(cr) {
  var ar = cr && cr.ownerDocument && cr.ownerDocument.defaultView;
  return ar || global$1;
}, emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(cr) {
  return parseFloat(cr) || 0;
}
function getBordersSize(cr) {
  for (var ar = [], lr = 1; lr < arguments.length; lr++)
    ar[lr - 1] = arguments[lr];
  return ar.reduce(function(ur, dr) {
    var fr = cr["border-" + dr + "-width"];
    return ur + toFloat(fr);
  }, 0);
}
function getPaddings(cr) {
  for (var ar = ["top", "right", "bottom", "left"], lr = {}, ur = 0, dr = ar; ur < dr.length; ur++) {
    var fr = dr[ur], gr = cr["padding-" + fr];
    lr[fr] = toFloat(gr);
  }
  return lr;
}
function getSVGContentRect(cr) {
  var ar = cr.getBBox();
  return createRectInit(0, 0, ar.width, ar.height);
}
function getHTMLElementContentRect(cr) {
  var ar = cr.clientWidth, lr = cr.clientHeight;
  if (!ar && !lr)
    return emptyRect;
  var ur = getWindowOf(cr).getComputedStyle(cr), dr = getPaddings(ur), fr = dr.left + dr.right, gr = dr.top + dr.bottom, mr = toFloat(ur.width), vr = toFloat(ur.height);
  if (ur.boxSizing === "border-box" && (Math.round(mr + fr) !== ar && (mr -= getBordersSize(ur, "left", "right") + fr), Math.round(vr + gr) !== lr && (vr -= getBordersSize(ur, "top", "bottom") + gr)), !isDocumentElement(cr)) {
    var yr = Math.round(mr + fr) - ar, _r = Math.round(vr + gr) - lr;
    Math.abs(yr) !== 1 && (mr -= yr), Math.abs(_r) !== 1 && (vr -= _r);
  }
  return createRectInit(dr.left, dr.top, mr, vr);
}
var isSVGGraphicsElement = function() {
  return typeof SVGGraphicsElement != "undefined" ? function(cr) {
    return cr instanceof getWindowOf(cr).SVGGraphicsElement;
  } : function(cr) {
    return cr instanceof getWindowOf(cr).SVGElement && typeof cr.getBBox == "function";
  };
}();
function isDocumentElement(cr) {
  return cr === getWindowOf(cr).document.documentElement;
}
function getContentRect(cr) {
  return isBrowser ? isSVGGraphicsElement(cr) ? getSVGContentRect(cr) : getHTMLElementContentRect(cr) : emptyRect;
}
function createReadOnlyRect(cr) {
  var ar = cr.x, lr = cr.y, ur = cr.width, dr = cr.height, fr = typeof DOMRectReadOnly != "undefined" ? DOMRectReadOnly : Object, gr = Object.create(fr.prototype);
  return defineConfigurable(gr, {
    x: ar,
    y: lr,
    width: ur,
    height: dr,
    top: lr,
    right: ar + ur,
    bottom: dr + lr,
    left: ar
  }), gr;
}
function createRectInit(cr, ar, lr, ur) {
  return { x: cr, y: ar, width: lr, height: ur };
}
var ResizeObservation = (
  /** @class */
  function() {
    function cr(ar) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = ar;
    }
    return cr.prototype.isActive = function() {
      var ar = getContentRect(this.target);
      return this.contentRect_ = ar, ar.width !== this.broadcastWidth || ar.height !== this.broadcastHeight;
    }, cr.prototype.broadcastRect = function() {
      var ar = this.contentRect_;
      return this.broadcastWidth = ar.width, this.broadcastHeight = ar.height, ar;
    }, cr;
  }()
), ResizeObserverEntry = (
  /** @class */
  function() {
    function cr(ar, lr) {
      var ur = createReadOnlyRect(lr);
      defineConfigurable(this, { target: ar, contentRect: ur });
    }
    return cr;
  }()
), ResizeObserverSPI = (
  /** @class */
  function() {
    function cr(ar, lr, ur) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof ar != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = ar, this.controller_ = lr, this.callbackCtx_ = ur;
    }
    return cr.prototype.observe = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var lr = this.observations_;
        lr.has(ar) || (lr.set(ar, new ResizeObservation(ar)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, cr.prototype.unobserve = function(ar) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(ar instanceof getWindowOf(ar).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var lr = this.observations_;
        lr.has(ar) && (lr.delete(ar), lr.size || this.controller_.removeObserver(this));
      }
    }, cr.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, cr.prototype.gatherActive = function() {
      var ar = this;
      this.clearActive(), this.observations_.forEach(function(lr) {
        lr.isActive() && ar.activeObservations_.push(lr);
      });
    }, cr.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var ar = this.callbackCtx_, lr = this.activeObservations_.map(function(ur) {
          return new ResizeObserverEntry(ur.target, ur.broadcastRect());
        });
        this.callback_.call(ar, lr, ar), this.clearActive();
      }
    }, cr.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, cr.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, cr;
  }()
), observers = typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver = (
  /** @class */
  function() {
    function cr(ar) {
      if (!(this instanceof cr))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var lr = ResizeObserverController.getInstance(), ur = new ResizeObserverSPI(ar, lr, this);
      observers.set(this, ur);
    }
    return cr;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(cr) {
  ResizeObserver.prototype[cr] = function() {
    var ar;
    return (ar = observers.get(this))[cr].apply(ar, arguments);
  };
});
var index = function() {
  return typeof global$1.ResizeObserver != "undefined" ? global$1.ResizeObserver : ResizeObserver;
}(), HeadingPopupBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return ar.prototype.execCommand = function(lr) {
      var ur = closest(lr.target, "li");
      this.props.execCommand("heading", {
        level: Number(ur.getAttribute("data-level"))
      });
    }, ar.prototype.render = function() {
      var lr = this;
      return html$3(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([`
      <ul
        onClick=`, `
        aria-role="menu"
        aria-label="`, `"
      >
        `, `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`, `</div>
        </li>
      </ul>
    `], [
        `
      <ul
        onClick=`,
        `
        aria-role="menu"
        aria-label="`,
        `"
      >
        `,
        `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
        `</div>
        </li>
      </ul>
    `
      ])), function(ur) {
        return lr.execCommand(ur);
      }, i18n.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(ur) {
        return html$3(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `], [`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `])), ur, "h" + ur, i18n.get("Heading"), ur);
      }), i18n.get("Paragraph"));
    }, ar;
  }(Component)
), templateObject_1$g, templateObject_2$8, Tabs = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return ar.prototype.toggleTab = function(lr, ur) {
      this.props.onClick(lr, ur);
    }, ar.prototype.render = function() {
      var lr = this;
      return html$3(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([`
      <div class="`, `" aria-role="tabpanel">
        `, `
      </div>
    `], [
        `
      <div class="`,
        `" aria-role="tabpanel">
        `,
        `
      </div>
    `
      ])), cls("tabs"), this.props.tabs.map(function(ur) {
        var dr = ur.name, fr = ur.text, gr = lr.props.activeTab === dr;
        return html$3(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `], [`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `])), gr ? " active" : "", function(mr) {
          return lr.toggleTab(mr, dr);
        }, i18n.get(fr), gr ? "true" : "false", gr ? "0" : "-1", i18n.get(fr));
      }));
    }, ar;
  }(Component)
), templateObject_1$f, templateObject_2$7, TYPE_UI = "ui", ImagePopupBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.initialize = function(dr) {
        dr === void 0 && (dr = "file");
        var fr = ur.refs.url;
        fr.value = "", ur.refs.altText.value = "", ur.refs.file.value = "", removeClass_1(fr, "wrong"), ur.setState({ activeTab: dr, file: null, fileNameElClassName: "" });
      }, ur.execCommand = function() {
        ur.state.activeTab === "file" ? ur.emitAddImageBlob() : ur.emitAddImage();
      }, ur.toggleTab = function(dr, fr) {
        fr !== ur.state.activeTab && ur.initialize(fr);
      }, ur.showFileSelectBox = function() {
        ur.refs.file.click();
      }, ur.changeFile = function(dr) {
        var fr = dr.target.files;
        fr != null && fr.length && ur.setState({ file: fr[0] });
      }, ur.state = { activeTab: "file", file: null, fileNameElClassName: "" }, ur.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ], ur;
    }
    return ar.prototype.emitAddImageBlob = function() {
      var lr = this, ur = this.refs.file.files, dr = this.refs.altText, fr = " wrong";
      if (ur != null && ur.length) {
        fr = "";
        var gr = ur.item(0), mr = function(vr, yr) {
          return lr.props.execCommand("addImage", { imageUrl: vr, altText: yr || dr.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", gr, mr, TYPE_UI);
      }
      this.setState({ fileNameElClassName: fr });
    }, ar.prototype.emitAddImage = function() {
      var lr = this.refs.url, ur = this.refs.altText, dr = lr.value, fr = ur.value || "image";
      if (removeClass_1(lr, "wrong"), !dr.length) {
        addClass_1(lr, "wrong");
        return;
      }
      dr && this.props.execCommand("addImage", { imageUrl: dr, altText: fr });
    }, ar.prototype.preventSelectStart = function(lr) {
      lr.preventDefault();
    }, ar.prototype.updated = function() {
      this.props.show || this.initialize();
    }, ar.prototype.render = function() {
      var lr = this, ur = this.state, dr = ur.activeTab, fr = ur.file, gr = ur.fileNameElClassName;
      return html$3(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert image"), Tabs, this.tabs, dr, this.toggleTab, dr === "url" ? "block" : "none", i18n.get("Image URL"), function(mr) {
        return lr.refs.url = mr;
      }, dr === "file" ? "block" : "none", i18n.get("Select image file"), cls("file-name"), fr ? " has-file" : gr, this.showFileSelectBox, this.preventSelectStart, fr ? fr.name : i18n.get("No file"), cls("file-select-button"), this.showFileSelectBox, i18n.get("Choose a file"), this.changeFile, function(mr) {
        return lr.refs.file = mr;
      }, i18n.get("Description"), function(mr) {
        return lr.refs.altText = mr;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$e, LinkPopupBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.execCommand = function() {
        var ur = lr.refs.url, dr = lr.refs.text;
        if (removeClass_1(ur, "wrong"), removeClass_1(dr, "wrong"), ur.value.length < 1) {
          addClass_1(ur, "wrong");
          return;
        }
        var fr = isUndefined_1(lr.props.initialValues.linkUrl);
        if (fr && dr.value.length < 1) {
          addClass_1(dr, "wrong");
          return;
        }
        lr.props.execCommand("addLink", {
          linkUrl: ur.value,
          linkText: dr.value
        });
      }, lr;
    }
    return ar.prototype.initialize = function() {
      var lr = this.props.initialValues, ur = lr.linkUrl, dr = lr.linkText, fr = this.refs.url, gr = this.refs.text;
      removeClass_1(fr, "wrong"), removeClass_1(gr, "wrong", "disabled"), gr.removeAttribute("disabled"), ur && (addClass_1(gr, "disabled"), gr.setAttribute("disabled", "disabled")), fr.value = ur || "", gr.value = dr || "";
    }, ar.prototype.mounted = function() {
      this.initialize();
    }, ar.prototype.updated = function(lr) {
      !lr.show && this.props.show && this.initialize();
    }, ar.prototype.render = function() {
      var lr = this;
      return html$3(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), i18n.get("Insert link"), i18n.get("URL"), function(ur) {
        return lr.refs.url = ur;
      }, i18n.get("Link text"), function(ur) {
        return lr.refs.text = ur;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    }, ar;
  }(Component)
), templateObject_1$d, CELL_WIDTH = 20, CELL_HEIGHT = 20, MIN_ROW_INDEX = 5, MAX_ROW_INDEX = 14, MIN_COL_INDEX = 5, MAX_COL_INDEX = 9, MIN_ROW_SELECTION_INDEX = 1, MIN_COL_SELECTION_INDEX = 1, BORDER_WIDTH = 1, TablePopupBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.extendSelectionRange = function(dr) {
        var fr = dr.pageX, gr = dr.pageY, mr = fr - ur.offsetRect.left, vr = gr - ur.offsetRect.top, yr = ur.getSelectionRangeByOffset(mr, vr);
        ur.setState(__assign$1({}, yr));
      }, ur.execCommand = function() {
        ur.props.execCommand("addTable", {
          rowCount: ur.state.rowIdx + 1,
          columnCount: ur.state.colIdx + 1
        });
      }, ur.state = {
        rowIdx: -1,
        colIdx: -1
      }, ur;
    }
    return ar.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    }, ar.prototype.getBoundByRange = function(lr, ur) {
      return {
        width: (lr + 1) * CELL_WIDTH,
        height: (ur + 1) * CELL_HEIGHT
      };
    }, ar.prototype.getRangeByOffset = function(lr, ur) {
      return {
        colIdx: Math.floor(lr / CELL_WIDTH),
        rowIdx: Math.floor(ur / CELL_HEIGHT)
      };
    }, ar.prototype.getTableRange = function() {
      var lr = this.state, ur = lr.colIdx, dr = lr.rowIdx, fr = Math.max(ur, MIN_COL_INDEX), gr = Math.max(dr, MIN_ROW_INDEX);
      return ur >= MIN_COL_INDEX && fr < MAX_COL_INDEX && (fr += 1), dr >= MIN_ROW_INDEX && gr < MAX_ROW_INDEX && (gr += 1), { colIdx: fr + 1, rowIdx: gr + 1 };
    }, ar.prototype.getSelectionAreaBound = function() {
      var lr = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), ur = lr.width, dr = lr.height;
      return !ur && !dr ? { display: "none" } : { width: ur - BORDER_WIDTH, height: dr - BORDER_WIDTH, display: "block" };
    }, ar.prototype.getSelectionRangeByOffset = function(lr, ur) {
      var dr = this.getRangeByOffset(lr, ur);
      return dr.rowIdx = Math.min(Math.max(dr.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX), dr.colIdx = Math.min(Math.max(dr.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX), dr;
    }, ar.prototype.updated = function() {
      if (!this.props.show)
        this.setState({ colIdx: -1, rowIdx: -1 });
      else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var lr = this.refs.tableEl.getBoundingClientRect(), ur = lr.left, dr = lr.top;
        this.offsetRect = {
          left: window.pageXOffset + ur,
          top: window.pageYOffset + dr
        };
      }
    }, ar.prototype.createTableArea = function(lr) {
      for (var ur = lr.colIdx, dr = lr.rowIdx, fr = [], gr = 0; gr < dr; gr += 1) {
        for (var mr = [], vr = 0; vr < ur; vr += 1) {
          var yr = "" + cls("table-cell") + (gr > 0 ? "" : " header");
          mr.push(html$3(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(['<div class="', '"></div>'], ['<div class="', '"></div>'])), yr));
        }
        fr.push(html$3(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table-row"), mr));
      }
      return html$3(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table"), fr);
    }, ar.prototype.render = function() {
      var lr = this, ur = this.getTableRange(), dr = this.getSelectionAreaBound();
      return html$3(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `], [`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `])), i18n.get("Insert table"), cls("table-selection"), function(fr) {
        return lr.refs.tableEl = fr;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(ur), cls("table-selection-layer"), dr, cls("table-description"), this.getDescription());
    }, ar;
  }(Component)
), templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1, CustomPopupBody = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return ar.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    }, ar.prototype.updated = function(lr) {
      this.refs.el.replaceChild(this.props.body, lr.body);
    }, ar.prototype.render = function() {
      var lr = this;
      return html$3(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(ur) {
        return lr.refs.el = ur;
      });
    }, ar;
  }(Component)
), templateObject_1$b;
function createToolbarItemInfo(cr) {
  return isString_1(cr) ? createDefaultToolbarItemInfo(cr) : cr;
}
function createScrollSyncToolbarItem() {
  var cr = document.createElement("label"), ar = document.createElement("input"), lr = document.createElement("span");
  cr.className = "scroll-sync active", ar.type = "checkbox", ar.checked = !0, lr.className = "switch";
  var ur = function(dr) {
    return ar.addEventListener("change", function(fr) {
      var gr = fr.target.checked;
      gr ? addClass_1(cr, "active") : removeClass_1(cr, "active"), dr("toggleScrollSync", { active: gr });
    });
  };
  return cr.appendChild(ar), cr.appendChild(lr), {
    name: "scrollSync",
    el: cr,
    onMounted: ur
  };
}
function createDefaultToolbarItemInfo(cr) {
  var ar;
  switch (cr) {
    case "heading":
      ar = {
        name: "heading",
        className: "heading",
        tooltip: i18n.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      ar = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: i18n.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      ar = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: i18n.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      ar = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: i18n.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      ar = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: i18n.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      ar = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: i18n.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      ar = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: i18n.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      ar = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: i18n.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      ar = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: i18n.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      ar = {
        name: "table",
        className: "table",
        tooltip: i18n.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      ar = {
        name: "image",
        className: "image",
        tooltip: i18n.get("Insert image")
      };
      break;
    case "link":
      ar = {
        name: "link",
        className: "link",
        tooltip: i18n.get("Insert link")
      };
      break;
    case "code":
      ar = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: i18n.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      ar = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: i18n.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      ar = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: i18n.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      ar = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: i18n.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      ar = createScrollSyncToolbarItem();
      break;
    case "more":
      ar = {
        name: "more",
        className: "more",
        tooltip: i18n.get("More")
      };
      break;
  }
  return ar.name !== "scrollSync" && (ar.className += " " + cls("toolbar-icons")), ar;
}
function createPopupInfo(cr, ar) {
  var lr = ar.el, ur = ar.pos, dr = ar.popup, fr = ar.initialValues;
  switch (cr) {
    case "heading":
      return {
        render: function(gr) {
          return html$3(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, gr);
        },
        className: cls("popup-add-heading"),
        fromEl: lr,
        pos: ur
      };
    case "link":
      return {
        render: function(gr) {
          return html$3(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, gr);
        },
        className: cls("popup-add-link"),
        fromEl: lr,
        pos: ur,
        initialValues: fr
      };
    case "image":
      return {
        render: function(gr) {
          return html$3(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, gr);
        },
        className: cls("popup-add-image"),
        fromEl: lr,
        pos: ur
      };
    case "table":
      return {
        render: function(gr) {
          return html$3(templateObject_4 || (templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, gr);
        },
        className: cls("popup-add-table"),
        fromEl: lr,
        pos: ur
      };
    case "customPopupBody":
      return dr ? __assign$1({ render: function(gr) {
        return html$3(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, gr, dr.body);
      }, fromEl: lr, pos: ur }, dr) : null;
    default:
      return null;
  }
}
function setGroupState(cr) {
  cr.hidden = cr.length === cr.filter(function(ar) {
    return ar.hidden;
  }).length;
}
function groupToolbarItems(cr, ar) {
  var lr = function(ur) {
    return ur.hidden = ur.name === "scrollSync" && ar, ur;
  };
  return cr.reduce(function(ur, dr) {
    ur.push(dr.map(function(gr) {
      return lr(createToolbarItemInfo(gr));
    }));
    var fr = ur[(ur.length || 1) - 1];
    return fr && setGroupState(fr), ur;
  }, []);
}
function toggleScrollSync(cr, ar) {
  cr.forEach(function(lr) {
    lr.forEach(function(ur) {
      return ur.hidden = ur.name === "scrollSync" && ar;
    }), setGroupState(lr);
  });
}
var templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5, MARGIN_FROM_RIGHT_SIDE = 20, Popup = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.handleMousedown = function(ur) {
        !closest(ur.target, "." + cls("popup")) && !closest(ur.target, lr.props.info.fromEl) && lr.props.hidePopup();
      }, lr;
    }
    return ar.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown), this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    }, ar.prototype.updated = function(lr) {
      var ur = this.props, dr = ur.show, fr = ur.info;
      if (dr && fr.pos && lr.show !== dr) {
        var gr = __assign$1({}, fr.pos), mr = this.refs.el.offsetWidth, vr = closest(this.refs.el, "." + cls("toolbar")), yr = vr.offsetWidth;
        gr.left + mr >= yr && (gr.left = yr - mr - MARGIN_FROM_RIGHT_SIDE), shallowEqual(this.state.popupPos, gr) || this.setState({ popupPos: gr });
      }
    }, ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.info, fr = ur.show, gr = ur.hidePopup, mr = ur.eventEmitter, vr = ur.execCommand, yr = dr || {}, _r = yr.className, kr = _r === void 0 ? "" : _r, xr = yr.style, Ar = yr.render, Er = yr.initialValues, Cr = Er === void 0 ? {} : Er, Tr = __assign$1(__assign$1({ display: fr ? "block" : "none" }, xr), this.state.popupPos);
      return html$3(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `], [`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `])), cls("popup"), kr, Tr, function(Sr) {
        return lr.refs.el = Sr;
      }, cls("popup-body"), Ar && Ar({ eventEmitter: mr, show: fr, hidePopup: gr, execCommand: vr, initialValues: Cr }));
    }, ar;
  }(Component)
), templateObject_1$9, TOOLTIP_INDENT = 6;
function connectHOC(cr) {
  return (
    /** @class */
    function(ar) {
      __extends$1(lr, ar);
      function lr(ur) {
        var dr = ar.call(this, ur) || this;
        return dr.showTooltip = function(fr) {
          var gr = dr.props.item.tooltip;
          if (!dr.props.disabled && gr) {
            var mr = dr.getBound(fr), vr = mr.left + TOOLTIP_INDENT + "px", yr = mr.top + TOOLTIP_INDENT + "px";
            css_1(dr.props.tooltipRef.current, { display: "block", left: vr, top: yr }), dr.props.tooltipRef.current.querySelector(".text").textContent = gr;
          }
        }, dr.hideTooltip = function() {
          css_1(dr.props.tooltipRef.current, "display", "none");
        }, dr.state = { active: !1, disabled: ur.disabled }, dr.addEvent(), dr;
      }
      return lr.prototype.addEvent = function() {
        var ur = this, dr = this.props, fr = dr.item, gr = dr.eventEmitter;
        fr.state && gr.listen("changeToolbarState", function(mr) {
          var vr, yr = mr.toolbarState, _r = (vr = yr[fr.state]) !== null && vr !== void 0 ? vr : {}, kr = _r.active, xr = _r.disabled;
          ur.setState({ active: !!kr, disabled: xr != null ? xr : ur.props.disabled });
        });
      }, lr.prototype.getBound = function(ur) {
        var dr = getTotalOffset(ur, closest(ur, "." + cls("toolbar"))), fr = dr.offsetLeft, gr = dr.offsetTop;
        return { left: fr, top: ur.offsetHeight + gr };
      }, lr.prototype.render = function() {
        return html$3(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `], [`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `])), cr, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      }, lr;
    }(Component)
  );
}
var templateObject_1$8, DEFAULT_WIDTH = 80, ToolbarButtonComp = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.showTooltip = function() {
        lr.props.showTooltip(lr.refs.el);
      }, lr.execCommand = function() {
        var ur = lr.props, dr = ur.item, fr = ur.execCommand, gr = ur.setPopupInfo, mr = ur.getBound, vr = ur.eventEmitter, yr = dr.command, _r = dr.name, kr = dr.popup;
        if (yr)
          fr(yr);
        else {
          var xr = kr ? "customPopupBody" : _r, Ar = vr.emit("query", "getPopupInitialValues", { popupName: xr })[0], Er = createPopupInfo(xr, {
            el: lr.refs.el,
            pos: mr(lr.refs.el),
            popup: kr,
            initialValues: Ar
          });
          Er && gr(Er);
        }
      }, lr;
    }
    return ar.prototype.mounted = function() {
      this.setItemWidth();
    }, ar.prototype.updated = function(lr) {
      lr.item.name !== this.props.item.name && this.setItemWidth();
    }, ar.prototype.setItemWidth = function() {
      var lr = this.props, ur = lr.setItemWidth, dr = lr.item;
      ur && ur(dr.name, getOuterWidth(this.refs.el) + (dr.hidden ? DEFAULT_WIDTH : 0));
    }, ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.hideTooltip, fr = ur.disabled, gr = ur.item, mr = ur.active, vr = __assign$1({ display: gr.hidden ? "none" : null }, gr.style), yr = "" + (gr.className || "") + (mr ? " active" : "");
      return html$3(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `], [`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `])), function(_r) {
        return lr.refs.el = _r;
      }, vr, yr, this.execCommand, this.showTooltip, dr, !!fr, gr.text || gr.tooltip || "", gr.text || "");
    }, ar;
  }(Component)
), ToolbarButton = connectHOC(ToolbarButtonComp), templateObject_1$7, CustomToolbarItemComp = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      var lr = cr !== null && cr.apply(this, arguments) || this;
      return lr.showTooltip = function() {
        lr.props.showTooltip(lr.refs.el);
      }, lr.showPopup = function() {
        var ur = createPopupInfo("customPopupBody", {
          el: lr.refs.el,
          pos: lr.props.getBound(lr.refs.el),
          popup: lr.props.item.popup
        });
        ur && lr.props.setPopupInfo(ur);
      }, lr;
    }
    return ar.prototype.mounted = function() {
      var lr = this.props, ur = lr.setItemWidth, dr = lr.item;
      this.refs.el.appendChild(dr.el), ur && ur(dr.name, getOuterWidth(this.refs.el)), dr.onMounted && dr.onMounted(this.props.execCommand);
    }, ar.prototype.updated = function(lr) {
      var ur, dr = this.props, fr = dr.item, gr = dr.active, mr = dr.disabled;
      (lr.active !== gr || lr.disabled !== mr) && ((ur = fr.onUpdated) === null || ur === void 0 || ur.call(fr, { active: gr, disabled: mr }));
    }, ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.disabled, fr = ur.item, gr = { display: fr.hidden ? "none" : "inline-block" }, mr = function(vr) {
        return dr ? null : vr;
      };
      return html$3(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `], [`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `])), function(vr) {
        return lr.refs.el = vr;
      }, gr, cls("toolbar-item-wrapper"), mr(this.showPopup), mr(this.showTooltip), mr(this.props.hideTooltip));
    }, ar;
  }(Component)
), CustomToolbarItem = connectHOC(CustomToolbarItemComp), templateObject_1$6, ToolbarGroup = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar() {
      return cr !== null && cr.apply(this, arguments) || this;
    }
    return ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.group, fr = ur.hiddenDivider, gr = dr.hidden ? { display: "none" } : null, mr = fr ? { display: "none" } : null;
      return html$3(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        `, `
        <div class="`, '" style=', `></div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        `,
        `
        <div class="`,
        '" style=',
        `></div>
      </div>
    `
      ])), cls("toolbar-group"), gr, dr.map(function(vr) {
        var yr = vr.el ? CustomToolbarItem : ToolbarButton;
        return html$3(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), yr, vr.name, lr.props, vr);
      }), cls("toolbar-divider"), mr);
    }, ar;
  }(Component)
), templateObject_1$5, templateObject_2$4, POPUP_INDENT = 4, DropdownToolbarButtonComp = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.handleClickDocument = function(dr) {
        var fr = dr.target;
        !closest(fr, "." + cls("dropdown-toolbar")) && !closest(fr, ".more") && ur.setState({ showDropdown: !1, dropdownPos: null });
      }, ur.showTooltip = function() {
        ur.props.showTooltip(ur.refs.el);
      }, ur.state = { showDropdown: !1, dropdownPos: null }, ur;
    }
    return ar.prototype.getBound = function() {
      var lr = this.props.getBound(this.refs.el);
      return lr.top += POPUP_INDENT, __assign$1(__assign$1({}, lr), { left: null, right: 10 });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.updated = function() {
      this.state.showDropdown && !this.state.dropdownPos && this.setState({ dropdownPos: this.getBound() });
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.render = function() {
      var lr = this, ur = this.state, dr = ur.showDropdown, fr = ur.dropdownPos, gr = this.props, mr = gr.disabled, vr = gr.item, yr = gr.items, _r = gr.hideTooltip, kr = yr.filter(function(Er) {
        return !Er.hidden;
      }), xr = kr.length ? null : { display: "none" }, Ar = dr ? null : { display: "none" };
      return html$3(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([`
      <div class="`, '" style=', `>
        <button
          ref=`, `
          type="button"
          class=`, `
          onClick=`, `
          onMouseover=`, `
          onMouseout=`, `
          disabled=`, `
        ></button>
        <div
          class="`, `"
          style=`, `
          ref=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        <button
          ref=`,
        `
          type="button"
          class=`,
        `
          onClick=`,
        `
          onMouseover=`,
        `
          onMouseout=`,
        `
          disabled=`,
        `
        ></button>
        <div
          class="`,
        `"
          style=`,
        `
          ref=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), cls("toolbar-group"), xr, function(Er) {
        return lr.refs.el = Er;
      }, vr.className, function() {
        return lr.setState({ showDropdown: !0 });
      }, this.showTooltip, _r, mr, cls("dropdown-toolbar"), __assign$1(__assign$1({}, Ar), fr), function(Er) {
        return lr.refs.dropdownEl = Er;
      }, kr.length ? kr.map(function(Er, Cr) {
        var Tr;
        return html$3(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([`
                  <`, `
                    group=`, `
                    hiddenDivider=`, `
                    ...`, `
                  />
                `], [
          `
                  <`,
          `
                    group=`,
          `
                    hiddenDivider=`,
          `
                    ...`,
          `
                  />
                `
        ])), ToolbarGroup, Er, Cr === kr.length - 1 || ((Tr = kr[Cr + 1]) === null || Tr === void 0 ? void 0 : Tr.hidden), lr.props);
      }) : null);
    }, ar;
  }(Component)
), DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp), templateObject_1$4, templateObject_2$3, INLINE_PADDING = 50, Toolbar = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.toggleTab = function(dr, fr) {
        var gr = ur.props.eventEmitter;
        if (ur.state.activeTab !== fr) {
          var mr = fr === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          gr.emit(mr), ur.setState({ activeTab: fr });
        }
      }, ur.setItemWidth = function(dr, fr) {
        ur.itemWidthMap[dr] = fr;
      }, ur.setPopupInfo = function(dr) {
        ur.setState({ showPopup: !0, popupInfo: dr });
      }, ur.openPopup = function(dr, fr) {
        fr === void 0 && (fr = {});
        var gr = ur.refs.el.querySelector("." + cls("toolbar-group") + " ." + dr);
        if (gr) {
          var mr = getTotalOffset(gr, closest(gr, "." + cls("toolbar"))), vr = mr.offsetLeft, yr = mr.offsetTop, _r = createPopupInfo(dr, {
            el: gr,
            pos: { left: vr, top: gr.offsetHeight + yr },
            initialValues: fr
          });
          _r && ur.setPopupInfo(_r);
        }
      }, ur.hidePopup = function() {
        ur.state.showPopup && ur.setState({ showPopup: !1 });
      }, ur.execCommand = function(dr, fr) {
        var gr = ur.props.eventEmitter;
        gr.emit("command", dr, fr), ur.hidePopup();
      }, ur.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ], ur.itemWidthMap = {}, ur.initialItems = groupToolbarItems(lr.toolbarItems || [], ur.hiddenScrollSync()), ur.state = {
        items: ur.initialItems,
        dropdownItems: [],
        showPopup: !1,
        popupInfo: {},
        activeTab: "write"
      }, ur.tooltipRef = { current: null }, ur.resizeObserver = new index(function() {
        return ur.handleResize();
      }), ur.addEvent(), ur;
    }
    return ar.prototype.insertToolbarItem = function(lr, ur) {
      var dr = lr.groupIndex, fr = lr.itemIndex, gr = this.initialItems[dr];
      ur = createToolbarItemInfo(ur), gr ? gr.splice(fr, 0, ur) : this.initialItems.push([ur]), this.setState(this.classifyToolbarItems());
    }, ar.prototype.removeToolbarItem = function(lr) {
      var ur = this;
      forEachArray_1(this.initialItems, function(dr) {
        var fr = !1;
        return forEachArray_1(dr, function(gr, mr) {
          return gr.name === lr ? (fr = !0, dr.splice(mr, 1), ur.setState(ur.classifyToolbarItems()), !1) : !0;
        }), !fr;
      });
    }, ar.prototype.addEvent = function() {
      var lr = this, ur = this.props.eventEmitter;
      this.handleResize = throttle_1(function() {
        lr.setState({ items: lr.initialItems, dropdownItems: [] }), lr.setState(lr.classifyToolbarItems());
      }, 200), ur.listen("openPopup", this.openPopup);
    }, ar.prototype.appendTooltipToRoot = function() {
      var lr = '<div class="' + cls("tooltip") + `" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`;
      this.tooltipRef.current = createElementWith(lr, this.refs.el);
    }, ar.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    }, ar.prototype.movePrevItemToDropdownToolbar = function(lr, ur, dr, fr) {
      var gr = function(vr) {
        var yr = vr.pop();
        yr && fr.push(yr);
      };
      if (lr > 1)
        gr(dr);
      else {
        var mr = last$1(ur);
        mr && gr(mr);
      }
    }, ar.prototype.classifyToolbarItems = function() {
      var lr = this, ur = 0, dr = this.refs.el.clientWidth, fr = this.refs.el.querySelector("." + cls("toolbar-divider")), gr = fr ? getOuterWidth(fr) : 0, mr = [], vr = [], yr = !1;
      return this.initialItems.forEach(function(_r, kr) {
        var xr = [], Ar = [];
        _r.forEach(function(Er, Cr) {
          Er.hidden || (ur += lr.itemWidthMap[Er.name], ur > dr - INLINE_PADDING ? (yr || (lr.movePrevItemToDropdownToolbar(Cr, mr, xr, Ar), yr = !0), Ar.push(Er)) : xr.push(Er));
        }), xr.length && (setGroupState(xr), mr.push(xr)), Ar.length && (setGroupState(Ar), vr.push(Ar)), kr < lr.state.items.length - 1 && (ur += gr);
      }), { items: mr, dropdownItems: vr };
    }, ar.prototype.mounted = function() {
      this.props.previewStyle === "tab" && this.props.eventEmitter.emit("changePreviewTabWrite", !0), this.setState(this.classifyToolbarItems()), this.appendTooltipToRoot(), this.resizeObserver.observe(this.refs.el);
    }, ar.prototype.updated = function(lr) {
      var ur = this.props, dr = ur.editorType, fr = ur.previewStyle, gr = ur.eventEmitter, mr = fr !== lr.previewStyle, vr = dr !== lr.editorType;
      if (mr || vr) {
        toggleScrollSync(this.initialItems, this.hiddenScrollSync());
        var yr = this.classifyToolbarItems();
        (mr || fr === "tab" && dr === "markdown") && (gr.emit("changePreviewTabWrite"), yr.activeTab = "write"), this.setState(yr);
      }
    }, ar.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize), this.resizeObserver.disconnect(), removeNode$1(this.tooltipRef.current);
    }, ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.previewStyle, fr = ur.eventEmitter, gr = ur.editorType, mr = this.state, vr = mr.popupInfo, yr = mr.showPopup, _r = mr.activeTab, kr = mr.items, xr = mr.dropdownItems, Ar = {
        eventEmitter: fr,
        tooltipRef: this.tooltipRef,
        disabled: gr === "markdown" && dr === "tab" && _r === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      }, Er = dr === "tab" ? { borderTopLeftRadius: 0 } : null;
      return html$3(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([`
      <div class="`, `">
        <div
          class="`, `"
          style="display: `, `"
        >
          <`, " tabs=", " activeTab=", " onClick=", ` />
        </div>
        <div
          class="`, `"
          ref=`, `
          style=`, `
        >
          `, `
          <`, `
            item=`, `
            items=`, `
            ...`, `
          />
        </div>
        <`, `
          info=`, `
          show=`, `
          eventEmitter=`, `
          hidePopup=`, `
          execCommand=`, `
        />
      </div>
    `], [
        `
      <div class="`,
        `">
        <div
          class="`,
        `"
          style="display: `,
        `"
        >
          <`,
        " tabs=",
        " activeTab=",
        " onClick=",
        ` />
        </div>
        <div
          class="`,
        `"
          ref=`,
        `
          style=`,
        `
        >
          `,
        `
          <`,
        `
            item=`,
        `
            items=`,
        `
            ...`,
        `
          />
        </div>
        <`,
        `
          info=`,
        `
          show=`,
        `
          eventEmitter=`,
        `
          hidePopup=`,
        `
          execCommand=`,
        `
        />
      </div>
    `
      ])), cls("toolbar"), cls("md-tab-container"), gr === "wysiwyg" || dr === "vertical" ? "none" : "block", Tabs, this.tabs, _r, this.toggleTab, cls("defaultUI-toolbar"), function(Cr) {
        return lr.refs.el = Cr;
      }, Er, kr.map(function(Cr, Tr) {
        var Sr;
        return html$3(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `], [`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `])), ToolbarGroup, Cr, Tr === kr.length - 1 || ((Sr = kr[Tr + 1]) === null || Sr === void 0 ? void 0 : Sr.hidden), lr.setItemWidth, Ar);
      }), DropdownToolbarButton, createToolbarItemInfo("more"), xr, Ar, Popup, vr, yr, fr, this.hidePopup, this.execCommand);
    }, ar;
  }(Component)
), templateObject_1$3, templateObject_2$2, ContextMenu = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      return ur.handleClickDocument = function(dr) {
        closest(dr.target, "." + cls("context-menu")) || ur.setState({ pos: null });
      }, ur.state = {
        pos: null,
        menuGroups: []
      }, ur.addEvent(), ur;
    }
    return ar.prototype.addEvent = function() {
      var lr = this;
      this.props.eventEmitter.listen("contextmenu", function(ur) {
        var dr = ur.pos, fr = ur.menuGroups;
        lr.setState({ pos: dr, menuGroups: fr });
      });
    }, ar.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, ar.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, ar.prototype.getMenuGroupElements = function() {
      var lr = this, ur = this.state, dr = ur.pos, fr = ur.menuGroups;
      return dr ? fr.reduce(function(gr, mr) {
        var vr = [];
        return mr.forEach(function(yr) {
          var _r = yr.label, kr = yr.className, xr = kr === void 0 ? !1 : kr, Ar = yr.disabled, Er = yr.onClick, Cr = function() {
            Ar || (Er(), lr.setState({ pos: null }));
          };
          vr.push(html$3(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `], [`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `])), Cr, Ar ? " disabled" : "", xr, _r));
        }), gr.push(html$3(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([`<ul class="menu-group">
              `, `
            </ul>`], [`<ul class="menu-group">
              `, `
            </ul>`])), vr)), gr;
      }, []) : [];
    }, ar.prototype.render = function() {
      var lr = __assign$1({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return html$3(templateObject_3 || (templateObject_3 = __makeTemplateObject(['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`], ['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`])), cls("context-menu"), lr, this.getMenuGroupElements());
    }, ar;
  }(Component)
), templateObject_1$2, templateObject_2$1, templateObject_3, Layout = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur = cr.call(this, lr) || this;
      ur.changeMode = function(gr) {
        gr !== ur.state.editorType && ur.setState({ editorType: gr });
      }, ur.changePreviewStyle = function(gr) {
        gr !== ur.state.previewStyle && ur.setState({ previewStyle: gr });
      }, ur.hide = function() {
        ur.setState({ hide: !0 });
      }, ur.show = function() {
        ur.setState({ hide: !1 });
      };
      var dr = lr.editorType, fr = lr.previewStyle;
      return ur.state = {
        editorType: dr,
        previewStyle: fr,
        hide: !1
      }, ur.addEvent(), ur;
    }
    return ar.prototype.mounted = function() {
      var lr = this.props.slots, ur = lr.wwEditor, dr = lr.mdEditor, fr = lr.mdPreview;
      this.refs.wwContainer.appendChild(ur), this.refs.mdContainer.insertAdjacentElement("afterbegin", dr), this.refs.mdContainer.appendChild(fr);
    }, ar.prototype.insertToolbarItem = function(lr, ur) {
      this.toolbar.insertToolbarItem(lr, ur);
    }, ar.prototype.removeToolbarItem = function(lr) {
      this.toolbar.removeToolbarItem(lr);
    }, ar.prototype.render = function() {
      var lr = this, ur = this.props, dr = ur.eventEmitter, fr = ur.hideModeSwitch, gr = ur.toolbarItems, mr = ur.theme, vr = this.state, yr = vr.hide, _r = vr.previewStyle, kr = vr.editorType, xr = yr ? " hidden" : "", Ar = cls(kr === "markdown" ? "md-mode" : "ww-mode"), Er = cls("md") + "-" + _r + "-style", Cr = cls([mr !== "light", mr + " "]);
      return html$3(templateObject_2 || (templateObject_2 = __makeTemplateObject([`
      <div
        class="`, "", "", `"
        ref=`, `
      >
        <`, `
          ref=`, `
          eventEmitter=`, `
          previewStyle=`, `
          toolbarItems=`, `
          editorType=`, `
        />
        <div
          class="`, " ", `"
          ref=`, `
        >
          <div class="`, `">
            <div
              class="`, " ", `"
              ref=`, `
            >
              <div class="`, `"></div>
            </div>
            <div
              class="`, `"
              ref=`, `
            />
          </div>
        </div>
        `, `
        <`, " eventEmitter=", ` />
      </div>
    `], [
        `
      <div
        class="`,
        "",
        "",
        `"
        ref=`,
        `
      >
        <`,
        `
          ref=`,
        `
          eventEmitter=`,
        `
          previewStyle=`,
        `
          toolbarItems=`,
        `
          editorType=`,
        `
        />
        <div
          class="`,
        " ",
        `"
          ref=`,
        `
        >
          <div class="`,
        `">
            <div
              class="`,
        " ",
        `"
              ref=`,
        `
            >
              <div class="`,
        `"></div>
            </div>
            <div
              class="`,
        `"
              ref=`,
        `
            />
          </div>
        </div>
        `,
        `
        <`,
        " eventEmitter=",
        ` />
      </div>
    `
      ])), Cr, cls("defaultUI"), xr, function(Tr) {
        return lr.refs.el = Tr;
      }, Toolbar, function(Tr) {
        return lr.toolbar = Tr;
      }, dr, _r, gr, kr, cls("main"), Ar, function(Tr) {
        return lr.refs.editorSection = Tr;
      }, cls("main-container"), cls("md-container"), Er, function(Tr) {
        return lr.refs.mdContainer = Tr;
      }, cls("md-splitter"), cls("ww-container"), function(Tr) {
        return lr.refs.wwContainer = Tr;
      }, !fr && html$3(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, dr, kr), ContextMenu, dr);
    }, ar.prototype.addEvent = function() {
      var lr = this.props.eventEmitter;
      lr.listen("hide", this.hide), lr.listen("show", this.show), lr.listen("changeMode", this.changeMode), lr.listen("changePreviewStyle", this.changePreviewStyle);
    }, ar;
  }(Component)
), templateObject_1$1, templateObject_2, ToastUIEditor = (
  /** @class */
  function(cr) {
    __extends$1(ar, cr);
    function ar(lr) {
      var ur, dr = cr.call(this, lr) || this, fr, gr = render(dr.options.el, html$3(templateObject_1 || (templateObject_1 = __makeTemplateObject([`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `], [`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `])), Layout, function(mr) {
        return fr = mr;
      }, dr.eventEmitter, dr.getEditorElements(), dr.options.hideModeSwitch, dr.options.toolbarItems, dr.options.previewStyle, dr.options.initialEditType, dr.options.theme));
      return dr.setMinHeight(dr.options.minHeight), dr.setHeight(dr.options.height), dr.defaultUI = {
        insertToolbarItem: fr.insertToolbarItem.bind(fr),
        removeToolbarItem: fr.removeToolbarItem.bind(fr),
        destroy: gr
      }, (ur = dr.pluginInfo.toolbarItems) === null || ur === void 0 || ur.forEach(function(mr) {
        var vr = mr.groupIndex, yr = mr.itemIndex, _r = mr.item;
        dr.defaultUI.insertToolbarItem({ groupIndex: vr, itemIndex: yr }, _r);
      }), dr.eventEmitter.emit("loadUI", dr), dr;
    }
    return ar.factory = function(lr) {
      return lr.viewer ? new ToastUIEditorViewer(lr) : new ar(lr);
    }, ar.prototype.insertToolbarItem = function(lr, ur) {
      this.defaultUI.insertToolbarItem(lr, ur);
    }, ar.prototype.removeToolbarItem = function(lr) {
      this.defaultUI.removeToolbarItem(lr);
    }, ar.prototype.destroy = function() {
      cr.prototype.destroy.call(this), this.defaultUI.destroy();
    }, ar;
  }(ToastUIEditorCore)
), templateObject_1;
ToastUIEditorCore.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});
const css = `/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */.ProseMirror{position:relative;word-wrap:break-word;white-space:pre-wrap;white-space:break-spaces;-webkit-font-variant-ligatures:none;font-variant-ligatures:none;-webkit-font-feature-settings:"liga" 0;font-feature-settings:"liga" 0}.ProseMirror pre{white-space:pre-wrap}.ProseMirror li{position:relative}.ProseMirror-hideselection *::selection{background:transparent}.ProseMirror-hideselection *::-moz-selection{background:transparent}.ProseMirror-hideselection{caret-color:transparent}.ProseMirror-selectednode{outline:2px solid #8cf}li.ProseMirror-selectednode{outline:none}li.ProseMirror-selectednode:after{content:"";position:absolute;inset:-2px -2px -2px -32px;border:2px solid #8cf;pointer-events:none}img.ProseMirror-separator{display:inline!important;border:none!important;margin:0!important}.auto-height,.auto-height .toastui-editor-defaultUI{height:auto}.auto-height .toastui-editor-md-container{position:relative}:not(.auto-height)>.toastui-editor-defaultUI,:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-direction:column;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}:not(.auto-height)>.toastui-editor-defaultUI>.toastui-editor-main{-ms-flex:1;-webkit-box-flex:1;flex:1}.toastui-editor-md-container:after,.toastui-editor-defaultUI-toolbar:after{content:"";display:block;height:0;clear:both}.toastui-editor-main{min-height:0px;position:relative;height:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-md-container{display:none;overflow:hidden;height:100%}.toastui-editor-md-container .toastui-editor{line-height:1.5;position:relative}.toastui-editor-md-container .toastui-editor,.toastui-editor-md-container .toastui-editor-md-preview{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;height:inherit}.toastui-editor-md-container .toastui-editor-md-preview{overflow:auto;padding:0 25px;height:100%}.toastui-editor-md-container .toastui-editor-md-preview>p:first-child{margin-top:0!important}.toastui-editor-md-container .toastui-editor-md-preview .toastui-editor-contents{padding-top:8px}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor,.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-md-preview{width:100%;display:none}.toastui-editor-main .toastui-editor-md-tab-style>.active{display:block}.toastui-editor-main .toastui-editor-md-vertical-style>.toastui-editor-tabs{display:none}.toastui-editor-main .toastui-editor-md-tab-style>.toastui-editor-tabs{display:block}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor,.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-preview{width:50%}.toastui-editor-main .toastui-editor-md-splitter{display:none;height:100%;width:1px;background-color:#ebedf2;position:absolute;left:50%}.toastui-editor-main .toastui-editor-md-vertical-style .toastui-editor-md-splitter{display:block}.toastui-editor-ww-container{display:none;overflow:hidden;height:inherit;background-color:#fff}.auto-height .toastui-editor-main-container{position:relative}.toastui-editor-main-container{position:absolute;line-height:1;color:#222;width:100%;height:inherit}.toastui-editor-ww-container>.toastui-editor{height:inherit;position:relative;width:100%}.toastui-editor-ww-container .toastui-editor-contents{overflow:auto;-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:16px 25px 0;height:inherit}.toastui-editor-ww-container .toastui-editor-contents p{margin:0}.toastui-editor-md-mode .toastui-editor-md-container,.toastui-editor-ww-mode .toastui-editor-ww-container{display:block;z-index:20}.toastui-editor-md-mode .toastui-editor-md-vertical-style{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-main.hidden,.toastui-editor-defaultUI.hidden{display:none}.toastui-editor-defaultUI .ProseMirror{padding:18px 25px}.toastui-editor-defaultUI{position:relative;border:1px solid #dadde6;height:100%;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,,Nanum Barun Gothic,,Malgun Gothic,sans-serif;border-radius:4px}.toastui-editor-defaultUI button{color:#333;height:28px;font-size:13px;cursor:pointer;border:none;border-radius:2px}.toastui-editor-defaultUI .toastui-editor-ok-button{min-width:63px;height:32px;background-color:#00a9ff;color:#fff;outline-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-ok-button:hover{background-color:#009bf2}.toastui-editor-defaultUI .toastui-editor-close-button{min-width:63px;height:32px;background-color:#f7f9fc;border:1px solid #dadde6;margin-right:5px;outline-color:#cbcfdb}.toastui-editor-defaultUI .toastui-editor-close-button:hover{border-color:#cbcfdb}.toastui-editor-mode-switch{background-color:#fff;border-top:1px solid #dadde6;font-size:12px;text-align:right;height:28px;padding-right:10px;border-radius:0 0 3px 3px}.toastui-editor-mode-switch .tab-item{display:inline-block;width:96px;height:24px;line-height:24px;text-align:center;background:#f7f9fc;color:#969aa5;margin-top:-1px;margin-right:-1px;cursor:pointer;border:1px solid #dadde6;border-radius:0 0 4px 4px;font-weight:500;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-mode-switch .tab-item.active{border-top:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-defaultUI .toastui-editor-md-tab-container{float:left;height:45px;font-size:13px;background:#f7f9fc;border-bottom:1px solid #ebedf2;border-top-left-radius:3px}.toastui-editor-md-tab-container .toastui-editor-tabs{margin-left:15px;height:100%}.toastui-editor-md-tab-container .tab-item{display:inline-block;width:70px;height:33px;line-height:33px;font-size:12px;font-weight:500;text-align:center;background:#eaedf1;color:#969aa5;cursor:pointer;border:1px solid #dadde6;border-radius:4px 4px 0 0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:13px}.toastui-editor-md-tab-container .tab-item.active{border-bottom:1px solid #fff;background-color:#fff;color:#555}.toastui-editor-md-tab-container .tab-item:last-child{margin-left:-1px}.toastui-editor-defaultUI-toolbar{display:-ms-flexbox;display:-webkit-box;display:flex;padding:0 25px;height:45px;background-color:#f7f9fc;border-bottom:1px solid #ebedf2;border-radius:3px 3px 0 0}.toastui-editor-toolbar{height:46px;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-toolbar-divider{display:inline-block;width:1px;height:18px;background-color:#e1e3e9;margin:14px 12px}.toastui-editor-toolbar-group{display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-defaultUI-toolbar button{-webkit-box-sizing:border-box;box-sizing:border-box;cursor:pointer;width:32px;height:32px;padding:0;border-radius:3px;margin:7px 5px;border:1px solid #f7f9fc}.toastui-editor-defaultUI-toolbar button:not(:disabled):hover{border:1px solid #e4e7ee;background-color:#fff}.toastui-editor-defaultUI-toolbar .scroll-sync{display:inline-block;position:relative;width:70px;height:10px;text-align:center;line-height:10px;color:#81858f;cursor:pointer}.toastui-editor-defaultUI-toolbar .scroll-sync:before{content:"Scroll";position:absolute;left:0;font-size:14px}.toastui-editor-defaultUI-toolbar .scroll-sync.active:before{color:#00a9ff}.toastui-editor-defaultUI-toolbar .scroll-sync input{opacity:0;width:0;height:0}.toastui-editor-defaultUI-toolbar .switch{position:absolute;inset:0 0 0 45px;background-color:#d6d8de;-webkit-transition:.4s;transition:.4s;border-radius:50px}.toastui-editor-defaultUI-toolbar input:checked+.switch{background-color:#acddfa}.toastui-editor-defaultUI-toolbar .switch:before{position:absolute;content:"";height:14px;width:14px;left:0;bottom:-2px;background-color:#94979f;-webkit-transition:.4s;transition:.4s;border-radius:50%}.toastui-editor-defaultUI-toolbar input:checked+.switch:before{background-color:#00a9ff;-webkit-transform:translateX(12px);transform:translate(12px)}.toastui-editor-dropdown-toolbar .scroll-sync{margin:0 5px}.toastui-editor-dropdown-toolbar{position:absolute;height:46px;z-index:30;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;background-color:#f7f9fc;display:-ms-flexbox;display:-webkit-box;display:flex}.toastui-editor-toolbar-item-wrapper{margin:7px 5px;height:32px;line-height:32px}.toastui-editor-popup{width:400px;margin-right:auto;background:#fff;z-index:30;position:absolute;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6}.toastui-editor-popup-body{padding:15px;font-size:12px}.toastui-editor-popup-body label{font-weight:600;color:#555;display:block;margin:20px 0 5px}.toastui-editor-popup-body .toastui-editor-button-container{text-align:right;margin-top:20px}.toastui-editor-popup-body input[type=text]{width:calc(100% - 26px);height:30px;padding:0 12px;border-radius:2px;border:1px solid #e1e3e9;color:#333}.toastui-editor-popup-body input[type=text]:focus{outline:1px solid #00a9ff;border-color:transparent}.toastui-editor-popup-body input[type=text].disabled{background-color:#f7f9fc;border-color:#e1e3e9;color:#969aa5}.toastui-editor-popup-body input[type=file]{opacity:0;border:none;width:1px;height:1px;position:absolute;top:0;left:0}.toastui-editor-popup-body input.wrong,.toastui-editor-popup-body span.wrong{border-color:#fa2828}.toastui-editor-popup-add-link .toastui-editor-popup-body,.toastui-editor-popup-add-image .toastui-editor-popup-body{padding:0 20px 20px}.toastui-editor-popup-add-image .toastui-editor-tabs{margin:5px 0 10px}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item{display:inline-block;width:60px;height:40px;line-height:40px;border-bottom:1px solid #dadde6;color:#333;font-size:13px;font-weight:600;text-align:center;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item:hover{border-bottom:1px solid #cbcfdb}.toastui-editor-popup-add-image .toastui-editor-tabs .tab-item.active{color:#00a9ff;border-bottom:2px solid #00a9ff}.toastui-editor-popup-add-image .toastui-editor-file-name{width:58%;display:inline-block;border-radius:2px;border:1px solid #e1e3e9;color:#dadde6;height:30px;line-height:30px;padding:0 12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:pointer}.toastui-editor-popup-add-image .toastui-editor-file-name.has-file{color:#333}.toastui-editor-popup-add-image .toastui-editor-file-select-button{width:33%;margin-left:5px;height:32px;border-radius:2px;border:1px solid #dadde6;background-color:#f7f9fc;vertical-align:top}.toastui-editor-popup-add-image .toastui-editor-file-select-button:hover{border-color:#cbcfdb}.toastui-editor-popup-add-table{width:auto}.toastui-editor-popup-add-table .toastui-editor-table-selection{position:relative}.toastui-editor-popup-add-table .toastui-editor-table-cell{display:table-cell;width:20px;height:20px;border:1px solid #e1e3e9;background:#fff;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-popup-add-table .toastui-editor-table-cell.header{background:#f7f9fc}.toastui-editor-popup-add-table .toastui-editor-table-row{display:table-row}.toastui-editor-popup-add-table .toastui-editor-table{display:table;border-collapse:collapse}.toastui-editor-popup-add-table .toastui-editor-table-selection-layer{position:absolute;top:0;left:0;border:1px solid #00a9ff;background:rgba(0,169,255,.1);z-index:30}.toastui-editor-popup-add-table .toastui-editor-table-description{margin:5px 0 0;text-align:center;color:#333}.toastui-editor-popup-add-heading{width:auto}.toastui-editor-popup-add-heading .toastui-editor-popup-body{padding:0}.toastui-editor-popup-add-heading h1,.toastui-editor-popup-add-heading h2,.toastui-editor-popup-add-heading h3,.toastui-editor-popup-add-heading h4,.toastui-editor-popup-add-heading h5,.toastui-editor-popup-add-heading h6,.toastui-editor-popup-add-heading ul,.toastui-editor-popup-add-heading p{padding:0;margin:0}.toastui-editor-popup-add-heading ul{padding:5px 0;list-style:none}.toastui-editor-popup-add-heading ul li{padding:4px 12px;cursor:pointer}.toastui-editor-popup-add-heading ul li:hover{background-color:#dff4ff}.toastui-editor-popup-add-heading h1{font-size:24px}.toastui-editor-popup-add-heading h2{font-size:22px}.toastui-editor-popup-add-heading h3{font-size:20px}.toastui-editor-popup-add-heading h4{font-size:18px}.toastui-editor-popup-add-heading h5{font-size:16px}.toastui-editor-popup-add-heading h6{font-size:14px}.toastui-editor-context-menu{position:absolute;width:auto;min-width:197px;color:#333;border-radius:2px;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;border:1px solid #dadde6;z-index:30;padding:5px 0;background-color:#fff}.toastui-editor-context-menu .menu-group{list-style:none;border-bottom:1px solid #ebedf2;padding:0;margin:0;font-size:13px}.toastui-editor-context-menu .menu-group:last-child{border-bottom:none!important}.toastui-editor-context-menu .menu-item{height:32px;line-height:32px;padding:0 14px;cursor:pointer}.toastui-editor-context-menu span{display:inline-block}.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px;content:"";width:20px;height:20px;display:inline-block;vertical-align:middle;margin-right:10px}.toastui-editor-context-menu .add-row-up:before{background-position:3px -104px}.toastui-editor-context-menu .add-row-down:before{background-position:-19px -104px}.toastui-editor-context-menu .remove-row:before{background-position:-41px -104px}.toastui-editor-context-menu .add-column-left:before{background-position:-63px -104px}.toastui-editor-context-menu .add-column-right:before{background-position:-85px -104px}.toastui-editor-context-menu .remove-column:before{background-position:-111px -104px}.toastui-editor-context-menu .align-column-left:before{background-position:-129px -104px}.toastui-editor-context-menu .align-column-center:before{background-position:-151px -104px}.toastui-editor-context-menu .align-column-right:before{background-position:-173px -104px}.toastui-editor-context-menu .remove-table:before{background-position:-197px -104px}.toastui-editor-context-menu .disabled span:before{opacity:.3}.toastui-editor-context-menu li:not(.disabled):hover{background-color:#dff4ff}.toastui-editor-context-menu li.disabled{color:#c9ccd5}.toastui-editor-tooltip{position:absolute;background-color:#444;z-index:40;padding:4px 7px;font-size:12px;border-radius:3px;color:#fff;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,,Nanum Barun Gothic,,Malgun Gothic,sans-serif}.toastui-editor-tooltip .arrow{content:"";display:inline-block;width:10px;height:10px;background-color:#444;-webkit-transform:rotate(45deg);transform:rotate(45deg);position:absolute;top:-3px;left:6px;z-index:-1}.toastui-editor-toolbar-icons{background:url(data:image/png;base64,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) no-repeat;background-size:466px 146px}@media only screen and (-webkit-min-device-pixel-ratio: 2),only screen and (min-device-pixel-ratio: 2),only screen and (min-resolution: 192dpi),only screen and (min-resolution: 2dppx){.toastui-editor-toolbar-icons,.toastui-editor-context-menu span:before{background:url(data:image/png;base64,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P0A9dgflJJi2Szl5led4F57jlvpECs/6vuTjuhR3dAo961VP9UoRby5eaGBuxz2Zy/3pyiWBlJEiA/s5FHaEnU170tGmBChvV5O1/Zske9dQ3upqiLdbfuL3hTpvY+q8m3ELRkrj1xLs36Md8A17jhOutYwTnYufJw89tLmvbxmhJagIVEmgaoW0yvjlXQREQASakkA77LJL42wfGmdpGiktpZBagaFRfQqNsDNGSykNldFTUQ6+3ZQFWEJlRsA6pVmzZjML1sks0hoiosy9vMoqq2wVjg7VEMNQkHbLTzEI7tOqdCoeTd1nn7dK2tjwf2F5Gsro3cVhdS4CItCcBKSQNud9kVQiIAIikIqAjZLSQNu8lGeujZiyW8pvs7mHI6W2tb/tlF28jigvcRfSmLUpw+doZDQvxM0Xb40zpbLKiE03nWtLiOpVRp1A7ZYfl6+4yTPqo5hO4nndFPt4fi+OHTv2Qb5x/Y+4P9lFQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAQ6mYDfyZlX3kVABESgnQgc/WRhlf5F3j6Dvjdw6UT/mnbKm/IiAiIgAiIgAiLQngSkkLbnfVWuREAEOohA7+OFsc8v8w4peN43yfZGlnW/y9t/9kT/2g7CoKyKgAiIgAiIgAi0IIGeFpRZIouACIhA3QSOm1fY4A3f28MiWqXg/fyCyf7CuiMdhQiOmFc4YOEy7zsk/fZhyRe89ww7b8GTI+YXthv0vBO9gjcZ8TdoUBYWer43r8vzzpk1yb+vQWkqmVEmcPQjhY36+rzv0amzI6I0qqy5XC9kdGDumDHeSRdv5T/n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vaXiGC338PM8x9WSftjWO6CWsArTOAKhollR2UwjEc9wdYeNvhHCevQvqneamUs5jzhd3GlMemI2KtUTUyq89dBYDwAArSK8cWt+zbJmtNII6bA8tdAI6TC5wxP7rtbACm97tkR/K+ssVude9DBm+gqV+JM9a3q/rfW7Vklpya19CNCr94HCAFOk3LRd33u1u8vbhSlgLfWJFJ71famHrqt0Z6ivplBf17v2qFIymV1n07LtaITNJW+jus8B3NjU09sxzQZqmWVeETWcACNtV1PespspVUcOKG/XMLpUV0O83fITx3nEo4WNB1d4N+O2Rdw9yc7z+z1GRr/RrCOjSTInuTHq+3naNz3U4dcnXZebCLQDAeo+HSIgAiLQeQTaYZfdI+YV9qGhUrGR0moKqZVGlG2bxnzGaCmloTJ6Ksrotzvv6eisHFunNGvWHiHX64xyzl8eO8bbKhwdqlmUdstPMYjgqwH/9I6mQ/F4OhKYzTvi+F82kzjtksn+3SOuyEEERKApCUghbcrbIqFEQAREIB0BGyXF5+ZlfCdN2S3jvXku2UgpCveJNDxtp+xh64hylNKm/s1jaPYcjYzmSLnJoq5lplSGWVhIY2yuLSGqVxl1MrVbfly+4qZtXnT0Q96kPs/btKvgjUc5fbHH9x6cMdG39Ws6REAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERAACviiIgAiIgAgMJ7DPPvvshMuNoeueN9xww5zhPnQmAiIgAiIgAiIgAiKQBYGeLCJRHCIgAiLQTgR839++UCiMtzyZHUMKaTvd4AzzctBBB627bNmydxDl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UvksxkDZi5yw9xKm1xzi5RjlMLe10HTi3YPCeTZ1ZPD5F2TYieT/wnPzFPb+vr6+zTDdxmA2a0Yjo3aDdIiACIiACIhADgS6ysRpa5gadTQyrUblqSHp0GgyZTTYwCghwWBNqflJuNZop2rucTV+S+Wjmjiq8VsqvbzdU8tIebDNVtxuusEGRjTArcPi2piQ+9Eg3yN2LqsI1EMgdflMmwhK4ADldgr+o3JLXRaN+DMD5GyU1prXQjMKfarF4eQhbp/fppy/FzOujM4kHU3TdaBkioAIiIAIiEDGBEoqpLaGibQyb2QkyD8qa8Ro7Ng60cX2C+0JojW/E0qF7aAbrRslL2faLyb57qGfmFPjrVWUp0zKQ6PTy5toFfmx0ZzbkMfKdqCMWqMdt+LG/XN8f/E3dch9axjWpgW33QGvtqgfKtyYzO5hNeWzgkzDLlu55XcEv1eHXchgLTRxFsJnYwfsd/GL775rQ7j2fHwGpfgorg1bX1oki05FQAREQAREQAREoHMJMBp2s02Rsx/2MxwJs8fctcuuA9MhJpuxbMrvU8XZtZEfysZetkau+JrORaDZCFBex1OP/drVZUXmNfGRzHpl57lYm867iTw32y5atGi9euNTeBEQAREQAREQgXQEgo+Dp/MqX81IgAbUm2iUXYBs8+nJvyguIw2sYzifRO/+cYwEBN8AiV+XXQREQASalYApo9Rh5dZCm+jX2rTe+Ohms+ZHcomACIiACIiACIiACIiACIiACLQIAUZDvx4fEaXz7SwbEcXtmrg7SuueLZIliSkCIiACIiACIpBAoOQa0gS/chIBERABERCBhhBg1LMRa6EbkhclIgIiIAIiIAIiIAIiIAIiIAIi0GIEtBa6xW6YxBUBERABERABERABERABERABERABERABERABERCBViHw/wHIAHUN1iL6RwAAAABJRU5ErkJggg==) no-repeat;background-size:466px 146px}}.toastui-editor-toolbar-icons{background-position-y:3px}.toastui-editor-toolbar-icons:disabled{opacity:.3}.toastui-editor-toolbar-icons.heading{background-position-x:3px}.toastui-editor-toolbar-icons.bold{background-position-x:-23px}.toastui-editor-toolbar-icons.italic{background-position-x:-49px}.toastui-editor-toolbar-icons.strike{background-position-x:-75px}.toastui-editor-toolbar-icons.hrline{background-position-x:-101px}.toastui-editor-toolbar-icons.quote{background-position-x:-127px}.toastui-editor-toolbar-icons.bullet-list{background-position-x:-153px}.toastui-editor-toolbar-icons.ordered-list{background-position-x:-179px}.toastui-editor-toolbar-icons.task-list{background-position-x:-205px}.toastui-editor-toolbar-icons.indent{background-position-x:-231px}.toastui-editor-toolbar-icons.outdent{background-position-x:-257px}.toastui-editor-toolbar-icons.table{background-position-x:-283px}.toastui-editor-toolbar-icons.image{background-position-x:-309px}.toastui-editor-toolbar-icons.link{background-position-x:-334px}.toastui-editor-toolbar-icons.code{background-position-x:-361px}.toastui-editor-toolbar-icons.codeblock{background-position-x:-388px}.toastui-editor-toolbar-icons.more{background-position-x:-412px}.toastui-editor-toolbar-icons:not(:disabled).active{background-position-y:-23px}@media only screen and (max-width: 480px){.toastui-editor-popup{max-width:300px;margin-left:-150px}.toastui-editor-dropdown-toolbar{max-width:none}}.ProseMirror{font-family:Open Sans,Helvetica Neue,Helvetica,Arial,,Nanum Barun Gothic,,Malgun Gothic,sans-serif;color:#222;font-size:13px;overflow-y:auto;overflow-X:hidden;height:calc(100% - 36px)}.ProseMirror .placeholder{color:#999}.ProseMirror:focus{outline:none}.ProseMirror-selectednode{outline:none}table.ProseMirror-selectednode,.html-block.ProseMirror-selectednode{border-radius:2px;outline:2px solid #00a9ff}.toastui-editor-contents{margin:0;padding:0;font-size:13px;font-family:Open Sans,Helvetica Neue,Helvetica,Arial,,Nanum Barun Gothic,,Malgun Gothic,sans-serif;z-index:20}.toastui-editor-contents *:not(table){line-height:160%;-webkit-box-sizing:content-box;box-sizing:content-box}.toastui-editor-contents i,.toastui-editor-contents cite,.toastui-editor-contents em,.toastui-editor-contents var,.toastui-editor-contents address,.toastui-editor-contents dfn{font-style:italic}.toastui-editor-contents strong{font-weight:700}.toastui-editor-contents p{margin:10px 0;color:#222}.toastui-editor-contents>h1:first-of-type,.toastui-editor-contents>div>div:first-of-type h1{margin-top:14px}.toastui-editor-contents h1,.toastui-editor-contents h2,.toastui-editor-contents h3,.toastui-editor-contents h4,.toastui-editor-contents h5,.toastui-editor-contents h6{font-weight:700;color:#222}.toastui-editor-contents h1{font-size:24px;line-height:28px;border-bottom:3px double #999;margin:52px 0 15px;padding-bottom:7px}.toastui-editor-contents h2{font-size:22px;line-height:23px;border-bottom:1px solid #dbdbdb;margin:20px 0 13px;padding-bottom:7px}.toastui-editor-contents h3{font-size:20px;margin:18px 0 2px}.toastui-editor-contents h4{font-size:18px;margin:10px 0 2px}.toastui-editor-contents h3,.toastui-editor-contents h4{line-height:18px}.toastui-editor-contents h5{font-size:16px}.toastui-editor-contents h6{font-size:14px}.toastui-editor-contents h5,.toastui-editor-contents h6{line-height:17px;margin:9px 0 -4px}.toastui-editor-contents del{color:#999}.toastui-editor-contents blockquote{margin:14px 0;border-left:4px solid #e5e5e5;padding:0 16px;color:#999}.toastui-editor-contents blockquote p,.toastui-editor-contents blockquote ul,.toastui-editor-contents blockquote ol{color:#999}.toastui-editor-contents blockquote>:first-child{margin-top:0}.toastui-editor-contents blockquote>:last-child{margin-bottom:0}.toastui-editor-contents pre,.toastui-editor-contents code{font-family:Consolas,Courier,Apple SD  Neo,-apple-system,Lucida Grande,Apple SD Gothic Neo, ,Malgun Gothic,Segoe UI,,dotum,sans-serif;border:0;border-radius:0}.toastui-editor-contents pre{margin:2px 0 8px;padding:18px;background-color:#f4f7f8}.toastui-editor-contents code{color:#c1798b;background-color:#f9f2f4;padding:2px 3px;letter-spacing:-.3px;border-radius:2px}.toastui-editor-contents pre code{padding:0;color:inherit;white-space:pre-wrap;background-color:transparent}.toastui-editor-contents img{margin:4px 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box;vertical-align:top;max-width:100%}.toastui-editor-contents table{border:1px solid rgba(0,0,0,.1);margin:12px 0 14px;color:#222;width:auto;border-collapse:collapse;-webkit-box-sizing:border-box;box-sizing:border-box}.toastui-editor-contents table th,.toastui-editor-contents table td{border:1px solid rgba(0,0,0,.1);padding:5px 14px 5px 12px;height:32px}.toastui-editor-contents table th{background-color:#555;font-weight:300;color:#fff;padding-top:6px}.toastui-editor-contents th p{margin:0;color:#fff}.toastui-editor-contents td p{margin:0;padding:0 2px}.toastui-editor-contents td.toastui-editor-cell-selected{background-color:#d8dfec}.toastui-editor-contents th.toastui-editor-cell-selected{background-color:#908f8f}.toastui-editor-contents ul,.toastui-editor-contents menu,.toastui-editor-contents ol,.toastui-editor-contents dir{display:block;list-style-type:none;padding-left:24px;margin:6px 0 10px;color:#222}.toastui-editor-contents ol{list-style-type:none;counter-reset:li}.toastui-editor-contents ol>li{counter-increment:li}.toastui-editor-contents ul>li:before,.toastui-editor-contents ol>li:before{display:inline-block;position:absolute}.toastui-editor-contents ul>li:before{content:"";margin-top:6px;margin-left:-17px;width:5px;height:5px;border-radius:50%;background-color:#ccc}.toastui-editor-contents ol>li:before{content:"." counter(li);margin-left:-28px;width:24px;text-align:right;direction:rtl;color:#aaa}.toastui-editor-contents ul ul,.toastui-editor-contents ul ol,.toastui-editor-contents ol ol,.toastui-editor-contents ol ul{margin-top:0!important;margin-bottom:0!important}.toastui-editor-contents ul li,.toastui-editor-contents ol li{position:relative}.toastui-editor-contents ul p,.toastui-editor-contents ol p{margin:0}.toastui-editor-contents hr{border-top:1px solid #eee;margin:16px 0}.toastui-editor-contents a{text-decoration:underline;color:#4b96e6}.toastui-editor-contents a:hover{color:#1f70de}.toastui-editor-contents .image-link{position:relative}.toastui-editor-contents .image-link:hover:before{content:"";position:absolute;width:30px;height:30px;right:0;border-radius:50%;border:1px solid #c9ccd5;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBzdHJva2U9IiM1NTUiIHN0cm9rZS13aWR0aD0iMS41Ij4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy42NjUgMTUuMDdsLTEuODE5LS4wMDJjLTEuNDg2IDAtMi42OTItMS4yMjgtMi42OTItMi43NDR2LS4xOTJjMC0xLjUxNSAxLjIwNi0yLjc0NCAyLjY5Mi0yLjc0NGgzLjg0NmMxLjQ4NyAwIDIuNjkyIDEuMjI5IDIuNjkyIDIuNzQ0di4xOTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAwIC00NTgxKSB0cmFuc2xhdGUoOTk1IDQ1NzYpIHRyYW5zbGF0ZSg1IDUpIHNjYWxlKDEgLTEpIHJvdGF0ZSg0NSAzNy4yOTMgMCkiLz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzI2IDQuOTM0bDEuODIyLjAwMmMxLjQ4NyAwIDIuNjkzIDEuMjI4IDIuNjkzIDIuNzQ0di4xOTJjMCAxLjUxNS0xLjIwNiAyLjc0NC0yLjY5MyAyLjc0NGgtMy44NDVjLTEuNDg3IDAtMi42OTItMS4yMjktMi42OTItMi43NDRWNy42OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMDAgLTQ1ODEpIHRyYW5zbGF0ZSg5OTUgNDU3NikgdHJhbnNsYXRlKDUgNSkgc2NhbGUoMSAtMSkgcm90YXRlKDQ1IDMwLjk5NiAwKSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K) no-repeat;background-position:center;-webkit-box-shadow:0 2px 4px 0 rgba(0,0,0,.08);box-shadow:0 2px 4px #00000014;cursor:pointer}.toastui-editor-contents .task-list-item{border:0;list-style:none;padding-left:24px;margin-left:-24px}.toastui-editor-contents .task-list-item:before{background-repeat:no-repeat;background-size:18px 18px;background-position:center;content:"";margin-left:0;margin-top:0;border-radius:2px;height:18px;width:18px;position:absolute;left:0;top:1px;cursor:pointer;background:transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQ0NDIj4KICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAzMCAtMjk2KSB0cmFuc2xhdGUoNzg4IDE5MikgdHJhbnNsYXRlKDI0MiAxMDQpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD0iMTciIGhlaWdodD0iMTciIHg9Ii41IiB5PSIuNSIgcng9IjIiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==)}.toastui-editor-contents .task-list-item.checked:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgZmlsbD0iIzRCOTZFNiI+CiAgICAgICAgICAgIDxnPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2IDBjMS4xMDUgMCAyIC44OTUgMiAydjE0YzAgMS4xMDUtLjg5NSAyLTIgMkgyYy0xLjEwNSAwLTItLjg5NS0yLTJWMkMwIC44OTUuODk1IDAgMiAwaDE0em0tMS43OTMgNS4yOTNjLS4zOS0uMzktMS4wMjQtLjM5LTEuNDE0IDBMNy41IDEwLjU4NSA1LjIwNyA4LjI5M2wtLjA5NC0uMDgzYy0uMzkyLS4zMDUtLjk2LS4yNzgtMS4zMi4wODMtLjM5LjM5LS4zOSAxLjAyNCAwIDEuNDE0bDMgMyAuMDk0LjA4M2MuMzkyLjMwNS45Ni4yNzggMS4zMi0uMDgzbDYtNiAuMDgzLS4wOTRjLjMwNS0uMzkyLjI3OC0uOTYtLjA4My0xLjMyeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTAgLTI5NikgdHJhbnNsYXRlKDc4OCAxOTIpIHRyYW5zbGF0ZSgyNjIgMTA0KSIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4K)}.toastui-editor-custom-block .toastui-editor-custom-block-editor{background:#f9f7fd;color:#452d6b;border:solid 1px #dbd4ea}.toastui-editor-custom-block .toastui-editor-custom-block-view{position:relative;padding:9px 13px 8px 12px}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view{border:solid 1px #dbd4ea;border-radius:2px}.toastui-editor-custom-block .toastui-editor-custom-block-view .tool{position:absolute;right:10px;top:7px;display:none}.toastui-editor-custom-block.ProseMirror-selectednode .toastui-editor-custom-block-view .tool{display:block}.toastui-editor-custom-block-view button{vertical-align:middle;width:15px;height:15px;margin-left:8px;padding:3px;border:solid 1px #cccccc;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:center;background-size:30px 30px}.toastui-editor-custom-block-view .info{font-size:13px;font-weight:700;color:#5200d0;vertical-align:middle}.toastui-editor-contents .toastui-editor-ww-code-block{position:relative}.toastui-editor-contents .toastui-editor-ww-code-block:after{content:attr(data-language);position:absolute;display:inline-block;top:10px;right:10px;height:24px;padding:3px 35px 0 10px;font-weight:700;font-size:13px;color:#333;background:#e5e9ea url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuugiOydtOyWtF8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwIDMwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6IzU1NTU1NTt9Cjwvc3R5bGU+CjxnPgoJPGc+CgkJPGc+CgkJCTxnPgoJCQkJPGc+CgkJCQkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE1LjUsMTIuNWwyLDJMMTIsMjBoLTJ2LTJMMTUuNSwxMi41eiBNMTgsMTBsMiwybC0xLjUsMS41bC0yLTJMMTgsMTB6Ii8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==) no-repeat;background-position:right;border-radius:2px;background-size:30px 30px;cursor:pointer}.toastui-editor-ww-code-block-language{position:fixed;display:inline-block;width:100px;height:27px;right:35px;border:1px solid #ccc;border-radius:2px;background-color:#fff;z-index:30}.toastui-editor-ww-code-block-language input{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;padding:0 10px;height:100%;width:100%;background-color:transparent;border:none;outline:none}.toastui-editor-contents-placeholder:before{content:attr(data-placeholder);color:gray;line-height:160%;position:absolute}.toastui-editor-md-preview .toastui-editor-contents h1{min-height:28px}.toastui-editor-md-preview .toastui-editor-contents h2{min-height:23px}.toastui-editor-md-preview .toastui-editor-contents blockquote{min-height:20px}.toastui-editor-md-preview .toastui-editor-contents li{min-height:22px}.toastui-editor-pseudo-clipboard{position:fixed;opacity:0;width:0;height:0;left:-1000px;top:-1000px;z-index:-1}.toastui-editor-contents .toastui-editor-md-preview-highlight{position:relative;z-index:0}.toastui-editor-contents .toastui-editor-md-preview-highlight:after{content:"";background-color:#fff58380;border-radius:4px;z-index:-1;position:absolute;inset:-4px}.toastui-editor-contents h1.toastui-editor-md-preview-highlight:after,.toastui-editor-contents h2.toastui-editor-md-preview-highlight:after{bottom:0}.toastui-editor-contents td.toastui-editor-md-preview-highlight:after,.toastui-editor-contents th.toastui-editor-md-preview-highlight:after{display:none}.toastui-editor-contents th.toastui-editor-md-preview-highlight,.toastui-editor-contents td.toastui-editor-md-preview-highlight{background-color:#fff58380}.toastui-editor-contents th.toastui-editor-md-preview-highlight{color:#222}.toastui-editor-md-heading1{font-size:24px}.toastui-editor-md-heading2{font-size:22px}.toastui-editor-md-heading3{font-size:20px}.toastui-editor-md-heading4{font-size:18px}.toastui-editor-md-heading5{font-size:16px}.toastui-editor-md-heading6{font-size:14px}.toastui-editor-md-heading.toastui-editor-md-delimiter.setext{line-height:15px}.toastui-editor-md-strong,.toastui-editor-md-heading,.toastui-editor-md-list-item-style,.toastui-editor-md-list-item .toastui-editor-md-meta{font-weight:700}.toastui-editor-md-emph{font-style:italic}.toastui-editor-md-strike{text-decoration:line-through}.toastui-editor-md-strike.toastui-editor-md-delimiter{text-decoration:none}.toastui-editor-md-delimiter,.toastui-editor-md-thematic-break,.toastui-editor-md-link,.toastui-editor-md-table,.toastui-editor-md-block-quote{color:#ccc}.toastui-editor-md-code.toastui-editor-md-delimiter{color:#aaa}.toastui-editor-md-meta,.toastui-editor-md-html,.toastui-editor-md-link.toastui-editor-md-link-url.toastui-editor-md-marked-text{color:#999}.toastui-editor-md-block-quote .toastui-editor-md-marked-text,.toastui-editor-md-list-item .toastui-editor-md-meta{color:#555}.toastui-editor-md-table .toastui-editor-md-table-cell{color:#222}.toastui-editor-md-link.toastui-editor-md-link-desc.toastui-editor-md-marked-text,.toastui-editor-md-list-item-style.toastui-editor-md-list-item-odd{color:#4b96e6}.toastui-editor-md-list-item-style.toastui-editor-md-list-item-even{color:#cb4848}.toastui-editor-md-code.toastui-editor-md-marked-text{color:#c1798b}.toastui-editor-md-code{background-color:#f3e5e980;padding:2px 0;letter-spacing:-.3px}.toastui-editor-md-code.toastui-editor-md-start{padding-left:2px;border-top-left-radius:2px;border-bottom-left-radius:2px}.toastui-editor-md-code.toastui-editor-md-end{padding-right:2px;border-top-right-radius:2px;border-bottom-right-radius:2px}.toastui-editor-md-code-block-line-background{background-color:#f5f7f8}.toastui-editor-md-code-block-line-background.start,.toastui-editor-md-custom-block-line-background.start{margin-top:2px}.toastui-editor-md-code,.toastui-editor-md-code-block{font-family:Consolas,Courier,Lucida Grande,,Nanum Barun Gothic,,Malgun Gothic,sans-serif}.toastui-editor-md-custom-block{color:#452d6b}.toastui-editor-md-custom-block-line-background{background-color:#f9f7fd}.toastui-editor-md-custom-block .toastui-editor-md-delimiter{color:#b8b3c0}.toastui-editor-md-custom-block .toastui-editor-md-meta{color:#5200d0}
`;
var dist = {}, api = {}, streamUploader = {}, upload = {}, sjcl = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(cr) {
  var ar = { cipher: {}, hash: {}, keyexchange: {}, mode: {}, misc: {}, codec: {}, exception: { corrupt: function(Er) {
    this.toString = function() {
      return "CORRUPT: " + this.message;
    }, this.message = Er;
  }, invalid: function(Er) {
    this.toString = function() {
      return "INVALID: " + this.message;
    }, this.message = Er;
  }, bug: function(Er) {
    this.toString = function() {
      return "BUG: " + this.message;
    }, this.message = Er;
  }, notReady: function(Er) {
    this.toString = function() {
      return "NOT READY: " + this.message;
    }, this.message = Er;
  } } };
  ar.cipher.aes = function(Er) {
    this.s[0][0][0] || this.O();
    var Cr, Tr, Sr, Lr, Ir = this.s[0][4], Nr = this.s[1];
    Cr = Er.length;
    var Rr = 1;
    if (Cr !== 4 && Cr !== 6 && Cr !== 8)
      throw new ar.exception.invalid("invalid aes key size");
    for (this.b = [Sr = Er.slice(0), Lr = []], Er = Cr; Er < 4 * Cr + 28; Er++)
      Tr = Sr[Er - 1], (Er % Cr === 0 || Cr === 8 && Er % Cr === 4) && (Tr = Ir[Tr >>> 24] << 24 ^ Ir[Tr >> 16 & 255] << 16 ^ Ir[Tr >> 8 & 255] << 8 ^ Ir[Tr & 255], Er % Cr === 0 && (Tr = Tr << 8 ^ Tr >>> 24 ^ Rr << 24, Rr = Rr << 1 ^ 283 * (Rr >> 7))), Sr[Er] = Sr[Er - Cr] ^ Tr;
    for (Cr = 0; Er; Cr++, Er--)
      Tr = Sr[Cr & 3 ? Er : Er - 4], Lr[Cr] = 4 >= Er || 4 > Cr ? Tr : Nr[0][Ir[Tr >>> 24]] ^ Nr[1][Ir[Tr >> 16 & 255]] ^ Nr[2][Ir[Tr >> 8 & 255]] ^ Nr[3][Ir[Tr & 255]];
  }, ar.cipher.aes.prototype = { encrypt: function(Er) {
    return lr(this, Er, 0);
  }, decrypt: function(Er) {
    return lr(this, Er, 1);
  }, s: [[[], [], [], [], []], [[], [], [], [], []]], O: function() {
    var Er = this.s[0], Cr = this.s[1], Tr = Er[4], Sr = Cr[4], Lr, Ir, Nr, Rr = [], Mr = [], Br, Dr, Hr, Fr;
    for (Lr = 0; 256 > Lr; Lr++)
      Mr[(Rr[Lr] = Lr << 1 ^ 283 * (Lr >> 7)) ^ Lr] = Lr;
    for (Ir = Nr = 0; !Tr[Ir]; Ir ^= Br || 1, Nr = Mr[Nr] || 1)
      for (Hr = Nr ^ Nr << 1 ^ Nr << 2 ^ Nr << 3 ^ Nr << 4, Hr = Hr >> 8 ^ Hr & 255 ^ 99, Tr[Ir] = Hr, Sr[Hr] = Ir, Dr = Rr[Lr = Rr[Br = Rr[Ir]]], Fr = 16843009 * Dr ^ 65537 * Lr ^ 257 * Br ^ 16843008 * Ir, Dr = 257 * Rr[Hr] ^ 16843008 * Hr, Lr = 0; 4 > Lr; Lr++)
        Er[Lr][Ir] = Dr = Dr << 24 ^ Dr >>> 8, Cr[Lr][Hr] = Fr = Fr << 24 ^ Fr >>> 8;
    for (Lr = 0; 5 > Lr; Lr++)
      Er[Lr] = Er[Lr].slice(0), Cr[Lr] = Cr[Lr].slice(0);
  } };
  function lr(Er, Cr, Tr) {
    if (Cr.length !== 4)
      throw new ar.exception.invalid("invalid aes block size");
    var Sr = Er.b[Tr], Lr = Cr[0] ^ Sr[0], Ir = Cr[Tr ? 3 : 1] ^ Sr[1], Nr = Cr[2] ^ Sr[2];
    Cr = Cr[Tr ? 1 : 3] ^ Sr[3];
    var Rr, Mr, Br, Dr = Sr.length / 4 - 2, Hr, Fr = 4, zr = [0, 0, 0, 0];
    Rr = Er.s[Tr], Er = Rr[0];
    var Ur = Rr[1], jr = Rr[2], Yr = Rr[3], qr = Rr[4];
    for (Hr = 0; Hr < Dr; Hr++)
      Rr = Er[Lr >>> 24] ^ Ur[Ir >> 16 & 255] ^ jr[Nr >> 8 & 255] ^ Yr[Cr & 255] ^ Sr[Fr], Mr = Er[Ir >>> 24] ^ Ur[Nr >> 16 & 255] ^ jr[Cr >> 8 & 255] ^ Yr[Lr & 255] ^ Sr[Fr + 1], Br = Er[Nr >>> 24] ^ Ur[Cr >> 16 & 255] ^ jr[Lr >> 8 & 255] ^ Yr[Ir & 255] ^ Sr[Fr + 2], Cr = Er[Cr >>> 24] ^ Ur[Lr >> 16 & 255] ^ jr[Ir >> 8 & 255] ^ Yr[Nr & 255] ^ Sr[Fr + 3], Fr += 4, Lr = Rr, Ir = Mr, Nr = Br;
    for (Hr = 0; 4 > Hr; Hr++)
      zr[Tr ? 3 & -Hr : Hr] = qr[Lr >>> 24] << 24 ^ qr[Ir >> 16 & 255] << 16 ^ qr[Nr >> 8 & 255] << 8 ^ qr[Cr & 255] ^ Sr[Fr++], Rr = Lr, Lr = Ir, Ir = Nr, Nr = Cr, Cr = Rr;
    return zr;
  }
  ar.bitArray = { bitSlice: function(Er, Cr, Tr) {
    return Er = ar.bitArray.$(Er.slice(Cr / 32), 32 - (Cr & 31)).slice(1), Tr === void 0 ? Er : ar.bitArray.clamp(Er, Tr - Cr);
  }, extract: function(Er, Cr, Tr) {
    var Sr = Math.floor(-Cr - Tr & 31);
    return ((Cr + Tr - 1 ^ Cr) & -32 ? Er[Cr / 32 | 0] << 32 - Sr ^ Er[Cr / 32 + 1 | 0] >>> Sr : Er[Cr / 32 | 0] >>> Sr) & (1 << Tr) - 1;
  }, concat: function(Er, Cr) {
    if (Er.length === 0 || Cr.length === 0)
      return Er.concat(Cr);
    var Tr = Er[Er.length - 1], Sr = ar.bitArray.getPartial(Tr);
    return Sr === 32 ? Er.concat(Cr) : ar.bitArray.$(Cr, Sr, Tr | 0, Er.slice(0, Er.length - 1));
  }, bitLength: function(Er) {
    var Cr = Er.length;
    return Cr === 0 ? 0 : 32 * (Cr - 1) + ar.bitArray.getPartial(Er[Cr - 1]);
  }, clamp: function(Er, Cr) {
    if (32 * Er.length < Cr)
      return Er;
    Er = Er.slice(0, Math.ceil(Cr / 32));
    var Tr = Er.length;
    return Cr = Cr & 31, 0 < Tr && Cr && (Er[Tr - 1] = ar.bitArray.partial(Cr, Er[Tr - 1] & 2147483648 >> Cr - 1, 1)), Er;
  }, partial: function(Er, Cr, Tr) {
    return Er === 32 ? Cr : (Tr ? Cr | 0 : Cr << 32 - Er) + 1099511627776 * Er;
  }, getPartial: function(Er) {
    return Math.round(Er / 1099511627776) || 32;
  }, equal: function(Er, Cr) {
    if (ar.bitArray.bitLength(Er) !== ar.bitArray.bitLength(Cr))
      return !1;
    var Tr = 0, Sr;
    for (Sr = 0; Sr < Er.length; Sr++)
      Tr |= Er[Sr] ^ Cr[Sr];
    return Tr === 0;
  }, $: function(Er, Cr, Tr, Sr) {
    var Lr;
    for (Lr = 0, Sr === void 0 && (Sr = []); 32 <= Cr; Cr -= 32)
      Sr.push(Tr), Tr = 0;
    if (Cr === 0)
      return Sr.concat(Er);
    for (Lr = 0; Lr < Er.length; Lr++)
      Sr.push(Tr | Er[Lr] >>> Cr), Tr = Er[Lr] << 32 - Cr;
    return Lr = Er.length ? Er[Er.length - 1] : 0, Er = ar.bitArray.getPartial(Lr), Sr.push(ar.bitArray.partial(Cr + Er & 31, 32 < Cr + Er ? Tr : Sr.pop(), 1)), Sr;
  }, i: function(Er, Cr) {
    return [Er[0] ^ Cr[0], Er[1] ^ Cr[1], Er[2] ^ Cr[2], Er[3] ^ Cr[3]];
  }, byteswapM: function(Er) {
    var Cr, Tr;
    for (Cr = 0; Cr < Er.length; ++Cr)
      Tr = Er[Cr], Er[Cr] = Tr >>> 24 | Tr >>> 8 & 65280 | (Tr & 65280) << 8 | Tr << 24;
    return Er;
  } }, ar.codec.utf8String = { fromBits: function(Er) {
    var Cr = "", Tr = ar.bitArray.bitLength(Er), Sr, Lr;
    for (Sr = 0; Sr < Tr / 8; Sr++)
      !(Sr & 3) && (Lr = Er[Sr / 4]), Cr += String.fromCharCode(Lr >>> 8 >>> 8 >>> 8), Lr <<= 8;
    return decodeURIComponent(escape(Cr));
  }, toBits: function(Er) {
    Er = unescape(encodeURIComponent(Er));
    var Cr = [], Tr, Sr = 0;
    for (Tr = 0; Tr < Er.length; Tr++)
      Sr = Sr << 8 | Er.charCodeAt(Tr), (Tr & 3) === 3 && (Cr.push(Sr), Sr = 0);
    return Tr & 3 && Cr.push(ar.bitArray.partial(8 * (Tr & 3), Sr)), Cr;
  } }, ar.codec.hex = { fromBits: function(Er) {
    var Cr = "", Tr;
    for (Tr = 0; Tr < Er.length; Tr++)
      Cr += ((Er[Tr] | 0) + 263882790666240).toString(16).substr(4);
    return Cr.substr(0, ar.bitArray.bitLength(Er) / 4);
  }, toBits: function(Er) {
    var Cr, Tr = [], Sr;
    for (Er = Er.replace(/\s|0x/g, ""), Sr = Er.length, Er = Er + "00000000", Cr = 0; Cr < Er.length; Cr += 8)
      Tr.push(parseInt(Er.substr(Cr, 8), 16) ^ 0);
    return ar.bitArray.clamp(Tr, 4 * Sr);
  } }, ar.codec.base32 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", X: "0123456789ABCDEFGHIJKLMNOPQRSTUV", BITS: 32, BASE: 5, REMAINING: 27, fromBits: function(Er, Cr, Tr) {
    var Sr = ar.codec.base32.BASE, Lr = ar.codec.base32.REMAINING, Ir = "", Nr = 0, Rr = ar.codec.base32.B, Mr = 0, Br = ar.bitArray.bitLength(Er);
    for (Tr && (Rr = ar.codec.base32.X), Tr = 0; Ir.length * Sr < Br; )
      Ir += Rr.charAt((Mr ^ Er[Tr] >>> Nr) >>> Lr), Nr < Sr ? (Mr = Er[Tr] << Sr - Nr, Nr += Lr, Tr++) : (Mr <<= Sr, Nr -= Sr);
    for (; Ir.length & 7 && !Cr; )
      Ir += "=";
    return Ir;
  }, toBits: function(Er, Cr) {
    Er = Er.replace(/\s|=/g, "").toUpperCase();
    var Tr = ar.codec.base32.BITS, Sr = ar.codec.base32.BASE, Lr = ar.codec.base32.REMAINING, Ir = [], Nr, Rr = 0, Mr = ar.codec.base32.B, Br = 0, Dr, Hr = "base32";
    for (Cr && (Mr = ar.codec.base32.X, Hr = "base32hex"), Nr = 0; Nr < Er.length; Nr++) {
      if (Dr = Mr.indexOf(Er.charAt(Nr)), 0 > Dr) {
        if (!Cr)
          try {
            return ar.codec.base32hex.toBits(Er);
          } catch (Fr) {
          }
        throw new ar.exception.invalid("this isn't " + Hr + "!");
      }
      Rr > Lr ? (Rr -= Lr, Ir.push(Br ^ Dr >>> Rr), Br = Dr << Tr - Rr) : (Rr += Sr, Br ^= Dr << Tr - Rr);
    }
    return Rr & 56 && Ir.push(ar.bitArray.partial(Rr & 56, Br, 1)), Ir;
  } }, ar.codec.base32hex = { fromBits: function(Er, Cr) {
    return ar.codec.base32.fromBits(Er, Cr, 1);
  }, toBits: function(Er) {
    return ar.codec.base32.toBits(Er, 1);
  } }, ar.codec.base64 = { B: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fromBits: function(Er, Cr, Tr) {
    var Sr = "", Lr = 0, Ir = ar.codec.base64.B, Nr = 0, Rr = ar.bitArray.bitLength(Er);
    for (Tr && (Ir = Ir.substr(0, 62) + "-_"), Tr = 0; 6 * Sr.length < Rr; )
      Sr += Ir.charAt((Nr ^ Er[Tr] >>> Lr) >>> 26), 6 > Lr ? (Nr = Er[Tr] << 6 - Lr, Lr += 26, Tr++) : (Nr <<= 6, Lr -= 6);
    for (; Sr.length & 3 && !Cr; )
      Sr += "=";
    return Sr;
  }, toBits: function(Er, Cr) {
    Er = Er.replace(/\s|=/g, "");
    var Tr = [], Sr, Lr = 0, Ir = ar.codec.base64.B, Nr = 0, Rr;
    for (Cr && (Ir = Ir.substr(0, 62) + "-_"), Sr = 0; Sr < Er.length; Sr++) {
      if (Rr = Ir.indexOf(Er.charAt(Sr)), 0 > Rr)
        throw new ar.exception.invalid("this isn't base64!");
      26 < Lr ? (Lr -= 26, Tr.push(Nr ^ Rr >>> Lr), Nr = Rr << 32 - Lr) : (Lr += 6, Nr ^= Rr << 32 - Lr);
    }
    return Lr & 56 && Tr.push(ar.bitArray.partial(Lr & 56, Nr, 1)), Tr;
  } }, ar.codec.base64url = { fromBits: function(Er) {
    return ar.codec.base64.fromBits(Er, 1, 1);
  }, toBits: function(Er) {
    return ar.codec.base64.toBits(Er, 1);
  } }, ar.hash.sha256 = function(Er) {
    this.b[0] || this.O(), Er ? (this.F = Er.F.slice(0), this.A = Er.A.slice(0), this.l = Er.l) : this.reset();
  }, ar.hash.sha256.hash = function(Er) {
    return new ar.hash.sha256().update(Er).finalize();
  }, ar.hash.sha256.prototype = { blockSize: 512, reset: function() {
    return this.F = this.Y.slice(0), this.A = [], this.l = 0, this;
  }, update: function(Er) {
    typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er));
    var Cr, Tr = this.A = ar.bitArray.concat(this.A, Er);
    if (Cr = this.l, Er = this.l = Cr + ar.bitArray.bitLength(Er), 9007199254740991 < Er)
      throw new ar.exception.invalid("Cannot hash more than 2^53 - 1 bits");
    if (typeof Uint32Array != "undefined") {
      var Sr = new Uint32Array(Tr), Lr = 0;
      for (Cr = 512 + Cr - (512 + Cr & 511); Cr <= Er; Cr += 512)
        ur(this, Sr.subarray(
          16 * Lr,
          16 * (Lr + 1)
        )), Lr += 1;
      Tr.splice(0, 16 * Lr);
    } else
      for (Cr = 512 + Cr - (512 + Cr & 511); Cr <= Er; Cr += 512)
        ur(this, Tr.splice(0, 16));
    return this;
  }, finalize: function() {
    var Er, Tr = this.A, Cr = this.F, Tr = ar.bitArray.concat(Tr, [ar.bitArray.partial(1, 1)]);
    for (Er = Tr.length + 2; Er & 15; Er++)
      Tr.push(0);
    for (Tr.push(Math.floor(this.l / 4294967296)), Tr.push(this.l | 0); Tr.length; )
      ur(this, Tr.splice(0, 16));
    return this.reset(), Cr;
  }, Y: [], b: [], O: function() {
    function Er(Ir) {
      return 4294967296 * (Ir - Math.floor(Ir)) | 0;
    }
    for (var Cr = 0, Tr = 2, Sr, Lr; 64 > Cr; Tr++) {
      for (Lr = !0, Sr = 2; Sr * Sr <= Tr; Sr++)
        if (Tr % Sr === 0) {
          Lr = !1;
          break;
        }
      Lr && (8 > Cr && (this.Y[Cr] = Er(Math.pow(Tr, 0.5))), this.b[Cr] = Er(Math.pow(Tr, 1 / 3)), Cr++);
    }
  } };
  function ur(Er, Cr) {
    var Tr, Sr, Lr, Ir = Er.F, Nr = Er.b, Rr = Ir[0], Mr = Ir[1], Br = Ir[2], Dr = Ir[3], Hr = Ir[4], Fr = Ir[5], zr = Ir[6], Ur = Ir[7];
    for (Tr = 0; 64 > Tr; Tr++)
      16 > Tr ? Sr = Cr[Tr] : (Sr = Cr[Tr + 1 & 15], Lr = Cr[Tr + 14 & 15], Sr = Cr[Tr & 15] = (Sr >>> 7 ^ Sr >>> 18 ^ Sr >>> 3 ^ Sr << 25 ^ Sr << 14) + (Lr >>> 17 ^ Lr >>> 19 ^ Lr >>> 10 ^ Lr << 15 ^ Lr << 13) + Cr[Tr & 15] + Cr[Tr + 9 & 15] | 0), Sr = Sr + Ur + (Hr >>> 6 ^ Hr >>> 11 ^ Hr >>> 25 ^ Hr << 26 ^ Hr << 21 ^ Hr << 7) + (zr ^ Hr & (Fr ^ zr)) + Nr[Tr], Ur = zr, zr = Fr, Fr = Hr, Hr = Dr + Sr | 0, Dr = Br, Br = Mr, Mr = Rr, Rr = Sr + (Mr & Br ^ Dr & (Mr ^ Br)) + (Mr >>> 2 ^ Mr >>> 13 ^ Mr >>> 22 ^ Mr << 30 ^ Mr << 19 ^ Mr << 10) | 0;
    Ir[0] = Ir[0] + Rr | 0, Ir[1] = Ir[1] + Mr | 0, Ir[2] = Ir[2] + Br | 0, Ir[3] = Ir[3] + Dr | 0, Ir[4] = Ir[4] + Hr | 0, Ir[5] = Ir[5] + Fr | 0, Ir[6] = Ir[6] + zr | 0, Ir[7] = Ir[7] + Ur | 0;
  }
  ar.mode.ccm = { name: "ccm", G: [], listenProgress: function(Er) {
    ar.mode.ccm.G.push(Er);
  }, unListenProgress: function(Er) {
    Er = ar.mode.ccm.G.indexOf(Er), -1 < Er && ar.mode.ccm.G.splice(Er, 1);
  }, fa: function(Er) {
    var Cr = ar.mode.ccm.G.slice(), Tr;
    for (Tr = 0; Tr < Cr.length; Tr += 1)
      Cr[Tr](Er);
  }, encrypt: function(Er, Cr, Tr, Sr, Lr) {
    var Ir, Nr = Cr.slice(0), Rr = ar.bitArray, Mr = Rr.bitLength(Tr) / 8, Br = Rr.bitLength(Nr) / 8;
    if (Lr = Lr || 64, Sr = Sr || [], 7 > Mr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Ir = 2; 4 > Ir && Br >>> 8 * Ir; Ir++)
      ;
    return Ir < 15 - Mr && (Ir = 15 - Mr), Tr = Rr.clamp(
      Tr,
      8 * (15 - Ir)
    ), Cr = ar.mode.ccm.V(Er, Cr, Tr, Sr, Lr, Ir), Nr = ar.mode.ccm.C(Er, Nr, Tr, Cr, Lr, Ir), Rr.concat(Nr.data, Nr.tag);
  }, decrypt: function(Er, Cr, Tr, Sr, Lr) {
    Lr = Lr || 64, Sr = Sr || [];
    var Ir = ar.bitArray, Nr = Ir.bitLength(Tr) / 8, Br = Ir.bitLength(Cr), Rr = Ir.clamp(Cr, Br - Lr), Mr = Ir.bitSlice(Cr, Br - Lr), Br = (Br - Lr) / 8;
    if (7 > Nr)
      throw new ar.exception.invalid("ccm: iv must be at least 7 bytes");
    for (Cr = 2; 4 > Cr && Br >>> 8 * Cr; Cr++)
      ;
    if (Cr < 15 - Nr && (Cr = 15 - Nr), Tr = Ir.clamp(Tr, 8 * (15 - Cr)), Rr = ar.mode.ccm.C(Er, Rr, Tr, Mr, Lr, Cr), Er = ar.mode.ccm.V(Er, Rr.data, Tr, Sr, Lr, Cr), !Ir.equal(Rr.tag, Er))
      throw new ar.exception.corrupt("ccm: tag doesn't match");
    return Rr.data;
  }, na: function(Er, Cr, Tr, Sr, Lr, Ir) {
    var Nr = [], Rr = ar.bitArray, Mr = Rr.i;
    if (Sr = [Rr.partial(8, (Cr.length ? 64 : 0) | Sr - 2 << 2 | Ir - 1)], Sr = Rr.concat(Sr, Tr), Sr[3] |= Lr, Sr = Er.encrypt(Sr), Cr.length)
      for (Tr = Rr.bitLength(Cr) / 8, 65279 >= Tr ? Nr = [Rr.partial(16, Tr)] : 4294967295 >= Tr && (Nr = Rr.concat([Rr.partial(16, 65534)], [Tr])), Nr = Rr.concat(Nr, Cr), Cr = 0; Cr < Nr.length; Cr += 4)
        Sr = Er.encrypt(Mr(Sr, Nr.slice(Cr, Cr + 4).concat([0, 0, 0])));
    return Sr;
  }, V: function(Er, Cr, Tr, Sr, Lr, Ir) {
    var Nr = ar.bitArray, Rr = Nr.i;
    if (Lr /= 8, Lr % 2 || 4 > Lr || 16 < Lr)
      throw new ar.exception.invalid("ccm: invalid tag length");
    if (4294967295 < Sr.length || 4294967295 < Cr.length)
      throw new ar.exception.bug("ccm: can't deal with 4GiB or more data");
    for (Tr = ar.mode.ccm.na(Er, Sr, Tr, Lr, Nr.bitLength(Cr) / 8, Ir), Sr = 0; Sr < Cr.length; Sr += 4)
      Tr = Er.encrypt(Rr(Tr, Cr.slice(Sr, Sr + 4).concat([0, 0, 0])));
    return Nr.clamp(Tr, 8 * Lr);
  }, C: function(Er, Cr, Tr, Sr, Lr, Ir) {
    var Nr, Rr = ar.bitArray;
    Nr = Rr.i;
    var Mr = Cr.length, Br = Rr.bitLength(Cr), Dr = Mr / 50, Hr = Dr;
    if (Tr = Rr.concat([Rr.partial(8, Ir - 1)], Tr).concat([0, 0, 0]).slice(0, 4), Sr = Rr.bitSlice(Nr(Sr, Er.encrypt(Tr)), 0, Lr), !Mr)
      return { tag: Sr, data: [] };
    for (Nr = 0; Nr < Mr; Nr += 4)
      Nr > Dr && (ar.mode.ccm.fa(Nr / Mr), Dr += Hr), Tr[3]++, Lr = Er.encrypt(Tr), Cr[Nr] ^= Lr[0], Cr[Nr + 1] ^= Lr[1], Cr[Nr + 2] ^= Lr[2], Cr[Nr + 3] ^= Lr[3];
    return { tag: Sr, data: Rr.clamp(Cr, Br) };
  } }, ar.mode.ocb2 = { name: "ocb2", encrypt: function(Er, Cr, Tr, Sr, Lr, Ir) {
    if (ar.bitArray.bitLength(Tr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    var Nr, Rr = ar.mode.ocb2.S, Mr = ar.bitArray, Br = Mr.i, Dr = [0, 0, 0, 0];
    Tr = Rr(Er.encrypt(Tr));
    var Hr, Fr = [];
    for (Sr = Sr || [], Lr = Lr || 64, Nr = 0; Nr + 4 < Cr.length; Nr += 4)
      Hr = Cr.slice(Nr, Nr + 4), Dr = Br(Dr, Hr), Fr = Fr.concat(Br(Tr, Er.encrypt(Br(Tr, Hr)))), Tr = Rr(Tr);
    return Hr = Cr.slice(Nr), Cr = Mr.bitLength(Hr), Nr = Er.encrypt(Br(Tr, [0, 0, 0, Cr])), Hr = Mr.clamp(Br(Hr.concat([0, 0, 0]), Nr), Cr), Dr = Br(Dr, Br(Hr.concat([0, 0, 0]), Nr)), Dr = Er.encrypt(Br(Dr, Br(Tr, Rr(Tr)))), Sr.length && (Dr = Br(Dr, Ir ? Sr : ar.mode.ocb2.pmac(Er, Sr))), Fr.concat(Mr.concat(Hr, Mr.clamp(Dr, Lr)));
  }, decrypt: function(Er, Cr, Tr, Sr, Lr, Ir) {
    if (ar.bitArray.bitLength(Tr) !== 128)
      throw new ar.exception.invalid("ocb iv must be 128 bits");
    Lr = Lr || 64;
    var Nr = ar.mode.ocb2.S, Rr = ar.bitArray, Mr = Rr.i, Br = [0, 0, 0, 0], Dr = Nr(Er.encrypt(Tr)), Hr, Fr, zr = ar.bitArray.bitLength(Cr) - Lr, Ur = [];
    for (Sr = Sr || [], Tr = 0; Tr + 4 < zr / 32; Tr += 4)
      Hr = Mr(Dr, Er.decrypt(Mr(Dr, Cr.slice(Tr, Tr + 4)))), Br = Mr(Br, Hr), Ur = Ur.concat(Hr), Dr = Nr(Dr);
    if (Fr = zr - 32 * Tr, Hr = Er.encrypt(Mr(Dr, [0, 0, 0, Fr])), Hr = Mr(Hr, Rr.clamp(Cr.slice(Tr), Fr).concat([
      0,
      0,
      0
    ])), Br = Mr(Br, Hr), Br = Er.encrypt(Mr(Br, Mr(Dr, Nr(Dr)))), Sr.length && (Br = Mr(Br, Ir ? Sr : ar.mode.ocb2.pmac(Er, Sr))), !Rr.equal(Rr.clamp(Br, Lr), Rr.bitSlice(Cr, zr)))
      throw new ar.exception.corrupt("ocb: tag doesn't match");
    return Ur.concat(Rr.clamp(Hr, Fr));
  }, pmac: function(Er, Cr) {
    var Tr, Sr = ar.mode.ocb2.S, Lr = ar.bitArray, Ir = Lr.i, Nr = [0, 0, 0, 0], Rr = Er.encrypt([0, 0, 0, 0]), Rr = Ir(Rr, Sr(Sr(Rr)));
    for (Tr = 0; Tr + 4 < Cr.length; Tr += 4)
      Rr = Sr(Rr), Nr = Ir(Nr, Er.encrypt(Ir(Rr, Cr.slice(Tr, Tr + 4))));
    return Tr = Cr.slice(Tr), 128 > Lr.bitLength(Tr) && (Rr = Ir(Rr, Sr(Rr)), Tr = Lr.concat(Tr, [-2147483648, 0, 0, 0])), Nr = Ir(Nr, Tr), Er.encrypt(Ir(Sr(Ir(Rr, Sr(Rr))), Nr));
  }, S: function(Er) {
    return [Er[0] << 1 ^ Er[1] >>> 31, Er[1] << 1 ^ Er[2] >>> 31, Er[2] << 1 ^ Er[3] >>> 31, Er[3] << 1 ^ 135 * (Er[0] >>> 31)];
  } }, ar.mode.gcm = { name: "gcm", encrypt: function(Er, Cr, Tr, Sr, Lr) {
    var Ir = Cr.slice(0);
    return Cr = ar.bitArray, Sr = Sr || [], Er = ar.mode.gcm.C(!0, Er, Ir, Sr, Tr, Lr || 128), Cr.concat(Er.data, Er.tag);
  }, decrypt: function(Er, Cr, Tr, Sr, Lr) {
    var Ir = Cr.slice(0), Nr = ar.bitArray, Rr = Nr.bitLength(Ir);
    if (Lr = Lr || 128, Sr = Sr || [], Lr <= Rr ? (Cr = Nr.bitSlice(Ir, Rr - Lr), Ir = Nr.bitSlice(Ir, 0, Rr - Lr)) : (Cr = Ir, Ir = []), Er = ar.mode.gcm.C(!1, Er, Ir, Sr, Tr, Lr), !Nr.equal(Er.tag, Cr))
      throw new ar.exception.corrupt("gcm: tag doesn't match");
    return Er.data;
  }, ka: function(Er, Cr) {
    var Tr, Sr, Lr, Ir, Nr, Rr = ar.bitArray.i;
    for (Lr = [
      0,
      0,
      0,
      0
    ], Ir = Cr.slice(0), Tr = 0; 128 > Tr; Tr++) {
      for ((Sr = (Er[Math.floor(Tr / 32)] & 1 << 31 - Tr % 32) !== 0) && (Lr = Rr(Lr, Ir)), Nr = (Ir[3] & 1) !== 0, Sr = 3; 0 < Sr; Sr--)
        Ir[Sr] = Ir[Sr] >>> 1 | (Ir[Sr - 1] & 1) << 31;
      Ir[0] >>>= 1, Nr && (Ir[0] ^= -520093696);
    }
    return Lr;
  }, j: function(Er, Cr, Tr) {
    var Sr, Lr = Tr.length;
    for (Cr = Cr.slice(0), Sr = 0; Sr < Lr; Sr += 4)
      Cr[0] ^= 4294967295 & Tr[Sr], Cr[1] ^= 4294967295 & Tr[Sr + 1], Cr[2] ^= 4294967295 & Tr[Sr + 2], Cr[3] ^= 4294967295 & Tr[Sr + 3], Cr = ar.mode.gcm.ka(Cr, Er);
    return Cr;
  }, C: function(Er, Cr, Tr, Sr, Lr, Ir) {
    var Nr, Rr, Mr, Br, Dr, Hr, Fr, zr, Ur = ar.bitArray;
    for (Hr = Tr.length, Fr = Ur.bitLength(Tr), zr = Ur.bitLength(Sr), Rr = Ur.bitLength(Lr), Nr = Cr.encrypt([0, 0, 0, 0]), Rr === 96 ? (Lr = Lr.slice(0), Lr = Ur.concat(Lr, [1])) : (Lr = ar.mode.gcm.j(Nr, [0, 0, 0, 0], Lr), Lr = ar.mode.gcm.j(Nr, Lr, [0, 0, Math.floor(Rr / 4294967296), Rr & 4294967295])), Rr = ar.mode.gcm.j(Nr, [0, 0, 0, 0], Sr), Dr = Lr.slice(0), Sr = Rr.slice(0), Er || (Sr = ar.mode.gcm.j(Nr, Rr, Tr)), Br = 0; Br < Hr; Br += 4)
      Dr[3]++, Mr = Cr.encrypt(Dr), Tr[Br] ^= Mr[0], Tr[Br + 1] ^= Mr[1], Tr[Br + 2] ^= Mr[2], Tr[Br + 3] ^= Mr[3];
    return Tr = Ur.clamp(Tr, Fr), Er && (Sr = ar.mode.gcm.j(Nr, Rr, Tr)), Er = [Math.floor(zr / 4294967296), zr & 4294967295, Math.floor(Fr / 4294967296), Fr & 4294967295], Sr = ar.mode.gcm.j(Nr, Sr, Er), Mr = Cr.encrypt(Lr), Sr[0] ^= Mr[0], Sr[1] ^= Mr[1], Sr[2] ^= Mr[2], Sr[3] ^= Mr[3], { tag: Ur.bitSlice(Sr, 0, Ir), data: Tr };
  } }, ar.misc.hmac = function(Er, Cr) {
    this.W = Cr = Cr || ar.hash.sha256;
    var Tr = [[], []], Sr, Lr = Cr.prototype.blockSize / 32;
    for (this.w = [new Cr(), new Cr()], Er.length > Lr && (Er = Cr.hash(Er)), Sr = 0; Sr < Lr; Sr++)
      Tr[0][Sr] = Er[Sr] ^ 909522486, Tr[1][Sr] = Er[Sr] ^ 1549556828;
    this.w[0].update(Tr[0]), this.w[1].update(Tr[1]), this.R = new Cr(this.w[0]);
  }, ar.misc.hmac.prototype.encrypt = ar.misc.hmac.prototype.mac = function(Er) {
    if (this.aa)
      throw new ar.exception.invalid("encrypt on already updated hmac called!");
    return this.update(Er), this.digest(Er);
  }, ar.misc.hmac.prototype.reset = function() {
    this.R = new this.W(this.w[0]), this.aa = !1;
  }, ar.misc.hmac.prototype.update = function(Er) {
    this.aa = !0, this.R.update(Er);
  }, ar.misc.hmac.prototype.digest = function() {
    var Er = this.R.finalize(), Er = new this.W(this.w[1]).update(Er).finalize();
    return this.reset(), Er;
  }, ar.misc.pbkdf2 = function(Er, Cr, Tr, Sr, Lr) {
    if (Tr = Tr || 1e4, 0 > Sr || 0 > Tr)
      throw new ar.exception.invalid("invalid params to pbkdf2");
    typeof Er == "string" && (Er = ar.codec.utf8String.toBits(Er)), typeof Cr == "string" && (Cr = ar.codec.utf8String.toBits(Cr)), Lr = Lr || ar.misc.hmac, Er = new Lr(Er);
    var Ir, Nr, Rr, Mr, Br = [], Dr = ar.bitArray;
    for (Mr = 1; 32 * Br.length < (Sr || 1); Mr++) {
      for (Lr = Ir = Er.encrypt(Dr.concat(Cr, [Mr])), Nr = 1; Nr < Tr; Nr++)
        for (Ir = Er.encrypt(Ir), Rr = 0; Rr < Ir.length; Rr++)
          Lr[Rr] ^= Ir[Rr];
      Br = Br.concat(Lr);
    }
    return Sr && (Br = Dr.clamp(Br, Sr)), Br;
  }, ar.prng = function(Er) {
    this.c = [new ar.hash.sha256()], this.m = [0], this.P = 0, this.H = {}, this.N = 0, this.U = {}, this.Z = this.f = this.o = this.ha = 0, this.b = [0, 0, 0, 0, 0, 0, 0, 0], this.h = [0, 0, 0, 0], this.L = void 0, this.M = Er, this.D = !1, this.K = { progress: {}, seeded: {} }, this.u = this.ga = 0, this.I = 1, this.J = 2, this.ca = 65536, this.T = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024], this.da = 3e4, this.ba = 80;
  }, ar.prng.prototype = {
    randomWords: function(Er, Cr) {
      var Tr = [], Sr;
      Sr = this.isReady(Cr);
      var Lr;
      if (Sr === this.u)
        throw new ar.exception.notReady("generator isn't seeded");
      if (Sr & this.J) {
        Sr = !(Sr & this.I), Lr = [];
        var Ir = 0, Nr;
        for (this.Z = Lr[0] = (/* @__PURE__ */ new Date()).valueOf() + this.da, Nr = 0; 16 > Nr; Nr++)
          Lr.push(4294967296 * Math.random() | 0);
        for (Nr = 0; Nr < this.c.length && (Lr = Lr.concat(this.c[Nr].finalize()), Ir += this.m[Nr], this.m[Nr] = 0, Sr || !(this.P & 1 << Nr)); Nr++)
          ;
        for (this.P >= 1 << this.c.length && (this.c.push(new ar.hash.sha256()), this.m.push(0)), this.f -= Ir, Ir > this.o && (this.o = Ir), this.P++, this.b = ar.hash.sha256.hash(this.b.concat(Lr)), this.L = new ar.cipher.aes(this.b), Sr = 0; 4 > Sr && (this.h[Sr] = this.h[Sr] + 1 | 0, !this.h[Sr]); Sr++)
          ;
      }
      for (Sr = 0; Sr < Er; Sr += 4)
        (Sr + 1) % this.ca === 0 && gr(this), Lr = mr(this), Tr.push(Lr[0], Lr[1], Lr[2], Lr[3]);
      return gr(this), Tr.slice(0, Er);
    },
    setDefaultParanoia: function(Er, Cr) {
      if (Er === 0 && Cr !== "Setting paranoia=0 will ruin your security; use it only for testing")
        throw new ar.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
      this.M = Er;
    },
    addEntropy: function(Er, Cr, Tr) {
      Tr = Tr || "user";
      var Sr, Lr, Ir = (/* @__PURE__ */ new Date()).valueOf(), Nr = this.H[Tr], Rr = this.isReady(), Mr = 0;
      switch (Sr = this.U[Tr], Sr === void 0 && (Sr = this.U[Tr] = this.ha++), Nr === void 0 && (Nr = this.H[Tr] = 0), this.H[Tr] = (this.H[Tr] + 1) % this.c.length, typeof Er) {
        case "number":
          Cr === void 0 && (Cr = 1), this.c[Nr].update([Sr, this.N++, 1, Cr, Ir, 1, Er | 0]);
          break;
        case "object":
          if (Tr = Object.prototype.toString.call(Er), Tr === "[object Uint32Array]") {
            for (Lr = [], Tr = 0; Tr < Er.length; Tr++)
              Lr.push(Er[Tr]);
            Er = Lr;
          } else
            for (Tr !== "[object Array]" && (Mr = 1), Tr = 0; Tr < Er.length && !Mr; Tr++)
              typeof Er[Tr] != "number" && (Mr = 1);
          if (!Mr) {
            if (Cr === void 0)
              for (Tr = Cr = 0; Tr < Er.length; Tr++)
                for (Lr = Er[Tr]; 0 < Lr; )
                  Cr++, Lr = Lr >>> 1;
            this.c[Nr].update([Sr, this.N++, 2, Cr, Ir, Er.length].concat(Er));
          }
          break;
        case "string":
          Cr === void 0 && (Cr = Er.length), this.c[Nr].update([Sr, this.N++, 3, Cr, Ir, Er.length]), this.c[Nr].update(Er);
          break;
        default:
          Mr = 1;
      }
      if (Mr)
        throw new ar.exception.bug("random: addEntropy only supports number, array of numbers or string");
      this.m[Nr] += Cr, this.f += Cr, Rr === this.u && (this.isReady() !== this.u && dr("seeded", Math.max(this.o, this.f)), dr("progress", this.getProgress()));
    },
    isReady: function(Er) {
      return Er = this.T[Er !== void 0 ? Er : this.M], this.o && this.o >= Er ? this.m[0] > this.ba && (/* @__PURE__ */ new Date()).valueOf() > this.Z ? this.J | this.I : this.I : this.f >= Er ? this.J | this.u : this.u;
    },
    getProgress: function(Er) {
      return Er = this.T[Er || this.M], this.o >= Er || this.f > Er ? 1 : this.f / Er;
    },
    startCollectors: function() {
      if (!this.D) {
        if (this.a = { loadTimeCollector: vr(this, this.ma), mouseCollector: vr(this, this.oa), keyboardCollector: vr(this, this.la), accelerometerCollector: vr(this, this.ea), touchCollector: vr(this, this.qa) }, window.addEventListener)
          window.addEventListener(
            "load",
            this.a.loadTimeCollector,
            !1
          ), window.addEventListener("mousemove", this.a.mouseCollector, !1), window.addEventListener("keypress", this.a.keyboardCollector, !1), window.addEventListener("devicemotion", this.a.accelerometerCollector, !1), window.addEventListener("touchmove", this.a.touchCollector, !1);
        else if (document.attachEvent)
          document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector);
        else
          throw new ar.exception.bug("can't attach event");
        this.D = !0;
      }
    },
    stopCollectors: function() {
      this.D && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, !1), window.removeEventListener("mousemove", this.a.mouseCollector, !1), window.removeEventListener("keypress", this.a.keyboardCollector, !1), window.removeEventListener("devicemotion", this.a.accelerometerCollector, !1), window.removeEventListener("touchmove", this.a.touchCollector, !1)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent(
        "onmousemove",
        this.a.mouseCollector
      ), document.detachEvent("keypress", this.a.keyboardCollector)), this.D = !1);
    },
    addEventListener: function(Er, Cr) {
      this.K[Er][this.ga++] = Cr;
    },
    removeEventListener: function(Er, Cr) {
      var Tr, Sr, Lr = this.K[Er], Ir = [];
      for (Sr in Lr)
        Lr.hasOwnProperty(Sr) && Lr[Sr] === Cr && Ir.push(Sr);
      for (Tr = 0; Tr < Ir.length; Tr++)
        Sr = Ir[Tr], delete Lr[Sr];
    },
    la: function() {
      fr(this, 1);
    },
    oa: function(Er) {
      var Cr, Tr;
      try {
        Cr = Er.x || Er.clientX || Er.offsetX || 0, Tr = Er.y || Er.clientY || Er.offsetY || 0;
      } catch (Sr) {
        Tr = Cr = 0;
      }
      Cr != 0 && Tr != 0 && this.addEntropy([Cr, Tr], 2, "mouse"), fr(this, 0);
    },
    qa: function(Er) {
      Er = Er.touches[0] || Er.changedTouches[0], this.addEntropy([Er.pageX || Er.clientX, Er.pageY || Er.clientY], 1, "touch"), fr(this, 0);
    },
    ma: function() {
      fr(this, 2);
    },
    ea: function(Er) {
      if (Er = Er.accelerationIncludingGravity.x || Er.accelerationIncludingGravity.y || Er.accelerationIncludingGravity.z, window.orientation) {
        var Cr = window.orientation;
        typeof Cr == "number" && this.addEntropy(Cr, 1, "accelerometer");
      }
      Er && this.addEntropy(Er, 2, "accelerometer"), fr(this, 0);
    }
  };
  function dr(Er, Cr) {
    var Tr, Sr = ar.random.K[Er], Lr = [];
    for (Tr in Sr)
      Sr.hasOwnProperty(Tr) && Lr.push(Sr[Tr]);
    for (Tr = 0; Tr < Lr.length; Tr++)
      Lr[Tr](Cr);
  }
  function fr(Er, Cr) {
    typeof window != "undefined" && window.performance && typeof window.performance.now == "function" ? Er.addEntropy(window.performance.now(), Cr, "loadtime") : Er.addEntropy((/* @__PURE__ */ new Date()).valueOf(), Cr, "loadtime");
  }
  function gr(Er) {
    Er.b = mr(Er).concat(mr(Er)), Er.L = new ar.cipher.aes(Er.b);
  }
  function mr(Er) {
    for (var Cr = 0; 4 > Cr && (Er.h[Cr] = Er.h[Cr] + 1 | 0, !Er.h[Cr]); Cr++)
      ;
    return Er.L.encrypt(Er.h);
  }
  function vr(Er, Cr) {
    return function() {
      Cr.apply(Er, arguments);
    };
  }
  ar.random = new ar.prng(6);
  e:
    try {
      var yr, _r, kr, xr;
      if (xr = cr.exports) {
        var Ar;
        try {
          Ar = require$$0;
        } catch (Er) {
          Ar = null;
        }
        xr = _r = Ar;
      }
      if (xr && _r.randomBytes)
        yr = _r.randomBytes(128), yr = new Uint32Array(new Uint8Array(yr).buffer), ar.random.addEntropy(yr, 1024, "crypto['randomBytes']");
      else if (typeof window != "undefined" && typeof Uint32Array != "undefined") {
        if (kr = new Uint32Array(32), window.crypto && window.crypto.getRandomValues)
          window.crypto.getRandomValues(kr);
        else if (window.msCrypto && window.msCrypto.getRandomValues)
          window.msCrypto.getRandomValues(kr);
        else
          break e;
        ar.random.addEntropy(kr, 1024, "crypto['getRandomValues']");
      }
    } catch (Er) {
      typeof window != "undefined" && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(Er));
    }
  ar.json = { defaults: { v: 1, iter: 1e4, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes" }, ja: function(Er, Cr, Tr, Sr) {
    Tr = Tr || {}, Sr = Sr || {};
    var Lr = ar.json, Ir = Lr.g({ iv: ar.random.randomWords(4, 0) }, Lr.defaults), Nr;
    if (Lr.g(Ir, Tr), Tr = Ir.adata, typeof Ir.salt == "string" && (Ir.salt = ar.codec.base64.toBits(Ir.salt)), typeof Ir.iv == "string" && (Ir.iv = ar.codec.base64.toBits(Ir.iv)), !ar.mode[Ir.mode] || !ar.cipher[Ir.cipher] || typeof Er == "string" && 100 >= Ir.iter || Ir.ts !== 64 && Ir.ts !== 96 && Ir.ts !== 128 || Ir.ks !== 128 && Ir.ks !== 192 && Ir.ks !== 256 || 2 > Ir.iv.length || 4 < Ir.iv.length)
      throw new ar.exception.invalid("json encrypt: invalid parameters");
    return typeof Er == "string" ? (Nr = ar.misc.cachedPbkdf2(Er, Ir), Er = Nr.key.slice(0, Ir.ks / 32), Ir.salt = Nr.salt) : ar.ecc && Er instanceof ar.ecc.elGamal.publicKey && (Nr = Er.kem(), Ir.kemtag = Nr.tag, Er = Nr.key.slice(0, Ir.ks / 32)), typeof Cr == "string" && (Cr = ar.codec.utf8String.toBits(Cr)), typeof Tr == "string" && (Ir.adata = Tr = ar.codec.utf8String.toBits(Tr)), Nr = new ar.cipher[Ir.cipher](Er), Lr.g(Sr, Ir), Sr.key = Er, Ir.ct = Ir.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Cr instanceof ArrayBuffer ? ar.arrayBuffer.ccm.encrypt(Nr, Cr, Ir.iv, Tr, Ir.ts) : ar.mode[Ir.mode].encrypt(Nr, Cr, Ir.iv, Tr, Ir.ts), Ir;
  }, encrypt: function(Er, Cr, Tr, Sr) {
    var Lr = ar.json, Ir = Lr.ja.apply(Lr, arguments);
    return Lr.encode(Ir);
  }, ia: function(Er, Cr, Tr, Sr) {
    Tr = Tr || {}, Sr = Sr || {};
    var Lr = ar.json;
    Cr = Lr.g(Lr.g(Lr.g({}, Lr.defaults), Cr), Tr, !0);
    var Ir, Nr;
    if (Ir = Cr.adata, typeof Cr.salt == "string" && (Cr.salt = ar.codec.base64.toBits(Cr.salt)), typeof Cr.iv == "string" && (Cr.iv = ar.codec.base64.toBits(Cr.iv)), !ar.mode[Cr.mode] || !ar.cipher[Cr.cipher] || typeof Er == "string" && 100 >= Cr.iter || Cr.ts !== 64 && Cr.ts !== 96 && Cr.ts !== 128 || Cr.ks !== 128 && Cr.ks !== 192 && Cr.ks !== 256 || !Cr.iv || 2 > Cr.iv.length || 4 < Cr.iv.length)
      throw new ar.exception.invalid("json decrypt: invalid parameters");
    return typeof Er == "string" ? (Nr = ar.misc.cachedPbkdf2(Er, Cr), Er = Nr.key.slice(0, Cr.ks / 32), Cr.salt = Nr.salt) : ar.ecc && Er instanceof ar.ecc.elGamal.secretKey && (Er = Er.unkem(ar.codec.base64.toBits(Cr.kemtag)).slice(0, Cr.ks / 32)), typeof Ir == "string" && (Ir = ar.codec.utf8String.toBits(Ir)), Nr = new ar.cipher[Cr.cipher](Er), Ir = Cr.mode === "ccm" && ar.arrayBuffer && ar.arrayBuffer.ccm && Cr.ct instanceof ArrayBuffer ? ar.arrayBuffer.ccm.decrypt(Nr, Cr.ct, Cr.iv, Cr.tag, Ir, Cr.ts) : ar.mode[Cr.mode].decrypt(Nr, Cr.ct, Cr.iv, Ir, Cr.ts), Lr.g(Sr, Cr), Sr.key = Er, Tr.raw === 1 ? Ir : ar.codec.utf8String.fromBits(Ir);
  }, decrypt: function(Er, Cr, Tr, Sr) {
    var Lr = ar.json;
    return Lr.ia(Er, Lr.decode(Cr), Tr, Sr);
  }, encode: function(Er) {
    var Cr, Tr = "{", Sr = "";
    for (Cr in Er)
      if (Er.hasOwnProperty(Cr)) {
        if (!Cr.match(/^[a-z0-9]+$/i))
          throw new ar.exception.invalid("json encode: invalid property name");
        switch (Tr += Sr + '"' + Cr + '":', Sr = ",", typeof Er[Cr]) {
          case "number":
          case "boolean":
            Tr += Er[Cr];
            break;
          case "string":
            Tr += '"' + escape(Er[Cr]) + '"';
            break;
          case "object":
            Tr += '"' + ar.codec.base64.fromBits(Er[Cr], 0) + '"';
            break;
          default:
            throw new ar.exception.bug("json encode: unsupported type");
        }
      }
    return Tr + "}";
  }, decode: function(Er) {
    if (Er = Er.replace(/\s/g, ""), !Er.match(/^\{.*\}$/))
      throw new ar.exception.invalid("json decode: this isn't json!");
    Er = Er.replace(/^\{|\}$/g, "").split(/,/);
    var Cr = {}, Tr, Sr;
    for (Tr = 0; Tr < Er.length; Tr++) {
      if (!(Sr = Er[Tr].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))
        throw new ar.exception.invalid("json decode: this isn't json!");
      Sr[3] != null ? Cr[Sr[2]] = parseInt(Sr[3], 10) : Sr[4] != null ? Cr[Sr[2]] = Sr[2].match(/^(ct|adata|salt|iv)$/) ? ar.codec.base64.toBits(Sr[4]) : unescape(Sr[4]) : Sr[5] != null && (Cr[Sr[2]] = Sr[5] === "true");
    }
    return Cr;
  }, g: function(Er, Cr, Tr) {
    if (Er === void 0 && (Er = {}), Cr === void 0)
      return Er;
    for (var Sr in Cr)
      if (Cr.hasOwnProperty(Sr)) {
        if (Tr && Er[Sr] !== void 0 && Er[Sr] !== Cr[Sr])
          throw new ar.exception.invalid("required parameter overridden");
        Er[Sr] = Cr[Sr];
      }
    return Er;
  }, sa: function(Er, Cr) {
    var Tr = {}, Sr;
    for (Sr in Er)
      Er.hasOwnProperty(Sr) && Er[Sr] !== Cr[Sr] && (Tr[Sr] = Er[Sr]);
    return Tr;
  }, ra: function(Er, Cr) {
    var Tr = {}, Sr;
    for (Sr = 0; Sr < Cr.length; Sr++)
      Er[Cr[Sr]] !== void 0 && (Tr[Cr[Sr]] = Er[Cr[Sr]]);
    return Tr;
  } }, ar.encrypt = ar.json.encrypt, ar.decrypt = ar.json.decrypt, ar.misc.pa = {}, ar.misc.cachedPbkdf2 = function(Er, Cr) {
    var Tr = ar.misc.pa, Sr;
    return Cr = Cr || {}, Sr = Cr.iter || 1e3, Tr = Tr[Er] = Tr[Er] || {}, Sr = Tr[Sr] = Tr[Sr] || { firstSalt: Cr.salt && Cr.salt.length ? Cr.salt.slice(0) : ar.random.randomWords(2, 0) }, Tr = Cr.salt === void 0 ? Sr.firstSalt : Cr.salt, Sr[Tr] = Sr[Tr] || ar.misc.pbkdf2(Er, Tr, Cr.iter), { key: Sr[Tr].slice(0), salt: Tr.slice(0) };
  }, cr.exports && (cr.exports = ar);
})(sjcl);
var sjclExports = sjcl.exports, codecBytes = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(cr) {
  return cr && cr.__esModule ? cr : { default: cr };
};
Object.defineProperty(codecBytes, "__esModule", { value: !0 });
codecBytes.sjclcodec = void 0;
const sjcl_1$1 = __importDefault$1(sjclExports);
codecBytes.sjclcodec = {
  /** Convert from a bitArray to an array of bytes. */
  fromBits: function(cr) {
    var ar = [], lr = sjcl_1$1.default.bitArray.bitLength(cr), ur, dr;
    for (ur = 0; ur < lr / 8; ur++)
      ur & 3 || (dr = cr[ur / 4]), ar.push(dr >>> 24), dr <<= 8;
    return ar;
  },
  /** Convert from an array of bytes to a bitArray. */
  /** @return {bitArray} */
  toBits: function(cr) {
    var ar = [], lr, ur = 0;
    for (lr = 0; lr < cr.length; lr++)
      ur = ur << 8 | cr[lr], (lr & 3) === 3 && (ar.push(ur), ur = 0);
    return lr & 3 && ar.push(sjcl_1$1.default.bitArray.partial(8 * (lr & 3), ur)), ar;
  }
};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: !0 });
utils.buf2hex = void 0;
function buf2hex(cr) {
  return [...new Uint8Array(cr)].map((ar) => ar.toString(16).padStart(2, "0")).join("");
}
utils.buf2hex = buf2hex;
(function(cr) {
  var ar = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(gr) {
    return gr && gr.__esModule ? gr : { default: gr };
  };
  Object.defineProperty(cr, "__esModule", { value: !0 }), cr.VoidUploader = cr.UploadState = void 0;
  const lr = ar(sjclExports), ur = codecBytes, dr = utils;
  (function(gr) {
    gr[gr.NotStarted = 0] = "NotStarted", gr[gr.Starting = 1] = "Starting", gr[gr.Hashing = 2] = "Hashing", gr[gr.Uploading = 3] = "Uploading", gr[gr.Done = 4] = "Done", gr[gr.Failed = 5] = "Failed", gr[gr.Challenge = 6] = "Challenge";
  })(cr.UploadState || (cr.UploadState = {}));
  class fr {
    constructor(mr, vr, yr, _r, kr, xr, Ar) {
      ti(this, "uri");
      ti(this, "file");
      ti(this, "auth");
      ti(this, "maxChunkSize");
      ti(this, "onStateChange");
      ti(this, "onProgress");
      ti(this, "onProxyChallenge");
      this.uri = mr, this.file = vr, this.onStateChange = yr, this.onProgress = _r, this.onProxyChallenge = kr, this.auth = xr, this.maxChunkSize = Ar != null ? Ar : Number.MAX_VALUE;
    }
    /**
     * SHA-256 hash the entire blob
     * @param file
     * @protected
     */
    async digest(mr) {
      var kr;
      const yr = new lr.default.hash.sha256();
      let _r = 0;
      for (let xr = 0; xr < Math.ceil(mr.size / 1048576); xr++) {
        const Ar = xr * 1048576, Cr = await mr.slice(Ar, Ar + 1048576).arrayBuffer();
        yr.update(ur.sjclcodec.toBits(new Uint8Array(Cr))), (kr = this.onProgress) == null || kr.call(this, _r += Cr.byteLength);
      }
      return (0, dr.buf2hex)(ur.sjclcodec.fromBits(yr.finalize()));
    }
  }
  cr.VoidUploader = fr;
})(upload);
var streamEncryption = {}, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(cr) {
  return cr && cr.__esModule ? cr : { default: cr };
};
Object.defineProperty(streamEncryption, "__esModule", { value: !0 });
streamEncryption.StreamEncryption = void 0;
const codecBytes_1 = codecBytes, sjcl_1 = __importDefault(sjclExports), utils_1 = utils;
var wo, Ao, Lo, No, Eo;
class StreamEncryption {
  constructor(ar, lr, ur) {
    mo(this, wo, void 0);
    mo(this, Ao, void 0);
    mo(this, Lo, void 0);
    mo(this, No, void 0);
    mo(this, Eo, void 0);
    var dr, fr;
    if (!ar && !lr && (ar = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(16))), lr = (0, utils_1.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(12)))), typeof ar == "string" && typeof lr == "string")
      ar = sjcl_1.default.codec.hex.toBits(ar), lr = sjcl_1.default.codec.hex.toBits(lr);
    else if (!Array.isArray(ar) || !Array.isArray(lr))
      throw "Key and IV must be hex string or bitArray";
    typeof ur == "string" && (ur = JSON.parse(ur)), xo(this, wo, (dr = ur == null ? void 0 : ur.ts) != null ? dr : 128), xo(this, Ao, (fr = ur == null ? void 0 : ur.cs) != null ? fr : 1024 * 1024 * 10), xo(this, Lo, new sjcl_1.default.cipher.aes(ar)), xo(this, No, ar), xo(this, Eo, lr), console.log(`ts=${Ki(this, wo)}, cs=${Ki(this, Ao)}, key=${ar}, iv=${Ki(this, Eo)}`);
  }
  /**
   * Return formatted encryption key
   */
  getKey() {
    return `${sjcl_1.default.codec.hex.fromBits(Ki(this, No))}:${sjcl_1.default.codec.hex.fromBits(Ki(this, Eo))}`;
  }
  /**
   * Get encryption params
   */
  getParams() {
    return {
      ts: Ki(this, wo),
      cs: Ki(this, Ao)
    };
  }
  /**
   * Get encryption TransformStream
   */
  getEncryptionTransform() {
    return this._getCryptoStream(0);
  }
  /**
   * Get decryption TransformStream
   */
  getDecryptionTransform() {
    return this._getCryptoStream(1);
  }
  _getCryptoStream(ar) {
    let lr = 0, ur = new Uint8Array(Ki(this, Ao) + (ar === 1 ? Ki(this, wo) / 8 : 0));
    return new TransformStream({
      transform: async (dr, fr) => {
        dr = await dr;
        try {
          let gr = Math.min(dr.byteLength, ur.byteLength - lr);
          if (ur.set(dr.slice(0, gr), lr), lr += gr, lr === ur.byteLength) {
            let mr = codecBytes_1.sjclcodec.toBits(ur), vr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(Ki(this, Lo), mr, Ki(this, Eo), [], Ki(this, wo)) : sjcl_1.default.mode.gcm.decrypt(Ki(this, Lo), mr, Ki(this, Eo), [], Ki(this, wo)));
            fr.enqueue(new Uint8Array(vr)), lr = dr.byteLength - gr, ur.set(dr.slice(gr));
          }
        } catch (gr) {
          throw console.error(gr), gr;
        }
      },
      flush: (dr) => {
        let fr = ur.slice(0, lr), gr = codecBytes_1.sjclcodec.toBits(fr), mr = codecBytes_1.sjclcodec.fromBits(ar === 0 ? sjcl_1.default.mode.gcm.encrypt(Ki(this, Lo), gr, Ki(this, Eo), [], Ki(this, wo)) : sjcl_1.default.mode.gcm.decrypt(Ki(this, Lo), gr, Ki(this, Eo), [], Ki(this, wo)));
        dr.enqueue(new Uint8Array(mr));
      }
    }, {
      highWaterMark: Ki(this, Ao)
    });
  }
}
wo = new WeakMap(), Ao = new WeakMap(), Lo = new WeakMap(), No = new WeakMap(), Eo = new WeakMap();
streamEncryption.StreamEncryption = StreamEncryption;
Object.defineProperty(streamUploader, "__esModule", { value: !0 });
streamUploader.StreamUploader = void 0;
const upload_1$1 = upload, stream_encryption_1 = streamEncryption;
var Co;
class StreamUploader extends upload_1$1.VoidUploader {
  constructor() {
    super(...arguments);
    mo(this, Co, void 0);
  }
  static canUse() {
    const lr = globalThis.navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    return (lr ? parseInt(lr[2], 10) : 0) >= 105 && "getRandomValues" in globalThis.crypto && globalThis.location.protocol === "https:";
  }
  canEncrypt() {
    return !0;
  }
  setEncryption(lr) {
    lr ? xo(this, Co, new stream_encryption_1.StreamEncryption(void 0, void 0, void 0)) : xo(this, Co, void 0);
  }
  getEncryptionKey() {
    var lr;
    return (lr = Ki(this, Co)) == null ? void 0 : lr.getKey();
  }
  async upload(lr) {
    var _r;
    (_r = this.onStateChange) == null || _r.call(this, upload_1$1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    let dr = 0;
    const fr = 1024 * 1024, gr = new ReadableStream({
      start: async () => {
        var kr;
        (kr = this.onStateChange) == null || kr.call(this, upload_1$1.UploadState.Uploading);
      },
      pull: async (kr) => {
        var Ar, Er;
        const xr = await this.readChunk(dr, (Ar = kr.desiredSize) != null ? Ar : fr);
        if (xr.byteLength === 0) {
          kr.close();
          return;
        }
        (Er = this.onProgress) == null || Er.call(this, dr + xr.byteLength), dr += xr.byteLength, kr.enqueue(xr);
      },
      cancel: (kr) => {
        console.log(kr);
      },
      type: "bytes"
    }, {
      highWaterMark: fr
    }), mr = `${this.uri}/upload`, vr = {
      "Content-Type": "application/octet-stream",
      "V-Content-Type": this.file.type ? this.file.type : "application/octet-stream",
      "V-Filename": "name" in this.file ? this.file.name : "",
      "V-Full-Digest": ur
    };
    Ki(this, Co) && (vr["V-EncryptionParams"] = JSON.stringify(Ki(this, Co).getParams())), this.auth && (vr.Authorization = await this.auth(mr, "POST"));
    const yr = await fetch(mr, {
      method: "POST",
      mode: "cors",
      body: Ki(this, Co) ? gr.pipeThrough(Ki(this, Co).getEncryptionTransform()) : gr,
      headers: {
        ...vr,
        ...lr
      },
      // @ts-ignore New stream spec
      duplex: "half"
    });
    if (yr.ok)
      return await yr.json();
    throw new Error("Unknown error");
  }
  async readChunk(lr, ur) {
    if (lr > this.file.size)
      return new Uint8Array(0);
    const dr = Math.min(lr + ur, this.file.size), gr = await this.file.slice(lr, dr, this.file.type).arrayBuffer();
    return new Uint8Array(gr);
  }
}
Co = new WeakMap();
streamUploader.StreamUploader = StreamUploader;
var xhrUploader = {};
Object.defineProperty(xhrUploader, "__esModule", { value: !0 });
xhrUploader.XHRUploader = void 0;
const upload_1 = upload;
var Do, Ko, Mo, Fo;
class XHRUploader extends upload_1.VoidUploader {
  constructor() {
    super(...arguments);
    mo(this, Do);
    /**
     * Upload a segment of the file
     * @param segment
     * @param fullDigest Full file hash
     * @param id
     * @param editSecret
     * @param part Segment number
     * @param partOf Total number of segments
     * @param headers
     */
    mo(this, Mo);
  }
  canEncrypt() {
    return !1;
  }
  setEncryption() {
  }
  getEncryptionKey() {
  }
  async upload(lr) {
    var dr;
    (dr = this.onStateChange) == null || dr.call(this, upload_1.UploadState.Hashing);
    const ur = await this.digest(this.file);
    return this.file.size > this.maxChunkSize ? await no(this, Do, Ko).call(this, ur, this.maxChunkSize, lr) : await no(this, Mo, Fo).call(this, this.file, ur, void 0, void 0, 1, 1, lr);
  }
}
Do = new WeakSet(), Ko = async function(lr, ur, dr) {
  var mr, vr, yr;
  let fr = null;
  const gr = Math.ceil(this.file.size / ur);
  for (let _r = 0; _r < gr; _r++) {
    const kr = _r * ur, xr = this.file.slice(kr, kr + ur, this.file.type);
    if (fr = await no(this, Mo, Fo).call(this, xr, lr, (mr = fr == null ? void 0 : fr.file) == null ? void 0 : mr.id, (yr = (vr = fr == null ? void 0 : fr.file) == null ? void 0 : vr.metadata) == null ? void 0 : yr.editSecret, _r + 1, gr, dr), !fr.ok)
      break;
  }
  return fr;
}, Mo = new WeakSet(), Fo = async function(lr, ur, dr, fr, gr, mr, vr) {
  var kr;
  (kr = this.onStateChange) == null || kr.call(this, upload_1.UploadState.Uploading);
  const yr = dr ? `${this.uri}/upload/${dr}` : `${this.uri}/upload`, _r = this.auth ? await this.auth(yr, "POST") : void 0;
  return await new Promise((xr, Ar) => {
    try {
      const Er = new XMLHttpRequest();
      if (Er.onreadystatechange = () => {
        var Cr, Tr;
        if (Er.readyState === XMLHttpRequest.DONE && Er.status === 200) {
          const Sr = JSON.parse(Er.responseText);
          xr(Sr);
        } else if (Er.readyState === XMLHttpRequest.DONE && Er.status === 403) {
          const Sr = Er.getResponseHeader("content-type");
          (Sr == null ? void 0 : Sr.toLowerCase().trim().indexOf("text/html")) === 0 && ((Cr = this.onProxyChallenge) == null || Cr.call(this, Er.response), (Tr = this.onStateChange) == null || Tr.call(this, upload_1.UploadState.Challenge), Ar(new Error("CF Challenge")));
        }
      }, Er.upload.onprogress = (Cr) => {
        var Tr;
        Cr instanceof ProgressEvent && ((Tr = this.onProgress) == null || Tr.call(this, Cr.loaded));
      }, Er.open("POST", yr), Er.setRequestHeader("Content-Type", "application/octet-stream"), Er.setRequestHeader("V-Content-Type", this.file.type ? this.file.type : "application/octet-stream"), Er.setRequestHeader("V-Filename", "name" in this.file ? this.file.name : ""), Er.setRequestHeader("V-Full-Digest", ur), Er.setRequestHeader("V-Segment", `${gr}/${mr}`), _r && (Er.withCredentials = !0, Er.setRequestHeader("Authorization", _r)), fr && Er.setRequestHeader("V-EditSecret", fr), vr)
        for (const [Cr, Tr] of Object.entries(vr))
          Er.setRequestHeader(Cr, Tr);
      Er.send(lr);
    } catch (Er) {
      Ar(Er);
    }
  });
};
xhrUploader.XHRUploader = XHRUploader;
var hasRequiredApi;
function requireApi() {
  var dr, fr, gr, so;
  if (hasRequiredApi)
    return api;
  hasRequiredApi = 1, Object.defineProperty(api, "__esModule", { value: !0 }), api.VoidApi = void 0;
  const cr = requireDist(), ar = streamUploader, lr = xhrUploader;
  class ur {
    constructor(yr, _r) {
      mo(this, gr);
      mo(this, dr, void 0);
      mo(this, fr, void 0);
      xo(this, dr, yr), xo(this, fr, _r);
    }
    /**
     * Get uploader for uploading files
     */
    getUploader(yr, _r, kr, xr, Ar) {
      return ar.StreamUploader.canUse() ? new ar.StreamUploader(Ki(this, dr), yr, _r, kr, xr, Ki(this, fr), Ar) : new lr.XHRUploader(Ki(this, dr), yr, _r, kr, xr, Ki(this, fr), Ar);
    }
    /**
     * General site information
     */
    info() {
      return no(this, gr, so).call(this, "GET", "/info");
    }
    fileInfo(yr) {
      return no(this, gr, so).call(this, "GET", `/upload/${yr}`);
    }
    setPaymentConfig(yr, _r) {
      return no(this, gr, so).call(this, "POST", `/upload/${yr}/payment`, _r);
    }
    createOrder(yr) {
      return no(this, gr, so).call(this, "GET", `/upload/${yr}/payment`);
    }
    getOrder(yr, _r) {
      return no(this, gr, so).call(this, "GET", `/upload/${yr}/payment/${_r}`);
    }
    login(yr, _r, kr) {
      return no(this, gr, so).call(this, "POST", "/auth/login", {
        username: yr,
        password: _r,
        captcha: kr
      });
    }
    register(yr, _r, kr) {
      return no(this, gr, so).call(this, "POST", "/auth/register", {
        username: yr,
        password: _r,
        captcha: kr
      });
    }
    getUser(yr) {
      return no(this, gr, so).call(this, "GET", `/user/${yr}`);
    }
    updateUser(yr) {
      return no(this, gr, so).call(this, "POST", `/user/${yr.id}`, yr);
    }
    listUserFiles(yr, _r) {
      return no(this, gr, so).call(this, "POST", `/user/${yr}/files`, _r);
    }
    submitVerifyCode(yr, _r) {
      return no(this, gr, so).call(this, "POST", `/user/${yr}/verify`, { code: _r });
    }
    sendNewCode(yr) {
      return no(this, gr, so).call(this, "GET", `/user/${yr}/verify`);
    }
    updateFileMetadata(yr, _r) {
      return no(this, gr, so).call(this, "POST", `/upload/${yr}/meta`, _r);
    }
    listApiKeys() {
      return no(this, gr, so).call(this, "GET", "/auth/api-key");
    }
    createApiKey(yr) {
      return no(this, gr, so).call(this, "POST", "/auth/api-key", yr);
    }
    adminListFiles(yr) {
      return no(this, gr, so).call(this, "POST", "/admin/file", yr);
    }
    adminDeleteFile(yr) {
      return no(this, gr, so).call(this, "DELETE", `/admin/file/${yr}`);
    }
    adminUserList(yr) {
      return no(this, gr, so).call(this, "POST", "/admin/users", yr);
    }
    adminUpdateUser(yr) {
      return no(this, gr, so).call(this, "POST", "/admin/update-user", yr);
    }
  }
  return dr = new WeakMap(), fr = new WeakMap(), gr = new WeakSet(), so = async function(yr, _r, kr) {
    const xr = `${Ki(this, dr)}${_r}`, Ar = {
      Accept: "application/json"
    };
    Ki(this, fr) && (Ar.Authorization = await Ki(this, fr).call(this, xr, yr)), kr && (Ar["Content-Type"] = "application/json");
    const Er = await fetch(xr, {
      method: yr,
      headers: Ar,
      mode: "cors",
      body: kr ? JSON.stringify(kr) : void 0
    }), Cr = await Er.text();
    if (Er.ok)
      return Cr ? JSON.parse(Cr) : {};
    throw new cr.ApiError(Er.status, Cr);
  }, api.VoidApi = ur, api;
}
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(cr) {
    Object.defineProperty(cr, "__esModule", { value: !0 }), cr.PageSortOrder = cr.PagedSortBy = cr.PaymentOrderState = cr.PaymentServices = cr.PaymentCurrencies = cr.ApiError = cr.StreamEncryption = cr.UploadState = cr.VoidApi = void 0;
    var ar = requireApi();
    Object.defineProperty(cr, "VoidApi", { enumerable: !0, get: function() {
      return ar.VoidApi;
    } });
    var lr = upload;
    Object.defineProperty(cr, "UploadState", { enumerable: !0, get: function() {
      return lr.UploadState;
    } });
    var ur = streamEncryption;
    Object.defineProperty(cr, "StreamEncryption", { enumerable: !0, get: function() {
      return ur.StreamEncryption;
    } });
    class dr extends Error {
      constructor(mr, vr) {
        super(vr);
        ti(this, "statusCode");
        this.statusCode = mr;
      }
    }
    cr.ApiError = dr, function(fr) {
      fr[fr.BTC = 0] = "BTC", fr[fr.USD = 1] = "USD", fr[fr.EUR = 2] = "EUR", fr[fr.GBP = 3] = "GBP";
    }(cr.PaymentCurrencies || (cr.PaymentCurrencies = {})), function(fr) {
      fr[fr.None = 0] = "None", fr[fr.Strike = 1] = "Strike";
    }(cr.PaymentServices || (cr.PaymentServices = {})), function(fr) {
      fr[fr.Unpaid = 0] = "Unpaid", fr[fr.Paid = 1] = "Paid", fr[fr.Expired = 2] = "Expired";
    }(cr.PaymentOrderState || (cr.PaymentOrderState = {})), function(fr) {
      fr[fr.Name = 0] = "Name", fr[fr.Date = 1] = "Date", fr[fr.Size = 2] = "Size", fr[fr.Id = 3] = "Id";
    }(cr.PagedSortBy || (cr.PagedSortBy = {})), function(fr) {
      fr[fr.Asc = 0] = "Asc", fr[fr.Dsc = 1] = "Dsc";
    }(cr.PageSortOrder || (cr.PageSortOrder = {}));
  }(dist)), dist;
}
var distExports = requireDist();
function create_fragment$f(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = element("style"), lr = space(), ur = element("div");
    },
    m(dr, fr) {
      insert(dr, ar, fr), ar.innerHTML = css, insert(dr, lr, fr), insert(dr, ur, fr), cr[5](ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && (detach(ar), detach(lr), detach(ur)), cr[5](null);
    }
  };
}
const FILE_EXT_REGEX$1 = /\.([\w]{1,7})$/i;
function instance$6(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, ndkStore, (Tr) => lr(6, ur = Tr)), component_subscribe(cr, localStore, (Tr) => lr(7, dr = Tr));
  let { opinionContent: fr } = ar, { fileArray: gr } = ar, mr, vr, yr = !1;
  const _r = uploadUrl, kr = new distExports.VoidApi(_r), xr = (Tr) => {
    const Sr = /(?<!\]\()https?:\/\/\S*\.(jpg|jpeg|png|gif|svg|webp)(?!\))/g;
    return Tr.replace(Sr, (Lr) => Lr.startsWith("![](") ? Lr : `![](${Lr})`);
  }, Ar = async (Tr) => {
    var Nr, Rr, Mr, Br, Dr, Hr;
    console.log(Tr);
    const Sr = dr.pk;
    Sr ? !ur.signer && await privkeyLogin(Sr) : !ur.signer && await NDKlogin();
    const Ir = await kr.getUploader(Tr).upload({ "V-Strip-Metadata": "true" });
    if (Ir.ok) {
      let Fr = Tr.name.match(FILE_EXT_REGEX$1);
      console.log(Fr), ((Rr = (Nr = Ir.file) == null ? void 0 : Nr.metadata) == null ? void 0 : Rr.mimeType) === "image/webp" && (Fr = ["", "webp"]);
      const zr = (Hr = (Br = (Mr = Ir.file) == null ? void 0 : Mr.metadata) == null ? void 0 : Br.url) != null ? Hr : `${_r}/d/${(Dr = Ir.file) == null ? void 0 : Dr.id}${Fr ? `.${Fr[1]}` : ""}`;
      return lr(2, gr = [...gr, { files: Tr, url: zr }]), zr;
    }
    return "";
  }, Er = () => {
    lr(4, yr = !0), lr(1, fr = vr.getMarkdown());
  };
  onMount(() => {
    lr(1, fr = fr.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), lr(3, vr = new ToastUIEditor({
      el: mr,
      height: "200px",
      initialEditType: "markdown",
      previewStyle: "tab",
      initialValue: fr,
      theme: "dark",
      events: {
        change() {
          Er();
        }
      },
      hooks: {
        addImageBlobHook: async (Tr, Sr) => {
          const Lr = await Ar(Tr);
          Lr && Sr(Lr, "image");
        }
      },
      extendedAutolinks: !0
    })), vr.getMarkdown();
  });
  function Cr(Tr) {
    binding_callbacks[Tr ? "unshift" : "push"](() => {
      mr = Tr, lr(0, mr);
    });
  }
  return cr.$$set = (Tr) => {
    "opinionContent" in Tr && lr(1, fr = Tr.opinionContent), "fileArray" in Tr && lr(2, gr = Tr.fileArray);
  }, cr.$$.update = () => {
    if (cr.$$.dirty & /*editor, isInternalUpdate, opinionContent*/
    26) {
      if (vr && !yr) {
        const Tr = vr.getMarkdown();
        fr !== Tr && (lr(1, fr = xr(fr)), vr.setMarkdown(fr));
      }
      lr(4, yr = !1);
    }
  }, [mr, fr, gr, vr, yr, Cr];
}
class Editor_1 extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$6, create_fragment$f, safe_not_equal, { opinionContent: 1, fileArray: 2 });
  }
  get opinionContent() {
    return this.$$.ctx[1];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
}
create_custom_element(Editor_1, { opinionContent: {}, fileArray: {} }, [], [], !0);
function create_fragment$e(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 17.7917L8.79169 16.6917C4.50002 12.8 1.66669 10.225 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5C16.3167 2.5 18.3334 4.50833 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917Z"), attr(ur, "fill", "black"), attr(lr, "opacity", "0.25"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class LikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$e, safe_not_equal, {});
  }
}
create_custom_element(LikeButton, {}, [], [], !0);
function create_fragment$d(cr) {
  let ar, lr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), attr(lr, "d", "M10 18.35L8.55 17.03C3.4 12.36 0 9.27 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0C17.58 0 20 2.41 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35Z"), attr(lr, "fill", "black"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, dr) {
      insert(ur, ar, dr), append(ar, lr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class LikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$d, safe_not_equal, {});
  }
}
create_custom_element(LikedButton, {}, [], [], !0);
function create_fragment$c(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("g"), ur = svg_element("path"), attr(ur, "fill-rule", "evenodd"), attr(ur, "clip-rule", "evenodd"), attr(ur, "d", "M13.75 2.5C14.5376 2.5 15.2734 2.68911 15.9151 3.02568L5.40369 13.5371C3.07255 11.2282 1.66669 9.29634 1.66669 7.08333C1.66669 4.50833 3.68335 2.5 6.25002 2.5C7.70002 2.5 9.09169 3.175 10 4.23333C10.9084 3.175 12.3 2.5 13.75 2.5ZM8.79169 16.6917C7.98933 15.9641 7.23794 15.2825 6.54651 14.6347L17.1749 4.00627C17.8982 4.81336 18.3334 5.88721 18.3334 7.08333C18.3334 10.225 15.5 12.8 11.2084 16.6917L10 17.7917L8.79169 16.6917Z"), attr(ur, "fill", "black"), attr(lr, "opacity", "0.25"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class DislikeButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$c, safe_not_equal, {});
  }
}
create_custom_element(DislikeButton, {}, [], [], !0);
function create_fragment$b(cr) {
  let ar, lr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), attr(lr, "fill-rule", "evenodd"), attr(lr, "clip-rule", "evenodd"), attr(lr, "d", "M14.5 0C15.4451 0 16.3281 0.226936 17.0981 0.630818L4.48441 13.2445C1.68704 10.4738 0 8.15561 0 5.5C0 2.41 2.42 0 5.5 0C7.24 0 8.91 0.81 10 2.08C11.09 0.81 12.76 0 14.5 0ZM8.55 17.03C7.58717 16.1569 6.68551 15.339 5.85579 14.5616L18.6099 1.80753C19.4778 2.77603 20 4.06465 20 5.5C20 9.27 16.6 12.36 11.45 17.03L10 18.35L8.55 17.03Z"), attr(lr, "fill", "black"), attr(ar, "width", "20"), attr(ar, "height", "19"), attr(ar, "viewBox", "0 0 20 19"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(ur, dr) {
      insert(ur, ar, dr), append(ar, lr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar);
    }
  };
}
class DislikedButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$b, safe_not_equal, {});
  }
}
create_custom_element(DislikedButton, {}, [], [], !0);
function create_fragment$a(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("g"), ur = svg_element("path"), attr(ur, "d", "M10 4L3 10L10 16V12.5C10 12.5 14.802 11.9579 17.2115 14.3323C17.2115 7.91272 10 7.5 10 7.5V4Z"), attr(ur, "fill", "black"), attr(lr, "opacity", "0.25"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(lr, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class ReplyButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$a, safe_not_equal, {});
  }
}
create_custom_element(ReplyButton, {}, [], [], !0);
function create_fragment$9(cr) {
  let ar, lr, ur, dr, fr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("g"), ur = svg_element("circle"), dr = svg_element("circle"), fr = svg_element("circle"), attr(ur, "cx", "3.66669"), attr(ur, "cy", "9.6665"), attr(ur, "r", "2"), attr(ur, "fill", "black"), attr(dr, "cx", "9.66669"), attr(dr, "cy", "9.6665"), attr(dr, "r", "2"), attr(dr, "fill", "black"), attr(fr, "cx", "15.6667"), attr(fr, "cy", "9.6665"), attr(fr, "r", "2"), attr(fr, "fill", "black"), attr(lr, "opacity", "0.25"), attr(ar, "width", "20"), attr(ar, "height", "20"), attr(ar, "viewBox", "0 0 20 20"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, lr), append(lr, ur), append(lr, dr), append(lr, fr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar);
    }
  };
}
class OptionButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$9, safe_not_equal, {});
  }
}
create_custom_element(OptionButton, {}, [], [], !0);
function create_fragment$8(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("rect"), ur = svg_element("path"), attr(lr, "y", "0.5"), attr(lr, "width", "106"), attr(lr, "height", "17"), attr(lr, "rx", "3"), attr(lr, "fill", "#F7931A"), attr(ur, "d", "M9.1985 10.07L8.3075 7.703C8.2355 7.52 8.162 7.2875 8.087 7.0055C8.054 7.1465 8.018 7.277 7.979 7.397C7.94 7.514 7.904 7.6175 7.871 7.7075L6.98 10.07H9.1985ZM11.192 12.5H10.3775C10.2845 12.5 10.2095 12.4775 10.1525 12.4325C10.0955 12.3845 10.052 12.326 10.022 12.257L9.482 10.826H6.692L6.152 12.257C6.128 12.317 6.086 12.3725 6.026 12.4235C5.966 12.4745 5.891 12.5 5.801 12.5H4.9865L7.556 6.02H8.6225L11.192 12.5ZM13.9642 9.323C14.1982 9.323 14.4037 9.293 14.5807 9.233C14.7607 9.173 14.9092 9.089 15.0262 8.981C15.1462 8.87 15.2362 8.7365 15.2962 8.5805C15.3562 8.4245 15.3862 8.2505 15.3862 8.0585C15.3862 7.8695 15.3562 7.7 15.2962 7.55C15.2392 7.4 15.1522 7.2725 15.0352 7.1675C14.9182 7.0625 14.7697 6.983 14.5897 6.929C14.4127 6.872 14.2042 6.8435 13.9642 6.8435H13.0012V9.323H13.9642ZM13.9642 6.02C14.3872 6.02 14.7532 6.0695 15.0622 6.1685C15.3742 6.2675 15.6307 6.407 15.8317 6.587C16.0357 6.764 16.1872 6.9785 16.2862 7.2305C16.3852 7.4795 16.4347 7.7555 16.4347 8.0585C16.4347 8.3675 16.3822 8.651 16.2772 8.909C16.1722 9.164 16.0162 9.3845 15.8092 9.5705C15.6022 9.7535 15.3442 9.8975 15.0352 10.0025C14.7292 10.1045 14.3722 10.1555 13.9642 10.1555H13.0012V12.5H11.9482V6.02H13.9642ZM19.4574 9.323C19.6914 9.323 19.8969 9.293 20.0739 9.233C20.2539 9.173 20.4024 9.089 20.5194 8.981C20.6394 8.87 20.7294 8.7365 20.7894 8.5805C20.8494 8.4245 20.8794 8.2505 20.8794 8.0585C20.8794 7.8695 20.8494 7.7 20.7894 7.55C20.7324 7.4 20.6454 7.2725 20.5284 7.1675C20.4114 7.0625 20.2629 6.983 20.0829 6.929C19.9059 6.872 19.6974 6.8435 19.4574 6.8435H18.4944V9.323H19.4574ZM19.4574 6.02C19.8804 6.02 20.2464 6.0695 20.5554 6.1685C20.8674 6.2675 21.1239 6.407 21.3249 6.587C21.5289 6.764 21.6804 6.9785 21.7794 7.2305C21.8784 7.4795 21.9279 7.7555 21.9279 8.0585C21.9279 8.3675 21.8754 8.651 21.7704 8.909C21.6654 9.164 21.5094 9.3845 21.3024 9.5705C21.0954 9.7535 20.8374 9.8975 20.5284 10.0025C20.2224 10.1045 19.8654 10.1555 19.4574 10.1555H18.4944V12.5H17.4414V6.02H19.4574ZM24.8155 9.125C25.0555 9.125 25.2655 9.0965 25.4455 9.0395C25.6255 8.9795 25.7755 8.897 25.8955 8.792C26.0155 8.687 26.1055 8.5625 26.1655 8.4185C26.2255 8.2715 26.2555 8.1095 26.2555 7.9325C26.2555 7.5785 26.1385 7.3085 25.9045 7.1225C25.6705 6.9365 25.3165 6.8435 24.8425 6.8435H23.9875V9.125H24.8155ZM27.8665 12.5H26.926C26.74 12.5 26.605 12.428 26.521 12.284L25.009 10.1015C24.958 10.0265 24.9025 9.9725 24.8425 9.9395C24.7825 9.9065 24.6925 9.89 24.5725 9.89H23.9875V12.5H22.9345V6.02H24.8425C25.2685 6.02 25.6345 6.0635 25.9405 6.1505C26.2495 6.2375 26.503 6.362 26.701 6.524C26.899 6.683 27.0445 6.875 27.1375 7.1C27.2335 7.325 27.2815 7.5755 27.2815 7.8515C27.2815 8.0765 27.247 8.2865 27.178 8.4815C27.112 8.6765 27.0145 8.8535 26.8855 9.0125C26.7595 9.1715 26.6035 9.3095 26.4175 9.4265C26.2315 9.5435 26.02 9.635 25.783 9.701C25.912 9.779 26.023 9.8885 26.116 10.0295L27.8665 12.5ZM34.6568 9.26C34.6568 9.74 34.5788 10.1825 34.4228 10.5875C34.2668 10.9925 34.0463 11.342 33.7613 11.636C33.4793 11.927 33.1388 12.155 32.7398 12.32C32.3438 12.485 31.9028 12.5675 31.4168 12.5675C30.9338 12.5675 30.4928 12.485 30.0938 12.32C29.6978 12.155 29.3573 11.927 29.0723 11.636C28.7873 11.342 28.5668 10.9925 28.4108 10.5875C28.2548 10.1825 28.1768 9.74 28.1768 9.26C28.1768 8.78 28.2548 8.3375 28.4108 7.9325C28.5668 7.5275 28.7873 7.178 29.0723 6.884C29.3573 6.59 29.6978 6.3605 30.0938 6.1955C30.4928 6.0305 30.9338 5.948 31.4168 5.948C31.9028 5.948 32.3438 6.0305 32.7398 6.1955C33.1388 6.3605 33.4793 6.59 33.7613 6.884C34.0463 7.178 34.2668 7.5275 34.4228 7.9325C34.5788 8.3375 34.6568 8.78 34.6568 9.26ZM33.5813 9.26C33.5813 8.888 33.5303 8.5535 33.4283 8.2565C33.3293 7.9595 33.1853 7.7075 32.9963 7.5005C32.8103 7.2935 32.5838 7.1345 32.3168 7.0235C32.0498 6.9125 31.7498 6.857 31.4168 6.857C31.0868 6.857 30.7883 6.9125 30.5213 7.0235C30.2543 7.1345 30.0263 7.2935 29.8373 7.5005C29.6483 7.7075 29.5028 7.9595 29.4008 8.2565C29.2988 8.5535 29.2478 8.888 29.2478 9.26C29.2478 9.635 29.2988 9.971 29.4008 10.268C29.5028 10.565 29.6483 10.817 29.8373 11.024C30.0263 11.228 30.2543 11.3855 30.5213 11.4965C30.7883 11.6045 31.0868 11.6585 31.4168 11.6585C31.7498 11.6585 32.0498 11.6045 32.3168 11.4965C32.5838 11.3855 32.8103 11.228 32.9963 11.024C33.1853 10.817 33.3293 10.565 33.4283 10.268C33.5303 9.971 33.5813 9.635 33.5813 9.26ZM41.0309 6.02L38.4029 12.5H37.4534L34.8254 6.02H35.6669C35.7599 6.02 35.8349 6.044 35.8919 6.092C35.9489 6.137 35.9924 6.194 36.0224 6.263L37.6919 10.4885C37.7819 10.7255 37.8644 10.9985 37.9394 11.3075C37.9724 11.1545 38.0069 11.009 38.0429 10.871C38.0819 10.733 38.1239 10.6055 38.1689 10.4885L39.8339 6.263C39.8579 6.203 39.8999 6.1475 39.9599 6.0965C40.0199 6.0455 40.0949 6.02 40.1849 6.02H41.0309ZM45.8326 11.6495L45.8281 12.5H41.7871V6.02H45.8281V6.8705H42.8446V8.8235H45.2296V9.647H42.8446V11.6495H45.8326ZM52.6606 9.26C52.6606 9.74 52.5826 10.1795 52.4266 10.5785C52.2706 10.9745 52.0501 11.315 51.7651 11.6C51.4831 11.885 51.1426 12.107 50.7436 12.266C50.3476 12.422 49.9066 12.5 49.4206 12.5H46.9726V6.02H49.4206C49.9066 6.02 50.3476 6.0995 50.7436 6.2585C51.1426 6.4145 51.4831 6.635 51.7651 6.92C52.0501 7.205 52.2706 7.547 52.4266 7.946C52.5826 8.342 52.6606 8.78 52.6606 9.26ZM51.5851 9.26C51.5851 8.888 51.5341 8.5535 51.4321 8.2565C51.3331 7.9595 51.1891 7.709 51.0001 7.505C50.8141 7.301 50.5876 7.145 50.3206 7.037C50.0536 6.926 49.7536 6.8705 49.4206 6.8705H48.0301V11.6495H49.4206C49.7536 11.6495 50.0536 11.5955 50.3206 11.4875C50.5876 11.3795 50.8141 11.2235 51.0001 11.0195C51.1891 10.8125 51.3331 10.562 51.4321 10.268C51.5341 9.971 51.5851 9.635 51.5851 9.26ZM57.9415 9.125C58.1815 9.125 58.3915 9.0965 58.5715 9.0395C58.7515 8.9795 58.9015 8.897 59.0215 8.792C59.1415 8.687 59.2315 8.5625 59.2915 8.4185C59.3515 8.2715 59.3815 8.1095 59.3815 7.9325C59.3815 7.5785 59.2645 7.3085 59.0305 7.1225C58.7965 6.9365 58.4425 6.8435 57.9685 6.8435H57.1135V9.125H57.9415ZM60.9925 12.5H60.052C59.866 12.5 59.731 12.428 59.647 12.284L58.135 10.1015C58.084 10.0265 58.0285 9.9725 57.9685 9.9395C57.9085 9.9065 57.8185 9.89 57.6985 9.89H57.1135V12.5H56.0605V6.02H57.9685C58.3945 6.02 58.7605 6.0635 59.0665 6.1505C59.3755 6.2375 59.629 6.362 59.827 6.524C60.025 6.683 60.1705 6.875 60.2635 7.1C60.3595 7.325 60.4075 7.5755 60.4075 7.8515C60.4075 8.0765 60.373 8.2865 60.304 8.4815C60.238 8.6765 60.1405 8.8535 60.0115 9.0125C59.8855 9.1715 59.7295 9.3095 59.5435 9.4265C59.3575 9.5435 59.146 9.635 58.909 9.701C59.038 9.779 59.149 9.8885 59.242 10.0295L60.9925 12.5ZM65.8189 11.6495L65.8144 12.5H61.7734V6.02H65.8144V6.8705H62.8309V8.8235H65.2159V9.647H62.8309V11.6495H65.8189ZM72.3815 6.02L69.7535 12.5H68.804L66.176 6.02H67.0175C67.1105 6.02 67.1855 6.044 67.2425 6.092C67.2995 6.137 67.343 6.194 67.373 6.263L69.0425 10.4885C69.1325 10.7255 69.215 10.9985 69.29 11.3075C69.323 11.1545 69.3575 11.009 69.3935 10.871C69.4325 10.733 69.4745 10.6055 69.5195 10.4885L71.1845 6.263C71.2085 6.203 71.2505 6.1475 71.3105 6.0965C71.3705 6.0455 71.4455 6.02 71.5355 6.02H72.3815ZM74.1952 12.5H73.1377V6.02H74.1952V12.5ZM79.7759 11.6495L79.7714 12.5H75.7304V6.02H79.7714V6.8705H76.7879V8.8235H79.1729V9.647H76.7879V11.6495H79.7759ZM89.4345 6.02L87.4185 12.5H86.469L84.948 7.847C84.93 7.796 84.912 7.7405 84.894 7.6805C84.879 7.6205 84.864 7.556 84.849 7.487C84.834 7.556 84.8175 7.6205 84.7995 7.6805C84.7845 7.7405 84.768 7.796 84.75 7.847L83.2155 12.5H82.266L80.25 6.02H81.132C81.222 6.02 81.297 6.0425 81.357 6.0875C81.42 6.1295 81.462 6.188 81.483 6.263L82.698 10.4165C82.722 10.5065 82.7445 10.604 82.7655 10.709C82.7865 10.814 82.8075 10.9235 82.8285 11.0375C82.8495 10.9235 82.872 10.814 82.896 10.709C82.923 10.601 82.9515 10.5035 82.9815 10.4165L84.372 6.263C84.393 6.203 84.435 6.1475 84.498 6.0965C84.561 6.0455 84.636 6.02 84.723 6.02H85.029C85.122 6.02 85.197 6.044 85.254 6.092C85.311 6.137 85.3545 6.194 85.3845 6.263L86.7705 10.4165C86.8005 10.5035 86.8275 10.598 86.8515 10.7C86.8785 10.799 86.9025 10.904 86.9235 11.015C86.9445 10.904 86.964 10.799 86.982 10.7C87.003 10.598 87.0255 10.5035 87.0495 10.4165L88.26 6.263C88.278 6.197 88.3185 6.14 88.3815 6.092C88.4475 6.044 88.524 6.02 88.611 6.02H89.4345ZM94.357 11.6495L94.3525 12.5H90.3115V6.02H94.3525V6.8705H91.369V8.8235H93.754V9.647H91.369V11.6495H94.357ZM97.378 9.125C97.618 9.125 97.828 9.0965 98.008 9.0395C98.188 8.9795 98.338 8.897 98.458 8.792C98.578 8.687 98.668 8.5625 98.728 8.4185C98.788 8.2715 98.818 8.1095 98.818 7.9325C98.818 7.5785 98.701 7.3085 98.467 7.1225C98.233 6.9365 97.879 6.8435 97.405 6.8435H96.55V9.125H97.378ZM100.429 12.5H99.4885C99.3025 12.5 99.1675 12.428 99.0835 12.284L97.5715 10.1015C97.5205 10.0265 97.465 9.9725 97.405 9.9395C97.345 9.9065 97.255 9.89 97.135 9.89H96.55V12.5H95.497V6.02H97.405C97.831 6.02 98.197 6.0635 98.503 6.1505C98.812 6.2375 99.0655 6.362 99.2635 6.524C99.4615 6.683 99.607 6.875 99.7 7.1C99.796 7.325 99.844 7.5755 99.844 7.8515C99.844 8.0765 99.8095 8.2865 99.7405 8.4815C99.6745 8.6765 99.577 8.8535 99.448 9.0125C99.322 9.1715 99.166 9.3095 98.98 9.4265C98.794 9.5435 98.5825 9.635 98.3455 9.701C98.4745 9.779 98.5855 9.8885 98.6785 10.0295L100.429 12.5Z"), attr(ur, "fill", "white"), attr(ar, "width", "106"), attr(ar, "height", "18"), attr(ar, "viewBox", "0 0 106 18"), attr(ar, "fill", "none"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class ApprovedBadge extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$8, safe_not_equal, {});
  }
}
create_custom_element(ApprovedBadge, {}, [], [], !0);
function _getDefaults() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
let _defaults = _getDefaults();
function changeDefaults(cr) {
  _defaults = cr;
}
const escapeTest = /[&<>"']/, escapeReplace = new RegExp(escapeTest.source, "g"), escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g"), escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, getEscapeReplacement = (cr) => escapeReplacements[cr];
function escape$1(cr, ar) {
  if (ar) {
    if (escapeTest.test(cr))
      return cr.replace(escapeReplace, getEscapeReplacement);
  } else if (escapeTestNoEncode.test(cr))
    return cr.replace(escapeReplaceNoEncode, getEscapeReplacement);
  return cr;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(cr) {
  return cr.replace(unescapeTest, (ar, lr) => (lr = lr.toLowerCase(), lr === "colon" ? ":" : lr.charAt(0) === "#" ? lr.charAt(1) === "x" ? String.fromCharCode(parseInt(lr.substring(2), 16)) : String.fromCharCode(+lr.substring(1)) : ""));
}
const caret = /(^|[^\[])\^/g;
function edit(cr, ar) {
  let lr = typeof cr == "string" ? cr : cr.source;
  ar = ar || "";
  const ur = {
    replace: (dr, fr) => {
      let gr = typeof fr == "string" ? fr : fr.source;
      return gr = gr.replace(caret, "$1"), lr = lr.replace(dr, gr), ur;
    },
    getRegex: () => new RegExp(lr, ar)
  };
  return ur;
}
function cleanUrl(cr) {
  try {
    cr = encodeURI(cr).replace(/%25/g, "%");
  } catch (ar) {
    return null;
  }
  return cr;
}
const noopTest = { exec: () => null };
function splitCells(cr, ar) {
  const lr = cr.replace(/\|/g, (fr, gr, mr) => {
    let vr = !1, yr = gr;
    for (; --yr >= 0 && mr[yr] === "\\"; )
      vr = !vr;
    return vr ? "|" : " |";
  }), ur = lr.split(/ \|/);
  let dr = 0;
  if (ur[0].trim() || ur.shift(), ur.length > 0 && !ur[ur.length - 1].trim() && ur.pop(), ar)
    if (ur.length > ar)
      ur.splice(ar);
    else
      for (; ur.length < ar; )
        ur.push("");
  for (; dr < ur.length; dr++)
    ur[dr] = ur[dr].trim().replace(/\\\|/g, "|");
  return ur;
}
function rtrim(cr, ar, lr) {
  const ur = cr.length;
  if (ur === 0)
    return "";
  let dr = 0;
  for (; dr < ur; ) {
    const fr = cr.charAt(ur - dr - 1);
    if (fr === ar && !lr)
      dr++;
    else if (fr !== ar && lr)
      dr++;
    else
      break;
  }
  return cr.slice(0, ur - dr);
}
function findClosingBracket(cr, ar) {
  if (cr.indexOf(ar[1]) === -1)
    return -1;
  let lr = 0;
  for (let ur = 0; ur < cr.length; ur++)
    if (cr[ur] === "\\")
      ur++;
    else if (cr[ur] === ar[0])
      lr++;
    else if (cr[ur] === ar[1] && (lr--, lr < 0))
      return ur;
  return -1;
}
function outputLink(cr, ar, lr, ur) {
  const dr = ar.href, fr = ar.title ? escape$1(ar.title) : null, gr = cr[1].replace(/\\([\[\]])/g, "$1");
  if (cr[0].charAt(0) !== "!") {
    ur.state.inLink = !0;
    const mr = {
      type: "link",
      raw: lr,
      href: dr,
      title: fr,
      text: gr,
      tokens: ur.inlineTokens(gr)
    };
    return ur.state.inLink = !1, mr;
  }
  return {
    type: "image",
    raw: lr,
    href: dr,
    title: fr,
    text: escape$1(gr)
  };
}
function indentCodeCompensation(cr, ar) {
  const lr = cr.match(/^(\s+)(?:```)/);
  if (lr === null)
    return ar;
  const ur = lr[1];
  return ar.split(`
`).map((dr) => {
    const fr = dr.match(/^\s+/);
    if (fr === null)
      return dr;
    const [gr] = fr;
    return gr.length >= ur.length ? dr.slice(ur.length) : dr;
  }).join(`
`);
}
class _Tokenizer {
  // set by the lexer
  constructor(ar) {
    ti(this, "options");
    ti(this, "rules");
    // set by the lexer
    ti(this, "lexer");
    this.options = ar || _defaults;
  }
  space(ar) {
    const lr = this.rules.block.newline.exec(ar);
    if (lr && lr[0].length > 0)
      return {
        type: "space",
        raw: lr[0]
      };
  }
  code(ar) {
    const lr = this.rules.block.code.exec(ar);
    if (lr) {
      const ur = lr[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: lr[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? ur : rtrim(ur, `
`)
      };
    }
  }
  fences(ar) {
    const lr = this.rules.block.fences.exec(ar);
    if (lr) {
      const ur = lr[0], dr = indentCodeCompensation(ur, lr[3] || "");
      return {
        type: "code",
        raw: ur,
        lang: lr[2] ? lr[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : lr[2],
        text: dr
      };
    }
  }
  heading(ar) {
    const lr = this.rules.block.heading.exec(ar);
    if (lr) {
      let ur = lr[2].trim();
      if (/#$/.test(ur)) {
        const dr = rtrim(ur, "#");
        (this.options.pedantic || !dr || / $/.test(dr)) && (ur = dr.trim());
      }
      return {
        type: "heading",
        raw: lr[0],
        depth: lr[1].length,
        text: ur,
        tokens: this.lexer.inline(ur)
      };
    }
  }
  hr(ar) {
    const lr = this.rules.block.hr.exec(ar);
    if (lr)
      return {
        type: "hr",
        raw: lr[0]
      };
  }
  blockquote(ar) {
    const lr = this.rules.block.blockquote.exec(ar);
    if (lr) {
      const ur = rtrim(lr[0].replace(/^ *>[ \t]?/gm, ""), `
`), dr = this.lexer.state.top;
      this.lexer.state.top = !0;
      const fr = this.lexer.blockTokens(ur);
      return this.lexer.state.top = dr, {
        type: "blockquote",
        raw: lr[0],
        tokens: fr,
        text: ur
      };
    }
  }
  list(ar) {
    let lr = this.rules.block.list.exec(ar);
    if (lr) {
      let ur = lr[1].trim();
      const dr = ur.length > 1, fr = {
        type: "list",
        raw: "",
        ordered: dr,
        start: dr ? +ur.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      ur = dr ? `\\d{1,9}\\${ur.slice(-1)}` : `\\${ur}`, this.options.pedantic && (ur = dr ? ur : "[*+-]");
      const gr = new RegExp(`^( {0,3}${ur})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let mr = "", vr = "", yr = !1;
      for (; ar; ) {
        let _r = !1;
        if (!(lr = gr.exec(ar)) || this.rules.block.hr.test(ar))
          break;
        mr = lr[0], ar = ar.substring(mr.length);
        let kr = lr[2].split(`
`, 1)[0].replace(/^\t+/, (Sr) => " ".repeat(3 * Sr.length)), xr = ar.split(`
`, 1)[0], Ar = 0;
        this.options.pedantic ? (Ar = 2, vr = kr.trimStart()) : (Ar = lr[2].search(/[^ ]/), Ar = Ar > 4 ? 1 : Ar, vr = kr.slice(Ar), Ar += lr[1].length);
        let Er = !1;
        if (!kr && /^ *$/.test(xr) && (mr += xr + `
`, ar = ar.substring(xr.length + 1), _r = !0), !_r) {
          const Sr = new RegExp(`^ {0,${Math.min(3, Ar - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Lr = new RegExp(`^ {0,${Math.min(3, Ar - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), Ir = new RegExp(`^ {0,${Math.min(3, Ar - 1)}}(?:\`\`\`|~~~)`), Nr = new RegExp(`^ {0,${Math.min(3, Ar - 1)}}#`);
          for (; ar; ) {
            const Rr = ar.split(`
`, 1)[0];
            if (xr = Rr, this.options.pedantic && (xr = xr.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), Ir.test(xr) || Nr.test(xr) || Sr.test(xr) || Lr.test(ar))
              break;
            if (xr.search(/[^ ]/) >= Ar || !xr.trim())
              vr += `
` + xr.slice(Ar);
            else {
              if (Er || kr.search(/[^ ]/) >= 4 || Ir.test(kr) || Nr.test(kr) || Lr.test(kr))
                break;
              vr += `
` + xr;
            }
            !Er && !xr.trim() && (Er = !0), mr += Rr + `
`, ar = ar.substring(Rr.length + 1), kr = xr.slice(Ar);
          }
        }
        fr.loose || (yr ? fr.loose = !0 : /\n *\n *$/.test(mr) && (yr = !0));
        let Cr = null, Tr;
        this.options.gfm && (Cr = /^\[[ xX]\] /.exec(vr), Cr && (Tr = Cr[0] !== "[ ] ", vr = vr.replace(/^\[[ xX]\] +/, ""))), fr.items.push({
          type: "list_item",
          raw: mr,
          task: !!Cr,
          checked: Tr,
          loose: !1,
          text: vr,
          tokens: []
        }), fr.raw += mr;
      }
      fr.items[fr.items.length - 1].raw = mr.trimEnd(), fr.items[fr.items.length - 1].text = vr.trimEnd(), fr.raw = fr.raw.trimEnd();
      for (let _r = 0; _r < fr.items.length; _r++)
        if (this.lexer.state.top = !1, fr.items[_r].tokens = this.lexer.blockTokens(fr.items[_r].text, []), !fr.loose) {
          const kr = fr.items[_r].tokens.filter((Ar) => Ar.type === "space"), xr = kr.length > 0 && kr.some((Ar) => /\n.*\n/.test(Ar.raw));
          fr.loose = xr;
        }
      if (fr.loose)
        for (let _r = 0; _r < fr.items.length; _r++)
          fr.items[_r].loose = !0;
      return fr;
    }
  }
  html(ar) {
    const lr = this.rules.block.html.exec(ar);
    if (lr)
      return {
        type: "html",
        block: !0,
        raw: lr[0],
        pre: lr[1] === "pre" || lr[1] === "script" || lr[1] === "style",
        text: lr[0]
      };
  }
  def(ar) {
    const lr = this.rules.block.def.exec(ar);
    if (lr) {
      const ur = lr[1].toLowerCase().replace(/\s+/g, " "), dr = lr[2] ? lr[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", fr = lr[3] ? lr[3].substring(1, lr[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : lr[3];
      return {
        type: "def",
        tag: ur,
        raw: lr[0],
        href: dr,
        title: fr
      };
    }
  }
  table(ar) {
    const lr = this.rules.block.table.exec(ar);
    if (!lr || !/[:|]/.test(lr[2]))
      return;
    const ur = splitCells(lr[1]), dr = lr[2].replace(/^\||\| *$/g, "").split("|"), fr = lr[3] && lr[3].trim() ? lr[3].replace(/\n[ \t]*$/, "").split(`
`) : [], gr = {
      type: "table",
      raw: lr[0],
      header: [],
      align: [],
      rows: []
    };
    if (ur.length === dr.length) {
      for (const mr of dr)
        /^ *-+: *$/.test(mr) ? gr.align.push("right") : /^ *:-+: *$/.test(mr) ? gr.align.push("center") : /^ *:-+ *$/.test(mr) ? gr.align.push("left") : gr.align.push(null);
      for (const mr of ur)
        gr.header.push({
          text: mr,
          tokens: this.lexer.inline(mr)
        });
      for (const mr of fr)
        gr.rows.push(splitCells(mr, gr.header.length).map((vr) => ({
          text: vr,
          tokens: this.lexer.inline(vr)
        })));
      return gr;
    }
  }
  lheading(ar) {
    const lr = this.rules.block.lheading.exec(ar);
    if (lr)
      return {
        type: "heading",
        raw: lr[0],
        depth: lr[2].charAt(0) === "=" ? 1 : 2,
        text: lr[1],
        tokens: this.lexer.inline(lr[1])
      };
  }
  paragraph(ar) {
    const lr = this.rules.block.paragraph.exec(ar);
    if (lr) {
      const ur = lr[1].charAt(lr[1].length - 1) === `
` ? lr[1].slice(0, -1) : lr[1];
      return {
        type: "paragraph",
        raw: lr[0],
        text: ur,
        tokens: this.lexer.inline(ur)
      };
    }
  }
  text(ar) {
    const lr = this.rules.block.text.exec(ar);
    if (lr)
      return {
        type: "text",
        raw: lr[0],
        text: lr[0],
        tokens: this.lexer.inline(lr[0])
      };
  }
  escape(ar) {
    const lr = this.rules.inline.escape.exec(ar);
    if (lr)
      return {
        type: "escape",
        raw: lr[0],
        text: escape$1(lr[1])
      };
  }
  tag(ar) {
    const lr = this.rules.inline.tag.exec(ar);
    if (lr)
      return !this.lexer.state.inLink && /^<a /i.test(lr[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(lr[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(lr[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(lr[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: lr[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: lr[0]
      };
  }
  link(ar) {
    const lr = this.rules.inline.link.exec(ar);
    if (lr) {
      const ur = lr[2].trim();
      if (!this.options.pedantic && /^</.test(ur)) {
        if (!/>$/.test(ur))
          return;
        const gr = rtrim(ur.slice(0, -1), "\\");
        if ((ur.length - gr.length) % 2 === 0)
          return;
      } else {
        const gr = findClosingBracket(lr[2], "()");
        if (gr > -1) {
          const vr = (lr[0].indexOf("!") === 0 ? 5 : 4) + lr[1].length + gr;
          lr[2] = lr[2].substring(0, gr), lr[0] = lr[0].substring(0, vr).trim(), lr[3] = "";
        }
      }
      let dr = lr[2], fr = "";
      if (this.options.pedantic) {
        const gr = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(dr);
        gr && (dr = gr[1], fr = gr[3]);
      } else
        fr = lr[3] ? lr[3].slice(1, -1) : "";
      return dr = dr.trim(), /^</.test(dr) && (this.options.pedantic && !/>$/.test(ur) ? dr = dr.slice(1) : dr = dr.slice(1, -1)), outputLink(lr, {
        href: dr && dr.replace(this.rules.inline.anyPunctuation, "$1"),
        title: fr && fr.replace(this.rules.inline.anyPunctuation, "$1")
      }, lr[0], this.lexer);
    }
  }
  reflink(ar, lr) {
    let ur;
    if ((ur = this.rules.inline.reflink.exec(ar)) || (ur = this.rules.inline.nolink.exec(ar))) {
      const dr = (ur[2] || ur[1]).replace(/\s+/g, " "), fr = lr[dr.toLowerCase()];
      if (!fr) {
        const gr = ur[0].charAt(0);
        return {
          type: "text",
          raw: gr,
          text: gr
        };
      }
      return outputLink(ur, fr, ur[0], this.lexer);
    }
  }
  emStrong(ar, lr, ur = "") {
    let dr = this.rules.inline.emStrongLDelim.exec(ar);
    if (!dr || dr[3] && ur.match(/[\p{L}\p{N}]/u))
      return;
    if (!(dr[1] || dr[2] || "") || !ur || this.rules.inline.punctuation.exec(ur)) {
      const gr = [...dr[0]].length - 1;
      let mr, vr, yr = gr, _r = 0;
      const kr = dr[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (kr.lastIndex = 0, lr = lr.slice(-1 * ar.length + gr); (dr = kr.exec(lr)) != null; ) {
        if (mr = dr[1] || dr[2] || dr[3] || dr[4] || dr[5] || dr[6], !mr)
          continue;
        if (vr = [...mr].length, dr[3] || dr[4]) {
          yr += vr;
          continue;
        } else if ((dr[5] || dr[6]) && gr % 3 && !((gr + vr) % 3)) {
          _r += vr;
          continue;
        }
        if (yr -= vr, yr > 0)
          continue;
        vr = Math.min(vr, vr + yr + _r);
        const xr = [...dr[0]][0].length, Ar = ar.slice(0, gr + dr.index + xr + vr);
        if (Math.min(gr, vr) % 2) {
          const Cr = Ar.slice(1, -1);
          return {
            type: "em",
            raw: Ar,
            text: Cr,
            tokens: this.lexer.inlineTokens(Cr)
          };
        }
        const Er = Ar.slice(2, -2);
        return {
          type: "strong",
          raw: Ar,
          text: Er,
          tokens: this.lexer.inlineTokens(Er)
        };
      }
    }
  }
  codespan(ar) {
    const lr = this.rules.inline.code.exec(ar);
    if (lr) {
      let ur = lr[2].replace(/\n/g, " ");
      const dr = /[^ ]/.test(ur), fr = /^ /.test(ur) && / $/.test(ur);
      return dr && fr && (ur = ur.substring(1, ur.length - 1)), ur = escape$1(ur, !0), {
        type: "codespan",
        raw: lr[0],
        text: ur
      };
    }
  }
  br(ar) {
    const lr = this.rules.inline.br.exec(ar);
    if (lr)
      return {
        type: "br",
        raw: lr[0]
      };
  }
  del(ar) {
    const lr = this.rules.inline.del.exec(ar);
    if (lr)
      return {
        type: "del",
        raw: lr[0],
        text: lr[2],
        tokens: this.lexer.inlineTokens(lr[2])
      };
  }
  autolink(ar) {
    const lr = this.rules.inline.autolink.exec(ar);
    if (lr) {
      let ur, dr;
      return lr[2] === "@" ? (ur = escape$1(lr[1]), dr = "mailto:" + ur) : (ur = escape$1(lr[1]), dr = ur), {
        type: "link",
        raw: lr[0],
        text: ur,
        href: dr,
        tokens: [
          {
            type: "text",
            raw: ur,
            text: ur
          }
        ]
      };
    }
  }
  url(ar) {
    var ur, dr;
    let lr;
    if (lr = this.rules.inline.url.exec(ar)) {
      let fr, gr;
      if (lr[2] === "@")
        fr = escape$1(lr[0]), gr = "mailto:" + fr;
      else {
        let mr;
        do
          mr = lr[0], lr[0] = (dr = (ur = this.rules.inline._backpedal.exec(lr[0])) == null ? void 0 : ur[0]) != null ? dr : "";
        while (mr !== lr[0]);
        fr = escape$1(lr[0]), lr[1] === "www." ? gr = "http://" + lr[0] : gr = lr[0];
      }
      return {
        type: "link",
        raw: lr[0],
        text: fr,
        href: gr,
        tokens: [
          {
            type: "text",
            raw: fr,
            text: fr
          }
        ]
      };
    }
  }
  inlineText(ar) {
    const lr = this.rules.inline.text.exec(ar);
    if (lr) {
      let ur;
      return this.lexer.state.inRawBlock ? ur = lr[0] : ur = escape$1(lr[0]), {
        type: "text",
        raw: lr[0],
        text: ur
      };
    }
  }
}
const newline = /^(?: *(?:\n|$))+/, blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/, lheading = edit(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, blockText = /^[^\n]+/, _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/, def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex(), _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, html$2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html: html$2,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
}, gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
}, blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, escape$2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br = /^( {2,}|\\)\n(?!\s*$)/, inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, _punctuation = "\\p{P}$+<=>`^|~", punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex(), blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex(), anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex(), autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex(), tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex(), nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex(), reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex(), inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$2,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
}, inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
}, inlineGfm = {
  ...inlineNormal,
  escape: edit(escape$2).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
}, inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
class _Lexer {
  constructor(ar) {
    ti(this, "tokens");
    ti(this, "options");
    ti(this, "state");
    ti(this, "tokenizer");
    ti(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = ar || _defaults, this.options.tokenizer = this.options.tokenizer || new _Tokenizer(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const lr = {
      block: block.normal,
      inline: inline.normal
    };
    this.options.pedantic ? (lr.block = block.pedantic, lr.inline = inline.pedantic) : this.options.gfm && (lr.block = block.gfm, this.options.breaks ? lr.inline = inline.breaks : lr.inline = inline.gfm), this.tokenizer.rules = lr;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(ar, lr) {
    return new _Lexer(lr).lex(ar);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(ar, lr) {
    return new _Lexer(lr).inlineTokens(ar);
  }
  /**
   * Preprocessing
   */
  lex(ar) {
    ar = ar.replace(/\r\n|\r/g, `
`), this.blockTokens(ar, this.tokens);
    let lr;
    for (; lr = this.inlineQueue.shift(); )
      this.inlineTokens(lr.src, lr.tokens);
    return this.tokens;
  }
  blockTokens(ar, lr = []) {
    this.options.pedantic ? ar = ar.replace(/\t/g, "    ").replace(/^ +$/gm, "") : ar = ar.replace(/^( *)(\t+)/gm, (mr, vr, yr) => vr + "    ".repeat(yr.length));
    let ur, dr, fr, gr;
    for (; ar; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((mr) => (ur = mr.call({ lexer: this }, ar, lr)) ? (ar = ar.substring(ur.raw.length), lr.push(ur), !0) : !1))) {
        if (ur = this.tokenizer.space(ar)) {
          ar = ar.substring(ur.raw.length), ur.raw.length === 1 && lr.length > 0 ? lr[lr.length - 1].raw += `
` : lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.code(ar)) {
          ar = ar.substring(ur.raw.length), dr = lr[lr.length - 1], dr && (dr.type === "paragraph" || dr.type === "text") ? (dr.raw += `
` + ur.raw, dr.text += `
` + ur.text, this.inlineQueue[this.inlineQueue.length - 1].src = dr.text) : lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.fences(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.heading(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.hr(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.blockquote(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.list(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.html(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.def(ar)) {
          ar = ar.substring(ur.raw.length), dr = lr[lr.length - 1], dr && (dr.type === "paragraph" || dr.type === "text") ? (dr.raw += `
` + ur.raw, dr.text += `
` + ur.raw, this.inlineQueue[this.inlineQueue.length - 1].src = dr.text) : this.tokens.links[ur.tag] || (this.tokens.links[ur.tag] = {
            href: ur.href,
            title: ur.title
          });
          continue;
        }
        if (ur = this.tokenizer.table(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.lheading(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (fr = ar, this.options.extensions && this.options.extensions.startBlock) {
          let mr = 1 / 0;
          const vr = ar.slice(1);
          let yr;
          this.options.extensions.startBlock.forEach((_r) => {
            yr = _r.call({ lexer: this }, vr), typeof yr == "number" && yr >= 0 && (mr = Math.min(mr, yr));
          }), mr < 1 / 0 && mr >= 0 && (fr = ar.substring(0, mr + 1));
        }
        if (this.state.top && (ur = this.tokenizer.paragraph(fr))) {
          dr = lr[lr.length - 1], gr && dr.type === "paragraph" ? (dr.raw += `
` + ur.raw, dr.text += `
` + ur.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = dr.text) : lr.push(ur), gr = fr.length !== ar.length, ar = ar.substring(ur.raw.length);
          continue;
        }
        if (ur = this.tokenizer.text(ar)) {
          ar = ar.substring(ur.raw.length), dr = lr[lr.length - 1], dr && dr.type === "text" ? (dr.raw += `
` + ur.raw, dr.text += `
` + ur.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = dr.text) : lr.push(ur);
          continue;
        }
        if (ar) {
          const mr = "Infinite loop on byte: " + ar.charCodeAt(0);
          if (this.options.silent) {
            console.error(mr);
            break;
          } else
            throw new Error(mr);
        }
      }
    return this.state.top = !0, lr;
  }
  inline(ar, lr = []) {
    return this.inlineQueue.push({ src: ar, tokens: lr }), lr;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(ar, lr = []) {
    let ur, dr, fr, gr = ar, mr, vr, yr;
    if (this.tokens.links) {
      const _r = Object.keys(this.tokens.links);
      if (_r.length > 0)
        for (; (mr = this.tokenizer.rules.inline.reflinkSearch.exec(gr)) != null; )
          _r.includes(mr[0].slice(mr[0].lastIndexOf("[") + 1, -1)) && (gr = gr.slice(0, mr.index) + "[" + "a".repeat(mr[0].length - 2) + "]" + gr.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (mr = this.tokenizer.rules.inline.blockSkip.exec(gr)) != null; )
      gr = gr.slice(0, mr.index) + "[" + "a".repeat(mr[0].length - 2) + "]" + gr.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (mr = this.tokenizer.rules.inline.anyPunctuation.exec(gr)) != null; )
      gr = gr.slice(0, mr.index) + "++" + gr.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; ar; )
      if (vr || (yr = ""), vr = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((_r) => (ur = _r.call({ lexer: this }, ar, lr)) ? (ar = ar.substring(ur.raw.length), lr.push(ur), !0) : !1))) {
        if (ur = this.tokenizer.escape(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.tag(ar)) {
          ar = ar.substring(ur.raw.length), dr = lr[lr.length - 1], dr && ur.type === "text" && dr.type === "text" ? (dr.raw += ur.raw, dr.text += ur.text) : lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.link(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.reflink(ar, this.tokens.links)) {
          ar = ar.substring(ur.raw.length), dr = lr[lr.length - 1], dr && ur.type === "text" && dr.type === "text" ? (dr.raw += ur.raw, dr.text += ur.text) : lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.emStrong(ar, gr, yr)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.codespan(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.br(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.del(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (ur = this.tokenizer.autolink(ar)) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (!this.state.inLink && (ur = this.tokenizer.url(ar))) {
          ar = ar.substring(ur.raw.length), lr.push(ur);
          continue;
        }
        if (fr = ar, this.options.extensions && this.options.extensions.startInline) {
          let _r = 1 / 0;
          const kr = ar.slice(1);
          let xr;
          this.options.extensions.startInline.forEach((Ar) => {
            xr = Ar.call({ lexer: this }, kr), typeof xr == "number" && xr >= 0 && (_r = Math.min(_r, xr));
          }), _r < 1 / 0 && _r >= 0 && (fr = ar.substring(0, _r + 1));
        }
        if (ur = this.tokenizer.inlineText(fr)) {
          ar = ar.substring(ur.raw.length), ur.raw.slice(-1) !== "_" && (yr = ur.raw.slice(-1)), vr = !0, dr = lr[lr.length - 1], dr && dr.type === "text" ? (dr.raw += ur.raw, dr.text += ur.text) : lr.push(ur);
          continue;
        }
        if (ar) {
          const _r = "Infinite loop on byte: " + ar.charCodeAt(0);
          if (this.options.silent) {
            console.error(_r);
            break;
          } else
            throw new Error(_r);
        }
      }
    return lr;
  }
}
class _Renderer {
  constructor(ar) {
    ti(this, "options");
    this.options = ar || _defaults;
  }
  code(ar, lr, ur) {
    var fr;
    const dr = (fr = (lr || "").match(/^\S*/)) == null ? void 0 : fr[0];
    return ar = ar.replace(/\n$/, "") + `
`, dr ? '<pre><code class="language-' + escape$1(dr) + '">' + (ur ? ar : escape$1(ar, !0)) + `</code></pre>
` : "<pre><code>" + (ur ? ar : escape$1(ar, !0)) + `</code></pre>
`;
  }
  blockquote(ar) {
    return `<blockquote>
${ar}</blockquote>
`;
  }
  html(ar, lr) {
    return ar;
  }
  heading(ar, lr, ur) {
    return `<h${lr}>${ar}</h${lr}>
`;
  }
  hr() {
    return `<hr>
`;
  }
  list(ar, lr, ur) {
    const dr = lr ? "ol" : "ul", fr = lr && ur !== 1 ? ' start="' + ur + '"' : "";
    return "<" + dr + fr + `>
` + ar + "</" + dr + `>
`;
  }
  listitem(ar, lr, ur) {
    return `<li>${ar}</li>
`;
  }
  checkbox(ar) {
    return "<input " + (ar ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(ar) {
    return `<p>${ar}</p>
`;
  }
  table(ar, lr) {
    return lr && (lr = `<tbody>${lr}</tbody>`), `<table>
<thead>
` + ar + `</thead>
` + lr + `</table>
`;
  }
  tablerow(ar) {
    return `<tr>
${ar}</tr>
`;
  }
  tablecell(ar, lr) {
    const ur = lr.header ? "th" : "td";
    return (lr.align ? `<${ur} align="${lr.align}">` : `<${ur}>`) + ar + `</${ur}>
`;
  }
  /**
   * span level renderer
   */
  strong(ar) {
    return `<strong>${ar}</strong>`;
  }
  em(ar) {
    return `<em>${ar}</em>`;
  }
  codespan(ar) {
    return `<code>${ar}</code>`;
  }
  br() {
    return "<br>";
  }
  del(ar) {
    return `<del>${ar}</del>`;
  }
  link(ar, lr, ur) {
    const dr = cleanUrl(ar);
    if (dr === null)
      return ur;
    ar = dr;
    let fr = '<a href="' + ar + '"';
    return lr && (fr += ' title="' + lr + '"'), fr += ">" + ur + "</a>", fr;
  }
  image(ar, lr, ur) {
    const dr = cleanUrl(ar);
    if (dr === null)
      return ur;
    ar = dr;
    let fr = `<img src="${ar}" alt="${ur}"`;
    return lr && (fr += ` title="${lr}"`), fr += ">", fr;
  }
  text(ar) {
    return ar;
  }
}
class _TextRenderer {
  // no need for block level renderers
  strong(ar) {
    return ar;
  }
  em(ar) {
    return ar;
  }
  codespan(ar) {
    return ar;
  }
  del(ar) {
    return ar;
  }
  html(ar) {
    return ar;
  }
  text(ar) {
    return ar;
  }
  link(ar, lr, ur) {
    return "" + ur;
  }
  image(ar, lr, ur) {
    return "" + ur;
  }
  br() {
    return "";
  }
}
class _Parser {
  constructor(ar) {
    ti(this, "options");
    ti(this, "renderer");
    ti(this, "textRenderer");
    this.options = ar || _defaults, this.options.renderer = this.options.renderer || new _Renderer(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(ar, lr) {
    return new _Parser(lr).parse(ar);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(ar, lr) {
    return new _Parser(lr).parseInline(ar);
  }
  /**
   * Parse Loop
   */
  parse(ar, lr = !0) {
    let ur = "";
    for (let dr = 0; dr < ar.length; dr++) {
      const fr = ar[dr];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[fr.type]) {
        const gr = fr, mr = this.options.extensions.renderers[gr.type].call({ parser: this }, gr);
        if (mr !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(gr.type)) {
          ur += mr || "";
          continue;
        }
      }
      switch (fr.type) {
        case "space":
          continue;
        case "hr": {
          ur += this.renderer.hr();
          continue;
        }
        case "heading": {
          const gr = fr;
          ur += this.renderer.heading(this.parseInline(gr.tokens), gr.depth, unescape$1(this.parseInline(gr.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const gr = fr;
          ur += this.renderer.code(gr.text, gr.lang, !!gr.escaped);
          continue;
        }
        case "table": {
          const gr = fr;
          let mr = "", vr = "";
          for (let _r = 0; _r < gr.header.length; _r++)
            vr += this.renderer.tablecell(this.parseInline(gr.header[_r].tokens), { header: !0, align: gr.align[_r] });
          mr += this.renderer.tablerow(vr);
          let yr = "";
          for (let _r = 0; _r < gr.rows.length; _r++) {
            const kr = gr.rows[_r];
            vr = "";
            for (let xr = 0; xr < kr.length; xr++)
              vr += this.renderer.tablecell(this.parseInline(kr[xr].tokens), { header: !1, align: gr.align[xr] });
            yr += this.renderer.tablerow(vr);
          }
          ur += this.renderer.table(mr, yr);
          continue;
        }
        case "blockquote": {
          const gr = fr, mr = this.parse(gr.tokens);
          ur += this.renderer.blockquote(mr);
          continue;
        }
        case "list": {
          const gr = fr, mr = gr.ordered, vr = gr.start, yr = gr.loose;
          let _r = "";
          for (let kr = 0; kr < gr.items.length; kr++) {
            const xr = gr.items[kr], Ar = xr.checked, Er = xr.task;
            let Cr = "";
            if (xr.task) {
              const Tr = this.renderer.checkbox(!!Ar);
              yr ? xr.tokens.length > 0 && xr.tokens[0].type === "paragraph" ? (xr.tokens[0].text = Tr + " " + xr.tokens[0].text, xr.tokens[0].tokens && xr.tokens[0].tokens.length > 0 && xr.tokens[0].tokens[0].type === "text" && (xr.tokens[0].tokens[0].text = Tr + " " + xr.tokens[0].tokens[0].text)) : xr.tokens.unshift({
                type: "text",
                text: Tr + " "
              }) : Cr += Tr + " ";
            }
            Cr += this.parse(xr.tokens, yr), _r += this.renderer.listitem(Cr, Er, !!Ar);
          }
          ur += this.renderer.list(_r, mr, vr);
          continue;
        }
        case "html": {
          const gr = fr;
          ur += this.renderer.html(gr.text, gr.block);
          continue;
        }
        case "paragraph": {
          const gr = fr;
          ur += this.renderer.paragraph(this.parseInline(gr.tokens));
          continue;
        }
        case "text": {
          let gr = fr, mr = gr.tokens ? this.parseInline(gr.tokens) : gr.text;
          for (; dr + 1 < ar.length && ar[dr + 1].type === "text"; )
            gr = ar[++dr], mr += `
` + (gr.tokens ? this.parseInline(gr.tokens) : gr.text);
          ur += lr ? this.renderer.paragraph(mr) : mr;
          continue;
        }
        default: {
          const gr = 'Token with "' + fr.type + '" type was not found.';
          if (this.options.silent)
            return console.error(gr), "";
          throw new Error(gr);
        }
      }
    }
    return ur;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(ar, lr) {
    lr = lr || this.renderer;
    let ur = "";
    for (let dr = 0; dr < ar.length; dr++) {
      const fr = ar[dr];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[fr.type]) {
        const gr = this.options.extensions.renderers[fr.type].call({ parser: this }, fr);
        if (gr !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(fr.type)) {
          ur += gr || "";
          continue;
        }
      }
      switch (fr.type) {
        case "escape": {
          const gr = fr;
          ur += lr.text(gr.text);
          break;
        }
        case "html": {
          const gr = fr;
          ur += lr.html(gr.text);
          break;
        }
        case "link": {
          const gr = fr;
          ur += lr.link(gr.href, gr.title, this.parseInline(gr.tokens, lr));
          break;
        }
        case "image": {
          const gr = fr;
          ur += lr.image(gr.href, gr.title, gr.text);
          break;
        }
        case "strong": {
          const gr = fr;
          ur += lr.strong(this.parseInline(gr.tokens, lr));
          break;
        }
        case "em": {
          const gr = fr;
          ur += lr.em(this.parseInline(gr.tokens, lr));
          break;
        }
        case "codespan": {
          const gr = fr;
          ur += lr.codespan(gr.text);
          break;
        }
        case "br": {
          ur += lr.br();
          break;
        }
        case "del": {
          const gr = fr;
          ur += lr.del(this.parseInline(gr.tokens, lr));
          break;
        }
        case "text": {
          const gr = fr;
          ur += lr.text(gr.text);
          break;
        }
        default: {
          const gr = 'Token with "' + fr.type + '" type was not found.';
          if (this.options.silent)
            return console.error(gr), "";
          throw new Error(gr);
        }
      }
    }
    return ur;
  }
}
class _Hooks {
  constructor(ar) {
    ti(this, "options");
    this.options = ar || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(ar) {
    return ar;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(ar) {
    return ar;
  }
}
ti(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
var Bo, jo, Po, Wo;
class Marked {
  constructor(...ar) {
    mo(this, Bo);
    mo(this, Po);
    ti(this, "defaults", _getDefaults());
    ti(this, "options", this.setOptions);
    ti(this, "parse", no(this, Bo, jo).call(this, _Lexer.lex, _Parser.parse));
    ti(this, "parseInline", no(this, Bo, jo).call(this, _Lexer.lexInline, _Parser.parseInline));
    ti(this, "Parser", _Parser);
    ti(this, "Renderer", _Renderer);
    ti(this, "TextRenderer", _TextRenderer);
    ti(this, "Lexer", _Lexer);
    ti(this, "Tokenizer", _Tokenizer);
    ti(this, "Hooks", _Hooks);
    this.use(...ar);
  }
  /**
   * Run callback for every token
   */
  walkTokens(ar, lr) {
    var dr, fr;
    let ur = [];
    for (const gr of ar)
      switch (ur = ur.concat(lr.call(this, gr)), gr.type) {
        case "table": {
          const mr = gr;
          for (const vr of mr.header)
            ur = ur.concat(this.walkTokens(vr.tokens, lr));
          for (const vr of mr.rows)
            for (const yr of vr)
              ur = ur.concat(this.walkTokens(yr.tokens, lr));
          break;
        }
        case "list": {
          const mr = gr;
          ur = ur.concat(this.walkTokens(mr.items, lr));
          break;
        }
        default: {
          const mr = gr;
          (fr = (dr = this.defaults.extensions) == null ? void 0 : dr.childTokens) != null && fr[mr.type] ? this.defaults.extensions.childTokens[mr.type].forEach((vr) => {
            ur = ur.concat(this.walkTokens(mr[vr], lr));
          }) : mr.tokens && (ur = ur.concat(this.walkTokens(mr.tokens, lr)));
        }
      }
    return ur;
  }
  use(...ar) {
    const lr = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return ar.forEach((ur) => {
      const dr = { ...ur };
      if (dr.async = this.defaults.async || dr.async || !1, ur.extensions && (ur.extensions.forEach((fr) => {
        if (!fr.name)
          throw new Error("extension name required");
        if ("renderer" in fr) {
          const gr = lr.renderers[fr.name];
          gr ? lr.renderers[fr.name] = function(...mr) {
            let vr = fr.renderer.apply(this, mr);
            return vr === !1 && (vr = gr.apply(this, mr)), vr;
          } : lr.renderers[fr.name] = fr.renderer;
        }
        if ("tokenizer" in fr) {
          if (!fr.level || fr.level !== "block" && fr.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const gr = lr[fr.level];
          gr ? gr.unshift(fr.tokenizer) : lr[fr.level] = [fr.tokenizer], fr.start && (fr.level === "block" ? lr.startBlock ? lr.startBlock.push(fr.start) : lr.startBlock = [fr.start] : fr.level === "inline" && (lr.startInline ? lr.startInline.push(fr.start) : lr.startInline = [fr.start]));
        }
        "childTokens" in fr && fr.childTokens && (lr.childTokens[fr.name] = fr.childTokens);
      }), dr.extensions = lr), ur.renderer) {
        const fr = this.defaults.renderer || new _Renderer(this.defaults);
        for (const gr in ur.renderer) {
          if (!(gr in fr) || gr === "options")
            throw new Error(`renderer '${gr}' does not exist`);
          const mr = gr, vr = ur.renderer[mr], yr = fr[mr];
          fr[mr] = (..._r) => {
            let kr = vr.apply(fr, _r);
            return kr === !1 && (kr = yr.apply(fr, _r)), kr || "";
          };
        }
        dr.renderer = fr;
      }
      if (ur.tokenizer) {
        const fr = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const gr in ur.tokenizer) {
          if (!(gr in fr) || ["options", "rules", "lexer"].includes(gr))
            throw new Error(`tokenizer '${gr}' does not exist`);
          const mr = gr, vr = ur.tokenizer[mr], yr = fr[mr];
          fr[mr] = (..._r) => {
            let kr = vr.apply(fr, _r);
            return kr === !1 && (kr = yr.apply(fr, _r)), kr;
          };
        }
        dr.tokenizer = fr;
      }
      if (ur.hooks) {
        const fr = this.defaults.hooks || new _Hooks();
        for (const gr in ur.hooks) {
          if (!(gr in fr) || gr === "options")
            throw new Error(`hook '${gr}' does not exist`);
          const mr = gr, vr = ur.hooks[mr], yr = fr[mr];
          _Hooks.passThroughHooks.has(gr) ? fr[mr] = (_r) => {
            if (this.defaults.async)
              return Promise.resolve(vr.call(fr, _r)).then((xr) => yr.call(fr, xr));
            const kr = vr.call(fr, _r);
            return yr.call(fr, kr);
          } : fr[mr] = (..._r) => {
            let kr = vr.apply(fr, _r);
            return kr === !1 && (kr = yr.apply(fr, _r)), kr;
          };
        }
        dr.hooks = fr;
      }
      if (ur.walkTokens) {
        const fr = this.defaults.walkTokens, gr = ur.walkTokens;
        dr.walkTokens = function(mr) {
          let vr = [];
          return vr.push(gr.call(this, mr)), fr && (vr = vr.concat(fr.call(this, mr))), vr;
        };
      }
      this.defaults = { ...this.defaults, ...dr };
    }), this;
  }
  setOptions(ar) {
    return this.defaults = { ...this.defaults, ...ar }, this;
  }
  lexer(ar, lr) {
    return _Lexer.lex(ar, lr != null ? lr : this.defaults);
  }
  parser(ar, lr) {
    return _Parser.parse(ar, lr != null ? lr : this.defaults);
  }
}
Bo = new WeakSet(), jo = function(ar, lr) {
  return (ur, dr) => {
    const fr = { ...dr }, gr = { ...this.defaults, ...fr };
    this.defaults.async === !0 && fr.async === !1 && (gr.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), gr.async = !0);
    const mr = no(this, Po, Wo).call(this, !!gr.silent, !!gr.async);
    if (typeof ur == "undefined" || ur === null)
      return mr(new Error("marked(): input parameter is undefined or null"));
    if (typeof ur != "string")
      return mr(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(ur) + ", string expected"));
    if (gr.hooks && (gr.hooks.options = gr), gr.async)
      return Promise.resolve(gr.hooks ? gr.hooks.preprocess(ur) : ur).then((vr) => ar(vr, gr)).then((vr) => gr.walkTokens ? Promise.all(this.walkTokens(vr, gr.walkTokens)).then(() => vr) : vr).then((vr) => lr(vr, gr)).then((vr) => gr.hooks ? gr.hooks.postprocess(vr) : vr).catch(mr);
    try {
      gr.hooks && (ur = gr.hooks.preprocess(ur));
      const vr = ar(ur, gr);
      gr.walkTokens && this.walkTokens(vr, gr.walkTokens);
      let yr = lr(vr, gr);
      return gr.hooks && (yr = gr.hooks.postprocess(yr)), yr;
    } catch (vr) {
      return mr(vr);
    }
  };
}, Po = new WeakSet(), Wo = function(ar, lr) {
  return (ur) => {
    if (ur.message += `
Please report this to https://github.com/markedjs/marked.`, ar) {
      const dr = "<p>An error occurred:</p><pre>" + escape$1(ur.message + "", !0) + "</pre>";
      return lr ? Promise.resolve(dr) : dr;
    }
    if (lr)
      return Promise.reject(ur);
    throw ur;
  };
};
const markedInstance = new Marked();
function marked(cr, ar) {
  return markedInstance.parse(cr, ar);
}
marked.options = marked.setOptions = function(cr) {
  return markedInstance.setOptions(cr), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...cr) {
  return markedInstance.use(...cr), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.walkTokens = function(cr, ar) {
  return markedInstance.walkTokens(cr, ar);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
function add_css$5(cr) {
  append_styles(cr, "svelte-1qh4vd6", ".preview-container.svelte-1qh4vd6{position:relative;width:150px;height:150px;border-radius:10px;overflow:hidden;box-shadow:0 4px 8px rgba(0, 0, 0, 0.1)}.preview-image.svelte-1qh4vd6{width:100%;height:100%;display:block;border-radius:10px}.delete-button.svelte-1qh4vd6{position:absolute;top:10px;right:10px;background-color:transparent;border:none;border-radius:50%;color:white;cursor:pointer}");
}
function create_if_block$2(cr) {
  let ar, lr, ur, dr, fr, gr;
  return {
    c() {
      ar = element("img"), ur = space(), dr = element("button"), dr.textContent = "X", attr(ar, "class", "preview-image svelte-1qh4vd6"), src_url_equal(ar.src, lr = /*dataUrl*/
      cr[0]) || attr(ar, "src", lr), attr(ar, "alt", "Uploaded file preview"), attr(dr, "class", "delete-button svelte-1qh4vd6");
    },
    m(mr, vr) {
      insert(mr, ar, vr), insert(mr, ur, vr), insert(mr, dr, vr), fr || (gr = listen(
        dr,
        "click",
        /*handleDelete*/
        cr[1]
      ), fr = !0);
    },
    p(mr, vr) {
      vr & /*dataUrl*/
      1 && !src_url_equal(ar.src, lr = /*dataUrl*/
      mr[0]) && attr(ar, "src", lr);
    },
    d(mr) {
      mr && (detach(ar), detach(ur), detach(dr)), fr = !1, gr();
    }
  };
}
function create_fragment$7(cr) {
  let ar, lr = (
    /*dataUrl*/
    cr[0] && create_if_block$2(cr)
  );
  return {
    c() {
      ar = element("div"), lr && lr.c(), attr(ar, "class", "preview-container svelte-1qh4vd6");
    },
    m(ur, dr) {
      insert(ur, ar, dr), lr && lr.m(ar, null);
    },
    p(ur, [dr]) {
      /*dataUrl*/
      ur[0] ? lr ? lr.p(ur, dr) : (lr = create_if_block$2(ur), lr.c(), lr.m(ar, null)) : lr && (lr.d(1), lr = null);
    },
    i: noop$1,
    o: noop$1,
    d(ur) {
      ur && detach(ar), lr && lr.d();
    }
  };
}
function instance$5(cr, ar, lr) {
  let { file: ur } = ar, { onDelete: dr } = ar, fr = "";
  const gr = new FileReader();
  gr.onload = (vr) => {
    var yr;
    typeof ((yr = vr == null ? void 0 : vr.target) == null ? void 0 : yr.result) == "string" && lr(0, fr = vr.target.result);
  }, ur && gr.readAsDataURL(ur);
  const mr = () => {
    dr(ur);
  };
  return cr.$$set = (vr) => {
    "file" in vr && lr(2, ur = vr.file), "onDelete" in vr && lr(3, dr = vr.onDelete);
  }, [fr, mr, ur, dr];
}
class FilePreview extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$5, create_fragment$7, safe_not_equal, { file: 2, onDelete: 3 }, add_css$5);
  }
  get file() {
    return this.$$.ctx[2];
  }
  set file(ar) {
    this.$$set({ file: ar }), flush();
  }
  get onDelete() {
    return this.$$.ctx[3];
  }
  set onDelete(ar) {
    this.$$set({ onDelete: ar }), flush();
  }
}
create_custom_element(FilePreview, { file: {}, onDelete: {} }, [], [], !0);
function create_fragment$6(cr) {
  let ar, lr, ur, dr;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), ur = svg_element("path"), dr = svg_element("path"), attr(lr, "d", "M455.111 284.444H512v682.667h-56.889z"), attr(lr, "fill", "#73777A"), attr(ur, "d", "M113.778 113.778h739.555v682.666H625.778v56.89h284.444V56.888H56.89v796.444h284.444v-56.889H113.778z"), attr(ur, "fill", "#73777A"), attr(dr, "d", "M284.444 415.289l39.823 39.822L483.556 307.2l159.288 147.911 39.823-39.822-199.111-187.733z"), attr(dr, "fill", "#73777A"), set_style(ar, "width", "50"), set_style(ar, "height", "30"), set_style(ar, "fill", "currentColor"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "version", "1.1"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(fr, gr) {
      insert(fr, ar, gr), append(ar, lr), append(ar, ur), append(ar, dr);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(fr) {
      fr && detach(ar);
    }
  };
}
class UploadButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$6, safe_not_equal, {});
  }
}
create_custom_element(UploadButton, {}, [], [], !0);
function add_css$4(cr) {
  append_styles(cr, "svelte-1w4b3tw", ".file-input.svelte-1w4b3tw{display:none}.upload-button.svelte-1w4b3tw{border:none;background-color:white;cursor:pointer}");
}
function create_fragment$5(cr) {
  let ar, lr, ur, dr, fr, gr, mr;
  return dr = new UploadButton({}), {
    c() {
      ar = element("input"), lr = space(), ur = element("button"), create_component(dr.$$.fragment), attr(ar, "type", "file"), attr(ar, "class", "file-input svelte-1w4b3tw"), attr(ar, "accept", "image/*"), attr(ur, "class", "upload-button svelte-1w4b3tw");
    },
    m(vr, yr) {
      insert(vr, ar, yr), cr[4](ar), insert(vr, lr, yr), insert(vr, ur, yr), mount_component(dr, ur, null), fr = !0, gr || (mr = [
        listen(
          ar,
          "change",
          /*handleChange*/
          cr[1]
        ),
        listen(ur, "click", prevent_default(
          /*click_handler*/
          cr[5]
        ))
      ], gr = !0);
    },
    p: noop$1,
    i(vr) {
      fr || (transition_in(dr.$$.fragment, vr), fr = !0);
    },
    o(vr) {
      transition_out(dr.$$.fragment, vr), fr = !1;
    },
    d(vr) {
      vr && (detach(ar), detach(lr), detach(ur)), cr[4](null), destroy_component(dr), gr = !1, run_all(mr);
    }
  };
}
const FILE_EXT_REGEX = /\.([\w]{1,7})$/i;
function instance$4(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, ndkStore, (Er) => lr(6, ur = Er)), component_subscribe(cr, localStore, (Er) => lr(7, dr = Er));
  let fr, gr, { fileArray: mr = [] } = ar, { opinionContent: vr } = ar;
  const yr = uploadUrl, _r = new distExports.VoidApi(yr), kr = async (Er) => {
    var Tr, Sr, Lr, Ir, Nr, Rr;
    const Cr = Er.target;
    if (!Cr.files) {
      console.log("Files array is empty");
      return;
    }
    for (gr of Cr.files) {
      const Mr = dr.pk;
      Mr ? !ur.signer && await privkeyLogin(Mr) : !ur.signer && await NDKlogin();
      const Dr = await _r.getUploader(gr).upload({ "V-Strip-Metadata": "true" });
      if (Dr.ok) {
        let Hr = gr.name.match(FILE_EXT_REGEX);
        ((Sr = (Tr = Dr.file) == null ? void 0 : Tr.metadata) == null ? void 0 : Sr.mimeType) === "image/webp" && (Hr = ["", "webp"]);
        const Fr = (Rr = (Ir = (Lr = Dr.file) == null ? void 0 : Lr.metadata) == null ? void 0 : Ir.url) != null ? Rr : `${yr}/d/${(Nr = Dr.file) == null ? void 0 : Nr.id}${Hr ? `.${Hr[1]}` : ""}`;
        lr(2, mr = [...mr, { files: gr, url: Fr }]), lr(3, vr = vr + " " + Fr);
      }
    }
  };
  function xr(Er) {
    binding_callbacks[Er ? "unshift" : "push"](() => {
      fr = Er, lr(0, fr);
    });
  }
  const Ar = () => fr.click();
  return cr.$$set = (Er) => {
    "fileArray" in Er && lr(2, mr = Er.fileArray), "opinionContent" in Er && lr(3, vr = Er.opinionContent);
  }, [
    fr,
    kr,
    mr,
    vr,
    xr,
    Ar
  ];
}
class Upload extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$4, create_fragment$5, safe_not_equal, { fileArray: 2, opinionContent: 3 }, add_css$4);
  }
  get fileArray() {
    return this.$$.ctx[2];
  }
  set fileArray(ar) {
    this.$$set({ fileArray: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[3];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(Upload, { fileArray: {}, opinionContent: {} }, [], [], !0);
function create_fragment$4(cr) {
  let ar, lr, ur;
  return {
    c() {
      ar = svg_element("svg"), lr = svg_element("path"), ur = svg_element("path"), attr(lr, "d", "M967.111 227.556H739.556V56.889H284.444v170.667H56.89v56.888h113.778v682.667h682.666V284.444h113.778v-56.888zM341.333 113.778h341.334v113.778H341.333V113.778z m455.111 796.444H227.556V284.444h568.888v625.778z"), attr(lr, "fill", "#73777A"), attr(ur, "d", "M398.222 341.333h56.89v512h-56.89z m170.667 0h56.889v512h-56.89z"), attr(ur, "fill", "#73777A"), attr(ar, "class", "svg-icon"), set_style(ar, "width", "20"), set_style(ar, "height", "32"), set_style(ar, "vertical-align", "middle"), set_style(ar, "fill", "currentColor"), set_style(ar, "overflow", "hidden"), attr(ar, "viewBox", "0 0 1024 1024"), attr(ar, "version", "1.1"), attr(ar, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(dr, fr) {
      insert(dr, ar, fr), append(ar, lr), append(ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(dr) {
      dr && detach(ar);
    }
  };
}
class DeleteButton extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, null, create_fragment$4, safe_not_equal, {});
  }
}
create_custom_element(DeleteButton, {}, [], [], !0);
function add_css$3(cr) {
  append_styles(cr, "svelte-1nsksb0", ".card-button.svelte-1nsksb0.svelte-1nsksb0{display:inline-flex;align-items:center;gap:2px}.card-button.svelte-1nsksb0 button.svelte-1nsksb0{background:none;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}");
}
function create_fragment$3(cr) {
  let ar, lr, ur, dr, fr, gr;
  return ur = new DeleteButton({}), {
    c() {
      ar = element("div"), lr = element("button"), create_component(ur.$$.fragment), attr(lr, "class", "svelte-1nsksb0"), attr(ar, "class", "card-button svelte-1nsksb0");
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, lr), mount_component(ur, lr, null), dr = !0, fr || (gr = listen(
        lr,
        "click",
        /*click_handler*/
        cr[4]
      ), fr = !0);
    },
    p: noop$1,
    i(mr) {
      dr || (transition_in(ur.$$.fragment, mr), dr = !0);
    },
    o(mr) {
      transition_out(ur.$$.fragment, mr), dr = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_component(ur), fr = !1, gr();
    }
  };
}
function instance$3(cr, ar, lr) {
  let ur, dr;
  component_subscribe(cr, ndkStore, (_r) => lr(5, ur = _r)), component_subscribe(cr, localStore, (_r) => lr(6, dr = _r));
  let { eventID: fr } = ar, { isDeleted: gr } = ar, { count: mr } = ar;
  async function vr(_r) {
    try {
      const kr = dr.pk;
      kr ? !ur.signer && await privkeyLogin(kr) : !ur.signer && await NDKlogin();
      const xr = await ur.fetchEvent({ ids: [_r] });
      await db.events.delete(_r), await (xr == null ? void 0 : xr.delete()), lr(2, gr = !0), lr(3, mr = mr == 0 ? 0 : mr - 1);
    } catch (kr) {
      console.log("Error: ", kr);
    }
  }
  const yr = () => vr(fr);
  return cr.$$set = (_r) => {
    "eventID" in _r && lr(0, fr = _r.eventID), "isDeleted" in _r && lr(2, gr = _r.isDeleted), "count" in _r && lr(3, mr = _r.count);
  }, [fr, vr, gr, mr, yr];
}
class DeleteEventData extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$3, create_fragment$3, safe_not_equal, { eventID: 0, isDeleted: 2, count: 3 }, add_css$3);
  }
  get eventID() {
    return this.$$.ctx[0];
  }
  set eventID(ar) {
    this.$$set({ eventID: ar }), flush();
  }
  get isDeleted() {
    return this.$$.ctx[2];
  }
  set isDeleted(ar) {
    this.$$set({ isDeleted: ar }), flush();
  }
  get count() {
    return this.$$.ctx[3];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
}
create_custom_element(DeleteEventData, { eventID: {}, isDeleted: {}, count: {} }, [], [], !0);
function add_css$2(cr) {
  append_styles(cr, "svelte-nsiq7z", ".textarea-style.svelte-nsiq7z{width:100%;height:200px;background-color:#f8f8f8;color:#333;border:1px solid #ccc;border-radius:4px;padding:10px;font-family:'Arial', sans-serif;font-size:16px;line-height:1.5;resize:vertical;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);transition:border-color 0.3s, box-shadow 0.3s}");
}
function create_fragment$2(cr) {
  let ar, lr, ur, dr, fr;
  return {
    c() {
      ar = element("textarea"), attr(ar, "class", "textarea-style svelte-nsiq7z"), ar.value = "";
    },
    m(gr, mr) {
      insert(gr, ar, mr), cr[3](ar), ur = !0, dr || (fr = listen(
        ar,
        "input",
        /*updateContent*/
        cr[1]
      ), dr = !0);
    },
    p: noop$1,
    i(gr) {
      ur || (gr && add_render_callback(() => {
        ur && (lr || (lr = create_bidirectional_transition(ar, slide, {}, !0)), lr.run(1));
      }), ur = !0);
    },
    o(gr) {
      gr && (lr || (lr = create_bidirectional_transition(ar, slide, {}, !1)), lr.run(0)), ur = !1;
    },
    d(gr) {
      gr && detach(ar), cr[3](null), gr && lr && lr.end(), dr = !1, fr();
    }
  };
}
function instance$2(cr, ar, lr) {
  let ur, { opinionContent: dr } = ar;
  const fr = () => {
    lr(2, dr = ur.value);
  };
  onMount(() => {
    lr(0, ur.value = dr, ur);
  });
  function gr(mr) {
    binding_callbacks[mr ? "unshift" : "push"](() => {
      ur = mr, lr(0, ur), lr(2, dr);
    });
  }
  return cr.$$set = (mr) => {
    "opinionContent" in mr && lr(2, dr = mr.opinionContent);
  }, cr.$$.update = () => {
    cr.$$.dirty & /*textarea, opinionContent*/
    5 && ur && lr(0, ur.value = dr, ur);
  }, [ur, fr, dr, gr];
}
class TextArea extends SvelteComponent {
  constructor(ar) {
    super(), init(this, ar, instance$2, create_fragment$2, safe_not_equal, { opinionContent: 2 }, add_css$2);
  }
  get opinionContent() {
    return this.$$.ctx[2];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
}
create_custom_element(TextArea, { opinionContent: {} }, [], [], !0);
/*! @license DOMPurify 3.0.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.8/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object, {
  apply,
  construct
} = typeof Reflect != "undefined" && Reflect;
freeze || (freeze = function(ar) {
  return ar;
});
seal || (seal = function(ar) {
  return ar;
});
apply || (apply = function(ar, lr, ur) {
  return ar.apply(lr, ur);
});
construct || (construct = function(ar, lr) {
  return new ar(...lr);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(cr) {
  return function(ar) {
    for (var lr = arguments.length, ur = new Array(lr > 1 ? lr - 1 : 0), dr = 1; dr < lr; dr++)
      ur[dr - 1] = arguments[dr];
    return apply(cr, ar, ur);
  };
}
function unconstruct(cr) {
  return function() {
    for (var ar = arguments.length, lr = new Array(ar), ur = 0; ur < ar; ur++)
      lr[ur] = arguments[ur];
    return construct(cr, lr);
  };
}
function addToSet(cr, ar) {
  let lr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(cr, null);
  let ur = ar.length;
  for (; ur--; ) {
    let dr = ar[ur];
    if (typeof dr == "string") {
      const fr = lr(dr);
      fr !== dr && (isFrozen(ar) || (ar[ur] = fr), dr = fr);
    }
    cr[dr] = !0;
  }
  return cr;
}
function cleanArray(cr) {
  for (let ar = 0; ar < cr.length; ar++)
    getOwnPropertyDescriptor(cr, ar) === void 0 && (cr[ar] = null);
  return cr;
}
function clone(cr) {
  const ar = create(null);
  for (const [lr, ur] of entries(cr))
    getOwnPropertyDescriptor(cr, lr) !== void 0 && (Array.isArray(ur) ? ar[lr] = cleanArray(ur) : ur && typeof ur == "object" && ur.constructor === Object ? ar[lr] = clone(ur) : ar[lr] = ur);
  return ar;
}
function lookupGetter(cr, ar) {
  for (; cr !== null; ) {
    const ur = getOwnPropertyDescriptor(cr, ar);
    if (ur) {
      if (ur.get)
        return unapply(ur.get);
      if (typeof ur.value == "function")
        return unapply(ur.value);
    }
    cr = getPrototypeOf(cr);
  }
  function lr(ur) {
    return console.warn("fallback value for", ur), null;
  }
  return lr;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = function cr() {
  return typeof window == "undefined" ? null : window;
}, _createTrustedTypesPolicy = function cr(ar, lr) {
  if (typeof ar != "object" || typeof ar.createPolicy != "function")
    return null;
  let ur = null;
  const dr = "data-tt-policy-suffix";
  lr && lr.hasAttribute(dr) && (ur = lr.getAttribute(dr));
  const fr = "dompurify" + (ur ? "#" + ur : "");
  try {
    return ar.createPolicy(fr, {
      createHTML(gr) {
        return gr;
      },
      createScriptURL(gr) {
        return gr;
      }
    });
  } catch (gr) {
    return console.warn("TrustedTypes policy " + fr + " could not be created."), null;
  }
};
function createDOMPurify() {
  let cr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const ar = (Ci) => createDOMPurify(Ci);
  if (ar.version = "3.0.8", ar.removed = [], !cr || !cr.document || cr.document.nodeType !== 9)
    return ar.isSupported = !1, ar;
  let {
    document: lr
  } = cr;
  const ur = lr, dr = ur.currentScript, {
    DocumentFragment: fr,
    HTMLTemplateElement: gr,
    Node: mr,
    Element: vr,
    NodeFilter: yr,
    NamedNodeMap: _r = cr.NamedNodeMap || cr.MozNamedAttrMap,
    HTMLFormElement: kr,
    DOMParser: xr,
    trustedTypes: Ar
  } = cr, Er = vr.prototype, Cr = lookupGetter(Er, "cloneNode"), Tr = lookupGetter(Er, "nextSibling"), Sr = lookupGetter(Er, "childNodes"), Lr = lookupGetter(Er, "parentNode");
  if (typeof gr == "function") {
    const Ci = lr.createElement("template");
    Ci.content && Ci.content.ownerDocument && (lr = Ci.content.ownerDocument);
  }
  let Ir, Nr = "";
  const {
    implementation: Rr,
    createNodeIterator: Mr,
    createDocumentFragment: Br,
    getElementsByTagName: Dr
  } = lr, {
    importNode: Hr
  } = ur;
  let Fr = {};
  ar.isSupported = typeof entries == "function" && typeof Lr == "function" && Rr && Rr.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: zr,
    ERB_EXPR: Ur,
    TMPLIT_EXPR: jr,
    DATA_ATTR: Yr,
    ARIA_ATTR: qr,
    IS_SCRIPT_OR_DATA: Wr,
    ATTR_WHITESPACE: Jr
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: Gr
  } = EXPRESSIONS, Vr = null;
  const Qr = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let $r = null;
  const Xr = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let si = Object.seal(create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Zr = null, li = null, Ei = !0, ki = !0, Di = !1, hi = !0, Ti = !1, fi = !1, Mi = !1, oi = !1, Ri = !1, qi = !1, zi = !1, to = !0, Hi = !1;
  const _i = "user-content-";
  let Ai = !0, ui = !1, ji = {}, ai = null;
  const Li = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let $i = null;
  const Wi = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let io = null;
  const ro = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mi = "http://www.w3.org/1998/Math/MathML", di = "http://www.w3.org/2000/svg", yi = "http://www.w3.org/1999/xhtml";
  let Bi = yi, Ii = !1, Fi = null;
  const eo = addToSet({}, [mi, di, yi], stringToString);
  let Ui = null;
  const Vi = ["application/xhtml+xml", "text/html"], Gi = "text/html";
  let bi = null, Ji = null;
  const oo = lr.createElement("form"), ci = function(ei) {
    return ei instanceof RegExp || ei instanceof Function;
  }, wi = function() {
    let ei = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ji && Ji === ei)) {
      if ((!ei || typeof ei != "object") && (ei = {}), ei = clone(ei), Ui = // eslint-disable-next-line unicorn/prefer-includes
      Vi.indexOf(ei.PARSER_MEDIA_TYPE) === -1 ? Gi : ei.PARSER_MEDIA_TYPE, bi = Ui === "application/xhtml+xml" ? stringToString : stringToLowerCase, Vr = "ALLOWED_TAGS" in ei ? addToSet({}, ei.ALLOWED_TAGS, bi) : Qr, $r = "ALLOWED_ATTR" in ei ? addToSet({}, ei.ALLOWED_ATTR, bi) : Xr, Fi = "ALLOWED_NAMESPACES" in ei ? addToSet({}, ei.ALLOWED_NAMESPACES, stringToString) : eo, io = "ADD_URI_SAFE_ATTR" in ei ? addToSet(
        clone(ro),
        // eslint-disable-line indent
        ei.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        bi
        // eslint-disable-line indent
      ) : ro, $i = "ADD_DATA_URI_TAGS" in ei ? addToSet(
        clone(Wi),
        // eslint-disable-line indent
        ei.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        bi
        // eslint-disable-line indent
      ) : Wi, ai = "FORBID_CONTENTS" in ei ? addToSet({}, ei.FORBID_CONTENTS, bi) : Li, Zr = "FORBID_TAGS" in ei ? addToSet({}, ei.FORBID_TAGS, bi) : {}, li = "FORBID_ATTR" in ei ? addToSet({}, ei.FORBID_ATTR, bi) : {}, ji = "USE_PROFILES" in ei ? ei.USE_PROFILES : !1, Ei = ei.ALLOW_ARIA_ATTR !== !1, ki = ei.ALLOW_DATA_ATTR !== !1, Di = ei.ALLOW_UNKNOWN_PROTOCOLS || !1, hi = ei.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ti = ei.SAFE_FOR_TEMPLATES || !1, fi = ei.WHOLE_DOCUMENT || !1, Ri = ei.RETURN_DOM || !1, qi = ei.RETURN_DOM_FRAGMENT || !1, zi = ei.RETURN_TRUSTED_TYPE || !1, oi = ei.FORCE_BODY || !1, to = ei.SANITIZE_DOM !== !1, Hi = ei.SANITIZE_NAMED_PROPS || !1, Ai = ei.KEEP_CONTENT !== !1, ui = ei.IN_PLACE || !1, Gr = ei.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, Bi = ei.NAMESPACE || yi, si = ei.CUSTOM_ELEMENT_HANDLING || {}, ei.CUSTOM_ELEMENT_HANDLING && ci(ei.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (si.tagNameCheck = ei.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ei.CUSTOM_ELEMENT_HANDLING && ci(ei.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (si.attributeNameCheck = ei.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ei.CUSTOM_ELEMENT_HANDLING && typeof ei.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (si.allowCustomizedBuiltInElements = ei.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ti && (ki = !1), qi && (Ri = !0), ji && (Vr = addToSet({}, text), $r = [], ji.html === !0 && (addToSet(Vr, html$1), addToSet($r, html)), ji.svg === !0 && (addToSet(Vr, svg$1), addToSet($r, svg), addToSet($r, xml)), ji.svgFilters === !0 && (addToSet(Vr, svgFilters), addToSet($r, svg), addToSet($r, xml)), ji.mathMl === !0 && (addToSet(Vr, mathMl$1), addToSet($r, mathMl), addToSet($r, xml))), ei.ADD_TAGS && (Vr === Qr && (Vr = clone(Vr)), addToSet(Vr, ei.ADD_TAGS, bi)), ei.ADD_ATTR && ($r === Xr && ($r = clone($r)), addToSet($r, ei.ADD_ATTR, bi)), ei.ADD_URI_SAFE_ATTR && addToSet(io, ei.ADD_URI_SAFE_ATTR, bi), ei.FORBID_CONTENTS && (ai === Li && (ai = clone(ai)), addToSet(ai, ei.FORBID_CONTENTS, bi)), Ai && (Vr["#text"] = !0), fi && addToSet(Vr, ["html", "head", "body"]), Vr.table && (addToSet(Vr, ["tbody"]), delete Zr.tbody), ei.TRUSTED_TYPES_POLICY) {
        if (typeof ei.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof ei.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        Ir = ei.TRUSTED_TYPES_POLICY, Nr = Ir.createHTML("");
      } else
        Ir === void 0 && (Ir = _createTrustedTypesPolicy(Ar, dr)), Ir !== null && typeof Nr == "string" && (Nr = Ir.createHTML(""));
      freeze && freeze(ei), Ji = ei;
    }
  }, Qi = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), ao = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]), co = addToSet({}, ["title", "style", "font", "a", "script"]), bo = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), _o = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), ko = function(ei) {
    let gi = Lr(ei);
    (!gi || !gi.tagName) && (gi = {
      namespaceURI: Bi,
      tagName: "template"
    });
    const Si = stringToLowerCase(ei.tagName), Zi = stringToLowerCase(gi.tagName);
    return Fi[ei.namespaceURI] ? ei.namespaceURI === di ? gi.namespaceURI === yi ? Si === "svg" : gi.namespaceURI === mi ? Si === "svg" && (Zi === "annotation-xml" || Qi[Zi]) : !!bo[Si] : ei.namespaceURI === mi ? gi.namespaceURI === yi ? Si === "math" : gi.namespaceURI === di ? Si === "math" && ao[Zi] : !!_o[Si] : ei.namespaceURI === yi ? gi.namespaceURI === di && !ao[Zi] || gi.namespaceURI === mi && !Qi[Zi] ? !1 : !_o[Si] && (co[Si] || !bo[Si]) : !!(Ui === "application/xhtml+xml" && Fi[ei.namespaceURI]) : !1;
  }, vo = function(ei) {
    arrayPush(ar.removed, {
      element: ei
    });
    try {
      ei.parentNode.removeChild(ei);
    } catch (gi) {
      ei.remove();
    }
  }, yo = function(ei, gi) {
    try {
      arrayPush(ar.removed, {
        attribute: gi.getAttributeNode(ei),
        from: gi
      });
    } catch (Si) {
      arrayPush(ar.removed, {
        attribute: null,
        from: gi
      });
    }
    if (gi.removeAttribute(ei), ei === "is" && !$r[ei])
      if (Ri || qi)
        try {
          vo(gi);
        } catch (Si) {
        }
      else
        try {
          gi.setAttribute(ei, "");
        } catch (Si) {
        }
  }, fo = function(ei) {
    let gi = null, Si = null;
    if (oi)
      ei = "<remove></remove>" + ei;
    else {
      const uo = stringMatch(ei, /^[\r\n\t ]+/);
      Si = uo && uo[0];
    }
    Ui === "application/xhtml+xml" && Bi === yi && (ei = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ei + "</body></html>");
    const Zi = Ir ? Ir.createHTML(ei) : ei;
    if (Bi === yi)
      try {
        gi = new xr().parseFromString(Zi, Ui);
      } catch (uo) {
      }
    if (!gi || !gi.documentElement) {
      gi = Rr.createDocument(Bi, "template", null);
      try {
        gi.documentElement.innerHTML = Ii ? Nr : Zi;
      } catch (uo) {
      }
    }
    const lo = gi.body || gi.documentElement;
    return ei && Si && lo.insertBefore(lr.createTextNode(Si), lo.childNodes[0] || null), Bi === yi ? Dr.call(gi, fi ? "html" : "body")[0] : fi ? gi.documentElement : lo;
  }, To = function(ei) {
    return Mr.call(
      ei.ownerDocument || ei,
      ei,
      // eslint-disable-next-line no-bitwise
      yr.SHOW_ELEMENT | yr.SHOW_COMMENT | yr.SHOW_TEXT,
      null
    );
  }, Io = function(ei) {
    return ei instanceof kr && (typeof ei.nodeName != "string" || typeof ei.textContent != "string" || typeof ei.removeChild != "function" || !(ei.attributes instanceof _r) || typeof ei.removeAttribute != "function" || typeof ei.setAttribute != "function" || typeof ei.namespaceURI != "string" || typeof ei.insertBefore != "function" || typeof ei.hasChildNodes != "function");
  }, So = function(ei) {
    return typeof mr == "function" && ei instanceof mr;
  }, po = function(ei, gi, Si) {
    Fr[ei] && arrayForEach(Fr[ei], (Zi) => {
      Zi.call(ar, gi, Si, Ji);
    });
  }, Ni = function(ei) {
    let gi = null;
    if (po("beforeSanitizeElements", ei, null), Io(ei))
      return vo(ei), !0;
    const Si = bi(ei.nodeName);
    if (po("uponSanitizeElement", ei, {
      tagName: Si,
      allowedTags: Vr
    }), ei.hasChildNodes() && !So(ei.firstElementChild) && regExpTest(/<[/\w]/g, ei.innerHTML) && regExpTest(/<[/\w]/g, ei.textContent))
      return vo(ei), !0;
    if (!Vr[Si] || Zr[Si]) {
      if (!Zr[Si] && vi(Si) && (si.tagNameCheck instanceof RegExp && regExpTest(si.tagNameCheck, Si) || si.tagNameCheck instanceof Function && si.tagNameCheck(Si)))
        return !1;
      if (Ai && !ai[Si]) {
        const Zi = Lr(ei) || ei.parentNode, lo = Sr(ei) || ei.childNodes;
        if (lo && Zi) {
          const uo = lo.length;
          for (let ho = uo - 1; ho >= 0; --ho)
            Zi.insertBefore(Cr(lo[ho], !0), Tr(ei));
        }
      }
      return vo(ei), !0;
    }
    return ei instanceof vr && !ko(ei) || (Si === "noscript" || Si === "noembed" || Si === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, ei.innerHTML) ? (vo(ei), !0) : (Ti && ei.nodeType === 3 && (gi = ei.textContent, arrayForEach([zr, Ur, jr], (Zi) => {
      gi = stringReplace(gi, Zi, " ");
    }), ei.textContent !== gi && (arrayPush(ar.removed, {
      element: ei.cloneNode()
    }), ei.textContent = gi)), po("afterSanitizeElements", ei, null), !1);
  }, ri = function(ei, gi, Si) {
    if (to && (gi === "id" || gi === "name") && (Si in lr || Si in oo))
      return !1;
    if (!(ki && !li[gi] && regExpTest(Yr, gi))) {
      if (!(Ei && regExpTest(qr, gi))) {
        if (!$r[gi] || li[gi]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(vi(ei) && (si.tagNameCheck instanceof RegExp && regExpTest(si.tagNameCheck, ei) || si.tagNameCheck instanceof Function && si.tagNameCheck(ei)) && (si.attributeNameCheck instanceof RegExp && regExpTest(si.attributeNameCheck, gi) || si.attributeNameCheck instanceof Function && si.attributeNameCheck(gi)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            gi === "is" && si.allowCustomizedBuiltInElements && (si.tagNameCheck instanceof RegExp && regExpTest(si.tagNameCheck, Si) || si.tagNameCheck instanceof Function && si.tagNameCheck(Si)))
          )
            return !1;
        } else if (!io[gi]) {
          if (!regExpTest(Gr, stringReplace(Si, Jr, ""))) {
            if (!((gi === "src" || gi === "xlink:href" || gi === "href") && ei !== "script" && stringIndexOf(Si, "data:") === 0 && $i[ei])) {
              if (!(Di && !regExpTest(Wr, stringReplace(Si, Jr, "")))) {
                if (Si)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, vi = function(ei) {
    return ei.indexOf("-") > 0;
  }, Oi = function(ei) {
    po("beforeSanitizeAttributes", ei, null);
    const {
      attributes: gi
    } = ei;
    if (!gi)
      return;
    const Si = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: $r
    };
    let Zi = gi.length;
    for (; Zi--; ) {
      const lo = gi[Zi], {
        name: uo,
        namespaceURI: ho,
        value: Ro
      } = lo, Oo = bi(uo);
      let go = uo === "value" ? Ro : stringTrim(Ro);
      if (Si.attrName = Oo, Si.attrValue = go, Si.keepAttr = !0, Si.forceKeepAttr = void 0, po("uponSanitizeAttribute", ei, Si), go = Si.attrValue, Si.forceKeepAttr || (yo(uo, ei), !Si.keepAttr))
        continue;
      if (!hi && regExpTest(/\/>/i, go)) {
        yo(uo, ei);
        continue;
      }
      Ti && arrayForEach([zr, Ur, jr], ($o) => {
        go = stringReplace(go, $o, " ");
      });
      const qo = bi(ei.nodeName);
      if (ri(qo, Oo, go)) {
        if (Hi && (Oo === "id" || Oo === "name") && (yo(uo, ei), go = _i + go), Ir && typeof Ar == "object" && typeof Ar.getAttributeType == "function" && !ho)
          switch (Ar.getAttributeType(qo, Oo)) {
            case "TrustedHTML": {
              go = Ir.createHTML(go);
              break;
            }
            case "TrustedScriptURL": {
              go = Ir.createScriptURL(go);
              break;
            }
          }
        try {
          ho ? ei.setAttributeNS(ho, uo, go) : ei.setAttribute(uo, go), arrayPop(ar.removed);
        } catch ($o) {
        }
      }
    }
    po("afterSanitizeAttributes", ei, null);
  }, Yi = function Ci(ei) {
    let gi = null;
    const Si = To(ei);
    for (po("beforeSanitizeShadowDOM", ei, null); gi = Si.nextNode(); )
      po("uponSanitizeShadowNode", gi, null), !Ni(gi) && (gi.content instanceof fr && Ci(gi.content), Oi(gi));
    po("afterSanitizeShadowDOM", ei, null);
  };
  return ar.sanitize = function(Ci) {
    let ei = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, gi = null, Si = null, Zi = null, lo = null;
    if (Ii = !Ci, Ii && (Ci = "<!-->"), typeof Ci != "string" && !So(Ci))
      if (typeof Ci.toString == "function") {
        if (Ci = Ci.toString(), typeof Ci != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!ar.isSupported)
      return Ci;
    if (Mi || wi(ei), ar.removed = [], typeof Ci == "string" && (ui = !1), ui) {
      if (Ci.nodeName) {
        const Ro = bi(Ci.nodeName);
        if (!Vr[Ro] || Zr[Ro])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ci instanceof mr)
      gi = fo("<!---->"), Si = gi.ownerDocument.importNode(Ci, !0), Si.nodeType === 1 && Si.nodeName === "BODY" || Si.nodeName === "HTML" ? gi = Si : gi.appendChild(Si);
    else {
      if (!Ri && !Ti && !fi && // eslint-disable-next-line unicorn/prefer-includes
      Ci.indexOf("<") === -1)
        return Ir && zi ? Ir.createHTML(Ci) : Ci;
      if (gi = fo(Ci), !gi)
        return Ri ? null : zi ? Nr : "";
    }
    gi && oi && vo(gi.firstChild);
    const uo = To(ui ? Ci : gi);
    for (; Zi = uo.nextNode(); )
      Ni(Zi) || (Zi.content instanceof fr && Yi(Zi.content), Oi(Zi));
    if (ui)
      return Ci;
    if (Ri) {
      if (qi)
        for (lo = Br.call(gi.ownerDocument); gi.firstChild; )
          lo.appendChild(gi.firstChild);
      else
        lo = gi;
      return ($r.shadowroot || $r.shadowrootmode) && (lo = Hr.call(ur, lo, !0)), lo;
    }
    let ho = fi ? gi.outerHTML : gi.innerHTML;
    return fi && Vr["!doctype"] && gi.ownerDocument && gi.ownerDocument.doctype && gi.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, gi.ownerDocument.doctype.name) && (ho = "<!DOCTYPE " + gi.ownerDocument.doctype.name + `>
` + ho), Ti && arrayForEach([zr, Ur, jr], (Ro) => {
      ho = stringReplace(ho, Ro, " ");
    }), Ir && zi ? Ir.createHTML(ho) : ho;
  }, ar.setConfig = function() {
    let Ci = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    wi(Ci), Mi = !0;
  }, ar.clearConfig = function() {
    Ji = null, Mi = !1;
  }, ar.isValidAttribute = function(Ci, ei, gi) {
    Ji || wi({});
    const Si = bi(Ci), Zi = bi(ei);
    return ri(Si, Zi, gi);
  }, ar.addHook = function(Ci, ei) {
    typeof ei == "function" && (Fr[Ci] = Fr[Ci] || [], arrayPush(Fr[Ci], ei));
  }, ar.removeHook = function(Ci) {
    if (Fr[Ci])
      return arrayPop(Fr[Ci]);
  }, ar.removeHooks = function(Ci) {
    Fr[Ci] && (Fr[Ci] = []);
  }, ar.removeAllHooks = function() {
    Fr = {};
  }, ar;
}
var purify = createDOMPurify();
function add_css$1(cr) {
  append_styles(cr, "svelte-1we9jm8", `.opinion-container.svelte-1we9jm8{border:1px solid #e0e0e0;border-radius:8px;padding:16px;margin-bottom:16px;background-color:#fff;font-family:'Barlow', sans-serif}.opinion-top.svelte-1we9jm8{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.pubkey.svelte-1we9jm8{display:flex;align-items:center;gap:10px;font-size:16px;font-weight:500}.profile-header.svelte-1we9jm8{display:flex;align-items:center;gap:0.5rem;font-size:18px}.profile-image.svelte-1we9jm8{border-radius:50%;width:40px;height:40px;object-fit:cover}.date.svelte-1we9jm8{color:#757575;font-size:14px}.content.svelte-1we9jm8{color:#333;margin-bottom:16px;overflow:scroll
	}.read-more.svelte-1we9jm8{color:#4da84d;cursor:pointer}.loader.svelte-1we9jm8{display:flex;justify-content:center;align-items:center;margin:2rem 0}.reply-section.svelte-1we9jm8{padding:1rem}.reply-file-preview.svelte-1we9jm8{display:flex;gap:1rem;overflow:scroll;margin:1rem 0}.reply-footer.svelte-1we9jm8{display:flex;align-content:center}.reply-button.svelte-1we9jm8{padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem;background-color:#4DA84D;color:white
	}.card-button.svelte-1we9jm8{display:inline-flex;align-items:center;gap:2px}.option-button.svelte-1we9jm8{background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}#allReply.svelte-1we9jm8{background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}#replyButton.svelte-1we9jm8{background-color:transparent;border:none;cursor:pointer}.reactionButton.svelte-1we9jm8{background-color:transparent;border:none;cursor:pointer;display:flex;align-items:center;padding:8px}.reactionDiv.svelte-1we9jm8{display:flex;gap:2rem}.selected.svelte-1we9jm8{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center;background-color:#4DA84D;color:white}.deselected.svelte-1we9jm8{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;display:flex;justify-content:center;align-items:center}.postButton.svelte-1we9jm8{color:#ffffff;background-color:#4da84d;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}`);
}
function get_each_context$1(cr, ar, lr) {
  const ur = cr.slice();
  return ur[3] = ar[lr], ur;
}
function get_each_context_1$1(cr, ar, lr) {
  const ur = cr.slice();
  return ur[64] = ar[lr], ur;
}
function create_if_block$1(cr) {
  let ar, lr, ur, dr;
  const fr = [create_if_block_1$1, create_else_block_4], gr = [];
  function mr(vr, yr) {
    return !/*loading*/
    vr[18] && /*expertOpinions*/
    vr[12] ? 0 : 1;
  }
  return ar = mr(cr), lr = gr[ar] = fr[ar](cr), {
    c() {
      lr.c(), ur = empty$2();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), dr = !0;
    },
    p(vr, yr) {
      let _r = ar;
      ar = mr(vr), ar === _r ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[_r], 1, 1, () => {
        gr[_r] = null;
      }), check_outros(), lr = gr[ar], lr ? lr.p(vr, yr) : (lr = gr[ar] = fr[ar](vr), lr.c()), transition_in(lr, 1), lr.m(ur.parentNode, ur));
    },
    i(vr) {
      dr || (transition_in(lr), dr = !0);
    },
    o(vr) {
      transition_out(lr), dr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
function create_else_block_4(cr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "Loading...", attr(ar, "class", "loader svelte-1we9jm8");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_if_block_1$1(cr) {
  var Ji, oo;
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr = (
    /*trustedAuthors*/
    cr[9].includes(
      /*event*/
      cr[3].pubkey
    )
  ), xr, Ar, Er, Cr, Tr, Sr, Lr, Ir, Nr, Rr, Mr, Br, Dr, Hr, Fr, zr = (
    /*likeCount*/
    (cr[13] || 0) + ""
  ), Ur, jr, Yr, qr, Wr, Jr, Gr, Vr, Qr = (
    /*dislikeCount*/
    (cr[14] || 0) + ""
  ), $r, Xr, si, Zr, li, Ei, ki, Di, hi = (
    /*replyEvents*/
    cr[11].length + ""
  ), Ti, fi, Mi, oi, Ri, qi, zi, to, Hi;
  const _i = [create_if_block_13, create_if_block_14, create_if_block_15], Ai = [];
  function ui(ci, wi) {
    var Qi, ao;
    return wi[0] & /*event, editLvl*/
    12 && (fr = null), wi[0] & /*event, editLvl*/
    12 && (gr = null), fr == null && (fr = /*event*/
    ((Qi = ci[3].tags.find(func)) == null ? void 0 : Qi[1]) === "-1" && /*editLvl*/
    ci[2] === 1), fr ? 0 : (gr == null && (gr = /*event*/
    ((ao = ci[3].tags.find(func_1)) == null ? void 0 : ao[1]) === "0" && /*editLvl*/
    ci[2] === 1), gr ? 1 : (
      /*editLvl*/
      ci[2] === 1 ? 2 : -1
    ));
  }
  ~(mr = ui(cr, [-1, -1, -1])) && (vr = Ai[mr] = _i[mr](cr));
  function ji(ci, wi) {
    return (
      /*profiles*/
      ci[4][
        /*event*/
        ci[3].pubkey
      ] ? create_if_block_12 : create_else_block_3
    );
  }
  let ai = ji(cr), Li = ai(cr), $i = kr && create_if_block_11(), Wi = (
    /*published_at*/
    cr[23] && /*published_at*/
    cr[23] < /*created_at*/
    cr[24] && create_if_block_10()
  );
  const io = [create_if_block_8, create_else_block_2], ro = [];
  function mi(ci, wi) {
    return (
      /*edit*/
      ci[15] ? 1 : 0
    );
  }
  Sr = mi(cr), Lr = ro[Sr] = io[Sr](cr);
  const di = [create_if_block_7, create_else_block_1$1], yi = [];
  function Bi(ci, wi) {
    return (
      /*liked*/
      ci[19] === !0 ? 0 : 1
    );
  }
  Br = Bi(cr), Dr = yi[Br] = di[Br](cr);
  const Ii = [create_if_block_6, create_else_block$1], Fi = [];
  function eo(ci, wi) {
    return (
      /*disliked*/
      ci[20] === !0 ? 0 : 1
    );
  }
  Wr = eo(cr), Jr = Fi[Wr] = Ii[Wr](cr), li = new ReplyButton({});
  let Ui = (
    /*$ndkUser*/
    ((Ji = cr[26]) == null ? void 0 : Ji.pubkey) === /*event*/
    cr[3].pubkey && create_if_block_5$1(cr)
  ), Vi = (
    /*$ndkUser*/
    ((oo = cr[26]) == null ? void 0 : oo.pubkey) === /*event*/
    cr[3].pubkey && /*editLvl*/
    cr[2] == 1 && create_if_block_4$1(cr)
  ), Gi = (
    /*reply*/
    cr[16] && create_if_block_3$1(cr)
  ), bi = (
    /*replyContent*/
    cr[17] && create_if_block_2$1(cr)
  );
  return {
    c() {
      ar = element("div"), lr = element("div"), ur = element("div"), dr = element("div"), vr && vr.c(), yr = space(), Li.c(), _r = space(), $i && $i.c(), xr = space(), Ar = element("p"), Wi && Wi.c(), Er = space(), Cr = text$3(
        /*relativeTime*/
        cr[22]
      ), Tr = space(), Lr.c(), Ir = space(), Nr = element("div"), Rr = element("div"), Mr = element("button"), Dr.c(), Hr = space(), Fr = element("span"), Ur = text$3(zr), jr = space(), Yr = element("div"), qr = element("button"), Jr.c(), Gr = space(), Vr = element("span"), $r = text$3(Qr), Xr = space(), si = element("div"), Zr = element("button"), create_component(li.$$.fragment), Ei = space(), ki = element("button"), Di = element("span"), Ti = text$3(hi), fi = space(), Ui && Ui.c(), Mi = space(), Vi && Vi.c(), oi = space(), Gi && Gi.c(), Ri = space(), bi && bi.c(), attr(ur, "class", "pubkey svelte-1we9jm8"), attr(Ar, "class", "date svelte-1we9jm8"), attr(lr, "class", "opinion-top svelte-1we9jm8"), attr(Mr, "class", "reactionButton svelte-1we9jm8"), attr(Rr, "class", "card-button svelte-1we9jm8"), attr(qr, "class", "reactionButton svelte-1we9jm8"), attr(Yr, "class", "card-button svelte-1we9jm8"), attr(Zr, "id", "replyButton"), attr(Zr, "class", "svelte-1we9jm8"), set_style(Di, "pointer", "cursor"), attr(ki, "id", "allReply"), attr(ki, "class", "svelte-1we9jm8"), attr(si, "class", "card-button svelte-1we9jm8"), attr(Nr, "class", "reactionDiv svelte-1we9jm8"), attr(ar, "class", "opinion-container svelte-1we9jm8");
    },
    m(ci, wi) {
      insert(ci, ar, wi), append(ar, lr), append(lr, ur), append(ur, dr), ~mr && Ai[mr].m(dr, null), append(ur, yr), Li.m(ur, null), append(ur, _r), $i && $i.m(ur, null), append(lr, xr), append(lr, Ar), Wi && Wi.m(Ar, null), append(Ar, Er), append(Ar, Cr), append(ar, Tr), ro[Sr].m(ar, null), append(ar, Ir), append(ar, Nr), append(Nr, Rr), append(Rr, Mr), yi[Br].m(Mr, null), append(Rr, Hr), append(Rr, Fr), append(Fr, Ur), append(Nr, jr), append(Nr, Yr), append(Yr, qr), Fi[Wr].m(qr, null), append(Yr, Gr), append(Yr, Vr), append(Vr, $r), append(Nr, Xr), append(Nr, si), append(si, Zr), mount_component(li, Zr, null), append(si, Ei), append(si, ki), append(ki, Di), append(Di, Ti), append(Nr, fi), Ui && Ui.m(Nr, null), append(Nr, Mi), Vi && Vi.m(Nr, null), append(ar, oi), Gi && Gi.m(ar, null), append(ar, Ri), bi && bi.m(ar, null), zi = !0, to || (Hi = [
        listen(
          Mr,
          "click",
          /*click_handler_3*/
          cr[40]
        ),
        listen(
          qr,
          "click",
          /*click_handler_4*/
          cr[41]
        ),
        listen(
          Zr,
          "click",
          /*click_handler_5*/
          cr[42]
        ),
        listen(
          ki,
          "click",
          /*click_handler_6*/
          cr[43]
        )
      ], to = !0);
    },
    p(ci, wi) {
      var _o, ko;
      let Qi = mr;
      mr = ui(ci, wi), mr !== Qi && (vr && (group_outros(), transition_out(Ai[Qi], 1, 1, () => {
        Ai[Qi] = null;
      }), check_outros()), ~mr ? (vr = Ai[mr], vr || (vr = Ai[mr] = _i[mr](ci), vr.c()), transition_in(vr, 1), vr.m(dr, null)) : vr = null), ai === (ai = ji(ci)) && Li ? Li.p(ci, wi) : (Li.d(1), Li = ai(ci), Li && (Li.c(), Li.m(ur, _r))), wi[0] & /*trustedAuthors, event*/
      520 && (kr = /*trustedAuthors*/
      ci[9].includes(
        /*event*/
        ci[3].pubkey
      )), kr ? $i ? wi[0] & /*trustedAuthors, event*/
      520 && transition_in($i, 1) : ($i = create_if_block_11(), $i.c(), transition_in($i, 1), $i.m(ur, null)) : $i && (group_outros(), transition_out($i, 1, 1, () => {
        $i = null;
      }), check_outros()), /*published_at*/
      ci[23] && /*published_at*/
      ci[23] < /*created_at*/
      ci[24] ? Wi || (Wi = create_if_block_10(), Wi.c(), Wi.m(Ar, Er)) : Wi && (Wi.d(1), Wi = null), (!zi || wi[0] & /*relativeTime*/
      4194304) && set_data(
        Cr,
        /*relativeTime*/
        ci[22]
      );
      let ao = Sr;
      Sr = mi(ci), Sr === ao ? ro[Sr].p(ci, wi) : (group_outros(), transition_out(ro[ao], 1, 1, () => {
        ro[ao] = null;
      }), check_outros(), Lr = ro[Sr], Lr ? Lr.p(ci, wi) : (Lr = ro[Sr] = io[Sr](ci), Lr.c()), transition_in(Lr, 1), Lr.m(ar, Ir));
      let co = Br;
      Br = Bi(ci), Br !== co && (group_outros(), transition_out(yi[co], 1, 1, () => {
        yi[co] = null;
      }), check_outros(), Dr = yi[Br], Dr || (Dr = yi[Br] = di[Br](ci), Dr.c()), transition_in(Dr, 1), Dr.m(Mr, null)), (!zi || wi[0] & /*likeCount*/
      8192) && zr !== (zr = /*likeCount*/
      (ci[13] || 0) + "") && set_data(Ur, zr);
      let bo = Wr;
      Wr = eo(ci), Wr !== bo && (group_outros(), transition_out(Fi[bo], 1, 1, () => {
        Fi[bo] = null;
      }), check_outros(), Jr = Fi[Wr], Jr || (Jr = Fi[Wr] = Ii[Wr](ci), Jr.c()), transition_in(Jr, 1), Jr.m(qr, null)), (!zi || wi[0] & /*dislikeCount*/
      16384) && Qr !== (Qr = /*dislikeCount*/
      (ci[14] || 0) + "") && set_data($r, Qr), (!zi || wi[0] & /*replyEvents*/
      2048) && hi !== (hi = /*replyEvents*/
      ci[11].length + "") && set_data(Ti, hi), /*$ndkUser*/
      ((_o = ci[26]) == null ? void 0 : _o.pubkey) === /*event*/
      ci[3].pubkey ? Ui ? (Ui.p(ci, wi), wi[0] & /*$ndkUser, event*/
      67108872 && transition_in(Ui, 1)) : (Ui = create_if_block_5$1(ci), Ui.c(), transition_in(Ui, 1), Ui.m(Nr, Mi)) : Ui && (group_outros(), transition_out(Ui, 1, 1, () => {
        Ui = null;
      }), check_outros()), /*$ndkUser*/
      ((ko = ci[26]) == null ? void 0 : ko.pubkey) === /*event*/
      ci[3].pubkey && /*editLvl*/
      ci[2] == 1 ? Vi ? (Vi.p(ci, wi), wi[0] & /*$ndkUser, event, editLvl*/
      67108876 && transition_in(Vi, 1)) : (Vi = create_if_block_4$1(ci), Vi.c(), transition_in(Vi, 1), Vi.m(Nr, null)) : Vi && (group_outros(), transition_out(Vi, 1, 1, () => {
        Vi = null;
      }), check_outros()), /*reply*/
      ci[16] ? Gi ? (Gi.p(ci, wi), wi[0] & /*reply*/
      65536 && transition_in(Gi, 1)) : (Gi = create_if_block_3$1(ci), Gi.c(), transition_in(Gi, 1), Gi.m(ar, Ri)) : Gi && (group_outros(), transition_out(Gi, 1, 1, () => {
        Gi = null;
      }), check_outros()), /*replyContent*/
      ci[17] ? bi ? (bi.p(ci, wi), wi[0] & /*replyContent*/
      131072 && transition_in(bi, 1)) : (bi = create_if_block_2$1(ci), bi.c(), transition_in(bi, 1), bi.m(ar, null)) : bi && (group_outros(), transition_out(bi, 1, 1, () => {
        bi = null;
      }), check_outros());
    },
    i(ci) {
      zi || (transition_in(vr), transition_in($i), transition_in(Lr), transition_in(Dr), transition_in(Jr), transition_in(li.$$.fragment, ci), transition_in(Ui), transition_in(Vi), transition_in(Gi), transition_in(bi), ci && add_render_callback(() => {
        zi && (qi || (qi = create_bidirectional_transition(ar, slide, {}, !0)), qi.run(1));
      }), zi = !0);
    },
    o(ci) {
      transition_out(vr), transition_out($i), transition_out(Lr), transition_out(Dr), transition_out(Jr), transition_out(li.$$.fragment, ci), transition_out(Ui), transition_out(Vi), transition_out(Gi), transition_out(bi), ci && (qi || (qi = create_bidirectional_transition(ar, slide, {}, !1)), qi.run(0)), zi = !1;
    },
    d(ci) {
      ci && detach(ar), ~mr && Ai[mr].d(), Li.d(), $i && $i.d(), Wi && Wi.d(), ro[Sr].d(), yi[Br].d(), Fi[Wr].d(), destroy_component(li), Ui && Ui.d(), Vi && Vi.d(), Gi && Gi.d(), bi && bi.d(), ci && qi && qi.end(), to = !1, run_all(Hi);
    }
  };
}
function create_if_block_15(cr) {
  let ar, lr;
  return ar = new Positive({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_14(cr) {
  let ar, lr;
  return ar = new Neutral({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_13(cr) {
  let ar, lr;
  return ar = new Negative({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block_3(cr) {
  let ar, lr, ur, dr, fr, gr = convertNostrPubKeyToBech32(
    /*event*/
    cr[3].pubkey
  ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
    /*event*/
    cr[3].pubkey
  ).slice(-4), mr;
  return {
    c() {
      ar = element("div"), lr = element("img"), dr = space(), fr = element("span"), mr = text$3(gr), attr(lr, "class", "profile-image svelte-1we9jm8"), src_url_equal(lr.src, ur = profileImageUrl + /*event*/
      cr[3].pubkey) || attr(lr, "src", ur), attr(lr, "alt", "Profile"), attr(ar, "class", "profile-header svelte-1we9jm8");
    },
    m(vr, yr) {
      insert(vr, ar, yr), append(ar, lr), append(ar, dr), append(ar, fr), append(fr, mr);
    },
    p(vr, yr) {
      yr[0] & /*event*/
      8 && !src_url_equal(lr.src, ur = profileImageUrl + /*event*/
      vr[3].pubkey) && attr(lr, "src", ur), yr[0] & /*event*/
      8 && gr !== (gr = convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(0, 8) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        vr[3].pubkey
      ).slice(-4)) && set_data(mr, gr);
    },
    d(vr) {
      vr && detach(ar);
    }
  };
}
function create_if_block_12(cr) {
  var vr;
  let ar, lr, ur, dr, fr, gr = (
    /*profiles*/
    (((vr = cr[4][
      /*event*/
      cr[3].pubkey
    ].content) == null ? void 0 : vr.name) || convertNostrPubKeyToBech32(
      /*event*/
      cr[3].pubkey
    ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
      /*event*/
      cr[3].pubkey
    ).slice(-5)) + ""
  ), mr;
  return {
    c() {
      var yr, _r;
      ar = element("div"), lr = element("img"), dr = space(), fr = element("span"), mr = text$3(gr), attr(lr, "class", "profile-image svelte-1we9jm8"), src_url_equal(lr.src, ur = /*profiles*/
      (yr = cr[4][
        /*event*/
        cr[3].pubkey
      ].content) != null && yr.image ? (
        /*profiles*/
        (_r = cr[4][
          /*event*/
          cr[3].pubkey
        ].content) == null ? void 0 : _r.image
      ) : profileImageUrl + /*event*/
      cr[3].pubkey) || attr(lr, "src", ur), attr(lr, "alt", "Profile Picture"), attr(ar, "class", "profile-header svelte-1we9jm8");
    },
    m(yr, _r) {
      insert(yr, ar, _r), append(ar, lr), append(ar, dr), append(ar, fr), append(fr, mr);
    },
    p(yr, _r) {
      var kr, xr, Ar;
      _r[0] & /*profiles, event*/
      24 && !src_url_equal(lr.src, ur = /*profiles*/
      (kr = yr[4][
        /*event*/
        yr[3].pubkey
      ].content) != null && kr.image ? (
        /*profiles*/
        (xr = yr[4][
          /*event*/
          yr[3].pubkey
        ].content) == null ? void 0 : xr.image
      ) : profileImageUrl + /*event*/
      yr[3].pubkey) && attr(lr, "src", ur), _r[0] & /*profiles, event*/
      24 && gr !== (gr = /*profiles*/
      (((Ar = yr[4][
        /*event*/
        yr[3].pubkey
      ].content) == null ? void 0 : Ar.name) || convertNostrPubKeyToBech32(
        /*event*/
        yr[3].pubkey
      ).slice(0, 10) + "..." + convertNostrPubKeyToBech32(
        /*event*/
        yr[3].pubkey
      ).slice(-5)) + "") && set_data(mr, gr);
    },
    d(yr) {
      yr && detach(ar);
    }
  };
}
function create_if_block_11(cr) {
  let ar, lr;
  return ar = new ApprovedBadge({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_10(cr) {
  let ar;
  return {
    c() {
      ar = text$3("Edited.");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_else_block_2(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr, Ir, Nr, Rr, Mr, Br, Dr, Hr, Fr, zr, Ur, jr, Yr, qr, Wr;
  function Jr(Qr) {
    cr[34](Qr);
  }
  function Gr(Qr) {
    cr[35](Qr);
  }
  let Vr = {};
  return (
    /*fileArray*/
    cr[25] !== void 0 && (Vr.fileArray = /*fileArray*/
    cr[25]), /*opinionContent*/
    cr[5] !== void 0 && (Vr.opinionContent = /*opinionContent*/
    cr[5]), ur = new Editor_1({ props: Vr }), binding_callbacks.push(() => bind$1(ur, "fileArray", Jr)), binding_callbacks.push(() => bind$1(ur, "opinionContent", Gr)), xr = new Positive({}), Sr = new Neutral({}), Mr = new Negative({}), {
      c() {
        ar = element("div"), lr = element("form"), create_component(ur.$$.fragment), gr = space(), mr = element("div"), vr = element("label"), vr.textContent = "Choose your overall sentiment", yr = space(), _r = element("div"), kr = element("button"), create_component(xr.$$.fragment), Ar = space(), Er = element("span"), Er.textContent = "Positive", Cr = space(), Tr = element("button"), create_component(Sr.$$.fragment), Lr = space(), Ir = element("span"), Ir.textContent = "Neutral", Nr = space(), Rr = element("button"), create_component(Mr.$$.fragment), Br = space(), Dr = element("span"), Dr.textContent = "Negative", Hr = space(), Fr = element("button"), zr = text$3("Post"), attr(vr, "for", "sentiment"), set_style(vr, "font-weight", "600"), attr(kr, "class", "deselected svelte-1we9jm8"), toggle_class(
          kr,
          "selected",
          /*newOpinion*/
          cr[0].sentiment === "1"
        ), attr(Tr, "class", "deselected svelte-1we9jm8"), toggle_class(
          Tr,
          "selected",
          /*newOpinion*/
          cr[0].sentiment === "0"
        ), attr(Rr, "class", "deselected svelte-1we9jm8"), toggle_class(
          Rr,
          "selected",
          /*newOpinion*/
          cr[0].sentiment === "-1"
        ), set_style(_r, "display", "flex"), set_style(_r, "gap", "0.4rem"), attr(mr, "id", "sentiment-box"), set_style(mr, "display", "flex"), set_style(mr, "flex-direction", "column"), set_style(mr, "gap", "0.3rem"), set_style(mr, "margin-bottom", "1rem"), attr(Fr, "type", "submit"), Fr.disabled = Ur = !/*$ndkUser*/
        cr[26], attr(Fr, "class", "postButton svelte-1we9jm8"), set_style(ar, "margin", "2rem 0");
      },
      m(Qr, $r) {
        insert(Qr, ar, $r), append(ar, lr), mount_component(ur, lr, null), append(lr, gr), append(lr, mr), append(mr, vr), append(mr, yr), append(mr, _r), append(_r, kr), mount_component(xr, kr, null), append(kr, Ar), append(kr, Er), append(_r, Cr), append(_r, Tr), mount_component(Sr, Tr, null), append(Tr, Lr), append(Tr, Ir), append(_r, Nr), append(_r, Rr), mount_component(Mr, Rr, null), append(Rr, Br), append(Rr, Dr), append(lr, Hr), append(lr, Fr), append(Fr, zr), Yr = !0, qr || (Wr = [
          listen(kr, "click", prevent_default(
            /*click_handler*/
            cr[36]
          )),
          listen(Tr, "click", prevent_default(
            /*click_handler_1*/
            cr[37]
          )),
          listen(Rr, "click", prevent_default(
            /*click_handler_2*/
            cr[38]
          )),
          listen(lr, "submit", prevent_default(
            /*submit_handler*/
            cr[39]
          ))
        ], qr = !0);
      },
      p(Qr, $r) {
        const Xr = {};
        !dr && $r[0] & /*fileArray*/
        33554432 && (dr = !0, Xr.fileArray = /*fileArray*/
        Qr[25], add_flush_callback(() => dr = !1)), !fr && $r[0] & /*opinionContent*/
        32 && (fr = !0, Xr.opinionContent = /*opinionContent*/
        Qr[5], add_flush_callback(() => fr = !1)), ur.$set(Xr), (!Yr || $r[0] & /*newOpinion*/
        1) && toggle_class(
          kr,
          "selected",
          /*newOpinion*/
          Qr[0].sentiment === "1"
        ), (!Yr || $r[0] & /*newOpinion*/
        1) && toggle_class(
          Tr,
          "selected",
          /*newOpinion*/
          Qr[0].sentiment === "0"
        ), (!Yr || $r[0] & /*newOpinion*/
        1) && toggle_class(
          Rr,
          "selected",
          /*newOpinion*/
          Qr[0].sentiment === "-1"
        ), (!Yr || $r[0] & /*$ndkUser*/
        67108864 && Ur !== (Ur = !/*$ndkUser*/
        Qr[26])) && (Fr.disabled = Ur);
      },
      i(Qr) {
        Yr || (transition_in(ur.$$.fragment, Qr), transition_in(xr.$$.fragment, Qr), transition_in(Sr.$$.fragment, Qr), transition_in(Mr.$$.fragment, Qr), Qr && add_render_callback(() => {
          Yr && (jr || (jr = create_bidirectional_transition(ar, slide, {}, !0)), jr.run(1));
        }), Yr = !0);
      },
      o(Qr) {
        transition_out(ur.$$.fragment, Qr), transition_out(xr.$$.fragment, Qr), transition_out(Sr.$$.fragment, Qr), transition_out(Mr.$$.fragment, Qr), Qr && (jr || (jr = create_bidirectional_transition(ar, slide, {}, !1)), jr.run(0)), Yr = !1;
      },
      d(Qr) {
        Qr && detach(ar), destroy_component(ur), destroy_component(xr), destroy_component(Sr), destroy_component(Mr), Qr && jr && jr.end(), qr = !1, run_all(Wr);
      }
    }
  );
}
function create_if_block_8(cr) {
  let ar, lr, ur = (
    /*showFullText*/
    (cr[21] ? (
      /*editLvl*/
      cr[2] > 1 ? purify.sanitize(
        /*event*/
        cr[3].content
      ) : marked(purify.sanitize(
        /*event*/
        cr[3].content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")
      ))
    ) : (
      /*editLvl*/
      cr[2] > 1 ? truncateText(purify.sanitize(
        /*event*/
        cr[3].content
      ), maxLength) : marked(truncateText(purify.sanitize(
        /*event*/
        cr[3].content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")
      ), maxLength))
    )) + ""
  ), dr, fr = (
    /*event*/
    cr[3].content.length > maxLength && create_if_block_9(cr)
  );
  return {
    c() {
      ar = element("p"), lr = new HtmlTag(!1), dr = space(), fr && fr.c(), lr.a = dr, attr(ar, "class", "content svelte-1we9jm8");
    },
    m(gr, mr) {
      insert(gr, ar, mr), lr.m(ur, ar), append(ar, dr), fr && fr.m(ar, null);
    },
    p(gr, mr) {
      mr[0] & /*showFullText, editLvl, event*/
      2097164 && ur !== (ur = /*showFullText*/
      (gr[21] ? (
        /*editLvl*/
        gr[2] > 1 ? purify.sanitize(
          /*event*/
          gr[3].content
        ) : marked(purify.sanitize(
          /*event*/
          gr[3].content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")
        ))
      ) : (
        /*editLvl*/
        gr[2] > 1 ? truncateText(purify.sanitize(
          /*event*/
          gr[3].content
        ), maxLength) : marked(truncateText(purify.sanitize(
          /*event*/
          gr[3].content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")
        ), maxLength))
      )) + "") && lr.p(ur), /*event*/
      gr[3].content.length > maxLength ? fr ? fr.p(gr, mr) : (fr = create_if_block_9(gr), fr.c(), fr.m(ar, null)) : fr && (fr.d(1), fr = null);
    },
    i: noop$1,
    o: noop$1,
    d(gr) {
      gr && detach(ar), fr && fr.d();
    }
  };
}
function create_if_block_9(cr) {
  let ar, lr = (
    /*showFullText*/
    cr[21] ? " Read Less" : " Read More"
  ), ur, dr, fr;
  return {
    c() {
      ar = element("span"), ur = text$3(lr), attr(ar, "class", "read-more svelte-1we9jm8");
    },
    m(gr, mr) {
      insert(gr, ar, mr), append(ar, ur), dr || (fr = listen(
        ar,
        "click",
        /*toggleFullText*/
        cr[27]
      ), dr = !0);
    },
    p(gr, mr) {
      mr[0] & /*showFullText*/
      2097152 && lr !== (lr = /*showFullText*/
      gr[21] ? " Read Less" : " Read More") && set_data(ur, lr);
    },
    d(gr) {
      gr && detach(ar), dr = !1, fr();
    }
  };
}
function create_else_block_1$1(cr) {
  let ar, lr;
  return ar = new LikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_7(cr) {
  let ar, lr;
  return ar = new LikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_else_block$1(cr) {
  let ar, lr;
  return ar = new DislikeButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_6(cr) {
  let ar, lr;
  return ar = new DislikedButton({}), {
    c() {
      create_component(ar.$$.fragment);
    },
    m(ur, dr) {
      mount_component(ar, ur, dr), lr = !0;
    },
    i(ur) {
      lr || (transition_in(ar.$$.fragment, ur), lr = !0);
    },
    o(ur) {
      transition_out(ar.$$.fragment, ur), lr = !1;
    },
    d(ur) {
      destroy_component(ar, ur);
    }
  };
}
function create_if_block_5$1(cr) {
  let ar, lr, ur, dr;
  function fr(vr) {
    cr[44](vr);
  }
  function gr(vr) {
    cr[45](vr);
  }
  let mr = { eventID: (
    /*event*/
    cr[3].id
  ) };
  return (
    /*isDeleted*/
    cr[10] !== void 0 && (mr.isDeleted = /*isDeleted*/
    cr[10]), /*count*/
    cr[6] !== void 0 && (mr.count = /*count*/
    cr[6]), ar = new DeleteEventData({ props: mr }), binding_callbacks.push(() => bind$1(ar, "isDeleted", fr)), binding_callbacks.push(() => bind$1(ar, "count", gr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, yr) {
        mount_component(ar, vr, yr), dr = !0;
      },
      p(vr, yr) {
        const _r = {};
        yr[0] & /*event*/
        8 && (_r.eventID = /*event*/
        vr[3].id), !lr && yr[0] & /*isDeleted*/
        1024 && (lr = !0, _r.isDeleted = /*isDeleted*/
        vr[10], add_flush_callback(() => lr = !1)), !ur && yr[0] & /*count*/
        64 && (ur = !0, _r.count = /*count*/
        vr[6], add_flush_callback(() => ur = !1)), ar.$set(_r);
      },
      i(vr) {
        dr || (transition_in(ar.$$.fragment, vr), dr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), dr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_4$1(cr) {
  let ar, lr, ur, dr, fr, gr;
  return ur = new OptionButton({}), {
    c() {
      ar = element("div"), lr = element("button"), create_component(ur.$$.fragment), attr(lr, "class", "option-button svelte-1we9jm8"), attr(ar, "class", "card-button svelte-1we9jm8");
    },
    m(mr, vr) {
      insert(mr, ar, vr), append(ar, lr), mount_component(ur, lr, null), dr = !0, fr || (gr = listen(
        lr,
        "click",
        /*click_handler_7*/
        cr[46]
      ), fr = !0);
    },
    p: noop$1,
    i(mr) {
      dr || (transition_in(ur.$$.fragment, mr), dr = !0);
    },
    o(mr) {
      transition_out(ur.$$.fragment, mr), dr = !1;
    },
    d(mr) {
      mr && detach(ar), destroy_component(ur), fr = !1, gr();
    }
  };
}
function create_if_block_3$1(cr) {
  let ar, lr, ur, dr, fr, gr = [], mr = /* @__PURE__ */ new Map(), vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr, Lr, Ir, Nr;
  function Rr(Ur) {
    cr[47](Ur);
  }
  let Mr = {};
  /*opinionContent*/
  cr[5] !== void 0 && (Mr.opinionContent = /*opinionContent*/
  cr[5]), lr = new TextArea({ props: Mr }), binding_callbacks.push(() => bind$1(lr, "opinionContent", Rr));
  let Br = ensure_array_like(
    /*fileArray*/
    cr[25]
  );
  const Dr = (Ur) => (
    /*file*/
    Ur[64].url
  );
  for (let Ur = 0; Ur < Br.length; Ur += 1) {
    let jr = get_each_context_1$1(cr, Br, Ur), Yr = Dr(jr);
    mr.set(Yr, gr[Ur] = create_each_block_1$1(Yr, jr));
  }
  function Hr(Ur) {
    cr[50](Ur);
  }
  function Fr(Ur) {
    cr[51](Ur);
  }
  let zr = {};
  return (
    /*fileArray*/
    cr[25] !== void 0 && (zr.fileArray = /*fileArray*/
    cr[25]), /*opinionContent*/
    cr[5] !== void 0 && (zr.opinionContent = /*opinionContent*/
    cr[5]), Er = new Upload({ props: zr }), binding_callbacks.push(() => bind$1(Er, "fileArray", Hr)), binding_callbacks.push(() => bind$1(Er, "opinionContent", Fr)), {
      c() {
        ar = element("div"), create_component(lr.$$.fragment), dr = space(), fr = element("div");
        for (let Ur = 0; Ur < gr.length; Ur += 1)
          gr[Ur].c();
        vr = space(), yr = element("div"), _r = element("button"), kr = text$3("Reply"), Ar = space(), create_component(Er.$$.fragment), attr(fr, "class", "reply-file-preview svelte-1we9jm8"), attr(_r, "class", "reply-button svelte-1we9jm8"), _r.disabled = xr = !/*$ndkUser*/
        cr[26], attr(yr, "class", "reply-footer svelte-1we9jm8"), attr(ar, "class", "reply-section svelte-1we9jm8");
      },
      m(Ur, jr) {
        insert(Ur, ar, jr), mount_component(lr, ar, null), append(ar, dr), append(ar, fr);
        for (let Yr = 0; Yr < gr.length; Yr += 1)
          gr[Yr] && gr[Yr].m(fr, null);
        append(ar, vr), append(ar, yr), append(yr, _r), append(_r, kr), append(yr, Ar), mount_component(Er, yr, null), Lr = !0, Ir || (Nr = listen(
          _r,
          "click",
          /*click_handler_8*/
          cr[49]
        ), Ir = !0);
      },
      p(Ur, jr) {
        const Yr = {};
        !ur && jr[0] & /*opinionContent*/
        32 && (ur = !0, Yr.opinionContent = /*opinionContent*/
        Ur[5], add_flush_callback(() => ur = !1)), lr.$set(Yr), jr[0] & /*fileArray*/
        33554432 | jr[1] & /*deleteFile*/
        1 && (Br = ensure_array_like(
          /*fileArray*/
          Ur[25]
        ), group_outros(), gr = update_keyed_each(gr, jr, Dr, 1, Ur, Br, mr, fr, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1), check_outros()), (!Lr || jr[0] & /*$ndkUser*/
        67108864 && xr !== (xr = !/*$ndkUser*/
        Ur[26])) && (_r.disabled = xr);
        const qr = {};
        !Cr && jr[0] & /*fileArray*/
        33554432 && (Cr = !0, qr.fileArray = /*fileArray*/
        Ur[25], add_flush_callback(() => Cr = !1)), !Tr && jr[0] & /*opinionContent*/
        32 && (Tr = !0, qr.opinionContent = /*opinionContent*/
        Ur[5], add_flush_callback(() => Tr = !1)), Er.$set(qr);
      },
      i(Ur) {
        if (!Lr) {
          transition_in(lr.$$.fragment, Ur);
          for (let jr = 0; jr < Br.length; jr += 1)
            transition_in(gr[jr]);
          transition_in(Er.$$.fragment, Ur), Ur && add_render_callback(() => {
            Lr && (Sr || (Sr = create_bidirectional_transition(ar, fade, {}, !0)), Sr.run(1));
          }), Lr = !0;
        }
      },
      o(Ur) {
        transition_out(lr.$$.fragment, Ur);
        for (let jr = 0; jr < gr.length; jr += 1)
          transition_out(gr[jr]);
        transition_out(Er.$$.fragment, Ur), Ur && (Sr || (Sr = create_bidirectional_transition(ar, fade, {}, !1)), Sr.run(0)), Lr = !1;
      },
      d(Ur) {
        Ur && detach(ar), destroy_component(lr);
        for (let jr = 0; jr < gr.length; jr += 1)
          gr[jr].d();
        destroy_component(Er), Ur && Sr && Sr.end(), Ir = !1, Nr();
      }
    }
  );
}
function create_each_block_1$1(cr, ar) {
  let lr, ur, dr;
  function fr() {
    return (
      /*func_2*/
      ar[48](
        /*file*/
        ar[64]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[64].files
      ),
      onDelete: fr
    }
  }), {
    key: cr,
    first: null,
    c() {
      lr = empty$2(), create_component(ur.$$.fragment), this.first = lr;
    },
    m(gr, mr) {
      insert(gr, lr, mr), mount_component(ur, gr, mr), dr = !0;
    },
    p(gr, mr) {
      ar = gr;
      const vr = {};
      mr[0] & /*fileArray*/
      33554432 && (vr.file = /*file*/
      ar[64].files), mr[0] & /*fileArray*/
      33554432 && (vr.onDelete = fr), ur.$set(vr);
    },
    i(gr) {
      dr || (transition_in(ur.$$.fragment, gr), dr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), dr = !1;
    },
    d(gr) {
      gr && detach(lr), destroy_component(ur, gr);
    }
  };
}
function create_if_block_2$1(cr) {
  let ar = [], lr = /* @__PURE__ */ new Map(), ur, dr, fr = ensure_array_like(
    /*replyEvents*/
    cr[11]
  );
  const gr = (mr) => (
    /*event*/
    mr[3].id
  );
  for (let mr = 0; mr < fr.length; mr += 1) {
    let vr = get_each_context$1(cr, fr, mr), yr = gr(vr);
    lr.set(yr, ar[mr] = create_each_block$1(yr, vr));
  }
  return {
    c() {
      for (let mr = 0; mr < ar.length; mr += 1)
        ar[mr].c();
      ur = empty$2();
    },
    m(mr, vr) {
      for (let yr = 0; yr < ar.length; yr += 1)
        ar[yr] && ar[yr].m(mr, vr);
      insert(mr, ur, vr), dr = !0;
    },
    p(mr, vr) {
      vr[0] & /*replyEvents, profiles, editLvl, subject, sentimentCount, opinionContent, newOpinion*/
      2359 && (fr = ensure_array_like(
        /*replyEvents*/
        mr[11]
      ), group_outros(), ar = update_keyed_each(ar, vr, gr, 1, mr, fr, lr, ur.parentNode, outro_and_destroy_block, create_each_block$1, ur, get_each_context$1), check_outros());
    },
    i(mr) {
      if (!dr) {
        for (let vr = 0; vr < fr.length; vr += 1)
          transition_in(ar[vr]);
        dr = !0;
      }
    },
    o(mr) {
      for (let vr = 0; vr < ar.length; vr += 1)
        transition_out(ar[vr]);
      dr = !1;
    },
    d(mr) {
      mr && detach(ur);
      for (let vr = 0; vr < ar.length; vr += 1)
        ar[vr].d(mr);
    }
  };
}
function create_each_block$1(cr, ar) {
  let lr, ur, dr, fr, gr, mr, vr;
  function yr(Er) {
    ar[52](Er);
  }
  function _r(Er) {
    ar[53](Er);
  }
  function kr(Er) {
    ar[54](Er);
  }
  function xr(Er) {
    ar[55](Er);
  }
  let Ar = {
    event: (
      /*event*/
      ar[3]
    ),
    profiles: (
      /*profiles*/
      ar[4]
    ),
    editLvl: (
      /*editLvl*/
      ar[2]
    ),
    subject: (
      /*subject*/
      ar[8]
    )
  };
  return (
    /*sentimentCount*/
    ar[1] !== void 0 && (Ar.sentimentCount = /*sentimentCount*/
    ar[1]), /*opinionContent*/
    ar[5] !== void 0 && (Ar.opinionContent = /*opinionContent*/
    ar[5]), /*newOpinion*/
    ar[0] !== void 0 && (Ar.newOpinion = /*newOpinion*/
    ar[0]), /*replyEvents*/
    ar[11].length !== void 0 && (Ar.count = /*replyEvents*/
    ar[11].length), ur = new OpinionCard({ props: Ar }), binding_callbacks.push(() => bind$1(ur, "sentimentCount", yr)), binding_callbacks.push(() => bind$1(ur, "opinionContent", _r)), binding_callbacks.push(() => bind$1(ur, "newOpinion", kr)), binding_callbacks.push(() => bind$1(ur, "count", xr)), {
      key: cr,
      first: null,
      c() {
        lr = empty$2(), create_component(ur.$$.fragment), this.first = lr;
      },
      m(Er, Cr) {
        insert(Er, lr, Cr), mount_component(ur, Er, Cr), vr = !0;
      },
      p(Er, Cr) {
        ar = Er;
        const Tr = {};
        Cr[0] & /*replyEvents*/
        2048 && (Tr.event = /*event*/
        ar[3]), Cr[0] & /*profiles*/
        16 && (Tr.profiles = /*profiles*/
        ar[4]), Cr[0] & /*editLvl*/
        4 && (Tr.editLvl = /*editLvl*/
        ar[2]), Cr[0] & /*subject*/
        256 && (Tr.subject = /*subject*/
        ar[8]), !dr && Cr[0] & /*sentimentCount*/
        2 && (dr = !0, Tr.sentimentCount = /*sentimentCount*/
        ar[1], add_flush_callback(() => dr = !1)), !fr && Cr[0] & /*opinionContent*/
        32 && (fr = !0, Tr.opinionContent = /*opinionContent*/
        ar[5], add_flush_callback(() => fr = !1)), !gr && Cr[0] & /*newOpinion*/
        1 && (gr = !0, Tr.newOpinion = /*newOpinion*/
        ar[0], add_flush_callback(() => gr = !1)), !mr && Cr[0] & /*replyEvents*/
        2048 && (mr = !0, Tr.count = /*replyEvents*/
        ar[11].length, add_flush_callback(() => mr = !1)), ur.$set(Tr);
      },
      i(Er) {
        vr || (transition_in(ur.$$.fragment, Er), vr = !0);
      },
      o(Er) {
        transition_out(ur.$$.fragment, Er), vr = !1;
      },
      d(Er) {
        Er && detach(lr), destroy_component(ur, Er);
      }
    }
  );
}
function create_fragment$1(cr) {
  let ar, lr, ur = !/*isDeleted*/
  cr[10] && create_if_block$1(cr);
  return {
    c() {
      ur && ur.c(), ar = empty$2();
    },
    m(dr, fr) {
      ur && ur.m(dr, fr), insert(dr, ar, fr), lr = !0;
    },
    p(dr, fr) {
      /*isDeleted*/
      dr[10] ? ur && (group_outros(), transition_out(ur, 1, 1, () => {
        ur = null;
      }), check_outros()) : ur ? (ur.p(dr, fr), fr[0] & /*isDeleted*/
      1024 && transition_in(ur, 1)) : (ur = create_if_block$1(dr), ur.c(), transition_in(ur, 1), ur.m(ar.parentNode, ar));
    },
    i(dr) {
      lr || (transition_in(ur), lr = !0);
    },
    o(dr) {
      transition_out(ur), lr = !1;
    },
    d(dr) {
      dr && detach(ar), ur && ur.d(dr);
    }
  };
}
const maxLength = 500;
function truncateText(cr, ar) {
  return cr.length > ar ? cr.slice(0, ar) + "..." : cr;
}
const func = (cr) => cr[0] === "sentiment", func_1 = (cr) => cr[0] === "sentiment";
function instance$1(cr, ar, lr) {
  let ur, dr, fr;
  component_subscribe(cr, ndkStore, (mi) => lr(58, ur = mi)), component_subscribe(cr, ndkUser, (mi) => lr(26, dr = mi)), component_subscribe(cr, localStore, (mi) => lr(59, fr = mi));
  let { event: gr } = ar, { profiles: mr } = ar, { submit: vr = () => {
  } } = ar, { opinionContent: yr } = ar, { newOpinion: _r } = ar, { sentimentCount: kr } = ar, { editLvl: xr } = ar, { subject: Ar } = ar, { count: Er } = ar, { deletedEventsArray: Cr = [] } = ar, { isMine: Tr = !1 } = ar;
  yr = yr.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "");
  let Sr = [], Lr = [], Ir, { trustedAuthors: Nr = [] } = ar, Rr = 0, Mr = 0, Br = !1, Dr = !1, Hr = !1, Fr = !0, zr = !1, Ur = !1, jr = !1, Yr = gr.id, qr = "", Wr, Jr, Gr = {
    read: DEFAULT_RELAY_URLS.read,
    write: DEFAULT_RELAY_URLS.write
  }, Vr = !1, Qr = [];
  xr === 0 && (Yr = kindOpinion + ":" + gr.pubkey + ":" + Ar);
  function $r() {
    lr(21, jr = !jr);
  }
  function Xr(mi) {
    lr(0, _r = { ..._r, sentiment: mi });
  }
  async function si(mi) {
    const di = fr.pk;
    if (di ? !ur.signer && await privkeyLogin(di) : !ur.signer && await NDKlogin(), !dr)
      return;
    let yi = Lr.findIndex((Ii) => Ii.pubkey === dr.pubkey);
    yi != -1 && Lr[yi].content === mi && (mi = "");
    const Bi = new NDKEvent(ur);
    Bi.kind = NDKKind.Reaction, Bi.content = mi, Bi.tags = [["a", Yr], ["p", dr.pubkey]], await Bi.publish(NDKRelaySet.fromRelayUrls(Gr.write, ur)), yi = Lr.findIndex((Ii) => Ii.pubkey === dr.pubkey), yi != -1 ? Lr[yi] = {
      pubkey: dr.pubkey,
      content: mi,
      timestamp: Date.now()
    } : Lr.push({
      pubkey: dr.pubkey,
      content: mi,
      timestamp: Date.now()
    }), lr(13, Rr = Lr.filter((Ii) => Ii.content === "+").length), lr(14, Mr = Lr.filter((Ii) => Ii.content === "-").length), mi === "+" ? (lr(19, zr = !0), lr(20, Ur = !1)) : mi === "-" ? (lr(19, zr = !1), lr(20, Ur = !0)) : (lr(19, zr = !1), lr(20, Ur = !1));
  }
  (async () => {
    var Vi, Gi;
    lr(3, gr.content = gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, ""), gr);
    const mi = new marked.Renderer(), di = "max-width: 100px; height: 100px; border-radius:10px; object-fit: cover;";
    mi.image = (bi, Ji, oo) => `<img src="${bi}" alt="${oo}" title="${Ji}" style="${di}" />`, mi.link = (bi, Ji, oo) => bi.match(/\.(jpeg|jpg|gif|png|svg|webp)$/i) != null ? `<a href="${bi}" target="_blank"><img src="${bi}" alt="${oo}" title="${Ji}" style="${di}" /></a>` : `<a href="${bi}" title="${Ji}" target="_blank">${oo}</a>`, marked.setOptions({ renderer: mi }), lr(12, Ir = (await Promise.resolve().then(() => main)).expertOpinions), lr(2, xr += 1), lr(22, qr = calculateRelativeTime(gr.created_at)), lr(18, Fr = !1);
    let yi = { kinds: [kindNotes], "#a": [Yr] };
    (await ur.fetchEvents(yi, { closeOnEose: !1 })).forEach(async (bi) => {
      lr(11, Sr = [...Sr, { ...bi }]);
      const Ji = await fetchUserProfile(bi.pubkey);
      Ji.image || (Ji.image = profileImageUrl + bi.pubkey), Ji.pubkey || (Ji.pubkey = bi.pubkey), lr(4, mr[bi.pubkey] = { content: Ji }, mr);
    });
    let Ii = 0;
    yi = { kinds: [kindReaction], "#a": [Yr] }, (await ur.fetchEvents(yi, { closeOnEose: !1 })).forEach((bi) => {
      let Ji = Lr.findIndex((oo) => oo.pubkey === bi.pubkey);
      bi.created_at && (Ji != -1 ? Lr[Ji].timestamp < bi.created_at && (Lr[Ji] = {
        pubkey: bi.pubkey,
        content: bi.content,
        timestamp: bi.created_at
      }) : Lr.push({
        pubkey: bi.pubkey,
        content: bi.content,
        timestamp: bi.created_at
      }), lr(13, Rr = Lr.filter((oo) => oo.content === "+").length), lr(14, Mr = Lr.filter((oo) => oo.content === "-").length), dr != null && dr.pubkey && bi.pubkey === dr.pubkey && Ii < bi.created_at && (Ii = bi.created_at, bi.content === "+" ? (lr(19, zr = !0), lr(20, Ur = !1)) : bi.content === "-" ? (lr(19, zr = !1), lr(20, Ur = !0)) : (lr(19, zr = !1), lr(20, Ur = !1))));
    });
    let eo = await ur.fetchEvent({ kinds: [10002], authors: [gr.pubkey] }, { closeOnEose: !0 });
    eo && eo.getMatchingTags("r").map((bi) => {
      bi.length === 3 ? bi[2] === "write" && !Gr.write.includes(bi[1]) ? Gr.write.push(bi[1]) : bi[2] === "read" && !Gr.read.includes(bi[1]) && Gr.read.push(bi[1]) : bi.length === 2 && (Gr.write.includes(bi[1]) || Gr.write.push(bi[1]), Gr.read.includes(bi[1]) || Gr.read.push(bi[1]));
    });
    const Ui = (Gi = (Vi = gr.tags.filter((bi) => bi[0] === "published_at")[0]) == null ? void 0 : Vi[1]) == null ? void 0 : Gi.slice(0, 10);
    Ui && lr(23, Wr = parseInt(Ui)), lr(24, Jr = gr.created_at);
  })();
  const li = async () => {
    if (!dr) {
      console.log("Can't submit reply. $ndkUser is undefined");
      return;
    }
    const mi = fr.pk;
    if (mi ? !ur.signer && await privkeyLogin(mi) : !ur.signer && await NDKlogin(), yr === "" || !yr)
      return;
    const di = new NDKEvent(ur);
    di.kind = NDKKind.Text, di.content = yr, di.tags = [["a", Yr], ["p", dr.pubkey]], await di.publish(NDKRelaySet.fromRelayUrls(Gr.write, ur)), lr(11, Sr = [...Sr, { ...di }]), lr(5, yr = "");
  };
  function Ei(mi) {
    const di = Qr.filter((yi) => yi === mi)[0].url;
    lr(5, yr = yr.replace(di, "")), lr(25, Qr = Qr.filter((yi) => yi !== mi));
  }
  function ki(mi) {
    Qr = mi, lr(25, Qr);
  }
  function Di(mi) {
    yr = mi, lr(5, yr), lr(10, Vr), lr(2, xr), lr(0, _r), lr(1, kr), lr(32, Cr), lr(3, gr);
  }
  const hi = () => Xr("1"), Ti = () => Xr("0"), fi = () => Xr("-1"), Mi = () => vr(Wr.toString()), oi = () => si("+"), Ri = () => si("-"), qi = () => {
    lr(16, Dr = !Dr), lr(15, Br = !1), lr(5, yr = ""), lr(17, Hr = !1);
  }, zi = () => {
    lr(17, Hr = !Hr);
  };
  function to(mi) {
    Vr = mi, lr(10, Vr);
  }
  function Hi(mi) {
    Er = mi, lr(6, Er);
  }
  const _i = () => {
    lr(15, Br = !Br), lr(5, yr = gr.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")), lr(0, _r = {
      content: yr,
      sentiment: gr.tagValue("sentiment") || "0"
    }), lr(16, Dr = !1), lr(17, Hr = !1);
  };
  function Ai(mi) {
    yr = mi, lr(5, yr), lr(10, Vr), lr(2, xr), lr(0, _r), lr(1, kr), lr(32, Cr), lr(3, gr);
  }
  const ui = (mi) => Ei(mi), ji = () => {
    li(), lr(16, Dr = !1), lr(17, Hr = !1);
  };
  function ai(mi) {
    Qr = mi, lr(25, Qr);
  }
  function Li(mi) {
    yr = mi, lr(5, yr), lr(10, Vr), lr(2, xr), lr(0, _r), lr(1, kr), lr(32, Cr), lr(3, gr);
  }
  function $i(mi) {
    kr = mi, lr(1, kr), lr(10, Vr), lr(2, xr), lr(0, _r), lr(32, Cr), lr(3, gr);
  }
  function Wi(mi) {
    yr = mi, lr(5, yr), lr(10, Vr), lr(2, xr), lr(0, _r), lr(1, kr), lr(32, Cr), lr(3, gr);
  }
  function io(mi) {
    _r = mi, lr(0, _r), lr(10, Vr), lr(2, xr), lr(1, kr), lr(32, Cr), lr(3, gr);
  }
  function ro(mi) {
    cr.$$.not_equal(Sr.length, mi) && (Sr.length = mi, lr(11, Sr));
  }
  return cr.$$set = (mi) => {
    "event" in mi && lr(3, gr = mi.event), "profiles" in mi && lr(4, mr = mi.profiles), "submit" in mi && lr(7, vr = mi.submit), "opinionContent" in mi && lr(5, yr = mi.opinionContent), "newOpinion" in mi && lr(0, _r = mi.newOpinion), "sentimentCount" in mi && lr(1, kr = mi.sentimentCount), "editLvl" in mi && lr(2, xr = mi.editLvl), "subject" in mi && lr(8, Ar = mi.subject), "count" in mi && lr(6, Er = mi.count), "deletedEventsArray" in mi && lr(32, Cr = mi.deletedEventsArray), "isMine" in mi && lr(33, Tr = mi.isMine), "trustedAuthors" in mi && lr(9, Nr = mi.trustedAuthors);
  }, cr.$$.update = () => {
    if (cr.$$.dirty[0] & /*isDeleted, editLvl, newOpinion, sentimentCount, event*/
    1039 | cr.$$.dirty[1] & /*deletedEventsArray*/
    2 && Vr) {
      if (xr == 1) {
        lr(33, Tr = !1);
        let mi = _r.sentiment, di = kr[mi] - 1;
        mi === "1" ? lr(1, kr = { ...kr, 1: di }) : mi === "0" ? lr(1, kr = { ...kr, 0: di }) : lr(1, kr = { ...kr, "-1": di }), lr(0, _r = { content: "", sentiment: "0" }), lr(5, yr = "");
      }
      lr(32, Cr = [...Cr, gr]);
    }
  }, [
    _r,
    kr,
    xr,
    gr,
    mr,
    yr,
    Er,
    vr,
    Ar,
    Nr,
    Vr,
    Sr,
    Ir,
    Rr,
    Mr,
    Br,
    Dr,
    Hr,
    Fr,
    zr,
    Ur,
    jr,
    qr,
    Wr,
    Jr,
    Qr,
    dr,
    $r,
    Xr,
    si,
    li,
    Ei,
    Cr,
    Tr,
    ki,
    Di,
    hi,
    Ti,
    fi,
    Mi,
    oi,
    Ri,
    qi,
    zi,
    to,
    Hi,
    _i,
    Ai,
    ui,
    ji,
    ai,
    Li,
    $i,
    Wi,
    io,
    ro
  ];
}
class OpinionCard extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance$1,
      create_fragment$1,
      safe_not_equal,
      {
        event: 3,
        profiles: 4,
        submit: 7,
        opinionContent: 5,
        newOpinion: 0,
        sentimentCount: 1,
        editLvl: 2,
        subject: 8,
        count: 6,
        deletedEventsArray: 32,
        isMine: 33,
        trustedAuthors: 9
      },
      add_css$1,
      [-1, -1, -1]
    );
  }
  get event() {
    return this.$$.ctx[3];
  }
  set event(ar) {
    this.$$set({ event: ar }), flush();
  }
  get profiles() {
    return this.$$.ctx[4];
  }
  set profiles(ar) {
    this.$$set({ profiles: ar }), flush();
  }
  get submit() {
    return this.$$.ctx[7];
  }
  set submit(ar) {
    this.$$set({ submit: ar }), flush();
  }
  get opinionContent() {
    return this.$$.ctx[5];
  }
  set opinionContent(ar) {
    this.$$set({ opinionContent: ar }), flush();
  }
  get newOpinion() {
    return this.$$.ctx[0];
  }
  set newOpinion(ar) {
    this.$$set({ newOpinion: ar }), flush();
  }
  get sentimentCount() {
    return this.$$.ctx[1];
  }
  set sentimentCount(ar) {
    this.$$set({ sentimentCount: ar }), flush();
  }
  get editLvl() {
    return this.$$.ctx[2];
  }
  set editLvl(ar) {
    this.$$set({ editLvl: ar }), flush();
  }
  get subject() {
    return this.$$.ctx[8];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get count() {
    return this.$$.ctx[6];
  }
  set count(ar) {
    this.$$set({ count: ar }), flush();
  }
  get deletedEventsArray() {
    return this.$$.ctx[32];
  }
  set deletedEventsArray(ar) {
    this.$$set({ deletedEventsArray: ar }), flush();
  }
  get isMine() {
    return this.$$.ctx[33];
  }
  set isMine(ar) {
    this.$$set({ isMine: ar }), flush();
  }
  get trustedAuthors() {
    return this.$$.ctx[9];
  }
  set trustedAuthors(ar) {
    this.$$set({ trustedAuthors: ar }), flush();
  }
}
create_custom_element(OpinionCard, { event: {}, profiles: {}, submit: {}, opinionContent: {}, newOpinion: {}, sentimentCount: {}, editLvl: {}, subject: {}, count: {}, deletedEventsArray: {}, isMine: { type: "Boolean" }, trustedAuthors: {} }, [], [], !0);
async function initializeApprovedAuthors() {
  const cr = (await Promise.resolve().then(() => main)).expertOpinions;
  let ar = [];
  ar = cr.trustedAuthors.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((mr) => mr != null);
  const lr = cr.trustedBadgeAuthors.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "npub")
      return vr.data;
    if (vr.type == "nprofile")
      return vr.data.pubkey;
  }).filter((mr) => mr != null), ur = cr.trustedBadges.map((mr) => {
    const vr = nip19_exports.decode(mr);
    if (vr.type == "naddr" && vr.data.kind == NDKKind.BadgeDefinition)
      return `${vr.data.kind}:${vr.data.pubkey}:${vr.data.identifier}`;
  }).filter((mr) => mr != null), dr = get_store_value(ndkStore);
  await dr.connect(), (await dr.fetchEvents({
    kinds: [NDKKind.BadgeDefinition],
    authors: lr
  })).forEach((mr) => {
    const vr = mr.tags.find((yr) => yr[0] == "d");
    vr && ur.push(`${mr.kind}:${mr.pubkey}:${vr[1]}`);
  });
  const gr = [];
  return (await dr.fetchEvents({
    kinds: [NDKKind.BadgeAward],
    "#a": ur
  })).forEach((mr) => {
    const vr = mr.tags.filter((yr) => yr[0] == "p");
    vr.length && vr.forEach((yr) => gr.push(yr[1]));
  }), ar.push(...gr), cr.trustedAuthors.push(...ar.map((mr) => nip19_exports.npubEncode(mr))), ar;
}
function add_css(cr) {
  append_styles(cr, "svelte-m6ofzm", ":host{--border-color:#dedede;--content-text-color:#606060;--pubkey-text-color:#7c2323;--date-text-color:#808080;--description-text-color:#808080;--filter-active-color:#000000;--filter-inactive-color:#808080;--button-text-color:#ffffff;--button-background-color:#4da84d;--sentiment-button-background-color:#4da84d;font-family:Arial, sans-serif;background-color:black}.expertOpinionsHeadline.svelte-m6ofzm.svelte-m6ofzm{font-family:'Barlow'}.top-nav.svelte-m6ofzm.svelte-m6ofzm{display:flex;justify-content:space-between;border-top:#dedede 1px solid;border-bottom:#dedede 1px solid;padding:20px 0}.nav-count.svelte-m6ofzm.svelte-m6ofzm{display:flex;align-items:center}.count-container.svelte-m6ofzm.svelte-m6ofzm{display:flex;flex-direction:row}.description.svelte-m6ofzm.svelte-m6ofzm{margin:10px 0}.blank-btn.svelte-m6ofzm.svelte-m6ofzm{background-color:transparent;border:none;cursor:pointer}.filter-container.svelte-m6ofzm.svelte-m6ofzm{display:flex;flex-direction:row}.filter-container.svelte-m6ofzm>.filter-active.svelte-m6ofzm{color:#4da84d}.filter-btn.svelte-m6ofzm.svelte-m6ofzm{color:#808080}.primary-btn.svelte-m6ofzm.svelte-m6ofzm{color:#ffffff;background-color:#4da84d;padding:7px 20px;border-radius:3px;cursor:pointer;border:none;height:2.5rem}#review-input-details-container.svelte-m6ofzm.svelte-m6ofzm{display:flex;flex-direction:column;gap:0.5rem;font-family:Arial, sans-serif}.btn-standard.svelte-m6ofzm.svelte-m6ofzm{border-radius:3px;width:7rem;height:3rem;cursor:pointer;border:none;padding-right:1.5rem;display:flex;justify-content:center;align-items:center;color:#808080}.btn-standard.svelte-m6ofzm.svelte-m6ofzm:hover{background-color:#4da84d}.btn-standard.svelte-m6ofzm.svelte-m6ofzm:hover{color:#ffffff}#sentiment-box.svelte-m6ofzm.svelte-m6ofzm{display:flex;flex-direction:column;gap:0.3rem}.selected-state.svelte-m6ofzm.svelte-m6ofzm{background-color:#4da84d;color:#ffffff}.placeholder.svelte-m6ofzm.svelte-m6ofzm{display:flex;font-family:Arial, sans-serif;align-items:center;gap:0.5rem;margin-top:1rem;margin-bottom:1rem}#imageContainer.svelte-m6ofzm.svelte-m6ofzm{display:block;border-radius:50%;width:50px;height:50px;object-fit:cover}#filePreview.svelte-m6ofzm.svelte-m6ofzm{display:flex;gap:1rem;overflow:scroll;margin:1rem 0}");
}
function get_each_context(cr, ar, lr) {
  const ur = cr.slice();
  return ur[63] = ar[lr], ur;
}
function get_each_context_1(cr, ar, lr) {
  const ur = cr.slice();
  return ur[66] = ar[lr], ur;
}
function create_else_block(cr) {
  let ar, lr = (
    /*expertOpinions*/
    cr[5].headline.replace(
      "$$nAll$$",
      /*allEventLength*/
      cr[16].toString() || "0"
    ).replace(
      "$$nTrusted$$",
      /*filter*/
      cr[11] === "approved" ? (
        /*filteredEventLength*/
        cr[17].toString()
      ) : (
        /*allEventLength*/
        cr[16].toString()
      )
    ) + ""
  ), ur, dr, fr, gr = (
    /*expertOpinions*/
    cr[5].description + ""
  ), mr, vr, yr, _r, kr, xr, Ar, Er = (
    /*sentimentCount*/
    cr[10][1] + ""
  ), Cr, Tr, Sr, Lr, Ir, Nr, Rr = (
    /*sentimentCount*/
    cr[10][0] + ""
  ), Mr, Br, Dr, Hr, Fr, zr, Ur = (
    /*sentimentCount*/
    cr[10][-1] + ""
  ), jr, Yr, qr, Wr, Jr, Gr, Vr, Qr, $r, Xr, si = [], Zr = /* @__PURE__ */ new Map(), li, Ei, ki, Di = /*isMine*/ cr[15] ? "Edit" : "Add", hi, Ti, fi, Mi, oi, Ri, qi;
  xr = new Positive({}), Ir = new Neutral({}), Fr = new Negative({});
  let zi = ensure_array_like(
    /*filteredEvents*/
    cr[2]
  );
  const to = (_i) => (
    /*event*/
    _i[66].id
  );
  for (let _i = 0; _i < zi.length; _i += 1) {
    let Ai = get_each_context_1(cr, zi, _i), ui = to(Ai);
    Zr.set(ui, si[_i] = create_each_block_1(ui, Ai));
  }
  let Hi = (
    /*showNewOpinion*/
    cr[3] && create_if_block_1(cr)
  );
  return {
    c() {
      ar = element("h1"), ur = text$3(lr), dr = space(), fr = element("p"), mr = text$3(gr), vr = space(), yr = element("nav"), _r = element("div"), kr = element("span"), create_component(xr.$$.fragment), Ar = space(), Cr = text$3(Er), Tr = text$3(" positive"), Sr = space(), Lr = element("span"), create_component(Ir.$$.fragment), Nr = space(), Mr = text$3(Rr), Br = text$3(" neutral"), Dr = space(), Hr = element("span"), create_component(Fr.$$.fragment), zr = space(), jr = text$3(Ur), Yr = text$3(" negative"), qr = space(), Wr = element("div"), Jr = element("button"), Jr.textContent = "Approved", Gr = space(), Vr = element("button"), Vr.textContent = "All opinions", $r = space(), Xr = element("div");
      for (let _i = 0; _i < si.length; _i += 1)
        si[_i].c();
      Ei = space(), ki = element("button"), hi = text$3(Di), Ti = text$3(" your opinion"), fi = space(), Hi && Hi.c(), Mi = empty$2(), attr(ar, "class", "expertOpinionsHeadline svelte-m6ofzm"), attr(fr, "class", "description svelte-m6ofzm"), attr(kr, "class", "nav-count svelte-m6ofzm"), attr(Lr, "class", "nav-count svelte-m6ofzm"), attr(Hr, "class", "nav-count svelte-m6ofzm"), attr(_r, "class", "count-container svelte-m6ofzm"), attr(Jr, "class", "blank-btn filter-btn svelte-m6ofzm"), attr(Jr, "aria-label", "filter by approved"), toggle_class(
        Jr,
        "filter-active",
        /*filter*/
        cr[11] === "approved"
      ), attr(Vr, "class", "blank-btn filter-btn svelte-m6ofzm"), attr(Vr, "aria-label", "filter by all"), toggle_class(
        Vr,
        "filter-active",
        /*filter*/
        cr[11] === "all"
      ), attr(Wr, "class", "filter-container svelte-m6ofzm"), attr(yr, "class", "top-nav svelte-m6ofzm"), attr(Xr, "class", "opinion-container"), attr(ki, "class", "primary-btn svelte-m6ofzm");
    },
    m(_i, Ai) {
      insert(_i, ar, Ai), append(ar, ur), insert(_i, dr, Ai), insert(_i, fr, Ai), append(fr, mr), insert(_i, vr, Ai), insert(_i, yr, Ai), append(yr, _r), append(_r, kr), mount_component(xr, kr, null), append(kr, Ar), append(kr, Cr), append(kr, Tr), append(_r, Sr), append(_r, Lr), mount_component(Ir, Lr, null), append(Lr, Nr), append(Lr, Mr), append(Lr, Br), append(_r, Dr), append(_r, Hr), mount_component(Fr, Hr, null), append(Hr, zr), append(Hr, jr), append(Hr, Yr), append(yr, qr), append(yr, Wr), append(Wr, Jr), append(Wr, Gr), append(Wr, Vr), insert(_i, $r, Ai), insert(_i, Xr, Ai);
      for (let ui = 0; ui < si.length; ui += 1)
        si[ui] && si[ui].m(Xr, null);
      insert(_i, Ei, Ai), insert(_i, ki, Ai), append(ki, hi), append(ki, Ti), insert(_i, fi, Ai), Hi && Hi.m(_i, Ai), insert(_i, Mi, Ai), oi = !0, Ri || (qi = [
        listen(
          Jr,
          "click",
          /*click_handler*/
          cr[32]
        ),
        listen(
          Vr,
          "click",
          /*click_handler_1*/
          cr[33]
        ),
        listen(
          ki,
          "click",
          /*click_handler_2*/
          cr[41]
        )
      ], Ri = !0);
    },
    p(_i, Ai) {
      (!oi || Ai[0] & /*expertOpinions, allEventLength, filter, filteredEventLength*/
      198688) && lr !== (lr = /*expertOpinions*/
      _i[5].headline.replace(
        "$$nAll$$",
        /*allEventLength*/
        _i[16].toString() || "0"
      ).replace(
        "$$nTrusted$$",
        /*filter*/
        _i[11] === "approved" ? (
          /*filteredEventLength*/
          _i[17].toString()
        ) : (
          /*allEventLength*/
          _i[16].toString()
        )
      ) + "") && set_data(ur, lr), (!oi || Ai[0] & /*expertOpinions*/
      32) && gr !== (gr = /*expertOpinions*/
      _i[5].description + "") && set_data(mr, gr), (!oi || Ai[0] & /*sentimentCount*/
      1024) && Er !== (Er = /*sentimentCount*/
      _i[10][1] + "") && set_data(Cr, Er), (!oi || Ai[0] & /*sentimentCount*/
      1024) && Rr !== (Rr = /*sentimentCount*/
      _i[10][0] + "") && set_data(Mr, Rr), (!oi || Ai[0] & /*sentimentCount*/
      1024) && Ur !== (Ur = /*sentimentCount*/
      _i[10][-1] + "") && set_data(jr, Ur), (!oi || Ai[0] & /*filter*/
      2048) && toggle_class(
        Jr,
        "filter-active",
        /*filter*/
        _i[11] === "approved"
      ), (!oi || Ai[0] & /*filter*/
      2048) && toggle_class(
        Vr,
        "filter-active",
        /*filter*/
        _i[11] === "all"
      ), Ai[0] & /*filteredEvents, profiles, submit, subject, sentimentCount, opinionContent, newOpinion, count, deletedEventsArray, isMine, trustedAuthors*/
      1091031 && (zi = ensure_array_like(
        /*filteredEvents*/
        _i[2]
      ), group_outros(), si = update_keyed_each(si, Ai, to, 1, _i, zi, Zr, Xr, outro_and_destroy_block, create_each_block_1, null, get_each_context_1), check_outros()), (!oi || Ai[0] & /*isMine*/
      32768) && Di !== (Di = /*isMine*/
      _i[15] ? "Edit" : "Add") && set_data(hi, Di), /*showNewOpinion*/
      _i[3] ? Hi ? (Hi.p(_i, Ai), Ai[0] & /*showNewOpinion*/
      8 && transition_in(Hi, 1)) : (Hi = create_if_block_1(_i), Hi.c(), transition_in(Hi, 1), Hi.m(Mi.parentNode, Mi)) : Hi && (group_outros(), transition_out(Hi, 1, 1, () => {
        Hi = null;
      }), check_outros());
    },
    i(_i) {
      if (!oi) {
        transition_in(xr.$$.fragment, _i), transition_in(Ir.$$.fragment, _i), transition_in(Fr.$$.fragment, _i), _i && add_render_callback(() => {
          oi && (Qr || (Qr = create_bidirectional_transition(yr, fade, {}, !0)), Qr.run(1));
        });
        for (let Ai = 0; Ai < zi.length; Ai += 1)
          transition_in(si[Ai]);
        _i && add_render_callback(() => {
          oi && (li || (li = create_bidirectional_transition(Xr, slide, {}, !0)), li.run(1));
        }), transition_in(Hi), oi = !0;
      }
    },
    o(_i) {
      transition_out(xr.$$.fragment, _i), transition_out(Ir.$$.fragment, _i), transition_out(Fr.$$.fragment, _i), _i && (Qr || (Qr = create_bidirectional_transition(yr, fade, {}, !1)), Qr.run(0));
      for (let Ai = 0; Ai < si.length; Ai += 1)
        transition_out(si[Ai]);
      _i && (li || (li = create_bidirectional_transition(Xr, slide, {}, !1)), li.run(0)), transition_out(Hi), oi = !1;
    },
    d(_i) {
      _i && (detach(ar), detach(dr), detach(fr), detach(vr), detach(yr), detach($r), detach(Xr), detach(Ei), detach(ki), detach(fi), detach(Mi)), destroy_component(xr), destroy_component(Ir), destroy_component(Fr), _i && Qr && Qr.end();
      for (let Ai = 0; Ai < si.length; Ai += 1)
        si[Ai].d();
      _i && li && li.end(), Hi && Hi.d(_i), Ri = !1, run_all(qi);
    }
  };
}
function create_if_block(cr) {
  let ar;
  return {
    c() {
      ar = element("p"), ar.textContent = "loading...", set_style(ar, "display", "flex"), set_style(ar, "justify-content", "center"), set_style(ar, "align-items", "center"), set_style(ar, "margin", "2rem 0");
    },
    m(lr, ur) {
      insert(lr, ar, ur);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(lr) {
      lr && detach(ar);
    }
  };
}
function create_if_block_5(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr;
  function _r(Lr) {
    cr[34](Lr);
  }
  function kr(Lr) {
    cr[35](Lr);
  }
  function xr(Lr) {
    cr[36](Lr);
  }
  function Ar(Lr) {
    cr[37](Lr);
  }
  function Er(Lr) {
    cr[38](Lr);
  }
  function Cr(Lr) {
    cr[39](Lr);
  }
  function Tr(Lr) {
    cr[40](Lr);
  }
  let Sr = {
    event: (
      /*event*/
      cr[66]
    ),
    profiles: (
      /*profiles*/
      cr[6]
    ),
    submit: (
      /*submit*/
      cr[20]
    ),
    editLvl,
    subject: (
      /*subject*/
      cr[0]
    )
  };
  return (
    /*sentimentCount*/
    cr[10] !== void 0 && (Sr.sentimentCount = /*sentimentCount*/
    cr[10]), /*opinionContent*/
    cr[8] !== void 0 && (Sr.opinionContent = /*opinionContent*/
    cr[8]), /*newOpinion*/
    cr[7] !== void 0 && (Sr.newOpinion = /*newOpinion*/
    cr[7]), /*count*/
    cr[13] !== void 0 && (Sr.count = /*count*/
    cr[13]), /*deletedEventsArray*/
    cr[4] !== void 0 && (Sr.deletedEventsArray = /*deletedEventsArray*/
    cr[4]), /*isMine*/
    cr[15] !== void 0 && (Sr.isMine = /*isMine*/
    cr[15]), /*trustedAuthors*/
    cr[1] !== void 0 && (Sr.trustedAuthors = /*trustedAuthors*/
    cr[1]), ar = new OpinionCard({ props: Sr }), binding_callbacks.push(() => bind$1(ar, "sentimentCount", _r)), binding_callbacks.push(() => bind$1(ar, "opinionContent", kr)), binding_callbacks.push(() => bind$1(ar, "newOpinion", xr)), binding_callbacks.push(() => bind$1(ar, "count", Ar)), binding_callbacks.push(() => bind$1(ar, "deletedEventsArray", Er)), binding_callbacks.push(() => bind$1(ar, "isMine", Cr)), binding_callbacks.push(() => bind$1(ar, "trustedAuthors", Tr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(Lr, Ir) {
        mount_component(ar, Lr, Ir), yr = !0;
      },
      p(Lr, Ir) {
        const Nr = {};
        Ir[0] & /*filteredEvents*/
        4 && (Nr.event = /*event*/
        Lr[66]), Ir[0] & /*profiles*/
        64 && (Nr.profiles = /*profiles*/
        Lr[6]), Ir[0] & /*subject*/
        1 && (Nr.subject = /*subject*/
        Lr[0]), !lr && Ir[0] & /*sentimentCount*/
        1024 && (lr = !0, Nr.sentimentCount = /*sentimentCount*/
        Lr[10], add_flush_callback(() => lr = !1)), !ur && Ir[0] & /*opinionContent*/
        256 && (ur = !0, Nr.opinionContent = /*opinionContent*/
        Lr[8], add_flush_callback(() => ur = !1)), !dr && Ir[0] & /*newOpinion*/
        128 && (dr = !0, Nr.newOpinion = /*newOpinion*/
        Lr[7], add_flush_callback(() => dr = !1)), !fr && Ir[0] & /*count*/
        8192 && (fr = !0, Nr.count = /*count*/
        Lr[13], add_flush_callback(() => fr = !1)), !gr && Ir[0] & /*deletedEventsArray*/
        16 && (gr = !0, Nr.deletedEventsArray = /*deletedEventsArray*/
        Lr[4], add_flush_callback(() => gr = !1)), !mr && Ir[0] & /*isMine*/
        32768 && (mr = !0, Nr.isMine = /*isMine*/
        Lr[15], add_flush_callback(() => mr = !1)), !vr && Ir[0] & /*trustedAuthors*/
        2 && (vr = !0, Nr.trustedAuthors = /*trustedAuthors*/
        Lr[1], add_flush_callback(() => vr = !1)), ar.$set(Nr);
      },
      i(Lr) {
        yr || (transition_in(ar.$$.fragment, Lr), yr = !0);
      },
      o(Lr) {
        transition_out(ar.$$.fragment, Lr), yr = !1;
      },
      d(Lr) {
        destroy_component(ar, Lr);
      }
    }
  );
}
function create_each_block_1(cr, ar) {
  let lr, ur = (
    /*deletedEventsArray*/
    ar[4].includes(
      /*event*/
      ar[66]
    ) === !1
  ), dr, fr, gr = ur && create_if_block_5(ar);
  return {
    key: cr,
    first: null,
    c() {
      lr = empty$2(), gr && gr.c(), dr = empty$2(), this.first = lr;
    },
    m(mr, vr) {
      insert(mr, lr, vr), gr && gr.m(mr, vr), insert(mr, dr, vr), fr = !0;
    },
    p(mr, vr) {
      ar = mr, vr[0] & /*deletedEventsArray, filteredEvents*/
      20 && (ur = /*deletedEventsArray*/
      ar[4].includes(
        /*event*/
        ar[66]
      ) === !1), ur ? gr ? (gr.p(ar, vr), vr[0] & /*deletedEventsArray, filteredEvents*/
      20 && transition_in(gr, 1)) : (gr = create_if_block_5(ar), gr.c(), transition_in(gr, 1), gr.m(dr.parentNode, dr)) : gr && (group_outros(), transition_out(gr, 1, 1, () => {
        gr = null;
      }), check_outros());
    },
    i(mr) {
      fr || (transition_in(gr), fr = !0);
    },
    o(mr) {
      transition_out(gr), fr = !1;
    },
    d(mr) {
      mr && (detach(lr), detach(dr)), gr && gr.d(mr);
    }
  };
}
function create_if_block_1(cr) {
  let ar, lr, ur = /*isMine*/ cr[15] ? "Edit" : "Add", dr, fr, gr, mr, vr = purify.sanitize(
    /*expertOpinions*/
    cr[5].newOpinionDescription
  ) + "", yr, _r, kr, xr, Ar;
  const Er = [create_if_block_2, create_else_block_1], Cr = [];
  function Tr(Sr, Lr) {
    var Ir, Nr;
    return (
      /*$ndkUser*/
      (Ir = Sr[18]) != null && Ir.pubkey && /*profiles*/
      Sr[6][
        /*$ndkUser*/
        (Nr = Sr[18]) == null ? void 0 : Nr.pubkey
      ] ? 0 : 1
    );
  }
  return _r = Tr(cr), kr = Cr[_r] = Er[_r](cr), {
    c() {
      ar = element("div"), lr = element("h3"), dr = text$3(ur), fr = text$3(" your opinion"), gr = space(), mr = element("div"), yr = space(), kr.c(), attr(mr, "class", "description svelte-m6ofzm"), attr(ar, "class", "add-opinion-init");
    },
    m(Sr, Lr) {
      insert(Sr, ar, Lr), append(ar, lr), append(lr, dr), append(lr, fr), append(ar, gr), append(ar, mr), mr.innerHTML = vr, append(ar, yr), Cr[_r].m(ar, null), Ar = !0;
    },
    p(Sr, Lr) {
      (!Ar || Lr[0] & /*isMine*/
      32768) && ur !== (ur = /*isMine*/
      Sr[15] ? "Edit" : "Add") && set_data(dr, ur), (!Ar || Lr[0] & /*expertOpinions*/
      32) && vr !== (vr = purify.sanitize(
        /*expertOpinions*/
        Sr[5].newOpinionDescription
      ) + "") && (mr.innerHTML = vr);
      let Ir = _r;
      _r = Tr(Sr), _r === Ir ? Cr[_r].p(Sr, Lr) : (group_outros(), transition_out(Cr[Ir], 1, 1, () => {
        Cr[Ir] = null;
      }), check_outros(), kr = Cr[_r], kr ? kr.p(Sr, Lr) : (kr = Cr[_r] = Er[_r](Sr), kr.c()), transition_in(kr, 1), kr.m(ar, null));
    },
    i(Sr) {
      Ar || (transition_in(kr), Sr && add_render_callback(() => {
        Ar && (xr || (xr = create_bidirectional_transition(ar, fade, {}, !0)), xr.run(1));
      }), Ar = !0);
    },
    o(Sr) {
      transition_out(kr), Sr && (xr || (xr = create_bidirectional_transition(ar, fade, {}, !1)), xr.run(0)), Ar = !1;
    },
    d(Sr) {
      Sr && detach(ar), Cr[_r].d(), Sr && xr && xr.end();
    }
  };
}
function create_else_block_1(cr) {
  let ar, lr, ur, dr, fr, gr, mr, vr, yr, _r, kr;
  const xr = [create_if_block_3, create_if_block_4], Ar = [];
  function Er(Cr, Tr) {
    return (
      /*showLoginOrRegister*/
      Cr[12] === "login" ? 0 : (
        /*showLoginOrRegister*/
        Cr[12] === "register" ? 1 : -1
      )
    );
  }
  return ~(gr = Er(cr)) && (mr = Ar[gr] = xr[gr](cr)), {
    c() {
      ar = element("div"), lr = element("button"), lr.textContent = "Log in", ur = space(), dr = element("button"), dr.textContent = "Register", fr = space(), mr && mr.c(), attr(lr, "class", "primary-btn svelte-m6ofzm"), attr(dr, "class", "primary-btn svelte-m6ofzm");
    },
    m(Cr, Tr) {
      insert(Cr, ar, Tr), append(ar, lr), append(ar, ur), append(ar, dr), append(ar, fr), ~gr && Ar[gr].m(ar, null), yr = !0, _r || (kr = [
        listen(
          lr,
          "click",
          /*click_handler_6*/
          cr[50]
        ),
        listen(
          dr,
          "click",
          /*click_handler_7*/
          cr[51]
        )
      ], _r = !0);
    },
    p(Cr, Tr) {
      let Sr = gr;
      gr = Er(Cr), gr === Sr ? ~gr && Ar[gr].p(Cr, Tr) : (mr && (group_outros(), transition_out(Ar[Sr], 1, 1, () => {
        Ar[Sr] = null;
      }), check_outros()), ~gr ? (mr = Ar[gr], mr ? mr.p(Cr, Tr) : (mr = Ar[gr] = xr[gr](Cr), mr.c()), transition_in(mr, 1), mr.m(ar, null)) : mr = null);
    },
    i(Cr) {
      yr || (transition_in(mr), Cr && add_render_callback(() => {
        yr && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !0)), vr.run(1));
      }), yr = !0);
    },
    o(Cr) {
      transition_out(mr), Cr && (vr || (vr = create_bidirectional_transition(ar, slide, {}, !1)), vr.run(0)), yr = !1;
    },
    d(Cr) {
      Cr && detach(ar), ~gr && Ar[gr].d(), Cr && vr && vr.end(), _r = !1, run_all(kr);
    }
  };
}
function create_if_block_2(cr) {
  var Bi, Ii, Fi, eo, Ui, Vi, Gi, bi, Ji, oo;
  let ar, lr, ur = (
    /*$ndkUser*/
    (((Bi = cr[18]) == null ? void 0 : Bi.npub) || "0") + ""
  ), dr, fr, gr, mr, vr, yr, _r, kr, xr, Ar, Er, Cr, Tr, Sr = (!/*profiles*/
  ((eo = (Fi = cr[6][
    /*$ndkUser*/
    (Ii = cr[18]) == null ? void 0 : Ii.pubkey
  ]) == null ? void 0 : Fi.content) != null && eo.name) || /*profiles*/
  ((Gi = (Vi = cr[6][
    /*$ndkUser*/
    (Ui = cr[18]) == null ? void 0 : Ui.pubkey
  ]) == null ? void 0 : Vi.content) == null ? void 0 : Gi.name) == "" ? (
    /*$ndkUser*/
    cr[18].npub.slice(0, 4) + "..." + /*$ndkUser*/
    cr[18].npub.slice(-4)
  ) : (
    /*profiles*/
    (oo = (Ji = cr[6][
      /*$ndkUser*/
      (bi = cr[18]) == null ? void 0 : bi.pubkey
    ]) == null ? void 0 : Ji.content) == null ? void 0 : oo.name
  )) + "", Lr, Ir, Nr, Rr, Mr, Br, Dr, Hr, Fr, zr, Ur, jr, Yr, qr, Wr, Jr, Gr, Vr, Qr, $r, Xr, si, Zr, li, Ei, ki, Di, hi, Ti = [], fi = /* @__PURE__ */ new Map(), Mi, oi, Ri, qi, zi, to, Hi, _i, Ai, ui, ji, ai;
  function Li(ci) {
    cr[42](ci);
  }
  function $i(ci) {
    cr[43](ci);
  }
  let Wi = {};
  /*fileArray*/
  cr[14] !== void 0 && (Wi.fileArray = /*fileArray*/
  cr[14]), /*opinionContent*/
  cr[8] !== void 0 && (Wi.opinionContent = /*opinionContent*/
  cr[8]), Mr = new Editor_1({ props: Wi }), binding_callbacks.push(() => bind$1(Mr, "fileArray", Li)), binding_callbacks.push(() => bind$1(Mr, "opinionContent", $i)), qr = new Positive({}), Qr = new Neutral({}), li = new Negative({});
  let io = ensure_array_like(
    /*fileArray*/
    cr[14]
  );
  const ro = (ci) => (
    /*file*/
    ci[63].url
  );
  for (let ci = 0; ci < io.length; ci += 1) {
    let wi = get_each_context(cr, io, ci), Qi = ro(wi);
    fi.set(Qi, Ti[ci] = create_each_block(Qi, wi));
  }
  function mi(ci) {
    cr[48](ci);
  }
  function di(ci) {
    cr[49](ci);
  }
  let yi = {};
  return (
    /*fileArray*/
    cr[14] !== void 0 && (yi.fileArray = /*fileArray*/
    cr[14]), /*opinionContent*/
    cr[8] !== void 0 && (yi.opinionContent = /*opinionContent*/
    cr[8]), Hi = new Upload({ props: yi }), binding_callbacks.push(() => bind$1(Hi, "fileArray", mi)), binding_callbacks.push(() => bind$1(Hi, "opinionContent", di)), {
      c() {
        var ci, wi, Qi;
        ar = element("p"), lr = text$3("Logged in as "), dr = text$3(ur), fr = space(), gr = element("button"), gr.textContent = "Logout", mr = space(), vr = element("h3"), vr.textContent = "Share your opinion", yr = space(), _r = element("p"), _r.textContent = `We use Nostr to store opinions. You can post and access your posts via a unique private
					key.`, kr = space(), xr = element("div"), Ar = element("img"), Cr = space(), Tr = element("span"), Lr = text$3(Sr), Ir = space(), Nr = element("form"), Rr = element("div"), create_component(Mr.$$.fragment), Hr = space(), Fr = element("div"), zr = element("label"), zr.textContent = "Choose your overall sentiment", Ur = space(), jr = element("div"), Yr = element("button"), create_component(qr.$$.fragment), Wr = space(), Jr = element("span"), Jr.textContent = "Positive", Gr = space(), Vr = element("button"), create_component(Qr.$$.fragment), $r = space(), Xr = element("span"), Xr.textContent = "Neutral", si = space(), Zr = element("button"), create_component(li.$$.fragment), Ei = space(), ki = element("span"), ki.textContent = "Negative", Di = space(), hi = element("div");
        for (let ao = 0; ao < Ti.length; ao += 1)
          Ti[ao].c();
        Mi = space(), oi = element("div"), Ri = element("button"), qi = text$3("Post"), to = space(), create_component(Hi.$$.fragment), attr(gr, "class", "primary-btn svelte-m6ofzm"), attr(_r, "class", "description svelte-m6ofzm"), set_style(_r, "margin-top", "-1rem"), attr(Ar, "id", "imageContainer"), src_url_equal(Ar.src, Er = /*profiles*/
        (Qi = (wi = cr[6][
          /*$ndkUser*/
          (ci = cr[18]) == null ? void 0 : ci.pubkey
        ]) == null ? void 0 : wi.content) == null ? void 0 : Qi.image) || attr(Ar, "src", Er), attr(Ar, "alt", "Miranda"), attr(Ar, "class", "svelte-m6ofzm"), set_style(Tr, "font-size", "24px"), attr(xr, "class", "placeholder svelte-m6ofzm"), set_style(Rr, "background", "#f2f0f0"), attr(zr, "for", "sentiment"), set_style(zr, "font-weight", "600"), attr(Yr, "class", "btn-standard svelte-m6ofzm"), toggle_class(
          Yr,
          "selected-state",
          /*newOpinion*/
          cr[7].sentiment === "1"
        ), attr(Vr, "class", "btn-standard svelte-m6ofzm"), toggle_class(
          Vr,
          "selected-state",
          /*newOpinion*/
          cr[7].sentiment === "0"
        ), attr(Zr, "class", "btn-standard svelte-m6ofzm"), toggle_class(
          Zr,
          "selected-state",
          /*newOpinion*/
          cr[7].sentiment === "-1"
        ), set_style(jr, "display", "flex"), set_style(jr, "gap", "0.4rem"), attr(Fr, "id", "sentiment-box"), attr(Fr, "class", "svelte-m6ofzm"), attr(hi, "id", "filePreview"), attr(hi, "class", "svelte-m6ofzm"), attr(Ri, "class", "primary-btn svelte-m6ofzm"), set_style(Ri, "width", "5rem"), attr(Ri, "type", "submit"), Ri.disabled = zi = !/*$ndkUser*/
        cr[18], set_style(oi, "display", "flex"), set_style(oi, "align-contents", "center"), attr(Nr, "id", "review-input-details-container"), attr(Nr, "class", "svelte-m6ofzm");
      },
      m(ci, wi) {
        insert(ci, ar, wi), append(ar, lr), append(ar, dr), insert(ci, fr, wi), insert(ci, gr, wi), insert(ci, mr, wi), insert(ci, vr, wi), insert(ci, yr, wi), insert(ci, _r, wi), insert(ci, kr, wi), insert(ci, xr, wi), append(xr, Ar), append(xr, Cr), append(xr, Tr), append(Tr, Lr), insert(ci, Ir, wi), insert(ci, Nr, wi), append(Nr, Rr), mount_component(Mr, Rr, null), append(Nr, Hr), append(Nr, Fr), append(Fr, zr), append(Fr, Ur), append(Fr, jr), append(jr, Yr), mount_component(qr, Yr, null), append(Yr, Wr), append(Yr, Jr), append(jr, Gr), append(jr, Vr), mount_component(Qr, Vr, null), append(Vr, $r), append(Vr, Xr), append(jr, si), append(jr, Zr), mount_component(li, Zr, null), append(Zr, Ei), append(Zr, ki), append(Nr, Di), append(Nr, hi);
        for (let Qi = 0; Qi < Ti.length; Qi += 1)
          Ti[Qi] && Ti[Qi].m(hi, null);
        append(Nr, Mi), append(Nr, oi), append(oi, Ri), append(Ri, qi), append(oi, to), mount_component(Hi, oi, null), ui = !0, ji || (ai = [
          listen(
            gr,
            "click",
            /*Logout*/
            cr[22]
          ),
          listen(Yr, "click", prevent_default(
            /*click_handler_3*/
            cr[44]
          )),
          listen(Vr, "click", prevent_default(
            /*click_handler_4*/
            cr[45]
          )),
          listen(Zr, "click", prevent_default(
            /*click_handler_5*/
            cr[46]
          )),
          listen(Nr, "submit", prevent_default(
            /*submit*/
            cr[20]
          ))
        ], ji = !0);
      },
      p(ci, wi) {
        var co, bo, _o, ko, vo, yo, fo, To, Io, So, po, Ni, ri;
        (!ui || wi[0] & /*$ndkUser*/
        262144) && ur !== (ur = /*$ndkUser*/
        (((co = ci[18]) == null ? void 0 : co.npub) || "0") + "") && set_data(dr, ur), (!ui || wi[0] & /*profiles, $ndkUser*/
        262208 && !src_url_equal(Ar.src, Er = /*profiles*/
        (ko = (_o = ci[6][
          /*$ndkUser*/
          (bo = ci[18]) == null ? void 0 : bo.pubkey
        ]) == null ? void 0 : _o.content) == null ? void 0 : ko.image)) && attr(Ar, "src", Er), (!ui || wi[0] & /*profiles, $ndkUser*/
        262208) && Sr !== (Sr = (!/*profiles*/
        ((fo = (yo = ci[6][
          /*$ndkUser*/
          (vo = ci[18]) == null ? void 0 : vo.pubkey
        ]) == null ? void 0 : yo.content) != null && fo.name) || /*profiles*/
        ((So = (Io = ci[6][
          /*$ndkUser*/
          (To = ci[18]) == null ? void 0 : To.pubkey
        ]) == null ? void 0 : Io.content) == null ? void 0 : So.name) == "" ? (
          /*$ndkUser*/
          ci[18].npub.slice(0, 4) + "..." + /*$ndkUser*/
          ci[18].npub.slice(-4)
        ) : (
          /*profiles*/
          (ri = (Ni = ci[6][
            /*$ndkUser*/
            (po = ci[18]) == null ? void 0 : po.pubkey
          ]) == null ? void 0 : Ni.content) == null ? void 0 : ri.name
        )) + "") && set_data(Lr, Sr);
        const Qi = {};
        !Br && wi[0] & /*fileArray*/
        16384 && (Br = !0, Qi.fileArray = /*fileArray*/
        ci[14], add_flush_callback(() => Br = !1)), !Dr && wi[0] & /*opinionContent*/
        256 && (Dr = !0, Qi.opinionContent = /*opinionContent*/
        ci[8], add_flush_callback(() => Dr = !1)), Mr.$set(Qi), (!ui || wi[0] & /*newOpinion*/
        128) && toggle_class(
          Yr,
          "selected-state",
          /*newOpinion*/
          ci[7].sentiment === "1"
        ), (!ui || wi[0] & /*newOpinion*/
        128) && toggle_class(
          Vr,
          "selected-state",
          /*newOpinion*/
          ci[7].sentiment === "0"
        ), (!ui || wi[0] & /*newOpinion*/
        128) && toggle_class(
          Zr,
          "selected-state",
          /*newOpinion*/
          ci[7].sentiment === "-1"
        ), wi[0] & /*fileArray, deleteFile*/
        8404992 && (io = ensure_array_like(
          /*fileArray*/
          ci[14]
        ), group_outros(), Ti = update_keyed_each(Ti, wi, ro, 1, ci, io, fi, hi, outro_and_destroy_block, create_each_block, null, get_each_context), check_outros()), (!ui || wi[0] & /*$ndkUser*/
        262144 && zi !== (zi = !/*$ndkUser*/
        ci[18])) && (Ri.disabled = zi);
        const ao = {};
        !_i && wi[0] & /*fileArray*/
        16384 && (_i = !0, ao.fileArray = /*fileArray*/
        ci[14], add_flush_callback(() => _i = !1)), !Ai && wi[0] & /*opinionContent*/
        256 && (Ai = !0, ao.opinionContent = /*opinionContent*/
        ci[8], add_flush_callback(() => Ai = !1)), Hi.$set(ao);
      },
      i(ci) {
        if (!ui) {
          transition_in(Mr.$$.fragment, ci), transition_in(qr.$$.fragment, ci), transition_in(Qr.$$.fragment, ci), transition_in(li.$$.fragment, ci);
          for (let wi = 0; wi < io.length; wi += 1)
            transition_in(Ti[wi]);
          transition_in(Hi.$$.fragment, ci), ui = !0;
        }
      },
      o(ci) {
        transition_out(Mr.$$.fragment, ci), transition_out(qr.$$.fragment, ci), transition_out(Qr.$$.fragment, ci), transition_out(li.$$.fragment, ci);
        for (let wi = 0; wi < Ti.length; wi += 1)
          transition_out(Ti[wi]);
        transition_out(Hi.$$.fragment, ci), ui = !1;
      },
      d(ci) {
        ci && (detach(ar), detach(fr), detach(gr), detach(mr), detach(vr), detach(yr), detach(_r), detach(kr), detach(xr), detach(Ir), detach(Nr)), destroy_component(Mr), destroy_component(qr), destroy_component(Qr), destroy_component(li);
        for (let wi = 0; wi < Ti.length; wi += 1)
          Ti[wi].d();
        destroy_component(Hi), ji = !1, run_all(ai);
      }
    }
  );
}
function create_if_block_4(cr) {
  let ar, lr, ur, dr;
  function fr(vr) {
    cr[55](vr);
  }
  function gr(vr) {
    cr[56](vr);
  }
  let mr = {};
  return (
    /*profiles*/
    cr[6] !== void 0 && (mr.profiles = /*profiles*/
    cr[6]), /*showNewOpinion*/
    cr[3] !== void 0 && (mr.showNewOpinion = /*showNewOpinion*/
    cr[3]), ar = new Register({ props: mr }), binding_callbacks.push(() => bind$1(ar, "profiles", fr)), binding_callbacks.push(() => bind$1(ar, "showNewOpinion", gr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(vr, yr) {
        mount_component(ar, vr, yr), dr = !0;
      },
      p(vr, yr) {
        const _r = {};
        !lr && yr[0] & /*profiles*/
        64 && (lr = !0, _r.profiles = /*profiles*/
        vr[6], add_flush_callback(() => lr = !1)), !ur && yr[0] & /*showNewOpinion*/
        8 && (ur = !0, _r.showNewOpinion = /*showNewOpinion*/
        vr[3], add_flush_callback(() => ur = !1)), ar.$set(_r);
      },
      i(vr) {
        dr || (transition_in(ar.$$.fragment, vr), dr = !0);
      },
      o(vr) {
        transition_out(ar.$$.fragment, vr), dr = !1;
      },
      d(vr) {
        destroy_component(ar, vr);
      }
    }
  );
}
function create_if_block_3(cr) {
  let ar, lr, ur, dr, fr;
  function gr(_r) {
    cr[52](_r);
  }
  function mr(_r) {
    cr[53](_r);
  }
  function vr(_r) {
    cr[54](_r);
  }
  let yr = { subject: (
    /*subject*/
    cr[0]
  ) };
  return (
    /*profiles*/
    cr[6] !== void 0 && (yr.profiles = /*profiles*/
    cr[6]), /*opinionContent*/
    cr[8] !== void 0 && (yr.opinionContent = /*opinionContent*/
    cr[8]), /*showNewOpinion*/
    cr[3] !== void 0 && (yr.showNewOpinion = /*showNewOpinion*/
    cr[3]), ar = new Login({ props: yr }), binding_callbacks.push(() => bind$1(ar, "profiles", gr)), binding_callbacks.push(() => bind$1(ar, "opinionContent", mr)), binding_callbacks.push(() => bind$1(ar, "showNewOpinion", vr)), {
      c() {
        create_component(ar.$$.fragment);
      },
      m(_r, kr) {
        mount_component(ar, _r, kr), fr = !0;
      },
      p(_r, kr) {
        const xr = {};
        kr[0] & /*subject*/
        1 && (xr.subject = /*subject*/
        _r[0]), !lr && kr[0] & /*profiles*/
        64 && (lr = !0, xr.profiles = /*profiles*/
        _r[6], add_flush_callback(() => lr = !1)), !ur && kr[0] & /*opinionContent*/
        256 && (ur = !0, xr.opinionContent = /*opinionContent*/
        _r[8], add_flush_callback(() => ur = !1)), !dr && kr[0] & /*showNewOpinion*/
        8 && (dr = !0, xr.showNewOpinion = /*showNewOpinion*/
        _r[3], add_flush_callback(() => dr = !1)), ar.$set(xr);
      },
      i(_r) {
        fr || (transition_in(ar.$$.fragment, _r), fr = !0);
      },
      o(_r) {
        transition_out(ar.$$.fragment, _r), fr = !1;
      },
      d(_r) {
        destroy_component(ar, _r);
      }
    }
  );
}
function create_each_block(cr, ar) {
  let lr, ur, dr;
  function fr() {
    return (
      /*func*/
      ar[47](
        /*file*/
        ar[63]
      )
    );
  }
  return ur = new FilePreview({
    props: {
      file: (
        /*file*/
        ar[63].files
      ),
      onDelete: fr
    }
  }), {
    key: cr,
    first: null,
    c() {
      lr = empty$2(), create_component(ur.$$.fragment), this.first = lr;
    },
    m(gr, mr) {
      insert(gr, lr, mr), mount_component(ur, gr, mr), dr = !0;
    },
    p(gr, mr) {
      ar = gr;
      const vr = {};
      mr[0] & /*fileArray*/
      16384 && (vr.file = /*file*/
      ar[63].files), mr[0] & /*fileArray*/
      16384 && (vr.onDelete = fr), ur.$set(vr);
    },
    i(gr) {
      dr || (transition_in(ur.$$.fragment, gr), dr = !0);
    },
    o(gr) {
      transition_out(ur.$$.fragment, gr), dr = !1;
    },
    d(gr) {
      gr && detach(lr), destroy_component(ur, gr);
    }
  };
}
function create_fragment(cr) {
  let ar, lr, ur, dr;
  const fr = [create_if_block, create_else_block], gr = [];
  function mr(vr, yr) {
    return (
      /*loading*/
      vr[9] ? 0 : 1
    );
  }
  return ar = mr(cr), lr = gr[ar] = fr[ar](cr), {
    c() {
      lr.c(), ur = empty$2();
    },
    m(vr, yr) {
      gr[ar].m(vr, yr), insert(vr, ur, yr), dr = !0;
    },
    p(vr, yr) {
      let _r = ar;
      ar = mr(vr), ar === _r ? gr[ar].p(vr, yr) : (group_outros(), transition_out(gr[_r], 1, 1, () => {
        gr[_r] = null;
      }), check_outros(), lr = gr[ar], lr ? lr.p(vr, yr) : (lr = gr[ar] = fr[ar](vr), lr.c()), transition_in(lr, 1), lr.m(ur.parentNode, ur));
    },
    i(vr) {
      dr || (transition_in(lr), dr = !0);
    },
    o(vr) {
      transition_out(lr), dr = !1;
    },
    d(vr) {
      vr && detach(ur), gr[ar].d(vr);
    }
  };
}
let editLvl = 0;
function instance(cr, ar, lr) {
  let ur, dr, fr, gr;
  component_subscribe(cr, ndkStore, (di) => lr(57, ur = di)), component_subscribe(cr, ndkUser, (di) => lr(18, dr = di)), component_subscribe(cr, localStore, (di) => lr(58, fr = di));
  let { subject: mr } = ar, { opinionTitle: vr } = ar, { opinionHeader: yr = vr } = ar, { opinionFooter: _r = void 0 } = ar, { opinionImage: kr = void 0 } = ar, { opinionTags: xr = "NostrOpinion" } = ar, { summary: Ar = `An opinion made about ${mr} generated using nostr-opinion-plugin.` } = ar, Er, Cr = [], Tr = [], Sr = [], Lr = {}, Ir = { content: "", sentiment: "0" }, Nr = "", Rr = !0, Mr = { "-1": 0, 0: 0, 1: 0 }, Br = "approved", Dr = !1, Hr = !1, Fr = 0, zr = [], Ur = [], jr = !1, Yr = 0, qr = 0, Wr = { kinds: [kindOpinion], "#d": [mr] };
  const Jr = ur.storeSubscribe(Wr, { closeOnEose: !1 });
  component_subscribe(cr, Jr, (di) => lr(31, gr = di));
  const Gr = async (di) => {
    var eo;
    const yi = fr.pk;
    if (yi ? !ur.signer && await privkeyLogin(yi) : !ur.signer && await NDKlogin(), !Nr || !ur.signer)
      return;
    lr(
      7,
      Ir.content = yr ? yr + opinionHeaderSeparator : "",
      Ir
    ), lr(7, Ir.content += Nr + opinionFooterSeparator, Ir);
    const Bi = (eo = await ur.fetchEvent({
      kinds: [kindOpinion],
      authors: [dr.pubkey]
    })) == null ? void 0 : eo.tags;
    (Bi == null ? void 0 : Bi.length) === 3 && Bi[2][1] && (di = Bi[2][1]);
    const Ii = new NDKEvent(ur);
    Ii.kind = kindOpinion, (!di || !di.length) && (di = (Date.now() + 5e3).toString()), Ii.tags = [
      ["d", mr],
      ["sentiment", Ir.sentiment],
      ["title", vr],
      ["summary", Ar],
      ["published_at", di]
    ], kr && Ii.tags.push(["image", kr]), xr.split(",").map((Ui) => {
      Ui == "" || !Ui || (Ii.tags.push(["t", Ui]), lr(7, Ir.content += `#${Ui} `, Ir));
    }), _r && lr(7, Ir.content += `

` + _r, Ir), Ii.content = Ir.content, Ii.publish(NDKRelaySet.fromRelayUrls(DEFAULT_RELAY_URLS.write, ur)).then(() => {
      const Ui = Tr.findIndex((Vi) => Vi.pubkey === Ii.pubkey);
      Ui !== -1 ? lr(30, Tr[Ui] = { ...Ii }, Tr) : lr(30, Tr = [{ ...Ii }, ...Tr]), Vr();
    });
    let Fi = Ur.filter((Ui) => Ui.pubkey != (dr == null ? void 0 : dr.pubkey));
    lr(4, Ur = [...Fi]), lr(15, jr = !0), lr(3, Dr = !1), lr(11, Br = "all");
  }, Vr = () => {
    lr(10, Mr = { "-1": 0, 0: 0, 1: 0 }), lr(2, Sr = Tr.filter((di) => {
      var Bi;
      if (Br === "approved" && !Cr.includes(di.pubkey))
        return !1;
      const yi = (Bi = di.tags.find((Ii) => Ii[0] === "sentiment")) == null ? void 0 : Bi[1];
      return yi && !Ur.includes(di) && lr(10, Mr[yi] += 1, Mr), !0;
    })), lr(2, Sr = Sr.sort((di, yi) => {
      const Bi = Cr.includes(di.pubkey), Ii = Cr.includes(yi.pubkey);
      if (Bi && !Ii)
        return -1;
      if (!Bi && Ii)
        return 1;
      let Fi = (di == null ? void 0 : di.created_at) || 0, eo = (yi == null ? void 0 : yi.created_at) || 0;
      return Fi > eo ? -1 : Fi < eo ? 1 : 0;
    }));
  };
  async function Qr(di) {
    if (!dr) {
      console.log("Can't find user profile. $ndkUser is undefined");
      return;
    }
    let yi = await fetchUserProfile(di);
    return yi || (yi = {
      image: profileImageUrl + dr.pubkey,
      pubkey: dr.pubkey
    }), yi.image || (yi.image = profileImageUrl + di), yi.pubkey || (yi.pubkey = di), { content: yi };
  }
  (async () => {
    lr(5, Er = (await Promise.resolve().then(() => main)).expertOpinions);
    try {
      lr(1, Cr = await initializeApprovedAuthors());
      const di = fr.lastUserLogged;
      if (lr(9, Rr = !1), di && window) {
        let yi = ur.getUser({ npub: di });
        Zr();
        let Bi = await ur.fetchEvent({ kinds: [10002], authors: [yi.pubkey] });
        Bi && Bi.getMatchingTags("r").map((Ii) => {
          DEFAULT_RELAY_URLS.read.includes(Ii[1]) || (Ii.length === 3 ? Ii[2] === "write" && !DEFAULT_RELAY_URLS.write.includes(Ii[1]) ? DEFAULT_RELAY_URLS.write.push(Ii[1]) : Ii[2] === "read" && !DEFAULT_RELAY_URLS.read.includes(Ii[1]) && DEFAULT_RELAY_URLS.read.push(Ii[1]) : Ii.length === 2 && (DEFAULT_RELAY_URLS.write.includes(Ii[1]) || DEFAULT_RELAY_URLS.write.push(Ii[1]), DEFAULT_RELAY_URLS.read.includes(Ii[1]) || DEFAULT_RELAY_URLS.read.push(Ii[1])));
        }), ndkUser.set(yi), dr && lr(6, Lr[dr.pubkey] = await Qr(dr.pubkey), Lr), Tr.map((Ii) => {
          Ii.pubkey === (dr == null ? void 0 : dr.pubkey) && lr(15, jr = !0);
        });
      }
    } catch (di) {
      console.log(di);
    }
  })();
  const Xr = () => {
    lr(15, jr = !1), logout(), lr(8, Nr = "");
  };
  function si(di) {
    const yi = zr.filter((Bi) => Bi === di)[0].url;
    lr(8, Nr = Nr.replace(yi, "")), lr(8, Nr = Nr.replace("![]()", "")), lr(8, Nr = Nr.replace("![image]()", "")), lr(14, zr = zr.filter((Bi) => Bi !== di));
  }
  const Zr = async () => {
    if (dr) {
      let di = {
        kinds: [kindOpinion],
        "#d": [mr],
        authors: [dr.pubkey]
      };
      const yi = await ur.fetchEvent(di);
      let Bi = {
        kinds: [kindDelete],
        "#a": [`${kindOpinion}:${dr.pubkey}:${mr}`],
        authors: [dr.pubkey]
      };
      const Ii = await ur.fetchEvent(Bi);
      if ((Ii == null ? void 0 : Ii.created_at) < (yi == null ? void 0 : yi.created_at) || !Ii && yi) {
        lr(15, jr = !0);
        let Fi = (yi == null ? void 0 : yi.content.replace(opinionHeaderRegex, "").replace(opinionFooterRegex, "")) || "";
        const eo = (yi == null ? void 0 : yi.tagValue("sentiment")) || "0";
        lr(7, Ir = { content: Fi, sentiment: eo }), lr(8, Nr = Fi);
      } else
        Dr && (lr(15, jr = !1), lr(7, Ir = { content: "", sentiment: "0" }), lr(8, Nr = ""));
    }
  }, li = () => {
    lr(11, Br = "approved"), Vr(), lr(3, Dr = !1);
  }, Ei = () => {
    lr(11, Br = "all"), Vr(), lr(3, Dr = !1);
  };
  function ki(di) {
    Mr = di, lr(10, Mr);
  }
  function Di(di) {
    Nr = di, lr(8, Nr);
  }
  function hi(di) {
    Ir = di, lr(7, Ir);
  }
  function Ti(di) {
    Fr = di, lr(13, Fr);
  }
  function fi(di) {
    Ur = di, lr(4, Ur);
  }
  function Mi(di) {
    jr = di, lr(15, jr);
  }
  function oi(di) {
    Cr = di, lr(1, Cr);
  }
  const Ri = () => lr(3, Dr = !Dr);
  function qi(di) {
    zr = di, lr(14, zr);
  }
  function zi(di) {
    Nr = di, lr(8, Nr);
  }
  const to = () => {
    lr(7, Ir = { ...Ir, sentiment: "1" });
  }, Hi = () => {
    lr(7, Ir = { ...Ir, sentiment: "0" });
  }, _i = () => {
    lr(7, Ir = { ...Ir, sentiment: "-1" });
  }, Ai = (di) => si(di);
  function ui(di) {
    zr = di, lr(14, zr);
  }
  function ji(di) {
    Nr = di, lr(8, Nr);
  }
  const ai = () => lr(12, Hr = "login"), Li = () => lr(12, Hr = "register");
  function $i(di) {
    Lr = di, lr(6, Lr), lr(31, gr), lr(30, Tr);
  }
  function Wi(di) {
    Nr = di, lr(8, Nr);
  }
  function io(di) {
    Dr = di, lr(3, Dr);
  }
  function ro(di) {
    Lr = di, lr(6, Lr), lr(31, gr), lr(30, Tr);
  }
  function mi(di) {
    Dr = di, lr(3, Dr);
  }
  return cr.$$set = (di) => {
    "subject" in di && lr(0, mr = di.subject), "opinionTitle" in di && lr(24, vr = di.opinionTitle), "opinionHeader" in di && lr(25, yr = di.opinionHeader), "opinionFooter" in di && lr(26, _r = di.opinionFooter), "opinionImage" in di && lr(27, kr = di.opinionImage), "opinionTags" in di && lr(28, xr = di.opinionTags), "summary" in di && lr(29, Ar = di.summary);
  }, cr.$$.update = () => {
    cr.$$.dirty[0] & /*trustedAuthors*/
    2 && Cr && Vr(), cr.$$.dirty[0] & /*showNewOpinion*/
    8 && Zr(), cr.$$.dirty[0] & /*allEvents*/
    1073741824 | cr.$$.dirty[1] & /*$sub*/
    1 && gr.forEach(async (di) => {
      Tr.filter((Bi) => Bi.pubkey === di.pubkey).length ? lr(30, Tr = Tr.map((Bi) => Bi.pubkey === di.pubkey ? di : Bi)) : (lr(30, Tr = [...Tr, { ...di }]), lr(6, Lr[di.pubkey] = await Qr(di.pubkey), Lr)), Vr();
    }), cr.$$.dirty[0] & /*allEvents, deletedEventsArray, filteredEvents*/
    1073741844 && (lr(16, Yr = Tr.filter((di) => !Ur.includes(di)).length), lr(17, qr = Sr.filter((di) => !Ur.includes(di)).length));
  }, [
    mr,
    Cr,
    Sr,
    Dr,
    Ur,
    Er,
    Lr,
    Ir,
    Nr,
    Rr,
    Mr,
    Br,
    Hr,
    Fr,
    zr,
    jr,
    Yr,
    qr,
    dr,
    Jr,
    Gr,
    Vr,
    Xr,
    si,
    vr,
    yr,
    _r,
    kr,
    xr,
    Ar,
    Tr,
    gr,
    li,
    Ei,
    ki,
    Di,
    hi,
    Ti,
    fi,
    Mi,
    oi,
    Ri,
    qi,
    zi,
    to,
    Hi,
    _i,
    Ai,
    ui,
    ji,
    ai,
    Li,
    $i,
    Wi,
    io,
    ro,
    mi
  ];
}
class App extends SvelteComponent {
  constructor(ar) {
    super(), init(
      this,
      ar,
      instance,
      create_fragment,
      safe_not_equal,
      {
        subject: 0,
        opinionTitle: 24,
        opinionHeader: 25,
        opinionFooter: 26,
        opinionImage: 27,
        opinionTags: 28,
        summary: 29
      },
      add_css,
      [-1, -1, -1]
    );
  }
  get subject() {
    return this.$$.ctx[0];
  }
  set subject(ar) {
    this.$$set({ subject: ar }), flush();
  }
  get opinionTitle() {
    return this.$$.ctx[24];
  }
  set opinionTitle(ar) {
    this.$$set({ opinionTitle: ar }), flush();
  }
  get opinionHeader() {
    return this.$$.ctx[25];
  }
  set opinionHeader(ar) {
    this.$$set({ opinionHeader: ar }), flush();
  }
  get opinionFooter() {
    return this.$$.ctx[26];
  }
  set opinionFooter(ar) {
    this.$$set({ opinionFooter: ar }), flush();
  }
  get opinionImage() {
    return this.$$.ctx[27];
  }
  set opinionImage(ar) {
    this.$$set({ opinionImage: ar }), flush();
  }
  get opinionTags() {
    return this.$$.ctx[28];
  }
  set opinionTags(ar) {
    this.$$set({ opinionTags: ar }), flush();
  }
  get summary() {
    return this.$$.ctx[29];
  }
  set summary(ar) {
    this.$$set({ summary: ar }), flush();
  }
}
customElements.define("nostr-opinion", create_custom_element(App, { subject: {}, opinionTitle: {}, opinionHeader: {}, opinionFooter: {}, opinionImage: {}, opinionTags: {}, summary: {} }, [], [], !1));
class ExpertOpinions {
  constructor() {
    ti(this, "headline", "Community Opinions ($$nTrusted$$/$$nAll$$)");
    ti(this, "description", "These comments are contributed by nostr users using the nostr-opinions-plugin.");
    ti(this, "newOpinionDescription", `<p>
	Thank you for contributing your opinion. Please make sure to follow these
	simple guidelines:
</p>
<ul>
	<li>Be objective</li>
	<li>Be polite</li>
</ul>`);
    ti(this, "trustedAuthors", []);
    ti(this, "trustedBadgeAuthors", []);
    ti(this, "trustedBadges", []);
  }
}
const expertOpinions = new ExpertOpinions(), main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  expertOpinions
}, Symbol.toStringTag, { value: "Module" }));
export {
  expertOpinions
};
