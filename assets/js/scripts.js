window.verdictCount = {}
window.walletTotal = 0
//RESULT IS NOT EQUAL TO window.full_wallet_count GENERATED BY JEKYLL. 
//FAVOURING JEKYLL

window.filteredWallets = window.wallets
window.addEventListener("load", () => {
  const platformNames = Object.keys(window.platforms)
  for (var p in platformNames) {
    const platform = platformNames[p]
    window.verdictCount[platform] = { all: 0 }
    for (var v in window.verdictOrder) {
      const verdict = window.verdictOrder[v]
      window.verdictCount[platform][verdict] = 0
    }
  }
  for (var w in window.filteredWallets) {
    const wallet = window.filteredWallets[w]
    window.verdictCount[wallet.folder][wallet.verdict]++
    window.verdictCount[wallet.folder]["all"]++
    window.walletTotal++
  }
  recreateDropdowns("reproducible", "all")

  var x, y
  x = document.getElementById("SwitchToDownloadsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.remove("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.add("selected")
    resizeLabelBold()
  })
  x = document.getElementById("SwitchToWalletsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.add("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.remove("selected")
    resizeLabelBold()
  })
  updateModularPayload()
  document.body.addEventListener('keydown', e => {
    if (e.key === "Escape")
      toggleApp()
  })
})

function recreateDropdowns(verdict, platform) {
  if (window.verdictOrder && window.verdictOrder.length > 0 && document.querySelector(".dropdown-verdict")) {
    let html = `<div class="option ${verdict === 'all' ? 'selected' : ''} all" data="all"><span>All verdicts</span><small>${String(productCount('all', platform)).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}</small></div>`
    let availableFilteredWallets = `Search ${window.full_wallet_count} wallet reviews...`
    for (const instanceVerdict of window.verdictOrder) {
      const count = productCount(instanceVerdict, platform)
      if (count > 0) {
        html += `<div class="option ${verdict === instanceVerdict ? 'selected' : ''} ${instanceVerdict}" data="${instanceVerdict}"><span>${window.verdicts[instanceVerdict].short}</span> <small>${String(count).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}</small></div>`
      }
      else if (verdict === instanceVerdict) {
        html += `<div class="option selected ${instanceVerdict}" data="${instanceVerdict}"><span>${instanceVerdict}</span> <small>0</small></div>`
      }
    }
    document.querySelector('.search-filtered-wallets').setAttribute("placeholder", availableFilteredWallets)
    document.querySelector(".dropdown-verdict").innerHTML = html
  }

  if (window.platformObs && window.platformObs.length > 0 && document.querySelector(".dropdown-platform")) {
    let html = ``
    for (const instancePlatform of window.platformObs) {
      let instancePlatformText = false
      switch (instancePlatform) {
        case 'iphone':
          instancePlatformText = "iPhone"
          break;
        case 'all':
          instancePlatformText = "All Platforms"
          break;
        default:
          instancePlatformText = instancePlatform.charAt(0).toUpperCase() + instancePlatform.slice(1)
      }
      html += `<div class="option ${platform === instancePlatform ? 'selected' : ''} ${instancePlatform}" data="${instancePlatform}"><span>${instancePlatformText}</span></div>`
    }
    document.querySelectorAll(".dropdown-platform").forEach((ele) => { ele.innerHTML = html })
  }
}

for (const target of ["verdict", "platform"]) {
  addDropdownEvents(target, () => { updateUrl(true); updateModularPayload() })
}

//SEPARATE FUNCTION FOR GRID / LIST TO AVOID MAKING THE LOGIC CONFUSING
let userSelectView = localStorage.getItem("userSelectView") ? localStorage.getItem("userSelectView") : 'tiles'
document.querySelector(".dropdown-view > .selected").classList.remove("selected")
document.querySelector(".dropdown-view > ." + userSelectView).classList.add("selected")
for (const view of document.querySelectorAll(".tile-list-ui")) { view.setAttribute("class", `tile-list-ui view-${userSelectView}`) }
document.querySelector(".dropdown-view").addEventListener("click", (event) => {
  const self = event.target.parentNode.classList.contains("option") ? event.target.parentNode : (event.target.querySelector(".option.selected") ? event.target.querySelector(".option.selected") : event.target)
  const parentEle = self.parentNode
  if (!self.classList.contains("selected") && self.classList.contains("option")) {
    //TARGET IS AN UN-SELECTED CHILD ELEMENT
    event.stopPropagation()
    parentEle.querySelectorAll(".selected").forEach((ele) => { ele.classList.remove("selected") })
    self.classList.add("selected")
    parentEle.classList.remove("opened")
    for (const view of document.querySelectorAll(".tile-list-ui")) {
      let newView = self.getAttribute("data")
      view.setAttribute("class", `tile-list-ui view-${newView}`)
      localStorage.setItem("userSelectView", newView)
    }
    return
  }
  resetDropdowns(event, parentEle)
})

/**
 * @return how many products in the platform have the verdict.
 **/
function productCount(verdict, platform) {
  if (platform === 'all') {
    let count = 0
    for (const key of Object.keys(window.verdictCount)) { count += window.verdictCount[key][verdict] }
    return count
  }
  return window.verdictCount[platform][verdict]
}

function updateModularPayload(page, unrestrictedSearch) {
  let verdict = document.querySelector(".dropdown-verdict").querySelector(".selected") ? document.querySelector(".dropdown-verdict").querySelector(".selected").getAttribute("data") : "reproducible"
  const platform = document.querySelector(".dropdown-platform").querySelector(".selected") ? document.querySelector(".dropdown-platform").querySelector(".selected").getAttribute("data") : "all"
  // remove empty verdicts
  recreateDropdowns(verdict, platform)
  verdict = document.querySelector(".dropdown-verdict").querySelector(".selected") ? document.querySelector(".dropdown-verdict").querySelector(".selected").getAttribute("data") : "reproducible"

  document.querySelectorAll(".-filter-element").forEach(e => {
    e.classList.contains(`-${platform}`) ? (e.style.display = "flex") : (e.style.display = "none")
  })


  var appIds = []
  var presort = []
  const paltformOrder = ['all', 'android', 'iphone', 'hardware', 'bearer']
  const metaOrder = ['ok', 'outdated', 'stale', 'obsolete', 'defunct']
  window.filteredWallets.forEach(obj => {
    if (unrestrictedSearch) {
      presort.push(obj)
      appIds.push(obj.appId)
    }
    else if (obj.appId && obj.verdict && obj.folder &&
      (verdict === "all" || String(obj.verdict) === verdict) &&
      (platform === "all" || String(obj.folder) === platform)) {
      presort.push(obj)
      appIds.push(obj.appId)
    }
  })
  appIds.sort().reverse()
  presort.sort((a, b) => {
    if (a.verdict != b.verdict)
      return window.verdictOrder.indexOf(a.verdict) - window.verdictOrder.indexOf(b.verdict)
    if (a.folder != b.folder)
      return paltformOrder.indexOf(a.folder) - paltformOrder.indexOf(b.folder)
    if (a.meta != b.meta)
      return metaOrder.indexOf(a.meta) - metaOrder.indexOf(b.meta)
    if (a.users != b.users)
      return b.users - a.users
    if (a.ratings != b.ratings)
      return b.ratings - a.ratings
    if (a.reviews != b.reviews)
      return b.reviews - a.reviews
    return 0
  })
  page = page ? page : 0
  renderBadgesToDiv(presort, document.getElementById("modularWalletPayload"), page, verdict, platform)
  resizeLabelBold()
  updateUrl()
}

const paginationLimit = 12
function renderBadgesToDiv(wallets, anchor, page, verdict, platform) {
  page = page ? page : 0
  const maxPages = Math.ceil(wallets.length / paginationLimit)
  if (!anchor)
    return
  let badgesHtml = ``
  let pagination = document.createElement("div")
  let allowedTargets = processAllowedTargetArray(page, maxPages)
  let gapAdded = false
  for (let i = 0; i < maxPages; i++) {
    const clickTarget = document.createElement("div")
    clickTarget.classList.add("click-target")
    clickTarget.innerHTML = i + 1
    clickTarget.addEventListener("click", () => {
      updatePageinationUI(i)
    })
    if (i == page) { clickTarget.classList.add("selected") }
    if (allowedTargets.indexOf(i) < 0) { clickTarget.style.display = 'none' }
    if ((allowedTargets[i] + 1 !== allowedTargets[i + 1]) && !gapAdded) {
      clickTarget.classList.add("major-gap")
      gapAdded = true
    }
    clickTarget.setAttribute("data-index", i)
    pagination.append(clickTarget)
  }

  for (let i = 0; i < paginationLimit; i++) {
    const numb = (page * paginationLimit) + i
    const instance = wallets[numb]
    if (!instance) { break }
    badgesHtml += getBadge(instance, i)
  }
  var d = document.createElement("div")
  d.classList.add("page-section")
  let flexListEle = document.createElement("div")
  pagination.classList.add("pagination")
  flexListEle.classList.add("flexi-list")
  var g = document.createElement("div")
  g.setAttribute("id", "tableofwallets")
  g.innerHTML = `<div id="modal" style="position:fixed;left:0;top:0;width:100%;height:100%;z-index:50;display:none" onclick="toggleApp(lastId);">&nbsp;</div>`
  let queryEcho = document.querySelector(".search-filtered-wallets").value.length > 0 ? `No wallets match for "${document.querySelector(".search-filtered-wallets").value}".` : `Enter some text to search all wallets.`
  let categoryMessage = productCount(verdict, platform) < 1 ? `No <b>${verdict}</b> wallets in <b>${platform}</b> category. ${(wallets.length > 0 ? `<br>Showing ${wallets.length} results from all categories and platforms.` : ``)}<br><br>` : `Showing ${wallets.length} wallets which match current filters.`
  flexListEle.innerHTML = badgesHtml.length == 0 ? `<p class="empty-results-info">${categoryMessage}${queryEcho}<br>You can search for wallets by name or description.</p>` : `<p class="empty-results-info">${categoryMessage}</p>${badgesHtml}`
  d.append(g)
  d.append(flexListEle)
  d.append(pagination)
  anchor.querySelectorAll(".page-section")[0].replaceWith(d)
  for (let i = 0; i < paginationLimit; i++) {
    const numb = (page * paginationLimit) + i
    const instance = wallets[numb]
    if (!instance) { break }
    processStyle(instance)
  }
}
function processAllowedTargetArray(page, maxPages) {
  let allowedTargets = [0, 1, 2, page - 2, page - 1, page, page + 1, page + 2, maxPages - 3, maxPages - 2, maxPages - 1]
  allowedTargets = [...new Set(allowedTargets)];
  allowedTargets = allowedTargets.filter(function (numb) { return numb > -1 });
  return allowedTargets
}
function updatePageinationUI(index) {
  index = index < 0 ? 0 : index
  window.pageIndex = index
  const allTargetEle = document.querySelectorAll(".click-target")
  for (const target of allTargetEle) { target.classList.remove("selected") }
  if (allTargetEle[index]) { allTargetEle[index].classList.add("selected") }
  updateUrl(true)
  updateModularPayload(index)
}

async function processStyle(wallet) {
  if (!wallet.icon) { return '' }
  const walletId = wallet.folder + String(wallet.appId)
  let wIdforDOM = String(walletId).replace(/\./g, "_")
  let target = await document.querySelector(`.${wIdforDOM}`)
  if (!target) { return }
  let imgObj = new Image();
  imgObj.src = `/images/wIcons/${wallet.folder}/small/${wallet.icon}`;
  imgObj.onload = function () {
    if(wallet.folder!=='bearer' && wallet.folder!=='hardware')
    {let instanceCanvas = document.createElement("canvas")
    instanceCanvas.setAttribute("class", `${wIdforDOM}-instance-canvas instance-canvas`)
    instanceCanvas.height = imgObj.height*.25
    instanceCanvas.width = imgObj.width*.25
    document.body.append(instanceCanvas)
    let canvasEle = document.querySelector(`.${wIdforDOM}-instance-canvas`)
    canvasEle.getContext("2d").drawImage(imgObj, 0, 0);
    const canvasEleData = canvasEle.getContext("2d").getImageData(0, 0, canvasEle.width, canvasEle.height);
    if (canvasEleData.data[3] == 0 && canvasEleData.data[canvasEleData.data.length-1] == 0) { target.setAttribute("data-icon-shape", "free") }
    else if (canvasEleData.data[3] < 255) { target.setAttribute("data-icon-shape", "round") }}

    let colorThief = new ColorThief();

    for (const rgb of colorThief.getPalette(imgObj, 3)) {
      if (rgb[0] < 70 && rgb[1] < 70 & rgb[2] < 70) { continue; }
      if (rgb[0] > 130 && rgb[1] > 130 & rgb[2] > 130) { continue; }
      if (target.style && target.style['background-image']) { break; }
      target.style['background-image'] = `linear-gradient(var(--white) -100%, rgb(${rgb[0]},${rgb[1]},${rgb[2]}) 400%)`
      let colour = `rgba(${rgb[0]},${rgb[1]},${rgb[2]}, 0.2)`;
      target.setAttribute("data-colour", colour);
    }
  }
}

function getBadge(wallet, numbInPage) {
  const walletId = wallet.folder + String(wallet.appId)
  let wIdforDOM = String(walletId).replace(/\./g, "_")
  let faCollection = getIcon(wallet.folder)
  const delay = numbInPage > 25 ? 2000 : numbInPage * 80
  // USER WILL LIKELY NEVER BROWSE AS MUCH AS 1% OF THE WALLETS
  // THEREFORE MOVING PARTS OF LOGIC TO ONLY BE CALLED WHEN
  // USER WANTS TO SEE MORE ABOUT A WALLET
  let passed = ``
  let failed = ``
  for (let i = 0; i < wallet.score.numerator; i++) { passed += `<i class="pass"></i>` }
  for (let i = 0; i < (wallet.score.denominator - wallet.score.numerator); i++) { failed += `<i class="fail"></i>` }
  return `
  <div id="card_${walletId}" class="AppDisplayCard item ${wallet.folder} ${wallet.meta} ${wIdforDOM}" href="${wallet.url}" onclick="toggleApp('${walletId}', false, this)" style="animation-delay:${delay}ms;">
    <div class="tile-head">
      <img src="${wallet.icon ? `/images/wIcons/${wallet.folder}/small/${wallet.icon}` : '/images/smallNoicon.png'}" class="app_logo" alt="Wallet Logo">
      <h3>${wallet.altTitle || wallet.title}</h3>
      <span class="platform tile-view-only"><i class="${faCollection}"></i><span> ${wallet.category}</span></span>
    </div>
    <div class="list-view-only list-details">
      <span><i class="${faCollection}"></i> ${wallet.category}</span>
        <div class="stats">
          <div class="tests-passed" data-numerator="${wallet.score.numerator}" data-denominator="${wallet.score.denominator}">
            <span>Passed ${wallet.score.numerator} of ${wallet.score.denominator} tests</span>
            <div>${passed}${failed}</div>
          </div>
        </div>
        <span class="updated" data-text="latest analysis">${wallet.updated ? wallet.updated : wallet.date}</span>
    </div>
    <div class="wallet-details">
      <div class="stamps">
      ${wallet.meta !== "outdated" ? `<span data-text="${window.verdicts[wallet.verdict].short}" class="stamp stamp-${wallet.verdict}" alt=""></span>` : ""}
      ${wallet.meta && wallet.meta !== "ok" ? `<span data-text="${window.verdicts[wallet.meta].short}" class="stamp stamp-${wallet.meta}" alt=""></span>` : ""}
      </div>
      <div class="score" data-numerator="${wallet.score.numerator}" data-denominator="${wallet.score.denominator}">
        <span>Passed ${wallet.score.numerator} of ${wallet.score.denominator} tests</span>
        <div>${passed}${failed}</div>
      </div>
    </div>
  </div>`
}

function filterWalletsByName() {
  let searchTerm = document.querySelector(".search-filtered-wallets").value.trim().toUpperCase()
  if (searchTerm.length < 1) { window.filteredWallets = window.wallets }
  else {
    window.filteredWallets = []
    const searchTermWords = searchTerm.split(" ")
    for (const wallet of window.wallets) {
      if (wallet.title.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
      else if (wallet.folder.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
      else if (wallet.category.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
      else if (wallet.appId.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
      else {
        for (const word of searchTermWords) {
          if (wallet.title.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
          else if (wallet.folder.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
          else if (wallet.category.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
          else if (wallet.appId.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
        }
      }
    }
  }
  const verdict = document.querySelector(".dropdown-verdict > .selected") ? document.querySelector(".dropdown-verdict > .selected").getAttribute("data") : "reproducible"
  const platform = document.querySelector(".dropdown-platform > .selected") ? document.querySelector(".dropdown-platform > .selected").getAttribute("data") : "all"
  recreateDropdowns(verdict, platform)
  updateModularPayload(0, searchTerm.length > 0 ? true : false)
}
document.querySelector(".search-filtered-wallets").addEventListener("input", filterWalletsByName)
document.querySelector(".search-filtered-wallets").value = ""