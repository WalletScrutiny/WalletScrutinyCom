window.verdictCount = {}
window.walletTotal = 0
//RESULT IS NOT EQUAL TO window.full_wallet_count GENERATED BY JEKYLL. 
//FAVOURING JEKYLL

window.filteredWallets = window.wallets
window.addEventListener("load", () => {
  const platformNames = Object.keys(window.platforms)
  for (var p in platformNames) {
    const platform = platformNames[p]
    window.verdictCount[platform] = { all: 0 }
    for (var v in window.verdictOrder) {
      const verdict = window.verdictOrder[v]
      window.verdictCount[platform][verdict] = 0
    }
  }
  for (var w in window.filteredWallets) {
    const wallet = window.filteredWallets[w]
    window.verdictCount[wallet.folder][wallet.verdict]++
    window.verdictCount[wallet.folder]["all"]++
    window.walletTotal++
  }
  recreateDropdowns("reproducible", "android")

  var x, y
  x = document.getElementById("SwitchToDownloadsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.remove("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.add("selected")
    resizeLabelBold()
  })
  x = document.getElementById("SwitchToWalletsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.add("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.remove("selected")
    resizeLabelBold()
  })
  updateModularPayload()
  document.body.addEventListener('keydown', e => {
    if (e.key === "Escape")
      toggleApp()
  })
})

function recreateDropdowns(verdict, platform) {
  if (window.verdictOrder && window.verdictOrder.length > 0 && document.querySelector(".dropdown-verdict")) {
    let html = `<div class="option ${verdict === 'all' ? 'selected' : ''} all" data="all"><span>All verdicts</span></div>`
    let availableFilteredWallets = `Search ${window.full_wallet_count} wallet reviews...`
    for (const instanceVerdict of window.verdictOrder) {
      const count = productCount(instanceVerdict, platform)
      if (count > 0) {
        html += `<div class="option ${verdict === instanceVerdict ? 'selected' : ''} ${instanceVerdict}" data="${instanceVerdict}"><span>${window.verdicts[instanceVerdict].short}</span> <small>${count} wallets</small></div>`
      }
      else if (verdict === instanceVerdict) {
        html += `<div class="option selected ${instanceVerdict}" data="${instanceVerdict}"><span>${instanceVerdict}</span> <small>none found</small></div>`
      }
    }
    document.querySelector('.search-filtered-wallets').setAttribute("placeholder", availableFilteredWallets)
    document.querySelector(".dropdown-verdict").innerHTML = html
  }

  if (window.platformObs && window.platformObs.length > 0 && document.querySelector(".dropdown-platform")) {
    let html = ``
    for (const instancePlatform of window.platformObs) {
      const instancePlatformText = instancePlatform==='iphone'? 'iPhone':instancePlatform.charAt(0).toUpperCase() + instancePlatform.slice(1)
      html += `<div class="option ${platform === instancePlatform ? 'selected' : ''} ${instancePlatform}" data="${instancePlatform}"><i class="${getIcon(instancePlatform)}"></i> <span>${instancePlatformText}</span></div>`
    }
    document.querySelectorAll(".dropdown-platform").forEach((ele) => { ele.innerHTML = html })
  }
}

for (const target of ["verdict", "platform"]) {
  addDropdownEvents(target, () => {updateUrl(true); updateModularPayload()})
}

//SEPARATE FUNCTION FOR GRID / LIST TO AVOID MAKING THE LOGIC CONFUSING
let userSelectView = localStorage.getItem("userSelectView") ? localStorage.getItem("userSelectView") : 'tiles'
document.querySelector(".dropdown-view > .selected").classList.remove("selected")
document.querySelector(".dropdown-view > ." + userSelectView).classList.add("selected")
for (const view of document.querySelectorAll(".tile-list-ui")) { view.setAttribute("class", `tile-list-ui view-${userSelectView}`) }
document.querySelector(".dropdown-view").addEventListener("click", (event) => {
  const self = event.target.parentNode.classList.contains("option") ? event.target.parentNode : (event.target.querySelector(".option.selected") ? event.target.querySelector(".option.selected") : event.target)
  const parentEle = self.parentNode
  if (!self.classList.contains("selected") && self.classList.contains("option")) {
    //TARGET IS AN UN-SELECTED CHILD ELEMENT
    event.stopPropagation()
    parentEle.querySelectorAll(".selected").forEach((ele) => { ele.classList.remove("selected") })
    self.classList.add("selected")
    parentEle.classList.remove("opened")
    for (const view of document.querySelectorAll(".tile-list-ui")) {
      let newView = self.getAttribute("data")
      view.setAttribute("class", `tile-list-ui view-${newView}`)
      localStorage.setItem("userSelectView", newView)
    }
    return
  }
  resetDropdowns(event, parentEle)
})

/**
 * @return how many products in the platform have the verdict.
 **/
function productCount(verdict, platform) {
  return window.verdictCount[platform][verdict]
}

function updateModularPayload(page, unrestrictedSearch) {
  let verdict = document.querySelector(".dropdown-verdict").querySelector(".selected") ? document.querySelector(".dropdown-verdict").querySelector(".selected").getAttribute("data") : "reproducible"
  const platform = document.querySelector(".dropdown-platform").querySelector(".selected") ? document.querySelector(".dropdown-platform").querySelector(".selected").getAttribute("data") : "android"
  // remove empty verdicts
  recreateDropdowns(verdict, platform)
  verdict = document.querySelector(".dropdown-verdict").querySelector(".selected") ? document.querySelector(".dropdown-verdict").querySelector(".selected").getAttribute("data") : "reproducible"

  document.querySelectorAll(".-filter-element").forEach(e => {
    e.classList.contains(`-${platform}`) ? (e.style.display = "flex") : (e.style.display = "none")
  })

  switch (platform) {
    case 'android':
      ((document.getElementById("SwitchToDownloadsView") || {}).style || {}).display = ""
      break
    case 'iphone':
    case 'hardware':
    case 'bearer':
      var x
      x = document.getElementById("SwitchToDownloadsView"); if (x) x.style.display = "none"
      x = document.getElementById("walletsPerCatContainer"); if (x) x.classList.add("selected")
      x = document.getElementById("proportionalViewContainer"); if (x) x.classList.remove("selected")
      break
  }

  var appIds = []
  var presort = []
  const paltformOrder = 'android,iphone,hardware,bearer'.split(',')
  const metaOrder = 'ok,outdated,stale,obsolete,defunct'.split(',')
  window.filteredWallets.forEach(obj => {
    if (unrestrictedSearch) {
      presort.push(obj)
      appIds.push(obj.appId)
    }
    else if (obj.appId && obj.verdict && obj.folder &&
      (verdict === "all" || String(obj.verdict) === verdict) &&
      (platform === "all" || String(obj.folder) === platform)) {
      presort.push(obj)
      appIds.push(obj.appId)
    }
  })
  appIds.sort().reverse()
  presort.sort((a, b) => {
    if (a.verdict != b.verdict)
      return window.verdictOrder.indexOf(a.verdict) - window.verdictOrder.indexOf(b.verdict)
    if (a.folder != b.folder)
      return paltformOrder.indexOf(a.folder) - paltformOrder.indexOf(b.folder)
    if (a.meta != b.meta)
      return metaOrder.indexOf(a.meta) - metaOrder.indexOf(b.meta)
    if (a.users != b.users)
      return b.users - a.users
    if (a.ratings != b.ratings)
      return b.ratings - a.ratings
    if (a.reviews != b.reviews)
      return b.reviews - a.reviews
    return 0
  })
  page = page ? page : 0
  renderBadgesToDiv(presort, document.getElementById("modularWalletPayload"), page, verdict, platform)
  resizeLabelBold()
  updateUrl()
}

const paginationLimit = 15
function renderBadgesToDiv(wallets, anchor, page, verdict, platform) {
  page = page ? page : 0
  const maxPages = Math.ceil(wallets.length / paginationLimit)
  if (!anchor)
    return
  let badgesHtml = ``
  let pagination = document.createElement("div")
  let allowedTargets = processAllowedTargetArray(page, maxPages)
  let gapAdded = false
  for (let i = 0; i < maxPages; i++) {
    const clickTarget = document.createElement("div")
    clickTarget.classList.add("click-target")
    clickTarget.innerHTML = i + 1
    clickTarget.addEventListener("click", () => {
      updatePageinationUI(i)
    })
    if (i == page) { clickTarget.classList.add("selected") }
    if (allowedTargets.indexOf(i) < 0) { clickTarget.style.display = 'none' }
    if ((allowedTargets[i] + 1 !== allowedTargets[i + 1]) && !gapAdded) {
      clickTarget.classList.add("major-gap")
      gapAdded = true
    }
    clickTarget.setAttribute("data-index", i)
    pagination.append(clickTarget)
  }

  for (let i = 0; i < paginationLimit; i++) {
    const numb = (page * paginationLimit) + i
    const instance = wallets[numb]
    if (!instance) { break }
    badgesHtml += getBadge(instance, numb)
  }
  var d = document.createElement("div")
  d.classList.add("page-section")
  let flexListEle = document.createElement("div")
  pagination.classList.add("pagination")
  flexListEle.classList.add("flexi-list")
  var g = document.createElement("div")
  g.setAttribute("id", "tableofwallets")
  g.innerHTML = `<div id="modal" style="position:fixed;left:0;top:0;width:100%;height:100%;z-index:50;display:none" onclick="toggleApp(lastId);">&nbsp;</div>`
  let queryEcho = document.querySelector(".search-filtered-wallets").value.length > 0 ? `No wallets match for "${document.querySelector(".search-filtered-wallets").value}".` : `Enter some text to search all wallets.`
  let categoryMessage = productCount(verdict, platform)<1?`No <b>${verdict}</b> wallets in <b>${platform}</b> category. ${(wallets.length>0?`<br>Showing ${wallets.length} results from all categories and platforms.`:``)}<br><br>`:`Showing ${wallets.length} results from <b>all</b> platforms and categories.`
  flexListEle.innerHTML = badgesHtml.length == 0 ? `<p class="empty-results-info">${categoryMessage}${queryEcho}<br>You can search for wallets by name or description.</p>` : `<p class="empty-results-info">${categoryMessage}</p>${badgesHtml}`
  d.append(g)
  d.append(flexListEle)
  d.append(pagination)
  anchor.querySelectorAll(".page-section")[0].replaceWith(d)
}
function processAllowedTargetArray(page, maxPages) {
  let allowedTargets = [0, 1, 2, page - 2, page - 1, page, page + 1, page + 2, maxPages - 3, maxPages - 2, maxPages - 1]
  allowedTargets = [...new Set(allowedTargets)];
  allowedTargets = allowedTargets.filter(function (numb) { return numb > -1 });
  return allowedTargets
}
function updatePageinationUI(index) {
  index=index<0?0:index
  window.pageIndex = index
  const allTargetEle = document.querySelectorAll(".click-target")
  for (const target of allTargetEle) { target.classList.remove("selected") }
  if (allTargetEle[index]) { allTargetEle[index].classList.add("selected") }
  updateUrl(true)
  updateModularPayload(index)
}


function getBadge(wallet, num) {
  const walletId = wallet.folder + String(wallet.appId)
  let wIdforDOM = String(walletId).replace(/\./g, "_")
  let faCollection = getIcon(wallet.folder)
  const delay = num > 25 ? 2000 : num * 80

  if (wallet.icon) {
    let imgObj = new Image();
    imgObj.src = `/images/wIcons/${wallet.folder}/small/${wallet.icon}`;
    imgObj.onload = function () {
      // document.querySelector(`.${wIdforDOM} img.app_logo`).src = this.src
      let colorThief = new ColorThief();
      let target = document.querySelector(`.${wIdforDOM}`)
      if (target) {
        for (const rgb of colorThief.getPalette(imgObj, 3)) {
          if (rgb[0] < 70 && rgb[1] < 70 & rgb[2] < 70) { continue; }
          if (rgb[0] > 130 && rgb[1] > 130 & rgb[2] > 130) { continue; }
          if (target.style && target.style['background-image']) { break; }
          target.style['background-image'] = `linear-gradient(var(--white) -100%, rgb(${rgb[0]},${rgb[1]},${rgb[2]}) 400%)`
          let colour = `rgba(${rgb[0]},${rgb[1]},${rgb[2]}, 0.2)`;
          target.setAttribute("data-colour", colour);
        }
      }
    }
  }
  // USER WILL LIKELY NEVER BROWSE AS MUCH AS 1% OF THE WALLETS
  // THEREFORE MOVING PARTS OF LOGIC TO ONLY BE CALLED WHEN
  // USER WANTS TO SEE MORE ABOUT A WALLET
  return `
  <div id="card_${walletId}" class="AppDisplayCard item ${wallet.meta} ${wIdforDOM}" href="${wallet.url}" onclick="toggleApp('${walletId}', false, this)" style="animation-delay:${delay}ms;">
    <div class="tile-head">
      <img loading="lazy" src="${wallet.icon ? `/images/wIcons/${wallet.folder}/small/${wallet.icon}` : '/images/smallNoicon.png'}" class="app_logo" alt="Wallet Logo">
      <h3>${wallet.altTitle || wallet.title}</h3>
      <span class="platform tile-view-only"><i class="${faCollection}"></i><span> ${wallet.category}</span></span>
    </div>
    <div class="list-view-only list-details">
      <span><i class="${faCollection}"></i> ${wallet.category}</span>
        <div class="stats">
          <span title="${wallet.stars} stars" class="star-rating" style="background-image: linear-gradient(90deg,var(--dark-grey, #ffd900) calc(${wallet.stars} / 5 * 100%), var(--shadow-3, #eee) 0%);">★★★★★</span>
        </div>
        <span class="updated" data-text="latest analysis">${wallet.updated ? wallet.updated : wallet.date}</span>
    </div>
    <div class="wallet-details">
      <div class="stamps">
      ${wallet.meta !== "outdated" ? `<span data-text="${window.verdicts[wallet.verdict].short}" class="stamp stamp-${wallet.verdict}" alt=""></span>` : ""}
      ${wallet.meta && wallet.meta !== "ok" ? `<span data-text="${window.verdicts[wallet.meta].short}" class="stamp stamp-${wallet.meta}" alt=""></span>` : ""}
      </div>
    </div>
  </div>`
}

function filterWalletsByName() {
  let searchTerm = document.querySelector(".search-filtered-wallets").value.trim().toUpperCase()
  if (searchTerm.length < 1) { window.filteredWallets = window.wallets }
  else {
    window.filteredWallets = []
    const searchTermWords = searchTerm.split(" ")
    for (const wallet of window.wallets) {
        if(wallet.title.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
        else if (wallet.folder.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
        else if (wallet.category.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
        else if (wallet.appId.toUpperCase().indexOf(searchTerm) >= 0) { window.filteredWallets.push(wallet) }
        else {
          for (const word of searchTermWords) {
            if(wallet.title.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
            else if(wallet.folder.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
            else if(wallet.category.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
            else  if(wallet.appId.toUpperCase().indexOf(word) >= 0) { window.filteredWallets.push(wallet) }
          }
    }
  }
  }
  const verdict = document.querySelector(".dropdown-verdict > .selected") ? document.querySelector(".dropdown-verdict > .selected").getAttribute("data") : "reproducible"
  const platform = document.querySelector(".dropdown-platform > .selected") ? document.querySelector(".dropdown-platform > .selected").getAttribute("data") : "android"
  recreateDropdowns(verdict, platform)
  updateModularPayload(0, searchTerm.length >0?true:false)
}
document.querySelector(".search-filtered-wallets").addEventListener("input", filterWalletsByName)
document.querySelector(".search-filtered-wallets").value=""