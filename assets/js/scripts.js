let lastVerdict = false
let lastPlatform = false
let persistRandomWallets = false
window.verdictCount = {}
window.walletTotal = 0
//RESULT IS NOT EQUAL TO window.full_wallet_count GENERATED BY JEKYLL. 
//FAVOURING JEKYLL

window.filteredWallets = window.wallets
window.addEventListener("load", () => {
  const platformNames = Object.keys(window.platforms)
  for (var p in platformNames) {
    const platform = platformNames[p]
    window.verdictCount[platform] = { all: 0 }
    for (const [key, value] of Object.entries(verdictGroups)) {
      window.verdictCount[platform][key] = 0
      for (const wallet of window.filteredWallets) {
        if(platform !== wallet.folder){continue}
        if (value.verdicts.indexOf(wallet.verdict) >= 0) {
          window.verdictCount[platform][key]++
        }
        window.walletTotal++
      }
    }
  }
  for (const key of Object.keys(window.verdictCount)) {
    let total = 0
    for (const [k, value] of Object.entries(window.verdictCount[key])) {
      total+=value
    }
    window.verdictCount[key].all=total
  }
  recreateDropdowns("all_tests_passed", "all")

  var x, y
  x = document.getElementById("SwitchToDownloadsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.remove("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.add("selected")
    resizeLabelBold()
  })
  x = document.getElementById("SwitchToWalletsView"); if (x) x.addEventListener("click", e => {
    y = document.getElementById("walletsPerCatContainer"); if (y) y.classList.add("selected")
    y = document.getElementById("proportionalViewContainer"); if (y) y.classList.remove("selected")
    resizeLabelBold()
  })
  document.querySelector('.search-filtered-wallets').setAttribute("placeholder", `Search ${productCount('all', 'all', true)} security reviews...`)
  updateModularPayload()
})

function recreateDropdowns(verdict, platform) {
  // verdictGroups DECLARED IN WALLETSJS
  if (verdictGroups && document.querySelector(".dropdown-verdict")) {
    const titleRow = verdict.indexOf('all')==0?'grid-row:3/4':'grid-row:4/5'
    let html = `<div class="option category-title" style=${titleRow}><span>Other test results</span></div><div class="option ${verdict === 'all' ? 'selected' : ''} all" data="all"><span>All reviews</span><small>${String(productCount('all', platform, true))}</small></div>`
    for (const [key, value] of Object.entries(verdictGroups)) {
      const count = productCount(key, platform, true)
      html += `<div class="option ${verdict === key ? 'selected' : ''} ${key}" data="${key}" data-name="${value.short}"><span>${value.short}</span> <small>${count}</small></div>`
    }
    document.querySelector(".dropdown-verdict").innerHTML = html
  }

  if (window.platformObs && window.platformObs.length > 0 && document.querySelector(".dropdown-platform")) {
    let html = ``
    for (const instancePlatform of window.platformObs) {
      let instancePlatformText = platformTitleFormatting(instancePlatform)
      html += `<div class="option ${platform === instancePlatform ? 'selected' : ''} ${instancePlatform}" data="${instancePlatform}"><span>${instancePlatformText}</span></div>`
    }
    document.querySelectorAll(".dropdown-platform").forEach((ele) => { ele.innerHTML = html })
  }
}

for (const target of ["verdict", "platform"]) {
  addDropdownEvents(target, () => { updateUrl(true); updateModularPayload(0, false) })
}

function platformTitleFormatting(platform) {
  let instancePlatformText = false
  switch (platform) {
    case 'iphone':
      instancePlatformText = "iPhone"
      break;
    case 'all':
      instancePlatformText = "All Platforms"
      break;
    default:
      instancePlatformText = platform.charAt(0).toUpperCase() + platform.slice(1)
  }
  return instancePlatformText
}

/**
 * @return how many products in the platform have the verdict.
 **/
function productCount(verdict, platform, toLocale) {
  let value = false
  if (platform === 'all') {
    let count = 0
    for (const key of Object.keys(window.verdictCount)) { count += window.verdictCount[key][verdict] }
    value = count
  } else {
    value = window.verdictCount[platform][verdict]
  }
  return toLocale?String(value).replace(/\B(?=(\d{3})+(?!\d))/g, ","):value
}
function updateModularPayload(page, unrestrictedSearch, noPush) {
  const verdict = document.querySelector(".dropdown-verdict").querySelector(".selected") ? document.querySelector(".dropdown-verdict").querySelector(".selected").getAttribute("data") : "all_tests_passed"
  const platform = document.querySelector(".dropdown-platform").querySelector(".selected") ? document.querySelector(".dropdown-platform").querySelector(".selected").getAttribute("data") : "all"
  if (unrestrictedSearch) {
    recreateDropdowns('all', 'all')
  } else {
    // remove empty verdicts
    recreateDropdowns(verdict, platform)
  }

  document.querySelectorAll(".-filter-element").forEach(e => {
    e.classList.contains(`-${platform}`) ? (e.style.display = "flex") : (e.style.display = "none")
  })

  if(lastVerdict!==verdict){persistRandomWallets = false}
  if(lastPlatform!==platform){persistRandomWallets = false}
  var appIds = []
  var presort = []
  const paltformOrder = ['all', 'android', 'iphone', 'hardware', 'bearer']
  const metaOrder = ['ok', 'outdated', 'stale', 'obsolete', 'defunct']
  window.filteredWallets.forEach(obj => {
    if (unrestrictedSearch) {
      presort.push(obj)
    }
    else if (obj.appId && obj.verdict && obj.folder &&
      (verdict === "all" || verdictGroups[verdict].verdicts.indexOf(obj.verdict) >= 0)
      &&
      (platform === "all" || String(obj.folder) === platform)) {
      presort.push(obj)
    }
  })
  if (platform !== 'hardware' || unrestrictedSearch) {
    presort.sort((a, b) => {
      if ((a.matchRank && b.matchRank) && (a.matchRank != b.matchRank))
        return a.matchRank - b.matchRank
      if (a.meta !== "ok")
        return 1
      if (a.verdict != b.verdict)
        return window.verdictOrder.indexOf(a.verdict) - window.verdictOrder.indexOf(b.verdict)
      if (a.folder != b.folder)
        return paltformOrder.indexOf(a.folder) - paltformOrder.indexOf(b.folder)
      if (a.meta != b.meta)
        return metaOrder.indexOf(a.meta) - metaOrder.indexOf(b.meta)
      if (a.users != b.users)
        return b.users - a.users
      if (a.ratings != b.ratings)
        return b.ratings - a.ratings
      if (a.reviews != b.reviews)
        return b.reviews - a.reviews
      return 0
    })
    persistRandomWallets = false
  } else {
    if (!persistRandomWallets) {
      presort.sort(() => Math.random() - 0.5)
      persistRandomWallets = presort
    }
  }
  page = page ? page : 0
  const sortedWalletsForRender = persistRandomWallets?persistRandomWallets:presort
  renderBadgesToDiv(sortedWalletsForRender, document.getElementById("modularWalletPayload"), page, verdict, platform)
  resizeLabelBold()
  if (!noPush) { updateUrl() }
  lastVerdict = lastVerdict!==verdict?verdict:lastVerdict
  lastPlatform = lastPlatform!==platform?platform:lastPlatform

}

const paginationLimit = 12
function renderBadgesToDiv(wallets, anchor, page, verdict, platform) {
  page = page ? page : 0
  const maxPages = Math.ceil(wallets.length / paginationLimit)
  if (!anchor)
    return
  let badgesHtml = ``
  let pagination = document.createElement("div")
  let allowedTargets = processAllowedTargetArray(page, maxPages)
  let gapAdded = false
  for (let i = 0; i < maxPages; i++) {
    const clickTarget = document.createElement("div")
    clickTarget.classList.add("click-target")
    clickTarget.innerHTML = i + 1
    clickTarget.addEventListener("click", () => {
      updatePageinationUI(i)
    })
    if (i == page) { clickTarget.classList.add("selected") }
    if (allowedTargets.indexOf(i) < 0) { clickTarget.style.display = 'none' }
    if ((allowedTargets[i] + 1 !== allowedTargets[i + 1]) && !gapAdded) {
      clickTarget.classList.add("major-gap")
      gapAdded = true
    }
    clickTarget.setAttribute("data-index", i)
    pagination.append(clickTarget)
  }

  for (let i = 0; i < paginationLimit; i++) {
    const numb = (page * paginationLimit) + i
    const instance = wallets[numb]
    if (!instance) { break }
    badgesHtml += getBadge(instance, i)
  }
  var d = document.createElement("div")
  d.classList.add("page-section")
  let flexListEle = document.createElement("div")
  pagination.classList.add("pagination")
  flexListEle.classList.add("flexi-list")
  var g = document.createElement("div")
  g.setAttribute("id", "tableofwallets")
  const searchTerm = document.querySelector(".search-filtered-wallets").value
  let resultsText = ``
  if (searchTerm.length > 0 && badgesHtml.length === 0) { resultsText = `No wallets match for <b>"${searchTerm}"</b>.<br>You can search for wallets by name or description.` }
  if (searchTerm.length === 0) {
    if (badgesHtml.length === 0) {
      let lessWorse = document.querySelectorAll(".dropdown-verdict .option")[3]?document.querySelectorAll(".dropdown-verdict .option")[3]:false
      // INDEX 3 IS HIGHLY SPECIFIC TO THE HTML LAYOUT CURRENTLY USED
      // THIS IS A HACK WHICH CAN BE BROKEN EASILY BY AN HTML OR OTHER LAYOUT CHANGE
      lessWorse = lessWorse?`<br><a onclick="recreateDropdowns('${lessWorse.getAttribute("data")}', '${platform}');updateModularPayload(0, false)" class="primary btn">View highest-scoring ${platformTitleFormatting(platform)} wallets</a>`:''
      if (platformNotes[platform]) { resultsText = `${platformNotes[platform]}<br>Learn more by exploring <a href="/methodology/?tests-we-run/${platform}/">our Methodology</a>.${lessWorse}` }
    }
    else {
      if (verdict === 'all_tests_passed') { resultsText = `These ${wallets.length} wallets passed all tests according to <a href="/methodology/?tests-we-run/${platform}/">our Methodology</a>.` }
    }
  }
  resultsText = resultsText.length>0?`<div class="empty-results-info"><p class="inner">${resultsText}</p></div>`:``
  flexListEle.innerHTML = `${resultsText}${badgesHtml}`
  d.append(g)
  d.append(flexListEle)
  d.append(pagination)
  anchor.querySelectorAll(".page-section")[0].replaceWith(d)
  for (let i = 0; i < paginationLimit; i++) {
    const numb = (page * paginationLimit) + i
    const instance = wallets[numb]
    if (!instance) { break }
    processStyle(instance)
  }
}
function processAllowedTargetArray(page, maxPages) {
  let allowedTargets = [0, 1, 2, page - 2, page - 1, page, page + 1, page + 2, maxPages - 3, maxPages - 2, maxPages - 1]
  allowedTargets = [...new Set(allowedTargets)];
  allowedTargets = allowedTargets.filter(function (numb) { return numb > -1 });
  return allowedTargets
}
function updatePageinationUI(index) {
  index = index < 0 ? 0 : index
  window.pageIndex = index
  const allTargetEle = document.querySelectorAll(".click-target")
  for (const target of allTargetEle) { target.classList.remove("selected") }
  if (allTargetEle[index]) { allTargetEle[index].classList.add("selected") }
  updateUrl(true)
  updateModularPayload(index)
  window.scroll(0, document.querySelector("#homepageSearch").offsetTop)
}

async function processStyle(wallet) {
  if (!wallet.icon) { return '' }
  const walletId = wallet.folder + String(wallet.appId)
  let wIdforDOM = String(walletId).replace(/\./g, "_")
  let target = await document.querySelector(`.${wIdforDOM}`)
  if (!target) { return }
  let imgObj = new Image();
  imgObj.src = `/images/wIcons/${wallet.folder}/small/${wallet.icon}`;
  imgObj.onload = function () {
    if (wallet.folder !== 'bearer' && wallet.folder !== 'hardware') {
      let instanceCanvas = document.createElement("canvas")
      instanceCanvas.setAttribute("class", `${wIdforDOM}-instance-canvas instance-canvas`)
      instanceCanvas.height = imgObj.height * .25
      instanceCanvas.width = imgObj.width * .25
      document.body.append(instanceCanvas)
      let canvasEle = document.querySelector(`.${wIdforDOM}-instance-canvas`)
      canvasEle.getContext("2d").drawImage(imgObj, 0, 0);
      const canvasEleData = canvasEle.getContext("2d").getImageData(0, 0, canvasEle.width, canvasEle.height);
      if (canvasEleData.data[3] == 0 && canvasEleData.data[canvasEleData.data.length - 1] == 0) { target.setAttribute("data-icon-shape", "free") }
      else if (canvasEleData.data[3] < 255) { target.setAttribute("data-icon-shape", "round") }
    }

    let colorThief = new ColorThief();

    for (const rgb of colorThief.getPalette(imgObj, 3)) {
      if (rgb[0] < 70 && rgb[1] < 70 & rgb[2] < 70) { continue; }
      if (rgb[0] > 130 && rgb[1] > 130 & rgb[2] > 130) { continue; }
      if (target.style && target.style['background-image']) { break; }
      target.style['background-image'] = `linear-gradient(var(--white) -80%, rgb(${rgb[0]},${rgb[1]},${rgb[2]}) 600%)`
      let colour = `rgba(${rgb[0]},${rgb[1]},${rgb[2]}, 0.2)`;
      target.setAttribute("data-colour", colour);
    }
  }
}

function getBadge(wallet, numbInPage) {
  const walletId = wallet.folder + String(wallet.appId)
  let wIdforDOM = String(walletId).replace(/\./g, "_")
  let faCollection = getIcon(wallet.folder)
  const delay = numbInPage > 25 ? 2000 : numbInPage * 80
  // USER WILL LIKELY NEVER BROWSE AS MUCH AS 1% OF THE WALLETS
  // THEREFORE MOVING PARTS OF LOGIC TO ONLY BE CALLED WHEN
  // USER WANTS TO SEE MORE ABOUT A WALLET
  let passed = ``
  let failed = ``
  for (let i = 0; i < wallet.score.numerator; i++) { passed += `<i class="pass"></i>` }
  for (let i = 0; i < (wallet.score.denominator - wallet.score.numerator); i++) { failed += `<i class="fail"></i>` }
  return `
  <a id="card_${walletId}" class="AppDisplayCard item ${wallet.folder} ${wallet.meta} ${wIdforDOM}" href="${wallet.url}" style="animation-delay:${delay}ms;">
    <div class="tile-head">
      <img src="${wallet.icon ? `/images/wIcons/${wallet.folder}/small/${wallet.icon}` : '/images/noimg.svg'}" class="app_logo" alt="Wallet Logo">
      <h3>${wallet.altTitle || wallet.title}</h3>
      <span class="platform tile-view-only"><i class="${faCollection}"></i><span> ${wallet.category}</span></span>
    </div>
    <div class="wallet-details">
      <div class="stamps">
      ${wallet.meta !== "outdated" ? `<span data-text="${window.verdicts[wallet.verdict].short}" class="stamp stamp-${wallet.verdict}" alt=""></span>` : ""}
      ${wallet.meta && wallet.meta !== "ok" ? `<span data-text="${window.verdicts[wallet.meta].short}" class="stamp stamp-${wallet.meta}" alt=""></span>` : ""}
      </div>
      <div class="score" data-numerator="${wallet.score.numerator}" data-denominator="${wallet.score.denominator}">
        <span>Passed ${wallet.score.numerator!==wallet.score.denominator?wallet.score.numerator:'all'} ${wallet.score.numerator!==wallet.score.denominator?'of':''} ${wallet.score.denominator} tests</span>
        <div>${passed}${failed}</div>
      </div>
    </div>
  </a>`
}

function filterWalletsByName() {
  const searchTerm = document.querySelector(".search-filtered-wallets").value.trim().toUpperCase()
  if (searchTerm.length < 1) { window.filteredWallets = window.wallets }
  else {
    window.filteredWallets = []
    const searchTermWords = searchTerm.split(" ")
    
    // const lexicon = ['ALL PASSED', 'ALL TESTS']
    // TO BE USED FOR CASE MATCHING VERDICTS LIKE REPRODUCIBLE, DIY WHEN USER SEARCHES FOR 'ALL TESTS PASSED' ETC.
    // NOT IMPLEMENTED YET

    for (const wallet of window.wallets) {
      let walletAsStr = ''
      for (const [key, value] of Object.entries(wallet)) {
        walletAsStr += Array.isArray(value) ? JSON.stringify(value) : value
      }
      walletAsStr = String(walletAsStr).toUpperCase()
      if (walletAsStr.indexOf(searchTerm.replace(/ /g, '')) >= 0) {
        wallet.matchRank = 0
        window.filteredWallets.push(wallet)
        continue
      }
      else if (walletAsStr.indexOf(searchTerm.replace(/wallet/g, '')) >= 0) {
        wallet.matchRank = 1
        window.filteredWallets.push(wallet)
        continue
      }
      else {
        for (const word of searchTermWords) {
          if (walletAsStr.indexOf(word) >= 0) {
            wallet.matchRank = walletAsStr.indexOf(word)
            window.filteredWallets.push(wallet)
            break
          }
        }
      }
    }
  }
  const verdict = document.querySelector(".dropdown-verdict > .selected") ? document.querySelector(".dropdown-verdict > .selected").getAttribute("data") : "all_tests_passed"
  const platform = document.querySelector(".dropdown-platform > .selected") ? document.querySelector(".dropdown-platform > .selected").getAttribute("data") : "all"
  recreateDropdowns(verdict, platform)
  updateModularPayload(0, true)
}
function timeoutWalletFilterByName() {
  try { clearTimeout(window.timeoutWalletFilterByNameObj) } catch (e) { }
  window.timeoutWalletFilterByNameObj = setTimeout(() => { filterWalletsByName() }, 500)
}
document.querySelector(".search-filtered-wallets").addEventListener("input", timeoutWalletFilterByName)
document.querySelector(".search-filtered-wallets").value = ""